File: src/main/java/com/thealgorithms/maths/AbsoluteMin.java
Patch:
@@ -19,7 +19,7 @@ public static int getMinValue(int... numbers) {
 
         var absMinWrapper = new Object() { int value = numbers[0]; };
 
-        Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = number);
+        Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) <= Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = Math.min(absMinWrapper.value, number));
 
         return absMinWrapper.value;
     }

File: src/main/java/com/thealgorithms/maths/AbsoluteMax.java
Patch:
@@ -17,7 +17,7 @@ public static int getMaxValue(int... numbers) {
         }
         int absMax = numbers[0];
         for (int i = 1; i < numbers.length; i++) {
-            if (Math.abs(numbers[i]) > Math.abs(absMax)) {
+            if (Math.abs(numbers[i]) > Math.abs(absMax) || (Math.abs(numbers[i]) == Math.abs(absMax) && numbers[i] > absMax)) {
                 absMax = numbers[i];
             }
         }

File: src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java
Patch:
@@ -281,7 +281,7 @@ public void preOrder(Node localRoot) {
     }
 
     /**
-     * Prints rightChild - leftChild - root
+     * Prints leftChild - rightChild - root
      *
      * @param localRoot The local root of the binary tree
      */

File: src/main/java/com/thealgorithms/audiofilters/IIRFilter.java
Patch:
@@ -58,7 +58,7 @@ public void setCoeffs(double[] aCoeffs, double[] bCoeffs) throws IllegalArgument
             throw new IllegalArgumentException("bCoeffs must be of size " + order + ", got " + bCoeffs.length);
         }
 
-        for (int i = 0; i <= order; i++) {
+        for (int i = 0; i < order; i++) {
             coeffsA[i] = aCoeffs[i];
             coeffsB[i] = bCoeffs[i];
         }

File: src/main/java/com/thealgorithms/bitmanipulation/CountSetBits.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.bitmanipulation;
 
 public class CountSetBits {
 

File: src/main/java/com/thealgorithms/strings/CountChar.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 public final class CountChar {
     private CountChar() {

File: src/main/java/com/thealgorithms/strings/CountWords.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 /**
  * @author Marcus

File: src/main/java/com/thealgorithms/strings/ReturnSubsequence.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 /**
  * Class for generating all subsequences of a given string.

File: src/main/java/com/thealgorithms/strings/StringMatchFiniteAutomata.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 import java.util.Set;
 import java.util.TreeSet;

File: src/test/java/com/thealgorithms/bitmanipulation/CountSetBitsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.bitmanipulation;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 

File: src/test/java/com/thealgorithms/strings/CountCharTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 

File: src/test/java/com/thealgorithms/strings/CountWordsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 

File: src/test/java/com/thealgorithms/strings/ReturnSubsequenceTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 

File: src/test/java/com/thealgorithms/strings/StringMatchFiniteAutomataTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 

File: src/main/java/com/thealgorithms/conversions/UnitsConverter.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.NoSuchElementException;
 import java.util.Set;
 import org.apache.commons.lang3.tuple.Pair;
 
@@ -77,7 +78,7 @@ public double convert(final String inputUnit, final String outputUnit, final dou
             throw new IllegalArgumentException("inputUnit must be different from outputUnit.");
         }
         final var conversionKey = Pair.of(inputUnit, outputUnit);
-        return conversions.get(conversionKey).convert(value);
+        return conversions.computeIfAbsent(conversionKey, k -> { throw new NoSuchElementException("No converter for: " + k); }).convert(value);
     }
 
     public Set<String> availableUnits() {

File: src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java
Patch:
@@ -19,8 +19,7 @@ This method returns the majority element(s) in the given array of integers.
     public static List<Integer> majority(int[] nums) {
         HashMap<Integer, Integer> numToCount = new HashMap<>();
         for (final var num : nums) {
-            final var curCount = numToCount.getOrDefault(num, 0);
-            numToCount.put(num, curCount + 1);
+            numToCount.merge(num, 1, Integer::sum);
         }
         List<Integer> majorityElements = new ArrayList<>();
         for (final var entry : numToCount.entrySet()) {

File: src/test/java/com/thealgorithms/maths/FindKthNumberTest.java
Patch:
@@ -41,14 +41,14 @@ public void testFindKthMaxInvalidK() {
     @Test
     public void testFindKthMaxLargeArray() {
         int[] array = generateArray(1000);
-        int k = new Random().nextInt(array.length);
+        int k = new Random().nextInt(1, array.length);
         int result = FindKthNumber.findKthMax(array, k);
         Arrays.sort(array);
         assertEquals(array[array.length - k], result);
     }
 
     public static int[] generateArray(int capacity) {
-        int size = new Random().nextInt(capacity) + 1;
+        int size = new Random().nextInt(2, capacity);
         int[] array = new int[size];
 
         for (int i = 0; i < size; i++) {

File: src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java
Patch:
@@ -12,6 +12,7 @@ void testGetMaxValue() {
         assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));
         assertEquals(-22, AbsoluteMax.getMaxValue(-3, -10, -22));
         assertEquals(-888, AbsoluteMax.getMaxValue(-888));
+        assertEquals(-1, AbsoluteMax.getMaxValue(-1, -1, -1, -1, -1));
     }
 
     @Test

File: src/main/java/com/thealgorithms/datastructures/graphs/FordFulkerson.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.dynamicprogramming;
+package com.thealgorithms.datastructures.graphs;
 
 import java.util.LinkedList;
 import java.util.Queue;

File: src/main/java/com/thealgorithms/dynamicprogramming/ShortestCommonSupersequenceLength.java
Patch:
@@ -5,8 +5,8 @@
  * supersequence of two given strings. The shortest supersequence is the smallest string
  * that contains both given strings as subsequences.
  */
-final class ShortestCommonSuperSequenceLength {
-    private ShortestCommonSuperSequenceLength() {
+final class ShortestCommonSupersequenceLength {
+    private ShortestCommonSupersequenceLength() {
     }
 
     /**

File: src/main/java/com/thealgorithms/maths/EulersFunction.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.maths;
 
 /**
  * Utility class for computing

File: src/main/java/com/thealgorithms/maths/SieveOfEratosthenes.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.maths;
 
 import java.util.Arrays;
 

File: src/main/java/com/thealgorithms/strings/KMP.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 /**
  * Implementation of Knuth–Morris–Pratt algorithm Usage: see the main function

File: src/main/java/com/thealgorithms/strings/RabinKarp.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.strings;
 
 import java.util.Scanner;
 

File: src/test/java/com/thealgorithms/datastructures/graphs/FordFulkersonTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.dynamicprogramming;
+package com.thealgorithms.datastructures.graphs;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 

File: src/test/java/com/thealgorithms/dynamicprogramming/ShortestCommonSupersequenceLengthTest.java
Patch:
@@ -5,10 +5,10 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.CsvSource;
 
-public class ShortestCommonSuperSequenceLengthTest {
+public class ShortestCommonSupersequenceLengthTest {
     @ParameterizedTest
     @CsvSource({"AGGTAB, GXTXAYB, 9", "ABC, ABC, 3", "ABC, DEF, 6", "'', ABC, 3", "ABCD, AB, 4", "ABC, BCD, 4", "A, B, 2"})
-    void testShortestSuperSequence(String input1, String input2, int expected) {
-        assertEquals(expected, ShortestCommonSuperSequenceLength.shortestSuperSequence(input1, input2));
+    void testShortestSupersequence(String input1, String input2, int expected) {
+        assertEquals(expected, ShortestCommonSupersequenceLength.shortestSuperSequence(input1, input2));
     }
 }

File: src/test/java/com/thealgorithms/maths/EulersFunctionTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.maths;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;

File: src/test/java/com/thealgorithms/maths/SieveOfEratosthenesTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.maths;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;

File: src/main/java/com/thealgorithms/datastructures/graphs/BipartiteGraphDFS.java
Patch:
@@ -14,8 +14,8 @@
  *
  * Output : YES
  */
-public final class BipartiteGrapfDFS {
-    private BipartiteGrapfDFS() {
+public final class BipartiteGraphDFS {
+    private BipartiteGraphDFS() {
     }
 
     private static boolean bipartite(int v, ArrayList<ArrayList<Integer>> adj, int[] color, int node) {

File: src/main/java/com/thealgorithms/datastructures/lists/MergeKSortedLinkedList.java
Patch:
@@ -7,7 +7,7 @@
 /**
  * @author Arun Pandey (https://github.com/pandeyarun709)
  */
-public class MergeKSortedLinkedlist {
+public class MergeKSortedLinkedList {
 
     /**
      * This function merge K sorted LinkedList

File: src/main/java/com/thealgorithms/stacks/LargestRectangle.java
Patch:
@@ -11,7 +11,7 @@ public final class LargestRectangle {
     private LargestRectangle() {
     }
 
-    public static String largestRectanglehistogram(int[] heights) {
+    public static String largestRectangleHistogram(int[] heights) {
         int n = heights.length;
         int maxArea = 0;
         Stack<int[]> st = new Stack<>();
@@ -32,7 +32,7 @@ public static String largestRectanglehistogram(int[] heights) {
     }
 
     public static void main(String[] args) {
-        assert largestRectanglehistogram(new int[] {2, 1, 5, 6, 2, 3}).equals("10");
-        assert largestRectanglehistogram(new int[] {2, 4}).equals("4");
+        assert largestRectangleHistogram(new int[] {2, 1, 5, 6, 2, 3}).equals("10");
+        assert largestRectangleHistogram(new int[] {2, 4}).equals("4");
     }
 }

File: src/main/java/com/thealgorithms/strings/ReverseWordsInString.java
Patch:
@@ -13,7 +13,6 @@ private ReverseWordsInString() {
      * @param s the input string
      * @return A string created by reversing the order of the words in {@code s}
      */
-
     public static String reverseWordsInString(final String s) {
         var words = s.trim().split("\\s+");
         Collections.reverse(Arrays.asList(words));

File: src/main/java/com/thealgorithms/strings/Upper.java
Patch:
@@ -15,13 +15,13 @@ public static void main(String[] args) {
     }
 
     /**
-     * Converts all of the characters in this {@code String} to upper case
+     * Converts all the characters in this {@code String} to upper case
      *
      * @param s the string to convert
      * @return the {@code String}, converted to uppercase.
      */
     public static String toUpperCase(String s) {
-        if (s == null || "".equals(s)) {
+        if (s == null || s.isEmpty()) {
             return s;
         }
         char[] values = s.toCharArray();

File: src/main/java/com/thealgorithms/strings/ReverseStringRecursive.java
Patch:
@@ -3,10 +3,10 @@
 /**
  * Reverse String using Recursion
  */
-
 public final class ReverseStringRecursive {
     private ReverseStringRecursive() {
     }
+
     /**
      * @param str string to be reversed
      * @return reversed string

File: src/main/java/com/thealgorithms/others/GaussLegendre.java
Patch:
@@ -6,8 +6,8 @@
  *
  * @author AKS1996
  */
-public final class GuassLegendre {
-    private GuassLegendre() {
+public final class GaussLegendre {
+    private GaussLegendre() {
     }
 
     public static void main(String[] args) {

File: src/main/java/com/thealgorithms/maths/TwinPrime.java
Patch:
@@ -16,7 +16,7 @@ private TwinPrime() {
     /**
      * This method returns twin prime of the integer value passed as argument
      *
-     * @param input_number Integer value of which twin prime is to be found
+     * @param inputNumber Integer value of which twin prime is to be found
      * @return (number + 2) if number and (number + 2) are prime, -1 otherwise
      */
     static int getTwinPrime(int inputNumber) {

File: src/main/java/com/thealgorithms/strings/StringCompression.java
Patch:
@@ -10,7 +10,7 @@ private StringCompression() {
     /**
      * Returns the compressed or encoded string
      *
-     * @param ch character array that contains the group of characters to be encoded
+     * @param input character array that contains the group of characters to be encoded
      * @return the compressed character array as string
      */
     public static String compress(String input) {

File: src/test/java/com/thealgorithms/strings/LongestNonRepetitiveSubstringTest.java
Patch:
@@ -3,13 +3,13 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-public class LongestNonRepeativeSubstringTest {
+public class LongestNonRepetitiveSubstringTest {
 
     @Test
     public void palindrome() {
         String input1 = "HelloWorld";
         String input2 = "javaIsAProgrammingLanguage";
-        Assertions.assertEquals(LongestNonRepeativeSubstring.lengthOfLongestSubstring(input1), 5);
-        Assertions.assertEquals(LongestNonRepeativeSubstring.lengthOfLongestSubstring(input2), 9);
+        Assertions.assertEquals(LongestNonRepetitiveSubstring.lengthOfLongestSubstring(input1), 5);
+        Assertions.assertEquals(LongestNonRepetitiveSubstring.lengthOfLongestSubstring(input2), 9);
     }
 }

File: src/main/java/com/thealgorithms/backtracking/ParenthesesGenerator.java
Patch:
@@ -19,7 +19,7 @@ private ParenthesesGenerator() {
      */
     public static List<String> generateParentheses(final int n) {
         if (n < 0) {
-            throw new IllegalArgumentException("The number of pairs of parentheses cannot be nagative");
+            throw new IllegalArgumentException("The number of pairs of parentheses cannot be negative");
         }
         List<String> result = new ArrayList<>();
         generateParenthesesHelper(result, "", 0, 0, n);

File: src/main/java/com/thealgorithms/datastructures/trees/BSTRecursive.java
Patch:
@@ -95,7 +95,7 @@ private Node insert(Node node, int data) {
     }
 
     /**
-     * Serach recursively if the given value is present in BST or not.
+     * Search recursively if the given value is present in BST or not.
      *
      * @param node the current node to check
      * @param data the value to be checked

File: src/main/java/com/thealgorithms/misc/PalindromePrime.java
Patch:
@@ -6,7 +6,7 @@ public final class PalindromePrime {
     private PalindromePrime() {
     }
 
-    public static void main(String[] args) { // Main funtion
+    public static void main(String[] args) { // Main function
         Scanner in = new Scanner(System.in);
         System.out.println("Enter the quantity of First Palindromic Primes you want");
         int n = in.nextInt(); // Input of how many first palindromic prime we want

File: src/main/java/com/thealgorithms/searches/HowManyTimesRotated.java
Patch:
@@ -17,7 +17,7 @@
     from its initial sorted position.
     Eg. For [2,5,6,8,11,12,15,18], 1 rotation gives [5,6,8,11,12,15,18,2], 2 rotations
    [6,8,11,12,15,18,2,5] and so on. Finding the minimum element will take O(N) time but, we can  use
-   Binary Search to find the mimimum element, we can reduce the complexity to O(log N). If we look
+   Binary Search to find the minimum element, we can reduce the complexity to O(log N). If we look
    at the rotated array, to identify the minimum element (say a[i]), we observe that
    a[i-1]>a[i]<a[i+1].
 

File: src/test/java/com/thealgorithms/maths/FFTTest.java
Patch:
@@ -40,7 +40,7 @@ void addFalseTest() {
         assertNotEquals(2.0, add);
     }
 
-    // Testing the function substract, assertEqual test
+    // Testing the function subtract, assertEqual test
     @Test
     void subtractTest() {
         FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);

File: src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java
Patch:
@@ -53,7 +53,7 @@ public void testSearchRoot() {
 
         // check value
         Optional<Node<String>> value = bfs.search(root, expectedValue);
-        assertEquals(expectedValue, value.orElse(new Node<>("")).getValue());
+        assertEquals(expectedValue, value.orElseGet(() -> new Node<>("")).getValue());
 
         // check path
         assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
@@ -65,7 +65,7 @@ public void testSearchF() {
         List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
 
         // check value
-        Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElse(new Node<>(null)));
+        Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElseGet(() -> new Node<>(null)));
         assertEquals(expectedValue, value.get().getValue());
 
         // check path

File: src/test/java/com/thealgorithms/searches/DepthFirstSearchTest.java
Patch:
@@ -54,7 +54,7 @@ public void testSearchRoot() {
 
         // check value
         Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);
-        assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());
+        assertEquals(expectedValue, value.orElseGet(() -> new Node<>(null)).getValue());
 
         // check path
         assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
@@ -67,7 +67,7 @@ public void testSearch4() {
 
         // check value
         Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);
-        assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());
+        assertEquals(expectedValue, value.orElseGet(() -> new Node<>(null)).getValue());
 
         // check path
         assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());

File: src/main/java/com/thealgorithms/sorts/SelectionSort.java
Patch:
@@ -1,7 +1,5 @@
 package com.thealgorithms.sorts;
 
-import static com.thealgorithms.sorts.SortUtils.swap;
-
 public class SelectionSort implements SortAlgorithm {
 
     /**
@@ -22,7 +20,7 @@ public <T extends Comparable<T>> T[] sort(T[] arr) {
                 }
             }
             if (minIndex != i) {
-                swap(arr, i, minIndex);
+                SortUtils.swap(arr, i, minIndex);
             }
         }
         return arr;

File: src/main/java/com/thealgorithms/sorts/SimpleSort.java
Patch:
@@ -9,9 +9,7 @@ public <T extends Comparable<T>> T[] sort(T[] array) {
         for (int i = 0; i < length; i++) {
             for (int j = i + 1; j < length; j++) {
                 if (SortUtils.less(array[j], array[i])) {
-                    T element = array[j];
-                    array[j] = array[i];
-                    array[i] = element;
+                    SortUtils.swap(array, i, j);
                 }
             }
         }

File: src/main/java/com/thealgorithms/sorts/SlowSort.java
Patch:
@@ -20,9 +20,7 @@ private <T extends Comparable<T>> void sort(T[] array, int i, int j) {
         sort(array, i, m);
         sort(array, m + 1, j);
         if (SortUtils.less(array[j], array[m])) {
-            T temp = array[j];
-            array[j] = array[m];
-            array[m] = temp;
+            SortUtils.swap(array, j, m);
         }
         sort(array, i, j - 1);
     }

File: src/main/java/com/thealgorithms/sorts/SwapSort.java
Patch:
@@ -18,9 +18,7 @@ public <T extends Comparable<T>> T[] sort(T[] array) {
             int amountSmallerElements = this.getSmallerElementCount(array, index);
 
             if (amountSmallerElements > 0 && index != amountSmallerElements) {
-                T element = array[index];
-                array[index] = array[amountSmallerElements];
-                array[amountSmallerElements] = element;
+                SortUtils.swap(array, index, amountSmallerElements);
             } else {
                 index++;
             }

File: src/main/java/com/thealgorithms/datastructures/graphs/AStar.java
Patch:
@@ -9,8 +9,8 @@
 import java.util.List;
 import java.util.PriorityQueue;
 
-public final class A_Star {
-    private A_Star() {
+public final class AStar {
+    private AStar() {
     }
 
     private static class Graph {

File: src/main/java/com/thealgorithms/datastructures/graphs/DIJSKSTRAS_ALGORITHM.java
Patch:
@@ -4,7 +4,7 @@
  */
 package com.thealgorithms.datastructures.graphs;
 
-class dijkstras {
+class Dijkstras {
 
     int k = 9;
 
@@ -67,7 +67,7 @@ public static void main(String[] args) {
             {8, 11, 0, 0, 0, 0, 1, 0, 7},
             {0, 0, 2, 0, 0, 0, 6, 7, 0},
         };
-        dijkstras t = new dijkstras();
+        Dijkstras t = new Dijkstras();
         t.dijkstra(graph, 0);
     } // main
 } // djikstras

File: src/main/java/com/thealgorithms/datastructures/lists/MergeKSortedLinkedlist.java
Patch:
@@ -7,7 +7,7 @@
 /**
  * @author Arun Pandey (https://github.com/pandeyarun709)
  */
-public class Merge_K_SortedLinkedlist {
+public class MergeKSortedLinkedlist {
 
     /**
      * This function merge K sorted LinkedList

File: src/main/java/com/thealgorithms/misc/MatrixTranspose.java
Patch:
@@ -18,8 +18,8 @@
  * @version 11.0.9
  * @since 2014-03-31
  */
-public final class matrixTranspose {
-    private matrixTranspose() {
+public final class MatrixTranspose {
+    private MatrixTranspose() {
     }
 
     public static void main(String[] args) {

File: src/main/java/com/thealgorithms/others/CountSetBits.java
Patch:
@@ -1,6 +1,6 @@
 package com.thealgorithms.others;
 
-public class countSetBits {
+public class CountSetBits {
 
     /**
      * The below algorithm is called as Brian Kernighan's algorithm
@@ -40,7 +40,7 @@ public class countSetBits {
      * @param num takes Long number whose number of set bit is to be found
      * @return the count of set bits in the binary equivalent
     */
-    public long countsetBits(long num) {
+    public long countSetBits(long num) {
         long cnt = 0;
         while (num > 0) {
             cnt++;

File: src/main/java/com/thealgorithms/others/RotateMatrixBy90Degrees.java
Patch:
@@ -6,8 +6,8 @@
  */
 import java.util.Scanner;
 
-final class Rotate_by_90_degrees {
-    private Rotate_by_90_degrees() {
+final class RotateMatrixBy90Degrees {
+    private RotateMatrixBy90Degrees() {
     }
 
     public static void main(String[] args) {

File: src/main/java/com/thealgorithms/searches/SortOrderAgnosticBinarySearch.java
Patch:
@@ -1,6 +1,6 @@
 package com.thealgorithms.searches;
-public final class sortOrderAgnosticBinarySearch {
-    private sortOrderAgnosticBinarySearch() {
+public final class SortOrderAgnosticBinarySearch {
+    private SortOrderAgnosticBinarySearch() {
     }
     public static int find(int[] arr, int key) {
         int start = 0;

File: src/main/java/com/thealgorithms/strings/LongestNonRepeativeSubstring.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.HashMap;
 
-final class longestNonRepeativeSubstring {
-    private longestNonRepeativeSubstring() {
+final class LongestNonRepeativeSubstring {
+    private LongestNonRepeativeSubstring() {
     }
 
     public static int lengthOfLongestSubstring(String s) {

File: src/main/java/com/thealgorithms/strings/zigZagPattern/ZigZagPattern.java
Patch:
@@ -1,7 +1,7 @@
 package com.thealgorithms.strings.zigZagPattern;
 
-final class zigZagPattern {
-    private zigZagPattern() {
+final class ZigZagPattern {
+    private ZigZagPattern() {
     }
 
     public static String encode(String s, int numRows) {

File: src/test/java/com/thealgorithms/dynamicprogramming/ClimbStairsTest.java
Patch:
@@ -4,7 +4,7 @@
 
 import org.junit.jupiter.api.Test;
 
-public class climbStairsTest {
+public class ClimbStairsTest {
 
     @Test
     void climbStairsTestForTwo() {

File: src/test/java/com/thealgorithms/searches/SortOrderAgnosticBinarySearchTest.java
Patch:
@@ -4,13 +4,13 @@
 
 import org.junit.jupiter.api.Test;
 
-public class sortOrderAgnosticBinarySearchTest {
+public class SortOrderAgnosticBinarySearchTest {
 
     @Test
     public void testAscending() {
         int[] arr = {1, 2, 3, 4, 5}; // for ascending order.
         int target = 2;
-        int ans = sortOrderAgnosticBinarySearch.find(arr, target);
+        int ans = SortOrderAgnosticBinarySearch.find(arr, target);
         int excepted = 1;
         assertEquals(excepted, ans);
     }
@@ -19,7 +19,7 @@ public void testAscending() {
     public void testDescending() {
         int[] arr = {5, 4, 3, 2, 1}; // for descending order.
         int target = 2;
-        int ans = sortOrderAgnosticBinarySearch.find(arr, target);
+        int ans = SortOrderAgnosticBinarySearch.find(arr, target);
         int excepted = 3;
         assertEquals(excepted, ans);
     }

File: src/test/java/com/thealgorithms/strings/LongestNonRepeativeSubstringTest.java
Patch:
@@ -3,13 +3,13 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-public class longestNonRepeativeSubstringTest {
+public class LongestNonRepeativeSubstringTest {
 
     @Test
     public void palindrome() {
         String input1 = "HelloWorld";
         String input2 = "javaIsAProgrammingLanguage";
-        Assertions.assertEquals(longestNonRepeativeSubstring.lengthOfLongestSubstring(input1), 5);
-        Assertions.assertEquals(longestNonRepeativeSubstring.lengthOfLongestSubstring(input2), 9);
+        Assertions.assertEquals(LongestNonRepeativeSubstring.lengthOfLongestSubstring(input1), 5);
+        Assertions.assertEquals(LongestNonRepeativeSubstring.lengthOfLongestSubstring(input2), 9);
     }
 }

File: src/test/java/com/thealgorithms/strings/zigZagPattern/ZigZagPatternTest.java
Patch:
@@ -3,13 +3,13 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-public class zigZagPatternTest {
+public class ZigZagPatternTest {
 
     @Test
     public void palindrome() {
         String input1 = "HelloWorldFromJava";
         String input2 = "javaIsAProgrammingLanguage";
-        Assertions.assertEquals(zigZagPattern.encode(input1, 4), "HooeWrrmalolFJvlda");
-        Assertions.assertEquals(zigZagPattern.encode(input2, 4), "jAaLgasPrmgaaevIrgmnnuaoig");
+        Assertions.assertEquals(ZigZagPattern.encode(input1, 4), "HooeWrrmalolFJvlda");
+        Assertions.assertEquals(ZigZagPattern.encode(input2, 4), "jAaLgasPrmgaaevIrgmnnuaoig");
     }
 }

File: src/main/java/com/thealgorithms/datastructures/graphs/FloydWarshall.java
Patch:
@@ -15,10 +15,10 @@ public FloydWarshall(int numberofvertices) {
         this.numberofvertices = numberofvertices;
     }
 
-    public void floydwarshall(int[][] AdjacencyMatrix) { // calculates all the distances from source to destination vertex
+    public void floydwarshall(int[][] adjacencyMatrix) { // calculates all the distances from source to destination vertex
         for (int source = 1; source <= numberofvertices; source++) {
             for (int destination = 1; destination <= numberofvertices; destination++) {
-                distanceMatrix[source][destination] = AdjacencyMatrix[source][destination];
+                distanceMatrix[source][destination] = adjacencyMatrix[source][destination];
             }
         }
         for (int intermediate = 1; intermediate <= numberofvertices; intermediate++) {

File: src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArray.java
Patch:
@@ -19,8 +19,8 @@ public GenericHashMapUsingArray() {
     // 75, then adding 76th item it will double the size, copy all elements
     // & then add 76th item.
 
-    private void initBuckets(int N) {
-        buckets = new LinkedList[N];
+    private void initBuckets(int n) {
+        buckets = new LinkedList[n];
         for (int i = 0; i < buckets.length; i++) {
             buckets[i] = new LinkedList<>();
         }

File: src/main/java/com/thealgorithms/datastructures/lists/Merge_K_SortedLinkedlist.java
Patch:
@@ -13,15 +13,15 @@ public class Merge_K_SortedLinkedlist {
      * This function merge K sorted LinkedList
      *
      * @param a array of LinkedList
-     * @param N size of array
+     * @param n size of array
      * @return node
      */
-    Node mergeKList(Node[] a, int N) {
+    Node mergeKList(Node[] a, int n) {
         // Min Heap
         PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));
 
         // adding head of all linkedList in min heap
-        min.addAll(Arrays.asList(a).subList(0, N));
+        min.addAll(Arrays.asList(a).subList(0, n));
 
         // Make new head among smallest heads in K linkedList
         Node head = min.poll();

File: src/main/java/com/thealgorithms/dynamicprogramming/KadaneAlgorithm.java
Patch:
@@ -10,7 +10,7 @@ public final class KadaneAlgorithm {
     private KadaneAlgorithm() {
     }
 
-    public static boolean maxSum(int[] a, int predicted_answer) {
+    public static boolean maxSum(int[] a, int predictedAnswer) {
         int sum = a[0];
         int runningSum = 0;
         for (int k : a) {
@@ -22,7 +22,7 @@ public static boolean maxSum(int[] a, int predicted_answer) {
             // if running sum is negative then it is initialized to zero
         }
         // for-each loop is used to iterate over the array and find the maximum subarray sum
-        return sum == predicted_answer;
+        return sum == predictedAnswer;
         // It returns true if sum and predicted answer matches
         // The predicted answer is the answer itself. So it always return true
     }

File: src/main/java/com/thealgorithms/dynamicprogramming/NewManShanksPrime.java
Patch:
@@ -12,7 +12,7 @@ public final class NewManShanksPrime {
     private NewManShanksPrime() {
     }
 
-    public static boolean nthManShanksPrime(int n, int expected_answer) {
+    public static boolean nthManShanksPrime(int n, int expectedAnswer) {
         int[] a = new int[n + 1];
         // array of n+1 size is initialized
         a[0] = 1;
@@ -22,7 +22,7 @@ public static boolean nthManShanksPrime(int n, int expected_answer) {
             a[i] = 2 * a[i - 1] + a[i - 2];
         }
         // The loop is continued till n
-        return a[n] == expected_answer;
+        return a[n] == expectedAnswer;
         // returns true if calculated answer matches with expected answer
     }
 }

File: src/main/java/com/thealgorithms/others/PasswordGen.java
Patch:
@@ -15,7 +15,7 @@ final class PasswordGen {
     private PasswordGen() {
     }
 
-    static String generatePassword(int min_length, int max_length) {
+    static String generatePassword(int minLength, int maxLength) {
         Random random = new Random();
 
         String upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
@@ -35,7 +35,7 @@ static String generatePassword(int min_length, int max_length) {
         StringBuilder password = new StringBuilder();
 
         // Note that size of the password is also random
-        for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {
+        for (int i = random.nextInt(maxLength - minLength) + minLength; i > 0; --i) {
             password.append(letters.get(random.nextInt(letters.size())));
         }
 

File: src/main/java/com/thealgorithms/sorts/BitonicSort.java
Patch:
@@ -55,8 +55,8 @@ void bitonicSort(int[] a, int low, int cnt, int dir) {
 
     /*Caller of bitonicSort for sorting the entire array
   of length N in ASCENDING order */
-    void sort(int[] a, int N, int up) {
-        bitonicSort(a, 0, N, up);
+    void sort(int[] a, int n, int up) {
+        bitonicSort(a, 0, n, up);
     }
 
     /* A utility function to print array of size n */

File: src/main/java/com/thealgorithms/ciphers/AffineCipher.java
Patch:
@@ -27,7 +27,7 @@ static String encryptMessage(char[] msg) {
 
     static String decryptCipher(String cipher) {
         String msg = "";
-        int a_inv = 0;
+        int aInv = 0;
         int flag = 0;
 
         // Find a^-1 (the multiplicative inverse of a
@@ -38,15 +38,15 @@ static String decryptCipher(String cipher) {
             // Check if (a*i)%26 == 1,
             // then i will be the multiplicative inverse of a
             if (flag == 1) {
-                a_inv = i;
+                aInv = i;
             }
         }
         for (int i = 0; i < cipher.length(); i++) {
             /*Applying decryption formula a^-1 ( x - b ) mod m
             {here x is cipher[i] and m is 26} and added 'A'
             to bring it in range of ASCII alphabet[ 65-90 | A-Z ] */
             if (cipher.charAt(i) != ' ') {
-                msg = msg + (char) (((a_inv * ((cipher.charAt(i) + 'A' - b)) % 26)) + 'A');
+                msg = msg + (char) (((aInv * ((cipher.charAt(i) + 'A' - b)) % 26)) + 'A');
             } else { // else simply append space character
                 msg += cipher.charAt(i);
             }

File: src/main/java/com/thealgorithms/datastructures/graphs/PrimMST.java
Patch:
@@ -15,16 +15,16 @@ class PrimMST {
     int minKey(int[] key, Boolean[] mstSet) {
         // Initialize min value
         int min = Integer.MAX_VALUE;
-        int min_index = -1;
+        int minIndex = -1;
 
         for (int v = 0; v < V; v++) {
             if (!mstSet[v] && key[v] < min) {
                 min = key[v];
-                min_index = v;
+                minIndex = v;
             }
         }
 
-        return min_index;
+        return minIndex;
     }
 
     // A utility function to print the constructed MST stored in

File: src/main/java/com/thealgorithms/datastructures/trees/SegmentTree.java
Patch:
@@ -10,9 +10,9 @@ public class SegmentTree {
     public SegmentTree(int n, int[] arr) {
         this.n = n;
         int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));
-        int seg_size = 2 * (int) Math.pow(2, x) - 1;
+        int segSize = 2 * (int) Math.pow(2, x) - 1;
 
-        this.seg_t = new int[seg_size];
+        this.seg_t = new int[segSize];
         this.arr = arr;
         this.n = n;
         constructTree(arr, 0, n - 1, 0);

File: src/main/java/com/thealgorithms/dynamicprogramming/BruteForceKnapsack.java
Patch:
@@ -32,8 +32,8 @@ static int knapSack(int W, int[] wt, int[] val, int n) {
     public static void main(String[] args) {
         int[] val = new int[] {60, 100, 120};
         int[] wt = new int[] {10, 20, 30};
-        int W = 50;
+        int w = 50;
         int n = val.length;
-        System.out.println(knapSack(W, wt, val, n));
+        System.out.println(knapSack(w, wt, val, n));
     }
 }

File: src/main/java/com/thealgorithms/dynamicprogramming/CoinChange.java
Patch:
@@ -58,9 +58,9 @@ public static int minimumCoins(int[] coins, int amount) {
         for (int i = 1; i <= amount; i++) {
             for (int coin : coins) {
                 if (coin <= i) {
-                    int sub_res = minimumCoins[i - coin];
-                    if (sub_res != Integer.MAX_VALUE && sub_res + 1 < minimumCoins[i]) {
-                        minimumCoins[i] = sub_res + 1;
+                    int subRes = minimumCoins[i - coin];
+                    if (subRes != Integer.MAX_VALUE && subRes + 1 < minimumCoins[i]) {
+                        minimumCoins[i] = subRes + 1;
                     }
                 }
             }

File: src/main/java/com/thealgorithms/maths/CrossCorrelation.java
Patch:
@@ -22,7 +22,7 @@ private CrossCorrelation() {
     public static double[] crossCorrelation(double[] x, double[] y) {
         // The result signal's length is the sum of the input signals' lengths minus 1
         double[] result = new double[x.length + y.length - 1];
-        int N = result.length;
+        int n = result.length;
 
         /*
         To find the cross-correlation between 2 discrete signals x & y, we start by "placing" the second signal
@@ -60,13 +60,13 @@ and for every new position (i++) of the result signal, we shift y signal one pos
 
 
 
-        To find the result[i] value for each i:0->N-1, the positions of x-signal in which the 2 signals meet
+        To find the result[i] value for each i:0->n-1, the positions of x-signal in which the 2 signals meet
         are calculated: kMin<=k<=kMax.
         The variable 'yStart' indicates the starting index of y in each sum calculation.
         The variable 'count' increases the index of y-signal by 1, to move to the next value.
          */
         int yStart = y.length;
-        for (int i = 0; i < N; i++) {
+        for (int i = 0; i < n; i++) {
             result[i] = 0;
 
             int kMin = Math.max(i - (y.length - 1), 0);

File: src/main/java/com/thealgorithms/searches/OrderAgnosticBinarySearch.java
Patch:
@@ -18,7 +18,7 @@ private OrderAgnosticBinarySearch() {
     static int binSearchAlgo(int[] arr, int start, int end, int target) {
 
         // Checking whether the given array is ascending order
-        boolean AscOrd = arr[start] < arr[end];
+        boolean ascOrd = arr[start] < arr[end];
 
         while (start <= end) {
             int middle = start + (end - start) / 2;
@@ -27,7 +27,7 @@ static int binSearchAlgo(int[] arr, int start, int end, int target) {
             if (arr[middle] == target) return middle; // returns the index of the middle element
 
             // Ascending order
-            if (AscOrd) {
+            if (ascOrd) {
                 if (arr[middle] < target)
                     start = middle + 1;
                 else

File: src/main/java/com/thealgorithms/sorts/SwapSort.java
Patch:
@@ -11,10 +11,10 @@ public class SwapSort implements SortAlgorithm {
 
     @Override
     public <T extends Comparable<T>> T[] sort(T[] array) {
-        int LENGTH = array.length;
+        int len = array.length;
         int index = 0;
 
-        while (index < LENGTH - 1) {
+        while (index < len - 1) {
             int amountSmallerElements = this.getSmallerElementCount(array, index);
 
             if (amountSmallerElements > 0 && index != amountSmallerElements) {

File: src/main/java/com/thealgorithms/strings/MyAtoi.java
Patch:
@@ -8,13 +8,13 @@ private MyAtoi() {
     }
     public static int myAtoi(String s) {
         s = s.trim();
-        char[] char_1 = s.toCharArray();
+        char[] char1 = s.toCharArray();
         String number = "";
         boolean negative = false;
         boolean zero = false;
         boolean isDigit = false;
 
-        for (char ch : char_1) {
+        for (char ch : char1) {
             if (Character.isDigit(ch)) {
                 if (number.length() > 1 && !isDigit) {
                     number = "0";

File: src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Main.java
Patch:
@@ -44,6 +44,9 @@ public static void main(String[] args) {
                 In.close();
                 return;
             }
+            default: {
+                throw new IllegalArgumentException("Unexpected value: " + choice);
+            }
             }
         }
     }

File: src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MainCuckooHashing.java
Patch:
@@ -62,6 +62,9 @@ public static void main(String[] args) {
                 h.reHashTableIncreasesTableSize();
                 break;
             }
+            default: {
+                throw new IllegalArgumentException("Unexpected value: " + choice);
+            }
             }
         }
     }

File: src/main/java/com/thealgorithms/misc/Sort012D.java
Patch:
@@ -51,6 +51,9 @@ public static void sort012(int[] a) {
                 h--;
                 break;
             }
+            default: {
+                throw new IllegalArgumentException("Unexpected value: " + a[mid]);
+            }
             }
         }
         System.out.println("the Sorted array is ");

File: src/main/java/com/thealgorithms/sorts/DNFSort.java
Patch:
@@ -31,6 +31,8 @@ static void sort012(int[] a, int arr_size) {
                 high--;
                 break;
             }
+            default:
+                throw new IllegalArgumentException("Unexpected value: " + a[mid]);
             }
         }
     }

File: src/main/java/com/thealgorithms/stacks/PostfixToInfix.java
Patch:
@@ -28,9 +28,9 @@ public static boolean isOperator(char token) {
         case '*':
         case '^':
             return true;
+        default:
+            return false;
         }
-
-        return false;
     }
 
     public static boolean isValidPostfixExpression(String postfix) {

File: src/main/java/com/thealgorithms/strings/ValidParentheses.java
Patch:
@@ -26,6 +26,8 @@ public static boolean isValid(String s) {
             case ']':
                 if (head == 0 || stack[--head] != '[') return false;
                 break;
+            default:
+                throw new IllegalArgumentException("Unexpected character: " + c);
             }
         }
         return head == 0;

File: src/test/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinderTest.java
Patch:
@@ -13,11 +13,11 @@ class NonRepeatingNumberFinderTest {
 
     @Test
     void testNonRepeatingNumberFinder() {
-        int arr[] = {1, 2, 1, 2, 6};
+        int[] arr = {1, 2, 1, 2, 6};
         assertEquals(6, NonRepeatingNumberFinder.findNonRepeatingNumber(arr));
-        int arr1[] = {1, 2, 1, 2};
+        int[] arr1 = {1, 2, 1, 2};
         assertEquals(0, NonRepeatingNumberFinder.findNonRepeatingNumber(arr1));
-        int arr2[] = {12};
+        int[] arr2 = {12};
         assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));
     }
 }

File: src/main/java/com/thealgorithms/backtracking/MColoring.java
Patch:
@@ -1,6 +1,5 @@
 package com.thealgorithms.backtracking;
 
-import java.io.*;
 import java.util.*;
 
 /**

File: src/main/java/com/thealgorithms/datastructures/dynamicarray/DynamicArray.java
Patch:
@@ -145,7 +145,7 @@ public String toString() {
      * @return Iterator a Dynamic Array Iterator
      */
     @Override
-    public Iterator iterator() {
+    public Iterator<E> iterator() {
         return new DynamicArrayIterator();
     }
 

File: src/main/java/com/thealgorithms/datastructures/lists/CircleLinkedList.java
Patch:
@@ -53,7 +53,7 @@ public void append(E value) {
 
     // utility function for traversing the list
     public String toString() {
-        Node p = head.next;
+        Node<E> p = head.next;
         String s = "[ ";
         while (p != head) {
             s += p.value;
@@ -91,7 +91,7 @@ public E remove(int pos) {
     }
 
     public static void main(String[] args) {
-        CircleLinkedList cl = new CircleLinkedList<String>();
+        CircleLinkedList<Integer> cl = new CircleLinkedList<>();
         cl.append(12);
         System.out.println(cl);
         cl.append(23);

File: src/main/java/com/thealgorithms/datastructures/lists/CursorLinkedList.java
Patch:
@@ -134,7 +134,7 @@ public void remove(T element) {
     }
 
     private void free(int index) {
-        Node os_node = cursorSpace[os];
+        Node<T> os_node = cursorSpace[os];
         int os_next = os_node.next;
         cursorSpace[os].next = index;
         cursorSpace[index].element = null;

File: src/main/java/com/thealgorithms/misc/ThreeSumProblem.java
Patch:
@@ -75,7 +75,7 @@ public List<List<Integer>> TwoPointer(int[] nums, int target) {
 
     public List<List<Integer>> Hashmap(int[] nums, int target) {
         Arrays.sort(nums);
-        Set<List<Integer>> ts = new HashSet();
+        Set<List<Integer>> ts = new HashSet<>();
         HashMap<Integer, Integer> hm = new HashMap<>();
 
         for (int i = 0; i < nums.length; i++) {
@@ -94,6 +94,6 @@ public List<List<Integer>> Hashmap(int[] nums, int target) {
                 }
             }
         }
-        return new ArrayList(ts);
+        return new ArrayList<>(ts);
     }
 }

File: src/main/java/com/thealgorithms/searches/UnionFind.java
Patch:
@@ -45,7 +45,7 @@ public void union(int x, int y) {
     }
 
     public int count() {
-        List parents = new ArrayList();
+        List<Integer> parents = new ArrayList<>();
         for (int i = 0; i < p.length; i++) {
             if (!parents.contains(find(i))) {
                 parents.add(find(i));

File: src/main/java/com/thealgorithms/strings/WordLadder.java
Patch:
@@ -51,13 +51,13 @@ class WordLadder {
      * if the endword is there. Otherwise, will return the length as 0.
      */
     public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
-        HashSet<String> set = new HashSet(wordList);
+        HashSet<String> set = new HashSet<>(wordList);
 
         if (!set.contains(endWord)) {
             return 0;
         }
 
-        Queue<String> queue = new LinkedList();
+        Queue<String> queue = new LinkedList<>();
         queue.offer(beginWord);
         int level = 1;
 

File: src/main/java/com/thealgorithms/datastructures/crdt/GSet.java
Patch:
@@ -50,7 +50,7 @@ public boolean lookup(T e) {
      * @return true if the current G-Set is a subset of the other, false otherwise
      */
     public boolean compare(GSet<T> other) {
-        return elements.containsAll(other.elements);
+        return other.elements.containsAll(elements);
     }
 
     /**

File: src/main/java/com/thealgorithms/maths/HarshadNumber.java
Patch:
@@ -15,7 +15,7 @@ public static boolean isHarshad(long n) {
         if (n <= 0) return false;
 
         long t = n;
-        int sumOfDigits = 0;
+        long sumOfDigits = 0;
         while (t > 0) {
             sumOfDigits += t % 10;
             t /= 10;

File: src/main/java/com/thealgorithms/sorts/SelectionSort.java
Patch:
@@ -1,5 +1,7 @@
 package com.thealgorithms.sorts;
 
+import static com.thealgorithms.sorts.SortUtils.swap;
+
 public class SelectionSort implements SortAlgorithm {
 
     /**
@@ -20,9 +22,7 @@ public <T extends Comparable<T>> T[] sort(T[] arr) {
                 }
             }
             if (minIndex != i) {
-                T temp = arr[i];
-                arr[i] = arr[minIndex];
-                arr[minIndex] = temp;
+                swap(arr, i, minIndex);
             }
         }
         return arr;

File: src/main/java/com/thealgorithms/misc/ColorContrastRatio.java
Patch:
@@ -3,7 +3,7 @@
 import java.awt.Color;
 
 /**
- * @brief A Java implementation of the offcial W3 documented procedure to
+ * @brief A Java implementation of the official W3 documented procedure to
  * calculate contrast ratio between colors on the web. This is used to calculate
  * the readability of a foreground color on top of a background color.
  * @since 2020-10-15

File: src/main/java/com/thealgorithms/ciphers/AESEncryption.java
Patch:
@@ -19,7 +19,7 @@ public class AESEncryption {
 
     /**
      * 1. Generate a plain text for encryption 2. Get a secret key (printed in
-     * hexadecimal form). In actual use this must by encrypted and kept safe.
+     * hexadecimal form). In actual use this must be encrypted and kept safe.
      * The same key is required for decryption.
      */
     public static void main(String[] args) throws Exception {

File: src/main/java/com/thealgorithms/conversions/AnyBaseToDecimal.java
Patch:
@@ -1,7 +1,7 @@
 package com.thealgorithms.conversions;
 
 /**
- * @author Varun Upadhyay (https://github.com/varunu28)
+ * @author Varun Upadhyay (<a href="https://github.com/varunu28">...</a>)
  */
 // Driver program
 public class AnyBaseToDecimal {

File: src/main/java/com/thealgorithms/conversions/DecimalToAnyBase.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.ArrayList;
 
 /**
- * @author Varun Upadhyay (https://github.com/varunu28)
+ * @author Varun Upadhyay (<a href="https://github.com/varunu28">...</a>)
  */
 // Driver Program
 public class DecimalToAnyBase {

File: src/main/java/com/thealgorithms/conversions/RgbHsvConversion.java
Patch:
@@ -10,8 +10,8 @@
  * models how colors appear under light. In it, colors are represented using
  * three components: hue, saturation and (brightness-)value. This class provides
  * methods for converting colors from one representation to the other.
- * (description adapted from https://en.wikipedia.org/wiki/RGB_color_model and
- * https://en.wikipedia.org/wiki/HSL_and_HSV).
+ * (description adapted from <a href="https://en.wikipedia.org/wiki/RGB_color_model">[1]</a> and
+ * <a href="https://en.wikipedia.org/wiki/HSL_and_HSV">[2]</a>).
  */
 public class RgbHsvConversion {
 

File: src/main/java/com/thealgorithms/maths/Average.java
Patch:
@@ -23,7 +23,7 @@ public static double average(double[] numbers) {
     }
 
     /**
-     * find average value of int array
+     * find average value of an int array
      *
      * @param numbers the array contains element and the sum does not excess long
      *                value limit

File: src/main/java/com/thealgorithms/maths/DeterminantOfMatrix.java
Patch:
@@ -4,7 +4,7 @@
 
 /*
  * @author Ojasva Jain
- * Determinant of Matrix Wikipedia link : https://en.wikipedia.org/wiki/Determinant
+ * Determinant of a Matrix Wikipedia link: https://en.wikipedia.org/wiki/Determinant
  */
 public class DeterminantOfMatrix {
 

File: src/main/java/com/thealgorithms/maths/DistanceFormula.java
Patch:
@@ -16,7 +16,7 @@ public static int hammingDistance(int[] b1, int[] b2) {
         int d = 0;
 
         if (b1.length != b2.length) {
-            return -1; // error, both array must be have the same length
+            return -1; // error, both arrays must have the same length
         }
 
         for (int i = 0; i < b1.length; i++) {
@@ -31,7 +31,7 @@ public static double minkowskiDistance(double[] p1, double[] p2, int p) {
         double distance = 0.0;
 
         if (p1.length != p2.length) {
-            return -1; // error, both array must be have the same length
+            return -1; // error, both arrays must have the same length
         }
 
         for (int i = 0; i < p1.length; i++) {

File: src/main/java/com/thealgorithms/maths/EulerMethod.java
Patch:
@@ -87,7 +87,7 @@ public static ArrayList<double[]> eulerFull(double xStart, double xEnd, double s
         double xCurrent = xStart;
 
         while (xCurrent < xEnd) {
-            // Euler method for next step
+            // Euler's method for next step
             yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation);
             xCurrent += stepSize;
             double[] point = {xCurrent, yCurrent};

File: src/main/java/com/thealgorithms/maths/FindKthNumber.java
Patch:
@@ -11,7 +11,7 @@ public class FindKthNumber {
     private static final Random random = new Random();
 
     public static void main(String[] args) {
-        /* generate array with random size and random elements */
+        /* generate an array with random size and random elements */
         int[] nums = generateArray(100);
 
         /* get 3th largest element */

File: src/main/java/com/thealgorithms/maths/FindMin.java
Patch:
@@ -13,7 +13,7 @@ private FindMin() {
      */
     public static int findMin(final int[] array) {
         if (array.length == 0) {
-            throw new IllegalArgumentException("array must be non-empty.");
+            throw new IllegalArgumentException("Array must be non-empty.");
         }
         int min = array[0];
         for (int i = 1; i < array.length; i++) {

File: src/main/java/com/thealgorithms/maths/GCD.java
Patch:
@@ -1,15 +1,15 @@
 package com.thealgorithms.maths;
 
 /**
- * This is Euclid's algorithm which is used to find the greatest common
- * denominator Overide function name gcd
+ * This is Euclid's algorithm, used to find the greatest common
+ * denominator Override function name gcd
  *
  * @author Oskar Enmalm 3/10/17
  */
 public class GCD {
 
     /**
-     * get greatest common divisor
+     * get the greatest common divisor
      *
      * @param num1 the first number
      * @param num2 the second number

File: src/main/java/com/thealgorithms/maths/Gaussian.java
Patch:
@@ -38,7 +38,7 @@ public static double[][] gaussianElimination(int mat_size, int i, double[][] mat
         return mat;
     }
 
-    // calculate the x_1, x_2,... values of the gaussian and save it in an arraylist.
+    // calculate the x_1, x_2, ... values of the gaussian and save it in an arraylist.
     public static ArrayList<Double> valueOfGaussian(int mat_size, double[][] x, double[][] mat) {
         ArrayList<Double> answerArray = new ArrayList<Double>();
         int i, j;

File: src/main/java/com/thealgorithms/searches/RecursiveBinarySearch.java
Patch:
@@ -2,7 +2,7 @@
 // Created:- 1/10/2023
 // File Name should be RecursiveBinarySearch.java
 // Explanation:- https://www.tutorialspoint.com/java-program-for-binary-search-recursive
-
+package com.thealgorithms.searches;
 import java.util.*;
 
 // Create a SearchAlgorithm class with a generic type

File: src/test/java/com/thealgorithms/searches/RecursiveBinarySearchTest.java
Patch:
@@ -1,6 +1,7 @@
 // Created by Pronay Debnath
 // Date:- 1/10/2023
 // Test file updated with JUnit tests
+package com.thealgorithms.searches;
 
 import static org.junit.jupiter.api.Assertions.*;
 

File: src/test/java/com/thealgorithms/maths/FactorialTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.thealgorithms.maths;
 
-import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import org.junit.jupiter.api.Test;
 

File: src/main/java/com/thealgorithms/stacks/BalancedBrackets.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Stack;
 

File: src/main/java/com/thealgorithms/stacks/CalculateMaxOfMin.java
Patch:
@@ -7,7 +7,7 @@
  * Program description - Given an integer array. The task is to find the maximum of the minimum of
  * the array
  */
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.*;
 

File: src/main/java/com/thealgorithms/stacks/DecimalToAnyUsingStack.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Stack;
 

File: src/main/java/com/thealgorithms/stacks/DuplicateBrackets.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 //  1. You are given a string exp representing an expression.
 // 2. Assume that the expression is balanced  i.e. the opening and closing brackets match with each

File: src/main/java/com/thealgorithms/stacks/InfixToPostfix.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Stack;
 

File: src/main/java/com/thealgorithms/stacks/LargestRectangle.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Stack;
 

File: src/main/java/com/thealgorithms/stacks/MaximumMinimumWindow.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Arrays;
 import java.util.Stack;

File: src/main/java/com/thealgorithms/stacks/NextGraterElement.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Arrays;
 import java.util.Stack;

File: src/main/java/com/thealgorithms/stacks/NextSmallerElement.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Arrays;
 import java.util.Stack;

File: src/main/java/com/thealgorithms/stacks/PostfixToInfix.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.datastructures.stacks;
+package com.thealgorithms.stacks;
 
 import java.util.Stack;
 

File: src/main/java/com/thealgorithms/stacks/StackPostfixNotation.java
Patch:
@@ -1,4 +1,4 @@
-package com.thealgorithms.others;
+package com.thealgorithms.stacks;
 
 import java.util.Scanner;
 import java.util.Stack;

File: src/test/java/com/thealgorithms/stacks/StackPostfixNotationTest.java
Patch:
@@ -1,8 +1,7 @@
-package com.thealgorithms.others;
+package com.thealgorithms.stacks;
 
 import static java.util.Map.entry;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.*;
 
 import java.util.Map;
 import org.junit.jupiter.api.Test;

File: src/main/java/com/thealgorithms/backtracking/FloodFill.java
Patch:
@@ -39,6 +39,7 @@ public static void putPixel(int[][] image, int x, int y, int newColor) {
      * @param oldColor The old color which is to be replaced in the image
      */
     public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {
+        if (newColor == oldColor) return;
         if (x < 0 || x >= image.length) return;
         if (y < 0 || y >= image[x].length) return;
         if (getPixel(image, x, y) != oldColor) return;

File: src/main/java/com/thealgorithms/io/BufferedReader.java
Patch:
@@ -16,7 +16,7 @@ public class BufferedReader {
     private static final int DEFAULT_BUFFER_SIZE = 5;
 
     /**
-     * Maximum number of bytes the buffer can hold.
+     * The maximum number of bytes the buffer can hold.
      * Value is changed when encountered Eof to not
      * cause overflow read of 0 bytes
      */
@@ -100,7 +100,7 @@ public int peek(int n) throws IOException {
      * Removes the already read bytes from the buffer
      * in-order to make space for new bytes to be filled up.
      * <p>
-     * This may also do the job to read first time data (whole buffer is empty)
+     * This may also do the job to read first time data (the whole buffer is empty)
      */
 
     private void pushRefreshData() throws IOException {
@@ -116,7 +116,7 @@ private void pushRefreshData() throws IOException {
 
     /**
      * Reads one complete block of size {bufferSize}
-     * if found eof, the total length of array will
+     * if found eof, the total length of an array will
      * be that of what's available
      *
      * @return a completed block

File: src/main/java/com/thealgorithms/maths/AmicableNumber.java
Patch:
@@ -15,9 +15,9 @@
  * <p>
  * link: https://en.wikipedia.org/wiki/Amicable_numbers
  * <p>
- * Simple Example : (220, 284)
- * 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110} <- SUM = 284
- * 284 is divisible by {1,2,4,71,142} <- SUM = 220.
+ * Simple Example: (220, 284)
+ * 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110} <-SUM = 284
+ * 284 is divisible by {1,2,4,71,142} <-SUM = 220.
  */
 public class AmicableNumber {
     /**

File: src/main/java/com/thealgorithms/backtracking/AllPathsFromSourceToTarget.java
Patch:
@@ -98,4 +98,4 @@ public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[]
         return nm;
         // returns all possible paths from source to destination
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/backtracking/ArrayCombination.java
Patch:
@@ -26,4 +26,4 @@ public static List<TreeSet<Integer>> combination(int n, int k) {
         }
         return Combination.combination(arr, length);
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBit.java
Patch:
@@ -25,4 +25,4 @@ public static int indexOfRightMostSetBit(int n) {
 
         return index;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/bitmanipulation/IsEven.java
Patch:
@@ -9,4 +9,4 @@ public class IsEven {
     public static boolean isEven(int number) {
         return (number & 1) == 0;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinder.java
Patch:
@@ -14,4 +14,4 @@ public static int findNonRepeatingNumber(int[] arr) {
         }
         return result;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/bitmanipulation/NumbersDifferentSigns.java
Patch:
@@ -10,4 +10,4 @@ public class NumbersDifferentSigns {
     public static boolean differentSigns(int num1, int num2) {
         return (num1 ^ num2) < 0;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/bitmanipulation/ReverseBits.java
Patch:
@@ -17,4 +17,4 @@ public static int reverseBits(int n) {
         }
         return result;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java
Patch:
@@ -111,4 +111,4 @@ private void in_order_aux(Node n, ArrayList<Integer> lst) {
         lst.add(n.element);
         in_order_aux(n.right, lst);
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/dynamicprogramming/Fibonacci.java
Patch:
@@ -109,4 +109,4 @@ public static int fibBinet(int n) {
         int nthTerm = (int) ((Math.pow(phi, n) - Math.pow(-phi, -n)) / squareRootOf5);
         return nthTerm;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/dynamicprogramming/OptimalJobScheduling.java
Patch:
@@ -126,4 +126,4 @@ private void showResults() {
     public int getCost(int process, int machine) {
         return Cost[process][machine];
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/maths/PowerUsingRecursion.java
Patch:
@@ -17,4 +17,4 @@ public static double power(double base, int exponent) {
         // Recurse with a smaller exponent and multiply with base
         return base * power(base, exponent - 1);
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/scheduling/PreemptivePriorityScheduling.java
Patch:
@@ -51,4 +51,4 @@ public static List<String> preemptivePriorityScheduling(List<Process> processes)
 
         return ganttChart;
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/sorts/DualPivotQuickSort.java
Patch:
@@ -103,4 +103,4 @@ public static void main(String[] args) {
     /*
      * References: https://www.geeksforgeeks.org/dual-pivot-quicksort/
      */
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/strings/StringCompression.java
Patch:
@@ -58,4 +58,4 @@ public static String appendCount(String res, int count, char ch) {
         }
         return res;
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java
Patch:
@@ -54,4 +54,4 @@ void testForFourthcase() {
         list2 = list1;
         assertIterableEquals(list1, list2);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/backtracking/WordSearchTest.java
Patch:
@@ -29,4 +29,4 @@ void test3() {
         String word = "ABCB";
         Assertions.assertFalse(ws.exist(board, word));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java
Patch:
@@ -17,4 +17,4 @@ void testIndexOfRightMostSetBit() {
         assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));
         assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinderTest.java
Patch:
@@ -20,4 +20,4 @@ void testNonRepeatingNumberFinder() {
         int arr2[] = {12};
         assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/bitmanipulation/NumbersDifferentSignsTest.java
Patch:
@@ -30,4 +30,4 @@ void testSameSignsPositive() {
     void testSameSignsNegative() {
         assertFalse(NumbersDifferentSigns.differentSigns(-5, -8));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/conversions/BinaryToDecimalTest.java
Patch:
@@ -30,4 +30,4 @@ public void testLargeBinaryToDecimal() {
         assertEquals(262144L, BinaryToDecimal.binaryToDecimal(1000000000000000000L));
         assertEquals(524287L, BinaryToDecimal.binaryToDecimal(1111111111111111111L));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java
Patch:
@@ -25,4 +25,4 @@ void testLeftistHeap() {
         heap.clear();
         Assertions.assertTrue(heap.isEmpty());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/datastructures/queues/LinkedQueueTest.java
Patch:
@@ -23,4 +23,4 @@ public void testQue() {
             if (element[0]++ != integer) throw new AssertionError();
         });
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/divideandconquer/StrassenMatrixMultiplicationTest.java
Patch:
@@ -37,4 +37,4 @@ void StrassenMatrixMultiplicationTestNegetiveNumber4x4() {
         int[][] actResult = SMM.multiply(A, B);
         assertArrayEquals(expResult, actResult);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/dynamicprogramming/KnapsackMemoizationTest.java
Patch:
@@ -31,4 +31,4 @@ void Test3() {
         int capacity = 50;
         assertEquals(220, knapsackMemoization.knapSack(capacity, weight, value, weight.length));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/dynamicprogramming/OptimalJobSchedulingTest.java
Patch:
@@ -95,4 +95,4 @@ public void testOptimalJobScheduling3() {
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/dynamicprogramming/PartitionProblemTest.java
Patch:
@@ -21,4 +21,4 @@ public void testIfSumOfTheArrayIsEven1() {
     public void testIfSumOfTheArrayIsEven2() {
         assertFalse(PartitionProblem.partition(new int[] {1, 2, 3, 8}));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/geometry/GrahamScanTest.java
Patch:
@@ -13,4 +13,4 @@ void testGrahamScan() {
         GrahamScan graham = new GrahamScan(points);
         assertEquals(expectedResult, graham.hull().toString());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/maths/AreaTest.java
Patch:
@@ -98,4 +98,4 @@ void testAllIllegalInput() {
                 -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),
             () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/maths/DudeneyNumberTest.java
Patch:
@@ -14,4 +14,4 @@ void isDudeney() {
         assertTrue(() -> DudeneyNumber.isDudeney(validDudeneyNumber));
         assertFalse(() -> DudeneyNumber.isDudeney(invalidDudeneyNumber));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/maths/PowerUsingRecursionTest.java
Patch:
@@ -17,4 +17,4 @@ void testPowerUsingRecursion() {
         assertEquals(97.65625, PowerUsingRecursion.power(2.5, 5));
         assertEquals(81, PowerUsingRecursion.power(3, 4));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/others/CountCharTest.java
Patch:
@@ -13,4 +13,4 @@ void testCountCharacters() {
 
         assertEquals(expectedValue, CountChar.CountCharacters(input));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/scheduling/PreemptivePrioritySchedulingTest.java
Patch:
@@ -29,4 +29,4 @@ void testPreemptivePriorityScheduling() {
         // Assert
         assertEquals(expectedGanttChart, actualGanttChart);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/scheduling/RRSchedulingTest.java
Patch:
@@ -60,4 +60,4 @@ private List<ProcessDetails> addProcessesForRR() {
 
         return processDetails;
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/scheduling/SJFSchedulingTest.java
Patch:
@@ -106,4 +106,4 @@ void schedulingOf_nothing() {
         a.scheduleProcesses();
         assertTrue(a.schedule.isEmpty());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java
Patch:
@@ -99,4 +99,4 @@ void testSearchValueThatNotExists() {
         // check path is the whole list
         assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java
Patch:
@@ -23,4 +23,4 @@ public void testDescending() {
         int excepted = 3;
         assertEquals(excepted, ans);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/sorts/BeadSortTest.java
Patch:
@@ -39,4 +39,4 @@ public void bogoSortDuplicateIntegerArray() {
         int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};
         assertArrayEquals(outputArray, expectedOutput);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/sorts/BucketSortTest.java
Patch:
@@ -45,4 +45,4 @@ public void bucketSortDuplicateIntegerArrayWithNegativeNum() {
         int[] expectedOutput = {-36, -15, -1, 6, 23, 23, 27, 27};
         assertArrayEquals(outputArray, expectedOutput);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java
Patch:
@@ -59,4 +59,4 @@ void quickSortWithStringArrayShouldPass() {
         String[] expected = {"ant", "apple", "boss", "cat", "dog", "eat"};
         assertArrayEquals(expected, sorted);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/thealgorithms/strings/HorspoolSearchTest.java
Patch:
@@ -83,4 +83,4 @@ void testFindFirstPatternNull() {
     void testFindFirstTextNull() {
         assertThrows(NullPointerException.class, () -> HorspoolSearch.findFirst("Hello", null));
     }
-}
\ No newline at end of file
+}

File: src/main/java/com/thealgorithms/datastructures/trees/BSTIterative.java
Patch:
@@ -10,10 +10,10 @@
  * <p>
  * An implementation of BST iteratively. Binary Search Tree is a binary tree
  * which satisfies three properties: left child is less than root node, right
- * child is grater than root node, both left and right childs must themselves be
+ * child is grater than root node, both left and right child must themselves be
  * a BST.
  *
- * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
+ * @author [Lakhan Nad](<a href="https://github.com/Lakhan-Nad">git-Lakhan Nad</a>)
  */
 
 public class BSTIterative {

File: src/main/java/com/thealgorithms/datastructures/trees/BSTRecursive.java
Patch:
@@ -17,7 +17,7 @@
  * I have made public functions as methods and to actually implement recursive
  * approach I have used private methods
  *
- * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
+ * @author [Lakhan Nad](<a href="https://github.com/Lakhan-Nad">git-Lakhan Nad</a>)
  */
 public class BSTRecursive {
 

File: src/main/java/com/thealgorithms/datastructures/trees/BSTRecursiveGeneric.java
Patch:
@@ -9,10 +9,10 @@
  * <p>
  * A recursive implementation of generic type BST.
  *
- * Reference: https://en.wikipedia.org/wiki/Binary_search_tree
+ * Reference: <a href="https://en.wikipedia.org/wiki/Binary_search_tree">Wiki links for BST</a>
  * </p>
  *
- * @author [Madhur Panwar](https://github.com/mdrpanwar)
+ * @author [Madhur Panwar](<a href="https://github.com/mdrpanwar">git-Madhur Panwar</a>)
  */
 public class BSTRecursiveGeneric<T extends Comparable<T>> {
 
@@ -219,7 +219,7 @@ private void inOrderSort(Node<T> node, List<T> sortedList) {
     }
 
     /**
-     * Serach recursively if the given value is present in BST or not.
+     * Search recursively if the given value is present in BST or not.
      *
      * @param node the node under which to check
      * @param data the value to be checked

File: src/main/java/com/thealgorithms/datastructures/trees/CeilInBinarySearchTree.java
Patch:
@@ -39,7 +39,7 @@
  * ii) If key is lesser than root value than ceil will be in right subtree so
  * call recursively on right subtree iii) if key is greater than current root,
  * then either a) the root is ceil b) ceil is in left subtree: call for left
- * subtree. If left subtree returns a non null value then that will be ceil
+ * subtree. If left subtree returns a non-null value then that will be ceil
  * otherwise the root is ceil
  */
 public class CeilInBinarySearchTree {

File: src/main/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalanced.java
Patch:
@@ -12,7 +12,7 @@
  * `isBalancedRecursive()` is implemented in a recursive fashion, and
  * `isBalancedIterative()` is implemented in an iterative fashion.
  *
- * @author [Ian Cowan](https://github.com/iccowan)
+ * @author [Ian Cowan](<a href="https://github.com/iccowan">Git-Ian Cowan</a>)
  */
 public class CheckIfBinaryTreeBalanced {
     /**

File: src/main/java/com/thealgorithms/datastructures/trees/LCA.java
Patch:
@@ -5,7 +5,7 @@
 
 public class LCA {
 
-    private static Scanner scanner = new Scanner(System.in);
+    private static final Scanner scanner = new Scanner(System.in);
 
     public static void main(String[] args) {
         // The adjacency list representation of a tree:
@@ -91,7 +91,7 @@ private static int getLCA(int v1, int v2, int[] depth, int[] parent) {
         return v1;
     }
 }
-/**
+/*
  * Input:
  * 10
  * 0 1

File: src/main/java/com/thealgorithms/others/StackPostfixNotation.java
Patch:
@@ -16,6 +16,9 @@ public static int postfixEvaluate(final String exp) {
             if (tokens.hasNextInt()) {
                 s.push(tokens.nextInt()); // If int then push to stack
             } else { // else pop top two values and perform the operation
+                if (s.size() < 2) {
+                    throw new IllegalArgumentException("exp is not a proper postfix expression (too few arguments).");
+                }
                 int num2 = s.pop();
                 int num1 = s.pop();
                 String op = tokens.next();

File: src/main/java/com/thealgorithms/maths/ReverseNumber.java
Patch:
@@ -1,11 +1,9 @@
 package com.thealgorithms.maths;
 
-import java.lang.IllegalArgumentException;
-
 /**
  * @brief utility class reversing numbers
  */
-final public class ReverseNumber {
+public final class ReverseNumber {
     private ReverseNumber() {
     }
 

File: src/main/java/com/thealgorithms/sorts/QuickSort.java
Patch:
@@ -40,7 +40,7 @@ private static <T extends Comparable<T>> void doSort(
     }
 
     /**
-     * Ramdomize the array to avoid the basically ordered sequences
+     * Randomize the array to avoid the basically ordered sequences
      *
      * @param array The array to be sorted
      * @param left The first index of an array

File: src/main/java/com/thealgorithms/maths/LongDivision.java
Patch:
@@ -11,6 +11,9 @@ public static int divide(int dividend, int divisor) {
         long new_dividend_1 = dividend;
         long new_divisor_1 = divisor;
 
+        if(divisor == 0){
+            return 0;
+        }
         if (dividend < 0) {
             new_dividend_1 = new_dividend_1 * -1;
         }

File: src/main/java/com/thealgorithms/datastructures/caches/LFUCache.java
Patch:
@@ -101,7 +101,7 @@ private void addNodeWithUpdatedFrequency(Node node) {
                         node.next = temp;
                         node.previous = temp.previous;
                         temp.previous.next = node;
-                        node.previous = temp.previous;
+                        temp.previous = node;
                         break;
                     }
                 } else {

File: src/test/java/com/thealgorithms/sorts/InsertionSortTest.java
Patch:
@@ -106,7 +106,7 @@ void insertionSortClassicalWithRandomArrayPass() {
     }
 
     private void testWithRandomArray(Function<Double[], Double[]> sortAlgorithm) {
-        int randomSize = (int) (SortUtilsRandomGenerator.generateDouble() * 10_000);
+        int randomSize = SortUtilsRandomGenerator.generateInt(10_000);
         Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);
         Double[] sorted = sortAlgorithm.apply(array);
         assertTrue(SortUtils.isSorted(sorted));

File: src/main/java/com/thealgorithms/backtracking/FloodFill.java
Patch:
@@ -37,7 +37,6 @@ public static void putPixel(int[][] image, int x, int y, int newColor) {
      * @param y The y co-ordinate at which color is to be filled
      * @param newColor The new color which to be filled in the image
      * @param oldColor The old color which is to be replaced in the image
-     * @return
      */
     public static void floodFill(
         int[][] image,

File: src/main/java/com/thealgorithms/searches/BinarySearch.java
Patch:
@@ -31,7 +31,7 @@ class BinarySearch implements SearchAlgorithm {
      */
     @Override
     public <T extends Comparable<T>> int find(T[] array, T key) {
-        return search(array, key, 0, array.length);
+        return search(array, key, 0, array.length - 1);
     }
 
     /**

File: src/main/java/com/thealgorithms/datastructures/trees/RedBlackBST.java
Patch:
@@ -39,8 +39,8 @@ public void printTreepre(Node node) {
         }
         System.out.print(
                 ((node.color == R) ? " R " : " B ") + "Key: " + node.key + " Parent: " + node.p.key + "\n");
-        printTree(node.left);
-        printTree(node.right);
+        printTreepre(node.left);
+        printTreepre(node.right);
     }
 
     private Node findNode(Node findNode, Node node) {

File: src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java
Patch:
@@ -1,3 +1,5 @@
+package com.thealgorithms.datastructures.heaps;
+
 import java.util.*;
 
 public class GenericHeap <T extends Comparable <T> >{

File: src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java
Patch:
@@ -89,7 +89,9 @@ private Node findKey(Node n, int key) {
         public void delete(int key) {
             if (!isEmpty()) {
                 if (first.getKey() == key) {
-                    first = null;
+                    Node next = first.next;
+                    first.next = null; // help GC
+                    first = next;
                 } else {
                     delete(first, key);
                 }

File: src/main/java/com/thealgorithms/datastructures/lists/CircleLinkedList.java
Patch:
@@ -19,7 +19,7 @@ private Node(E value, Node<E> next) {
     private Node<E> head = null;
     private Node<E> tail = null; // keeping a tail pointer to keep track of the end of list
 
-    // constructer for class.. here we will make a dummy node for circly linked list implementation
+    // constructor for class.. here we will make a dummy node for circly linked list implementation
     // with reduced error catching as our list will never be empty;
     public CircleLinkedList() {
         // creation of the dummy node

File: src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java
Patch:
@@ -50,7 +50,7 @@ private void swap(int index1, int index2) {
     // Toggle an element up to its right place as long as its key is lower than its parent's
     private void toggleUp(int elementIndex) {
         double key = minHeap.get(elementIndex - 1).getKey();
-        while (getElementKey((int) Math.floor(elementIndex / 2.0)) > key) {
+        while (getElementKey((int) Math.floor(elementIndex / 2.0) + 1) > key) {
             swap(elementIndex, (int) Math.floor(elementIndex / 2.0));
             elementIndex = (int) Math.floor(elementIndex / 2.0);
         }

File: src/main/java/com/thealgorithms/datastructures/lists/SkipList.java
Patch:
@@ -117,7 +117,9 @@ public void remove(E e) {
         }
         for (int i = 0; i <= layer; i++) {
             current.previous(i).setNext(i, current.next(i));
-            current.next(i).setPrevious(i, current.previous(i));
+            if (current.next(i) != null) {
+                current.next(i).setPrevious(i, current.previous(i));
+            }
         }
         size--;
     }

File: src/main/java/com/thealgorithms/sorts/TimSort.java
Patch:
@@ -71,10 +71,10 @@ public TimSort() {
      * sorting.
      */
     public void insertion_sort(int[] array, int start_idx, int end_idx) {
-        for (int i = 0; i < array.length; i++) {
+        for (int i = start_idx; i <= end_idx; i++) {
             int current_element = array[i];
             int j = i - 1;
-            while (j >= 0 && array[j] > current_element) {
+            while (j >= start_idx && array[j] > current_element) {
                 array[j + 1] = array[j];
                 j--;
             }

File: src/main/java/com/thealgorithms/datastructures/lists/CircleLinkedList.java
Patch:
@@ -90,7 +90,7 @@ public E remove(int pos) {
         }
         Node<E> destroy = before.next;
         E saved = destroy.value;
-        // assigning the next reference to the the element following the element we want to remove...
+        // assigning the next reference to the element following the element we want to remove...
         // the last element will be assigned to the head.
         before.next = before.next.next;
         // scrubbing

File: src/main/java/com/thealgorithms/dynamicprogramming/CoinChange.java
Patch:
@@ -49,7 +49,7 @@ public static int change(int[] coins, int amount) {
      *
      * @param coins The list of coins
      * @param amount The amount for which we need to find the minimum number of
-     * coins. Finds the the minimum number of coins that make a given value.
+     * coins. Finds the minimum number of coins that make a given value.
      */
     public static int minimumCoins(int[] coins, int amount) {
         // minimumCoins[i] will store the minimum coins needed for amount i

File: src/main/java/com/thealgorithms/maths/VectorCrossProduct.java
Patch:
@@ -28,7 +28,7 @@
  * following Java Program calculates the direction ratios of the cross products
  * of two vector. The program uses a function, cross() for doing so. The
  * direction ratios for the first and the second vector has to be passed one by
- * one seperated by a space character.
+ * one separated by a space character.
  *
  * Magnitude of a vector is the square root of the sum of the squares of the
  * direction ratios.

File: src/main/java/com/thealgorithms/misc/RangeInSortedArray.java
Patch:
@@ -90,7 +90,7 @@ public static int getLessThan(int[] nums, int key, int left, int right) {
             if (nums[mid] > key) {
                 right = mid - 1;
             } else if (nums[mid] <= key) {
-                count = mid + 1; // Atleast mid+1 elements exist which are <= key
+                count = mid + 1; // At least mid+1 elements exist which are <= key
                 left = mid + 1;
             }
         }

File: src/main/java/com/thealgorithms/others/Implementing_auto_completing_features_using_trie.java
Patch:
@@ -135,7 +135,7 @@ static int printAutoSuggestions(TrieNode root,
             return -1;
         }
 
-        // If there are are nodes below last 
+        // If there are nodes below the last 
         // matching character. 
         if (!isLast) {
             String prefix = query;

File: src/main/java/com/thealgorithms/strings/Upper.java
Patch:
@@ -19,6 +19,9 @@ public static void main(String[] args) {
      * @return the {@code String}, converted to uppercase.
      */
     public static String toUpperCase(String s) {
+        if (s == null || "".equals(s)) {
+            return s;
+        }
         char[] values = s.toCharArray();
         for (int i = 0; i < values.length; ++i) {
             if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {

File: src/main/java/com/thealgorithms/maths/Gaussian.java
Patch:
@@ -38,7 +38,7 @@ public static double[][] gaussianElimination(int mat_size, int i, double[][] mat
         return mat;
     }
 
-    // calcilate the x_1, x_2,... values of the gaussian and save it in an arraylist.
+    // calculate the x_1, x_2,... values of the gaussian and save it in an arraylist.
     public static ArrayList<Double> valueOfGaussian(int mat_size, double[][] x, double[][] mat) {
         ArrayList<Double> answerArray = new ArrayList<Double>();
         int i, j;

File: src/main/java/com/thealgorithms/datastructures/trees/AVLSimple.java
Patch:
@@ -29,7 +29,7 @@
 
 
 
-public class AVLTree {
+public class AVLSimple {
 	private class Node{
 		int data;
 		int height;
@@ -82,7 +82,7 @@ public void display() {
 		System.out.println(this.root.height);
 	}
 	private void display (Node node) {
-		Strings str="";
+		String str="";
 		if(node.left!=null)
 			str+=node.left.data+"=>";
 		else

File: src/main/java/com/thealgorithms/datastructures/stacks/NextSmallerElement.java
Patch:
@@ -19,9 +19,9 @@ Next smaller element between (0 , 1) is 2
     At i = 3
     Next smaller element between (0 , 2) is 3
     At i = 4
-    Next smaller element between (0 , 3) is 4
+    Next smaller element between (0 , 3) is 3
     At i = 5
-    Next smaller element between (0 , 4) is 3
+    Next smaller element between (0 , 4) is 4
     At i = 6
     Next smaller element between (0 , 5) is 6
     

File: src/main/java/com/thealgorithms/datastructures/graphs/A_Star.java
Patch:
@@ -16,7 +16,7 @@ private static class Graph {
         public Graph(int size) {
             this.graph = new ArrayList<>();
             for (int i = 0; i < size; i++) {
-                this.graph.set(i, new ArrayList<>());
+                this.graph.add(new ArrayList<>());
             }
         }
 

File: Maths/Area.java
Patch:
@@ -74,10 +74,11 @@ private static double surfaceAreaRectangle(double length, double width) {
   }
   
   /**
-   * Calculate surface of a cylinder
+   * Calculate surface area of a cylinder
    *
    * @param radius radius of the floor
    * @param height height of the cylinder.
+   * @return volume of given cylinder
    */
   private static double surfaceAreaCylinder(double radius, double height) {
     return 2 * (Math.PI * radius * radius + Math.PI * radius * height);

File: DataStructures/Trees/BSTRecursive.java
Patch:
@@ -26,7 +26,7 @@ public class BSTRecursive {
 
   /** main function for tests */
   public static void main(String[] args) {
-    BSTIterative tree = new BSTIterative();
+    BSTRecursive tree = new BSTRecursive();
     tree.add(5);
     tree.add(10);
     tree.add(9);

File: DataStructures/Graphs/A_Star.java
Patch:
@@ -2,9 +2,8 @@
 	Time Complexity = O(E), where E is equal to the number of edges
 */
 
-package Graphs;
+package DataStructures.Graphs;
 
-import java.lang.reflect.Array;
 import java.util.*;
 
 public class A_Star {

File: DataStructures/Graphs/DIJSKSTRAS_ALGORITHM.java
Patch:
@@ -4,9 +4,6 @@
 */
 package DataStructures.Graphs;
 
-import java.util.*;
-import java.io.*;
-
 class dijkstras{
 
     int k=9;

File: DataStructures/Graphs/KahnsAlgorithm.java
Patch:
@@ -1,4 +1,4 @@
-package Graphs;
+package DataStructures.Graphs;
 
 import java.util.ArrayList;
 import java.util.Map;
@@ -104,7 +104,6 @@ void calculateInDegree(){
      */
     ArrayList<E> topSortOrder(){
         calculateInDegree();
-        int count = 0;
         Queue<E> q = new LinkedList<E>();
         
         for(E vertex: inDegree.keySet()){

File: DataStructures/Graphs/Kruskal.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Graphs;
+
 // Problem -> Connect all the edges with the minimum cost.
 // Possible Solution -> Kruskal Algorithm (KA), KA finds the minimum-spanning-tree, which means, the
 // group of edges with the minimum sum of their weights that connect the whole graph.

File: DataStructures/Lists/RemoveDuplicateNodes.java
Patch:
@@ -1,7 +1,5 @@
 package DataStructures.Lists;
 
-import DataStructures.Lists.Node;
-
 public class RemoveDuplicateNodes {
 
     public Node deleteDuplicates(Node head) {

File: DataStructures/Queues/CircularQueue.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Queues;
+
 //This program implements the concept of CircularQueue in Java
 //Link to the concept: (https://en.wikipedia.org/wiki/Circular_buffer)
 

File: DataStructures/Trees/BSTIterative.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Trees;
+
 /**
  *
  *

File: DataStructures/Trees/BSTRecursive.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Trees;
+
 /**
  *
  *

File: DataStructures/Trees/LCA.java
Patch:
@@ -1,4 +1,4 @@
-package Trees;
+package DataStructures.Trees;
 
 import java.util.ArrayList;
 import java.util.Scanner;

File: DivideAndConquer/BinaryExponentiation.java
Patch:
@@ -1,3 +1,5 @@
+package DivideAndConquer;
+
 public class BinaryExponentiation {
 
     public static void main(String args[]) {

File: DivideAndConquer/ClosestPair.java
Patch:
@@ -1,7 +1,5 @@
 package DivideAndConquer;
 
-import java.io.IOException;
-
 /**
  * For a set of points in a coordinates system (10000 maximum), ClosestPair class calculates the two
  * closest points.

File: DivideAndConquer/StrassenMatrixMultiplication.java
Patch:
@@ -1,3 +1,5 @@
+package DivideAndConquer;
+
 // Java Program to Implement Strassen Algorithm
  
 // Class Strassen matrix multiplication

File: DynamicProgramming/DiceThrow.java
Patch:
@@ -1,3 +1,5 @@
+package DynamicProgramming;
+
 // Given N dice each with M faces, numbered from 1 to M, find the number of ways to get sum X.
 // X is the summation of values on each face when all the dice are thrown.
 
@@ -14,9 +16,6 @@ And it can be done using Dynamic Programming(DP).
 // Code ---->
 // Java program to find number of ways to get sum 'x' with 'n' 
 // dice where every dice has 'm' faces 
-import java.util.*;
-import java.lang.*;
-import java.io.*;
 
 class DP {
     /* The main function that returns the number of ways to get sum 'x' with 'n' dice and 'm' with m faces. */

File: DynamicProgramming/MinimumSumPartition.java
Patch:
@@ -15,9 +15,6 @@
 Subset2 = {36, 40} ; sum of Subset2  = 76
  */
 
-import java.io.*;
-import java.util.*;
-
 public class MinimumSumPartition {
   public static int subSet(int[] arr) {
     int n = arr.length;

File: DynamicProgramming/ShortestCommonSupersequenceLength.java
Patch:
@@ -1,3 +1,5 @@
+package DynamicProgramming;
+
 // Java program to find length of the shortest supersequence
 class ShortestSuperSequence {
  

File: DynamicProgramming/Sum_Of_Subset.java
Patch:
@@ -1,3 +1,5 @@
+package DynamicProgramming;
+
 public class Sum_Of_Subset {
         public static void main(String[] args){
     

File: Maths/AutomorphicNumber.java
Patch:
@@ -1,3 +1,5 @@
+package Maths;
+
 /**
  * A number is said to be an Automorphic, if it is present in the last digit(s) of its square.
  * Example- Let the number be 25, its square is 625.

File: Maths/CircularConvolutionFFT.java
Patch:
@@ -1,4 +1,4 @@
-package com.maths;
+package Maths;
 
 import java.util.ArrayList;
 

File: Maths/Convolution.java
Patch:
@@ -1,4 +1,4 @@
-package com.maths;
+package Maths;
 
 /**
  * Class for linear convolution of two discrete signals

File: Maths/ConvolutionFFT.java
Patch:
@@ -1,4 +1,4 @@
-package com.maths;
+package Maths;
 
 import java.util.ArrayList;
 

File: Maths/FFT.java
Patch:
@@ -1,4 +1,4 @@
-package com.maths;
+package Maths;
 
 import java.util.ArrayList;
 import java.util.Collections;

File: Maths/FFTBluestein.java
Patch:
@@ -1,4 +1,4 @@
-package com.maths;
+package Maths;
 
 import java.util.ArrayList;
 

File: Maths/GenericRoot.java
Patch:
@@ -1,3 +1,5 @@
+package Maths;
+
 /*
  * Algorithm explanation: https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/#:~:text=Generic%20Root%3A%20of%20a%20number,get%20a%20single%2Ddigit%20output.&text=For%20Example%3A%20If%20user%20input,%2B%204%20%2B%205%20%3D%2015.
  */

File: Maths/KrishnamurthyNumber.java
Patch:
@@ -1,4 +1,4 @@
-//package Maths;
+package Maths;
 
 /* This is a program to check if a number is a Krishnamurthy number or not.
 A number is a Krishnamurthy number if the sum of the factorials of the digits of the number is equal to the number itself.

File: Maths/MagicSquare.java
Patch:
@@ -1,4 +1,7 @@
+package Maths;
+
 import java.util.*;
+
 /*A magic square of order n is an arrangement of distinct n^2 integers,in a square, such that the n numbers in all
 rows, all columns, and both diagonals sum to the same constant. A magic square contains the integers from 1 to n^2.*/
 public class MagicSquare {

File: Maths/RomanNumeralUtil.java
Patch:
@@ -1,3 +1,5 @@
+package Maths;
+
 /**
  * Translates numbers into the Roman Numeral System.
  *

File: Misc/TwoSumProblem.java
Patch:
@@ -1,5 +1,8 @@
+package Misc;
+
 import java.util.*;
 import java.util.stream.Collectors;
+
 public class TwoSumProblem {
 	public static void main(String args[])
 	{

File: Misc/WordBoggle.java
Patch:
@@ -1,3 +1,5 @@
+package Misc;
+
 import java.util.*;
 
 public class WordBoggle {

File: Others/RabinKarp.java
Patch:
@@ -1,3 +1,5 @@
+package Others;
+
 /** @author Prateek Kumar Oraon (https://github.com/prateekKrOraon) */
 import java.util.Scanner;
 

File: Others/RestrictedTowerOfHanoi/Main/Hanoi.java
Patch:
@@ -1,3 +1,5 @@
+package Others.RestrictedTowerOfHanoi.Main;
+
 import java.awt.*;
 import java.awt.event.*;
 import java.util.*;

File: Others/StringMatchFiniteAutomata.java
Patch:
@@ -1,3 +1,5 @@
+package Others;
+
 /** @author Prateek Kumar Oraon (https://github.com/prateekKrOraon) */
 import java.util.Scanner;
 

File: Searches/PerfectBinarySearch.java
Patch:
@@ -1,7 +1,5 @@
 package Searches;
 
-import java.util.*;
-
 class PerfectBinarySearch {
 
   static int binarySearch(int[] arr, int target) {

File: Sorts/MergeSortRecursive.java
Patch:
@@ -1,3 +1,5 @@
+package Sorts;
+
 import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.List;

File: Strings/List_all_Possible_Words_From_Phone_Digits.java
Patch:
@@ -1,7 +1,5 @@
 package Strings;
 import java.util.*;
-import java.lang.*;
-import java.io.*;
 
 public class List_all_Possible_Words_From_Phone_Digits {
  

File: Strings/LongestPalindromicSubstring.java
Patch:
@@ -1,7 +1,8 @@
+package Strings;
+
 // Longest Palindromic Substring
 import java.util.Scanner;;
 
-
 class LongestPalindromicSubstring {
     public static void main(String[] args) {
         Solution s = new Solution();

File: Strings/WordLadder.java
Patch:
@@ -1,6 +1,5 @@
 package Strings;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Arrays;
 import java.util.LinkedList;

File: Others/MiniMaxAlgorithm.java
Patch:
@@ -97,8 +97,8 @@ public static int[] getRandomScores(int size, int maxScore) {
         int[] randomScores = new int[(int) Math.pow(2, size)];
         Random rand = new Random();
 
-        for (int a : randomScores) {
-            a = rand.nextInt(maxScore) + 1;
+        for (int i = 0; i < randomScores.length; i++) {
+            randomScores[i] = rand.nextInt(maxScore) + 1;
         }
 
         return randomScores;

File: DataStructures/Queues/LinkedQueue.java
Patch:
@@ -38,7 +38,7 @@ public LinkedQueue() {
   /**
    * Check if queue is empty
    *
-   * @return <tt>true</tt> if queue is empty, otherwise <tt>false</tt>
+   * @return true if queue is empty, otherwise false
    */
   public boolean isEmpty() {
     return size == 0;
@@ -48,7 +48,7 @@ public boolean isEmpty() {
    * Add element to rear of queue
    *
    * @param data insert value
-   * @return <tt>true</tt> if add successfully
+   * @return true if add successfully
    */
   public boolean enqueue(int data) {
     Node newNode = new Node(data);

File: DataStructures/Queues/Queues.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * This implements Queues by using the class Queue.
  *
- * <p>A queue data structure functions the same as a real world queue. The elements that are added
+ * A queue data structure functions the same as a real world queue. The elements that are added
  * first are the first to be removed. New elements are added to the back/rear of the queue.
  */
 class Queue {
@@ -153,7 +153,7 @@ public static void main(String[] args) {
     myQueue.remove(); // Will make 2 the new front, making 10 no longer part of the queue
     // [10, 2(front), 5, 3(rear)]
 
-    myQueue.insert(7); // Insert 7 at the rear which will be index 0 because of wrap around
+    myQueue.insert(7); // Insert 7 at the rear which will get 0 index because of wrap around
     // [7(rear), 2(front), 5, 3]
 
     System.out.println(myQueue.peekFront()); // Will print 2

File: Conversions/OctalToHexadecimal.java
Patch:
@@ -51,10 +51,10 @@ public static void main(String args[]) {
     // Take octal number as input from user in a string
     String oct = input.next();
 
-    // Pass the octal number to function and get converted deciaml form
+    // Pass the octal number to function and get converted decimal form
     int decimal = octToDec(oct);
 
-    // Pass the decimla number to function and get converted Hex form of the number
+    // Pass the decimal number to function and get converted Hex form of the number
     String hex = decimalToHex(decimal);
     System.out.println("The Hexadecimal equivalant is: " + hex);
     input.close();

File: DynamicProgramming/RegexMatching.java
Patch:
@@ -9,7 +9,7 @@
  **/
 
 /**
- * For calculation Time and Space Complexity. Let N be length of src and M be length of pat
+ * For calculation of Time and Space Complexity. Let N be length of src and M be length of pat
  **/
 
 public class RegexMatching {
@@ -168,4 +168,4 @@ public static void main(String[] args) {
 
 }
 // Memoization vs Tabulation : https://www.geeksforgeeks.org/tabulation-vs-memoization/
-// Question Link : https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1
\ No newline at end of file
+// Question Link : https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1

File: Sorts/BitonicSort.java
Patch:
@@ -44,7 +44,7 @@ void bitonicSort(int a[], int low, int cnt, int dir) {
       // sort in descending order since dir here is 0
       bitonicSort(a, low + k, k, 0);
 
-      // Will merge wole sequence in ascending order
+      // Will merge whole sequence in ascending order
       // since dir=1.
       bitonicMerge(a, low, cnt, dir);
     }

File: Sorts/PancakeSort.java
Patch:
@@ -3,7 +3,7 @@
 import static Sorts.SortUtils.*;
 
 /**
- * Implementation of gnome sort
+ * Implementation of pancake sort
  *
  * @author Podshivalov Nikita (https://github.com/nikitap492)
  * @since 2018-04-10

File: Conversions/IntegerToRoman.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * Converting Integers into Roman Numerals
  *
- * <p>('I', 1); ('IV',4); ('V', 5); ('IV',9); ('X', 10); ('XL',40; ('L', 50); ('XC',90); ('C', 100);
+ * <p>('I', 1); ('IV',4); ('V', 5); ('IX',9); ('X', 10); ('XL',40); ('L', 50); ('XC',90); ('C', 100);
  * ('D', 500); ('M', 1000);
  */
 public class IntegerToRoman {

File: Misc/PalindromePrime.java
Patch:
@@ -7,7 +7,7 @@ public class PalindromePrime {
   public static void main(String[] args) { // Main funtion
     Scanner in = new Scanner(System.in);
     System.out.println("Enter the quantity of First Palindromic Primes you want");
-    int n = in.nextInt(); // Input of how many first pallindromic prime we want
+    int n = in.nextInt(); // Input of how many first palindromic prime we want
     functioning(n); // calling function - functioning
     in.close();
   }

File: Misc/WordBoggle.java
Patch:
@@ -3,8 +3,8 @@
 public class WordBoggle {
 
   /**
-   * O(nm * 8^s + ws) time where n=width of boggle board, m=height of boggle board, s=length of
-   * longest word in string array, w= length of string array, 8 is due to 8 explorable neighbours
+   * O(nm * 8^s + ws) time where n = width of boggle board, m = height of boggle board, s = length of
+   * longest word in string array, w = length of string array, 8 is due to 8 explorable neighbours
    * O(nm + ws) space.
    */
   public static List<String> boggleBoard(char[][] board, String[] words) {

File: Strings/Alphabetical.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 /**
  * Alphabetical order is a system whereby character strings are placed in order based on the

File: Strings/CharactersSame.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 public class CharactersSame {
 

File: Strings/CheckAnagrams.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 import java.util.HashMap;
 import java.util.Map;

File: Strings/CheckVowels.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 /**
  * Vowel Count is a system whereby character strings are placed in order based on the position of
@@ -33,7 +33,7 @@ public static boolean hasVowels(String input) {
    * @param input a string prints the count of vowels
    */
   public static void countVowels(String input) {
-    input.toLowerCase();
+    input = input.toLowerCase();
     int count = 0;
     int i = 0;
     while (i < input.length()) {

File: Strings/HorspoolSearch.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 import java.util.HashMap;
 

File: Strings/Lower.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 public class Lower {
 

File: Strings/Palindrome.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 /** Wikipedia: https://en.wikipedia.org/wiki/Palindrome */
 class Palindrome {

File: Strings/Pangram.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 /** Wikipedia: https://en.wikipedia.org/wiki/Pangram */
 public class Pangram {

File: Strings/ReverseString.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 /** Reverse String using different version */
 public class ReverseString {

File: Strings/Rotation.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 /**
  * Given a string, moving several characters in front of the string to the end of the string. For

File: Strings/Upper.java
Patch:
@@ -1,4 +1,4 @@
-package strings;
+package Strings;
 
 public class Upper {
 

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -4,7 +4,7 @@
 
 class BellmanFord
 /*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have
-start vertex, end vertes and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/
+start vertex, end vertex and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/
 {
   int vertex, edge;
   private Edge edges[];

File: Searches/BinarySearch.java
Patch:
@@ -45,7 +45,7 @@ private <T extends Comparable<T>> int search(T array[], T key, int left, int rig
     if (right < left) return -1; // this means that the key not found
 
     // find median
-    int median = (left + right) >>> 1;
+    int median = left + ((right-left) >>> 1);
     int comp = key.compareTo(array[median]);
 
     if (comp == 0) {

File: DataStructures/Graphs/FloydWarshall.java
Patch:
@@ -14,7 +14,7 @@ public FloydWarshall(int numberofvertices) {
             [numberofvertices
                 + 1]; // stores the value of distance from all the possible path form the source
     // vertex to destination vertex
-    Arrays.fill(DistanceMatrix, 0);
+    // The matrix is initialized with 0's by default
     this.numberofvertices = numberofvertices;
   }
 

File: Sorts/SelectionSort.java
Patch:
@@ -32,7 +32,7 @@ public <T extends Comparable<T>> T[] sort(T[] arr) {
       int min = i;
 
       for (int j = i + 1; j < n; j++) {
-        if (arr[min].compareTo(arr[j]) < 0) {
+        if (arr[min].compareTo(arr[j]) > 0) {
           min = j;
         }
       }

File: Maths/ConvolutionFFT.java
Patch:
@@ -53,7 +53,7 @@ public static ArrayList<FFT.Complex> convolutionFFT(
     convolved
         .subList(convolvedSize, convolved.size())
         .clear(); // Remove the remaining zeros after the convolvedSize. These extra zeros came from
-                  // paddingPowerOfTwo() method inside the fft() method.
+    // paddingPowerOfTwo() method inside the fft() method.
 
     return convolved;
   }

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String args[]) {
 
   public void
       go() // Interactive run for understanding the class first time. Assumes source vertex is 0 and
-        // shows distaance to all vertices
+        // shows distance to all vertices
       {
     Scanner sc = new Scanner(System.in); // Grab scanner object for user input
     int i, v, e, u, ve, w, j, neg = 0;

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -87,7 +87,7 @@ public static void main(String args[]) {
         System.out.println("Negative cycle");
         break;
       }
-    if (neg == 0) // Go ahead and show results of computaion
+    if (neg == 0) // Go ahead and show results of computation
     {
       System.out.println("Distances are: ");
       for (i = 0; i < v; i++) System.out.println(i + " " + dist[i]);

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -150,7 +150,7 @@ public void show(
    * @param y End vertex
    * @param z Weight
    */
-  public void addEdge(int x, int y, int z) // Adds unidirectionl Edge
+  public void addEdge(int x, int y, int z) // Adds unidirectional edge
       {
     edges[index++] = new Edge(x, y, z);
   }

File: Misc/MedianOfRunningArray.java
Patch:
@@ -9,7 +9,7 @@
  */
 public class MedianOfRunningArray {
     private PriorityQueue<Integer> p1;
-    private PriorityQueue<Integer> p2;
+    private PriorityQueue<Integer> p2
 
     //Constructor
     public MedianOfRunningArray() {

File: DataStructures/DynamicArray/DynamicArray.java
Patch:
@@ -1,6 +1,9 @@
 package DataStructures.DynamicArray;
 
 import java.util.*;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 /**
  * This class implements a dynamic array

File: DynamicProgramming/LongestPalindromicSubsequence.java
Patch:
@@ -5,6 +5,7 @@
   
 /**
  * @author Matteo Messmer https://github.com/matteomessmer
+ * Algorithm explanation https://www.educative.io/edpresso/longest-palindromic-subsequence-algorithm
  */
 public class LongestPalindromicSubsequence {
     public static void main(String[] args) {

File: DynamicProgramming/LongestPalindromicSubsequence.java
Patch:
@@ -22,11 +22,11 @@ private static String LPS(String original) {
         StringBuilder reverse = new StringBuilder(); 
         reverse.append(original); 
         reverse = reverse.reverse();
-        return recursiveLPS(original, reverse);
+        return recursiveLPS(original, reverse.toString());
     }
 
     private static String recursiveLPS(String original, String reverse) {
-        String bestResult = ""
+        String bestResult = "";
         
         //no more chars, then return empty
         if(original.length() == 0 || reverse.length() == 0) {

File: Maths/PrimeFactorization.java
Patch:
@@ -11,6 +11,7 @@ public static void main(String[] args){
         int n = scanner.nextInt();
         System.out.print(("printing factors of " + n + " : "));
         pfactors(n);
+        scanner.close();
     }
     public static void pfactors(int n){
 

File: Maths/Armstrong.java
Patch:
@@ -1,4 +1,4 @@
-package Others;
+package strings;
 
 /**
  * An Armstrong number is equal to the sum of the cubes of its digits.

File: Conversions/AnyBaseToAnyBase.java
Patch:
@@ -115,7 +115,8 @@ public static String base2base(String n, int b1, int b2) {
         // the remainder until the quotient is zero. The number in the
         // new base is the remainders, with the last remainder
         // being the left-most digit.
-
+        if (0 == decimalValue)
+        	return "0";
         // While the quotient is NOT zero:
         while (decimalValue != 0) {
             // If the remainder is a digit < 10, simply add it to

File: Maths/AbsoluteMin.java
Patch:
@@ -10,10 +10,10 @@
  */
 public class AbsoluteMin {
     public static void main(String[] args) {
-    	int[] testnums = new int[]{4, 0, 16};
+    	int[] testnums = {4, 0, 16};
     	assert absMin(testnums) == 0;
     	
-        int[] numbers = new int[]{3, -10, -2};
+        int[] numbers = {3, -10, -2};
         System.out.println("absMin(" + Arrays.toString(numbers) + ") = " + absMin(numbers));
     }
 

File: Maths/AbsoluteMax.java
Patch:
@@ -10,10 +10,10 @@
  */
 public class AbsoluteMax {
     public static void main(String[] args) {
-    	int[] testnums = new int[]{-2, 0, 16};
+    	int[] testnums = {-2, 0, 16};
     	assert absMax(testnums) == 16;
     	
-        int[] numbers = new int[]{3, -10, -2};
+        int[] numbers = {3, -10, -2};
         System.out.println("absMax(" + Arrays.toString(numbers) + ") = " + absMax(numbers));
     }
 

File: Others/3 sum.java
Patch:
@@ -53,8 +53,8 @@ public static void main(String args[])
 				else r--;
 			}
 		}
-		
 
+		sc.close();
 		
 	}
 }
\ No newline at end of file

File: Sorts/BucketSort.java
Patch:
@@ -1,7 +1,8 @@
+package Sorts;
 
 import java.util.Random;
  
-public class Bucket_Sort 
+public class BucketSort 
 {
     static int[] sort(int[] sequence, int maxValue) 
     {

File: Sorts/SelectionSort.java
Patch:
@@ -10,10 +10,12 @@ public class SelectionSort implements SortAlgorithm {
 
     /**
      * This method swaps the two elements in the array
+     * @param <T>
      * @param arr, i, j The array for the swap and 
                         the indexes of the to-swap elements
      */
-    public void swap(T[] arr, int i, int j) {
+    
+    public <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;

File: Sorts/SelectionSort.java
Patch:
@@ -10,10 +10,12 @@ public class SelectionSort implements SortAlgorithm {
 
     /**
      * This method swaps the two elements in the array
+     * @param <T>
      * @param arr, i, j The array for the swap and 
                         the indexes of the to-swap elements
      */
-    public void swap(T[] arr, int i, int j) {
+    
+    public <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;

File: Others/3 sum.java
Patch:
@@ -53,8 +53,8 @@ public static void main(String args[])
 				else r--;
 			}
 		}
-		
 
+		sc.close();
 		
 	}
 }
\ No newline at end of file

File: Sorts/BucketSort.java
Patch:
@@ -1,7 +1,8 @@
+package Sorts;
 
 import java.util.Random;
  
-public class Bucket_Sort 
+public class BucketSort 
 {
     static int[] sort(int[] sequence, int maxValue) 
     {

File: Maths/ParseInteger.java
Patch:
@@ -16,7 +16,7 @@ public static void main(String[] args) {
      * @throws NumberFormatException if the {@code string} does not contain a parsable integer.
      */
     public static int parseInt(String s) {
-        if (s == null) {
+        if (s == null || s.length() == 0) {
             throw new NumberFormatException("null");
         }
         boolean isNegative = s.charAt(0) == '-';

File: Conversions/DecimalToBinary.java
Patch:
@@ -27,7 +27,7 @@ public static void main(String args[]) {
     public static void conventionalConversion() {
         int n, b = 0, c = 0, d;
         Scanner input = new Scanner(System.in);
-        System.out.printf("Conventional conversion.\n\tEnter the decimal number: ");
+        System.out.printf("Conventional conversion.%n Enter the decimal number: ");
         n = input.nextInt();
         while (n != 0) {
             d = n % 2;
@@ -46,7 +46,7 @@ public static void conventionalConversion() {
     public static void bitwiseConversion() {
         int n, b = 0, c = 0, d;
         Scanner input = new Scanner(System.in);
-        System.out.printf("Bitwise conversion.\n\tEnter the decimal number: ");
+        System.out.printf("Bitwise conversion.%n Enter the decimal number: ");
         n = input.nextInt();
         while (n != 0) {
             d = (n & 1);

File: DataStructures/DynamicArray/DynamicArray.java
Patch:
@@ -41,7 +41,7 @@ public void add(final E element) {
     }
 
     public void put(final int index, E element) {
-        Objects.checkIndex(index, this.size);
+//        Objects.checkIndex(index, this.size);
 
         this.elements[index] = element;
     }
@@ -79,7 +79,7 @@ private void fastRemove(final Object[] elements, final int index) {
     }
 
     private E getElement(final int index) {
-        Objects.checkIndex(index, this.size);
+//        Objects.checkIndex(index, this.size);
         return (E) this.elements[index];
     }
 

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -23,7 +23,7 @@ class Edge
         * @param v End vertex
         * @param c Weight
         */
-        Edge(int a,int b,int c)
+        public Edge(int a,int b,int c)
         {
             u=a;
             v=b;

File: DataStructures/Graphs/MatrixGraphs.java
Patch:
@@ -127,8 +127,7 @@ public boolean removeEdge(int from, int to) {
      * @return returns a string describing this graph
      */
     public String toString() {
-        String s = new String();
-        s = "    ";
+        String s = "    ";
         for (int i = 0; i < this.numberOfVertices(); i++) {
             s = s + String.valueOf(i) + " ";
         }

File: DataStructures/Lists/CircleLinkedList.java
Patch:
@@ -14,7 +14,7 @@ private Node(E value, Node<E> next) {
     //For better O.O design this should be private allows for better black box design
     private int size;
     //this will point to dummy node;
-    private Node<E> head;
+    private Node<E> head =  null;
 
     //constructer for class.. here we will make a dummy node for circly linked list implementation with reduced error catching as our list will never be empty;
     public CircleLinkedList() {

File: DataStructures/Stacks/NodeStack.java
Patch:
@@ -74,7 +74,7 @@ public void push(Item item) {
         } else {
         	newNs.setPrevious(NodeStack.head);
         	NodeStack.head.setNext(newNs);
-        	NodeStack.head = newNs;
+        	NodeStack.head.setHead(newNs);
         }
 
         NodeStack.setSize(NodeStack.getSize() + 1);
@@ -89,7 +89,7 @@ public Item pop() {
 
     	Item item = (Item) NodeStack.head.getData();
 
-    	NodeStack.head = NodeStack.head.getPrevious();
+        NodeStack.head.setHead(NodeStack.head.getPrevious());
     	NodeStack.head.setNext(null);
 
     	NodeStack.setSize(NodeStack.getSize() - 1);

File: DataStructures/Trees/LevelOrderTraversal.java
Patch:
@@ -15,8 +15,8 @@ public Node(int item) {
     // Root of the Binary Tree
     Node root;
 
-    public LevelOrderTraversal() {
-        root = null;
+    public LevelOrderTraversal( Node root) {
+        this.root = root;
     }
 
     /* function to print level order traversal of tree*/

File: DataStructures/Trees/LevelOrderTraversalQueue.java
Patch:
@@ -19,11 +19,9 @@ public Node(int item) {
         }
     }
 
-    Node root;
-
     /* Given a binary tree. Print its nodes in level order
      using array for implementing queue  */
-    void printLevelOrder() {
+    void printLevelOrder(Node root) {
         Queue<Node> queue = new LinkedList<Node>();
         queue.add(root);
         while (!queue.isEmpty()) {

File: DataStructures/Trees/ValidBSTOrNot.java
Patch:
@@ -13,14 +13,13 @@ public Node(int item) {
     }
 
     //Root of the Binary Tree
-    Node root;
  
     /* can give min and max value according to your code or
     can write a function to find min and max value of tree. */
 
     /* returns true if given search tree is binary
      search tree (efficient version) */
-    boolean isBST() {
+    boolean isBST(Node root) {
         return isBSTUtil(root, Integer.MIN_VALUE,
                 Integer.MAX_VALUE);
     }

File: DynamicProgramming/LongestIncreasingSubsequence.java
Patch:
@@ -22,7 +22,7 @@ public static void main(String[] args) {
 
     private static int upperBound(int[] ar, int l, int r, int key) {
         while (l < r - 1) {
-            int m = (l + r) / 2;
+            int m = (l + r) >>> 1;
             if (ar[m] >= key)
                 r = m;
             else

File: DynamicProgramming/MatrixChainMultiplication.java
Patch:
@@ -25,7 +25,7 @@ public static void main(String[] args) {
             count++;
         }
         for (Matrix m : mArray) {
-            System.out.format("A(%d)  =  %2d  x  %2d\n", m.count(), m.col(), m.row());
+            System.out.format("A(%d)  =  %2d  x  %2d%n", m.count(), m.col(), m.row());
         }
 
         size = mArray.size();

File: Maths/GCD.java
Patch:
@@ -52,6 +52,6 @@ public static void main(String[] args) {
 
         // call gcd function (input array)
         System.out.println(gcd(myIntArray)); // => 4
-        System.out.printf("gcd(40,24)=%d gcd(24,40)=%d\n", gcd(40, 24), gcd(24, 40)); // => 8
+        System.out.printf("gcd(40,24)=%d gcd(24,40)=%d%n", gcd(40, 24), gcd(24, 40)); // => 8
     }
 }

File: Others/TopKWords.java
Patch:
@@ -50,7 +50,8 @@ public Map<String, Integer> getDictionary() {
             } finally {
                 try {
                     // you always have to close the I/O streams
-                    fis.close();
+                    if (fis != null)
+                        fis.close();
                 } catch (IOException e) {
                     e.printStackTrace();
                 }

File: Others/TowerOfHanoi.java
Patch:
@@ -12,7 +12,7 @@ public static void shift(int n, String startPole, String intermediatePole, Strin
 
         // Shift function is called in recursion for swapping the n-1 disc from the startPole to the intermediatePole
         shift(n - 1, startPole, endPole, intermediatePole);
-        System.out.println("\nMove \"" + n + "\" from " + startPole + " --> " + endPole); // Result Printing
+        System.out.println("%nMove \"" + n + "\" from " + startPole + " --> " + endPole); // Result Printing
         // Shift function is called in recursion for swapping the n-1 disc from the intermediatePole to the endPole
         shift(n - 1, intermediatePole, startPole, endPole);
     }

File: Searches/IterativeBinarySearch.java
Patch:
@@ -40,7 +40,7 @@ public <T extends Comparable<T>> int find(T[] array, T key) {
         r = array.length - 1;
 
         while (l <= r) {
-            k = (l + r) / 2;
+            k = (l + r) >>> 1;
             cmp = key.compareTo(array[k]);
 
             if (cmp == 0) {

File: Sorts/QuickSort.java
Patch:
@@ -64,7 +64,7 @@ private static <T extends Comparable<T>> int randomPartition(T[] array, int left
      **/
 
     private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {
-        int mid = (left + right) / 2;
+        int mid = (left + right) >>> 1;
         T pivot = array[mid];
 
         while (left <= right) {

File: ciphers/Caesar.java
Patch:
@@ -125,6 +125,8 @@ public static void main(String[] args) {
             case 'D':
             case 'd':
                 System.out.println("DECODED MESSAGE IS \n" + decode(message, shift));
+            default:
+                System.out.println("default case");
         }
         input.close();
     }

File: ciphers/ColumnarTranspositionCipher.java
Patch:
@@ -117,7 +117,7 @@ private static Object[][] tableBuilder(String word) {
      * order to respect the Columnar Transposition Cipher Rule.
      */
     private static int numberOfRows(String word) {
-        if ((double) word.length() / keyword.length() > word.length() / keyword.length()) {
+        if (word.length() / keyword.length() > word.length() / keyword.length()) {
             return (word.length() / keyword.length()) + 1;
         } else {
             return word.length() / keyword.length();

File: Conversions/DecimalToBinary.java
Patch:
@@ -27,7 +27,7 @@ public static void main(String args[]) {
     public static void conventionalConversion() {
         int n, b = 0, c = 0, d;
         Scanner input = new Scanner(System.in);
-        System.out.printf("Conventional conversion.\n\tEnter the decimal number: ");
+        System.out.printf("Conventional conversion.%n Enter the decimal number: ");
         n = input.nextInt();
         while (n != 0) {
             d = n % 2;
@@ -46,7 +46,7 @@ public static void conventionalConversion() {
     public static void bitwiseConversion() {
         int n, b = 0, c = 0, d;
         Scanner input = new Scanner(System.in);
-        System.out.printf("Bitwise conversion.\n\tEnter the decimal number: ");
+        System.out.printf("Bitwise conversion.%n Enter the decimal number: ");
         n = input.nextInt();
         while (n != 0) {
             d = (n & 1);

File: DataStructures/DynamicArray/DynamicArray.java
Patch:
@@ -41,7 +41,7 @@ public void add(final E element) {
     }
 
     public void put(final int index, E element) {
-        Objects.checkIndex(index, this.size);
+//        Objects.checkIndex(index, this.size);
 
         this.elements[index] = element;
     }
@@ -79,7 +79,7 @@ private void fastRemove(final Object[] elements, final int index) {
     }
 
     private E getElement(final int index) {
-        Objects.checkIndex(index, this.size);
+//        Objects.checkIndex(index, this.size);
         return (E) this.elements[index];
     }
 

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -23,7 +23,7 @@ class Edge
         * @param v End vertex
         * @param c Weight
         */
-        Edge(int a,int b,int c)
+        public Edge(int a,int b,int c)
         {
             u=a;
             v=b;

File: DataStructures/Graphs/MatrixGraphs.java
Patch:
@@ -127,8 +127,7 @@ public boolean removeEdge(int from, int to) {
      * @return returns a string describing this graph
      */
     public String toString() {
-        String s = new String();
-        s = "    ";
+        String s = "    ";
         for (int i = 0; i < this.numberOfVertices(); i++) {
             s = s + String.valueOf(i) + " ";
         }

File: DataStructures/Lists/CircleLinkedList.java
Patch:
@@ -14,7 +14,7 @@ private Node(E value, Node<E> next) {
     //For better O.O design this should be private allows for better black box design
     private int size;
     //this will point to dummy node;
-    private Node<E> head;
+    private Node<E> head =  null;
 
     //constructer for class.. here we will make a dummy node for circly linked list implementation with reduced error catching as our list will never be empty;
     public CircleLinkedList() {

File: DataStructures/Stacks/NodeStack.java
Patch:
@@ -74,7 +74,7 @@ public void push(Item item) {
         } else {
         	newNs.setPrevious(NodeStack.head);
         	NodeStack.head.setNext(newNs);
-        	NodeStack.head = newNs;
+        	NodeStack.head.setHead(newNs);
         }
 
         NodeStack.setSize(NodeStack.getSize() + 1);
@@ -89,7 +89,7 @@ public Item pop() {
 
     	Item item = (Item) NodeStack.head.getData();
 
-    	NodeStack.head = NodeStack.head.getPrevious();
+        NodeStack.head.setHead(NodeStack.head.getPrevious());
     	NodeStack.head.setNext(null);
 
     	NodeStack.setSize(NodeStack.getSize() - 1);

File: DataStructures/Trees/LevelOrderTraversal.java
Patch:
@@ -15,8 +15,8 @@ public Node(int item) {
     // Root of the Binary Tree
     Node root;
 
-    public LevelOrderTraversal() {
-        root = null;
+    public LevelOrderTraversal( Node root) {
+        this.root = root;
     }
 
     /* function to print level order traversal of tree*/

File: DataStructures/Trees/LevelOrderTraversalQueue.java
Patch:
@@ -19,11 +19,9 @@ public Node(int item) {
         }
     }
 
-    Node root;
-
     /* Given a binary tree. Print its nodes in level order
      using array for implementing queue  */
-    void printLevelOrder() {
+    void printLevelOrder(Node root) {
         Queue<Node> queue = new LinkedList<Node>();
         queue.add(root);
         while (!queue.isEmpty()) {

File: DataStructures/Trees/ValidBSTOrNot.java
Patch:
@@ -13,14 +13,13 @@ public Node(int item) {
     }
 
     //Root of the Binary Tree
-    Node root;
  
     /* can give min and max value according to your code or
     can write a function to find min and max value of tree. */
 
     /* returns true if given search tree is binary
      search tree (efficient version) */
-    boolean isBST() {
+    boolean isBST(Node root) {
         return isBSTUtil(root, Integer.MIN_VALUE,
                 Integer.MAX_VALUE);
     }

File: DynamicProgramming/LongestIncreasingSubsequence.java
Patch:
@@ -22,7 +22,7 @@ public static void main(String[] args) {
 
     private static int upperBound(int[] ar, int l, int r, int key) {
         while (l < r - 1) {
-            int m = (l + r) / 2;
+            int m = (l + r) >>> 1;
             if (ar[m] >= key)
                 r = m;
             else

File: DynamicProgramming/MatrixChainMultiplication.java
Patch:
@@ -25,7 +25,7 @@ public static void main(String[] args) {
             count++;
         }
         for (Matrix m : mArray) {
-            System.out.format("A(%d)  =  %2d  x  %2d\n", m.count(), m.col(), m.row());
+            System.out.format("A(%d)  =  %2d  x  %2d%n", m.count(), m.col(), m.row());
         }
 
         size = mArray.size();

File: Maths/GCD.java
Patch:
@@ -52,6 +52,6 @@ public static void main(String[] args) {
 
         // call gcd function (input array)
         System.out.println(gcd(myIntArray)); // => 4
-        System.out.printf("gcd(40,24)=%d gcd(24,40)=%d\n", gcd(40, 24), gcd(24, 40)); // => 8
+        System.out.printf("gcd(40,24)=%d gcd(24,40)=%d%n", gcd(40, 24), gcd(24, 40)); // => 8
     }
 }

File: Others/TopKWords.java
Patch:
@@ -50,7 +50,8 @@ public Map<String, Integer> getDictionary() {
             } finally {
                 try {
                     // you always have to close the I/O streams
-                    fis.close();
+                    if (fis != null)
+                        fis.close();
                 } catch (IOException e) {
                     e.printStackTrace();
                 }

File: Others/TowerOfHanoi.java
Patch:
@@ -12,7 +12,7 @@ public static void shift(int n, String startPole, String intermediatePole, Strin
 
         // Shift function is called in recursion for swapping the n-1 disc from the startPole to the intermediatePole
         shift(n - 1, startPole, endPole, intermediatePole);
-        System.out.println("\nMove \"" + n + "\" from " + startPole + " --> " + endPole); // Result Printing
+        System.out.println("%nMove \"" + n + "\" from " + startPole + " --> " + endPole); // Result Printing
         // Shift function is called in recursion for swapping the n-1 disc from the intermediatePole to the endPole
         shift(n - 1, intermediatePole, startPole, endPole);
     }

File: Searches/IterativeBinarySearch.java
Patch:
@@ -40,7 +40,7 @@ public <T extends Comparable<T>> int find(T[] array, T key) {
         r = array.length - 1;
 
         while (l <= r) {
-            k = (l + r) / 2;
+            k = (l + r) >>> 1;
             cmp = key.compareTo(array[k]);
 
             if (cmp == 0) {

File: Sorts/QuickSort.java
Patch:
@@ -64,7 +64,7 @@ private static <T extends Comparable<T>> int randomPartition(T[] array, int left
      **/
 
     private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {
-        int mid = (left + right) / 2;
+        int mid = (left + right) >>> 1;
         T pivot = array[mid];
 
         while (left <= right) {

File: ciphers/Caesar.java
Patch:
@@ -125,6 +125,8 @@ public static void main(String[] args) {
             case 'D':
             case 'd':
                 System.out.println("DECODED MESSAGE IS \n" + decode(message, shift));
+            default:
+                System.out.println("default case");
         }
         input.close();
     }

File: ciphers/ColumnarTranspositionCipher.java
Patch:
@@ -117,7 +117,7 @@ private static Object[][] tableBuilder(String word) {
      * order to respect the Columnar Transposition Cipher Rule.
      */
     private static int numberOfRows(String word) {
-        if ((double) word.length() / keyword.length() > word.length() / keyword.length()) {
+        if (word.length() / keyword.length() > word.length() / keyword.length()) {
             return (word.length() / keyword.length()) + 1;
         } else {
             return word.length() / keyword.length();

File: Maths/PrimeFactorization.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.Math;
 import java.util.Scanner;
 
-public class algorithm {
+public class PrimeFactorization {
     public static void main(String[] args){
         System.out.println("## all prime factors ##");
         Scanner scanner = new Scanner(System.in);

File: Maths/PrimeFactorization.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.Math;
 import java.util.Scanner;
 
-public class algorithm {
+public class PrimeFactorization {
     public static void main(String[] args){
         System.out.println("## all prime factors ##");
         Scanner scanner = new Scanner(System.in);

File: DataStructures/Graphs/ConnectedComponent.java
Patch:
@@ -108,7 +108,7 @@ public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited) {
 public class ConnectedComponent {
 
     public static void main(String[] args) {
-        Graph graphChars = new Graph();
+        Graph<Character> graphChars = new Graph<>();
 
         // Graph 1
         graphChars.addEdge('a', 'b');
@@ -123,7 +123,7 @@ public static void main(String[] args) {
 
         graphChars.addEdge('w', 'w');
 
-        Graph graphInts = new Graph();
+        Graph<Integer> graphInts = new Graph<>();
 
         // Graph 2
         graphInts.addEdge(1, 2);

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Graphs;
+
 import java.util.*;
 class BellmanFord
 /*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have 

File: DataStructures/Queues/LinkedQueue.java
Patch:
@@ -1,4 +1,4 @@
-package DataStructures;
+package DataStructures.Queues;
 
 import java.util.NoSuchElementException;
 

File: DataStructures/Stacks/NodeStack.java
Patch:
@@ -1,3 +1,4 @@
+package DataStructures.Stacks;
 /**
 * Implementation of a stack using nodes.
 * Unlimited size, no arraylist.

File: DataStructures/Stacks/StackArray.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Stacks;
+
 /**
  * This class implements a Stack using a regular array.
  * <p>

File: DataStructures/Stacks/StackArrayList.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Stacks;
+
 import java.util.ArrayList;
 
 /**

File: DataStructures/Stacks/StackOfLinkedList.java
Patch:
@@ -1,5 +1,7 @@
 package DataStructures.Stacks;
 
+import java.util.NoSuchElementException;
+
 /**
  * @author Varun Upadhyay (https://github.com/varunu28)
  */

File: Maths/Pow.java
Patch:
@@ -1,4 +1,4 @@
-package maths;
+package Maths;
 
 //POWER (exponentials) Examples (a^b)
 public class Pow {

File: DataStructures/Graphs/BellmanFord.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Graphs;
+
 import java.util.*;
 class BellmanFord
 /*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have 

File: DataStructures/Queues/LinkedQueue.java
Patch:
@@ -1,4 +1,4 @@
-package DataStructures;
+package DataStructures.Queues;
 
 import java.util.NoSuchElementException;
 

File: DataStructures/Stacks/NodeStack.java
Patch:
@@ -1,3 +1,4 @@
+package DataStructures.Stacks;
 /**
 * Implementation of a stack using nodes.
 * Unlimited size, no arraylist.

File: DataStructures/Stacks/StackArray.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Stacks;
+
 /**
  * This class implements a Stack using a regular array.
  * <p>

File: DataStructures/Stacks/StackArrayList.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Stacks;
+
 import java.util.ArrayList;
 
 /**

File: DataStructures/Stacks/StackOfLinkedList.java
Patch:
@@ -1,5 +1,7 @@
 package DataStructures.Stacks;
 
+import java.util.NoSuchElementException;
+
 /**
  * @author Varun Upadhyay (https://github.com/varunu28)
  */

File: Maths/Pow.java
Patch:
@@ -1,4 +1,4 @@
-package maths;
+package Maths;
 
 //POWER (exponentials) Examples (a^b)
 public class Pow {

File: Sorts/BogoSort.java
Patch:
@@ -12,15 +12,15 @@ public class BogoSort implements SortAlgorithm {
     private static final Random random = new Random();
 
 
-    private static <T extends Comparable<T>> boolean isSorted(T array[]) {
+    private static <T extends Comparable<T>> boolean isSorted(T[] array) {
         for (int i = 0; i < array.length - 1; i++) {
             if (SortUtils.less(array[i + 1], array[i])) return false;
         }
         return true;
     }
 
     // Randomly shuffles the array
-    private static <T> void nextPermutation(T array[]) {
+    private static <T> void nextPermutation(T[] array) {
         int length = array.length;
 
         for (int i = 0; i < array.length; i++) {
@@ -29,7 +29,7 @@ private static <T> void nextPermutation(T array[]) {
         }
     }
 
-    public <T extends Comparable<T>> T[] sort(T array[]) {
+    public <T extends Comparable<T>> T[] sort(T[] array) {
         while (!isSorted(array)) {
             nextPermutation(array);
         }

File: Sorts/BubbleSort.java
Patch:
@@ -17,7 +17,7 @@ class BubbleSort implements SortAlgorithm {
      **/
 
     @Override
-    public <T extends Comparable<T>> T[] sort(T array[]) {
+    public <T extends Comparable<T>> T[] sort(T[] array) {
         for (int i = 0, size = array.length; i < size - 1; ++i) {
             boolean swapped = false;
             for (int j = 0; j < size - 1 - i; ++j) {

File: Sorts/CombSort.java
Patch:
@@ -33,7 +33,7 @@ private int nextGap(int gap) {
      * @return sorted array
      */
     @Override
-    public <T extends Comparable<T>> T[] sort(T arr[]) {
+    public <T extends Comparable<T>> T[] sort(T[] arr) {
         int size = arr.length;
 
         // initialize gap
@@ -62,9 +62,9 @@ public <T extends Comparable<T>> T[] sort(T arr[]) {
     }
 
     // Driver method
-    public static void main(String args[]) {
+    public static void main(String[] args) {
         CombSort ob = new CombSort();
-        Integer arr[] = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};
+        Integer[] arr = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};
         ob.sort(arr);
 
         System.out.println("sorted array");

File: Sorts/BogoSort.java
Patch:
@@ -12,15 +12,15 @@ public class BogoSort implements SortAlgorithm {
     private static final Random random = new Random();
 
 
-    private static <T extends Comparable<T>> boolean isSorted(T array[]) {
+    private static <T extends Comparable<T>> boolean isSorted(T[] array) {
         for (int i = 0; i < array.length - 1; i++) {
             if (SortUtils.less(array[i + 1], array[i])) return false;
         }
         return true;
     }
 
     // Randomly shuffles the array
-    private static <T> void nextPermutation(T array[]) {
+    private static <T> void nextPermutation(T[] array) {
         int length = array.length;
 
         for (int i = 0; i < array.length; i++) {
@@ -29,7 +29,7 @@ private static <T> void nextPermutation(T array[]) {
         }
     }
 
-    public <T extends Comparable<T>> T[] sort(T array[]) {
+    public <T extends Comparable<T>> T[] sort(T[] array) {
         while (!isSorted(array)) {
             nextPermutation(array);
         }

File: Sorts/BubbleSort.java
Patch:
@@ -17,7 +17,7 @@ class BubbleSort implements SortAlgorithm {
      **/
 
     @Override
-    public <T extends Comparable<T>> T[] sort(T array[]) {
+    public <T extends Comparable<T>> T[] sort(T[] array) {
         for (int i = 0, size = array.length; i < size - 1; ++i) {
             boolean swapped = false;
             for (int j = 0; j < size - 1 - i; ++j) {

File: Sorts/CombSort.java
Patch:
@@ -33,7 +33,7 @@ private int nextGap(int gap) {
      * @return sorted array
      */
     @Override
-    public <T extends Comparable<T>> T[] sort(T arr[]) {
+    public <T extends Comparable<T>> T[] sort(T[] arr) {
         int size = arr.length;
 
         // initialize gap
@@ -62,9 +62,9 @@ public <T extends Comparable<T>> T[] sort(T arr[]) {
     }
 
     // Driver method
-    public static void main(String args[]) {
+    public static void main(String[] args) {
         CombSort ob = new CombSort();
-        Integer arr[] = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};
+        Integer[] arr = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};
         ob.sort(arr);
 
         System.out.println("sorted array");

File: Maths/FindMin.java
Patch:
@@ -5,7 +5,7 @@ public class FindMin {
     //Driver
     public static void main(String[] args) {
         int[] array = {2, 4, 9, 7, 19, 94, 5};
-        System.out.println("min = " + findMax(array));
+        System.out.println("min = " + findMin(array));
     }
 
     /**
@@ -14,7 +14,7 @@ public static void main(String[] args) {
      * @param array the array contains element
      * @return min value
      */
-    public static int findMax(int[] array) {
+    public static int findMin(int[] array) {
         int min = array[0];
         for (int i = 1; i < array.length; ++i) {
             if (array[i] < min) {

File: DataStructures/Lists/SinglyLinkedList.java
Patch:
@@ -61,7 +61,9 @@ public void deleteHead() {
             throw new RuntimeException("The list is empty!");
         }
 
+        Node destroy = head;
         head = head.next;
+        destroy = null;  // clear to let GC do its work
     }
 
     /**

File: DataStructures/Lists/SinglyLinkedList.java
Patch:
@@ -61,7 +61,9 @@ public void deleteHead() {
             throw new RuntimeException("The list is empty!");
         }
 
+        Node destroy = head;
         head = head.next;
+        destroy = null;  // clear to let GC do its work
     }
 
     /**

File: DataStructures/Stacks/StackArray.java
Patch:
@@ -109,14 +109,13 @@ public int peek() {
     }
 
     private void resize(int newSize) {
-        // private int[] transferArray = new int[newSize]; we can't put modifiers here !
         int[] transferArray = new int[newSize];
 
-        // for(int i = 0; i < stackArray.length(); i++){ the length isn't a method .
         for (int i = 0; i < stackArray.length; i++) {
             transferArray[i] = stackArray[i];
-            stackArray = transferArray;
         }
+        // This reference change might be nice in here
+        stackArray = transferArray;
         maxSize = newSize;
     }
 

File: DataStructures/Stacks/StackArray.java
Patch:
@@ -109,14 +109,13 @@ public int peek() {
     }
 
     private void resize(int newSize) {
-        // private int[] transferArray = new int[newSize]; we can't put modifiers here !
         int[] transferArray = new int[newSize];
 
-        // for(int i = 0; i < stackArray.length(); i++){ the length isn't a method .
         for (int i = 0; i < stackArray.length; i++) {
             transferArray[i] = stackArray[i];
-            stackArray = transferArray;
         }
+        // This reference change might be nice in here
+        stackArray = transferArray;
         maxSize = newSize;
     }
 

File: DataStructures/Lists/SinglyLinkedList.java
Patch:
@@ -68,7 +68,7 @@ public void deleteHead() {
      * This method deletes an element at Nth position
      */
     public void deleteNth(int position) {
-        if (position < 0 || position > getSize()) {
+        if (position < 0 || position >= getSize()) {
             throw new RuntimeException("position less than zero or position more than the count of list");
         } else if (position == 0)
             deleteHead();

File: DataStructures/Lists/CircleLinkedList.java
Patch:
@@ -52,7 +52,7 @@ public E remove(int pos) {
             before = before.next;
         }
         E saved = iterator.value;
-        // assigning the next referance to the the element following the element we want to remove... the last element will be assigned to the head.
+        // assigning the next reference to the the element following the element we want to remove... the last element will be assigned to the head.
         before.next = iterator.next;
         // scrubbing
         iterator.next = null;

File: Conversions/HexaDecimalToDecimal.java
Patch:
@@ -6,7 +6,7 @@ public class HexaDecimalToDecimal {
 
     // convert hexadecimal to decimal
     public static int getHexaToDec(String hex) {
-        String digits = "012345678910ABCDEFF";
+        String digits = "0123456789ABCDEF";
         hex = hex.toUpperCase();
         int val = 0;
         for (int i = 0; i < hex.length(); i++) {

File: Conversions/AnyBaseToDecimal.java
Patch:
@@ -1,3 +1,5 @@
+package Conversions;
+
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 

File: Conversions/AnytoAny.java
Patch:
@@ -1,4 +1,4 @@
-package Java.Conversions;
+package Conversions;
 
 import java.util.Scanner;
 //given a source number , source base, destination base, this code can give you the destination number.

File: Conversions/DecimalToAnyBase.java
Patch:
@@ -1,3 +1,5 @@
+package Conversions;
+
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.ArrayList;

File: Conversions/DecimalToHexaDecimal.java
Patch:
@@ -1,3 +1,4 @@
+package Conversions;
 
 class DecimalToHexaDecimal {
 	private static final int sizeOfIntInHalfBytes = 8;

File: Conversions/HexaDecimalToBinary.java
Patch:
@@ -1,3 +1,5 @@
+package Conversions;
+
 public class HexaDecimalToBinary {
 
     private final int LONG_BITS = 8;

File: Conversions/OctalToDecimal.java
Patch:
@@ -1,3 +1,5 @@
+package Conversions;
+
 import java.util.Scanner;
 
 /**

File: Conversions/RomanToInteger.java
Patch:
@@ -1,8 +1,10 @@
+package Conversions;
+
 import java.util.*;
 
 public class RomanToInteger {
 
-    private static Map<Character, Integer> map = new HashMap<>() {{
+    private static Map<Character, Integer> map = new HashMap<Character, Integer>() {{
         put('I', 1);
         put('V', 5);
         put('X', 10);

File: DataStructures/HashMap/Hashing/LinkedList.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.HashMap.Hashing;
+
 class LinkedList {
 
 	private Node Head;

File: DataStructures/HashMap/Hashing/Main.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.HashMap.Hashing;
+
 import java.util.Scanner;
 
 public class Main {

File: DataStructures/HashMap/Hashing/Node.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.HashMap.Hashing;
+
 class Node {
 	int data;
 	Node next;

File: DataStructures/Heaps/EmptyHeapException.java
Patch:
@@ -1,6 +1,3 @@
-/**
- *
- */
 package DataStructures.Heaps;
 
 /**

File: DataStructures/Heaps/HeapElement.java
Patch:
@@ -1,6 +1,3 @@
-/**
- *
- */
 package DataStructures.Heaps;
 
 import java.lang.Double;

File: DataStructures/Heaps/MinHeap.java
Patch:
@@ -1,6 +1,3 @@
-/**
- *
- */
 package DataStructures.Heaps;
 
 import java.util.ArrayList;

File: DataStructures/Lists/DoublyLinkedList.java
Patch:
@@ -1,3 +1,4 @@
+package DataStructures.Lists;
 
 /**
  * This class implements a DoublyLinkedList. This is done using the classes
@@ -13,7 +14,7 @@
  * @author Unknown
  */
 
-class DoublyLinkedList {
+public class DoublyLinkedList {
     /**
      * Head refers to the front of the list
      */

File: DataStructures/Lists/Merge_K_SortedLinkedlist.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Lists;
+
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.PriorityQueue;

File: DataStructures/Queues/GenericArrayListQueue.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Queues;
+
 import java.util.ArrayList;
 
 public class GenericArrayListQueue<T> {

File: DataStructures/Queues/PriorityQueues.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Queues;
+
 /**
  * This class implements a PriorityQueue.
  * <p>
@@ -6,7 +8,6 @@
  * In this example I give numbers that are bigger, a higher priority.
  * Queues in theory have no fixed size but when using an array
  * implementation it does.
- *
  */
 class PriorityQueue {
     /**

File: DataStructures/Queues/Queues.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Queues;
+
 /**
  * This implements Queues by using the class Queue.
  * <p>

File: DataStructures/Stacks/StackOfLinkedList.java
Patch:
@@ -1,3 +1,5 @@
+package DataStructures.Stacks;
+
 /**
  * @author Varun Upadhyay (https://github.com/varunu28)
  */

File: DynamicProgramming/Fibonacci.java
Patch:
@@ -1,11 +1,12 @@
+package DynamicProgramming;
+
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * @author Varun Upadhyay (https://github.com/varunu28)
- * @author yanglbme (https://github.com/yanglbme)
  */
 
 public class Fibonacci {

File: DynamicProgramming/LevenshteinDistance.java
Patch:
@@ -1,3 +1,5 @@
+package DynamicProgramming;
+
 /**
  * @author Kshitij VERMA (github.com/kv19971)
  * LEVENSHTEIN DISTANCE dyamic programming implementation to show the difference between two strings (https://en.wikipedia.org/wiki/Levenshtein_distance)

File: DynamicProgramming/LongestIncreasingSubsequence.java
Patch:
@@ -1,8 +1,9 @@
+package DynamicProgramming;
+
 import java.util.Scanner;
 
 /**
  * @author Afrizal Fikri (https://github.com/icalF)
- * @author Libin Yang (https://github.com/yanglbme)
  */
 public class LongestIncreasingSubsequence {
     public static void main(String[] args) {

File: DynamicProgramming/LongestValidParentheses.java
Patch:
@@ -1,3 +1,5 @@
+package DynamicProgramming;
+
 import java.util.Scanner;
 
 /**

File: DynamicProgramming/MatrixChainMultiplication.java
Patch:
@@ -1,3 +1,5 @@
+package DynamicProgramming;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Scanner;

File: Others/CRC32.java
Patch:
@@ -1,3 +1,5 @@
+package Others;
+
 import java.util.BitSet;
 
 /**

File: Others/Palindrome.java
Patch:
@@ -1,3 +1,5 @@
+package Others;
+
 class Palindrome {
 
     private String reverseString(String x) { // *helper method

File: Others/QueueUsingTwoStacks.java
Patch:
@@ -1,3 +1,5 @@
+package Others;
+
 import java.util.Stack;
 
 /**

File: Others/RootPrecision.java
Patch:
@@ -1,3 +1,5 @@
+package Others;
+
 import java.util.Scanner;
 
 public class RootPrecision {

File: Searches/SaddlebackSearch.java
Patch:
@@ -27,10 +27,10 @@ public class SaddlebackSearch {
     /**
      * This method performs Saddleback Search
      *
-     * @param arr  The **Sorted** array in which we will search the element.
+     * @param arr The **Sorted** array in which we will search the element.
      * @param row the current row.
      * @param col the current column.
-     * @param key  the element that we want to search for.
+     * @param key the element that we want to search for.
      * @return The index(row and column) of the element if found.
      * Else returns -1 -1.
      */

File: divideconquer/SkylineAlgorithm.java
Patch:
@@ -1,3 +1,5 @@
+package divideconquer;
+
 import java.util.ArrayList;
 import java.util.Comparator;
 
@@ -42,7 +44,6 @@ public ArrayList<Point> getPoints() {
      * @param list, the initial list of points
      * @return leftSkyLine, the combination of first half's and second half's skyline
      * @see Point
-     * @see produceFinalSkyLine
      */
     public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) {
 
@@ -72,7 +73,7 @@ public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) {
             }
         }
         ArrayList<Point> leftSubSkyLine = produceSubSkyLines(leftHalf);
-        ArrayList<Point> rightSubSkyLine= produceSubSkyLines(rightHalf);
+        ArrayList<Point> rightSubSkyLine = produceSubSkyLines(rightHalf);
 
         // skyline is produced
         return produceFinalSkyLine(leftSubSkyLine, rightSubSkyLine);

File: DataStructures/Heaps/EmptyHeapException.java
Patch:
@@ -1,7 +1,7 @@
 /**
  *
  */
-package Heaps;
+package DataStructures.Heaps;
 
 /**
  * @author Nicolas Renard

File: DataStructures/Heaps/Heap.java
Patch:
@@ -1,4 +1,4 @@
-package Heaps;
+package DataStructures.Heaps;
 
 /**
  * Interface common to heap data structures.<br>

File: DataStructures/Heaps/HeapElement.java
Patch:
@@ -1,7 +1,7 @@
 /**
  *
  */
-package Heaps;
+package DataStructures.Heaps;
 
 import java.lang.Double;
 import java.lang.Object;

File: DataStructures/Heaps/MaxHeap.java
Patch:
@@ -1,4 +1,4 @@
-package Heaps;
+package DataStructures.Heaps;
 
 import java.util.ArrayList;
 import java.util.List;

File: DataStructures/Heaps/MinHeap.java
Patch:
@@ -1,7 +1,7 @@
 /**
  *
  */
-package Heaps;
+package DataStructures.Heaps;
 
 import java.util.ArrayList;
 import java.util.List;

File: DataStructures/Heaps/MinPriorityQueue.java
Patch:
@@ -1,4 +1,4 @@
-package Heaps;
+package DataStructures.Heaps;
 /* Minimum Priority Queue
  * It is a part of heap data structure
  * A heap is a specific tree based data structure

File: DataStructures/CSVFile/src/CSVFile.java
Patch:
@@ -136,7 +136,7 @@ public CSVFile(char separator) {
 		table = new ArrayList<ArrayList<String>>();
 		trackList = new ArrayList<Integer>();
 		pathCSVFile = "";
-		this.seperator = seperator;
+		this.seperator = separator;
 	}
 
 	

File: Searches/BinarySearch.java
Patch:
@@ -72,7 +72,7 @@ private <T extends Comparable<T>> int search(T array[], T key, int left, int rig
     // Driver Program
     public static void main(String[] args) {
         // Just generate data
-        Random random = ThreadLocalRandom.current();
+        Random r = ThreadLocalRandom.current();
         
         int size = 100;
         int maxElement = 100000;

File: DataStructures/Lists/SinglyLinkedList.java
Patch:
@@ -2,10 +2,10 @@
  * This class implements a SinglyLinked List. This is done
  * using SinglyLinkedList class and a LinkForLinkedList Class.
  * 
- * A linked list is implar to an array, it hold values.
+ * A linked list is similar to an array, it hold values.
  * However, links in a linked list do not have indexes. With
  * a linked list you do not need to predetermine it's size as
- * it gorws and shrinks as it is edited. This is an example of
+ * it grows and shrinks as it is edited. This is an example of
  * a singly linked list. Elements can only be added/removed
  * at the head/front of the list.
  * 
@@ -120,7 +120,7 @@ public static void main(String args[]){
 
 /**
  * This class is the nodes of the SinglyLinked List.
- * They consist of a vlue and a pointer to the node
+ * They consist of a value and a pointer to the node
  * after them.
  * 
  * @author Unknown

File: DataStructures/Lists/SinglyLinkedList.java
Patch:
@@ -2,10 +2,10 @@
  * This class implements a SinglyLinked List. This is done
  * using SinglyLinkedList class and a LinkForLinkedList Class.
  * 
- * A linked list is implar to an array, it hold values.
+ * A linked list is similar to an array, it hold values.
  * However, links in a linked list do not have indexes. With
  * a linked list you do not need to predetermine it's size as
- * it gorws and shrinks as it is edited. This is an example of
+ * it grows and shrinks as it is edited. This is an example of
  * a singly linked list. Elements can only be added/removed
  * at the head/front of the list.
  * 
@@ -120,7 +120,7 @@ public static void main(String args[]){
 
 /**
  * This class is the nodes of the SinglyLinked List.
- * They consist of a vlue and a pointer to the node
+ * They consist of a value and a pointer to the node
  * after them.
  * 
  * @author Unknown

File: Sorts/src/sort/BubbleSort.java
Patch:
@@ -43,12 +43,12 @@ public static void main(String[] args) {
         BubbleSort bubbleSort = new BubbleSort();
         bubbleSort.sort(integers);
 
-        // Output => 1	  4	 6	9	12	23	54	78	231
+        // Output => 231, 78, 54, 23, 12, 9, 6, 4, 1
         print(integers);
 
         // String Input
         String[] strings = {"c", "a", "e", "b","d"};
-        //Output => a	  b	 c	d	e
+        //Output => e, d, c, b, a
         print(bubbleSort.sort(strings));
 
     }

File: Sorts/src/sort/BubbleSort.java
Patch:
@@ -43,12 +43,12 @@ public static void main(String[] args) {
         BubbleSort bubbleSort = new BubbleSort();
         bubbleSort.sort(integers);
 
-        // Output => 1	  4	 6	9	12	23	54	78	231
+        // Output => 231, 78, 54, 23, 12, 9, 6, 4, 1
         print(integers);
 
         // String Input
         String[] strings = {"c", "a", "e", "b","d"};
-        //Output => a	  b	 c	d	e
+        //Output => e, d, c, b, a
         print(bubbleSort.sort(strings));
 
     }

File: Sorts/src/sort/ShellSort.java
Patch:
@@ -1,6 +1,6 @@
-package Sorts;
+package sort;
 
-import static Sorts.SortUtils.*;
+import static sort.SortUtils.*;
 
 
 /**

File: Sorts/src/sort/SortAlgorithm.java
Patch:
@@ -1,4 +1,4 @@
-package Sorts;
+package sort;
 
 /**
  *  The common interface of most algorithms

File: Sorts/src/sort/SortUtils.java
Patch:
@@ -1,4 +1,4 @@
-package Sorts;
+package sort;
 
 import java.util.Arrays;
 import java.util.List;

File: Others/countwords.java
Patch:
@@ -18,8 +18,8 @@ public static void main(String[] args){
 	  input.close();
         } 
 
-        public static int wordCount(String s){
-          if(s.isEmpty() || s == null) return -1;
+        private static int wordCount(String s){
+          if(s.isEmpty() || s == null) return 0;
           return s.trim().split("[\\s]+").length;
         }
         

File: Others/countwords.java
Patch:
@@ -19,7 +19,7 @@ public static void main(String[] args){
         } 
 
         private static int wordCount(String s){
-          if(s.isEmpty() || s == null) return -1;
+          if(s.isEmpty() || s == null) return 0;
           return s.trim().split("[\\s]+").length;
         }
         

File: Conversions/HexaDecimalToBinary.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Scanner;
 import javax.swing.*;
 
-public class HexaToBin {
+public class HexaDecimalToBinary {
  
     private final int LONG_BITS = 8;
 
@@ -28,10 +28,10 @@ public static void main(String[] args) {
         //Testing Numbers:
         String[] hexNums = {"1", "A1", "ef", "BA", "AA", "BB",
             "19", "01", "02", "03", "04"};
-        Convert objConvert = new Convert();
+        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();
 
         for (String num : hexNums) {
             objConvert.convert(num);
         }
     }
-}
\ No newline at end of file
+}

File: Dynamic Programming/Levenshtein_distance.java
Patch:
@@ -17,8 +17,8 @@ private static int minimum(int a, int b, int c){
 		}
 	}
 	private static int calculate_distance(String a, String b){
-		len_a = a.length() + 1;
-		len_b = b.length() + 1;
+		int len_a = a.length() + 1;
+		int len_b = b.length() + 1;
 		int [][] distance_mat = new int[len_a][len_b];
 		for(int i = 0; i < len_a; i++){
 			distance_mat[i][0] = i;

File: Dynamic Programming/rod_cutting.java
Patch:
@@ -2,8 +2,7 @@
     Returns the best obtainable price for a rod of
 	length n and price[] as prices of different pieces */
 
-public class RodCutting
-{
+public class RodCutting {
 	
 	private static int cutRod(int price[],int n)
 	{

File: Others/Abecedarian.java
Patch:
@@ -12,6 +12,6 @@ public static boolean isAbecedarian(String s){
 
             else{return false;}
             }
-        }
         return true;
+        }
 }

File: Others/Factorial.java
Patch:
@@ -1,4 +1,3 @@
-package factorial;
 import java.util.Scanner;
 
 /**

File: Others/FloydTriangle.java
Patch:
@@ -1,6 +1,5 @@
 import java.util.Scanner;
 
-
 public class FloydTriangle {
     public static void main(String[] args) {
           Scanner sc = new Scanner(System.in);

File: Others/ReverseString.java
Patch:
@@ -39,7 +39,7 @@ public static void main(String args[]) throws IOException
 		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
 		System.out.println("Enter the string");
 		String srr=br.readLine();
-		System.out.println("Reverse="+reverseString(srr));
+		System.out.println("Reverse="+reverse(srr));
 		br.close();
 	}
 }

File: Others/krishnamurthy.java
Patch:
@@ -1,4 +1,5 @@
 import java.util.Scanner;
+
 class krishnamurthy
 {
  int fact(int n)

File: Sorts/radixSort.java
Patch:
@@ -1,5 +1,3 @@
-
-import java.io.*;
 import java.util.*;
  
 class Radix {

File: data_structures/Graphs/PrimMST.java
Patch:
@@ -1,9 +1,7 @@
 // A Java program for Prim's Minimum Spanning Tree (MST) algorithm.
 //adjacency matrix representation of the graph
- 
-import java.util.*;
+
 import java.lang.*;
-import java.io.*;
  
 class PrimMST
 {

File: data_structures/HashMap/HashMap.java
Patch:
@@ -1,5 +1,3 @@
-
-
 import java.util.ArrayList;
 import java.util.LinkedList;
 

File: Dynamic Programming/Fibonacci.java
Patch:
@@ -11,7 +11,7 @@
 
 public class Fibonacci {
 
-    public static Map<Integer,Integer> map = new HashMap<Integer,Integer>();
+    private static Map<Integer,Integer> map = new HashMap<Integer,Integer>();
 
     public static void main(String[] args) throws Exception {
 
@@ -29,7 +29,7 @@ public static void main(String[] args) throws Exception {
      * Outputs the nth fibonacci number
      **/
 
-    public static int fibMemo(int n) {
+    private static int fibMemo(int n) {
         if (map.containsKey(n)) {
             return map.get(n);
         }
@@ -54,7 +54,7 @@ public static int fibMemo(int n) {
      * Outputs the nth fibonacci number
      **/
 
-    public static int fibBotUp(int n) {
+    private static int fibBotUp(int n) {
 
         Map<Integer,Integer> fib = new HashMap<Integer,Integer>();
 

File: Dynamic Programming/Levenshtein_distance.java
Patch:
@@ -7,7 +7,7 @@
  */
 
 public class Levenshtein_distance{
-	private int minimum(int a, int b, int c){
+	private static int minimum(int a, int b, int c){
 		if(a < b && a < c){
 			return a;
 		}else if(b < a && b < c){
@@ -16,7 +16,7 @@ private int minimum(int a, int b, int c){
 			return c;
 		}
 	}
-	public int calculate_distance(String a, String b){
+	private static int calculate_distance(String a, String b){
 		len_a = a.length() + 1;
 		len_b = b.length() + 1;
 		int [][] distance_mat = new int[len_a][len_b];

File: Dynamic Programming/LongestIncreasingSubsequence.java
Patch:
@@ -31,7 +31,7 @@ private static int upperBound(int[] ar, int l, int r, int key) {
         return r;
     }
 
-    public static int LIS(int[] array) {
+    private static int LIS(int[] array) {
         int N = array.length;
         if (N == 0)
             return 0;

File: Dynamic Programming/Fibonacci.java
Patch:
@@ -11,7 +11,7 @@
 
 public class Fibonacci {
 
-    public static Map<Integer,Integer> map = new HashMap<Integer,Integer>();
+    private static Map<Integer,Integer> map = new HashMap<Integer,Integer>();
 
     public static void main(String[] args) throws Exception {
 
@@ -29,7 +29,7 @@ public static void main(String[] args) throws Exception {
      * Outputs the nth fibonacci number
      **/
 
-    public static int fibMemo(int n) {
+    private static int fibMemo(int n) {
         if (map.containsKey(n)) {
             return map.get(n);
         }
@@ -54,7 +54,7 @@ public static int fibMemo(int n) {
      * Outputs the nth fibonacci number
      **/
 
-    public static int fibBotUp(int n) {
+    private static int fibBotUp(int n) {
 
         Map<Integer,Integer> fib = new HashMap<Integer,Integer>();
 

File: Dynamic Programming/Levenshtein_distance.java
Patch:
@@ -7,7 +7,7 @@
  */
 
 public class Levenshtein_distance{
-	private int minimum(int a, int b, int c){
+	private static int minimum(int a, int b, int c){
 		if(a < b && a < c){
 			return a;
 		}else if(b < a && b < c){
@@ -16,7 +16,7 @@ private int minimum(int a, int b, int c){
 			return c;
 		}
 	}
-	public int calculate_distance(String a, String b){
+	private static int calculate_distance(String a, String b){
 		len_a = a.length() + 1;
 		len_b = b.length() + 1;
 		int [][] distance_mat = new int[len_a][len_b];

File: Dynamic Programming/LongestIncreasingSubsequence.java
Patch:
@@ -31,7 +31,7 @@ private static int upperBound(int[] ar, int l, int r, int key) {
         return r;
     }
 
-    public static int LIS(int[] array) {
+    private static int LIS(int[] array) {
         int N = array.length;
         if (N == 0)
             return 0;

File: Misc/crc32.java
Patch:
@@ -20,7 +20,6 @@ public static int crc32(byte[] data) {
             else
                 crc32 = (crc32 << 1);
         }
-        crc32 = crc32 ^ 0;
         crc32 = Integer.reverse(crc32);                   //result reflect
         return crc32 ^ 0xFFFFFFFF;                        //final xor value
     }

