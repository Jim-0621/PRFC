File: jadx-core/src/main/java/jadx/core/export/TemplateFile.java
Patch:
@@ -11,7 +11,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import jadx.core.utils.exceptions.JadxRuntimeException;
@@ -49,8 +48,8 @@ private TemplateFile(String name, InputStream in) {
 		this.template = in;
 	}
 
-	public void add(String name, @NotNull Object value) {
-		values.put(name, value.toString());
+	public void add(String name, @Nullable Object value) {
+		values.put(name, String.valueOf(value));
 	}
 
 	public String build() throws IOException {

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -35,7 +35,7 @@
 
 public class JadxCLIArgs {
 
-	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab, .xapk, .jadx.kts)")
+	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab, .xapk, .apkm, .jadx.kts)")
 	protected List<String> files = new ArrayList<>(1);
 
 	@Parameter(names = { "-d", "--output-dir" }, description = "output directory")

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java
Patch:
@@ -17,7 +17,7 @@
 public class FileDialogWrapper {
 
 	private static final List<String> OPEN_FILES_EXTS = Arrays.asList(
-			"apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc", "jadx.kts", "xapk");
+			"apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc", "jadx.kts", "xapk", "apkm");
 
 	private final MainWindow mainWindow;
 

File: jadx-gui/src/main/java/jadx/gui/JadxGUI.java
Patch:
@@ -12,8 +12,8 @@
 import jadx.gui.logs.LogCollector;
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.settings.JadxSettingsAdapter;
-import jadx.gui.ui.ExceptionDialog;
 import jadx.gui.ui.MainWindow;
+import jadx.gui.ui.dialog.ExceptionDialog;
 import jadx.gui.utils.LafManager;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.SystemInfo;

File: jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java
Patch:
@@ -37,7 +37,7 @@ public enum ActionModel {
 			Shortcut.keyboard(KeyEvent.VK_F5, InputEvent.SHIFT_DOWN_MASK)),
 	SAVE_ALL(MENU_TOOLBAR, "file.save_all", "file.save_all", "ui/menu-saveall",
 			Shortcut.keyboard(KeyEvent.VK_E, UiUtils.ctrlButton())),
-	EXPORT(MENU_TOOLBAR, "file.export_gradle", "file.export_gradle", "ui/export",
+	EXPORT(MENU_TOOLBAR, "file.export", "file.export", "ui/export",
 			Shortcut.keyboard(KeyEvent.VK_E, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),
 	PREFS(MENU_TOOLBAR, "menu.preferences", "menu.preferences", "ui/settings",
 			Shortcut.keyboard(KeyEvent.VK_P, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -182,6 +182,7 @@ public void dispose() {
 		removeActiveTabListener();
 		searchBackgroundExecutor.execute(() -> {
 			stopSearchTask();
+			mainWindow.getBackgroundExecutor().waitForComplete();
 			unloadTempData();
 		});
 		super.dispose();

File: jadx-gui/src/main/java/jadx/gui/treemodel/JInputFile.java
Patch:
@@ -23,6 +23,7 @@ public JPopupMenu onTreePopupMenu(MainWindow mainWindow) {
 		JPopupMenu menu = new JPopupMenu();
 		menu.add(new SimpleMenuItem(NLS.str("popup.add_files"), mainWindow::addFiles));
 		menu.add(new SimpleMenuItem(NLS.str("popup.remove"), () -> mainWindow.removeInput(filePath)));
+		menu.add(new SimpleMenuItem(NLS.str("popup.rename"), () -> mainWindow.renameInput(filePath)));
 		return menu;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JInputScript.java
Patch:
@@ -66,6 +66,7 @@ public JPopupMenu onTreePopupMenu(MainWindow mainWindow) {
 		menu.add(new SimpleMenuItem(NLS.str("popup.add_scripts"), mainWindow::addFiles));
 		menu.add(new SimpleMenuItem(NLS.str("popup.new_script"), mainWindow::addNewScript));
 		menu.add(new SimpleMenuItem(NLS.str("popup.remove"), () -> mainWindow.removeInput(scriptPath)));
+		menu.add(new SimpleMenuItem(NLS.str("popup.rename"), () -> mainWindow.renameInput(scriptPath)));
 		return menu;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -175,9 +175,7 @@ public void updateGenericClsData(List<ArgType> generics, ArgType superClass, Lis
 	}
 
 	private static void processSpecialClasses(ClassNode cls) {
-		AccessInfo flags = cls.getAccessFlags();
-		if (flags.isSynthetic() && flags.isInterface() && flags.isAbstract()
-				&& cls.getName().equals("package-info")) {
+		if (cls.getName().equals("package-info") && cls.getFields().isEmpty() && cls.getMethods().isEmpty()) {
 			cls.add(AFlag.PACKAGE_INFO);
 			cls.add(AFlag.DONT_RENAME);
 		}

File: jadx-core/src/test/java/jadx/tests/integration/special/TestPackageInfoSupport.java
Patch:
@@ -28,5 +28,7 @@ public void test() {
 						"package special.pkg2;",
 						"",
 						"import org.jetbrains.annotations.ApiStatus;");
+		assertThat(searchCls(classes, "special.pkg3.package-info"))
+				.code().isEqualTo("\npackage special.pkg3;\n");
 	}
 }

File: jadx-core/src/main/java/jadx/api/ResourceType.java
Patch:
@@ -11,7 +11,7 @@ public enum ResourceType {
 	XML(".xml"),
 	ARSC(".arsc"),
 	FONT(".ttf", ".otf"),
-	IMG(".png", ".gif", ".jpg"),
+	IMG(".png", ".gif", ".jpg", ".webp"),
 	MEDIA(".mp3", ".wav"),
 	LIB(".so"),
 	MANIFEST,

File: jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java
Patch:
@@ -12,7 +12,7 @@
 
 public class JadxMenu extends JMenu {
 	// fake component to fill action shortcut component property
-	private static final JComponent JADX_MENU_COMPONENT = new JComponent() {
+	public static final JComponent JADX_MENU_COMPONENT = new JComponent() {
 		@Override
 		public String toString() {
 			return "JADX_MENU_COMPONENT";

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java
Patch:
@@ -150,7 +150,7 @@ private static boolean fixVisibilityOfInlineCode(MethodNode mth, InsnNode insn)
 		if (insnType == InsnType.INVOKE) {
 			InvokeNode invoke = (InvokeNode) insn;
 			MethodNode callMthNode = mth.root().resolveMethod(invoke.getCallMth());
-			if (callMthNode != null) {
+			if (callMthNode != null && !callMthNode.root().getArgs().isRespectBytecodeAccModifiers()) {
 				FixAccessModifiers.changeVisibility(callMthNode, newVisFlag);
 			}
 			return true;

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -513,7 +513,7 @@ private List<File> compileSourceFiles(List<File> compileFileList) throws IOExcep
 	}
 
 	private void saveToJar(List<File> files, Path baseDir) throws IOException {
-		Path jarFile = Files.createTempFile(testDir, "tests-" + getTestName() + '-', ".jar");
+		Path jarFile = Files.createTempFile("tests-" + getTestName() + '-', ".jar");
 		try (JarOutputStream jar = new JarOutputStream(Files.newOutputStream(jarFile))) {
 			for (File file : files) {
 				Path fullPath = file.toPath();

File: jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java
Patch:
@@ -1,6 +1,5 @@
 package jadx.cli.tools;
 
-import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Files;
@@ -71,7 +70,7 @@ public static void main(String[] args) throws IOException {
 				}
 			} else {
 				// Load resources.arsc from extracted file
-				try (InputStream inputStream = new BufferedInputStream(Files.newInputStream(resFile))) {
+				try (InputStream inputStream = Files.newInputStream(resFile)) {
 					resTableParser.decode(inputStream);
 				}
 			}

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java
Patch:
@@ -18,6 +18,7 @@ public class ParserStream {
 
 	private final InputStream input;
 	private long readPos = 0;
+	private long markPos = 0;
 
 	public ParserStream(@NotNull InputStream inputStream) {
 		this.input = inputStream;
@@ -143,10 +144,12 @@ public void mark(int len) throws IOException {
 			throw new IOException("Mark not supported for input stream " + input.getClass());
 		}
 		input.mark(len);
+		markPos = readPos;
 	}
 
 	public void reset() throws IOException {
 		input.reset();
+		readPos = markPos;
 	}
 
 	public void readFully(byte[] b) throws IOException {

File: jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java
Patch:
@@ -9,7 +9,6 @@
 
 import com.google.gson.FieldNamingPolicy;
 import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
 
 import jadx.api.ICodeInfo;
 import jadx.api.ICodeWriter;
@@ -32,13 +31,13 @@
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.RootNode;
+import jadx.core.utils.GsonUtils;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
 public class JsonCodeGen {
 
-	private static final Gson GSON = new GsonBuilder()
-			.setPrettyPrinting()
+	private static final Gson GSON = GsonUtils.defaultGsonBuilder()
 			.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
 			.disableHtmlEscaping()
 			.create();

File: jadx-core/src/main/java/jadx/core/codegen/json/JsonMappingGen.java
Patch:
@@ -11,7 +11,6 @@
 
 import com.google.gson.FieldNamingPolicy;
 import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
 
 import jadx.api.JadxArgs;
 import jadx.core.codegen.json.mapping.JsonClsMapping;
@@ -24,14 +23,14 @@
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.RootNode;
+import jadx.core.utils.GsonUtils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
 
 public class JsonMappingGen {
 	private static final Logger LOG = LoggerFactory.getLogger(JsonMappingGen.class);
 
-	private static final Gson GSON = new GsonBuilder()
-			.setPrettyPrinting()
+	private static final Gson GSON = GsonUtils.defaultGsonBuilder()
 			.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
 			.disableHtmlEscaping()
 			.create();

File: jadx-gui/src/main/java/jadx/gui/cache/manager/CacheManager.java
Patch:
@@ -19,10 +19,10 @@
 import org.slf4j.LoggerFactory;
 
 import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
 import com.google.gson.reflect.TypeToken;
 
 import jadx.api.plugins.utils.CommonFileUtils;
+import jadx.core.utils.GsonUtils;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
@@ -34,7 +34,7 @@
 public class CacheManager {
 	private static final Logger LOG = LoggerFactory.getLogger(CacheManager.class);
 
-	private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
+	private static final Gson GSON = GsonUtils.buildGson();
 	private static final Type CACHES_TYPE = new TypeToken<List<CacheEntry>>() {
 	}.getType();
 

File: jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java
Patch:
@@ -42,7 +42,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.gson.GsonBuilder;
 import com.google.gson.JsonObject;
 
 import jadx.api.CommentsLevel;
@@ -57,6 +56,7 @@
 import jadx.api.plugins.events.JadxEvents;
 import jadx.api.plugins.events.types.ReloadSettingsWindow;
 import jadx.api.plugins.gui.ISettingsGroup;
+import jadx.core.utils.GsonUtils;
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.settings.JadxSettingsAdapter;
 import jadx.gui.settings.JadxUpdateChannel;
@@ -747,7 +747,7 @@ private void copySettings() {
 		settingsJson.remove("lastOpenFilePath");
 		settingsJson.remove("lastSaveFilePath");
 		settingsJson.remove("recentProjects");
-		String settingsText = new GsonBuilder().setPrettyPrinting().create().toJson(settingsJson);
+		String settingsText = GsonUtils.buildGson().toJson(settingsJson);
 		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
 		StringSelection selection = new StringSelection(settingsText);
 		clipboard.setContents(selection, selection);

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -322,7 +322,7 @@ private void checkForUpdate() {
 		if (!settings.isCheckForUpdates()) {
 			return;
 		}
-		JadxUpdate.check(settings.getJadxUpdateChannel(), release -> SwingUtilities.invokeLater(() -> {
+		new JadxUpdate().check(settings.getJadxUpdateChannel(), release -> SwingUtilities.invokeLater(() -> {
 			switch (settings.getJadxUpdateChannel()) {
 				case STABLE:
 					updateLink.setUrl(JadxUpdate.JADX_RELEASES_URL);

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/JsonPrettifyAction.java
Patch:
@@ -1,17 +1,17 @@
 package jadx.gui.ui.codearea;
 
 import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 
+import jadx.core.utils.GsonUtils;
 import jadx.gui.treemodel.JNode;
 import jadx.gui.ui.action.ActionModel;
 
 public class JsonPrettifyAction extends JNodeAction {
-
 	private static final long serialVersionUID = -2682529369671695550L;
-	private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
+
+	private static final Gson GSON = GsonUtils.buildGson();
 
 	public JsonPrettifyAction(CodeArea codeArea) {
 		super(ActionModel.JSON_PRETTIFY, codeArea);

File: jadx-plugins-tools/src/main/java/jadx/plugins/tools/resolvers/github/GithubTools.java
Patch:
@@ -10,11 +10,12 @@
 import java.util.List;
 import java.util.stream.Collectors;
 
-import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
 
 import jadx.plugins.tools.resolvers.github.data.Release;
 
+import static jadx.core.utils.GsonUtils.buildGson;
+
 public class GithubTools {
 	private static final String GITHUB_API_URL = "https://api.github.com/";
 
@@ -59,7 +60,7 @@ private static <T> T get(String url, Type type) {
 			throw new RuntimeException("Request failed, url: " + url, e);
 		}
 		try (Reader reader = new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8)) {
-			return new Gson().fromJson(reader, type);
+			return buildGson().fromJson(reader, type);
 		} catch (Exception e) {
 			throw new RuntimeException("Failed to parse response, url: " + url, e);
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java
Patch:
@@ -318,6 +318,9 @@ private boolean processCase(SwitchData switchData, SwitchRegion.CaseInfo caseInf
 			if (ifInsn.getOp() == IfOp.NE && ifInsn.getArg(1).isTrue()) {
 				neg = true;
 			}
+			if (ifInsn.getOp() == IfOp.EQ && ifInsn.getArg(1).isFalse()) {
+				neg = true;
+			}
 			if (str != null) {
 				switchData.getToRemove().add(ifInsn);
 				switchData.getToRemove().addAll(ifRegion.getConditionBlocks());

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java
Patch:
@@ -103,10 +103,10 @@ private boolean restoreSwitchOverString(MethodNode mth, SwitchRegion switchRegio
 			// all checks passed, replace with new switch
 			IRegion parentRegion = switchRegion.getParent();
 			SwitchRegion replaceRegion = new SwitchRegion(parentRegion, switchRegion.getHeader());
-			replaceRegion.addDefaultCase(switchData.getDefaultCode());
 			for (CaseData caseData : switchData.getCases()) {
 				replaceRegion.addCase(Collections.unmodifiableList(caseData.getStrValues()), caseData.getCode());
 			}
+			replaceRegion.addDefaultCase(switchData.getDefaultCode());
 			if (!parentRegion.replaceSubBlock(switchRegion, replaceRegion)) {
 				mth.addWarnComment("Failed to restore switch over string. Please report as a decompilation issue");
 				return false;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings.java
Patch:
@@ -46,6 +46,7 @@ public void test() {
 				.code()
 				.doesNotContain("case -603257287:")
 				.doesNotContain("c = ")
+				.doesNotContainSubsequence("default:", "case ")
 				.containsOne("case \"frewhyh\":")
 				.countString(5, "return ");
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java
Patch:
@@ -243,9 +243,10 @@ private JPopupMenu createTabPopupMenu() {
 		if (tabs.size() > 1) {
 			JMenuItem closeOther = new JMenuItem(NLS.str("tabs.closeOthers"));
 			closeOther.addActionListener(e -> {
+				JNode currentNode = getNode();
 				for (TabBlueprint tab : tabs) {
-					if (tab != getBlueprint()) {
-						tabsController.closeTab(getNode(), true);
+					if (tab.getNode() != currentNode) {
+						tabsController.closeTab(tab, true);
 					}
 				}
 			});
@@ -310,7 +311,6 @@ public TabBlueprint getBlueprint() {
 		if (blueprint == null) {
 			throw new JadxRuntimeException("TabComponent does not have a corresponding TabBlueprint");
 		}
-
 		return blueprint;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java
Patch:
@@ -141,11 +141,11 @@ private static void fillListModel(DefaultListModel<BasePluginListNode> listModel
 			List<BasePluginListNode> nodes, List<AvailablePluginNode> available) {
 		listModel.clear();
 		listModel.addElement(new TitleNode("Installed"));
-		nodes.stream().filter(n -> n.getVersion() != null).forEach(listModel::addElement);
+		nodes.stream().filter(n -> n.getAction() == PluginAction.UNINSTALL).forEach(listModel::addElement);
 		listModel.addElement(new TitleNode("Available"));
 		listModel.addAll(available);
 		listModel.addElement(new TitleNode("Bundled"));
-		nodes.stream().filter(n -> n.getVersion() == null).forEach(listModel::addElement);
+		nodes.stream().filter(n -> n.getAction() == PluginAction.NONE).forEach(listModel::addElement);
 	}
 
 	private void loadAvailablePlugins(DefaultListModel<BasePluginListNode> listModel,

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -178,7 +178,7 @@ public void close() {
 		closeInputs();
 		closeLoaders();
 		args.close();
-		FileUtils.deleteTempRootDir();
+		FileUtils.clearTempRootDir();
 	}
 
 	private void closeInputs() {

File: jadx-gui/src/main/java/jadx/gui/cache/manager/CacheManager.java
Patch:
@@ -47,8 +47,8 @@ public CacheManager(JadxSettings settings) {
 	}
 
 	/**
-	 * If project cache is set -> check if cache entry exists for this project.
-	 * If not -> calculate new and add entry.
+	 * If project cache is set -&gt; check if cache entry exists for this project.
+	 * If not -&gt; calculate new and add entry.
 	 */
 	public Path getCacheDir(JadxProject project, @Nullable String cacheDirStr) {
 		if (cacheDirStr == null) {

File: jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java
Patch:
@@ -533,7 +533,7 @@ public int readArrayLength(RuntimeValue val) throws SmaliDebuggerException {
 	/**
 	 * @param startIndex less than 0 means 0
 	 * @param len        less than or equals 0 means the maximum value 99 or the rest of the elements.
-	 * @return An entry, The key is the total length of this array when len is <= 0, otherwise 0,
+	 * @return An entry, The key is the total length of this array when len is &lt;= 0, otherwise 0,
 	 *         the value, if this array is an object array then it's object ids.
 	 */
 	public Entry<Integer, List<Long>> readArray(RuntimeValue reg, int startIndex, int len) throws SmaliDebuggerException {

File: jadx-gui/src/main/java/jadx/gui/device/protocol/ADBDevice.java
Patch:
@@ -123,7 +123,7 @@ public int launchApp(String fullAppName) throws IOException, InterruptedExceptio
 	}
 
 	/**
-	 * @Return binary output of logcat
+	 * @return binary output of logcat
 	 */
 	public byte[] getBinaryLogcat() throws IOException {
 
@@ -133,7 +133,7 @@ public byte[] getBinaryLogcat() throws IOException {
 	}
 
 	/**
-	 * @Return binary output of logcat after provided timestamp
+	 * @return binary output of logcat after provided timestamp
 	 *         Timestamp is in the format 09-08 02:18:03.131
 	 */
 	public byte[] getBinaryLogcat(String timestamp) throws IOException {
@@ -147,7 +147,7 @@ public byte[] getBinaryLogcat(String timestamp) throws IOException {
 	}
 
 	/**
-	 * @Return binary output of logcat -c
+	 * Binary output of logcat -c
 	 */
 	public void clearLogcat() throws IOException {
 		Socket socket = ADB.connect(info.getAdbHost(), info.getAdbPort());

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java
Patch:
@@ -39,7 +39,7 @@
 import jadx.gui.utils.ui.MousePressedHandler;
 
 /**
- * A panel combining a {@link SearchBar and a scollable {@link CodeArea}
+ * A panel combining a {@link SearchBar} and a scollable {@link CodeArea}
  */
 public class CodePanel extends JPanel {
 	private static final long serialVersionUID = 1117721869391885865L;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliTokenMaker.java
Patch:
@@ -9,7 +9,7 @@
 import org.fife.ui.rsyntaxtextarea.*;
 
 /**
- * 用于Smali代码高亮
+ * SmaliTokenMaker
  * MartinKay@qq.com
  */
 
@@ -1280,7 +1280,7 @@ private boolean zzRefill() {
 	 *
 	 * All internal variables are reset, the old input stream
 	 * <b>cannot</b> be reused (internal buffer is discarded and lost).
-	 * Lexical state is set to <tt>YY_INITIAL</tt>.
+	 * Lexical state is set to <code>YY_INITIAL</code>
 	 *
 	 * @param reader the new input stream
 	 */
@@ -1371,7 +1371,7 @@ public final String yytext() {
 	}
 
 	/**
-	 * Returns the character at position <tt>pos</tt> from the
+	 * Returns the character at position<code>pos</code> from the
 	 * matched text.
 	 *
 	 * It is equivalent to yytext().charAt(pos), but faster

File: jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java
Patch:
@@ -666,10 +666,10 @@ private SettingsGroup makeOtherGroup() {
 		group.addRow(NLS.str("preferences.lineNumbersMode"), lineNumbersMode);
 		group.addRow(NLS.str("preferences.jumpOnDoubleClick"), jumpOnDoubleClick);
 		group.addRow(NLS.str("preferences.useAlternativeFileDialog"), useAltFileDialog);
-		group.addRow(NLS.str("preferences.check_for_updates"), update);
 		group.addRow(NLS.str("preferences.cfg"), cfg);
 		group.addRow(NLS.str("preferences.raw_cfg"), rawCfg);
 		group.addRow(NLS.str("preferences.xposed_codegen_language"), xposedCodegenLanguage);
+		group.addRow(NLS.str("preferences.check_for_updates"), update);
 		group.addRow(NLS.str("preferences.update_channel"), updateChannel);
 		return group;
 	}

File: jadx-core/src/main/java/jadx/core/codegen/utils/CodeGenUtils.java
Patch:
@@ -140,7 +140,9 @@ public static void addInputFileInfo(ICodeWriter code, ClassNode cls) {
 			String inputFileName = cls.getClsData().getInputFileName();
 			if (inputFileName != null) {
 				ClassNode declCls = cls.getDeclaringClass();
-				if (declCls != null && inputFileName.equals(declCls.getClsData().getInputFileName())) {
+				if (declCls != null
+						&& declCls.getClsData() != null
+						&& inputFileName.equals(declCls.getClsData().getInputFileName())) {
 					// don't add same comment for inner classes
 					return;
 				}

File: jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java
Patch:
@@ -284,7 +284,7 @@ private JPopupMenu createTabPopupMenu() {
 				JNode node = tab.getNode();
 				final String clsName = node.makeLongString();
 				JMenuItem item = new JMenuItem(clsName);
-				item.addActionListener(e -> tabsController.selectTab(node));
+				item.addActionListener(e -> tabsController.codeJump(node));
 				item.setIcon(node.getIcon());
 				menu.add(item);
 			}

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -19,6 +19,7 @@ public class NameMapper {
 
 	private static final Set<String> RESERVED_NAMES = new HashSet<>(
 			Arrays.asList(
+					"_",
 					"abstract",
 					"assert",
 					"boolean",

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -16,7 +16,6 @@
 import jadx.cli.plugins.JadxFilesGetter;
 import jadx.commons.app.JadxCommonEnv;
 import jadx.core.utils.exceptions.JadxArgsValidateException;
-import jadx.core.utils.files.FileUtils;
 import jadx.plugins.tools.JadxExternalPluginsLoader;
 
 public class JadxCLI {
@@ -33,7 +32,6 @@ public static void main(String[] args) {
 			LOG.error("Process error:", e);
 			result = 1;
 		} finally {
-			FileUtils.deleteTempRootDir();
 			System.exit(result);
 		}
 	}

File: jadx-cli/src/main/java/jadx/cli/plugins/JadxFilesGetter.java
Patch:
@@ -3,8 +3,8 @@
 import java.nio.file.Path;
 
 import jadx.commons.app.JadxCommonFiles;
+import jadx.commons.app.JadxTempFiles;
 import jadx.core.plugins.files.IJadxFilesGetter;
-import jadx.core.utils.files.FileUtils;
 
 public class JadxFilesGetter implements IJadxFilesGetter {
 
@@ -22,7 +22,7 @@ public Path getCacheDir() {
 
 	@Override
 	public Path getTempDir() {
-		return FileUtils.getTempRootDir();
+		return JadxTempFiles.getTempRootDir();
 	}
 
 	private JadxFilesGetter() {

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -111,6 +111,7 @@ public void load() {
 		reset();
 		JadxArgsValidator.validate(this);
 		LOG.info("loading ...");
+		FileUtils.updateTempRootDir(args.getFilesGetter().getTempDir());
 		loadPlugins();
 		loadInputFiles();
 
@@ -174,6 +175,7 @@ public void close() {
 		closeInputs();
 		closeLoaders();
 		args.close();
+		FileUtils.deleteTempRootDir();
 	}
 
 	private void closeInputs() {

File: jadx-gui/src/main/java/jadx/gui/jobs/DecompileTask.java
Patch:
@@ -13,16 +13,16 @@
 import jadx.api.ICodeCache;
 import jadx.api.JavaClass;
 import jadx.api.utils.tasks.ITaskExecutor;
+import jadx.commons.app.JadxCommonEnv;
 import jadx.core.utils.tasks.TaskExecutor;
 import jadx.gui.JadxWrapper;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.NLS;
-import jadx.gui.utils.UiUtils;
 
 public class DecompileTask extends CancelableBackgroundTask {
 	private static final Logger LOG = LoggerFactory.getLogger(DecompileTask.class);
 
-	private static final int CLS_LIMIT = Integer.parseInt(UiUtils.getEnvVar("JADX_CLS_PROCESS_LIMIT", "50"));
+	private static final int CLS_LIMIT = JadxCommonEnv.getInt("JADX_CLS_PROCESS_LIMIT", 50);
 
 	public static int calcDecompileTimeLimit(int classCount) {
 		return classCount * CLS_LIMIT + 5000;

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -1549,7 +1549,6 @@ private void closeWindow() {
 		heapUsageBar.reset();
 		closeAll();
 
-		FileUtils.deleteTempRootDir();
 		dispose();
 		System.exit(0);
 	}

File: jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java
Patch:
@@ -12,14 +12,14 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import jadx.api.JadxArgs;
 import jadx.core.dex.nodes.RootNode;
 import jadx.core.utils.android.TextResMapFile;
+import jadx.core.utils.files.ZipFile;
 import jadx.core.xmlgen.ResTableBinaryParser;
 
 /**

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -27,6 +26,7 @@
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
+import jadx.core.utils.files.ZipFile;
 import jadx.core.xmlgen.BinaryXMLParser;
 import jadx.core.xmlgen.IResTableParser;
 import jadx.core.xmlgen.ResContainer;

File: jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java
Patch:
@@ -8,14 +8,14 @@
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
 
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
+import jadx.core.utils.files.ZipFile;
 
 public class ZipSecurity {
 	private static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);

File: jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java
Patch:
@@ -55,6 +55,8 @@ public enum ActionModel {
 			Shortcut.keyboard(KeyEvent.VK_M, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),
 	GO_TO_APPLICATION(MENU_TOOLBAR, "menu.go_to_application", "menu.go_to_application", "ui/application",
 			Shortcut.keyboard(KeyEvent.VK_A, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),
+	GO_TO_ANDROID_MANIFEST(MENU_TOOLBAR, "menu.go_to_android_manifest", "menu.go_to_android_manifest", "ui/androidManifest",
+			Shortcut.none()),
 	DECOMPILE_ALL(MENU_TOOLBAR, "menu.decompile_all", "menu.decompile_all", "ui/runAll",
 			Shortcut.none()),
 	RESET_CACHE(MENU_TOOLBAR, "menu.reset_cache", "menu.reset_cache", "ui/reset",

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -434,7 +434,7 @@ private void makeInsnBody(ICodeWriter code, InsnNode insn, Set<Flags> state) thr
 					code.add(']');
 				}
 				int dim = arrayType.getArrayDimension();
-				for (; k < dim - 1; k++) {
+				for (; k < dim; k++) {
 					code.add("[]");
 				}
 				break;

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -540,6 +540,7 @@ private InsnNode makeNewArray(InsnData insn) {
 		for (int i = 1; i < regsCount; i++) {
 			newArr.addArg(InsnArg.typeImmutableReg(insn, i, ArgType.INT));
 		}
+		CodeFeaturesAttr.add(method, CodeFeature.NEW_ARRAY);
 		return newArr;
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java
Patch:
@@ -45,7 +45,7 @@ public void check() {
 	public void test() {
 		assertThat(getClassNode(TestCls.class))
 				.code()
-				.countString(0, "break;")
-				.countString(3, "return;");
+				.countString(3, "break;")
+				.countString(0, "return;");
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -576,6 +576,7 @@ private void closeAll() {
 		LogCollector.getInstance().reset();
 		wrapper.close();
 		tabsController.forceCloseAllTabs();
+		shortcutsController.reset();
 		UiUtils.resetClipboardOwner();
 		System.gc();
 		update();

File: jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java
Patch:
@@ -15,6 +15,7 @@ public class TestConstructor2 extends SmaliTest {
 	public void test() {
 		assertThat(getClassNodeFromSmaliFiles())
 				.code()
-				.containsOne("A a = new A();");
+				.containsOne("A a = new A();")
+				.doesNotContain("return");
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java
Patch:
@@ -14,6 +14,6 @@ public void test() {
 		disableCompilation();
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.countString(4, "return new f(");
+				.countString(2, "return new f(");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -327,7 +327,8 @@ public ICodeInfo decompileWithMode(DecompilationMode mode) {
 				args.setDecompilationMode(mode);
 				ProcessClass process = new ProcessClass(Jadx.getPassesList(args));
 				process.initPasses(root);
-				return process.generateCode(this);
+				ICodeInfo code = process.forceGenerateCode(this);
+				return Utils.getOrElse(code, ICodeInfo.EMPTY);
 			} finally {
 				args.setDecompilationMode(baseMode);
 				unload();

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java
Patch:
@@ -21,6 +21,7 @@
 import jadx.core.dex.visitors.blocks.BlockSplitter;
 import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.utils.ListUtils;
+import jadx.core.utils.exceptions.InvalidDataException;
 import jadx.core.utils.exceptions.JadxException;
 
 @JadxVisitor(
@@ -40,6 +41,8 @@ public void visit(MethodNode mth) throws JadxException {
 			if (debugInfo != null) {
 				processDebugInfo(mth, debugInfo);
 			}
+		} catch (InvalidDataException e) {
+			mth.addWarnComment(e.getMessage());
 		} catch (Exception e) {
 			mth.addWarnComment("Failed to parse debug info", e);
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java
Patch:
@@ -248,6 +248,7 @@ public void forceCloseAllTabs() {
 		forceClose = true;
 		closeAllTabs();
 		forceClose = false;
+		selectedTab = null;
 	}
 
 	public boolean isForceClose() {

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java
Patch:
@@ -72,7 +72,8 @@ public BinaryXMLStrings getKeyStrings() {
 	 */
 	private final boolean useRawResName;
 	private final RootNode root;
-	private final ResourceStorage resStorage = new ResourceStorage();
+
+	private ResourceStorage resStorage;
 	private BinaryXMLStrings strings;
 
 	public ResTableBinaryParser(RootNode root) {
@@ -88,6 +89,7 @@ public ResTableBinaryParser(RootNode root, boolean useRawResNames) {
 	public void decode(InputStream inputStream) throws IOException {
 		long start = System.currentTimeMillis();
 		is = new ParserStream(inputStream);
+		resStorage = new ResourceStorage();
 		decodeTableChunk();
 		resStorage.finish();
 		if (LOG.isDebugEnabled()) {

File: jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java
Patch:
@@ -26,14 +26,15 @@
 
 public class ResTableProtoParser extends CommonProtoParser implements IResTableParser {
 	private final RootNode root;
-	private final ResourceStorage resStorage = new ResourceStorage();
+	private ResourceStorage resStorage;
 
 	public ResTableProtoParser(RootNode root) {
 		this.root = root;
 	}
 
 	@Override
 	public void decode(InputStream inputStream) throws IOException {
+		resStorage = new ResourceStorage();
 		ResourceTable table = ResourceTable.parseFrom(FileUtils.streamToByteArray(inputStream));
 		for (Package p : table.getPackageList()) {
 			parse(p);

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -269,7 +269,7 @@ public void addInstructions(ICodeWriter code) throws CodegenException {
 		JadxArgs args = mth.root().getArgs();
 		switch (args.getDecompilationMode()) {
 			case AUTO:
-				if (classGen.isFallbackMode()) {
+				if (classGen.isFallbackMode() || mth.getRegion() == null) {
 					// TODO: try simple mode first
 					dumpInstructions(code);
 				} else {

File: jadx-gui/src/main/java/jadx/gui/plugins/context/GuiPluginContext.java
Patch:
@@ -179,7 +179,7 @@ public boolean open(ICodeNodeRef ref) {
 			return false;
 		}
 
-		commonContext.getMainWindow().getTabbedPane().codeJump(node);
+		commonContext.getMainWindow().getTabsController().codeJump(node);
 		return true;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java
Patch:
@@ -114,7 +114,7 @@ private void loadReport() {
 			root.replaceCustomNode(quarkNode);
 			root.update();
 			mainWindow.reloadTree();
-			mainWindow.getTabbedPane().showNode(quarkNode);
+			mainWindow.getTabsController().selectTab(quarkNode);
 		} catch (Exception e) {
 			UiUtils.errorMessage(mainWindow, "Failed to load Quark report.");
 			LOG.error("Failed to load Quark report.", e);

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java
Patch:
@@ -117,7 +117,7 @@ public void mouseClicked(MouseEvent event) {
 					Object node = getNodeUnderMouse(tree, event);
 					if (node instanceof MethodTreeNode) {
 						JMethod method = ((MethodTreeNode) node).getJMethod();
-						tabbedPane.codeJump(method);
+						tabbedPane.getTabsController().codeJump(method);
 					}
 				}
 			}
@@ -159,7 +159,7 @@ private String buildHeader() {
 
 	@Override
 	public void loadSettings() {
-		Font settingsFont = getTabbedPane().getMainWindow().getSettings().getFont();
+		Font settingsFont = getMainWindow().getSettings().getFont();
 		this.font = settingsFont.deriveFont(settingsFont.getSize2D() + 1.f);
 		this.boldFont = font.deriveFont(Font.BOLD);
 		header.setFont(font);
@@ -279,7 +279,7 @@ public MutableTreeNode resolveMethod(String descr) {
 			String[] parts = removeQuotes(descr).split(" ", 3);
 			String cls = Utils.cleanObjectName(parts[0].replace('$', '.'));
 			String mth = parts[1] + parts[2].replace(" ", "");
-			MainWindow mainWindow = getTabbedPane().getMainWindow();
+			MainWindow mainWindow = getMainWindow();
 			JadxWrapper wrapper = mainWindow.getWrapper();
 			JavaClass javaClass = wrapper.searchJavaClassByRawName(cls);
 			if (javaClass == null) {

File: jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCodeArea.java
Patch:
@@ -25,8 +25,8 @@ public ScriptCodeArea(ContentPanel contentPanel, JInputScript node) {
 		setCodeFoldingEnabled(true);
 		setCloseCurlyBraces(true);
 
-		shortcutsController = contentPanel.getTabbedPane().getMainWindow().getShortcutsController();
-		JadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();
+		shortcutsController = contentPanel.getMainWindow().getShortcutsController();
+		JadxSettings settings = contentPanel.getMainWindow().getSettings();
 		autoCompletion = addAutoComplete(settings);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java
Patch:
@@ -232,7 +232,7 @@ private void applySettings() {
 	}
 
 	private void showScriptLog() {
-		getTabbedPane().getMainWindow().showLogViewer(LogOptions.forScript(getNode().getName()));
+		getMainWindow().showLogViewer(LogOptions.forScript(getNode().getName()));
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -40,8 +40,7 @@ public ICodeNodeRef getCodeNodeRef() {
 		return null;
 	}
 
-	@Nullable
-	public ContentPanel getContentPanel(TabbedPane tabbedPane) {
+	public @Nullable ContentPanel getContentPanel(TabbedPane tabbedPane) {
 		return null;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java
Patch:
@@ -90,7 +90,7 @@ public AbstractCodeArea(ContentPanel contentPanel, JNode node) {
 		applyEditableProperties(node);
 		loadSettings();
 
-		JadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();
+		JadxSettings settings = contentPanel.getMainWindow().getSettings();
 		setLineWrap(settings.isCodeAreaLineWrap());
 
 		ZoomActions.register(this, settings, this::loadSettings);
@@ -147,7 +147,7 @@ protected void appendFoldingMenu(JPopupMenu popup) {
 	}
 
 	private void appendWrapLineMenu(JPopupMenu popupMenu) {
-		JadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();
+		JadxSettings settings = contentPanel.getMainWindow().getSettings();
 		popupMenu.addSeparator();
 		JCheckBoxMenuItem wrapItem = new JCheckBoxMenuItem(NLS.str("popup.line_wrap"), getLineWrap());
 		wrapItem.setAction(new AbstractAction(NLS.str("popup.line_wrap")) {
@@ -378,7 +378,7 @@ public static void loadCommonSettings(MainWindow mainWindow, RSyntaxTextArea are
 	}
 
 	public void loadSettings() {
-		loadCommonSettings(contentPanel.getTabbedPane().getMainWindow(), this);
+		loadCommonSettings(contentPanel.getMainWindow(), this);
 	}
 
 	public void scrollToPos(int pos) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -87,7 +87,7 @@ private void navToDecl(Point point) {
 		int offs = viewToModel2D(point);
 		JNode node = getJNodeAtOffset(adjustOffsetForWordToken(offs));
 		if (node != null) {
-			contentPanel.getTabbedPane().codeJump(node);
+			contentPanel.getTabsController().codeJump(node);
 		}
 	}
 
@@ -332,7 +332,7 @@ public void refreshClass() {
 	}
 
 	public MainWindow getMainWindow() {
-		return contentPanel.getTabbedPane().getMainWindow();
+		return contentPanel.getMainWindow();
 	}
 
 	public JadxWrapper getJadxWrapper() {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java
Patch:
@@ -82,7 +82,7 @@ public void actionPerformed(ActionEvent e) {
 		AbstractAction globalSearchAction = new AbstractAction(NLS.str("popup.search_global", "")) {
 			@Override
 			public void actionPerformed(ActionEvent e) {
-				MainWindow mainWindow = codeArea.getContentPanel().getTabbedPane().getMainWindow();
+				MainWindow mainWindow = codeArea.getContentPanel().getMainWindow();
 				SearchDialog.searchText(mainWindow, codeArea.getSelectedText());
 			}
 		};

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java
Patch:
@@ -12,6 +12,6 @@ public GoToDeclarationAction(CodeArea codeArea) {
 
 	@Override
 	public void runAction(JNode node) {
-		getCodeArea().getContentPanel().getTabbedPane().codeJump(node);
+		getCodeArea().getContentPanel().getTabsController().codeJump(node);
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/HexArea.java
Patch:
@@ -85,10 +85,10 @@ public void loadSettings() {
 	}
 
 	private void applyTheme() {
-		Font font = getContentPanel().getTabbedPane().getMainWindow().getSettings().getSmaliFont();
+		Font font = getContentPanel().getMainWindow().getSettings().getSmaliFont();
 		setFont(font);
 
-		Theme theme = contentPanel.getTabbedPane().getMainWindow().getEditorTheme();
+		Theme theme = contentPanel.getMainWindow().getEditorTheme();
 		if (hexPreviewPanel != null) {
 			hexPreviewPanel.applyTheme(theme, font);
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/panel/HtmlPanel.java
Patch:
@@ -34,7 +34,7 @@ public HtmlPanel(TabbedPane panel, JNode jnode) {
 
 	@Override
 	public void loadSettings() {
-		JadxSettings settings = getTabbedPane().getMainWindow().getSettings();
+		JadxSettings settings = getMainWindow().getSettings();
 		textArea.setFont(settings.getFont());
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/panel/JDebuggerPanel.java
Patch:
@@ -445,7 +445,7 @@ public void resetUI() {
 	}
 
 	public void scrollToSmaliLine(JClass cls, int pos, boolean debugMode) {
-		SwingUtilities.invokeLater(() -> getMainWindow().getTabbedPane().smaliJump(cls, pos, debugMode));
+		SwingUtilities.invokeLater(() -> getMainWindow().getTabsController().smaliJump(cls, pos, debugMode));
 	}
 
 	public void resetAllDebuggingInfo() {

File: jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java
Patch:
@@ -43,8 +43,7 @@ private boolean ignoreJump(JumpPosition pos) {
 		return pos.equals(current);
 	}
 
-	@Nullable
-	private JumpPosition getCurrent() {
+	public @Nullable JumpPosition getCurrent() {
 		if (currentPos >= 0 && currentPos < list.size()) {
 			return list.get(currentPos);
 		}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -28,7 +28,6 @@
 import jadx.core.dex.visitors.EnumVisitor;
 import jadx.core.dex.visitors.ExtractFieldInit;
 import jadx.core.dex.visitors.FallbackModeVisitor;
-import jadx.core.dex.visitors.FixAccessModifiers;
 import jadx.core.dex.visitors.FixSwitchOverEnum;
 import jadx.core.dex.visitors.GenericTypesVisitor;
 import jadx.core.dex.visitors.IDexTreeVisitor;
@@ -53,6 +52,7 @@
 import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;
 import jadx.core.dex.visitors.debuginfo.DebugInfoAttachVisitor;
 import jadx.core.dex.visitors.finaly.MarkFinallyVisitor;
+import jadx.core.dex.visitors.fixaccessmodifiers.FixAccessModifiers;
 import jadx.core.dex.visitors.kotlin.ProcessKotlinInternals;
 import jadx.core.dex.visitors.prepare.AddAndroidConstants;
 import jadx.core.dex.visitors.prepare.CollectConstValues;

File: jadx-core/src/main/java/jadx/core/dex/nodes/ICodeNode.java
Patch:
@@ -5,6 +5,9 @@
 import jadx.core.dex.info.AccessInfo;
 
 public interface ICodeNode extends IDexNode, IAttributeNode, IUsageInfoNode, ICodeNodeRef {
+
+	ClassNode getDeclaringClass();
+
 	AccessInfo getAccessFlags();
 
 	void setAccessFlags(AccessInfo newAccessFlags);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -32,6 +32,7 @@
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.dex.visitors.fixaccessmodifiers.FixAccessModifiers;
 import jadx.core.dex.visitors.usage.UsageInfoVisitor;
 import jadx.core.utils.BlockUtils;
 import jadx.core.utils.InsnRemover;

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java
Patch:
@@ -19,6 +19,7 @@
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.dex.visitors.fixaccessmodifiers.FixAccessModifiers;
 import jadx.core.utils.BlockUtils;
 import jadx.core.utils.ListUtils;
 import jadx.core.utils.exceptions.JadxException;

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFixClassAccessModifiers.java
Patch:
@@ -12,8 +12,10 @@
 public class TestFixClassAccessModifiers extends SmaliTest {
 	// @formatter:off
 	/*
+		// class others.TestCls
 		public Cls.InnerCls field;
 
+		// class others.Cls
 		public static class Cls {
 			private static class InnerCls {
 			}
@@ -25,7 +27,6 @@ private static class InnerCls {
 	public void test() {
 		List<ClassNode> classes = loadFromSmaliFiles();
 		assertThat(searchCls(classes, "others.Cls"))
-				.code()
-				.containsOne("public static class InnerCls {");
+				.code();
 	}
 }

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -8,7 +8,6 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.api.ICodeInfo;
-import jadx.api.JadxArgs;
 import jadx.api.impl.SimpleCodeInfo;
 import jadx.core.codegen.CodeGen;
 import jadx.core.dex.attributes.AFlag;
@@ -32,8 +31,8 @@ public class ProcessClass {
 
 	private final List<IDexTreeVisitor> passes;
 
-	public ProcessClass(JadxArgs args) {
-		this.passes = Jadx.getPassesList(args);
+	public ProcessClass(List<IDexTreeVisitor> passesList) {
+		this.passes = passesList;
 	}
 
 	@Nullable

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -37,6 +37,7 @@
 import jadx.api.plugins.input.data.impl.ListConsumer;
 import jadx.api.usage.IUsageInfoData;
 import jadx.core.Consts;
+import jadx.core.Jadx;
 import jadx.core.ProcessClass;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
@@ -324,7 +325,7 @@ public ICodeInfo decompileWithMode(DecompilationMode mode) {
 			try {
 				unload();
 				args.setDecompilationMode(mode);
-				ProcessClass process = new ProcessClass(args);
+				ProcessClass process = new ProcessClass(Jadx.getPassesList(args));
 				process.initPasses(root);
 				return process.generateCode(this);
 			} finally {

File: jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java
Patch:
@@ -19,7 +19,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.RootNode;
-import jadx.core.utils.DebugChecks;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.tests.api.utils.TestUtils;
 
@@ -37,7 +36,6 @@ protected JadxArgs prepare(String inputFile) {
 	}
 
 	protected JadxArgs prepare(File input) {
-		DebugChecks.checksEnabled = false;
 		JadxArgs args = new JadxArgs();
 		args.getInputFiles().add(input);
 		args.setOutDir(new File("../jadx-external-tests-tmp"));

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -348,11 +348,11 @@ public static List<Path> toPathsWithTrim(File[] files) {
 	}
 
 	public static Path toPathWithTrim(File file) {
-		return Path.of(file.getPath().stripTrailing());
+		return toPathWithTrim(file.getPath());
 	}
 
 	public static Path toPathWithTrim(String file) {
-		return Path.of(file.stripTrailing());
+		return Path.of(file.trim());
 	}
 
 	public static List<Path> fileNamesToPaths(List<String> fileNames) {

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java
Patch:
@@ -56,11 +56,11 @@ public List<Path> showDialog() {
 		data.setCurrentDir(getCurrentDirectory().toPath());
 		File[] selectedFiles = getSelectedFiles();
 		if (selectedFiles.length != 0) {
-			return FileUtils.toPaths(selectedFiles);
+			return FileUtils.toPathsWithTrim(selectedFiles);
 		}
 		File chosenFile = getSelectedFile();
 		if (chosenFile != null) {
-			return Collections.singletonList(chosenFile.toPath());
+			return Collections.singletonList(FileUtils.toPathWithTrim(chosenFile));
 		}
 		return Collections.emptyList();
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileDialog.java
Patch:
@@ -37,10 +37,10 @@ public List<Path> showDialog() {
 		File[] selectedFiles = fileDialog.getFiles();
 		if (!Utils.isEmpty(selectedFiles)) {
 			data.setCurrentDir(Paths.get(fileDialog.getDirectory()));
-			return FileUtils.toPaths(selectedFiles);
+			return FileUtils.toPathsWithTrim(selectedFiles);
 		}
 		if (fileDialog.getFile() != null) {
-			return Collections.singletonList(Paths.get(fileDialog.getFile()));
+			return Collections.singletonList(FileUtils.toPathWithTrim(fileDialog.getFile()));
 		}
 		return Collections.emptyList();
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java
Patch:
@@ -115,8 +115,8 @@ private static RegisterArg insertPhiInsn(MethodNode mth, BlockNode curBlock,
 
 		PhiInsn phiInsn = SSATransform.addPhi(mth, crossBlock, useArg.getRegNum());
 		phiInsn.setResult(useArg.duplicate());
-		phiInsn.bindArg(newResArg.duplicate(), BlockUtils.getPrevBlockOnPath(crossBlock, curBlock));
-		phiInsn.bindArg(otherResArg.duplicate(), BlockUtils.getPrevBlockOnPath(crossBlock, otherBlock));
+		phiInsn.bindArg(newResArg.duplicate(), BlockUtils.getPrevBlockOnPath(mth, crossBlock, curBlock));
+		phiInsn.bindArg(otherResArg.duplicate(), BlockUtils.getPrevBlockOnPath(mth, crossBlock, otherBlock));
 		phiInsn.rebindArgs();
 
 		otherCtr.setResult(otherResArg.duplicate());

File: jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java
Patch:
@@ -202,7 +202,7 @@ private List<ArgType> checkArgTypes(MethodNode mth, SignatureParser sp, List<Arg
 			}
 			if (mthInfo.isConstructor() && !mthArgTypes.isEmpty() && !parsedArgTypes.isEmpty()) {
 				// add synthetic arg for outer class (see test TestGeneric8)
-				ArrayList<ArgType> newArgTypes = new ArrayList<>(parsedArgTypes);
+				List<ArgType> newArgTypes = new ArrayList<>(parsedArgTypes);
 				newArgTypes.add(0, mthArgTypes.get(0));
 				if (newArgTypes.size() == mthArgTypes.size()) {
 					return newArgTypes;

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java
Patch:
@@ -256,7 +256,7 @@ private void fillTypeCandidates(SSAVar ssaVar) {
 		} else {
 			varInfo.setTypeResolved(false);
 			varInfo.setCurrentType(ArgType.UNKNOWN);
-			ArrayList<ArgType> types = new ArrayList<>(candidateTypes);
+			List<ArgType> types = new ArrayList<>(candidateTypes);
 			types.sort(typeCompare.getReversedComparator());
 			varInfo.setCandidateTypes(Collections.unmodifiableList(types));
 		}

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java
Patch:
@@ -15,6 +15,7 @@
 
 public class TestCastInOverloadedInvoke extends IntegrationTest {
 
+	@SuppressWarnings("IllegalType")
 	public static class TestCls {
 		int c = 0;
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestHierarchyOverloadedInvoke.java
Patch:
@@ -14,6 +14,7 @@
 
 public class TestHierarchyOverloadedInvoke extends IntegrationTest {
 
+	@SuppressWarnings("IllegalType")
 	public static class TestCls {
 		static int c = 0;
 		B b = new B();

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.tests.integration.loops;
 
+import java.util.List;
+
 import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
@@ -11,7 +13,7 @@
 public class TestLoopCondition extends IntegrationTest {
 
 	public static class TestCls {
-		public void test(java.util.ArrayList<String> list) {
+		public void test(List<String> list) {
 			for (int i = 0; i != 16 && i < 255; i++) {
 				list.set(i, "ABC");
 				if (i == 128) {

File: jadx-gui/src/main/java/jadx/gui/settings/ui/JPreferredFontChooser.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 
 import org.slf4j.Logger;
@@ -28,7 +29,7 @@ protected String[] getFontFamilies() {
 			GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
 			Set<String> fontSet = new HashSet<>();
 			Collections.addAll(fontSet, env.getAvailableFontFamilyNames());
-			ArrayList<String> found = new ArrayList<>(PREFERRED_FONTS.length);
+			List<String> found = new ArrayList<>(PREFERRED_FONTS.length);
 			for (String font : PREFERRED_FONTS) {
 				if (fontSet.contains(font)) {
 					found.add(font);

File: jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsTree.java
Patch:
@@ -1,6 +1,5 @@
 package jadx.gui.settings.ui;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
@@ -52,7 +51,7 @@ private void switchGroup(JPanel groupPanel) {
 	}
 
 	private static void setNodeExpandedState(JTree tree, TreeNode node, boolean expanded) {
-		ArrayList<? extends TreeNode> list = Collections.list(node.children());
+		List<? extends TreeNode> list = Collections.list(node.children());
 		for (TreeNode treeNode : list) {
 			setNodeExpandedState(tree, treeNode, expanded);
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/tab/ITabStatesListener.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.ui.tab;
 
-import java.util.ArrayList;
+import java.util.List;
 
 import jadx.gui.ui.codearea.EditorViewState;
 
@@ -23,7 +23,7 @@ public interface ITabStatesListener {
 
 	void onTabsRestoreDone();
 
-	void onTabsReorder(ArrayList<TabBlueprint> blueprints);
+	void onTabsReorder(List<TabBlueprint> blueprints);
 
 	void onTabSave(TabBlueprint blueprint, EditorViewState viewState);
 }

File: jadx-gui/src/main/java/jadx/gui/ui/tab/QuickTabsTree.java
Patch:
@@ -6,7 +6,7 @@
 import java.awt.event.KeyEvent;
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;
-import java.util.ArrayList;
+import java.util.List;
 
 import javax.swing.JPopupMenu;
 import javax.swing.JTree;
@@ -238,7 +238,7 @@ public void onTabsRestoreDone() {
 	}
 
 	@Override
-	public void onTabsReorder(ArrayList<TabBlueprint> blueprints) {
+	public void onTabsReorder(List<TabBlueprint> blueprints) {
 
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java
Patch:
@@ -569,8 +569,8 @@ public void onTabsRestoreDone() {
 	}
 
 	@Override
-	public void onTabsReorder(ArrayList<TabBlueprint> blueprints) {
-		ArrayList<TabBlueprint> newBlueprints = new ArrayList<>();
+	public void onTabsReorder(List<TabBlueprint> blueprints) {
+		List<TabBlueprint> newBlueprints = new ArrayList<>();
 		for (ContentPanel contentPanel : getTabs()) {
 			Optional<TabBlueprint> blueprintFindResult = blueprints.stream()
 					.filter(b -> b.getNode() == contentPanel.getNode())

File: jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java
Patch:
@@ -15,7 +15,7 @@
 public class TabsController {
 	private final transient MainWindow mainWindow;
 	private final Map<JNode, TabBlueprint> tabsMap = new HashMap<>();
-	private final ArrayList<ITabStatesListener> listeners = new ArrayList<>();
+	private final List<ITabStatesListener> listeners = new ArrayList<>();
 
 	private boolean forceClose;
 
@@ -223,7 +223,7 @@ public void notifyRestoreEditorViewStateDone() {
 	}
 
 	public List<EditorViewState> getEditorViewStates() {
-		ArrayList<TabBlueprint> reorderedTabs = new ArrayList<>(tabsMap.values());
+		List<TabBlueprint> reorderedTabs = new ArrayList<>(tabsMap.values());
 		listeners.forEach(l -> l.onTabsReorder(reorderedTabs));
 		List<EditorViewState> states = new ArrayList<>();
 		for (TabBlueprint blueprint : reorderedTabs) {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -68,7 +68,7 @@ public String getName() {
 		return javaNode.getName();
 	}
 
-	public boolean isPinnable() {
+	public boolean supportsQuickTabs() {
 		return true;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeContentPanel.java
Patch:
@@ -56,10 +56,11 @@ public String getTabTooltip() {
 	}
 
 	@Override
-	public EditorViewState getEditorViewState() {
+	public void saveEditorViewState(EditorViewState viewState) {
 		int caretPos = codePanel.getCodeArea().getCaretPosition();
 		Point viewPoint = codePanel.getCodeScrollPane().getViewport().getViewPosition();
-		return new EditorViewState(getNode(), "", caretPos, viewPoint);
+		viewState.setCaretPos(caretPos);
+		viewState.setViewPoint(viewPoint);
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/ui/panel/IViewStateSupport.java
Patch:
@@ -4,7 +4,7 @@
 
 public interface IViewStateSupport {
 
-	EditorViewState getEditorViewState();
+	void saveEditorViewState(EditorViewState viewState);
 
 	void restoreEditorViewState(EditorViewState viewState);
 }

File: jadx-gui/src/main/java/jadx/gui/ui/tab/QuickTabsPinParentNode.java
Patch:
@@ -9,8 +9,8 @@
 import jadx.gui.utils.NLS;
 
 public class QuickTabsPinParentNode extends QuickTabsParentNode {
-	protected QuickTabsPinParentNode(TabbedPane tabbedPane) {
-		super(tabbedPane);
+	protected QuickTabsPinParentNode(TabsController tabsController) {
+		super(tabsController);
 	}
 
 	@Override
@@ -31,7 +31,7 @@ JPopupMenu onTreePopupMenu(MainWindow mainWindow) {
 
 		JPopupMenu menu = new JPopupMenu();
 		JMenuItem unpinAll = new JMenuItem(NLS.str("tabs.unpin_all"));
-		unpinAll.addActionListener(e -> getTabbedPane().unpinAll());
+		unpinAll.addActionListener(e -> getTabsController().unpinAllTabs());
 		menu.add(unpinAll);
 
 		return menu;

File: jadx-gui/src/main/java/jadx/gui/ui/treenodes/StartPageNode.java
Patch:
@@ -34,7 +34,7 @@ public JClass getJParent() {
 	}
 
 	@Override
-	public boolean isPinnable() {
+	public boolean supportsQuickTabs() {
 		return false;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -90,7 +90,6 @@ public enum AFlag {
 
 	REQUEST_IF_REGION_OPTIMIZE, // run if region visitor again
 	REQUEST_CODE_SHRINK,
-	RERUN_SSA_TRANSFORM,
 
 	METHOD_CANDIDATE_FOR_INLINE,
 	USE_LINES_HINTS, // source lines info in methods can be trusted

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -43,6 +43,9 @@ public void bindArg(RegisterArg arg, BlockNode pred) {
 		if (blockBinds.contains(pred)) {
 			throw new JadxRuntimeException("Duplicate predecessors in PHI insn: " + pred + ", " + this);
 		}
+		if (pred == null) {
+			throw new JadxRuntimeException("Null bind block in PHI insn: " + this);
+		}
 		super.addArg(arg);
 		blockBinds.add(pred);
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java
Patch:
@@ -92,7 +92,6 @@ public AbstractCodeArea(ContentPanel contentPanel, JNode node) {
 
 		JadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();
 		setLineWrap(settings.isCodeAreaLineWrap());
-		addWrapLineMenuAction(settings);
 
 		ZoomActions.register(this, settings, this::loadSettings);
 
@@ -135,6 +134,7 @@ protected JPopupMenu createPopupMenu() {
 			menu.add(createPopupMenuItem(getAction(SELECT_ALL_ACTION)));
 		}
 		appendFoldingMenu(menu);
+		appendWrapLineMenu(menu);
 		return menu;
 	}
 
@@ -146,8 +146,8 @@ protected void appendFoldingMenu(JPopupMenu popup) {
 		}
 	}
 
-	private void addWrapLineMenuAction(JadxSettings settings) {
-		JPopupMenu popupMenu = getPopupMenu();
+	private void appendWrapLineMenu(JPopupMenu popupMenu) {
+		JadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();
 		popupMenu.addSeparator();
 		JCheckBoxMenuItem wrapItem = new JCheckBoxMenuItem(NLS.str("popup.line_wrap"), getLineWrap());
 		wrapItem.setAction(new AbstractAction(NLS.str("popup.line_wrap")) {

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -250,6 +250,7 @@ public MainWindow(JadxSettings settings) {
 		this.cacheManager = new CacheManager(settings);
 		this.shortcutsController = new ShortcutsController(settings);
 
+		JadxEventQueue.register();
 		resetCache();
 		FontUtils.registerBundledFonts();
 		setEditorTheme(settings.getEditorThemePath());

File: jadx-gui/src/main/java/jadx/gui/utils/SystemInfo.java
Patch:
@@ -17,6 +17,7 @@ public class SystemInfo {
 	public static final boolean IS_WINDOWS = LOWER_OS_NAME.startsWith("windows");
 	public static final boolean IS_MAC = LOWER_OS_NAME.startsWith("mac");
 	public static final boolean IS_LINUX = LOWER_OS_NAME.startsWith("linux");
+	public static final boolean IS_UNIX = !IS_WINDOWS;
 
 	private SystemInfo() {
 	}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -24,8 +24,8 @@
 import jadx.core.dex.nodes.ICodeNode;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.ui.codearea.ClassCodeContentPanel;
-import jadx.gui.ui.dialog.RenameDialog;
 import jadx.gui.ui.panel.ContentPanel;
+import jadx.gui.ui.popupmenu.JClassPopupMenu;
 import jadx.gui.ui.tab.TabbedPane;
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.Icons;
@@ -130,7 +130,7 @@ public String getSyntaxName() {
 
 	@Override
 	public JPopupMenu onTreePopupMenu(MainWindow mainWindow) {
-		return RenameDialog.buildRenamePopup(mainWindow, this);
+		return new JClassPopupMenu(mainWindow, this);
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileOpenMode.java
Patch:
@@ -7,5 +7,7 @@ public enum FileOpenMode {
 	SAVE_PROJECT,
 	EXPORT,
 	CUSTOM_SAVE,
-	CUSTOM_OPEN
+	CUSTOM_OPEN,
+	EXPORT_NODE,
+	EXPORT_NODE_FOLDER,
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java
Patch:
@@ -627,7 +627,7 @@ private static void removeUnusedExcHandlers(MethodNode mth, List<TryCatchBlockAt
 				continue;
 			}
 			for (TryCatchBlockAttr tcb : tryBlocks) {
-				if (tcb.getHandlers().contains(handlerBlock)) {
+				if (tcb.getHandlers().contains(eh)) {
 					notProcessed = false;
 					break;
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -445,8 +445,9 @@ private boolean canInsertBreak(BlockNode exit) {
 		List<BlockNode> simplePath = BlockUtils.buildSimplePath(exit);
 		if (!simplePath.isEmpty()) {
 			BlockNode lastBlock = simplePath.get(simplePath.size() - 1);
-			if (lastBlock.contains(AFlag.RETURN)
-					|| lastBlock.getSuccessors().isEmpty()) {
+			if (lastBlock.isMthExitBlock()
+					|| lastBlock.isReturnBlock()
+					|| mth.isPreExitBlock(lastBlock)) {
 				return false;
 			}
 		}

File: jadx-plugins/jadx-rename-mappings/src/main/java/jadx/plugins/mappings/utils/DalvikToJavaBytecodeUtils.java
Patch:
@@ -46,7 +46,7 @@ private static Integer getMethodArgLvIndexViaSsaVars(int regNum, MethodNode mth)
 
 	// Method vars
 
-	public static Integer getMethodVarLvIndex(VarNode methodVar) {
+	public static int getMethodVarLvIndex(VarNode methodVar) {
 		MethodNode mth = methodVar.getMth();
 		Integer lvIndex = getMethodVarLvIndexViaSsaVars(methodVar.getReg(), mth);
 		if (lvIndex != null) {

File: jadx-core/src/main/java/jadx/core/utils/android/AppAttribute.java
Patch:
@@ -7,4 +7,5 @@ public enum AppAttribute {
 	VERSION_CODE,
 	VERSION_NAME,
 	MAIN_ACTIVITY,
+	APPLICATION,
 }

File: jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java
Patch:
@@ -154,7 +154,7 @@ public String getProcessName() {
 			return null;
 		}
 		ApplicationParams results = parser.parse();
-		String mainActivityName = results.getMainActivityName();
+		String mainActivityName = results.getMainActivity();
 		if (mainActivityName == null) {
 			UiUtils.errorMessage(mw, NLS.str("adb_dialog.msg_read_mani_fail"));
 			return null;
@@ -163,7 +163,7 @@ public String getProcessName() {
 			UiUtils.errorMessage(mw, "Invalid main activity name");
 			return null;
 		}
-		JavaClass mainActivityClass = results.getMainActivity(decompiler);
+		JavaClass mainActivityClass = results.getMainActivityJavaClass(decompiler);
 		if (mainActivityClass == null) {
 			UiUtils.errorMessage(mw, NLS.str("error_dialog.not_found", "Main activity class"));
 			return null;

File: jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java
Patch:
@@ -51,8 +51,10 @@ public enum ActionModel {
 			Shortcut.keyboard(KeyEvent.VK_N, UiUtils.ctrlButton())),
 	COMMENT_SEARCH(MENU_TOOLBAR, "menu.comment_search", "menu.comment_search", "ui/usagesFinder",
 			Shortcut.keyboard(KeyEvent.VK_SEMICOLON, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),
-	GOTO_MAIN_ACTIVITY(MENU_TOOLBAR, "menu.goto_main_activity", "menu.goto_main_activity", "ui/home",
+	GO_TO_MAIN_ACTIVITY(MENU_TOOLBAR, "menu.go_to_main_activity", "menu.go_to_main_activity", "ui/home",
 			Shortcut.keyboard(KeyEvent.VK_M, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),
+	GO_TO_APPLICATION(MENU_TOOLBAR, "menu.go_to_application", "menu.go_to_application", "ui/application",
+			Shortcut.keyboard(KeyEvent.VK_A, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),
 	DECOMPILE_ALL(MENU_TOOLBAR, "menu.decompile_all", "menu.decompile_all", "ui/runAll",
 			Shortcut.none()),
 	RESET_CACHE(MENU_TOOLBAR, "menu.reset_cache", "menu.reset_cache", "ui/reset",

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -12,7 +12,7 @@ protected ParserConstants() {
 	protected static final String ANDROID_NS_VALUE = "android";
 
 	/**
-	 * Chunk types
+	 * Chunk types as defined in frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h (AOSP)
 	 */
 	protected static final int RES_NULL_TYPE = 0x0000;
 	protected static final int RES_STRING_POOL_TYPE = 0x0001;

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java
Patch:
@@ -13,7 +13,6 @@
 import javax.swing.JFileChooser;
 import javax.swing.JOptionPane;
 import javax.swing.UIManager;
-import javax.swing.filechooser.FileNameExtensionFilter;
 
 import jadx.api.plugins.utils.CommonFileUtils;
 import jadx.core.utils.Utils;
@@ -44,7 +43,7 @@ public List<Path> showDialog() {
 		List<String> fileExtList = data.getFileExtList();
 		if (Utils.notEmpty(fileExtList)) {
 			String description = NLS.str("file_dialog.supported_files") + ": (" + Utils.listToString(fileExtList) + ')';
-			setFileFilter(new FileNameExtensionFilter(description, fileExtList.toArray(new String[0])));
+			setFileFilter(new FileNameMultiExtensionFilter(description, fileExtList.toArray(new String[0])));
 		}
 		if (data.getSelectedFile() != null) {
 			setSelectedFile(data.getSelectedFile().toFile());

File: jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java
Patch:
@@ -20,7 +20,7 @@
 import jadx.api.JadxArgs;
 import jadx.core.dex.nodes.RootNode;
 import jadx.core.utils.android.TextResMapFile;
-import jadx.core.xmlgen.ResTableParser;
+import jadx.core.xmlgen.ResTableBinaryParser;
 
 /**
  * Utility class for convert '.arsc' to simple text file with mapping id to resource name
@@ -54,7 +54,7 @@ public static void main(String[] args) throws IOException {
 		rewritesCount = 0;
 		for (Path resFile : inputPaths) {
 			LOG.info("Processing {}", resFile);
-			ResTableParser resTableParser = new ResTableParser(root, true);
+			ResTableBinaryParser resTableParser = new ResTableBinaryParser(root, true);
 			if (resFile.getFileName().toString().endsWith(".jar")) {
 				// Load resources.arsc from android.jar
 				try (ZipFile zip = new ZipFile(resFile.toFile())) {

File: jadx-core/src/main/java/jadx/core/xmlgen/IResTableParser.java
Patch:
@@ -3,10 +3,12 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-public interface IResParser {
+public interface IResTableParser {
 
 	void decode(InputStream inputStream) throws IOException;
 
+	ResContainer decodeFiles();
+
 	ResourceStorage getResStorage();
 
 	BinaryXMLStrings getStrings();

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java
Patch:
@@ -83,7 +83,8 @@ private void initForMode(FileOpenMode mode) {
 
 			case ADD:
 				title = NLS.str("file.add_files_action");
-				fileExtList = OPEN_FILES_EXTS;
+				fileExtList = new ArrayList<>(OPEN_FILES_EXTS);
+				fileExtList.add("aab");
 				selectionMode = JFileChooser.FILES_AND_DIRECTORIES;
 				currentDir = mainWindow.getSettings().getLastOpenFilePath();
 				isOpen = true;

File: jadx-cli/src/main/java/jadx/cli/JadxCLICommands.java
Patch:
@@ -7,6 +7,7 @@
 
 import jadx.cli.commands.CommandPlugins;
 import jadx.cli.commands.ICommand;
+import jadx.core.utils.exceptions.JadxArgsValidateException;
 
 public class JadxCLICommands {
 	private static final Map<String, ICommand> COMMANDS_MAP = new TreeMap<>();
@@ -26,7 +27,8 @@ public static void append(JCommander.Builder builder) {
 	public static boolean process(JCommanderWrapper<?> jcw, JCommander jc, String parsedCommand) {
 		ICommand command = COMMANDS_MAP.get(parsedCommand);
 		if (command == null) {
-			throw new IllegalArgumentException("Unknown command: " + parsedCommand);
+			throw new JadxArgsValidateException("Unknown command: " + parsedCommand
+					+ ". Expected one of: " + COMMANDS_MAP.keySet());
 		}
 		JCommander subCommander = jc.getCommands().get(parsedCommand);
 		command.process(jcw, subCommander);

File: jadx-cli/src/test/java/jadx/cli/RenameConverterTest.java
Patch:
@@ -7,6 +7,7 @@
 
 import jadx.api.JadxArgs.RenameEnum;
 import jadx.cli.JadxCLIArgs.RenameConverter;
+import jadx.core.utils.exceptions.JadxArgsValidateException;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -38,7 +39,7 @@ public void none() {
 
 	@Test
 	public void wrong() {
-		IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,
+		JadxArgsValidateException thrown = assertThrows(JadxArgsValidateException.class,
 				() -> converter.convert("wrong"),
 				"Expected convert() to throw, but it didn't");
 

File: jadx-core/src/main/java/jadx/api/impl/SimpleCodeWriter.java
Patch:
@@ -44,7 +44,7 @@ public SimpleCodeWriter(JadxArgs args) {
 	public SimpleCodeWriter() {
 		this.insertLineNumbers = false;
 		this.singleIndentStr = JadxArgs.DEFAULT_INDENT_STR;
-		this.newLineStr = JadxArgs.DEFAULT_INDENT_STR;
+		this.newLineStr = JadxArgs.DEFAULT_NEW_LINE_STR;
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/device/debugger/smali/SmaliWriter.java
Patch:
@@ -11,6 +11,7 @@ public class SmaliWriter extends SimpleCodeWriter {
 	private final ClassNode cls;
 
 	public SmaliWriter(ClassNode cls) {
+		super(cls.root().getArgs());
 		this.cls = cls;
 	}
 

File: jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java
Patch:
@@ -108,6 +108,7 @@ public void printUsage() {
 		out.println(appendPluginOptions(maxNamesLen));
 		out.println();
 		out.println("Environment variables:");
+		out.println("  JADX_DISABLE_XML_SECURITY - set to 'true' to disable all security checks for XML files");
 		out.println("  JADX_DISABLE_ZIP_SECURITY - set to 'true' to disable all security checks for zip files");
 		out.println("  JADX_ZIP_MAX_ENTRIES_COUNT - maximum allowed number of entries in zip files (default: 100 000)");
 		out.println("  JADX_TMP_DIR - custom temp directory, using system by default");

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -86,7 +86,7 @@ private Document loadXML(String xml) {
 			if (xmlStream == null) {
 				throw new JadxRuntimeException(xml + " not found in classpath");
 			}
-			DocumentBuilder dBuilder = XmlSecurity.getSecureDbf().newDocumentBuilder();
+			DocumentBuilder dBuilder = XmlSecurity.getDBF().newDocumentBuilder();
 			doc = dBuilder.parse(xmlStream);
 		} catch (Exception e) {
 			throw new JadxRuntimeException("Xml load error, file: " + xml, e);

File: jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java
Patch:
@@ -76,7 +76,7 @@ public String getAppPackage() {
 	}
 
 	public void setAppPackage(String appPackage) {
-		this.appPackage = appPackage;
+		this.appPackage = XmlSecurity.verifyAppPackage(appPackage);
 	}
 
 	public Map<Integer, String> getResourcesNames() {

File: jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java
Patch:
@@ -309,6 +309,7 @@ public static void showMessageBox(Component parent, String msg) {
 	}
 
 	public static void errorMessage(Component parent, String message) {
+		LOG.error(message);
 		JOptionPane.showMessageDialog(parent, message,
 				NLS.str("message.errorTitle"), JOptionPane.ERROR_MESSAGE);
 	}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -106,4 +106,5 @@ public enum AFlag {
 	DONT_UNLOAD_CLASS, // don't unload class after code generation (only for tests and debug!)
 
 	RESOLVE_JAVA_JSR,
+	COMPUTE_POST_DOM,
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -521,6 +521,7 @@ private SwitchInsn makeSwitch(InsnData insn, boolean packed) {
 		if (payload != null) {
 			swInsn.attachSwitchData(new SwitchData((ISwitchPayload) payload), insn.getTarget());
 		}
+		method.add(AFlag.COMPUTE_POST_DOM);
 		return swInsn;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/NotificationAttrNode.java
Patch:
@@ -30,7 +30,7 @@ public void addCodeComment(String comment) {
 		addAttr(AType.CODE_COMMENTS, new CodeComment(comment, CommentStyle.LINE));
 	}
 
-	public void addCodeComment(CommentStyle style, String comment) {
+	public void addCodeComment(String comment, CommentStyle style) {
 		addAttr(AType.CODE_COMMENTS, new CodeComment(comment, style));
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -936,7 +936,7 @@ private void makeInvokeLambda(ICodeWriter code, InvokeCustomNode customNode) thr
 		makeInlinedLambdaMethod(code, customNode, callMth);
 	}
 
-	private void makeRefLambda(ICodeWriter code, InvokeCustomNode customNode) {
+	private void makeRefLambda(ICodeWriter code, InvokeCustomNode customNode) throws CodegenException {
 		InsnNode callInsn = customNode.getCallInsn();
 		if (callInsn instanceof ConstructorInsn) {
 			MethodInfo callMth = ((ConstructorInsn) callInsn).getCallMth();
@@ -950,7 +950,7 @@ private void makeRefLambda(ICodeWriter code, InvokeCustomNode customNode) {
 			if (customNode.getHandleType() == MethodHandleType.INVOKE_STATIC) {
 				useClass(code, callMth.getDeclClass());
 			} else {
-				code.add("this");
+				addArg(code, customNode.getArg(0));
 			}
 			code.add("::").add(callMth.getAlias());
 		}

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/ConstPoolReader.java
Patch:
@@ -221,6 +221,8 @@ public EncodedValue readAsEncodedValue(int idx) {
 				return new EncodedValue(EncodedType.ENCODED_LONG, data.readS8());
 			case DOUBLE:
 				return new EncodedValue(EncodedType.ENCODED_DOUBLE, Double.longBitsToDouble(data.readU8()));
+			case CLASS:
+				return new EncodedValue(EncodedType.ENCODED_TYPE, getClass(idx));
 			case METHOD_TYPE:
 				return new EncodedValue(EncodedType.ENCODED_METHOD_TYPE, DescriptorParser.parseToMethodProto(getUtf8(readU2())));
 			case METHOD_HANDLE:

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -460,6 +460,9 @@ private void open(List<Path> paths, Runnable onFinish) {
 	}
 
 	private boolean openSingleFile(Path singleFile, Runnable onFinish) {
+		if (singleFile.getFileName() == null) {
+			return false;
+		}
 		String fileExtension = CommonFileUtils.getFileExtension(singleFile.getFileName().toString());
 		if (fileExtension != null && fileExtension.equalsIgnoreCase(JadxProject.PROJECT_EXTENSION)) {
 			openProject(singleFile, onFinish);

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -34,7 +34,7 @@
 
 public class JadxCLIArgs {
 
-	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab, .xapk)")
+	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab, .xapk, .jadx.kts)")
 	protected List<String> files = new ArrayList<>(1);
 
 	@Parameter(names = { "-d", "--output-dir" }, description = "output directory")

File: jadx-core/src/main/java/jadx/api/plugins/options/OptionFlag.java
Patch:
@@ -12,12 +12,12 @@ public enum OptionFlag {
 	HIDE_IN_GUI,
 
 	/**
-	 * Do not show this option in jadx-gui (useful if option is configured with custom ui)
+	 * Option will be read-only in jadx-gui (can be used for calculated properties)
 	 */
 	DISABLE_IN_GUI,
 
 	/**
-	 * Add this flag only if option do not affect generated code.
+	 * Add this flag only if the option does not affect generated code.
 	 * If added, option value change will not cause code cache reset.
 	 */
 	NOT_CHANGING_CODE,

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java
Patch:
@@ -78,7 +78,7 @@ private List<DexReader> load(@Nullable File file, InputStream inputStream, Strin
 
 	public DexReader loadDexReader(String fileName, byte[] content) {
 		if (options.isVerifyChecksum()) {
-			DexCheckSum.verify(content);
+			DexCheckSum.verify(content, fileName);
 		}
 		return new DexReader(getNextUniqId(), fileName, content);
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java
Patch:
@@ -36,7 +36,6 @@
 import org.fife.ui.rsyntaxtextarea.TokenTypes;
 import org.fife.ui.rtextarea.SearchContext;
 import org.fife.ui.rtextarea.SearchEngine;
-import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -108,7 +107,6 @@ public AbstractCodeArea(ContentPanel contentPanel, JNode node) {
 	private void applyEditableProperties(JNode node) {
 		boolean editable = node.isEditable();
 		setEditable(editable);
-		setCodeFoldingEnabled(editable);
 		if (editable) {
 			setCloseCurlyBraces(true);
 			setCloseMarkupTags(true);
@@ -337,7 +335,7 @@ public static boolean isWordToken(@Nullable Token token) {
 		}
 	}
 
-	public abstract @NotNull ICodeInfo getCodeInfo();
+	public abstract ICodeInfo getCodeInfo();
 
 	/**
 	 * Implement in this method the code that loads and sets the content to be displayed

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -61,6 +61,7 @@ public final class CodeArea extends AbstractCodeArea {
 		}
 
 		setHyperlinksEnabled(true);
+		setCodeFoldingEnabled(true);
 		setLinkScanningMask(InputEvent.CTRL_DOWN_MASK);
 		CodeLinkGenerator codeLinkGenerator = new CodeLinkGenerator(this);
 		setLinkGenerator(codeLinkGenerator);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java
Patch:
@@ -600,7 +600,7 @@ private static void removeUnusedExcHandlers(MethodNode mth, List<TryCatchBlockAt
 		for (ExceptionHandler eh : mth.getExceptionHandlers()) {
 			boolean notProcessed = true;
 			BlockNode handlerBlock = eh.getHandlerBlock();
-			if (blocks.get(handlerBlock)) {
+			if (handlerBlock == null || blocks.get(handlerBlock)) {
 				continue;
 			}
 			for (TryCatchBlockAttr tcb : tryBlocks) {

File: jadx-core/src/main/java/jadx/core/codegen/SimpleModeHelper.java
Patch:
@@ -56,7 +56,7 @@ public List<BlockNode> prepareBlocks() {
 					if (!block.contains(AFlag.EXC_BOTTOM_SPLITTER)) {
 						startLabel.set(block.getId());
 					}
-					if (prev.getSuccessors().size() == 1 && !mth.isPreExitBlocks(prev)) {
+					if (prev.getSuccessors().size() == 1 && !mth.isPreExitBlock(prev)) {
 						endGoto.set(prev.getId());
 					}
 				}
@@ -68,7 +68,7 @@ public List<BlockNode> prepareBlocks() {
 			if (block.contains(AType.EXC_HANDLER)) {
 				startLabel.set(block.getId());
 			}
-			if (nextBlock == null && !mth.isPreExitBlocks(block)) {
+			if (nextBlock == null && !mth.isPreExitBlock(block)) {
 				endGoto.set(block.getId());
 			}
 			prev = block;
@@ -145,7 +145,7 @@ public boolean isNeedEndGoto(BlockNode block) {
 	// DFS sort blocks to reduce goto count
 	private List<BlockNode> getSortedBlocks() {
 		List<BlockNode> list = new ArrayList<>(mth.getBasicBlocks().size());
-		BlockUtils.dfsVisit(mth, list::add);
+		BlockUtils.visitDFS(mth, list::add);
 		return list;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java
Patch:
@@ -68,7 +68,7 @@ public static boolean process(MethodNode mth) {
 		BlockProcessor.removeMarkedBlocks(mth);
 
 		BlockSet sorted = new BlockSet(mth);
-		BlockUtils.dfsVisit(mth, sorted::set);
+		BlockUtils.visitDFS(mth, sorted::set);
 		removeUnusedExcHandlers(mth, tryBlocks, sorted);
 		return true;
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java
Patch:
@@ -70,6 +70,8 @@ private static void processBlocksTree(MethodNode mth) {
 		registerLoops(mth);
 		processNestedLoops(mth);
 
+		PostDominatorTree.compute(mth);
+
 		updateCleanSuccessors(mth);
 		if (!mth.contains(AFlag.DISABLE_BLOCKS_LOCK)) {
 			mth.finishBasicBlocks();

File: jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java
Patch:
@@ -124,8 +124,7 @@ public static void addRenamedComment(ICodeWriter code, NotificationAttrNode node
 		code.startLine("/* renamed from: ").add(origName);
 		RenameReasonAttr renameReasonAttr = node.get(AType.RENAME_REASON);
 		if (renameReasonAttr != null) {
-			code.add("  reason: ");
-			code.add(renameReasonAttr.getDescription());
+			code.add(", reason: ").add(renameReasonAttr.getDescription());
 		}
 		code.add(" */");
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -103,6 +103,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return baseString() + " type: " + type + " call: " + mth + attributesString();
+		return baseString() + " " + type + " call: " + mth + attributesString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java
Patch:
@@ -99,7 +99,7 @@ private static boolean isSyntheticAccessPattern(MethodNode mth, InsnNode firstIn
 						&& retInsn.getArg(0).isSameVar(firstInsn.getResult())
 						&& firstInsn.getArg(0).isSameVar(mthRegs.get(0));
 			case SGET:
-				return mthRegs.size() == 0
+				return mthRegs.isEmpty()
 						&& retInsn.getArg(0).isSameVar(firstInsn.getResult());
 
 			case IPUT:
@@ -113,7 +113,7 @@ private static boolean isSyntheticAccessPattern(MethodNode mth, InsnNode firstIn
 						&& firstInsn.getArg(0).isSameVar(mthRegs.get(0));
 
 			case INVOKE:
-				return mthRegs.size() >= 1
+				return !mthRegs.isEmpty()
 						&& firstInsn.getArg(0).isSameVar(mthRegs.get(0))
 						&& retInsn.getArg(0).isSameVar(firstInsn.getResult());
 			default:

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -89,7 +89,7 @@ private static void searchDebugInfoByOffset(MethodNode mth, SSAVar ssaVar) {
 			return;
 		}
 		OptionalInt max = ssaVar.getUseList().stream().mapToInt(DebugInfoApplyVisitor::getInsnOffsetByArg).max();
-		if (!max.isPresent()) {
+		if (max.isEmpty()) {
 			return;
 		}
 		int startOffset = getInsnOffsetByArg(ssaVar.getAssign());

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundCheckCastAssign.java
Patch:
@@ -8,7 +8,7 @@
 import jadx.core.dex.nodes.RootNode;
 
 /**
- * Allow to ignore down casts (return arg type instead cast type)
+ * Allow ignoring down casts (return arg type instead cast type)
  * Such casts will be removed later.
  */
 public final class TypeBoundCheckCastAssign implements ITypeBoundDynamic {
@@ -36,7 +36,7 @@ public ArgType getType() {
 	}
 
 	private ArgType getReturnType(ArgType argType) {
-		ArgType castType = (ArgType) insn.getIndex();
+		ArgType castType = insn.getIndexAsType();
 		TypeCompareEnum result = root.getTypeCompare().compareTypes(argType, castType);
 		return result.isNarrow() ? argType : castType;
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateFlags.java
Patch:
@@ -1,7 +1,5 @@
 package jadx.core.dex.visitors.typeinference;
 
-import org.jetbrains.annotations.NotNull;
-
 public class TypeUpdateFlags {
 	private static final int ALLOW_WIDER = 1;
 	private static final int IGNORE_SAME = 2;
@@ -14,7 +12,6 @@ public class TypeUpdateFlags {
 
 	private final int flags;
 
-	@NotNull
 	private static TypeUpdateFlags build(int flags) {
 		return new TypeUpdateFlags(flags);
 	}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -149,10 +149,10 @@ public void init() {
 
 	@AfterEach
 	public void after() throws IOException {
-		FileUtils.clearTempRootDir();
 		close(jadxDecompiler);
 		close(sourceCompiler);
 		close(decompiledCompiler);
+		FileUtils.clearTempRootDir();
 	}
 
 	private void close(Closeable closeable) throws IOException {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java
Patch:
@@ -139,14 +139,12 @@ public void clearAttributes() {
 		storage = EMPTY_ATTR_STORAGE;
 	}
 
-	/**
-	 * Remove all attribute
-	 */
 	public void unloadAttributes() {
 		if (storage == EMPTY_ATTR_STORAGE) {
 			return;
 		}
 		storage.unloadAttributes();
+		storage.clearFlags();
 		unloadIfEmpty();
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -432,7 +432,7 @@ public void unload() {
 		}
 		methods.forEach(MethodNode::unload);
 		innerClasses.forEach(ClassNode::unload);
-		fields.forEach(FieldNode::unloadAttributes);
+		fields.forEach(FieldNode::unload);
 		unloadAttributes();
 		setState(NOT_LOADED);
 		this.loadStage = LoadStage.NONE;

File: jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java
Patch:
@@ -79,7 +79,7 @@ private void init() {
 
 		MouseAdapter clickAdapter = new MouseAdapter() {
 			@Override
-			public void mouseClicked(MouseEvent e) {
+			public void mousePressed(MouseEvent e) {
 				if (SwingUtilities.isMiddleMouseButton(e)) {
 					tabbedPane.closeCodePanel(contentPanel);
 				} else if (SwingUtilities.isRightMouseButton(e)) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -275,8 +275,9 @@ private void updateObfuscatedFiles(IResParser parser, List<ResourceFile> resourc
 		for (ResourceFile resource : resources) {
 			ResourceEntry resEntry = entryNames.get(resource.getOriginalName());
 			if (resEntry != null) {
-				resource.setAlias(resEntry);
-				renamedCount++;
+				if (resource.setAlias(resEntry)) {
+					renamedCount++;
+				}
 			}
 		}
 		if (LOG.isDebugEnabled()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java
Patch:
@@ -654,13 +654,14 @@ private static void removeUnreachableBlocks(MethodNode mth) {
 			return;
 		}
 
-		toRemove.forEach(BlockSplitter::detachBlock);
-		mth.getBasicBlocks().removeAll(toRemove);
 		long notEmptyBlocks = toRemove.stream().filter(block -> !block.getInstructions().isEmpty()).count();
 		if (notEmptyBlocks != 0) {
 			int insnsCount = toRemove.stream().mapToInt(block -> block.getInstructions().size()).sum();
 			mth.addWarnComment("Unreachable blocks removed: " + notEmptyBlocks + ", instructions: " + insnsCount);
 		}
+
+		toRemove.forEach(BlockSplitter::detachBlock);
+		mth.getBasicBlocks().removeAll(toRemove);
 	}
 
 	private static void clearBlocksState(MethodNode mth) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java
Patch:
@@ -455,7 +455,6 @@ static void detachBlock(BlockNode block) {
 			successor.getPredecessors().remove(block);
 		}
 		block.add(AFlag.REMOVE);
-		block.getInstructions().clear();
 		block.getPredecessors().clear();
 		block.getSuccessors().clear();
 	}

File: jadx-core/src/main/java/jadx/api/JavaVariable.java
Patch:
@@ -79,6 +79,7 @@ public List<JavaNode> getUseIn() {
 
 	@Override
 	public void removeAlias() {
+		varNode.setName(null);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/rename/CodeRenameVisitor.java
Patch:
@@ -106,7 +106,7 @@ private List<ICodeRename> getRenames(ClassNode cls) {
 		if (clsRenamesMap == null) {
 			return Collections.emptyList();
 		}
-		List<ICodeRename> clsComments = clsRenamesMap.get(cls.getClassInfo().getFullName());
+		List<ICodeRename> clsComments = clsRenamesMap.get(cls.getClassInfo().getRawName());
 		if (clsComments == null) {
 			return Collections.emptyList();
 		}

File: jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java
Patch:
@@ -175,7 +175,6 @@ private boolean checkScript() {
 			errorService.clearErrors();
 			errorService.addCompilerIssues(issues);
 			errorService.addLintErrors(lintErrs);
-			errorService.apply();
 			if (!success) {
 				resultLabel.setText("Compile issues: " + issues.size());
 				showScriptLog();
@@ -184,6 +183,7 @@ private boolean checkScript() {
 			} else {
 				resultLabel.setText("OK");
 			}
+			errorService.apply();
 			return success;
 		} catch (Throwable e) {
 			scriptLog.error("Failed to check code", e);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -25,6 +25,7 @@
 import jadx.core.dex.attributes.nodes.MethodTypeVarsAttr;
 import jadx.core.dex.attributes.nodes.PhiListAttr;
 import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
+import jadx.core.dex.attributes.nodes.RegionRefAttr;
 import jadx.core.dex.attributes.nodes.RenameReasonAttr;
 import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;
 import jadx.core.dex.attributes.nodes.SpecialEdgeAttr;
@@ -94,6 +95,7 @@ public final class AType<T extends IJadxAttribute> implements IJadxAttrType<T> {
 	public static final AType<AttrList<JumpInfo>> JUMP = new AType<>();
 	public static final AType<IMethodDetails> METHOD_DETAILS = new AType<>();
 	public static final AType<GenericInfoAttr> GENERIC_INFO = new AType<>();
+	public static final AType<RegionRefAttr> REGION_REF = new AType<>();
 
 	// register
 	public static final AType<RegDebugInfoAttr> REG_DEBUG_INFO = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -63,7 +63,7 @@
 		runAfter = {
 				CodeShrinkVisitor.class, // all possible instructions already inlined
 				ModVisitor.class,
-				ReSugarCode.class,
+				ReplaceNewArray.class, // values array normalized
 				IfRegionVisitor.class, // ternary operator inlined
 				CheckRegions.class // regions processing finished
 		},

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -22,6 +22,7 @@
 import jadx.core.dex.attributes.nodes.EdgeInsnAttr;
 import jadx.core.dex.attributes.nodes.LoopInfo;
 import jadx.core.dex.attributes.nodes.LoopLabelAttr;
+import jadx.core.dex.attributes.nodes.RegionRefAttr;
 import jadx.core.dex.instructions.IfNode;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.SwitchInsn;
@@ -827,6 +828,7 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchIn
 		}
 
 		SwitchRegion sw = new SwitchRegion(currentRegion, block);
+		insn.addAttr(new RegionRefAttr(sw));
 		currentRegion.getSubBlocks().add(sw);
 		stack.push(sw);
 		stack.addExit(out);

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaCodeReader.java
Patch:
@@ -70,12 +70,11 @@ public void visitInstructions(Consumer<InsnData> insnConsumer) {
 			if (insnInfo == null) {
 				throw new JavaClassParseException("Unknown opcode: 0x" + Integer.toHexString(opcode));
 			}
-			insn.setInsnInfo(insnInfo);
+			insn.setOpcodeUnit(opcode);
 			insn.setInsnInfo(insnInfo);
 			insn.setRegsCount(insnInfo.getRegsCount());
 			insn.setOpcode(insnInfo.getApiOpcode());
 			insn.setPayloadSize(insnInfo.getPayloadSize());
-			insn.setOpcodeUnit(opcode);
 			insn.setPayload(null);
 
 			state.onInsn(offset);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java
Patch:
@@ -644,14 +644,13 @@ public static void removeMarkedBlocks(MethodNode mth) {
 	}
 
 	private static void removeUnreachableBlocks(MethodNode mth) {
-		Set<BlockNode> toRemove = null;
+		Set<BlockNode> toRemove = new LinkedHashSet<>();
 		for (BlockNode block : mth.getBasicBlocks()) {
 			if (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {
-				toRemove = new LinkedHashSet<>();
 				BlockSplitter.collectSuccessors(block, mth.getEnterBlock(), toRemove);
 			}
 		}
-		if (toRemove == null || toRemove.isEmpty()) {
+		if (toRemove.isEmpty()) {
 			return;
 		}
 

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -34,7 +34,7 @@
 
 public class JadxCLIArgs {
 
-	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab)")
+	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab, .xapk)")
 	protected List<String> files = new ArrayList<>(1);
 
 	@Parameter(names = { "-d", "--output-dir" }, description = "output directory")

File: jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java
Patch:
@@ -17,7 +17,7 @@
 public class FileDialogWrapper {
 
 	private static final List<String> OPEN_FILES_EXTS = Arrays.asList(
-			"apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc", "jadx.kts");
+			"apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc", "jadx.kts", "xapk");
 
 	private final MainWindow mainWindow;
 

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java
Patch:
@@ -32,7 +32,6 @@ public class DexFileLoader {
 
 	public DexFileLoader(DexInputOptions options) {
 		this.options = options;
-		resetDexUniqId();
 	}
 
 	public List<DexReader> collectDexFiles(List<Path> pathsList) {

File: jadx-core/src/main/java/jadx/api/plugins/events/types/ReloadProject.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ReloadProject implements IJadxEvent {
 
-	public static final ReloadProject INSTANCE = new ReloadProject();
+	public static final ReloadProject EVENT = new ReloadProject();
 
 	private ReloadProject() {
 		// singleton

File: jadx-gui/src/main/java/jadx/gui/cache/manager/CacheManager.java
Patch:
@@ -111,7 +111,7 @@ private Path buildCacheDir(JadxProject project) {
 		if (Objects.equals(cacheDirValue, ".")) {
 			return buildLocalCacheDir(project);
 		}
-		Path cacheBaseDir = cacheDirValue == null ? JadxFiles.CACHE_DIR : Paths.get(cacheDirValue);
+		Path cacheBaseDir = cacheDirValue == null ? JadxFiles.PROJECTS_CACHE_DIR : Paths.get(cacheDirValue);
 		return cacheBaseDir.resolve(buildProjectUniqName(project));
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettings.java
Patch:
@@ -69,7 +69,7 @@ public void addPlugin() {
 	}
 
 	private void requestReload() {
-		mainWindow.events().send(ReloadProject.INSTANCE);
+		mainWindow.events().send(ReloadProject.EVENT);
 	}
 
 	public void install(String locationId) {

File: jadx-gui/src/main/java/jadx/gui/utils/files/JadxFiles.java
Patch:
@@ -16,6 +16,7 @@ public class JadxFiles {
 	public static final Path CACHES_LIST = Paths.get(CONFIG_DIR, "caches.json");
 
 	public static final Path CACHE_DIR = Paths.get(DIRS.cacheDir);
+	public static final Path PROJECTS_CACHE_DIR = CACHE_DIR.resolve("projects");
 
 	static {
 		FileUtils.makeDirs(Paths.get(CONFIG_DIR));

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java
Patch:
@@ -74,7 +74,7 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {
 		@Override
 		public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {
 			int[] regs = insn.getArgsReg();
-			regs[0] = signedByte1(opcodeUnit);
+			regs[0] = byte1(opcodeUnit);
 			insn.setTarget(insn.getOffset() + in.readShort());
 		}
 	};

File: jadx-core/src/main/java/jadx/core/export/ExportGradleTask.java
Patch:
@@ -55,7 +55,7 @@ public void run() {
 				.orElseGet(() -> resContainers.stream()
 						.filter(resContainer -> resContainer.getFileName().contains("strings.xml"))
 						.findFirst()
-						.orElseThrow(IllegalStateException::new));
+						.orElse(null));
 
 		ExportGradleProject export = new ExportGradleProject(root, projectDir, androidManifest, strings);
 

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -514,7 +514,7 @@ private void addEnumFields(ICodeWriter code) throws CodegenException {
 			}
 			code.add(';');
 			if (isFieldsPresents()) {
-				code.startLine();
+				code.newLine();
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -70,6 +70,7 @@ public BinaryXMLParser(RootNode rootNode) {
 	}
 
 	public synchronized ICodeInfo parse(InputStream inputStream) throws IOException {
+		resourceIds = null;
 		is = new ParserStream(inputStream);
 		if (!isBinaryXml()) {
 			return ResourcesLoader.loadToCodeWriter(inputStream);

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -104,7 +104,6 @@ public ICodeInfo generateCode(ClassNode cls) {
 		try {
 			if (cls.contains(AFlag.DONT_GENERATE)) {
 				process(cls, false);
-				LOG.warn("Requested code for class with DONT_GENERATE flag: {}", cls);
 				return NOT_GENERATED;
 			}
 			for (ClassNode depCls : cls.getDependencies()) {

File: jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java
Patch:
@@ -32,7 +32,7 @@ public MethodSearchProvider(MainWindow mw, SearchSettings searchSettings, List<J
 			if (mthNum < methods.size()) {
 				MethodNode mth = methods.get(mthNum++);
 				if (checkMth(mth.getMethodInfo())) {
-					return convert(mth.getJavaNode());
+					return convert(mth);
 				}
 			} else {
 				clsNum++;

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -9,6 +9,7 @@ public class Consts {
 	public static final boolean DEBUG_EXC_HANDLERS = false;
 	public static final boolean DEBUG_FINALLY = false;
 	public static final boolean DEBUG_ATTRIBUTES = false;
+	public static final boolean DEBUG_RESTRUCTURE = false;
 	public static final boolean DEBUG_EVENTS = true;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -8,6 +8,7 @@
 
 import jadx.api.ICodeWriter;
 import jadx.api.impl.SimpleCodeWriter;
+import jadx.core.Consts;
 import jadx.core.codegen.InsnGen;
 import jadx.core.codegen.MethodGen;
 import jadx.core.dex.attributes.AFlag;
@@ -46,7 +47,8 @@ public void processBlock(MethodNode mth, IBlock container) {
 				if (blocksInRegions.add(block)) {
 					return;
 				}
-				if (LOG.isDebugEnabled()
+				if (Consts.DEBUG_RESTRUCTURE
+						&& LOG.isDebugEnabled()
 						&& !block.contains(AFlag.RETURN)
 						&& !block.contains(AFlag.REMOVE)
 						&& !block.contains(AFlag.SYNTHETIC)

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java
Patch:
@@ -309,7 +309,7 @@ public String toString() {
 			return "TaskWorker{status=" + status
 					+ ", jobsCount=" + jobsCount
 					+ ", jobsComplete=" + jobsComplete
-					+ ", time=" + time + '}';
+					+ ", time=" + time + "ms}";
 		}
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -33,6 +33,7 @@ public enum AFlag {
 	EXC_TOP_SPLITTER,
 	EXC_BOTTOM_SPLITTER,
 	FINALLY_INSNS,
+	IGNORE_THROW_SPLIT,
 
 	SKIP_FIRST_ARG,
 	SKIP_ARG, // skip argument in invoke call

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -37,7 +37,7 @@
 public class BinaryXMLParser extends CommonBinaryParser {
 	private static final Logger LOG = LoggerFactory.getLogger(BinaryXMLParser.class);
 
-	private static final boolean ATTR_NEW_LINE = false;
+	private static final boolean ATTR_NEW_LINE = true;
 
 	private final Map<Integer, String> resNames;
 	private Map<String, String> nsMap;

File: jadx-cli/src/main/java/jadx/cli/SingleClassMode.java
Patch:
@@ -36,7 +36,7 @@ public static boolean process(JadxDecompiler jadx, JadxCLIArgs cliArgs) {
 				throw new JadxRuntimeException("Input class not found: " + singleClass);
 			}
 			if (clsForProcess.contains(AFlag.DONT_GENERATE)) {
-				throw new JadxRuntimeException("Input class can't be saved by currect jadx settings (marked as DONT_GENERATE)");
+				throw new JadxRuntimeException("Input class can't be saved by current jadx settings (marked as DONT_GENERATE)");
 			}
 			if (clsForProcess.isInner()) {
 				clsForProcess = clsForProcess.getTopParentClass();

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -675,13 +675,13 @@ private IndexInsnNode makeSoftCastInsn(RegisterArg result, RegisterArg arg, ArgT
 	}
 
 	private boolean trySplitConstInsns(MethodNode mth) {
-		boolean constSplitted = false;
+		boolean constSplit = false;
 		for (SSAVar var : new ArrayList<>(mth.getSVars())) {
 			if (checkAndSplitConstInsn(mth, var)) {
-				constSplitted = true;
+				constSplit = true;
 			}
 		}
-		if (!constSplitted) {
+		if (!constSplit) {
 			return false;
 		}
 		InitCodeVariables.rerun(mth);

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -155,7 +155,7 @@ protected ParserConstants() {
 	protected static final int FLAG_COMPLEX = 0x0001;
 	// If set, this resource has been declared public, so libraries are allowed to reference it.
 	protected static final int FLAG_PUBLIC = 0x0002;
-	// If set, this is a weak resource and may be overriden by strong resources of the same name/type.
+	// If set, this is a weak resource and may be overridden by strong resources of the same name/type.
 	// This is only useful during linking with other resource tables.
 	protected static final int FLAG_WEAK = 0x0004;
 

File: jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java
Patch:
@@ -392,7 +392,7 @@ void onClassPrepare(ClassPrepareEvent event) {
 
 	public interface MethodEntryListener {
 		/**
-		 * return ture to remove
+		 * return true to remove
 		 */
 		boolean entry(String mthSig);
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliTokenMaker.java
Patch:
@@ -1055,7 +1055,7 @@ private static int zzUnpackTrans(String packed, int offset, int[] result) {
 
 	/* error messages for the codes above */
 	private static final String ZZ_ERROR_MSG[] = {
-			"Unkown internal scanner error",
+			"Unknown internal scanner error",
 			"Error: could not match input",
 			"Error: pushback value was too large"
 	};
@@ -1393,7 +1393,7 @@ public final int yylength() {
 	}
 
 	/**
-	 * Reports an error that occured while scanning.
+	 * Reports an error that occurred while scanning.
 	 *
 	 * In a wellformed scanner (no or only correct usage of
 	 * yypushback(int) and a match-all fallback rule) this method

File: jadx-gui/src/main/java/jadx/gui/utils/layout/WrapLayout.java
Patch:
@@ -92,7 +92,7 @@ public Dimension minimumLayoutSize(Container target) {
 	 */
 	private Dimension layoutSize(Container target, boolean preferred) {
 		synchronized (target.getTreeLock()) {
-			// Each row must fit with the width allocated to the containter.
+			// Each row must fit with the width allocated to the container.
 			// When the container width = 0, the preferred width of the container
 			// has not yet been calculated so lets ask for the maximum.
 
@@ -155,7 +155,7 @@ private Dimension layoutSize(Container target, boolean preferred) {
 
 			// When using a scroll pane or the DecoratedLookAndFeel we need to
 			// make sure the preferred size is less than the size of the
-			// target containter so shrinking the container size works
+			// target container so shrinking the container size works
 			// correctly. Removing the horizontal gap is an easy way to do this.
 
 			Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java
Patch:
@@ -112,10 +112,11 @@ private void updateTitle(String searchText) {
 		}
 	}
 
-	public void updateHighlightContext(String text, boolean caseSensitive, boolean regexp) {
+	public void updateHighlightContext(String text, boolean caseSensitive, boolean regexp, boolean wholeWord) {
 		updateTitle(text);
 		highlightContext = new SearchContext(text);
 		highlightContext.setMatchCase(caseSensitive);
+		highlightContext.setWholeWord(wholeWord);
 		highlightContext.setRegularExpression(regexp);
 		highlightContext.setMarkAll(true);
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -595,7 +595,7 @@ private void updateTable() {
 
 	private void updateTableHighlight() {
 		String text = searchField.getText();
-		updateHighlightContext(text, !options.contains(IGNORE_CASE), options.contains(USE_REGEX));
+		updateHighlightContext(text, !options.contains(IGNORE_CASE), options.contains(USE_REGEX), false);
 		cache.setLastSearch(text);
 		cache.getLastSearchOptions().put(searchPreset, options);
 		if (!mainWindow.getSettings().isUseAutoSearch()) {

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java
Patch:
@@ -160,7 +160,7 @@ protected void loadFinished() {
 
 		Collections.sort(usageList);
 		resultsModel.addAll(usageList);
-		updateHighlightContext(node.getName(), true, false);
+		updateHighlightContext(node.getName(), true, false, true);
 		resultsTable.initColumnWidth();
 		resultsTable.updateTable();
 		updateProgressLabel(true);

File: jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertPlugin.java
Patch:
@@ -32,7 +32,6 @@ public JadxPluginInfo getPluginInfo() {
 	public void init(JadxPluginContext context) {
 		context.registerOptions(options);
 		context.addCodeInput(this);
-		context.registerInputsHashSupplier(options::getOptionsHash);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -79,7 +79,7 @@ public void changeShortName(String aliasName) {
 
 	public void changePkg(String aliasPkg) {
 		if (isInner()) {
-			throw new JadxRuntimeException("Can't change package for inner class");
+			throw new JadxRuntimeException("Can't change package for inner class: " + this);
 		}
 		if (!Objects.equals(getAliasPkg(), aliasPkg)) {
 			ClassAliasInfo newAlias = new ClassAliasInfo(aliasPkg, getAliasShortName());

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -582,7 +582,7 @@ public void rename(String newName) {
 			clsInfo.changeShortName(newName);
 			return;
 		}
-		if (isInner()) {
+		if (clsInfo.isInner()) {
 			addWarn("Can't change package for inner class: " + this + " to " + newName);
 			return;
 		}
@@ -598,7 +598,7 @@ public void rename(String newName) {
 
 	private boolean changeClassNodePackage(String fullPkg) {
 		if (clsInfo.isInner()) {
-			throw new JadxRuntimeException("Can't change package for inner class");
+			throw new JadxRuntimeException("Can't change package for inner class: " + clsInfo);
 		}
 		if (fullPkg.equals(clsInfo.getAliasPkg())) {
 			return false;
@@ -618,7 +618,7 @@ public void removeAlias() {
 
 	@Override
 	public void onParentPackageUpdate(PackageNode updatedPkg) {
-		if (isInner()) {
+		if (clsInfo.isInner()) {
 			return;
 		}
 		clsInfo.changePkg(packageNode.getAliasPkgInfo().getFullName());

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -313,7 +313,7 @@ private void initInnerClasses() {
 		}
 		classes.forEach(ClassNode::updateParentClass);
 		for (PackageNode pkg : packages) {
-			pkg.getClasses().removeIf(ClassNode::isInner);
+			pkg.getClasses().removeIf(cls -> cls.getClassInfo().isInner());
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java
Patch:
@@ -136,8 +136,7 @@ public void removeAttr(IJadxAttribute attr) {
 
 	@Override
 	public void clearAttributes() {
-		storage.clear();
-		unloadIfEmpty();
+		storage = EMPTY_ATTR_STORAGE;
 	}
 
 	/**

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -351,8 +351,8 @@ public void deepUnload() {
 			// manually added class
 			return;
 		}
-		unload();
 		clearAttributes();
+		unload();
 		root().getConstValues().removeForClass(this);
 		load(clsData, true);
 

File: jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -71,7 +72,6 @@
 import io.github.skylot.jdwp.JDWP.VirtualMachine.AllThreads.AllThreadsReplyData;
 import io.github.skylot.jdwp.JDWP.VirtualMachine.AllThreads.AllThreadsReplyDataThreads;
 import io.github.skylot.jdwp.JDWP.VirtualMachine.CreateString.CreateStringReplyData;
-import io.reactivex.annotations.NonNull;
 
 import jadx.api.plugins.input.data.AccessFlags;
 import jadx.gui.device.debugger.smali.RegisterInfo;
@@ -1292,7 +1292,7 @@ public String getType() {
 			return gen;
 		}
 
-		@NonNull
+		@NotNull
 		@Override
 		public String getSignature() {
 			return this.slot.genericSignature.trim();

File: jadx-gui/src/main/java/jadx/gui/plugins/context/CodePopupAction.java
Patch:
@@ -34,12 +34,14 @@ private static class NodeAction extends JNodeAction {
 
 		public NodeAction(CodePopupAction data, CodeArea codeArea) {
 			super(data.name, codeArea);
+			setName(data.name);
+			setShortcutComponent(codeArea);
 			if (data.keyBinding != null) {
 				KeyStroke key = KeyStroke.getKeyStroke(data.keyBinding);
 				if (key == null) {
 					throw new IllegalArgumentException("Failed to parse key stroke: " + data.keyBinding);
 				}
-				addKeyBinding(key, data.name);
+				setKeyBinding(key);
 			}
 			this.data = data;
 		}

File: jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java
Patch:
@@ -62,6 +62,7 @@
 import jadx.gui.settings.LineNumbersMode;
 import jadx.gui.settings.ui.cache.CacheSettingsGroup;
 import jadx.gui.settings.ui.plugins.PluginsSettings;
+import jadx.gui.settings.ui.shortcut.ShortcutsSettingsGroup;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.ui.codearea.EditorTheme;
 import jadx.gui.utils.FontUtils;
@@ -126,6 +127,7 @@ private void initUI() {
 		groups.add(makeRenameGroup());
 		groups.add(new CacheSettingsGroup(this));
 		groups.add(makeAppearanceGroup());
+		groups.add(new ShortcutsSettingsGroup(this, settings));
 		groups.add(makeSearchResGroup());
 		groups.add(makeProjectGroup());
 		groups.add(new PluginsSettings(mainWindow, settings).build());
@@ -640,6 +642,7 @@ private void save() {
 		enableComponents(this, false);
 		SwingUtilities.invokeLater(() -> {
 			if (shouldReload()) {
+				mainWindow.getShortcutsController().loadSettings();
 				mainWindow.reopen();
 			}
 			if (!settings.getLangLocale().equals(prevLang)) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/JsonPrettifyAction.java
Patch:
@@ -6,15 +6,15 @@
 import com.google.gson.JsonParser;
 
 import jadx.gui.treemodel.JNode;
-import jadx.gui.utils.NLS;
+import jadx.gui.ui.action.ActionModel;
 
 public class JsonPrettifyAction extends JNodeAction {
 
 	private static final long serialVersionUID = -2682529369671695550L;
 	private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
 
 	public JsonPrettifyAction(CodeArea codeArea) {
-		super(NLS.str("popup.json_prettify"), codeArea);
+		super(ActionModel.JSON_PRETTIFY, codeArea);
 	}
 
 	@Override

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/JavaInputLoader.java
Patch:
@@ -101,7 +101,7 @@ private List<JavaClassReader> collectFromZip(File file, String name) {
 				}
 			});
 		} catch (Exception e) {
-			LOG.error("Failed to process zip file: {}", file.getAbsolutePath(), e);
+			LOG.error("Failed to process zip file: {}", name, e);
 		}
 		return result;
 	}

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -199,6 +199,7 @@ private void loadPlugins() {
 	}
 
 	private void loadFinished() {
+		LOG.debug("Load finished");
 		List<JadxPass> list = customPasses.get(JadxAfterLoadPass.TYPE);
 		if (list != null) {
 			for (JadxPass pass : list) {

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -209,9 +209,10 @@ public void updateAttributes(IResParser parser) {
 			if (ri.getTypeName().equals("attr") && ri.getNamedValues().size() > 1) {
 				RawNamedValue first = ri.getNamedValues().get(0);
 				MAttrType attrTyp;
-				if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_FLAGS) {
+				int attrTypeVal = first.getRawValue().getData() & 0xff0000;
+				if (attrTypeVal == ValuesParser.ATTR_TYPE_FLAGS) {
 					attrTyp = MAttrType.FLAG;
-				} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM || first.getRawValue().getData() == 65600) {
+				} else if (attrTypeVal == ValuesParser.ATTR_TYPE_ENUM) {
 					attrTyp = MAttrType.ENUM;
 				} else {
 					continue;

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -45,7 +45,7 @@ public class BinaryXMLParser extends CommonBinaryParser {
 	private final Map<String, String> tagAttrDeobfNames = new HashMap<>();
 
 	private ICodeWriter writer;
-	private String[] strings;
+	private BinaryXMLStrings strings;
 	private String currentTag = "ERROR";
 	private boolean firstElement;
 	private ValuesParser valuesParser;
@@ -387,8 +387,8 @@ private String getAttributeName(int id) {
 	}
 
 	private String getString(int strId) {
-		if (0 <= strId && strId < strings.length) {
-			return strings[strId];
+		if (0 <= strId && strId < strings.size()) {
+			return strings.get(strId);
 		}
 		return "NOT_FOUND_STR_0x" + Integer.toHexString(strId);
 	}

File: jadx-core/src/main/java/jadx/core/xmlgen/IResParser.java
Patch:
@@ -9,5 +9,5 @@ public interface IResParser {
 
 	ResourceStorage getResStorage();
 
-	String[] getStrings();
+	BinaryXMLStrings getStrings();
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/ResProtoParser.java
Patch:
@@ -39,7 +39,7 @@ public ResProtoParser(RootNode root) {
 
 	public ResContainer decodeFiles(InputStream inputStream) throws IOException {
 		decode(inputStream);
-		ValuesParser vp = new ValuesParser(new String[0], resStorage.getResourcesNames());
+		ValuesParser vp = new ValuesParser(new BinaryXMLStrings(), resStorage.getResourcesNames());
 		ResXmlGen resGen = new ResXmlGen(resStorage, vp);
 		ICodeInfo content = XmlGenUtils.makeXmlDump(root.makeCodeWriter(), resStorage);
 		List<ResContainer> xmlFiles = resGen.makeResourcesXml();
@@ -252,7 +252,7 @@ public ResourceStorage getResStorage() {
 	}
 
 	@Override
-	public String[] getStrings() {
-		return new String[0];
+	public BinaryXMLStrings getStrings() {
+		return new BinaryXMLStrings();
 	}
 }

File: jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java
Patch:
@@ -38,7 +38,7 @@ public ClspGraph(RootNode rootNode) {
 		this.root = rootNode;
 	}
 
-	public void load() throws IOException, DecodeException {
+	public void loadClsSetFile() throws IOException, DecodeException {
 		ClsSet set = new ClsSet(root);
 		set.loadFromClstFile();
 		addClasspath(set);
@@ -55,7 +55,7 @@ public void addClasspath(ClsSet set) {
 
 	public void addApp(List<ClassNode> classes) {
 		if (nameMap == null) {
-			throw new JadxRuntimeException("Classpath must be loaded first");
+			nameMap = new HashMap<>(classes.size());
 		}
 		for (ClassNode cls : classes) {
 			addClass(cls);

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -245,7 +245,9 @@ public void initClassPath() {
 		try {
 			if (this.clsp == null) {
 				ClspGraph newClsp = new ClspGraph(this);
-				newClsp.load();
+				if (args.isLoadJadxClsSetFile()) {
+					newClsp.loadClsSetFile();
+				}
 				newClsp.addApp(classes);
 				newClsp.initCache();
 				this.clsp = newClsp;

File: jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java
Patch:
@@ -80,6 +80,9 @@ private void saveApplicationBuildGradle() throws IOException {
 		if (gradleInfo.isVectorPathData() && minSdkVersion < 21 || gradleInfo.isVectorFillType() && minSdkVersion < 24) {
 			additionalOptions.add("vectorDrawables.useSupportLibrary = true");
 		}
+		if (gradleInfo.isUseApacheHttpLegacy()) {
+			additionalOptions.add("useLibrary 'org.apache.http.legacy'");
+		}
 		genAdditionalAndroidPluginOptions(tmpl, additionalOptions);
 
 		tmpl.save(new File(appDir, "build.gradle"));

File: jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java
Patch:
@@ -65,7 +65,9 @@ public JadxProject(MainWindow mainWindow) {
 
 	public void fillJadxArgs(JadxArgs jadxArgs) {
 		jadxArgs.setInputFiles(FileUtils.toFiles(getFilePaths()));
-		jadxArgs.setUserRenamesMappingsPath(getMappingsPath());
+		if (jadxArgs.getUserRenamesMappingsPath() == null) {
+			jadxArgs.setUserRenamesMappingsPath(getMappingsPath());
+		}
 		jadxArgs.setCodeData(getCodeData());
 		jadxArgs.getPluginOptions().putAll(data.getPluginOptions());
 	}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -62,6 +62,7 @@
 import jadx.core.dex.visitors.regions.variables.ProcessVariables;
 import jadx.core.dex.visitors.rename.CodeRenameVisitor;
 import jadx.core.dex.visitors.rename.RenameVisitor;
+import jadx.core.dex.visitors.rename.SourceFileRename;
 import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;
 import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.dex.visitors.typeinference.FinishTypeInference;
@@ -96,6 +97,7 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {
 
 		// rename and deobfuscation
 		passes.add(new DeobfuscatorVisitor());
+		passes.add(new SourceFileRename());
 		passes.add(new RenameVisitor());
 		passes.add(new SaveDeobfMapping());
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java
Patch:
@@ -40,8 +40,6 @@ public void init(RootNode root) {
 	}
 
 	private void process(RootNode root) {
-		SourceFileRename.process(root);
-
 		UserRenames.apply(root);
 		checkNames(root);
 	}

File: jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java
Patch:
@@ -62,6 +62,9 @@ private void jumpCaretToFirstError() {
 
 	public void addCompilerIssues(List<ScriptDiagnostic> issues) {
 		for (ScriptDiagnostic issue : issues) {
+			if (issue.getSeverity() == ScriptDiagnostic.Severity.DEBUG) {
+				continue;
+			}
 			DefaultParserNotice notice;
 			SourceCode.Location loc = issue.getLocation();
 			if (loc == null) {

File: jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java
Patch:
@@ -128,9 +128,6 @@ private JPanel buildScriptActionsPanel() {
 
 	private void runScript() {
 		scriptArea.save();
-		if (!checkScript()) {
-			return;
-		}
 		resetResultLabel();
 
 		TabbedPane tabbedPane = getTabbedPane();

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java
Patch:
@@ -222,9 +222,9 @@ private static boolean canInline(MethodNode mth, RegisterArg arg) {
 		}
 		if (parentInsn.getType() == InsnType.CONSTRUCTOR) {
 			// don't inline into anonymous call if it can be inlined later
-			ConstructorInsn ctrInsn = (ConstructorInsn) parentInsn;
-			MethodNode ctrMth = mth.root().getMethodUtils().resolveMethod(ctrInsn);
-			if (ctrMth != null && ctrMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE)) {
+			MethodNode ctrMth = mth.root().getMethodUtils().resolveMethod((ConstructorInsn) parentInsn);
+			if (ctrMth != null
+					&& (ctrMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE) || ctrMth.contains(AFlag.ANONYMOUS_CONSTRUCTOR))) {
 				return false;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java
Patch:
@@ -28,7 +28,7 @@ public static byte[] readData(InputStream i) throws IOException {
 	}
 
 	public static ICodeInfo makeXmlDump(ICodeWriter writer, ResourceStorage resStorage) {
-		writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
+		writer.add("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
 		writer.startLine("<resources>");
 		writer.incIndent();
 

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java
Patch:
@@ -65,7 +65,7 @@ public class RenameDialog extends JDialog {
 	private transient JTextField renameField;
 	private transient JButton renameBtn;
 
-	public static boolean rename(MainWindow mainWindow, JNode source, JRenameNode node) {
+	public static boolean rename(MainWindow mainWindow, @Nullable JNode source, JRenameNode node) {
 		RenameDialog renameDialog = new RenameDialog(mainWindow, source, node);
 		UiUtils.uiRun(() -> renameDialog.setVisible(true));
 		UiUtils.uiRun(renameDialog::initRenameField); // wait for UI events to propagate
@@ -75,12 +75,13 @@ public static boolean rename(MainWindow mainWindow, JNode source, JRenameNode no
 	public static JPopupMenu buildRenamePopup(MainWindow mainWindow, JRenameNode node) {
 		JMenuItem jmi = new JMenuItem(NLS.str("popup.rename"));
 		jmi.addActionListener(action -> RenameDialog.rename(mainWindow, null, node));
+		jmi.setEnabled(node.canRename());
 		JPopupMenu menu = new JPopupMenu();
 		menu.add(jmi);
 		return menu;
 	}
 
-	private RenameDialog(MainWindow mainWindow, JNode source, JRenameNode node) {
+	private RenameDialog(MainWindow mainWindow, @Nullable JNode source, JRenameNode node) {
 		super(mainWindow);
 		this.mainWindow = mainWindow;
 		this.cache = mainWindow.getCacheObject();

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -220,7 +220,8 @@ public ICodeRename buildCodeRename(String newName, Set<ICodeRename> renames) {
 
 	@Override
 	public void removeAlias() {
-		cls.removeAlias();
+		// reset only short name, package name should be reset explicitly using PackageNode
+		cls.getClassNode().rename("");
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java
Patch:
@@ -125,8 +125,9 @@ private void rename() {
 	private void processRename(String newName, Set<ICodeRename> renames) {
 		ICodeRename rename = node.buildCodeRename(newName, renames);
 		renames.remove(rename);
-		node.removeAlias();
-		if (!newName.isEmpty()) {
+		if (newName.isEmpty()) {
+			node.removeAlias();
+		} else {
 			renames.add(rename);
 		}
 	}

File: jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java
Patch:
@@ -154,7 +154,6 @@ private void attachSourceLine(int decompiledLine, int sourceLine) {
 
 	@Override
 	public ICodeInfo finish() {
-		removeFirstEmptyLine();
 		processDefinitionAnnotations();
 		validateAnnotations();
 		String code = buf.toString();

File: jadx-core/src/test/java/jadx/tests/export/OptionalTargetSdkVersion.java
Patch:
@@ -12,7 +12,7 @@ public class OptionalTargetSdkVersion extends ExportGradleTest {
 	void test() {
 		exportGradle("OptionalTargetSdkVersion.xml", "strings.xml");
 
-		assertThat(getAppGradleBuild()).contains("targetSdkVersion 14");
+		assertThat(getAppGradleBuild()).contains("targetSdkVersion 14").doesNotContain("        vectorDrawables.useSupportLibrary = true");
 	}
 
 }

File: jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java
Patch:
@@ -17,6 +17,7 @@ public void testBuildGradle() throws Exception {
 		tmpl.add("targetSdkVersion", 2);
 		tmpl.add("versionCode", 3);
 		tmpl.add("versionName", "1.2.3");
+		tmpl.add("additionalOptions", "useLibrary 'org.apache.http.legacy'");
 		String res = tmpl.build();
 		System.out.println(res);
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -602,7 +602,7 @@ private SettingsGroup makeDecompilationGroup() {
 		other.addRow(NLS.str("preferences.useImports"), useImports);
 		other.addRow(NLS.str("preferences.useDebugInfo"), useDebugInfo);
 		other.addRow(NLS.str("preferences.inlineAnonymous"), inlineAnonymous);
-		other.addRow(NLS.str("preferences.inlineMethods"), moveInnerClasses);
+		other.addRow(NLS.str("preferences.inlineMethods"), inlineMethods);
 		other.addRow(NLS.str("preferences.inlineKotlinLambdas"), inlineKotlinLambdas);
 		other.addRow(NLS.str("preferences.moveInnerClasses"), moveInnerClasses);
 		other.addRow(NLS.str("preferences.extractFinally"), extractFinally);

File: jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java
Patch:
@@ -74,6 +74,8 @@ private static Object mergeValues(Class<?> type, Object value, Supplier<Object>
 	}
 
 	public void printUsage() {
+		LogHelper.setLogLevel(LogHelper.LogLevelEnum.ERROR); // mute logger while printing help
+
 		// print usage in not sorted fields order (by default sorted by description)
 		PrintStream out = System.out;
 		out.println();

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -13,6 +13,7 @@
 import jadx.api.CommentsLevel;
 import jadx.api.ICodeWriter;
 import jadx.api.JadxArgs;
+import jadx.api.args.IntegerFormat;
 import jadx.api.metadata.annotations.InsnCodeOffset;
 import jadx.api.metadata.annotations.VarNode;
 import jadx.api.plugins.input.data.AccessFlags;
@@ -548,7 +549,7 @@ private static boolean needLabel(InsnNode insn, InsnNode prevInsn) {
 	 * Return fallback variant of method codegen
 	 */
 	public static MethodGen getFallbackMethodGen(MethodNode mth) {
-		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, false, true, true);
+		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, false, true, true, IntegerFormat.AUTO);
 		return new MethodGen(clsGen, mth);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java
Patch:
@@ -40,7 +40,6 @@ public void init(RootNode root) {
 	}
 
 	private void process(RootNode root) {
-		KotlinMetadataRename.process(root);
 		SourceFileRename.process(root);
 
 		UserRenames.apply(root);

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -553,7 +553,7 @@ public static MethodGen getFallbackMethodGen(MethodNode mth) {
 	}
 
 	public static String getLabelName(BlockNode block) {
-		return String.format("L%d", block.getId());
+		return String.format("L%d", block.getCId());
 	}
 
 	public static String getLabelName(IfNode insn) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java
Patch:
@@ -20,7 +20,7 @@ public Object test() {
 			do {
 				obj = this.it.next();
 				if (obj == null) {
-					return obj; // 'return null' works
+					return obj; // 'return null' or 'break' also fine
 				}
 			} while (this.it.hasNext());
 			return obj;

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -981,6 +981,9 @@ public static BlockNode skipSyntheticPredecessor(BlockNode block) {
 	}
 
 	public static boolean isAllBlocksEmpty(List<BlockNode> blocks) {
+		if (Utils.isEmpty(blocks)) {
+			return true;
+		}
 		for (BlockNode block : blocks) {
 			if (!block.getInstructions().isEmpty()) {
 				return false;

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -243,7 +243,7 @@ private void addSimpleValue(ICodeWriter cw, String typeName, String itemTag, Str
 			cw.add(" />");
 		} else {
 			cw.add('>');
-			if (itemTag.equals("string")) {
+			if (itemTag.equals("string") || (typeName.equals("array") && valueStr.charAt(0) != '@')) {
 				cw.add(StringUtils.escapeResStrValue(valueStr));
 			} else {
 				cw.add(StringUtils.escapeResValue(valueStr));

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -72,7 +72,7 @@ public void visit(MethodNode mth) {
 				changed = true;
 			}
 		}
-		if (changed) {
+		if (changed || mth.contains(AFlag.REQUEST_CODE_SHRINK)) {
 			CodeShrinkVisitor.shrinkMethod(mth);
 		}
 	}
@@ -121,6 +121,7 @@ private void simplifyArgs(MethodNode mth, InsnNode insn) {
 		}
 		if (changed) {
 			insn.rebindArgs();
+			mth.add(AFlag.REQUEST_CODE_SHRINK);
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java
Patch:
@@ -68,7 +68,7 @@ private static JNode loadJNode(MainWindow mw, TabViewState tvs) {
 						.searchNode(node -> node instanceof JInputScript && node.getName().equals(tvs.getTabPath()));
 
 			case "mapping":
-				return mw.getTreeRoot().followStaticPath("JInputs", "JInputMapping");
+				return mw.getTreeRoot().followStaticPath("JInputs").searchNode(node -> node instanceof JInputMapping);
 		}
 		return null;
 	}

File: jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java
Patch:
@@ -5,10 +5,10 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.api.JavaClass;
+import jadx.gui.plugins.mappings.JInputMapping;
 import jadx.gui.settings.data.TabViewState;
 import jadx.gui.settings.data.ViewPoint;
 import jadx.gui.treemodel.JClass;
-import jadx.gui.treemodel.JInputMapping;
 import jadx.gui.treemodel.JInputScript;
 import jadx.gui.treemodel.JNode;
 import jadx.gui.treemodel.JResource;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JInputs.java
Patch:
@@ -11,6 +11,7 @@
 
 import jadx.core.utils.files.FileUtils;
 import jadx.gui.JadxWrapper;
+import jadx.gui.plugins.mappings.JInputMapping;
 import jadx.gui.settings.JadxProject;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java
Patch:
@@ -176,7 +176,6 @@ private void refreshState() {
 						UiUtils.errorMessage(this, NLS.str("message.memoryLow"));
 					}
 					node.reload(mainWindow);
-					mainWindow.renamesChanged();
 				});
 	}
 

File: jadx-gui/src/main/java/jadx/gui/logs/LogPanel.java
Patch:
@@ -141,7 +141,7 @@ private void registerLogListener(LogOptions logOptions) {
 	}
 
 	private @Nullable String getCurrentScriptName() {
-		ContentPanel selectedCodePanel = mainWindow.getTabbedPane().getSelectedCodePanel();
+		ContentPanel selectedCodePanel = mainWindow.getTabbedPane().getSelectedContentPanel();
 		if (selectedCodePanel != null) {
 			JNode node = selectedCodePanel.getNode();
 			if (node instanceof JInputScript) {

File: jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java
Patch:
@@ -150,7 +150,7 @@ private JPopupMenu createTabPopupMenu(final ContentPanel contentPanel) {
 			menu.add(closeAll);
 			menu.addSeparator();
 
-			ContentPanel selectedContentPanel = tabbedPane.getSelectedCodePanel();
+			ContentPanel selectedContentPanel = tabbedPane.getSelectedContentPanel();
 			for (final Map.Entry<JNode, ContentPanel> entry : openTabs.entrySet()) {
 				final ContentPanel cp = entry.getValue();
 				if (cp == selectedContentPanel) {

File: jadx-core/src/main/java/jadx/api/JadxArgs.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.io.Closeable;
 import java.io.File;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -636,8 +635,8 @@ public String makeCodeArgsHash() {
 				+ insertDebugLines + extractFinally
 				+ debugInfo + useSourceNameAsClassAlias + escapeUnicode + replaceConsts
 				+ respectBytecodeAccModifiers + fsCaseSensitive + renameFlags
-				+ commentsLevel + useDxInput + pluginOptions;
-		return FileUtils.md5Sum(argStr.getBytes(StandardCharsets.US_ASCII));
+				+ commentsLevel + useDxInput;
+		return FileUtils.md5Sum(argStr);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/api/plugins/pass/types/JadxAfterLoadPass.java
Patch:
@@ -4,7 +4,7 @@
 import jadx.api.plugins.pass.JadxPass;
 
 public interface JadxAfterLoadPass extends JadxPass {
-	JadxPassType TYPE = new JadxPassType(JadxAfterLoadPass.class);
+	JadxPassType TYPE = new JadxPassType("AfterLoadPass");
 
 	void init(JadxDecompiler decompiler);
 

File: jadx-core/src/main/java/jadx/api/plugins/pass/types/JadxDecompilePass.java
Patch:
@@ -6,7 +6,7 @@
 import jadx.core.dex.nodes.RootNode;
 
 public interface JadxDecompilePass extends JadxPass {
-	JadxPassType TYPE = new JadxPassType(JadxDecompilePass.class);
+	JadxPassType TYPE = new JadxPassType("DecompilePass");
 
 	void init(RootNode root);
 

File: jadx-core/src/main/java/jadx/api/plugins/pass/types/JadxPreparePass.java
Patch:
@@ -4,7 +4,7 @@
 import jadx.core.dex.nodes.RootNode;
 
 public interface JadxPreparePass extends JadxPass {
-	JadxPassType TYPE = new JadxPassType(JadxPreparePass.class);
+	JadxPassType TYPE = new JadxPassType("PreparePass");
 
 	void init(RootNode root);
 

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -138,7 +138,7 @@ private void initUsageCache(JadxArgs jadxArgs) {
 
 	private void initGuiPluginsContext() {
 		guiPluginsContext = new GuiPluginsContext(mainWindow);
-		decompiler.getPluginsContext().setGuiContext(guiPluginsContext);
+		decompiler.getPluginManager().setGuiContext(guiPluginsContext);
 	}
 
 	public GuiPluginsContext getGuiPluginsContext() {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsStorage.java
Patch:
@@ -39,7 +39,7 @@ public synchronized void save(String jsonStr) throws IOException {
 
 	private static Path initConfigFile() {
 		ProjectDirectories jadxDirs = ProjectDirectories.from("io.github", "skylot", "jadx");
-		Path confPath = Paths.get(jadxDirs.configDir, "config.json");
+		Path confPath = Paths.get(jadxDirs.configDir, "gui.json");
 		if (!Files.exists(confPath)) {
 			copyFromPreferences(confPath);
 		}

File: jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertPlugin.java
Patch:
@@ -32,6 +32,7 @@ public JadxPluginInfo getPluginInfo() {
 	public void init(JadxPluginContext context) {
 		context.registerOptions(options);
 		context.addCodeInput(this);
+		context.registerInputsHashSupplier(options::getOptionsHash);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/api/impl/plugins/PluginsContext.java
Patch:
@@ -55,7 +55,7 @@ public List<JadxCodeInput> getCodeInputs() {
 		return codeInputs;
 	}
 
-	public void setCurrentPlugin(JadxPlugin currentPlugin) {
+	public void setCurrentPlugin(@Nullable JadxPlugin currentPlugin) {
 		this.currentPlugin = currentPlugin;
 	}
 

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -201,7 +201,7 @@ public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {
 		if (args.isRawCFGOutput()) {
 			passes.add(DotGraphVisitor.dumpRaw());
 		}
-		passes.add(new MethodVisitor(mth -> mth.add(AFlag.DISABLE_BLOCKS_LOCK)));
+		passes.add(new MethodVisitor("DisableBlockLock", mth -> mth.add(AFlag.DISABLE_BLOCKS_LOCK)));
 		passes.add(new BlockProcessor());
 		passes.add(new SSATransform());
 		passes.add(new MoveInlineVisitor());
@@ -220,7 +220,7 @@ public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {
 		passes.add(new ReSugarCode());
 		passes.add(new CodeShrinkVisitor());
 		passes.add(new SimplifyVisitor());
-		passes.add(new MethodVisitor(mth -> mth.remove(AFlag.DONT_GENERATE)));
+		passes.add(new MethodVisitor("ForceGenerateAll", mth -> mth.remove(AFlag.DONT_GENERATE)));
 		if (args.isCfgOutput()) {
 			passes.add(DotGraphVisitor.dump());
 		}

File: jadx-core/src/main/java/jadx/core/deobf/DeobfuscatorVisitor.java
Patch:
@@ -73,7 +73,7 @@ public static void process(RootNode root, IRenameCondition renameCondition, IAli
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "DeobfuscatorVisitor";
 	}
 }

File: jadx-core/src/main/java/jadx/core/deobf/SaveDeobfMapping.java
Patch:
@@ -47,7 +47,7 @@ private void saveMappings(RootNode root) {
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "SaveDeobfMapping";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java
Patch:
@@ -462,7 +462,7 @@ private static String makeNewAlias(MethodNode mth) {
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "OverrideMethodVisitor";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java
Patch:
@@ -362,7 +362,7 @@ private static ArgType getBaseType(ClassNode cls) {
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "ProcessAnonymous";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ProcessMethodsForInline.java
Patch:
@@ -73,7 +73,7 @@ private static void fixClassDependencies(MethodNode mth) {
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "ProcessMethodsForInline";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java
Patch:
@@ -278,7 +278,7 @@ private boolean validateInnerType(ArgType type) {
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "SignatureProcessor";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java
Patch:
@@ -246,7 +246,7 @@ private static Set<String> collectRootPkgs(RootNode root) {
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "RenameVisitor";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java
Patch:
@@ -177,7 +177,7 @@ public static void replaceMethodUsage(MethodNode mergeIntoMth, MethodNode source
 	}
 
 	@Override
-	public String toString() {
+	public String getName() {
 		return "UsageInfoVisitor";
 	}
 }

File: jadx-core/src/main/java/jadx/api/plugins/JadxPluginManager.java
Patch:
@@ -119,11 +119,12 @@ public void initResolved(PluginsContext context) {
 		init(context, resolvedPlugins);
 	}
 
-	private void init(PluginsContext context, List<JadxPlugin> plugins) {
+	public void init(PluginsContext context, List<JadxPlugin> plugins) {
 		for (JadxPlugin plugin : plugins) {
 			try {
 				context.setCurrentPlugin(plugin);
 				plugin.init(context);
+				context.setCurrentPlugin(null);
 			} catch (Exception e) {
 				String pluginId = plugin.getPluginInfo().getPluginId();
 				throw new JadxRuntimeException("Failed to init plugin: " + pluginId, e);

File: jadx-core/src/main/java/jadx/core/utils/BetterName.java
Patch:
@@ -25,9 +25,9 @@ public static String compareAndGet(String first, String second) {
 		boolean firstBetter = firstRating >= secondRating;
 		if (DEBUG) {
 			if (firstBetter) {
-				LOG.info("Better name: '{}' > '{}' ({} > {})", first, second, firstRating, secondRating);
+				LOG.debug("Better name: '{}' > '{}' ({} > {})", first, second, firstRating, secondRating);
 			} else {
-				LOG.info("Better name: '{}' > '{}' ({} > {})", second, first, secondRating, firstRating);
+				LOG.debug("Better name: '{}' > '{}' ({} > {})", second, first, secondRating, firstRating);
 			}
 		}
 		return firstBetter ? first : second;

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -8,6 +8,7 @@ public class Consts {
 	public static final boolean DEBUG_OVERLOADED_CASTS = false;
 	public static final boolean DEBUG_EXC_HANDLERS = false;
 	public static final boolean DEBUG_FINALLY = false;
+	public static final boolean DEBUG_ATTRIBUTES = false;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";
 	public static final String CLASS_STRING = "java.lang.String";

File: jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java
Patch:
@@ -149,6 +149,7 @@ public String toString() {
 		return InsnUtils.formatOffset(offset) + ": "
 				+ InsnUtils.insnTypeToString(insnType)
 				+ getArg(0) + ' ' + op.getSymbol() + ' ' + getArg(1)
-				+ "  -> " + (thenBlock != null ? thenBlock : InsnUtils.formatOffset(target));
+				+ "  -> " + (thenBlock != null ? thenBlock : InsnUtils.formatOffset(target))
+				+ attributesString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeCustomNode.java
Patch:
@@ -123,6 +123,7 @@ public String toString() {
 			sb.append(getResult()).append(" = ");
 		}
 		appendArgs(sb);
+		appendAttributes(sb);
 		sb.append("\n handle type: ").append(handleType);
 		sb.append("\n lambda: ").append(implMthInfo);
 		sb.append("\n call insn: ").append(callInsn);

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeCustomRawNode.java
Patch:
@@ -92,6 +92,7 @@ public String toString() {
 		if (!appendArgs(sb)) {
 			sb.append('\n');
 		}
+		appendAttributes(sb);
 		sb.append(" call-site: \n  ").append(Utils.listToString(callSiteValues, "\n  ")).append('\n');
 		return sb.toString();
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -103,6 +103,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return super.toString() + " type: " + type + " call: " + mth;
+		return baseString() + " type: " + type + " call: " + mth + attributesString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokePolymorphicNode.java
Patch:
@@ -59,6 +59,7 @@ public String toString() {
 		if (!appendArgs(sb)) {
 			sb.append('\n');
 		}
+		appendAttributes(sb);
 		sb.append(" base: ").append(baseCallRef).append('\n');
 		sb.append(" proto: ").append(proto).append('\n');
 		return sb.toString();

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -14,7 +14,6 @@
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.InsnRemover;
-import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
 public final class PhiInsn extends InsnNode {
@@ -134,7 +133,6 @@ public InsnNode copy() {
 
 	@Override
 	public String toString() {
-		return "PHI: " + getResult() + " = " + Utils.listToString(getArguments())
-				+ " binds: " + blockBinds;
+		return baseString() + " binds: " + blockBinds + attributesString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/SwitchData.java
Patch:
@@ -44,6 +44,7 @@ public String toString() {
 			sb.append(keys[i]).append("->").append(InsnUtils.formatOffset(targets[i])).append(", ");
 		}
 		sb.append('}');
+		appendAttributes(sb);
 		return sb.toString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/SwitchInsn.java
Patch:
@@ -103,7 +103,7 @@ public InsnNode copy() {
 	@Override
 	public String toString() {
 		StringBuilder sb = new StringBuilder();
-		sb.append(super.toString());
+		sb.append(baseString());
 		if (switchData == null) {
 			sb.append("no payload");
 		} else {
@@ -129,6 +129,7 @@ public String toString() {
 				}
 			}
 		}
+		appendAttributes(sb);
 		return sb.toString();
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java
Patch:
@@ -96,7 +96,7 @@ public void rebindArgs() {
 
 	@Override
 	public String toString() {
-		return InsnUtils.formatOffset(offset) + ": TERNARY"
+		return InsnUtils.formatOffset(offset) + ": TERNARY "
 				+ getResult() + " = (" + condition + ") ? " + getArg(0) + " : " + getArg(1);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/ForEachLoop.java
Patch:
@@ -13,7 +13,7 @@ public final class ForEachLoop extends LoopType {
 	public ForEachLoop(RegisterArg varArg, InsnArg iterableArg) {
 		// store for-each args in fake instructions to
 		// save code semantics and allow args manipulations like args inlining
-		varArgInsn = new InsnNode(InsnType.REGION_ARG, 1);
+		varArgInsn = new InsnNode(InsnType.REGION_ARG, 0);
 		varArgInsn.add(AFlag.DONT_INLINE);
 		varArgInsn.setResult(varArg.duplicate());
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -79,8 +79,9 @@ private static void removeSyntheticFields(ClassNode cls) {
 		boolean inline = cls.isAnonymous();
 		if (inline || cls.getClassInfo().isInner()) {
 			for (FieldNode field : cls.getFields()) {
-				if (field.getAccessFlags().isSynthetic() && field.getType().isObject()) {
-					ClassInfo clsInfo = ClassInfo.fromType(cls.root(), field.getType());
+				ArgType fldType = field.getType();
+				if (field.getAccessFlags().isSynthetic() && fldType.isObject() && !fldType.isGenericType()) {
+					ClassInfo clsInfo = ClassInfo.fromType(cls.root(), fldType);
 					ClassNode fieldsCls = cls.root().resolveClass(clsInfo);
 					ClassInfo parentClass = cls.getClassInfo().getParentClass();
 					if (fieldsCls != null

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -531,15 +531,15 @@ private static InsnNode makeFilledArrayInsn(MethodNode mth, NewArrayNode newArra
 
 		List<LiteralArg> list = insn.getLiteralArgs(elType);
 		InsnNode filledArr = new FilledNewArrayNode(elType, list.size());
-		filledArr.setResult(newArrayNode.getResult());
+		filledArr.setResult(newArrayNode.getResult().duplicate());
 		for (LiteralArg arg : list) {
 			FieldNode f = mth.getParentClass().getConstFieldByLiteralArg(arg);
 			if (f != null) {
 				InsnNode fGet = new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0);
 				filledArr.addArg(InsnArg.wrapArg(fGet));
 				f.addUseIn(mth);
 			} else {
-				filledArr.addArg(arg);
+				filledArr.addArg(arg.duplicate());
 			}
 		}
 		return filledArr;

File: jadx-gui/src/main/java/jadx/gui/logs/LogAppender.java
Patch:
@@ -6,7 +6,7 @@
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.gui.utils.UiUtils;
 
-import static jadx.plugins.script.runtime.JadxScriptTemplateKt.JADX_SCRIPT_LOG_PREFIX;
+import static jadx.plugins.script.runtime.ScriptRuntime.JADX_SCRIPT_LOG_PREFIX;
 
 class LogAppender implements ILogListener {
 	private final LogOptions options;

File: jadx-gui/src/main/java/jadx/gui/logs/LogOptions.java
Patch:
@@ -6,7 +6,7 @@
 
 import jadx.core.utils.Utils;
 
-import static jadx.plugins.script.runtime.JadxScriptTemplateKt.JADX_SCRIPT_LOG_PREFIX;
+import static jadx.plugins.script.runtime.ScriptRuntime.JADX_SCRIPT_LOG_PREFIX;
 
 public class LogOptions {
 

File: jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java
Patch:
@@ -16,7 +16,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.api.JadxArgs;
-import jadx.api.args.DeobfuscationMapFileMode;
+import jadx.api.args.GeneratedRenamesMappingFileMode;
 import jadx.api.deobf.IAliasProvider;
 import jadx.api.deobf.impl.AlwaysRename;
 import jadx.core.dex.info.ClassInfo;
@@ -45,15 +45,15 @@ public class DeobfPresets {
 
 	public static DeobfPresets build(RootNode root) {
 		Path deobfMapPath = getPathDeobfMapPath(root);
-		if (root.getArgs().getDeobfuscationMapFileMode() != DeobfuscationMapFileMode.IGNORE) {
+		if (root.getArgs().getGeneratedRenamesMappingFileMode() != GeneratedRenamesMappingFileMode.IGNORE) {
 			LOG.debug("Deobfuscation map file set to: {}", deobfMapPath);
 		}
 		return new DeobfPresets(deobfMapPath);
 	}
 
 	private static Path getPathDeobfMapPath(RootNode root) {
 		JadxArgs jadxArgs = root.getArgs();
-		File deobfMapFile = jadxArgs.getDeobfuscationMapFile();
+		File deobfMapFile = jadxArgs.getGeneratedRenamesMappingFile();
 		if (deobfMapFile != null) {
 			return deobfMapFile.toPath();
 		}

File: jadx-core/src/main/java/jadx/core/deobf/DeobfuscatorVisitor.java
Patch:
@@ -20,7 +20,7 @@ public void init(RootNode root) throws JadxException {
 			return;
 		}
 		DeobfPresets mapping = DeobfPresets.build(root);
-		if (args.getDeobfuscationMapFileMode().shouldRead()) {
+		if (args.getGeneratedRenamesMappingFileMode().shouldRead()) {
 			if (mapping.load()) {
 				mapping.apply(root);
 			}

File: jadx-core/src/main/java/jadx/core/deobf/SaveDeobfMapping.java
Patch:
@@ -7,7 +7,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.api.JadxArgs;
-import jadx.api.args.DeobfuscationMapFileMode;
+import jadx.api.args.GeneratedRenamesMappingFileMode;
 import jadx.core.codegen.json.JsonMappingGen;
 import jadx.core.dex.nodes.RootNode;
 import jadx.core.dex.visitors.AbstractVisitor;
@@ -28,13 +28,13 @@ public void init(RootNode root) throws JadxException {
 	}
 
 	private void saveMappings(RootNode root) {
-		DeobfuscationMapFileMode mode = root.getArgs().getDeobfuscationMapFileMode();
+		GeneratedRenamesMappingFileMode mode = root.getArgs().getGeneratedRenamesMappingFileMode();
 		if (!mode.shouldWrite()) {
 			return;
 		}
 		DeobfPresets mapping = DeobfPresets.build(root);
 		Path deobfMapFile = mapping.getDeobfMapFile();
-		if (mode == DeobfuscationMapFileMode.READ_OR_SAVE && Files.exists(deobfMapFile)) {
+		if (mode == GeneratedRenamesMappingFileMode.READ_OR_SAVE && Files.exists(deobfMapFile)) {
 			return;
 		}
 		try {

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -40,7 +40,7 @@
 import jadx.api.JadxDecompiler;
 import jadx.api.JadxInternalAccess;
 import jadx.api.JavaClass;
-import jadx.api.args.DeobfuscationMapFileMode;
+import jadx.api.args.GeneratedRenamesMappingFileMode;
 import jadx.api.metadata.ICodeMetadata;
 import jadx.api.metadata.annotations.InsnCodeOffset;
 import jadx.core.dex.attributes.AFlag;
@@ -139,7 +139,7 @@ public void init() {
 		args.setFsCaseSensitive(false); // use same value on all systems
 		args.setCommentsLevel(CommentsLevel.DEBUG);
 		args.setDeobfuscationOn(false);
-		args.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.IGNORE);
+		args.setGeneratedRenamesMappingFileMode(GeneratedRenamesMappingFileMode.IGNORE);
 	}
 
 	@AfterEach
@@ -570,7 +570,7 @@ protected void forceDecompiledCheck() {
 
 	protected void enableDeobfuscation() {
 		args.setDeobfuscationOn(true);
-		args.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.IGNORE);
+		args.setGeneratedRenamesMappingFileMode(GeneratedRenamesMappingFileMode.IGNORE);
 		args.setDeobfuscationMinLength(2);
 		args.setDeobfuscationMaxLength(64);
 	}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -1014,9 +1014,10 @@ private void makeInlinedLambdaMethod(ICodeWriter code, InvokeCustomNode customNo
 		// force set external arg names into call method args
 		int extArgsCount = customNode.getArgsCount();
 		int startArg = customNode.getHandleType() == MethodHandleType.INVOKE_STATIC ? 0 : 1; // skip 'this' arg
+		int callArg = 0;
 		for (int i = startArg; i < extArgsCount; i++) {
 			RegisterArg extArg = (RegisterArg) customNode.getArg(i);
-			RegisterArg callRegArg = callArgs.get(i);
+			RegisterArg callRegArg = callArgs.get(callArg++);
 			callRegArg.getSVar().setCodeVar(extArg.getSVar().getCodeVar());
 		}
 		code.add(" -> {");

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -211,7 +211,7 @@ public void updateAttributes(IResParser parser) {
 				MAttrType attrTyp;
 				if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_FLAGS) {
 					attrTyp = MAttrType.FLAG;
-				} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM) {
+				} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM || first.getRawValue().getData() == 65600) {
 					attrTyp = MAttrType.ENUM;
 				} else {
 					continue;

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -177,7 +177,7 @@ private void addItem(ICodeWriter cw, String itemTag, String typeName, RawNamedVa
 			if (dataType == ParserConstants.TYPE_INT_DEC && nameStr != null) {
 				try {
 					int intVal = Integer.parseInt(valueStr);
-					String newVal = ManifestAttributes.getInstance().decode(nameStr.replace("android:attr.", ""), intVal);
+					String newVal = ManifestAttributes.getInstance().decode(nameStr.replace("android:", "").replace("attr.", ""), intVal);
 					if (newVal != null) {
 						valueStr = newVal;
 					}
@@ -188,7 +188,7 @@ private void addItem(ICodeWriter cw, String itemTag, String typeName, RawNamedVa
 			if (dataType == ParserConstants.TYPE_INT_HEX && nameStr != null) {
 				try {
 					int intVal = Integer.decode(valueStr);
-					String newVal = ManifestAttributes.getInstance().decode(nameStr.replace("android:attr.", ""), intVal);
+					String newVal = ManifestAttributes.getInstance().decode(nameStr.replace("android:", "").replace("attr.", ""), intVal);
 					if (newVal != null) {
 						valueStr = newVal;
 					}

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -33,7 +33,8 @@ protected ParserConstants() {
 	protected static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202; // 514
 	protected static final int RES_TABLE_TYPE_LIBRARY = 0x0203; // 515
 	protected static final int RES_TABLE_TYPE_OVERLAY = 0x0204; // 516
-	protected static final int RES_TABLE_TYPE_STAGED_ALIAS = 0x0206; // 517
+	protected static final int RES_TABLE_TYPE_OVERLAY_POLICY = 0x0205; // 517
+	protected static final int RES_TABLE_TYPE_STAGED_ALIAS = 0x0206; // 518
 
 	/**
 	 * Type constants

File: jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java
Patch:
@@ -139,11 +139,13 @@ private static List<List<JavaClass>> buildFallback(List<JavaClass> classes) {
 	}
 
 	private void dumpBatchesStats(List<JavaClass> classes, List<List<JavaClass>> result, List<DepInfo> deps) {
+		int clsInBatches = result.stream().mapToInt(List::size).sum();
 		double avg = result.stream().mapToInt(List::size).average().orElse(-1);
 		int maxSingleDeps = classes.stream().mapToInt(JavaClass::getTotalDepsCount).max().orElse(-1);
 		int maxSubDeps = deps.stream().mapToInt(DepInfo::getDepsCount).max().orElse(-1);
 		LOG.info("Batches stats:"
 				+ "\n input classes: " + classes.size()
+				+ ",\n classes in batches: " + clsInBatches
 				+ ",\n batches: " + result.size()
 				+ ",\n average batch size: " + String.format("%.2f", avg)
 				+ ",\n max single deps count: " + maxSingleDeps

File: jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java
Patch:
@@ -26,7 +26,7 @@ protected String[] parseStringPoolNoType() throws IOException {
 		int[] stringsOffset = is.readInt32Array(stringCount);
 		int[] stylesOffset = is.readInt32Array(styleCount);
 
-		is.checkPos(start + stringsStart, "Expected strings start");
+		is.skipToPos(start + stringsStart, "Expected strings start");
 		String[] strings = new String[stringCount];
 		byte[] strData = is.readInt8Array((int) (chunkEnd - is.getPos()));
 		if ((flags & UTF8_FLAG) != 0) {

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Random;
 import java.util.Set;
 
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -51,7 +52,7 @@ public class BinaryXMLParser extends CommonBinaryParser {
 	private boolean isLastEnd = true;
 	private boolean isOneLine = true;
 	private int namespaceDepth = 0;
-	private int[] resourceIds;
+	private @Nullable int[] resourceIds;
 
 	private final RootNode rootNode;
 	private String appPackageName;
@@ -358,7 +359,7 @@ private String getAttributeName(int id) {
 		// As the outcome of https://github.com/skylot/jadx/issues/1208
 		// Android seems to favor entries from AndroidResMap and only if
 		// there is no entry uses the values form the XML string pool
-		if (0 <= id && id < resourceIds.length) {
+		if (resourceIds != null && 0 <= id && id < resourceIds.length) {
 			int resId = resourceIds[id];
 			String str = ValuesParser.getAndroidResMap().get(resId);
 			if (str != null) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeType.java
Patch:
@@ -8,4 +8,5 @@ public enum InvokeType {
 	SUPER,
 	POLYMORPHIC,
 	CUSTOM,
+	CUSTOM_RAW,
 }

File: jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaExtVar.java
Patch:
@@ -33,7 +33,5 @@ public void test() {
 				.code()
 				.doesNotContain("lambda$")
 				.containsOne("return s.equals(str);"); // TODO: simplify to expression
-
-		System.out.println(cls.getCode().getCodeMetadata());
 	}
 }

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/annotations/EncodedValue.java
Patch:
@@ -53,12 +53,12 @@ public String toString() {
 		switch (type) {
 			case ENCODED_NULL:
 				return "null";
-			case ENCODED_STRING:
-				return (String) value;
 			case ENCODED_ARRAY:
 				return "[" + value + "]";
+			case ENCODED_STRING:
+				return "{STRING: \"" + value + "\"}";
 			default:
-				return "{" + type + ": " + value + '}';
+				return "{" + type.toString().substring(8) + ": " + value + '}';
 		}
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/panel/LogcatPanel.java
Patch:
@@ -94,6 +94,8 @@ public void actionPerformed(ActionEvent e) {
 	};
 
 	public boolean showLogcat() {
+		this.removeAll();
+
 		ArrayList<String> pkgs = new ArrayList<>();
 		pids = new ArrayList<>();
 		JPanel procBox;

File: jadx-gui/src/main/java/jadx/gui/device/debugger/smali/SmaliMethodNode.java
Patch:
@@ -94,7 +94,6 @@ protected void setDefPos(int pos) {
 	protected void setParamReg(int regNum, String name) {
 		SmaliRegister r = regList.get(regNum);
 		r.setParam(name);
-		r.setStartOffset(-1);
 	}
 
 	protected void setParamRegStart(int paramRegStart) {

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/debuginfo/DebugInfoParser.java
Patch:
@@ -96,8 +96,9 @@ public DebugInfo process(int debugOff) {
 			int nameId = in.readUleb128p1();
 			String name = ext.getString(nameId);
 			if (name != null && i < argsCount) {
-				int regNum = argRegs[i];
-				startVar(new DexLocalVar(regNum, name, argTypes.get(i)), -1);
+				DexLocalVar paramVar = new DexLocalVar(argRegs[i], name, argTypes.get(i));
+				startVar(paramVar, addr);
+				paramVar.markAsParameter();
 				varsInfoFound = true;
 			}
 		}

File: jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java
Patch:
@@ -463,7 +463,7 @@ private boolean formatMthParamInfo(IMethodData mth, SmaliWriter smali, ICodeRead
 		IDebugInfo dbgInfo = codeReader.getDebugInfo();
 		if (dbgInfo != null) {
 			for (ILocalVar var : dbgInfo.getLocalVars()) {
-				if (var.getStartOffset() == -1) {
+				if (var.getRegNum() == regNum) {
 					int i = writeParamInfo(smali, line, regNum, paramStart, var.getName(), var.getType());
 					regNum += i;
 					paramStart += i;

File: jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java
Patch:
@@ -84,7 +84,7 @@ private void decode(XmlAttribute a) {
 		}
 		String name = a.getName();
 		String value = deobfClassName(a.getValue());
-		writer.add(name).add("=\"").add(value).add('\"');
+		writer.add(name).add("=\"").add(StringUtils.escapeXML(value)).add('\"');
 		memorizePackageName(name, value);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java
Patch:
@@ -79,12 +79,12 @@ private String generateMethodSnippet(JMethod jMth) {
 		JavaMethod javaMethod = jMth.getJavaMethod();
 		MethodInfo methodInfo = javaMethod.getMethodNode().getMethodInfo();
 		String methodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());
-		String callMethodName = methodName;
 
 		if (methodInfo.isConstructor()) {
 			methodName = "$init";
-			callMethodName = "$new";
 		}
+
+		String callMethodName = methodName;
 		String shortClassName = javaMethod.getDeclaringClass().getName();
 
 		String functionUntilImplementation;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java
Patch:
@@ -454,10 +454,10 @@ private void updateSelection(JTable table, Component comp, int column, boolean i
 
 		private Component makeCell(JNode node, int column) {
 			if (column == 0) {
+				label.disableHtml(node.disableHtml());
 				label.setText(node.makeLongStringHtml());
 				label.setToolTipText(node.getTooltip());
 				label.setIcon(node.getIcon());
-				label.disableHtml(node.disableHtml());
 				return label;
 			}
 			if (!node.hasDescString()) {

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkDialog.java
Patch:
@@ -21,6 +21,7 @@
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.UiUtils;
+import jadx.gui.utils.ui.NodeLabel;
 
 public class QuarkDialog extends JDialog {
 	private static final long serialVersionUID = 4855753773520368215L;
@@ -59,7 +60,7 @@ private void initUI() {
 		description.setAlignmentX(0.5f);
 
 		fileSelectCombo = new JComboBox<>(files.toArray(new Path[0]));
-		fileSelectCombo.setRenderer((list, value, index, isSelected, cellHasFocus) -> new JLabel(value.getFileName().toString()));
+		fileSelectCombo.setRenderer((list, value, index, isSelected, cellHasFocus) -> new NodeLabel(value.getFileName().toString()));
 
 		JPanel textPane = new JPanel();
 		textPane.add(description);

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java
Patch:
@@ -44,6 +44,7 @@
 import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.utils.JNodeCache;
+import jadx.gui.utils.ui.NodeLabel;
 
 public class QuarkReportPanel extends ContentPanel {
 	private static final long serialVersionUID = -242266836695889206L;
@@ -211,7 +212,7 @@ public TextTreeNode bold() {
 
 		@Override
 		public Component render() {
-			JLabel label = new JLabel(((String) getUserObject()));
+			JLabel label = new NodeLabel(((String) getUserObject()));
 			label.setFont(bold ? boldFont : font);
 			label.setIcon(null);
 			label.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
@@ -320,7 +321,7 @@ public JMethod getJMethod() {
 
 		@Override
 		public Component render() {
-			JLabel label = new JLabel(mth.toString());
+			JLabel label = new NodeLabel(mth.toString());
 			label.setFont(font);
 			label.setIcon(jnode.getIcon());
 			label.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -142,6 +142,7 @@
 import jadx.gui.utils.fileswatcher.LiveReloadWorker;
 import jadx.gui.utils.logs.LogCollector;
 import jadx.gui.utils.ui.ActionHandler;
+import jadx.gui.utils.ui.NodeLabel;
 
 import static io.reactivex.internal.functions.Functions.EMPTY_RUNNABLE;
 import static javax.swing.KeyStroke.getKeyStroke;
@@ -1281,6 +1282,7 @@ public Component getTreeCellRendererComponent(JTree tree,
 				Component c = super.getTreeCellRendererComponent(tree, value, selected, expanded, isLeaf, row, focused);
 				if (value instanceof JNode) {
 					JNode jNode = (JNode) value;
+					NodeLabel.disableHtml(this, jNode.disableHtml());
 					setText(jNode.makeStringHtml());
 					setIcon(jNode.getIcon());
 					setToolTipText(jNode.getTooltip());

File: jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java
Patch:
@@ -23,6 +23,7 @@
 import jadx.gui.utils.Icons;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
+import jadx.gui.utils.ui.NodeLabel;
 
 public class TabComponent extends JPanel {
 	private static final long serialVersionUID = -8147035487543610321L;
@@ -58,7 +59,7 @@ private void init() {
 		} else {
 			tabTitle = node.makeLongStringHtml();
 		}
-		label = new JLabel(tabTitle);
+		label = new NodeLabel(tabTitle, node.disableHtml());
 		label.setFont(getLabelFont());
 		String toolTip = contentPanel.getTabTooltip();
 		if (toolTip != null) {

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java
Patch:
@@ -22,7 +22,6 @@
 import javax.swing.JLabel;
 import javax.swing.JPanel;
 import javax.swing.JTextField;
-import javax.swing.SwingConstants;
 import javax.swing.WindowConstants;
 
 import org.jetbrains.annotations.NotNull;
@@ -60,6 +59,7 @@
 import jadx.gui.utils.TextStandardActions;
 import jadx.gui.utils.UiUtils;
 import jadx.gui.utils.ui.DocumentUpdateListener;
+import jadx.gui.utils.ui.NodeLabel;
 
 public class RenameDialog extends JDialog {
 	private static final long serialVersionUID = -3269715644416902410L;
@@ -313,7 +313,7 @@ protected JPanel initButtonsPanel() {
 
 	private void initUI() {
 		JLabel lbl = new JLabel(NLS.str("popup.rename"));
-		JLabel nodeLabel = new JLabel(this.node.makeLongStringHtml(), this.node.getIcon(), SwingConstants.LEFT);
+		JLabel nodeLabel = NodeLabel.longName(node);
 		lbl.setLabelFor(nodeLabel);
 
 		renameField = new JTextField(40);

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java
Patch:
@@ -12,7 +12,6 @@
 import javax.swing.BorderFactory;
 import javax.swing.JLabel;
 import javax.swing.JPanel;
-import javax.swing.SwingConstants;
 import javax.swing.WindowConstants;
 
 import jadx.api.ICodeInfo;
@@ -31,6 +30,7 @@
 import jadx.gui.utils.JNodeCache;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
+import jadx.gui.utils.ui.NodeLabel;
 
 public class UsageDialog extends CommonSearchDialog {
 	private static final long serialVersionUID = -5105405789969134105L;
@@ -147,7 +147,7 @@ private void initUI() {
 		Font codeFont = settings.getFont();
 		JLabel lbl = new JLabel(NLS.str("usage_dialog.label"));
 		lbl.setFont(codeFont);
-		JLabel nodeLabel = new JLabel(this.node.makeLongStringHtml(), this.node.getIcon(), SwingConstants.LEFT);
+		JLabel nodeLabel = NodeLabel.longName(node);
 		nodeLabel.setFont(codeFont);
 		lbl.setLabelFor(nodeLabel);
 

File: jadx-gui/src/main/java/jadx/gui/ui/panel/LogcatPanel.java
Patch:
@@ -46,6 +46,7 @@
 import jadx.gui.device.protocol.ADBDevice;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
+import jadx.gui.utils.ui.NodeLabel;
 
 public class LogcatPanel extends JPanel {
 	private static final Logger LOG = LoggerFactory.getLogger(LogcatPanel.class);
@@ -301,7 +302,7 @@ public void actionPerformed(ActionEvent e) {
 		}
 
 		public JPanel getContent() {
-			JLabel label = new JLabel(this.label + ": ");
+			JLabel label = NodeLabel.noHtml(this.label + ": ");
 			CheckComboStore[] stores = new CheckComboStore[ids.length];
 			for (int j = 0; j < ids.length; j++) {
 				stores[j] = new CheckComboStore(index[j], ids[j], Boolean.TRUE);

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -171,7 +171,7 @@ public void addClassDeclaration(ICodeWriter clsCode) {
 		ArgType sup = cls.getSuperClass();
 		if (sup != null
 				&& !sup.equals(ArgType.OBJECT)
-				&& !cls.isEnum()) {
+				&& !cls.contains(AFlag.REMOVE_SUPER_CLASS)) {
 			clsCode.add("extends ");
 			useClass(clsCode, sup);
 			clsCode.add(' ');

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -21,6 +21,7 @@ public enum AFlag {
 	DONT_GENERATE, // process as usual, but don't output to generated code
 	COMMENT_OUT, // process as usual, but comment insn in generated code
 	REMOVE, // can be completely removed
+	REMOVE_SUPER_CLASS, // don't add super class
 
 	HIDDEN, // instruction used inside other instruction but not listed in args
 

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java
Patch:
@@ -156,7 +156,7 @@ public static IfCondition simplify(IfCondition cond) {
 				return i;
 			}
 			if (c.getOp() == IfOp.EQ && c.getB().isFalse()) {
-				cond = not(new IfCondition(c.invert()));
+				cond = new IfCondition(Mode.NOT, Collections.singletonList(new IfCondition(c.invert())));
 			} else {
 				c.normalize();
 			}

File: jadx-gui/src/main/java/jadx/gui/device/debugger/RuntimeType.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.device.debugger;
 
-import io.github.hqktech.JDWP;
+import io.github.skylot.jdwp.JDWP;
 
 public enum RuntimeType {
 	ARRAY(91, "[]"),

File: jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java
Patch:
@@ -49,7 +49,7 @@ private void saveResources(ResContainer rc) {
 	private void save(ResContainer rc, File outDir) {
 		File outFile = new File(outDir, rc.getFileName());
 		if (!ZipSecurity.isInSubDirectory(outDir, outFile)) {
-			LOG.error("Path traversal attack detected, invalid resource name: {}", outFile.getPath());
+			LOG.error("Invalid resource name or path traversal attack detected: {}", outFile.getPath());
 			return;
 		}
 		saveToFile(rc, outFile);

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java
Patch:
@@ -53,10 +53,10 @@ public static boolean isValidZipEntryName(String entryName) {
 			if (isInSubDirectoryInternal(currentPath, canonical)) {
 				return true;
 			}
-			LOG.error("Path traversal attack detected, invalid name: {}", entryName);
+			LOG.error("Invalid file name or path traversal attack detected: {}", entryName);
 			return false;
 		} catch (Exception e) {
-			LOG.error("Path traversal attack detected, invalid name: {}", entryName);
+			LOG.error("Invalid file name or path traversal attack detected: {}", entryName);
 			return false;
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java
Patch:
@@ -6,6 +6,7 @@
 
 import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;
 
+@SuppressWarnings("CommentedOutCode")
 public class TestBooleanToInt extends SmaliTest {
 
 	// @formatter:off

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -805,7 +805,9 @@ public void setCodegenDeps(List<ClassNode> codegenDeps) {
 	}
 
 	public void addCodegenDep(ClassNode dep) {
-		this.codegenDeps = ListUtils.safeAdd(this.codegenDeps, dep);
+		if (!codegenDeps.contains(dep)) {
+			this.codegenDeps = ListUtils.safeAdd(this.codegenDeps, dep);
+		}
 	}
 
 	public int getTotalDepsCount() {

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java
Patch:
@@ -361,7 +361,9 @@ private static boolean attachProcess(MainWindow mainWindow) {
 					debugSetter.name,
 					debugSetter.device.getDeviceInfo().getAdbHost(),
 					debugSetter.forwardTcpPort,
-					debugSetter.ver);
+					debugSetter.ver,
+					debugSetter.device,
+					debugSetter.pid);
 		} catch (Exception e) {
 			LOG.error("Failed to attach to process", e);
 			return false;

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java
Patch:
@@ -107,7 +107,7 @@ private void startAnalysis() {
 	private void loadReport() {
 		try {
 			QuarkReportNode quarkNode = new QuarkReportNode(reportFile);
-			JRoot root = mainWindow.getCacheObject().getJRoot();
+			JRoot root = mainWindow.getTreeRoot();
 			root.replaceCustomNode(quarkNode);
 			root.update();
 			mainWindow.reloadTree();

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -469,6 +469,9 @@ public List<FieldNode> getFields() {
 	}
 
 	public void addField(FieldNode fld) {
+		if (fields == null || fields.isEmpty()) {
+			fields = new ArrayList<>(1);
+		}
 		fields.add(fld);
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -129,7 +129,7 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora
 				FieldNode newResField = new FieldNode(typeCls, rFieldInfo,
 						AccessFlags.PUBLIC | AccessFlags.STATIC | AccessFlags.FINAL);
 				newResField.addAttr(new EncodedValue(EncodedType.ENCODED_INT, resource.getId()));
-				typeCls.getFields().add(newResField);
+				typeCls.addField(newResField);
 				if (rClsExists) {
 					newResField.addInfoComment("Added by JADX");
 				}

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java
Patch:
@@ -420,6 +420,9 @@ public ResultsTableCellRenderer() {
 		@Override
 		public Component getTableCellRendererComponent(JTable table, Object obj,
 				boolean isSelected, boolean hasFocus, int row, int column) {
+			if (obj == null || table == null) {
+				return emptyLabel;
+			}
 			Component comp = makeCell((JNode) obj, column);
 			updateSelection(table, comp, column, isSelected);
 			return comp;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -553,6 +553,7 @@ private void prepareForSearch() {
 	}
 
 	private void addSearchResult(JNode node) {
+		Objects.requireNonNull(node);
 		synchronized (pendingResults) {
 			UiUtils.notUiThreadGuard();
 			pendingResults.add(node);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java
Patch:
@@ -137,8 +137,9 @@ static BlockNode connectNewBlock(MethodNode mth, BlockNode block, int offset) {
 	}
 
 	static BlockNode startNewBlock(MethodNode mth, int offset) {
-		BlockNode block = new BlockNode(mth.getBasicBlocks().size(), offset);
-		mth.getBasicBlocks().add(block);
+		List<BlockNode> blocks = mth.getBasicBlocks();
+		BlockNode block = new BlockNode(mth.getNextBlockCId(), blocks.size(), offset);
+		blocks.add(block);
 		return block;
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -697,7 +697,7 @@ public static BlockNode traverseWhileDominates(BlockNode dom, BlockNode start) {
 	}
 
 	/**
-	 * Search lowest common ancestor in dominator tree for input set.
+	 * Search the lowest common ancestor in dominator tree for input set.
 	 */
 	@Nullable
 	public static BlockNode getCommonDominator(MethodNode mth, List<BlockNode> blocks) {

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -13,6 +13,7 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.nio.file.StandardOpenOption;
 import java.security.MessageDigest;
 import java.util.ArrayList;
 import java.util.Comparator;
@@ -228,7 +229,8 @@ public static void close(Closeable c) {
 
 	public static void writeFile(Path file, String data) throws IOException {
 		FileUtils.makeDirsForFile(file);
-		Files.write(file, data.getBytes(StandardCharsets.UTF_8));
+		Files.write(file, data.getBytes(StandardCharsets.UTF_8),
+				StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
 	}
 
 	public static String readFile(Path textFile) throws IOException {

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java
Patch:
@@ -391,7 +391,8 @@ private static boolean canRemoveBlock(BlockNode block) {
 				&& block.getSuccessors().size() <= 1
 				&& !block.getPredecessors().isEmpty()
 				&& !block.contains(AFlag.MTH_ENTER_BLOCK)
-				&& !block.contains(AFlag.MTH_EXIT_BLOCK);
+				&& !block.contains(AFlag.MTH_EXIT_BLOCK)
+				&& !block.getSuccessors().contains(block); // no self loop
 	}
 
 	static void collectSuccessors(BlockNode startBlock, BlockNode methodEnterBlock, Set<BlockNode> toRemove) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -464,7 +464,7 @@ private boolean insertLoopBreak(RegionStack stack, LoopInfo loop, BlockNode loop
 		BlockNode exitEnd = BlockUtils.followEmptyPath(exit);
 		List<LoopInfo> loops = exitEnd.getAll(AType.LOOP);
 		for (LoopInfo loopAtEnd : loops) {
-			if (loopAtEnd != loop) {
+			if (loopAtEnd != loop && loop.hasParent(loopAtEnd)) {
 				insertEdge = exitEdge;
 				confirm = true;
 				break;

File: jadx-gui/src/main/java/jadx/gui/jobs/IBackgroundTask.java
Patch:
@@ -54,7 +54,7 @@ default boolean checkMemoryUsage() {
 	/**
 	 * Return progress notifications listener (use executor tick rate and thread) (Optional)
 	 */
-	default @Nullable Consumer<ITaskProgress> getOnProgressListener() {
+	default @Nullable Consumer<ITaskProgress> getProgressListener() {
 		return null;
 	}
 }

File: jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java
Patch:
@@ -113,7 +113,7 @@ public Object invoke(String clsFullName, String methodName, Class<?>[] types, Ob
 			assertNotNull(mth, "Failed to get method " + methodName + '(' + Arrays.toString(types) + ')');
 			return mth.invoke(inst, args);
 		} catch (Throwable e) {
-			IntegrationTest.rethrow("Invoke error", e);
+			IntegrationTest.rethrow("Invoke error for method: " + methodName, e);
 			return null;
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -66,7 +66,7 @@ private JResource getHierarchyResources(List<ResourceFile> resources) {
 					if (i != count - 1) {
 						subRF = new JResource(null, name, JResType.DIR);
 					} else {
-						subRF = new JResource(rf, rf.getOriginalName(), name, JResType.FILE);
+						subRF = new JResource(rf, rf.getDeobfName(), name, JResType.FILE);
 					}
 					curRf.getFiles().add(subRF);
 				}

File: jadx-gui/src/main/java/jadx/gui/utils/NLS.java
Patch:
@@ -37,6 +37,7 @@ public class NLS {
 		LANG_LOCALES.add(new LangLocale("es", "ES"));
 		LANG_LOCALES.add(new LangLocale("de", "DE"));
 		LANG_LOCALES.add(new LangLocale("ko", "KR"));
+		LANG_LOCALES.add(new LangLocale("pt", "BR"));
 
 		LANG_LOCALES.forEach(NLS::load);
 

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -428,7 +428,9 @@ private String makeClsPrefix(ClassNode cls) {
 			return "Enum";
 		}
 		String result = "";
-		if (cls.getAccessFlags().isAbstract()) {
+		if (cls.getAccessFlags().isInterface()) {
+			result += "Interface";
+		} else if (cls.getAccessFlags().isAbstract()) {
 			result += "Abstract";
 		}
 

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -411,7 +411,7 @@ private boolean openSingleFile(Path singleFile, Runnable onFinish) {
 		// check if project file already saved with default name
 		Path projectPath = getProjectPathForFile(singleFile);
 		if (Files.exists(projectPath)) {
-			LOG.info("Loading project for this file");
+			LOG.info("Loading project {}", projectPath);
 			openProject(projectPath, onFinish);
 			return true;
 		}

File: jadx-core/src/main/java/jadx/core/codegen/SimpleModeHelper.java
Patch:
@@ -53,7 +53,9 @@ public List<BlockNode> prepareBlocks() {
 				startLabel.set(block.getId());
 			} else if (predsCount == 1 && prev != null) {
 				if (!prev.equals(preds.get(0))) {
-					startLabel.set(block.getId());
+					if (!block.contains(AFlag.EXC_BOTTOM_SPLITTER)) {
+						startLabel.set(block.getId());
+					}
 					if (prev.getSuccessors().size() == 1 && !mth.isPreExitBlocks(prev)) {
 						endGoto.set(prev.getId());
 					}

File: jadx-gui/src/main/java/jadx/gui/device/protocol/ADB.java
Patch:
@@ -103,7 +103,7 @@ static byte[] readServiceProtocol(InputStream stream) {
 			}
 			return result;
 		} catch (SocketException e) {
-			LOG.error("Aborting readServiceProtocol: socket closed");
+			LOG.warn("Aborting readServiceProtocol: {}", e.toString());
 		} catch (IOException e) {
 			LOG.error("Failed to read readServiceProtocol", e);
 		}
@@ -207,7 +207,7 @@ public static Socket listenForDeviceState(DeviceStateListener listener, String h
 					List<ADBDeviceInfo> deviceInfoList = new ArrayList<>(deviceLines.length);
 					for (String deviceLine : deviceLines) {
 						if (!deviceLine.trim().isEmpty()) {
-							deviceInfoList.add(ADBDeviceInfo.make(deviceLine, host, port));
+							deviceInfoList.add(new ADBDeviceInfo(deviceLine, host, port));
 						}
 					}
 					listener.onDeviceStatusChange(deviceInfoList);

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -555,7 +555,7 @@ protected void disableCompilation() {
 
 	protected void enableDeobfuscation() {
 		args.setDeobfuscationOn(true);
-		args.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.OVERWRITE);
+		args.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.IGNORE);
 		args.setDeobfuscationMinLength(2);
 		args.setDeobfuscationMaxLength(64);
 	}

File: jadx-core/src/test/java/jadx/tests/integration/names/TestClassNamesCollision2.java
Patch:
@@ -1,7 +1,5 @@
 package jadx.tests.integration.names;
 
-import java.util.List;
-
 import org.junit.jupiter.api.Test;
 
 import jadx.api.CommentsLevel;

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericsMthOverride.java
Patch:
@@ -56,8 +56,6 @@ public void test() {
 		assertThat(code, containsOne("public Y method(Exception x) {"));
 		assertThat(code, containsOne("public Object method(Object x) {"));
 
-		assertThat(code, countString(3, "@Override"));
-		// TODO: @Override missing for class C
-		// assertThat(code, countString(4, "@Override"));
+		assertThat(code, countString(4, "@Override"));
 	}
 }

File: jadx-core/src/main/java/jadx/api/metadata/ICodeAnnotation.java
Patch:
@@ -9,7 +9,8 @@ enum AnnType {
 		VAR,
 		VAR_REF,
 		DECLARATION,
-		OFFSET
+		OFFSET,
+		END // class or method body end
 	}
 
 	AnnType getAnnType();

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -19,6 +19,7 @@
 import jadx.api.ICodeInfo;
 import jadx.api.ICodeWriter;
 import jadx.api.JadxArgs;
+import jadx.api.metadata.annotations.NodeEnd;
 import jadx.api.plugins.input.data.AccessFlags;
 import jadx.api.plugins.input.data.annotations.EncodedType;
 import jadx.api.plugins.input.data.annotations.EncodedValue;
@@ -256,6 +257,7 @@ public void addClassBody(ICodeWriter clsCode, boolean printClassName) throws Cod
 		addInnerClsAndMethods(clsCode);
 		clsCode.decIndent();
 		clsCode.startLine('}');
+		clsCode.attachAnnotation(NodeEnd.VALUE);
 	}
 
 	private void addInnerClsAndMethods(ICodeWriter clsCode) {
@@ -369,6 +371,7 @@ public void addMethodCode(ICodeWriter code, MethodNode mth) throws CodegenExcept
 			mthGen.addInstructions(code);
 			code.decIndent();
 			code.startLine('}');
+			code.attachAnnotation(NodeEnd.VALUE);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -761,6 +761,7 @@ private void inlineAnonymousConstructor(ICodeWriter code, ClassNode cls, Constru
 				ctor.add(AFlag.DONT_GENERATE);
 			}
 		}
+		code.attachDefinition(cls);
 		code.add("new ");
 		useClass(code, parent);
 		MethodNode callMth = mth.root().resolveMethod(insn.getCallMth());

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -228,7 +228,7 @@ public JavaNode getJavaNodeByRef(ICodeNodeRef nodeRef) {
 		return getDecompiler().getJavaNodeByRef(nodeRef);
 	}
 
-	public JavaNode getEnclosingNode(ICodeInfo codeInfo, int pos) {
+	public @Nullable JavaNode getEnclosingNode(ICodeInfo codeInfo, int pos) {
 		return getDecompiler().getEnclosingNode(codeInfo, pos);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/search/providers/BaseSearchProvider.java
Patch:
@@ -7,6 +7,7 @@
 import jadx.gui.search.ISearchMethod;
 import jadx.gui.search.ISearchProvider;
 import jadx.gui.search.SearchSettings;
+import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.JNodeCache;
@@ -33,7 +34,7 @@ protected JNode convert(JavaNode node) {
 		return nodeCache.makeFrom(node);
 	}
 
-	protected JNode convert(JavaClass cls) {
+	protected JClass convert(JavaClass cls) {
 		return nodeCache.makeFrom(cls);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java
Patch:
@@ -42,7 +42,7 @@
 public class DiskCodeCache implements ICodeCache {
 	private static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);
 
-	private static final int DATA_FORMAT_VERSION = 11;
+	private static final int DATA_FORMAT_VERSION = 12;
 
 	private static final byte[] JADX_NAMES_MAP_HEADER = "jadxnm".getBytes(StandardCharsets.US_ASCII);
 

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/CodeAnnotationAdapter.java
Patch:
@@ -38,6 +38,7 @@ private Map<AnnType, DataAdapter<?>> registerAdapters(RootNode root) {
 		map.put(AnnType.VAR, new VarNodeAdapter(mthAdapter));
 		map.put(AnnType.VAR_REF, VarRefAdapter.INSTANCE);
 		map.put(AnnType.OFFSET, InsnCodeOffsetAdapter.INSTANCE);
+		map.put(AnnType.END, new NodeEndAdapter());
 		return map;
 	}
 

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -356,8 +356,9 @@ private void appendSourcesSave(List<Runnable> tasks, File outDir) {
 			tasks.add(() -> {
 				for (JavaClass cls : decompileBatch) {
 					try {
-						ICodeInfo code = cls.getCodeInfo();
-						SaveCode.save(outDir, cls.getClassNode(), code);
+						ClassNode clsNode = cls.getClassNode();
+						ICodeInfo code = clsNode.getCode();
+						SaveCode.save(outDir, clsNode, code);
 					} catch (Exception e) {
 						LOG.error("Error saving class: {}", cls, e);
 					}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java
Patch:
@@ -226,6 +226,7 @@ public String getSyntaxName() {
 
 			case MANIFEST:
 			case XML:
+			case ARSC:
 				return SyntaxConstants.SYNTAX_STYLE_XML;
 
 			default:
@@ -249,8 +250,7 @@ public String getSyntaxName() {
 			"yaml", SyntaxConstants.SYNTAX_STYLE_YAML,
 			"properties", SyntaxConstants.SYNTAX_STYLE_PROPERTIES_FILE,
 			"ini", SyntaxConstants.SYNTAX_STYLE_INI,
-			"sql", SyntaxConstants.SYNTAX_STYLE_SQL,
-			"arsc", SyntaxConstants.SYNTAX_STYLE_XML);
+			"sql", SyntaxConstants.SYNTAX_STYLE_SQL);
 
 	private String getSyntaxByExtension(String name) {
 		int dot = name.lastIndexOf('.');

File: jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java
Patch:
@@ -82,5 +82,6 @@ public JumpPosition getNext() {
 
 	public void reset() {
 		list.clear();
+		currentPos = 0;
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -823,7 +823,9 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti
 		}
 		if (callMthNode != null) {
 			code.attachAnnotation(callMthNode);
-			code.add(callMthNode.getAlias());
+		}
+		if (insn.contains(AFlag.FORCE_RAW_NAME)) {
+			code.add(callMth.getName());
 		} else {
 			code.add(callMth.getAlias());
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -25,6 +25,8 @@ public enum AFlag {
 	HIDDEN, // instruction used inside other instruction but not listed in args
 
 	DONT_RENAME, // do not rename during deobfuscation
+	FORCE_RAW_NAME, // force use of raw name instead alias
+
 	ADDED_TO_REGION,
 
 	EXC_TOP_SPLITTER,

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -1013,6 +1013,9 @@ public static List<InsnNode> collectInsnsWithLimit(List<BlockNode> blocks, int l
 	 */
 	@Nullable
 	public static InsnNode getOnlyOneInsnFromMth(MethodNode mth) {
+		if (mth.isNoCode()) {
+			return null;
+		}
 		InsnNode insn = null;
 		for (BlockNode block : mth.getBasicBlocks()) {
 			List<InsnNode> blockInsns = block.getInstructions();

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -406,7 +406,6 @@ private boolean buildSearch(String text, SearchSettings searchSettings) {
 	private synchronized void stopSearchTask() {
 		if (searchTask != null) {
 			searchTask.cancel();
-			searchTask.waitTask();
 			searchTask = null;
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java
Patch:
@@ -50,7 +50,7 @@ public static boolean process(MethodNode mth) {
 			return false;
 		}
 		BlockProcessor.updateCleanSuccessors(mth);
-		BlockProcessor.computeDominanceFrontier(mth);
+		DominatorTree.computeDominanceFrontier(mth);
 
 		processCatchAttr(mth);
 		initExcHandlers(mth);

File: jadx-core/src/test/java/jadx/tests/integration/others/TestMoveInline.java
Patch:
@@ -26,7 +26,6 @@ public final void Y(int i) throws k {
 
 	@Test
 	public void test() {
-		getArgs().setRawCFGOutput(true);
 		assertThat(getClassNodeFromSmali())
 				.code()
 				// check operations order

File: jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java
Patch:
@@ -45,8 +45,8 @@ private void process(RootNode root) {
 			deobfuscator.execute();
 		}
 
-		checkClasses(deobfuscator, root, args);
 		UserRenames.applyForNodes(root);
+		checkClasses(deobfuscator, root, args);
 
 		if (args.isDeobfuscationOn() || !args.isJsonOutput()) {
 			deobfuscator.savePresets();

File: jadx-core/src/main/java/jadx/api/JavaVariable.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.List;
 
 import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
 
 import jadx.api.metadata.ICodeAnnotation;
 import jadx.api.metadata.annotations.VarNode;
@@ -32,7 +33,7 @@ public int getSsa() {
 	}
 
 	@Override
-	public String getName() {
+	public @Nullable String getName() {
 		return varNode.getName();
 	}
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java
Patch:
@@ -70,6 +70,6 @@ public String getTooltip() {
 
 	@Override
 	public boolean canRename() {
-		return true;
+		return var.getName() != null;
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliArea.java
Patch:
@@ -136,15 +136,15 @@ public void scrollToDebugPos(int pos) {
 
 	@Override
 	public Font getFont() {
-		if (model == null) {
+		if (model == null || isDisposed()) {
 			return super.getFont();
 		}
 		return model.getFont();
 	}
 
 	@Override
 	public Font getFontForTokenType(int type) {
-		return model.getFont();
+		return getFont();
 	}
 
 	private boolean shouldUseSmaliPrinterV2() {

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java
Patch:
@@ -70,7 +70,7 @@ protected QuarkReportPanel(TabbedPane panel, QuarkReportNode node, QuarkReportDa
 	}
 
 	private void prepareData() {
-		data.crimes.sort(Comparator.comparingInt(c -> -Integer.parseInt(c.confidence.replace("%", ""))));
+		data.crimes.sort(Comparator.comparingInt(c -> -c.parseConfidence()));
 	}
 
 	private void initUI() {
@@ -290,7 +290,7 @@ public MutableTreeNode resolveMethod(String descr) {
 			}
 			return new MethodTreeNode(javaMethod);
 		} catch (Exception e) {
-			LOG.error("Failed to parse method descriptor string", e);
+			LOG.error("Failed to parse method descriptor string: {}", descr, e);
 			return new TextTreeNode(descr);
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -307,7 +307,7 @@ private void searchFieldSubscribe() {
 		Flowable<String> textChanges = onTextFieldChanges(searchField);
 		Flowable<String> searchEvents = Flowable.merge(textChanges, searchEmitter.getFlowable());
 		searchDisposable = searchEvents
-				.debounce(100, TimeUnit.MILLISECONDS)
+				.debounce(500, TimeUnit.MILLISECONDS)
 				.observeOn(SwingSchedulers.edt())
 				.subscribe(this::search);
 	}
@@ -342,6 +342,7 @@ private synchronized void search(String text) {
 			return;
 		}
 
+		updateTableHighlight();
 		startSearch();
 		searchTask.setResultsLimit(100);
 		searchTask.setProgressListener(this::updateProgress);
@@ -476,7 +477,6 @@ private void updateProgress(ITaskProgress progress) {
 	private synchronized void searchComplete() {
 		UiUtils.uiThreadGuard();
 		LOG.debug("Search complete");
-		updateTableHighlight();
 		updateTable();
 
 		boolean complete = searchTask == null || searchTask.isSearchComplete();

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -814,7 +814,6 @@ public void syncWithEditor() {
 	}
 
 	private void initMenuAndToolbar() {
-		final boolean devVersion = (Jadx.VERSION_DEV.equals(Jadx.getVersion()));
 		Action openAction = new AbstractAction(NLS.str("file.open_action"), ICON_OPEN) {
 			@Override
 			public void actionPerformed(ActionEvent e) {
@@ -1124,7 +1123,7 @@ public void actionPerformed(ActionEvent e) {
 		JMenu help = new JMenu(NLS.str("menu.help"));
 		help.setMnemonic(KeyEvent.VK_H);
 		help.add(logAction);
-		if (devVersion) {
+		if (Jadx.isDevVersion()) {
 			help.add(new AbstractAction("Show sample error report") {
 				@Override
 				public void actionPerformed(ActionEvent e) {

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -180,12 +180,12 @@ public String makeRawFullName() {
 		return makeFullClsName(pkg, name, parentClass, false, true);
 	}
 
-	private String makeAliasFullName() {
+	public String makeAliasFullName() {
 		return makeFullClsName(getAliasPkg(), getAliasShortName(), parentClass, true, false);
 	}
 
-	private String makeAliasRawFullName() {
-		return makeFullClsName(pkg, name, parentClass, true, true);
+	public String makeAliasRawFullName() {
+		return makeFullClsName(getAliasPkg(), getAliasShortName(), parentClass, true, true);
 	}
 
 	public String getAliasFullPath() {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodePopupListener.java
Patch:
@@ -33,7 +33,7 @@ public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
 
 	@Override
 	public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
-		updateNode(null);
+		// this event can be called just before running action, so can't reset node here
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java
Patch:
@@ -203,6 +203,9 @@ private void addSuperTypes(ClspClass cls, Set<String> result) {
 				if (isNew) {
 					addSuperTypes(parentCls, result);
 				}
+			} else {
+				// parent type is unknown
+				result.add(parentType.getObject());
 			}
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java
Patch:
@@ -11,7 +11,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Locale;
 
 import javax.tools.DiagnosticListener;
 import javax.tools.JavaCompiler;
@@ -82,7 +81,7 @@ private void compile(List<JavaFileObject> jfObjects) {
 		arguments.addAll(options.getArguments());
 
 		DiagnosticListener<? super JavaFileObject> diagnostic =
-				diagObj -> System.out.println("Compiler diagnostic: " + diagObj.getMessage(Locale.ROOT));
+				diagObj -> System.out.println("Compiler diagnostic: " + diagObj);
 		Writer out = new PrintWriter(System.out);
 		CompilationTask compilerTask = compiler.getTask(out, fileManager, diagnostic, arguments, null, jfObjects);
 		if (Boolean.FALSE.equals(compilerTask.call())) {

File: jadx-core/src/main/java/jadx/api/JadxArgs.java
Patch:
@@ -128,7 +128,7 @@ public void setRootDir(File rootDir) {
 
 	public void close() {
 		try {
-			inputFiles.clear();
+			inputFiles = null;
 			if (codeCache != null) {
 				codeCache.close();
 			}

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java
Patch:
@@ -29,6 +29,7 @@
 import jadx.api.ICodeCache;
 import jadx.api.ICodeInfo;
 import jadx.api.JadxArgs;
+import jadx.core.Jadx;
 import jadx.core.dex.nodes.RootNode;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
@@ -190,6 +191,7 @@ public void remove(String clsFullName) {
 
 	private String buildCodeVersion(JadxArgs args) {
 		return DATA_FORMAT_VERSION
+				+ ":" + Jadx.getVersion()
 				+ ":" + args.makeCodeArgsHash()
 				+ ":" + buildInputsHash(args.getInputFiles());
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java
Patch:
@@ -133,7 +133,7 @@ private static ExceptionHandler createHandler(MethodNode mth, InsnNode[] insnByO
 			ExcHandlerAttr excHandlerAttr = insn.get(AType.EXC_HANDLER);
 			if (excHandlerAttr != null) {
 				ExceptionHandler handler = excHandlerAttr.getHandler();
-				if (handler.addCatchType(type)) {
+				if (handler.addCatchType(mth, type)) {
 					// exist handler updated (assume from same try block) - don't add again
 					return null;
 				}
@@ -143,7 +143,7 @@ private static ExceptionHandler createHandler(MethodNode mth, InsnNode[] insnByO
 		} else {
 			insn = insertNOP(insnByOffset, handlerOffset);
 		}
-		ExceptionHandler handler = new ExceptionHandler(handlerOffset, type);
+		ExceptionHandler handler = ExceptionHandler.build(mth, handlerOffset, type);
 		mth.addExceptionHandler(handler);
 		insn.addAttr(new ExcHandlerAttr(handler));
 		return handler;

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java
Patch:
@@ -549,7 +549,7 @@ private static boolean mergeMultiCatch(MethodNode mth, TryCatchBlockAttr tryCatc
 			if (handler == resultHandler) {
 				return false;
 			}
-			resultHandler.addCatchTypes(handler.getCatchTypes());
+			resultHandler.addCatchTypes(mth, handler.getCatchTypes());
 			handler.markForRemove();
 			return true;
 		});

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException.java
Patch:
@@ -25,8 +25,6 @@ public void test() {
 
 	@Test
 	public void test() {
-		// printDisassemble();
-		// setFallback();
 		noDebugInfo();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java
Patch:
@@ -309,6 +309,7 @@ private void addContentPanel(ContentPanel contentPanel) {
 	public void closeCodePanel(ContentPanel contentPanel) {
 		openTabs.remove(contentPanel.getNode());
 		remove(contentPanel);
+		contentPanel.dispose();
 	}
 
 	@Nullable

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -437,6 +437,7 @@ private void closeAll() {
 		LogCollector.getInstance().reset();
 		wrapper.close();
 		tabbedPane.closeAllTabs();
+		UiUtils.resetClipboardOwner();
 		System.gc();
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -147,6 +147,7 @@ public void dispose() {
 		if (searchDisposable != null && !searchDisposable.isDisposed()) {
 			searchDisposable.dispose();
 		}
+		resultsModel.clear();
 		removeActiveTabListener();
 		super.dispose();
 	}
@@ -399,6 +400,7 @@ private synchronized void stopSearchTask() {
 		if (searchTask != null) {
 			searchTask.cancel();
 			searchTask.waitTask();
+			searchTask = null;
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java
Patch:
@@ -160,7 +160,7 @@ public static JClass searchMainActivity(MainWindow mainWindow) {
 	// TODO: parse AndroidManifest.xml instead of looking for keywords
 	private static String getManifestContent(MainWindow mainWindow) {
 		try {
-			ResourceFile androidManifest = mainWindow.getWrapper().getDecompiler().getResources()
+			ResourceFile androidManifest = mainWindow.getWrapper().getResources()
 					.stream()
 					.filter(res -> res.getType() == ResourceType.MANIFEST)
 					.findFirst()

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -65,7 +65,6 @@
 import jadx.api.args.DeobfuscationMapFileMode;
 import jadx.api.plugins.JadxPlugin;
 import jadx.api.plugins.JadxPluginInfo;
-import jadx.api.plugins.JadxPluginManager;
 import jadx.api.plugins.options.JadxPluginOptions;
 import jadx.api.plugins.options.OptionDescription;
 import jadx.gui.ui.MainWindow;
@@ -580,8 +579,7 @@ private SettingsGroup makeDecompilationGroup() {
 
 	private SettingsGroup makePluginOptionsGroup() {
 		SettingsGroup pluginsGroup = new SettingsGroup(NLS.str("preferences.plugins"));
-		JadxPluginManager pluginManager = mainWindow.getWrapper().getDecompiler().getPluginManager();
-		for (JadxPlugin plugin : pluginManager.getAllPlugins()) {
+		for (JadxPlugin plugin : mainWindow.getWrapper().getAllPlugins()) {
 			if (!(plugin instanceof JadxPluginOptions)) {
 				continue;
 			}

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java
Patch:
@@ -65,7 +65,7 @@ private static void updateCommentsData(CodeArea codeArea, Consumer<List<ICodeCom
 			Collections.sort(list);
 			codeData.setComments(list);
 			project.setCodeData(codeData);
-			codeArea.getMainWindow().getWrapper().getDecompiler().reloadCodeData();
+			codeArea.getMainWindow().getWrapper().reloadCodeData();
 		} catch (Exception e) {
 			LOG.error("Comment action failed", e);
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/ExcludePkgDialog.java
Patch:
@@ -121,7 +121,7 @@ public void mousePressed(MouseEvent e) {
 	}
 
 	private void initPackageList() {
-		List<String> pkgs = mainWindow.getWrapper().getDecompiler().getPackages()
+		List<String> pkgs = mainWindow.getWrapper().getPackages()
 				.stream()
 				.map(JavaPackage::getFullName)
 				.collect(Collectors.toList());

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java
Patch:
@@ -16,11 +16,11 @@
 import javax.swing.WindowConstants;
 
 import jadx.api.ICodeInfo;
-import jadx.api.JadxDecompiler;
 import jadx.api.JavaClass;
 import jadx.api.JavaMethod;
 import jadx.api.JavaNode;
 import jadx.api.utils.CodeUtils;
+import jadx.gui.JadxWrapper;
 import jadx.gui.jobs.TaskStatus;
 import jadx.gui.treemodel.CodeNode;
 import jadx.gui.treemodel.JMethod;
@@ -97,14 +97,14 @@ private List<JavaMethod> getMethodWithOverrides(JavaMethod javaMethod) {
 	private void processUsage(JavaNode searchNode, JavaClass topUseClass) {
 		ICodeInfo codeInfo = topUseClass.getCodeInfo();
 		String code = codeInfo.getCodeStr();
-		JadxDecompiler decompiler = mainWindow.getWrapper().getDecompiler();
+		JadxWrapper wrapper = mainWindow.getWrapper();
 		List<Integer> usePositions = topUseClass.getUsePlacesFor(codeInfo, searchNode);
 		for (int pos : usePositions) {
 			String line = CodeUtils.getLineForPos(code, pos);
 			if (line.startsWith("import ")) {
 				continue;
 			}
-			JavaNode enclosingNode = decompiler.getEnclosingNode(codeInfo, pos);
+			JavaNode enclosingNode = wrapper.getEnclosingNode(codeInfo, pos);
 			JavaNode usageNode = enclosingNode == null ? topUseClass : enclosingNode;
 			usageList.add(new CodeNode(getNodeCache().makeFrom(usageNode), line.trim(), pos));
 		}

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -7,6 +7,7 @@ public class Consts {
 	public static final boolean DEBUG_TYPE_INFERENCE = false;
 	public static final boolean DEBUG_OVERLOADED_CASTS = false;
 	public static final boolean DEBUG_EXC_HANDLERS = false;
+	public static final boolean DEBUG_FINALLY = false;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";
 	public static final String CLASS_STRING = "java.lang.String";

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -379,7 +379,9 @@ private synchronized ICodeInfo decompile(boolean searchInCache) {
 			}
 		}
 		ICodeInfo codeInfo = root.getProcessClasses().generateCode(this);
-		codeCache.add(clsRawName, codeInfo);
+		if (codeInfo != ICodeInfo.EMPTY) {
+			codeCache.add(clsRawName, codeInfo);
+		}
 		return codeInfo;
 	}
 

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -89,7 +89,8 @@ private boolean isBinaryXml() throws IOException {
 		is.mark(4);
 		int v = is.readInt16(); // version
 		int h = is.readInt16(); // header size
-		if (v == 0x0003 && h == 0x0008) {
+		// Some APK Manifest.xml the version is 0
+		if (h == 0x0008) {
 			return true;
 		}
 		is.reset();

File: jadx-core/src/test/java/jadx/tests/integration/others/TestCodeMetadata.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.others;
 
 import java.util.List;
-import java.util.Objects;
 
 import org.junit.jupiter.api.Test;
 
+import jadx.api.JadxInternalAccess;
 import jadx.api.JavaClass;
 import jadx.api.JavaMethod;
 import jadx.api.metadata.ICodeAnnotation;
@@ -46,8 +46,8 @@ public void test() {
 		int callDefPos = callMth.getDefPosition();
 		assertThat(callDefPos).isNotZero();
 
-		JavaClass javaClass = Objects.requireNonNull(jadxDecompiler.getJavaClassByNode(cls));
-		JavaMethod callJavaMethod = Objects.requireNonNull(jadxDecompiler.getJavaMethodByNode(callMth));
+		JavaClass javaClass = JadxInternalAccess.convertClassNode(jadxDecompiler, cls);
+		JavaMethod callJavaMethod = JadxInternalAccess.convertMethodNode(jadxDecompiler, callMth);
 		List<Integer> callUsePlaces = javaClass.getUsePlacesFor(javaClass.getCodeInfo(), callJavaMethod);
 		assertThat(callUsePlaces).hasSize(1);
 		int callUse = callUsePlaces.get(0);

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -20,7 +20,6 @@
 import jadx.api.JavaClass;
 import jadx.api.JavaNode;
 import jadx.api.metadata.ICodeAnnotation;
-import jadx.core.dex.nodes.ClassNode;
 import jadx.gui.settings.JadxProject;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
@@ -244,8 +243,8 @@ public JavaClass getJavaClassIfAtPos(int pos) {
 			ICodeInfo codeInfo = getCodeInfo();
 			if (codeInfo.hasMetadata()) {
 				ICodeAnnotation ann = codeInfo.getCodeMetadata().getAt(pos);
-				if (ann instanceof ClassNode) {
-					return getDecompiler().getJavaClassByNode(((ClassNode) ann));
+				if (ann != null && ann.getAnnType() == ICodeAnnotation.AnnType.CLASS) {
+					return (JavaClass) getDecompiler().getJavaNodeByCodeAnnotation(codeInfo, ann);
 				}
 			}
 		} catch (Exception e) {

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkDialog.java
Patch:
@@ -39,15 +39,15 @@ public QuarkDialog(MainWindow mainWindow) {
 		this.files = filterOpenFiles(mainWindow);
 		if (files.isEmpty()) {
 			UiUtils.errorMessage(mainWindow, "Quark is unable to analyze loaded files");
-			LOG.error("Quark: The files cannot be analyzed: {}", mainWindow.getWrapper().getOpenPaths());
+			LOG.error("Quark: The files cannot be analyzed: {}", mainWindow.getProject().getFilePaths());
 			return;
 		}
 		initUI();
 	}
 
 	private List<Path> filterOpenFiles(MainWindow mainWindow) {
 		PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:**.{apk,dex}");
-		return mainWindow.getWrapper().getOpenPaths()
+		return mainWindow.getProject().getFilePaths()
 				.stream()
 				.filter(matcher::matches)
 				.collect(Collectors.toList());

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -138,7 +138,7 @@ private void initUI() {
 
 			SwingUtilities.invokeLater(() -> {
 				if (needReload) {
-					mainWindow.reOpenFile();
+					mainWindow.reopen();
 				}
 				if (!settings.getLangLocale().equals(prevLang)) {
 					JOptionPane.showMessageDialog(

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -133,7 +133,7 @@ public JClass getJParent() {
 
 	@Override
 	public String makeString() {
-		List<Path> paths = wrapper.getOpenPaths();
+		List<Path> paths = wrapper.getProject().getFilePaths();
 		int count = paths.size();
 		if (count == 0) {
 			return "File not open";
@@ -146,7 +146,7 @@ public String makeString() {
 
 	@Override
 	public String getTooltip() {
-		List<Path> paths = wrapper.getOpenPaths();
+		List<Path> paths = wrapper.getProject().getFilePaths();
 		int count = paths.size();
 		if (count < 2) {
 			return null;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/ExcludePkgDialog.java
Patch:
@@ -103,7 +103,7 @@ public void mousePressed(MouseEvent e) {
 
 		btnOk.addActionListener(e -> {
 			mainWindow.getWrapper().setExcludedPackages(getExcludes());
-			mainWindow.reOpenFile();
+			mainWindow.reopen();
 			dispose();
 		});
 		btnAll.addActionListener(e -> {

File: jadx-gui/src/main/java/jadx/gui/ui/popupmenu/JPackagePopupMenu.java
Patch:
@@ -120,7 +120,7 @@ private JMenuItem makeExcludeItem(JPackage pkg) {
 			} else {
 				wrapper.removeExcludedPackage(fullName);
 			}
-			mainWindow.reOpenFile();
+			mainWindow.reopen();
 		});
 		return excludeItem;
 	}

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java
Patch:
@@ -111,7 +111,8 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
 					return FileVisitResult.CONTINUE;
 				}
 			});
-			LOG.info("Found {} classes in disk cache in {} ms", cachedKeys.size(), System.currentTimeMillis() - start);
+			LOG.info("Found {} classes metadata in disk cache in {} ms, dir: {}", cachedKeys.size(),
+					System.currentTimeMillis() - start, metaDir);
 		} catch (Exception e) {
 			LOG.error("Failed to collect cached items", e);
 		}

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java
Patch:
@@ -37,7 +37,7 @@
 public class DiskCodeCache implements ICodeCache {
 	private static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);
 
-	private static final int DATA_FORMAT_VERSION = 9;
+	private static final int DATA_FORMAT_VERSION = 10;
 
 	private final Path srcDir;
 	private final Path metaDir;

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -168,10 +168,11 @@ public void declareVar(ICodeWriter code, CodeVar codeVar) {
 	 * Variable definition without type, only var name
 	 */
 	private void defVar(ICodeWriter code, CodeVar codeVar) {
+		String varName = mgen.getNameGen().assignArg(codeVar);
 		if (code.isMetadataSupported()) {
 			code.attachDefinition(VarNode.get(mth, codeVar));
 		}
-		code.add(mgen.getNameGen().assignArg(codeVar));
+		code.add(varName);
 	}
 
 	private String lit(LiteralArg arg) {

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -206,7 +206,6 @@ public List<Integer> getUsePlacesFor(ICodeInfo codeInfo, JavaNode javaNode) {
 				// ignore declarations and offset annotations
 				continue;
 			}
-			// ignore declarations
 			JavaNode annNode = rootDec.getJavaNodeByCodeAnnotation(codeInfo, ann);
 			if (annNode == null && LOG.isDebugEnabled()) {
 				LOG.debug("Failed to resolve code annotation, cls: {}, pos: {}, ann: {}", this, entry.getKey(), ann);

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java
Patch:
@@ -37,7 +37,7 @@
 public class DiskCodeCache implements ICodeCache {
 	private static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);
 
-	private static final int DATA_FORMAT_VERSION = 8;
+	private static final int DATA_FORMAT_VERSION = 9;
 
 	private final Path srcDir;
 	private final Path metaDir;

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/InsnCodeOffsetAdapter.java
Patch:
@@ -12,11 +12,11 @@ public class InsnCodeOffsetAdapter implements DataAdapter<InsnCodeOffset> {
 
 	@Override
 	public void write(DataOutput out, InsnCodeOffset value) throws IOException {
-		out.writeShort(value.getOffset());
+		DataAdapterHelper.writeUVInt(out, value.getOffset());
 	}
 
 	@Override
 	public InsnCodeOffset read(DataInput in) throws IOException {
-		return new InsnCodeOffset(in.readShort());
+		return new InsnCodeOffset(DataAdapterHelper.readUVInt(in));
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/NodeDeclareRefAdapter.java
Patch:
@@ -21,13 +21,13 @@ public void write(DataOutput out, NodeDeclareRef value) throws IOException {
 			throw new RuntimeException("Null node in NodeDeclareRef");
 		}
 		refAdapter.write(out, node);
-		out.writeShort(value.getDefPos());
+		DataAdapterHelper.writeUVInt(out, value.getDefPos());
 	}
 
 	@Override
 	public NodeDeclareRef read(DataInput in) throws IOException {
 		ICodeNodeRef ref = (ICodeNodeRef) refAdapter.read(in);
-		int defPos = in.readShort();
+		int defPos = DataAdapterHelper.readUVInt(in);
 		NodeDeclareRef nodeDeclareRef = new NodeDeclareRef(ref);
 		nodeDeclareRef.setDefPos(defPos);
 		// restore def position if loading metadata without actual decompilation

File: jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java
Patch:
@@ -37,7 +37,7 @@
 public class DiskCodeCache implements ICodeCache {
 	private static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);
 
-	private static final int DATA_FORMAT_VERSION = 7;
+	private static final int DATA_FORMAT_VERSION = 8;
 
 	private final Path srcDir;
 	private final Path metaDir;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -90,7 +90,7 @@ public int getPos() {
 	}
 
 	public String getTooltip() {
-		return null;
+		return makeLongStringHtml();
 	}
 
 	private static final Comparator<JNode> COMPARATOR = Comparator

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java
Patch:
@@ -83,6 +83,6 @@ private void updateToolTip(JavaNode node) {
 		}
 		JNodeCache nodeCache = codeArea.getMainWindow().getCacheObject().getNodeCache();
 		JNode jNode = nodeCache.makeFrom(node);
-		codeArea.setToolTipText(jNode.makeLongString());
+		codeArea.setToolTipText(jNode.getTooltip());
 	}
 }

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -21,7 +21,7 @@ public static void main(String[] args) {
 		} catch (JadxArgsValidateException e) {
 			LOG.error("Incorrect arguments: {}", e.getMessage());
 			result = 1;
-		} catch (Exception e) {
+		} catch (Throwable e) {
 			LOG.error("Process error:", e);
 			result = 1;
 		} finally {

File: jadx-core/src/main/java/jadx/api/JavaNode.java
Patch:
@@ -12,8 +12,6 @@ public interface JavaNode {
 
 	JavaClass getTopParentClass();
 
-	int getDecompiledLine();
-
 	int getDefPos();
 
 	List<JavaNode> getUseIn();

File: jadx-core/src/main/java/jadx/api/data/impl/JadxCodeRef.java
Patch:
@@ -3,7 +3,7 @@
 import jadx.api.JavaVariable;
 import jadx.api.data.CodeRefType;
 import jadx.api.data.IJavaCodeRef;
-import jadx.api.data.annotations.VarRef;
+import jadx.api.metadata.annotations.VarNode;
 
 public class JadxCodeRef implements IJavaCodeRef {
 
@@ -23,8 +23,8 @@ public static JadxCodeRef forVar(JavaVariable javaVariable) {
 		return forVar(javaVariable.getReg(), javaVariable.getSsa());
 	}
 
-	public static JadxCodeRef forVar(VarRef varRef) {
-		return forVar(varRef.getReg(), varRef.getSsa());
+	public static JadxCodeRef forVar(VarNode varNode) {
+		return forVar(varNode.getReg(), varNode.getSsa());
 	}
 
 	public static JadxCodeRef forCatch(int handlerOffset) {

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -13,8 +13,8 @@
 import jadx.api.CommentsLevel;
 import jadx.api.ICodeWriter;
 import jadx.api.JadxArgs;
-import jadx.api.data.annotations.InsnCodeOffset;
-import jadx.api.data.annotations.VarDeclareRef;
+import jadx.api.metadata.annotations.InsnCodeOffset;
+import jadx.api.metadata.annotations.VarNode;
 import jadx.api.plugins.input.data.AccessFlags;
 import jadx.api.plugins.input.data.annotations.EncodedValue;
 import jadx.api.plugins.input.data.attributes.JadxAttrType;
@@ -243,7 +243,7 @@ private void addMethodArguments(ICodeWriter code, List<RegisterArg> args) {
 			code.add(' ');
 			String varName = nameGen.assignArg(var);
 			if (code.isMetadataSupported() && ssaVar != null /* for fallback mode */) {
-				code.attachDefinition(VarDeclareRef.get(mth, var));
+				code.attachDefinition(VarNode.get(mth, var));
 			}
 			code.add(varName);
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/ICodeNode.java
Patch:
@@ -1,9 +1,10 @@
 package jadx.core.dex.nodes;
 
+import jadx.api.metadata.ICodeNodeRef;
 import jadx.core.dex.attributes.IAttributeNode;
 import jadx.core.dex.info.AccessInfo;
 
-public interface ICodeNode extends IDexNode, IAttributeNode, IUsageInfoNode {
+public interface ICodeNode extends IDexNode, IAttributeNode, IUsageInfoNode, ICodeNodeRef {
 	AccessInfo getAccessFlags();
 
 	void setAccessFlags(AccessInfo newAccessFlags);

File: jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java
Patch:
@@ -4,9 +4,9 @@
 
 import org.jetbrains.annotations.Nullable;
 
-import jadx.api.CodePosition;
 import jadx.api.CommentsLevel;
 import jadx.api.ICodeWriter;
+import jadx.api.metadata.ICodeAnnotation;
 import jadx.api.plugins.input.data.attributes.JadxAttrType;
 import jadx.api.plugins.input.data.attributes.types.SourceFileAttr;
 import jadx.core.dex.attributes.AType;
@@ -95,7 +95,7 @@ private static void addCodeComments(ICodeWriter code, @Nullable IAttributeNode n
 	private static void addMultiLineComment(ICodeWriter code, List<String> comments) {
 		boolean first = true;
 		String indent = "";
-		Object lineAnn = null;
+		ICodeAnnotation lineAnn = null;
 		for (String comment : comments) {
 			for (String line : comment.split("\n")) {
 				if (first) {
@@ -104,7 +104,7 @@ private static void addMultiLineComment(ICodeWriter code, List<String> comments)
 					int startLinePos = buf.lastIndexOf(ICodeWriter.NL) + 1;
 					indent = Utils.strRepeat(" ", buf.length() - startLinePos);
 					if (code.isMetadataSupported()) {
-						lineAnn = code.getRawAnnotations().get(new CodePosition(code.getLine()));
+						lineAnn = code.getRawAnnotations().get(startLinePos);
 					}
 				} else {
 					code.newLine().add(indent);

File: jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java
Patch:
@@ -5,8 +5,8 @@
 import org.assertj.core.api.AbstractObjectAssert;
 import org.assertj.core.api.Assertions;
 
-import jadx.api.CodePosition;
 import jadx.api.ICodeInfo;
+import jadx.api.metadata.ICodeAnnotation;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.ICodeNode;
 import jadx.tests.api.IntegrationTest;
@@ -67,8 +67,8 @@ public void checkCodeAnnotationFor(String refStr, int refOffset, ICodeNode node)
 		int codePos = code.getCodeStr().indexOf(refStr);
 		assertThat(codePos).describedAs("String '%s' not found", refStr).isNotEqualTo(-1);
 		int refPos = codePos + refOffset;
-		for (Map.Entry<CodePosition, Object> entry : code.getAnnotations().entrySet()) {
-			if (entry.getKey().getPos() == refPos) {
+		for (Map.Entry<Integer, ICodeAnnotation> entry : code.getCodeMetadata().getAsMap().entrySet()) {
+			if (entry.getKey() == refPos) {
 				Assertions.assertThat(entry.getValue()).isEqualTo(node);
 				return;
 			}

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -37,7 +37,7 @@ public void test() {
 		printLineNumbers();
 
 		ClassNode cls = getClassNode(TestCls.class);
-		String linesMapStr = cls.getCode().getLineMapping().toString();
+		String linesMapStr = cls.getCode().getCodeMetadata().getLineMapping().toString();
 		if (isJavaInput()) {
 			assertEquals("{6=16, 9=17, 12=21, 13=22, 14=23, 15=24, 16=25, 18=27, 21=30, 22=31}", linesMapStr);
 		} else {

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers3.java
Patch:
@@ -33,7 +33,7 @@ public TestCls(final Object message) {
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		assertThat(cls).code().containsOne("super(message == null ? \"\" : message.toString());");
-		String linesMapStr = cls.getCode().getLineMapping().toString();
+		String linesMapStr = cls.getCode().getCodeMetadata().getLineMapping().toString();
 		assertThat(linesMapStr).isEqualTo("{4=13, 5=14, 6=15}");
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/jobs/ExportTask.java
Patch:
@@ -9,10 +9,10 @@
 import jadx.api.JadxDecompiler;
 import jadx.gui.JadxWrapper;
 import jadx.gui.ui.MainWindow;
-import jadx.gui.utils.FixedCodeCache;
 import jadx.gui.utils.NLS;
+import jadx.gui.utils.codecache.FixedCodeCache;
 
-public class ExportTask implements IBackgroundTask {
+public class ExportTask extends CancelableBackgroundTask {
 
 	private final MainWindow mainWindow;
 	private final JadxWrapper wrapper;

File: jadx-gui/src/main/java/jadx/gui/jobs/TaskStatus.java
Patch:
@@ -7,5 +7,5 @@ public enum TaskStatus {
 	CANCEL_BY_USER,
 	CANCEL_BY_TIMEOUT,
 	CANCEL_BY_MEMORY,
-	ERROR
+	ERROR;
 }

File: jadx-gui/src/main/java/jadx/gui/ui/MainDropTarget.java
Patch:
@@ -13,7 +13,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static jadx.gui.utils.FileUtils.toPaths;
+import jadx.core.utils.files.FileUtils;
 
 /**
  * Enables drop support from external applications for the {@link MainWindow} (load dropped APK
@@ -64,7 +64,7 @@ public void drop(DropTargetDropEvent dtde) {
 			List<File> transferData = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);
 			if (!transferData.isEmpty()) {
 				dtde.dropComplete(true);
-				mainWindow.open(toPaths(transferData));
+				mainWindow.open(FileUtils.toPaths(transferData));
 			}
 		} catch (Exception e) {
 			LOG.error("File drop operation failed", e);

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java
Patch:
@@ -155,11 +155,11 @@ private void initLineNumbers() {
 	}
 
 	private boolean canShowDebugLines() {
-		ICodeInfo codeInfo = codeArea.getNode().getCodeInfo();
-		if (codeInfo == null) {
+		ICodeInfo codeInfo = codeArea.getCodeInfo();
+		if (!codeInfo.hasMetadata()) {
 			return false;
 		}
-		Map<Integer, Integer> lineMapping = codeInfo.getLineMapping();
+		Map<Integer, Integer> lineMapping = codeInfo.getCodeMetadata().getLineMapping();
 		if (lineMapping.isEmpty()) {
 			return false;
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java
Patch:
@@ -52,7 +52,7 @@ private boolean addHighlight(MouseEvent e) {
 				// don't repaint highlight
 				return true;
 			}
-			JavaNode nodeAtOffset = codeLinkGenerator.getNodeAtOffset(codeArea, tokenOffset);
+			JavaNode nodeAtOffset = codeLinkGenerator.getNodeAtOffset(tokenOffset);
 			if (nodeAtOffset == null) {
 				return false;
 			}

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java
Patch:
@@ -19,9 +19,9 @@
 import org.jetbrains.annotations.Nullable;
 
 import jadx.core.utils.Utils;
+import jadx.core.utils.files.FileUtils;
 import jadx.gui.settings.JadxProject;
 import jadx.gui.ui.MainWindow;
-import jadx.gui.utils.FileUtils;
 import jadx.gui.utils.NLS;
 
 public class FileDialog {

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java
Patch:
@@ -248,7 +248,6 @@ private void refreshClasses(Set<JClass> updatedTopClasses) {
 		} else {
 			// big batch => unload
 			LOG.debug("Classes to unload: {}", updatedTopClasses.size());
-			cache.getIndexService().setComplete(false);
 			for (JClass cls : updatedTopClasses) {
 				try {
 					cls.unload(cache);

File: jadx-gui/src/main/java/jadx/gui/ui/panel/HtmlPanel.java
Patch:
@@ -23,7 +23,7 @@ public HtmlPanel(TabbedPane panel, JNode jnode) {
 		setLayout(new BorderLayout());
 		textArea = new JHtmlPane();
 		loadSettings();
-		textArea.setText(jnode.getContent());
+		textArea.setText(jnode.getCodeInfo().getCodeStr());
 		textArea.setCaretPosition(0); // otherwise the start view will be the last line
 		textArea.setEditable(false);
 		JScrollPane sp = new JScrollPane(textArea);

File: jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java
Patch:
@@ -52,6 +52,8 @@ public void removeWholeClass(JavaClass javaCls) {
 		remove(javaCls);
 		javaCls.getMethods().forEach(this::remove);
 		javaCls.getFields().forEach(this::remove);
+		javaCls.getInnerClasses().forEach(this::remove);
+		javaCls.getInlinedClasses().forEach(this::remove);
 	}
 
 	private JClass convert(JavaClass cls) {

File: jadx-gui/src/test/java/jadx/gui/utils/JumpManagerTest.java
Patch:
@@ -118,6 +118,6 @@ public void addSame() {
 	}
 
 	private JumpPosition makeJumpPos() {
-		return new JumpPosition(new TextNode(""), 0, 0);
+		return new JumpPosition(new TextNode(""), 0);
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -443,7 +443,7 @@ private boolean ensureProjectIsSaved() {
 				return false;
 			}
 			if (res == JOptionPane.YES_OPTION) {
-				project.save();
+				saveProject();
 			}
 		}
 		return true;

File: jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java
Patch:
@@ -61,7 +61,9 @@ private static boolean processMove(MethodNode mth, InsnNode move) {
 		}
 		SSAVar ssaVar = resultArg.getSVar();
 		if (ssaVar.isUsedInPhi()) {
-			return deleteMove(mth, move);
+			return false;
+			// TODO: review conditions of 'up' move inline (test TestMoveInline)
+			// return deleteMove(mth, move);
 		}
 		RegDebugInfoAttr debugInfo = moveArg.get(AType.REG_DEBUG_INFO);
 		for (RegisterArg useArg : ssaVar.getUseList()) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -80,6 +80,7 @@ public enum AFlag {
 	RERUN_SSA_TRANSFORM,
 
 	METHOD_CANDIDATE_FOR_INLINE,
+	USE_LINES_HINTS, // source lines info in methods can be trusted
 
 	DISABLE_BLOCKS_LOCK,
 

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -150,9 +150,9 @@ public void after() throws IOException {
 		close(decompiledCompiler);
 	}
 
-	private void close(Closeable cloaseble) throws IOException {
-		if (cloaseble != null) {
-			cloaseble.close();
+	private void close(Closeable closeable) throws IOException {
+		if (closeable != null) {
+			closeable.close();
 		}
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseAnd.java
Patch:
@@ -8,6 +8,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@SuppressWarnings({ "PointlessBooleanExpression", "unused" })
 public class TestBitwiseAnd extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java
Patch:
@@ -10,6 +10,7 @@
 
 public class TestConditions14 extends IntegrationTest {
 
+	@SuppressWarnings({ "EqualsReplaceableByObjectsCall", "ConstantConditions" })
 	public static class TestCls {
 
 		public static boolean test(Object a, Object b) {

File: jadx-gui/src/main/java/jadx/gui/settings/data/ProjectData.java
Patch:
@@ -4,13 +4,14 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 
 import jadx.api.data.impl.JadxCodeData;
 
 public class ProjectData {
 
 	private int projectVersion = 1;
-	private List<Path> files;
+	private List<Path> files = new ArrayList<>();
 	private List<String[]> treeExpansions = new ArrayList<>();
 	private JadxCodeData codeData = new JadxCodeData();
 	private List<TabViewState> openTabs = Collections.emptyList();
@@ -21,7 +22,7 @@ public List<Path> getFiles() {
 	}
 
 	public void setFiles(List<Path> files) {
-		this.files = files;
+		this.files = Objects.requireNonNull(files);
 	}
 
 	public List<String[]> getTreeExpansions() {

File: jadx-core/src/main/java/jadx/core/utils/ListUtils.java
Patch:
@@ -112,7 +112,7 @@ public static <T> List<T> safeAdd(List<T> list, T obj) {
 		return list;
 	}
 
-	public static <T> List<T> filter(List<T> list, Predicate<T> filter) {
+	public static <T> List<T> filter(Collection<T> list, Predicate<T> filter) {
 		if (list == null || list.isEmpty()) {
 			return Collections.emptyList();
 		}
@@ -148,7 +148,7 @@ public static <T> T filterOnlyOne(List<T> list, Predicate<T> filter) {
 		return found;
 	}
 
-	public static <T> boolean allMatch(List<T> list, Predicate<T> test) {
+	public static <T> boolean allMatch(Collection<T> list, Predicate<T> test) {
 		if (list == null || list.isEmpty()) {
 			return false;
 		}
@@ -160,7 +160,7 @@ public static <T> boolean allMatch(List<T> list, Predicate<T> test) {
 		return true;
 	}
 
-	public static <T> boolean anyMatch(List<T> list, Predicate<T> test) {
+	public static <T> boolean anyMatch(Collection<T> list, Predicate<T> test) {
 		if (list == null || list.isEmpty()) {
 			return false;
 		}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -62,6 +62,7 @@
 import jadx.core.dex.visitors.rename.RenameVisitor;
 import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;
 import jadx.core.dex.visitors.ssa.SSATransform;
+import jadx.core.dex.visitors.typeinference.FinishTypeInference;
 import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
 import jadx.core.dex.visitors.usage.UsageInfoVisitor;
 import jadx.core.utils.exceptions.JadxRuntimeException;
@@ -130,6 +131,7 @@ public static List<IDexTreeVisitor> getRegionsModePasses(JadxArgs args) {
 		if (args.isDebugInfo()) {
 			passes.add(new DebugInfoApplyVisitor());
 		}
+		passes.add(new FinishTypeInference());
 		if (args.getUseKotlinMethodsForVarNames() != JadxArgs.UseKotlinMethodsForVarNames.DISABLE) {
 			passes.add(new ProcessKotlinInternals());
 		}
@@ -204,6 +206,7 @@ public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {
 		if (args.isDebugInfo()) {
 			passes.add(new DebugInfoApplyVisitor());
 		}
+		passes.add(new FinishTypeInference());
 		passes.add(new CodeRenameVisitor());
 		passes.add(new DeboxingVisitor());
 		passes.add(new ModVisitor());

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -21,6 +21,7 @@
 import jadx.core.dex.attributes.nodes.MethodBridgeAttr;
 import jadx.core.dex.attributes.nodes.MethodInlineAttr;
 import jadx.core.dex.attributes.nodes.MethodOverrideAttr;
+import jadx.core.dex.attributes.nodes.MethodReplaceAttr;
 import jadx.core.dex.attributes.nodes.MethodTypeVarsAttr;
 import jadx.core.dex.attributes.nodes.PhiListAttr;
 import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
@@ -65,11 +66,12 @@ public final class AType<T extends IJadxAttribute> implements IJadxAttrType<T> {
 	// method
 	public static final AType<LocalVarsDebugInfoAttr> LOCAL_VARS_DEBUG_INFO = new AType<>();
 	public static final AType<MethodInlineAttr> METHOD_INLINE = new AType<>();
+	public static final AType<MethodReplaceAttr> METHOD_REPLACE = new AType<>();
+	public static final AType<MethodBridgeAttr> BRIDGED_BY = new AType<>();
 	public static final AType<SkipMethodArgsAttr> SKIP_MTH_ARGS = new AType<>();
 	public static final AType<MethodOverrideAttr> METHOD_OVERRIDE = new AType<>();
 	public static final AType<MethodTypeVarsAttr> METHOD_TYPE_VARS = new AType<>();
 	public static final AType<AttrList<TryCatchBlockAttr>> TRY_BLOCKS_LIST = new AType<>();
-	public static final AType<MethodBridgeAttr> BRIDGED_BY = new AType<>();
 
 	// region
 	public static final AType<DeclareVariablesAttr> DECLARE_VARIABLES = new AType<>();

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Assumptions;
@@ -219,7 +220,7 @@ public List<ClassNode> decompileFiles(List<File> files) {
 		return sortedClsNodes;
 	}
 
-	@Nullable
+	@NotNull
 	public ClassNode searchCls(List<ClassNode> list, String clsName) {
 		for (ClassNode cls : list) {
 			if (cls.getClassInfo().getFullName().equals(clsName)) {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java
Patch:
@@ -103,6 +103,9 @@ public String getSyntaxName() {
 
 	@Override
 	public boolean canRename() {
+		if (mth.isClassInit()) {
+			return false;
+		}
 		return !mth.getMethodNode().contains(AFlag.DONT_RENAME);
 	}
 

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -66,7 +66,7 @@ public class JadxCLIArgs {
 					+ "\n 'restructure' - restore code structure (normal java code)"
 					+ "\n 'simple' - simplified instructions (linear, with goto's)"
 					+ "\n 'fallback' - raw instructions without modifications",
-			converter = RenameConverter.class
+			converter = DecompilationModeConverter.class
 	)
 	protected DecompilationMode decompilationMode = DecompilationMode.AUTO;
 

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -132,7 +132,7 @@ private void fillDeobfPresets() {
 			for (MethodNode mth : cls.getMethods()) {
 				MethodInfo methodInfo = mth.getMethodInfo();
 				if (methodInfo.hasAlias()) {
-					deobfPresets.getFldPresetMap().put(methodInfo.getRawFullId(), methodInfo.getAlias());
+					deobfPresets.getMthPresetMap().put(methodInfo.getRawFullId(), methodInfo.getAlias());
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -11,6 +11,7 @@
 import jadx.core.dex.attributes.nodes.FieldReplaceAttr;
 import jadx.core.dex.attributes.nodes.ForceReturnAttr;
 import jadx.core.dex.attributes.nodes.GenericInfoAttr;
+import jadx.core.dex.attributes.nodes.InlinedAttr;
 import jadx.core.dex.attributes.nodes.JadxCommentsAttr;
 import jadx.core.dex.attributes.nodes.JadxError;
 import jadx.core.dex.attributes.nodes.JumpInfo;
@@ -55,6 +56,7 @@ public final class AType<T extends IJadxAttribute> implements IJadxAttrType<T> {
 	public static final AType<EnumMapAttr> ENUM_MAP = new AType<>();
 	public static final AType<ClassTypeVarsAttr> CLASS_TYPE_VARS = new AType<>();
 	public static final AType<AnonymousClassAttr> ANONYMOUS_CLASS = new AType<>();
+	public static final AType<InlinedAttr> INLINED = new AType<>();
 
 	// field
 	public static final AType<FieldInitInsnAttr> FIELD_INIT_INSN = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -36,6 +36,7 @@
 import jadx.core.ProcessClass;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
+import jadx.core.dex.attributes.nodes.InlinedAttr;
 import jadx.core.dex.attributes.nodes.NotificationAttrNode;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.info.AccessInfo.AFType;
@@ -633,6 +634,7 @@ public void addInlinedClass(ClassNode cls) {
 		if (inlinedClasses.isEmpty()) {
 			inlinedClasses = new ArrayList<>(5);
 		}
+		cls.addAttr(new InlinedAttr(this));
 		inlinedClasses.add(cls);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java
Patch:
@@ -73,6 +73,7 @@ private static void markAnonymousClass(ClassNode cls) {
 			return;
 		}
 		ClassNode outerCls = anonymousConstructor.getUseIn().get(0).getParentClass();
+		outerCls.addInlinedClass(cls);
 		cls.addAttr(new AnonymousClassAttr(outerCls, baseType));
 		cls.add(AFlag.DONT_GENERATE);
 		anonymousConstructor.add(AFlag.ANONYMOUS_CONSTRUCTOR);

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -123,10 +123,10 @@ private void initUI() {
 		leftPanel.add(makeAppearanceGroup());
 		leftPanel.add(makeOtherGroup());
 		leftPanel.add(makeSearchResGroup());
-		leftPanel.add(makePluginOptionsGroup());
 		leftPanel.add(Box.createVerticalGlue());
 
 		rightPanel.add(makeDecompilationGroup());
+		rightPanel.add(makePluginOptionsGroup());
 		rightPanel.add(Box.createVerticalGlue());
 
 		JButton saveBtn = new JButton(NLS.str("preferences.save"));

File: jadx-gui/src/main/java/jadx/gui/ui/panel/IDebugController.java
Patch:
@@ -4,7 +4,7 @@
 import jadx.gui.ui.panel.JDebuggerPanel.ValueTreeNode;
 
 public interface IDebugController {
-	boolean startDebugger(JDebuggerPanel panel, String[] args);
+	boolean startDebugger(JDebuggerPanel debuggerPanel, String adbHost, int adbPort, int androidVer);
 
 	boolean run();
 

File: jadx-gui/src/main/java/jadx/gui/ui/panel/JDebuggerPanel.java
Patch:
@@ -373,8 +373,8 @@ private void stackFrameSelected(Point p) {
 		}
 	}
 
-	public boolean showDebugger(String procName, String host, int port, String androidVer) {
-		boolean ok = controller.startDebugger(this, new String[] { host, String.valueOf(port), androidVer });
+	public boolean showDebugger(String procName, String host, int port, int androidVer) {
+		boolean ok = controller.startDebugger(this, host, port, androidVer);
 		if (ok) {
 			log(String.format("Attached %s %s:%d", procName, host, port));
 			leftSplitter.setDividerLocation(mainWindow.getSettings().getDebuggerStackFrameSplitterLoc());

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java
Patch:
@@ -101,6 +101,9 @@ public boolean unload(String pluginId) {
 	}
 
 	public List<JadxPlugin> getAllPlugins() {
+		if (allPlugins.isEmpty()) {
+			load();
+		}
 		return allPlugins.stream().map(PluginData::getPlugin).collect(Collectors.toList());
 	}
 

File: jadx-gui/src/main/java/jadx/gui/JadxGUI.java
Patch:
@@ -8,6 +8,7 @@
 import jadx.cli.LogHelper;
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.settings.JadxSettingsAdapter;
+import jadx.gui.ui.ExceptionDialog;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.LafManager;
 import jadx.gui.utils.NLS;
@@ -29,7 +30,7 @@ public static void main(String[] args) {
 			printSystemInfo();
 			LafManager.init(settings);
 			NLS.setLocale(settings.getLangLocale());
-
+			ExceptionDialog.registerUncaughtExceptionHandler();
 			SwingUtilities.invokeLater(new MainWindow(settings)::init);
 		} catch (Exception e) {
 			LOG.error("Error: {}", e.getMessage(), e);

File: jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java
Patch:
@@ -178,7 +178,7 @@ public void save() {
 				buildGson(basePath).toJson(data, writer);
 				saved = true;
 			} catch (Exception e) {
-				LOG.error("Error saving project", e);
+				throw new RuntimeException("Error saving project", e);
 			}
 		}
 	}

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java
Patch:
@@ -38,6 +38,7 @@ public void providesSuggestion(String provides, String pluginId) {
 	}
 
 	public void load() {
+		allPlugins.clear();
 		ServiceLoader<JadxPlugin> jadxPlugins = ServiceLoader.load(JadxPlugin.class);
 		for (JadxPlugin plugin : jadxPlugins) {
 			addPlugin(plugin);

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -34,11 +34,11 @@ private static ICodeInfo process(ClassNode cls, boolean codegen) {
 				if (cls.contains(AFlag.CLASS_DEEP_RELOAD)) {
 					cls.remove(AFlag.CLASS_DEEP_RELOAD);
 					cls.deepUnload();
-					cls.root().runPreDecompileStageForClass(cls);
+					cls.add(AFlag.CLASS_UNLOADED);
 				}
 				if (cls.contains(AFlag.CLASS_UNLOADED)) {
-					cls.remove(AFlag.CLASS_UNLOADED);
 					cls.root().runPreDecompileStageForClass(cls);
+					cls.remove(AFlag.CLASS_UNLOADED);
 				}
 				if (cls.getState() == GENERATED_AND_UNLOADED) {
 					// force loading code again

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -285,7 +285,7 @@ private void addInnerClass(ICodeWriter code, ClassNode innerCls) {
 
 	private boolean isInnerClassesPresents() {
 		for (ClassNode innerCls : cls.getInnerClasses()) {
-			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {
+			if (!innerCls.contains(AType.ANONYMOUS_CLASS)) {
 				return true;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -719,13 +719,13 @@ private void makeConstructor(ConstructorInsn insn, ICodeWriter code) throws Code
 
 	private void inlineAnonymousConstructor(ICodeWriter code, ClassNode cls, ConstructorInsn insn) throws CodegenException {
 		if (this.mth.getParentClass() == cls) {
-			cls.remove(AFlag.ANONYMOUS_CLASS);
+			cls.remove(AType.ANONYMOUS_CLASS);
 			cls.remove(AFlag.DONT_GENERATE);
 			mth.getParentClass().getTopParentClass().add(AFlag.RESTART_CODEGEN);
 			throw new CodegenException("Anonymous inner class unlimited recursion detected."
 					+ " Convert class to inner: " + cls.getClassInfo().getFullName());
 		}
-		ArgType parent = cls.get(AType.ANONYMOUS_CLASS_BASE).getBaseType();
+		ArgType parent = cls.get(AType.ANONYMOUS_CLASS).getBaseType();
 		// hide empty anonymous constructors
 		for (MethodNode ctor : cls.getMethods()) {
 			if (ctor.contains(AFlag.ANONYMOUS_CONSTRUCTOR)

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -35,7 +35,6 @@ public enum AFlag {
 	SKIP_ARG, // skip argument in invoke call
 	NO_SKIP_ARGS,
 	ANONYMOUS_CONSTRUCTOR,
-	ANONYMOUS_CLASS,
 
 	THIS,
 	SUPER,

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -2,7 +2,7 @@
 
 import jadx.api.plugins.input.data.attributes.IJadxAttrType;
 import jadx.api.plugins.input.data.attributes.IJadxAttribute;
-import jadx.core.dex.attributes.nodes.AnonymousClassBaseAttr;
+import jadx.core.dex.attributes.nodes.AnonymousClassAttr;
 import jadx.core.dex.attributes.nodes.ClassTypeVarsAttr;
 import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;
 import jadx.core.dex.attributes.nodes.EdgeInsnAttr;
@@ -54,7 +54,7 @@ public final class AType<T extends IJadxAttribute> implements IJadxAttrType<T> {
 	public static final AType<EnumClassAttr> ENUM_CLASS = new AType<>();
 	public static final AType<EnumMapAttr> ENUM_MAP = new AType<>();
 	public static final AType<ClassTypeVarsAttr> CLASS_TYPE_VARS = new AType<>();
-	public static final AType<AnonymousClassBaseAttr> ANONYMOUS_CLASS_BASE = new AType<>();
+	public static final AType<AnonymousClassAttr> ANONYMOUS_CLASS = new AType<>();
 
 	// field
 	public static final AType<FieldInitInsnAttr> FIELD_INIT_INSN = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/AnonymousClassVisitor.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.Map;
 
 import jadx.core.dex.attributes.AFlag;
+import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.nodes.FieldReplaceAttr;
 import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;
 import jadx.core.dex.info.FieldInfo;
@@ -36,7 +37,7 @@ public class AnonymousClassVisitor extends AbstractVisitor {
 
 	@Override
 	public boolean visit(ClassNode cls) throws JadxException {
-		if (cls.contains(AFlag.ANONYMOUS_CLASS)) {
+		if (cls.contains(AType.ANONYMOUS_CLASS)) {
 			for (MethodNode mth : cls.getMethods()) {
 				if (mth.contains(AFlag.ANONYMOUS_CONSTRUCTOR)) {
 					processAnonymousConstructor(mth);

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -15,6 +15,7 @@
 import jadx.core.codegen.TypeGen;
 import jadx.core.deobf.NameMapper;
 import jadx.core.dex.attributes.AFlag;
+import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.nodes.EnumClassAttr;
 import jadx.core.dex.attributes.nodes.EnumClassAttr.EnumField;
 import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;
@@ -389,7 +390,7 @@ private EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFiel
 		}
 		if (constrCls.equals(cls)) {
 			// allow same class
-		} else if (constrCls.contains(AFlag.ANONYMOUS_CLASS)) {
+		} else if (constrCls.contains(AType.ANONYMOUS_CLASS)) {
 			// allow external class already marked as anonymous
 		} else {
 			return null;

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -19,7 +19,7 @@
 import jadx.core.clsp.ClspGraph;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
-import jadx.core.dex.attributes.nodes.AnonymousClassBaseAttr;
+import jadx.core.dex.attributes.nodes.AnonymousClassAttr;
 import jadx.core.dex.attributes.nodes.PhiListAttr;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.instructions.ArithNode;
@@ -321,7 +321,7 @@ private ArgType replaceAnonymousType(ConstructorInsn ctr) {
 		if (ctr.isNewInstance()) {
 			ClassNode ctrCls = root.resolveClass(ctr.getClassType());
 			if (ctrCls != null && ctrCls.contains(AFlag.DONT_GENERATE)) {
-				AnonymousClassBaseAttr baseTypeAttr = ctrCls.get(AType.ANONYMOUS_CLASS_BASE);
+				AnonymousClassAttr baseTypeAttr = ctrCls.get(AType.ANONYMOUS_CLASS);
 				if (baseTypeAttr != null) {
 					return baseTypeAttr.getBaseType();
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -457,7 +457,7 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 		}
 		SkipMethodArgsAttr attr = callMth.get(AType.SKIP_MTH_ARGS);
 		if (attr != null) {
-			int argsCount = Math.min(callMth.getArgRegs().size(), co.getArgsCount());
+			int argsCount = Math.min(callMth.getMethodInfo().getArgsCount(), co.getArgsCount());
 			for (int i = 0; i < argsCount; i++) {
 				if (attr.isSkip(i)) {
 					anonymousCallArgMod(co.getArg(i));

File: jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java
Patch:
@@ -55,7 +55,7 @@ private static void initTryCatches(MethodNode mth, InsnNode[] insnByOffset, List
 			if (handlers.isEmpty()) {
 				continue;
 			}
-			markTryBounds(insnByOffset, tryData, new CatchAttr(handlers));
+			markTryBounds(insnByOffset, tryData, CatchAttr.build(handlers));
 		}
 	}
 
@@ -96,7 +96,7 @@ private static void attachCatchAttr(CatchAttr catchAttr, InsnNode insn) {
 		if (existAttr != null) {
 			// merge handlers
 			List<ExceptionHandler> handlers = Utils.concat(existAttr.getHandlers(), catchAttr.getHandlers());
-			insn.addAttr(new CatchAttr(handlers));
+			insn.addAttr(CatchAttr.build(handlers));
 		} else {
 			insn.addAttr(catchAttr);
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java
Patch:
@@ -126,7 +126,7 @@ private static CatchAttr getCommonCatchAttr(BlockNode block) {
 					commonCatchAttr = catchAttr;
 					continue;
 				}
-				if (commonCatchAttr != catchAttr) {
+				if (!commonCatchAttr.equals(catchAttr)) {
 					return null;
 				}
 			}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -105,6 +105,7 @@ private void addMenuItems() {
 		popup.add(new CommentSearchAction(this));
 		popup.add(rename);
 		popup.addPopupMenuListener(findUsage);
+		popup.addPopupMenuListener(frida);
 		popup.addPopupMenuListener(goToDeclaration);
 		popup.addPopupMenuListener(comment);
 		popup.addPopupMenuListener(rename);

File: jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java
Patch:
@@ -120,7 +120,7 @@ public int hashCode() {
 	}
 
 	public static final Comparator<CodeNode> COMPARATOR = Comparator
-			.comparing(CodeNode::getJParent)
+			.comparing(CodeNode::makeLongString)
 			.thenComparingInt(CodeNode::getPos);
 
 	@Override

File: jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java
Patch:
@@ -110,7 +110,8 @@ private ApplicationParams getApplicationParams(Document androidManifest, Documen
 		Integer versionCode = Integer.valueOf(manifest.getAttribute("android:versionCode"));
 		String versionName = manifest.getAttribute("android:versionName");
 		Integer minSdk = Integer.valueOf(usesSdk.getAttribute("android:minSdkVersion"));
-		Integer targetSdk = Integer.valueOf(usesSdk.getAttribute("android:targetSdkVersion"));
+		String stringTargetSdk = usesSdk.getAttribute("android:targetSdkVersion");
+		Integer targetSdk = stringTargetSdk.isEmpty() ? minSdk : Integer.valueOf(stringTargetSdk);
 		String appName = "UNKNOWN";
 
 		if (application.hasAttribute("android:label")) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -25,6 +25,7 @@
 import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
 import jadx.core.dex.attributes.nodes.RenameReasonAttr;
 import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;
+import jadx.core.dex.attributes.nodes.SpecialEdgeAttr;
 import jadx.core.dex.attributes.nodes.TmpEdgeAttr;
 import jadx.core.dex.nodes.IMethodDetails;
 import jadx.core.dex.trycatch.CatchAttr;
@@ -76,6 +77,7 @@ public final class AType<T extends IJadxAttribute> implements IJadxAttrType<T> {
 	public static final AType<ForceReturnAttr> FORCE_RETURN = new AType<>();
 	public static final AType<AttrList<LoopInfo>> LOOP = new AType<>();
 	public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<>();
+	public static final AType<AttrList<SpecialEdgeAttr>> SPECIAL_EDGE = new AType<>();
 	public static final AType<TmpEdgeAttr> TMP_EDGE = new AType<>();
 	public static final AType<TryCatchBlockAttr> TRY_BLOCK = new AType<>();
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LoopInfo.java
Patch:
@@ -1,7 +1,6 @@
 package jadx.core.dex.attributes.nodes;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -20,10 +19,10 @@ public class LoopInfo {
 	private int id;
 	private LoopInfo parentLoop;
 
-	public LoopInfo(BlockNode start, BlockNode end) {
+	public LoopInfo(BlockNode start, BlockNode end, Set<BlockNode> loopBlocks) {
 		this.start = start;
 		this.end = end;
-		this.loopBlocks = Collections.unmodifiableSet(BlockUtils.getAllPathsBlocks(start, end));
+		this.loopBlocks = loopBlocks;
 	}
 
 	public BlockNode getStart() {

File: jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java
Patch:
@@ -10,6 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.api.CommentsLevel;
 import jadx.api.ICodeWriter;
 import jadx.api.JadxArgs;
 import jadx.api.JadxDecompiler;
@@ -42,6 +43,7 @@ protected JadxArgs prepare(File input) {
 		args.setSkipFilesSave(true);
 		args.setSkipResources(true);
 		args.setShowInconsistentCode(true);
+		args.setCommentsLevel(CommentsLevel.DEBUG);
 		return args;
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java
Patch:
@@ -28,7 +28,8 @@ public void test() {
 		prepareArgs(true);
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.containsOne("class TestMetaData {");
+				.containsOne("class TestMetaData {")
+				.containsOne("reason: from Kotlin metadata");
 	}
 
 	@Test
@@ -42,6 +43,7 @@ public void testIgnoreMetadata() {
 	private void prepareArgs(boolean parseKotlinMetadata) {
 		enableDeobfuscation();
 		args.setDeobfuscationMinLength(100); // rename everything
+		args.setDeobfuscationForceSave(true);
 		getArgs().setParseKotlinMetadata(parseKotlinMetadata);
 		disableCompilation();
 	}

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -126,8 +126,9 @@ private static ResContainer decodeImage(ResourceFile rf, InputStream inputStream
 		if (name.endsWith(".9.png")) {
 			try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
 				Res9patchStreamDecoder decoder = new Res9patchStreamDecoder();
-				decoder.decode(inputStream, os);
-				return ResContainer.decodedData(rf.getDeobfName(), os.toByteArray());
+				if (decoder.decode(inputStream, os)) {
+					return ResContainer.decodedData(rf.getDeobfName(), os.toByteArray());
+				}
 			} catch (Exception e) {
 				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);
 			}

File: jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java
Patch:
@@ -203,7 +203,7 @@ private void filter(JResource resNode, ZipFile zip) {
 					resNodes.add(resNode);
 				}
 			} else {
-				LOG.debug("Resource skipped because of size limit: {} res size {} bytes", resNode, size);
+				LOG.debug("Resource index skipped because of size limit: {} res size {} bytes", resNode, size);
 			}
 		}
 	}

File: jadx-cli/src/main/java/jadx/cli/LogHelper.java
Patch:
@@ -54,7 +54,7 @@ public static void applyLogLevel(LogLevelEnum logLevel) {
 		Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
 		rootLogger.setLevel(logLevel.getLevel());
 
-		if (logLevel != LogLevelEnum.QUIET) {
+		if (logLevel == LogLevelEnum.PROGRESS) {
 			// show progress for all levels except quiet
 			setLevelForClass(JadxCLI.class, Level.INFO);
 			setLevelForClass(JadxDecompiler.class, Level.INFO);

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -128,6 +128,7 @@ private void loadInputFiles() {
 				loadedInputs.add(loadResult);
 			}
 		}
+		LOG.debug("Loaded using {} inputs plugin", loadedInputs.size());
 	}
 
 	private void reset() {

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java
Patch:
@@ -39,6 +39,7 @@ public void load() {
 		ServiceLoader<JadxPlugin> jadxPlugins = ServiceLoader.load(JadxPlugin.class);
 		for (JadxPlugin plugin : jadxPlugins) {
 			addPlugin(plugin);
+			LOG.debug("Loading plugin: {}", plugin.getPluginInfo().getPluginId());
 		}
 		resolve();
 	}

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -459,7 +459,7 @@ private void addEnumFields(ICodeWriter code) throws CodegenException {
 			}
 			if (f.getCls() != null) {
 				code.add(' ');
-				new ClassGen(f.getCls(), this).addClassBody(code);
+				new ClassGen(f.getCls(), this).addClassBody(code, true);
 			}
 			if (it.hasNext()) {
 				code.add(',');

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java
Patch:
@@ -382,6 +382,9 @@ private static IfInfo getNextIfNodeInfo(IfInfo info, BlockNode block) {
 				}
 				if (useCount > 1) {
 					forceInlineInsns.add(insn);
+				} else {
+					// allow only forced assign inline
+					pass = false;
 				}
 			}
 		}

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass10.java
Patch:
@@ -19,8 +19,7 @@ public static class TestCls {
 		public A test() {
 			Random random = new Random();
 			int a2 = random.nextInt();
-			int a3 = a2 + 3;
-			return new A(this, a2, a3, 4, 5, random.nextDouble()) {
+			return new A(this, a2, a2 + 3, 4, 5, random.nextDouble()) {
 				@Override
 				public void m() {
 					System.out.println(1);

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops2.java
Patch:
@@ -32,6 +32,6 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("for (int i = 0; i < list.size(); i++) {"));
-		assertThat(code, containsOne("while (j < list.get(i).length()) {"));
+		assertThat(code, containsOne("while (j < s.length()) {"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSequentialLoops2.java
Patch:
@@ -12,6 +12,7 @@
 
 public class TestSequentialLoops2 extends IntegrationTest {
 
+	@SuppressWarnings({ "unused", "FieldMayBeFinal" })
 	public static class TestCls {
 		private static char[] lowercases = new char[] { 'a' };
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java
Patch:
@@ -55,7 +55,6 @@ public void test() {
 	}
 
 	@Test
-	@NotYetImplemented
 	public void test2() {
 		disableCompilation();
 		ClassNode cls = getClassNode(TestCls.class);

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -172,7 +172,7 @@ private String lit(LiteralArg arg) {
 
 	private void instanceField(ICodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {
 		ClassNode pCls = mth.getParentClass();
-		FieldNode fieldNode = pCls.root().deepResolveField(field);
+		FieldNode fieldNode = pCls.root().resolveField(field);
 		if (fieldNode != null) {
 			FieldReplaceAttr replace = fieldNode.get(AType.FIELD_REPLACE);
 			if (replace != null) {
@@ -210,7 +210,7 @@ public static void makeStaticFieldAccess(ICodeWriter code, FieldInfo field, Clas
 			}
 			code.add('.');
 		}
-		FieldNode fieldNode = clsGen.getClassNode().root().deepResolveField(field);
+		FieldNode fieldNode = clsGen.getClassNode().root().resolveField(field);
 		if (fieldNode != null) {
 			code.attachAnnotation(fieldNode);
 		}
@@ -764,7 +764,7 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti
 			return;
 		}
 		MethodInfo callMth = insn.getCallMth();
-		MethodNode callMthNode = mth.root().deepResolveMethod(callMth);
+		MethodNode callMthNode = mth.root().resolveMethod(callMth);
 
 		int k = 0;
 		switch (type) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java
Patch:
@@ -38,7 +38,7 @@ public IMethodDetails getMethodDetails(BaseInvokeNode invokeNode) {
 
 	@Nullable
 	public IMethodDetails getMethodDetails(MethodInfo callMth) {
-		MethodNode mthNode = root.deepResolveMethod(callMth);
+		MethodNode mthNode = root.resolveMethod(callMth);
 		if (mthNode != null) {
 			return mthNode;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -244,7 +244,7 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {
 			return false;
 		}
 		MethodInfo callMth = invokeInsn.getCallMth();
-		MethodNode wrappedMth = mth.root().deepResolveMethod(callMth);
+		MethodNode wrappedMth = mth.root().resolveMethod(callMth);
 		if (wrappedMth == null) {
 			return false;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java
Patch:
@@ -106,7 +106,7 @@ private static boolean fixVisibilityOfInlineCode(MethodNode mth, InsnNode insn)
 		InsnType insnType = insn.getType();
 		if (insnType == InsnType.INVOKE) {
 			InvokeNode invoke = (InvokeNode) insn;
-			MethodNode callMthNode = mth.root().deepResolveMethod(invoke.getCallMth());
+			MethodNode callMthNode = mth.root().resolveMethod(invoke.getCallMth());
 			if (callMthNode != null) {
 				FixAccessModifiers.changeVisibility(callMthNode, newVisFlag);
 			}

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -96,7 +96,7 @@ public static Object getConstValueByInsn(RootNode root, InsnNode insn) {
 				return ((ConstClassNode) insn).getClsType();
 			case SGET:
 				FieldInfo f = (FieldInfo) ((IndexInsnNode) insn).getIndex();
-				FieldNode fieldNode = root.deepResolveField(f);
+				FieldNode fieldNode = root.resolveField(f);
 				if (fieldNode == null) {
 					LOG.warn("Field {} not found", f);
 					return null;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -94,10 +94,12 @@ private void addMenuItems() {
 		GoToDeclarationAction goToDeclaration = new GoToDeclarationAction(this);
 		RenameAction rename = new RenameAction(this);
 		CommentAction comment = new CommentAction(this);
+		FridaAction frida = new FridaAction(this);
 
 		JPopupMenu popup = getPopupMenu();
 		popup.addSeparator();
 		popup.add(findUsage);
+		popup.add(frida);
 		popup.add(goToDeclaration);
 		popup.add(comment);
 		popup.add(new CommentSearchAction(this));

File: jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java
Patch:
@@ -176,6 +176,9 @@ private FieldNode getResourceField(Integer value, RootNode root) {
 
 	@Nullable
 	public FieldNode getConstFieldByLiteralArg(ClassNode cls, LiteralArg arg) {
+		if (!replaceEnabled) {
+			return null;
+		}
 		PrimitiveType type = arg.getType().getPrimitiveType();
 		if (type == null) {
 			return null;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java
Patch:
@@ -164,7 +164,9 @@ private static InsnArg replaceConstInArg(MethodNode mth, InsnArg valueArg) {
 			FieldNode f = mth.getParentClass().getConstFieldByLiteralArg((LiteralArg) valueArg);
 			if (f != null) {
 				InsnNode fGet = new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0);
-				return InsnArg.wrapArg(fGet);
+				InsnArg arg = InsnArg.wrapArg(fGet);
+				f.addUseIn(mth);
+				return arg;
 			}
 		}
 		return valueArg.duplicate();

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -238,10 +238,11 @@ private void addMethodArguments(ICodeWriter code, List<RegisterArg> args) {
 				classGen.useType(code, argType);
 			}
 			code.add(' ');
-			if (code.isMetadataSupported() && ssaVar != null) {
+			String varName = nameGen.assignArg(var);
+			if (code.isMetadataSupported() && ssaVar != null /* for fallback mode */) {
 				code.attachDefinition(VarDeclareRef.get(mth, var));
 			}
-			code.add(nameGen.assignArg(var));
+			code.add(varName);
 
 			i++;
 			if (it.hasNext()) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -99,9 +99,6 @@ private MethodNode(ClassNode classNode, IMethodData mthData) {
 	@Override
 	public void unload() {
 		loaded = false;
-		if (noCode) {
-			return;
-		}
 		// don't unload retType, argTypes, typeParameters
 		thisArg = null;
 		argsList = null;

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -246,13 +246,13 @@ public boolean isInner() {
 	}
 
 	public void notInner(RootNode root) {
-		this.parentClass = null;
 		splitAndApplyNames(root, type, false);
+		this.parentClass = null;
 	}
 
 	public void convertToInner(ClassNode parent) {
-		this.parentClass = parent.getClassInfo();
 		splitAndApplyNames(parent.root(), type, true);
+		this.parentClass = parent.getClassInfo();
 	}
 
 	public void updateNames(RootNode root) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedList;
 import java.util.List;
 
 import org.jetbrains.annotations.Nullable;
@@ -197,6 +196,8 @@ private ArgType consumeObjectType(boolean innerType) {
 		String obj = slice();
 		if (!innerType) {
 			obj += ';';
+		} else {
+			obj = obj.replace('/', '.');
 		}
 		List<ArgType> typeVars = consumeGenericArgs();
 		consume('>');
@@ -227,7 +228,7 @@ private ArgType consumeObjectType(boolean innerType) {
 	}
 
 	private List<ArgType> consumeGenericArgs() {
-		List<ArgType> list = new LinkedList<>();
+		List<ArgType> list = new ArrayList<>();
 		ArgType type;
 		do {
 			if (lookAhead('*')) {

File: jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java
Patch:
@@ -8,7 +8,6 @@
 import java.util.Set;
 
 import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -24,6 +23,7 @@
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
 import jadx.core.xmlgen.ResContainer;
+import jadx.core.xmlgen.XmlSecurity;
 
 public class ExportGradleProject {
 
@@ -139,7 +139,7 @@ private ApplicationParams getApplicationParams(Document androidManifest, Documen
 
 	private Document parseXml(String xmlContent) {
 		try {
-			DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+			DocumentBuilder builder = XmlSecurity.getSecureDbf().newDocumentBuilder();
 			Document document = builder.parse(new InputSource(new StringReader(xmlContent)));
 
 			document.getDocumentElement().normalize();

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -180,7 +180,7 @@ private void addOverrideAnnotation(ICodeWriter code, MethodNode mth) {
 		if (overrideAttr == null) {
 			return;
 		}
-		if (!overrideAttr.isAtBaseMth()) {
+		if (!overrideAttr.getBaseMethods().contains(mth)) {
 			code.startLine("@Override");
 			if (mth.checkCommentsLevel(CommentsLevel.INFO)) {
 				code.add(" // ");

File: jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java
Patch:
@@ -18,6 +18,7 @@
 import jadx.core.dex.nodes.IMethodDetails;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.RootNode;
+import jadx.core.utils.Utils;
 
 public class MethodUtils {
 	private final RootNode root;
@@ -132,7 +133,7 @@ public IMethodDetails getOverrideBaseMth(MethodNode mth) {
 		if (overrideAttr == null) {
 			return null;
 		}
-		return overrideAttr.getBaseMth();
+		return Utils.getOne(overrideAttr.getBaseMethods());
 	}
 
 	public ClassInfo getMethodOriginDeclClass(MethodNode mth) {

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -38,6 +38,7 @@
 import jadx.core.dex.visitors.PrepareForCodeGen;
 import jadx.core.dex.visitors.ProcessAnonymous;
 import jadx.core.dex.visitors.ProcessInstructionsVisitor;
+import jadx.core.dex.visitors.ProcessMethodsForInline;
 import jadx.core.dex.visitors.ReSugarCode;
 import jadx.core.dex.visitors.ShadowFieldVisitor;
 import jadx.core.dex.visitors.SignatureProcessor;
@@ -89,6 +90,7 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {
 		passes.add(new RenameVisitor());
 		passes.add(new UsageInfoVisitor());
 		passes.add(new ProcessAnonymous());
+		passes.add(new ProcessMethodsForInline());
 		return passes;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -79,6 +79,8 @@ public enum AFlag {
 	REQUEST_IF_REGION_OPTIMIZE, // run if region visitor again
 	RERUN_SSA_TRANSFORM,
 
+	METHOD_CANDIDATE_FOR_INLINE,
+
 	// Class processing flags
 	RESTART_CODEGEN, // codegen must be executed again
 	RELOAD_AT_CODEGEN_STAGE, // class can't be analyzed at 'process' stage => unload before 'codegen' stage

File: jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java
Patch:
@@ -86,7 +86,7 @@ private int fixClassVisibility(ClassNode cls) {
 		if (!accessFlags.isPublic()) {
 			// if class is used in inlinable method => make it public
 			for (MethodNode useMth : cls.getUseInMth()) {
-				boolean canInline = MarkMethodsForInline.canInline(useMth) || useMth.contains(AType.METHOD_INLINE);
+				boolean canInline = useMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE) || useMth.contains(AType.METHOD_INLINE);
 				if (canInline && !useMth.getUseIn().isEmpty()) {
 					return AccessFlags.PUBLIC;
 				}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -655,7 +655,7 @@ public static boolean isCastNeeded(RootNode root, ArgType from, ArgType to) {
 		if (from.equals(to)) {
 			return false;
 		}
-		TypeCompareEnum result = root.getTypeUpdate().getTypeCompare().compareTypes(from, to);
+		TypeCompareEnum result = root.getTypeCompare().compareTypes(from, to);
 		return !result.isNarrow();
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java
Patch:
@@ -31,6 +31,6 @@ public void test() {
 
 		assertThat(code, containsOne("int[] a = {1, 2, 4, 6, 8};"));
 		assertThat(code, containsOne("for (int i = 0; i < a.length; i += 2) {"));
-		assertThat(code, containsOne("for (long i2 = (long) b; i2 > 0; i2--) {"));
+		assertThat(code, containsOne("for (long i2 = b; i2 > 0; i2--) {"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToByte.java
Patch:
@@ -24,6 +24,6 @@ public void writeToParcel(TestBooleanToByte testBooleanToByte) {
 	public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.containsOne("write(this.showConsent ? (byte) 1 : 0);");
+				.containsOne("write(this.showConsent ? (byte) 1 : (byte) 0);");
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToChar.java
Patch:
@@ -24,6 +24,6 @@ public void writeToParcel(TestBooleanToChar testBooleanToChar) {
 	public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.containsOne("write(this.showConsent ? (char) 1 : 0);");
+				.containsOne("write(this.showConsent ? (char) 1 : (char) 0);");
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToLong.java
Patch:
@@ -24,6 +24,6 @@ public void writeToParcel(TestBooleanToLong testBooleanToLong) {
 	public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.containsOne("write(this.showConsent ? 1 : 0);");
+				.containsOne("write(this.showConsent ? 1L : 0L);");
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToShort.java
Patch:
@@ -24,6 +24,6 @@ public void writeToParcel(TestBooleanToShort testBooleanToShort) {
 	public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.containsOne("write(this.showConsent ? (short) 1 : 0);");
+				.containsOne("write(this.showConsent ? (short) 1 : (short) 0);");
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass2.java
Patch:
@@ -23,7 +23,7 @@ public void run() {
 		}
 
 		public void test() {
-			new Timer().schedule(new TerminateTask(), 1000);
+			new Timer().schedule(new TerminateTask(), 1000L);
 		}
 	}
 
@@ -32,7 +32,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsString("new Timer().schedule(new TerminateTask(), 1000);"));
+		assertThat(code, containsString("new Timer().schedule(new TerminateTask(), 1000L);"));
 		assertThat(code, not(containsString("synthetic")));
 		assertThat(code, not(containsString("this")));
 		assertThat(code, not(containsString("null")));

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop2.java
Patch:
@@ -13,6 +13,7 @@
 
 public class TestBreakInLoop2 extends IntegrationTest {
 
+	@SuppressWarnings({ "BusyWait", "ResultOfMethodCallIgnored" })
 	public static class TestCls {
 		public void test(List<Integer> data) throws Exception {
 			for (;;) {
@@ -25,7 +26,7 @@ public void test(List<Integer> data) throws Exception {
 					}
 					data.clear();
 				}
-				Thread.sleep(100);
+				Thread.sleep(100L);
 			}
 		}
 
@@ -47,6 +48,6 @@ public void test() {
 		assertThat(code, anyOf(containsOne("break;"), containsOne("return;")));
 		assertThat(code, containsOne("throw ex;"));
 		assertThat(code, containsOne("data.clear();"));
-		assertThat(code, containsOne("Thread.sleep(100);"));
+		assertThat(code, containsOne("Thread.sleep(100L);"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java
Patch:
@@ -26,7 +26,7 @@ int test() {
 				}
 				try {
 					f++;
-					Thread.sleep(100);
+					Thread.sleep(100L);
 				} catch (Exception e) {
 					throw new RuntimeException(e);
 				}
@@ -42,7 +42,7 @@ public void test() {
 		assertThat(code, containsOne("synchronized (this) {"));
 		assertThat(code, containsOne("try {"));
 		assertThat(code, containsOne("f++;"));
-		assertThat(code, containsOne("Thread.sleep(100);"));
+		assertThat(code, containsOne("Thread.sleep(100L);"));
 		assertThat(code, containsOne("} catch (Exception e) {"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing.java
Patch:
@@ -69,7 +69,7 @@ public void test() {
 		assertThat(code, containsOne("return 1;"));
 		assertThat(code, containsOne("return true;"));
 		assertThat(code, containsOne("return (byte) 2;"));
-		assertThat(code, containsOne("return 3;"));
+		assertThat(code, containsOne("return (short) 3;"));
 		assertThat(code, containsOne("return 'c';"));
 		assertThat(code, containsOne("return 4L;"));
 		assertThat(code, countString(2, "use(true);"));

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch.java
Patch:
@@ -14,7 +14,7 @@ public class TestTryCatch extends IntegrationTest {
 	public static class TestCls {
 		public void f() {
 			try {
-				Thread.sleep(50);
+				Thread.sleep(50L);
 			} catch (InterruptedException e) {
 				// ignore
 			}
@@ -27,7 +27,7 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsString("try {"));
-		assertThat(code, containsString("Thread.sleep(50);"));
+		assertThat(code, containsString("Thread.sleep(50L);"));
 		assertThat(code, containsString("} catch (InterruptedException e) {"));
 		assertThat(code, not(containsString("return")));
 	}

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch2.java
Patch:
@@ -16,7 +16,7 @@ public static class TestCls {
 		public static boolean test() {
 			try {
 				synchronized (OBJ) {
-					OBJ.wait(5);
+					OBJ.wait(5L);
 				}
 				return true;
 			} catch (InterruptedException e) {
@@ -32,7 +32,7 @@ public void test() {
 
 		assertThat(code, containsString("try {"));
 		assertThat(code, containsString("synchronized (OBJ) {"));
-		assertThat(code, containsString("OBJ.wait(5);"));
+		assertThat(code, containsString("OBJ.wait(5L);"));
 		assertThat(code, containsString("return true;"));
 		assertThat(code, containsString("} catch (InterruptedException e) {"));
 		assertThat(code, containsString("return false;"));

File: jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion.java
Patch:
@@ -23,6 +23,6 @@ public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
 				.doesNotContain("putByte(j, z);")
-				.containsOne("putByte(j, z ? (byte) 1 : 0);");
+				.containsOne("putByte(j, z ? (byte) 1 : (byte) 0);");
 	}
 }

File: jadx-core/src/main/java/jadx/api/JadxArgs.java
Patch:
@@ -138,7 +138,7 @@ public int getThreadsCount() {
 	}
 
 	public void setThreadsCount(int threadsCount) {
-		this.threadsCount = threadsCount;
+		this.threadsCount = Math.max(1, threadsCount); // make sure threadsCount >= 1
 	}
 
 	public boolean isCfgOutput() {

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -12,6 +12,7 @@
 
 import jadx.api.CommentsLevel;
 import jadx.api.JadxArgs;
+import jadx.core.dex.visitors.AnonymousClassVisitor;
 import jadx.core.dex.visitors.AttachCommentsVisitor;
 import jadx.core.dex.visitors.AttachMethodDetails;
 import jadx.core.dex.visitors.AttachTryCatchVisitor;
@@ -135,6 +136,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 		passes.add(new GenericTypesVisitor());
 		passes.add(new ShadowFieldVisitor());
 		passes.add(new DeboxingVisitor());
+		passes.add(new AnonymousClassVisitor());
 		passes.add(new ModVisitor());
 		passes.add(new CodeShrinkVisitor());
 		passes.add(new ReSugarCode());

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -33,6 +33,7 @@ public enum AFlag {
 
 	SKIP_FIRST_ARG,
 	SKIP_ARG, // skip argument in invoke call
+	NO_SKIP_ARGS,
 	ANONYMOUS_CONSTRUCTOR,
 	ANONYMOUS_CLASS,
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java
Patch:
@@ -154,7 +154,7 @@ private List<ArgType> checkArgTypes(MethodNode mth, SignatureParser sp, List<Arg
 					return newArgTypes;
 				}
 			}
-			mth.addWarnComment("Incorrect args count in method signature: " + sp.getSignature());
+			mth.addDebugComment("Incorrect args count in method signature: " + sp.getSignature());
 			return null;
 		}
 		for (int i = 0; i < len; i++) {

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass3a.java
Patch:
@@ -3,6 +3,7 @@
 import org.junit.jupiter.api.Test;
 
 import jadx.NotYetImplemented;
+import jadx.api.CommentsLevel;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;
@@ -41,9 +42,11 @@ public void check() {
 	@Test
 	@NotYetImplemented
 	public void test() {
+		getArgs().setCommentsLevel(CommentsLevel.NONE);
 		assertThat(getClassNode(TestCls.class))
 				.code()
 				.doesNotContain("synthetic")
+				.doesNotContain("access$00")
 				.doesNotContain("AnonymousClass_")
 				.doesNotContain("unused = ")
 				.containsLine(4, "public void run() {")

File: jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java
Patch:
@@ -58,7 +58,7 @@ private static Path getPathDeobfMapPath(RootNode root) {
 		if (inputFiles.isEmpty()) {
 			return null;
 		}
-		Path inputFilePath = inputFiles.get(0).getAbsoluteFile().toPath();
+		Path inputFilePath = inputFiles.get(0).toPath().toAbsolutePath();
 		String baseName = FileUtils.getPathBaseName(inputFilePath);
 		return inputFilePath.getParent().resolve(baseName + ".jobf");
 	}

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -75,7 +75,7 @@ public static void addFileToJar(JarOutputStream jar, File source, String entryNa
 
 	public static void makeDirsForFile(Path path) {
 		if (path != null) {
-			makeDirs(path.getParent().toFile());
+			makeDirs(path.toAbsolutePath().getParent().toFile());
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -451,7 +451,7 @@ private void onOpen(List<Path> paths) {
 		update();
 		restoreOpenTabs();
 		runInitialBackgroundJobs();
-		BreakpointManager.init(paths.get(0).getParent());
+		BreakpointManager.init(paths.get(0).toAbsolutePath().getParent());
 	}
 
 	private void addTreeCustomNodes() {
@@ -517,7 +517,7 @@ private void update() {
 		if (projectPath == null) {
 			pathString = "";
 		} else {
-			pathString = " [" + projectPath.getParent().toAbsolutePath() + ']';
+			pathString = " [" + projectPath.toAbsolutePath().getParent() + ']';
 		}
 		setTitle((project.isSaved() ? "" : '*')
 				+ project.getName() + pathString + " - " + DEFAULT_TITLE);

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestIssue86.java
Patch:
@@ -11,6 +11,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@SuppressWarnings("checkstyle:printstacktrace")
 public class TestIssue86 extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithTryCatch.java
Patch:
@@ -8,6 +8,7 @@
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@SuppressWarnings("checkstyle:printstacktrace")
 public class TestSwitchWithTryCatch extends IntegrationTest {
 	public static class TestCls {
 		void test(int a) {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestMultiExceptionCatch2.java
Patch:
@@ -11,6 +11,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@SuppressWarnings("checkstyle:printstacktrace")
 public class TestMultiExceptionCatch2 extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch7.java
Patch:
@@ -8,6 +8,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@SuppressWarnings("checkstyle:printstacktrace")
 public class TestTryCatch7 extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally.java
Patch:
@@ -7,6 +7,7 @@
 import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+@SuppressWarnings("checkstyle:printstacktrace")
 public class TestTryCatchFinally extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables4.java
Patch:
@@ -11,6 +11,7 @@
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@SuppressWarnings("checkstyle:printstacktrace")
 public class TestVariables4 extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java
Patch:
@@ -195,7 +195,7 @@ private void showCode(final JumpPosition jumpPos) {
 					jumpPos.setPos(offs);
 					codeArea.scrollToPos(offs);
 				} catch (BadLocationException e) {
-					e.printStackTrace();
+					LOG.error("Failed to jump to position: {}", pos, e);
 					codeArea.scrollToLine(line);
 				}
 			}

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -42,7 +42,7 @@ public ConditionGen(InsnGen insnGen) {
 		super(insnGen.mgen, insnGen.fallback);
 	}
 
-	void add(ICodeWriter code, IfCondition condition) throws CodegenException {
+	public void add(ICodeWriter code, IfCondition condition) throws CodegenException {
 		add(code, new CondStack(), condition);
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -161,7 +161,7 @@ private boolean connectElseIf(ICodeWriter code, IContainer els) throws CodegenEx
 	}
 
 	public void makeLoop(LoopRegion region, ICodeWriter code) throws CodegenException {
-		code.startLineWithNum(region.getConditionSourceLine());
+		code.startLineWithNum(region.getSourceLine());
 		LoopLabelAttr labelAttr = region.getInfo().getStart().get(AType.LOOP_LABEL);
 		if (labelAttr != null) {
 			code.add(mgen.getNameGen().getLoopLabel(labelAttr)).add(": ");
@@ -213,7 +213,7 @@ public void makeLoop(LoopRegion region, ICodeWriter code) throws CodegenExceptio
 			code.add("do {");
 			CodeGenUtils.addCodeComments(code, mth, condInsn);
 			makeRegionIndent(code, region.getBody());
-			code.startLineWithNum(region.getConditionSourceLine());
+			code.startLineWithNum(region.getSourceLine());
 			code.add("} while (");
 			conditionGen.add(code, condition);
 			code.add(");");

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -216,7 +216,7 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac
 			// invert loop condition if 'then' points to exit
 			condInfo = IfInfo.invert(condInfo);
 		}
-		loopRegion.setCondition(condInfo.getCondition());
+		loopRegion.updateCondition(condInfo);
 		exitBlocks.removeAll(condInfo.getMergedBlocks());
 
 		if (!exitBlocks.isEmpty()) {
@@ -720,8 +720,7 @@ private BlockNode processIf(IRegion currentRegion, BlockNode block, IfNode ifnod
 		confirmMerge(currentIf);
 
 		IfRegion ifRegion = new IfRegion(currentRegion);
-		ifRegion.setCondition(currentIf.getCondition());
-		ifRegion.setConditionBlocks(currentIf.getMergedBlocks());
+		ifRegion.updateCondition(currentIf);
 		currentRegion.getSubBlocks().add(ifRegion);
 
 		BlockNode outBlock = currentIf.getOutBlock();

File: jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java
Patch:
@@ -97,7 +97,7 @@ private static void checkClassName(Deobfuscator deobfuscator, ClassNode cls, Jad
 			// check inner classes names
 			ClassInfo parentClass = classInfo.getParentClass();
 			while (parentClass != null) {
-				if (parentClass.getAliasShortName().equals(clsName)) {
+				if (parentClass.getAliasShortName().equals(newShortName)) {
 					String clsAlias = deobfuscator.getClsAlias(cls);
 					classInfo.changeShortName(clsAlias);
 					cls.addAttr(new RenameReasonAttr(cls).append("collision with other inner class name"));

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -47,6 +47,7 @@
 import jadx.core.xmlgen.ResourceStorage;
 import jadx.core.xmlgen.entry.ResourceEntry;
 import jadx.tests.api.compiler.DynamicCompiler;
+import jadx.tests.api.compiler.JavaUtils;
 import jadx.tests.api.compiler.StaticCompiler;
 import jadx.tests.api.utils.TestUtils;
 
@@ -490,6 +491,7 @@ protected void useEclipseCompiler() {
 	}
 
 	protected void useTargetJavaVersion(int version) {
+		Assumptions.assumeTrue(JavaUtils.checkJavaVersion(version), "skip test for higher java version");
 		this.targetJavaVersion = version;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java
Patch:
@@ -76,7 +76,7 @@ private static void processBlocksTree(MethodNode mth) {
 		mth.finishBasicBlocks();
 	}
 
-	private static void updateCleanSuccessors(MethodNode mth) {
+	static void updateCleanSuccessors(MethodNode mth) {
 		mth.getBasicBlocks().forEach(BlockNode::updateCleanSuccessors);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -948,7 +948,7 @@ public void actionPerformed(ActionEvent e) {
 			}
 		};
 		forwardAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("nav.forward"));
-		forwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT, KeyEvent.ALT_DOWN_MASK));
+		forwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT, KeyEvent.ALT_DOWN_MASK, SystemInfo.IS_MAC));
 
 		Action quarkAction = new AbstractAction("Quark Engine", ICON_QUARK) {
 			@Override

File: jadx-core/src/test/java/jadx/tests/api/SmaliTest.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.stream.Stream;
 
 import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.Assumptions;
 import org.junit.jupiter.api.BeforeEach;
 
 import jadx.api.JadxInternalAccess;
@@ -24,6 +25,7 @@ public abstract class SmaliTest extends IntegrationTest {
 
 	@BeforeEach
 	public void init() {
+		Assumptions.assumeFalse(USE_JAVA_INPUT, "skip smali test for java input tests");
 		super.init();
 		this.useDexInput();
 	}

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java
Patch:
@@ -283,7 +283,7 @@ public class JavaInsnsRegister {
 		register(arr, 0xb5, "putfield", 2, 2, Opcode.IPUT, InsnIndexType.FIELD_REF, s -> s.idx(s.u2()).pop(0).pop(1));
 
 		invoke(arr, 0xb6, "invokevirtual", 2, Opcode.INVOKE_VIRTUAL);
-		invoke(arr, 0xb7, "invokespecial", 2, Opcode.INVOKE_DIRECT);
+		invoke(arr, 0xb7, "invokespecial", 2, Opcode.INVOKE_SPECIAL);
 		invoke(arr, 0xb8, "invokestatic", 2, Opcode.INVOKE_STATIC);
 		invoke(arr, 0xb9, "invokeinterface", 4, Opcode.INVOKE_INTERFACE);
 		invoke(arr, 0xba, "invokedynamic", 4, Opcode.INVOKE_CUSTOM);

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/insns/Opcode.java
Patch:
@@ -97,6 +97,7 @@ public enum Opcode {
 	INVOKE_SUPER_RANGE,
 	INVOKE_VIRTUAL,
 	INVOKE_VIRTUAL_RANGE,
+	INVOKE_SPECIAL,
 
 	IGET,
 	IPUT,

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.List;
 import java.util.Map;
 
+import com.google.gson.JsonElement;
 import com.google.gson.annotations.SerializedName;
 
 import jadx.core.utils.Utils;
@@ -15,7 +16,7 @@ public static class Crime {
 		public List<String> permissions;
 
 		List<Method> native_api;
-		List<String[]> combination;
+		List<JsonElement> combination;
 		List<Map<String, InvokePlace>> register;
 	}
 

File: jadx-core/src/main/java/jadx/api/JavaField.java
Patch:
@@ -13,7 +13,7 @@ public final class JavaField implements JavaNode {
 	private final FieldNode field;
 	private final JavaClass parent;
 
-	JavaField(FieldNode f, JavaClass cls) {
+	JavaField(JavaClass cls, FieldNode f) {
 		this.field = f;
 		this.parent = cls;
 	}

File: jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java
Patch:
@@ -109,7 +109,7 @@ public String decodeValue(int dataType, int data) {
 			case TYPE_INT_DEC:
 				return Integer.toString(data);
 			case TYPE_INT_HEX:
-				return Integer.toHexString(data);
+				return "0x" + Integer.toHexString(data);
 			case TYPE_INT_BOOLEAN:
 				return data == 0 ? "false" : "true";
 			case TYPE_FLOAT:

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/annotations/EncodedValue.java
Patch:
@@ -5,8 +5,9 @@
 import jadx.api.plugins.input.data.attributes.IJadxAttrType;
 import jadx.api.plugins.input.data.attributes.IJadxAttribute;
 import jadx.api.plugins.input.data.attributes.JadxAttrType;
+import jadx.api.plugins.input.data.attributes.PinnedAttribute;
 
-public class EncodedValue implements IJadxAttribute {
+public class EncodedValue extends PinnedAttribute {
 	public static final EncodedValue NULL = new EncodedValue(EncodedType.ENCODED_NULL, null);
 
 	private final EncodedType type;

File: jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java
Patch:
@@ -129,7 +129,7 @@ private boolean validateAndApplyTypes(MethodNode mth, SignatureParser sp, ArgTyp
 			if (checkedArgTypes == null) {
 				return false;
 			}
-			mth.updateTypes(Utils.lockList(checkedArgTypes), retType);
+			mth.updateTypes(Collections.unmodifiableList(checkedArgTypes), retType);
 			return true;
 		} catch (Exception e) {
 			mth.addWarnComment("Type validation failed for signature: " + sp.getSignature(), e);

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -196,6 +196,7 @@ public void initClassPath() {
 				ClspGraph newClsp = new ClspGraph(this);
 				newClsp.load();
 				newClsp.addApp(classes);
+				newClsp.initCache();
 				this.clsp = newClsp;
 			}
 		} catch (Exception e) {

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -254,8 +254,7 @@ private void handleSelectClassOption() {
 						NLS.str("error_dialog.title"), JOptionPane.ERROR_MESSAGE);
 				return;
 			}
-			JNode node = cacheObject.getNodeCache().makeFrom(javaNode);
-			tabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine(), JumpPosition.getDefPos(node)));
+			tabbedPane.codeJump(cacheObject.getNodeCache().makeFrom(javaNode));
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -171,7 +171,7 @@ public JumpPosition getDefPosForNodeAtOffset(int offset) {
 			return null;
 		}
 		JNode jNode = convertJavaNode(foundNode);
-		return new JumpPosition(jNode.getRootClass(), pos.getLine(), JumpPosition.getDefPos(jNode));
+		return new JumpPosition(jNode.getRootClass(), pos);
 	}
 
 	private JNode convertJavaNode(JavaNode javaNode) {
@@ -252,8 +252,7 @@ public void refreshClass() {
 				CaretPositionFix caretFix = new CaretPositionFix(this);
 				caretFix.save();
 
-				cls.reload();
-				getMainWindow().getCacheObject().getIndexService().refreshIndex(cls.getCls());
+				cls.reload(getMainWindow().getCacheObject());
 
 				ClassCodeContentPanel codeContentPanel = (ClassCodeContentPanel) this.contentPanel;
 				codeContentPanel.getTabbedPane().refresh(cls);

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java
Patch:
@@ -45,7 +45,6 @@ public UsageDialog(MainWindow mainWindow, JNode node) {
 
 	@Override
 	protected void openInit() {
-		usageList = new ArrayList<>();
 		mainWindow.getBackgroundExecutor().execute(NLS.str("progress.load"),
 				this::collectUsageData,
 				(status) -> {
@@ -59,6 +58,7 @@ protected void openInit() {
 	}
 
 	private void collectUsageData() {
+		usageList = new ArrayList<>();
 		node.getJavaNode().getUseIn()
 				.stream()
 				.map(JavaNode::getTopParentClass)

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -37,6 +37,7 @@ public boolean shouldSkipField(FieldAttributes f) {
 			return JadxSettings.SKIP_FIELDS.contains(f.getName())
 					|| f.hasModifier(Modifier.PUBLIC)
 					|| f.hasModifier(Modifier.TRANSIENT)
+					|| f.hasModifier(Modifier.STATIC)
 					|| (f.getAnnotation(GsonExclude.class) != null);
 		}
 

File: jadx-core/src/main/java/jadx/api/JavaField.java
Patch:
@@ -2,6 +2,8 @@
 
 import java.util.List;
 
+import org.jetbrains.annotations.ApiStatus;
+
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.FieldNode;
@@ -67,6 +69,7 @@ public void removeAlias() {
 	/**
 	 * Internal API. Not Stable!
 	 */
+	@ApiStatus.Internal
 	public FieldNode getFieldNode() {
 		return field;
 	}

File: jadx-core/src/main/java/jadx/api/JavaMethod.java
Patch:
@@ -4,6 +4,8 @@
 import java.util.List;
 import java.util.stream.Collectors;
 
+import org.jetbrains.annotations.ApiStatus;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.nodes.MethodOverrideAttr;
 import jadx.core.dex.info.AccessInfo;
@@ -101,6 +103,7 @@ public void removeAlias() {
 	/**
 	 * Internal API. Not Stable!
 	 */
+	@ApiStatus.Internal
 	public MethodNode getMethodNode() {
 		return mth;
 	}

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java
Patch:
@@ -119,6 +119,7 @@ private void runJobs() throws InterruptedException {
 		private TaskStatus waitTermination(ThreadPoolExecutor executor) throws InterruptedException {
 			Supplier<TaskStatus> cancelCheck = buildCancelCheck();
 			try {
+				int k = 0;
 				while (true) {
 					if (executor.isTerminated()) {
 						return TaskStatus.COMPLETE;
@@ -129,7 +130,8 @@ private TaskStatus waitTermination(ThreadPoolExecutor executor) throws Interrupt
 						return cancelStatus;
 					}
 					setProgress(calcProgress(executor.getCompletedTaskCount()));
-					Thread.sleep(300);
+					k++;
+					Thread.sleep(k < 20 ? 100 : 1000); // faster update for short tasks
 				}
 			} catch (InterruptedException e) {
 				LOG.debug("Task wait interrupted");

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -122,7 +122,6 @@
 import jadx.gui.update.JadxUpdate.IUpdateCallback;
 import jadx.gui.update.data.Release;
 import jadx.gui.utils.CacheObject;
-import jadx.gui.utils.CodeUsageInfo;
 import jadx.gui.utils.FontUtils;
 import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.LafManager;
@@ -525,7 +524,6 @@ protected void resetCache() {
 		cacheObject.setJadxSettings(settings);
 
 		cacheObject.setIndexService(new IndexService(cacheObject));
-		cacheObject.setUsageInfo(new CodeUsageInfo(cacheObject.getNodeCache()));
 		cacheObject.setTextIndex(new TextSearchIndex(this));
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java
Patch:
@@ -20,11 +20,11 @@ public class CodeIndex {
 
 	private final List<CodeNode> values = new ArrayList<>();
 
-	public synchronized void put(CodeNode value) {
+	public void put(CodeNode value) {
 		values.add(value);
 	}
 
-	public synchronized void removeForCls(JavaClass cls) {
+	public void removeForCls(JavaClass cls) {
 		values.removeIf(v -> v.getJavaNode().getTopParentClass().equals(cls));
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java
Patch:
@@ -1,8 +1,8 @@
 package jadx.gui.utils.search;
 
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
-import java.util.concurrent.ConcurrentHashMap;
 
 import io.reactivex.BackpressureStrategy;
 import io.reactivex.Flowable;
@@ -12,7 +12,7 @@
 import jadx.gui.treemodel.JNode;
 
 public class SimpleIndex {
-	private final Map<JNode, String> data = new ConcurrentHashMap<>();
+	private final Map<JNode, String> data = new HashMap<>();
 
 	public void put(String str, JNode value) {
 		data.put(value, str);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -70,9 +70,6 @@ private static boolean isEmptySyntheticClass(ClassNode cls) {
 	 * Remove synthetic fields if type is outer class or class will be inlined (anonymous)
 	 */
 	private static void removeSyntheticFields(ClassNode cls) {
-		if (cls.getAccessFlags().isStatic()) {
-			return;
-		}
 		boolean inline = cls.isAnonymous();
 		if (inline || cls.getClassInfo().isInner()) {
 			for (FieldNode field : cls.getFields()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java
Patch:
@@ -261,7 +261,7 @@ private boolean fixMethodReturnType(MethodNode mth, IMethodDetails baseMth, List
 		}
 		boolean updated = updateReturnType(mth, baseMth, superTypes);
 		if (updated) {
-			mth.addInfoComment("Return type fixed from '" + returnType + "' to match base method");
+			mth.addDebugComment("Return type fixed from '" + returnType + "' to match base method");
 		}
 		return updated;
 	}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -123,6 +123,7 @@ public void init() {
 		args.setThreadsCount(1);
 		args.setSkipResources(true);
 		args.setFsCaseSensitive(false); // use same value on all systems
+		args.setCommentsLevel(CommentsLevel.DEBUG);
 	}
 
 	@AfterEach

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/ClassCodeContentPanel.java
Patch:
@@ -8,6 +8,7 @@
 
 import jadx.gui.treemodel.JNode;
 import jadx.gui.ui.TabbedPane;
+import jadx.gui.ui.panel.IViewStateSupport;
 import jadx.gui.utils.NLS;
 
 /**
@@ -18,7 +19,7 @@
  * <li>Smali source code of the selected class</li>
  * </ul>
  */
-public final class ClassCodeContentPanel extends AbstractCodeContentPanel {
+public final class ClassCodeContentPanel extends AbstractCodeContentPanel implements IViewStateSupport {
 	private static final long serialVersionUID = -7229931102504634591L;
 
 	private final transient CodePanel javaCodePanel;

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -228,7 +228,7 @@ private void addMethodArguments(ICodeWriter code, List<RegisterArg> args) {
 			}
 			code.add(' ');
 			if (code.isMetadataSupported() && ssaVar != null) {
-				code.attachAnnotation(VarDeclareRef.get(mth, var));
+				code.attachDefinition(VarDeclareRef.get(mth, var));
 			}
 			code.add(nameGen.assignArg(var));
 

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -348,7 +348,7 @@ private void makeCatchBlock(ICodeWriter code, ExceptionHandler handler) throws C
 		} else if (arg instanceof RegisterArg) {
 			CodeVar codeVar = ((RegisterArg) arg).getSVar().getCodeVar();
 			if (code.isMetadataSupported()) {
-				code.attachAnnotation(VarDeclareRef.get(mth, codeVar));
+				code.attachDefinition(VarDeclareRef.get(mth, codeVar));
 			}
 			code.add(mgen.getNameGen().assignArg(codeVar));
 		} else if (arg instanceof NamedArg) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java
Patch:
@@ -49,7 +49,7 @@ private void showRenameDialog() {
 			LOG.warn("Can't rename node: {}", node);
 			return;
 		}
-		RenameDialog.rename(codeArea.getMainWindow(), node);
+		RenameDialog.rename(codeArea.getMainWindow(), codeArea.getNode(), node);
 		node = null;
 	}
 

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -83,7 +83,7 @@ public void execute() {
 	public void savePresets() {
 		Path deobfMapFile = deobfPresets.getDeobfMapFile();
 		if (Files.exists(deobfMapFile) && !args.isDeobfuscationForceSave()) {
-			LOG.warn("Deobfuscation map file '{}' exists. Use command line option '--deobf-rewrite-cfg' to rewrite it",
+			LOG.info("Deobfuscation map file '{}' exists. Use command line option '--deobf-rewrite-cfg' to rewrite it",
 					deobfMapFile.toAbsolutePath());
 			return;
 		}

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java
Patch:
@@ -15,7 +15,7 @@ public static class Crime {
 		public List<String> permissions;
 
 		List<Method> native_api;
-		List<Method> combination;
+		List<String[]> combination;
 		List<Map<String, InvokePlace>> register;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -249,8 +249,8 @@ public boolean isAlwaysSelectOpened() {
 		return alwaysSelectOpened;
 	}
 
-	public void setAlwaysSelectOpened(boolean showHeapUsageBar) {
-		this.alwaysSelectOpened = showHeapUsageBar;
+	public void setAlwaysSelectOpened(boolean alwaysSelectOpened) {
+		this.alwaysSelectOpened = alwaysSelectOpened;
 		partialSync(settings -> settings.alwaysSelectOpened = alwaysSelectOpened);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -868,6 +868,9 @@ public void actionPerformed(ActionEvent e) {
 		alwaysSelectOpened.setState(settings.isAlwaysSelectOpened());
 		alwaysSelectOpened.addActionListener(event -> {
 			settings.setAlwaysSelectOpened(!settings.isAlwaysSelectOpened());
+			if (settings.isAlwaysSelectOpened()) {
+				this.syncWithEditor();
+			}
 		});
 
 		Action syncAction = new AbstractAction(NLS.str("menu.sync"), ICON_SYNC) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -186,7 +186,7 @@ private InsnNode simplifyStringConstructor(MethodNode mth, ConstructorInsn insn)
 							return null;
 						}
 						arr[i] = (byte) ((LiteralArg) arrArg).getLiteral();
-						if (NameMapper.isPrintableChar(arr[i])) {
+						if (NameMapper.isPrintableChar((char) arr[i])) {
 							printable++;
 						}
 					}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -224,7 +224,7 @@ protected void decompileAndCheck(List<ClassNode> clsList) {
 		}
 		System.out.println("-----------------------------------------------------------");
 		if (printDisassemble) {
-			clsList.forEach(this::printSmali);
+			clsList.forEach(this::printDisasm);
 		}
 		runChecks(clsList);
 	}
@@ -239,7 +239,7 @@ protected void runChecks(List<ClassNode> clsList) {
 		clsList.forEach(this::runAutoCheck);
 	}
 
-	private void printSmali(ClassNode cls) {
+	private void printDisasm(ClassNode cls) {
 		System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
 		System.out.println(cls.getDisassembledCode());
 		System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java
Patch:
@@ -76,7 +76,7 @@ private static MethodInlineAttr inlineMth(MethodNode mth) {
 		}
 		if (insnsCount == 1) {
 			InsnNode insn = insns.get(0);
-			if (insn.getType() == InsnType.RETURN) {
+			if (insn.getType() == InsnType.RETURN && insn.getArgsCount() == 1) {
 				// synthetic field getter
 				// set arg from 'return' instruction
 				return addInlineAttr(mth, InsnNode.wrapArg(insn.getArg(0)));

File: jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java
Patch:
@@ -24,6 +24,9 @@ public static String indent(int indent) {
 	}
 
 	public static int count(String string, String substring) {
+		if (substring == null || substring.isEmpty()) {
+			throw new IllegalArgumentException("Substring can't be null or empty");
+		}
 		int count = 0;
 		int idx = 0;
 		while ((idx = string.indexOf(substring, idx)) != -1) {

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java
Patch:
@@ -82,6 +82,8 @@ public void test3() {
 		ClassNode cls = getClassNode(TestCls3.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("public static final String[] A = {\"a\"};"));
+		// don't move code from try/catch
+		assertThat(code, containsOne("public static final String[] A;"));
+		assertThat(code, containsOne("A = new String[]{\"a\"};"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java
Patch:
@@ -245,12 +245,12 @@ private TypeCompareEnum compareGenericTypeWithObject(ArgType genericType, ArgTyp
 		if (objType.isGenericType()) {
 			return compareTypeVariables(genericType, objType);
 		}
-
+		boolean rootObject = objType.equals(ArgType.OBJECT);
 		List<ArgType> extendTypes = genericType.getExtendTypes();
 		if (extendTypes.isEmpty()) {
-			return NARROW;
+			return rootObject ? NARROW : CONFLICT;
 		}
-		if (extendTypes.contains(objType) || objType.equals(ArgType.OBJECT)) {
+		if (extendTypes.contains(objType) || rootObject) {
 			return NARROW;
 		}
 		for (ArgType extendType : extendTypes) {

File: jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java
Patch:
@@ -138,7 +138,7 @@ public void compareWildCards() {
 	public void compareGenericTypes() {
 		ArgType vType = genericType("V");
 		check(vType, OBJECT, TypeCompareEnum.NARROW);
-		check(vType, STRING, TypeCompareEnum.NARROW);
+		check(vType, STRING, TypeCompareEnum.CONFLICT);
 
 		ArgType rType = genericType("R");
 		check(vType, rType, TypeCompareEnum.CONFLICT);

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -579,7 +579,7 @@ public void useClass(ICodeWriter code, ClassNode classNode) {
 		addClsName(code, classNode.getClassInfo());
 	}
 
-	private void addClsName(ICodeWriter code, ClassInfo classInfo) {
+	public void addClsName(ICodeWriter code, ClassInfo classInfo) {
 		String clsName = useClassInternal(cls.getClassInfo(), classInfo);
 		code.add(clsName);
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -1108,6 +1108,7 @@ public Component getTreeCellRendererComponent(JTree tree,
 				Component c = super.getTreeCellRendererComponent(tree, value, selected, expanded, isLeaf, row, focused);
 				if (value instanceof JNode) {
 					JNode jNode = (JNode) value;
+					setText(jNode.makeStringHtml());
 					setIcon(jNode.getIcon());
 					setToolTipText(jNode.getTooltip());
 				} else {

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/insns/InsnData.java
Patch:
@@ -17,6 +17,8 @@ public interface InsnData {
 
 	Opcode getOpcode();
 
+	String getOpcodeMnemonic();
+
 	byte[] getByteCode();
 
 	InsnIndexType getIndexType();

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -586,7 +586,6 @@ private void makeInsnBody(ICodeWriter code, InsnNode insn, Set<Flags> state) thr
 
 			case MOVE_MULTI:
 				fallbackOnlyInsn(insn);
-				code.add("move-multi: ");
 				int len = insn.getArgsCount();
 				for (int i = 0; i < len - 1; i += 2) {
 					addArg(code, insn.getArg(i));

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/attributes/AttributesReader.java
Patch:
@@ -16,7 +16,7 @@ public class AttributesReader {
 
 	private final JavaClassData clsData;
 	private final ConstPoolReader constPool;
-	private final Map<Integer, JavaAttrType<?>> attrMap = new HashMap<>(JavaAttrType.size());
+	private final Map<Integer, JavaAttrType<?>> attrCache = new HashMap<>(JavaAttrType.size());
 
 	public AttributesReader(JavaClassData clsData, ConstPoolReader constPoolReader) {
 		this.clsData = clsData;
@@ -95,8 +95,8 @@ private IJavaAttribute readType(JavaAttrType<?> type, DataReader reader) {
 	}
 
 	private JavaAttrType<?> resolveAttrReader(int nameIdx) {
-		return attrMap.computeIfAbsent(nameIdx, idx -> {
-			String attrName = constPool.getUtf8(nameIdx);
+		return attrCache.computeIfAbsent(nameIdx, idx -> {
+			String attrName = constPool.getUtf8(idx);
 			JavaAttrType<?> attrType = JavaAttrType.byName(attrName);
 			if (attrType == null) {
 				LOG.warn("Unknown java class attribute type: {}", attrName);

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/IClassData.java
Patch:
@@ -1,7 +1,6 @@
 package jadx.api.plugins.input.data;
 
 import java.util.List;
-import java.util.function.Consumer;
 
 import org.jetbrains.annotations.Nullable;
 
@@ -21,7 +20,7 @@ public interface IClassData {
 
 	List<String> getInterfacesTypes();
 
-	void visitFieldsAndMethods(Consumer<IFieldData> fieldsConsumer, Consumer<IMethodData> mthConsumer);
+	void visitFieldsAndMethods(ISeqConsumer<IFieldData> fieldsConsumer, ISeqConsumer<IMethodData> mthConsumer);
 
 	List<IJadxAttribute> getAttributes();
 

File: jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java
Patch:
@@ -11,7 +11,7 @@ public class InfoStorage {
 	private final Map<FieldInfo, FieldInfo> fields = new HashMap<>();
 	// use only one MethodInfo instance
 	private final Map<MethodInfo, MethodInfo> uniqueMethods = new HashMap<>();
-	// can contain same method with different ids (from different dex files)
+	// can contain same method with different ids (from different files)
 	private final Map<Integer, MethodInfo> methods = new HashMap<>();
 
 	public ClassInfo getCls(ArgType type) {

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/JavaInputPlugin.java
Patch:
@@ -22,7 +22,7 @@ public JadxPluginInfo getPluginInfo() {
 
 	@Override
 	public ILoadResult loadFiles(List<Path> inputFiles) {
-		List<JavaClassReader> readers = JavaFileLoader.collectFiles(inputFiles);
+		List<JavaClassReader> readers = new JavaFileLoader().collectFiles(inputFiles);
 		if (readers.isEmpty()) {
 			return EmptyLoadResult.INSTANCE;
 		}

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/ConstPoolReader.java
Patch:
@@ -78,7 +78,7 @@ public IMethodRef getMethodRef(int idx) {
 		int descIdx = data.readU2();
 
 		JavaMethodRef mthRef = new JavaMethodRef();
-		mthRef.initUniqId(clsReader, clsIdx, nameIdx, descIdx);
+		mthRef.initUniqId(clsReader, idx, true);
 		mthRef.setParentClassType(getClass(clsIdx));
 		mthRef.setName(getUtf8(nameIdx));
 		mthRef.setDescr(getUtf8(descIdx));

File: jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/JavaClassData.java
Patch:
@@ -94,7 +94,7 @@ public void visitFieldsAndMethods(Consumer<IFieldData> fieldsConsumer, Consumer<
 			methodRef.setParentClassType(classType);
 			JavaMethodData method = new JavaMethodData(this, methodRef);
 			for (int i = 0; i < methodsCount; i++) {
-				parseMethod(reader, method, clsIdx);
+				parseMethod(reader, method, i);
 				mthConsumer.accept(method);
 			}
 		}
@@ -112,15 +112,15 @@ private void parseField(DataReader reader, JavaFieldData field) {
 		field.setAttributes(attributes);
 	}
 
-	private void parseMethod(DataReader reader, JavaMethodData method, int clsIdx) {
+	private void parseMethod(DataReader reader, JavaMethodData method, int id) {
 		int accessFlags = reader.readU2();
 		int nameIdx = reader.readU2();
 		int descriptorIdx = reader.readU2();
 		JavaAttrStorage attributes = attributesReader.load(reader);
 
 		JavaMethodRef methodRef = method.getMethodRef();
 		methodRef.reset();
-		methodRef.initUniqId(clsReader, clsIdx, nameIdx, descriptorIdx);
+		methodRef.initUniqId(clsReader, id, false);
 		methodRef.setName(constPoolReader.getUtf8(nameIdx));
 		methodRef.setDescr(constPoolReader.getUtf8(descriptorIdx));
 

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -311,7 +311,7 @@ private String getResName(String typeName, int resRef, String origKeyName) {
 			first = false;
 		}
 		// autogenerate key name, appended with cleaned origKeyName to be human-friendly
-		String newResName = String.format("res_0x%08x",resRef);
+		String newResName = String.format("res_0x%08x", resRef);
 		String cleanedResName = sb.toString();
 		if (!cleanedResName.isEmpty()) {
 			newResName += "_" + cleanedResName.toLowerCase();

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -38,8 +38,7 @@ public class ResXmlGen {
 			"navigation",
 			"raw",
 			"transition",
-			"xml"
-			));
+			"xml"));
 
 	private final ResourceStorage resStorage;
 	private final ValuesParser vp;

File: jadx-core/src/main/java/jadx/core/xmlgen/entry/ResourceEntry.java
Patch:
@@ -33,7 +33,7 @@ public ResourceEntry copy(String newKeyName) {
 	}
 
 	public ResourceEntry copyWithId() {
-		return copy(String.format("%s_res_0x%08x",keyName,id));
+		return copy(String.format("%s_res_0x%08x", keyName, id));
 	}
 
 	public int getId() {

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java
Patch:
@@ -16,9 +16,9 @@
 
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.panel.HtmlPanel;
-import jadx.gui.ui.TabbedPane;
 import jadx.gui.utils.UiUtils;
 
 public class QuarkReportNode extends JNode {

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java
Patch:
@@ -38,9 +38,9 @@
 import jadx.gui.JadxWrapper;
 import jadx.gui.jobs.BackgroundExecutor;
 import jadx.gui.treemodel.JMethod;
-import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.ui.TabbedPane;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.utils.JNodeCache;
 
 public class QuarkReportPanel extends ContentPanel {

File: jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.settings;
 
-import java.awt.*;
+import java.awt.Rectangle;
 
 public class WindowLocation {
 	private String windowId;

File: jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java
Patch:
@@ -19,9 +19,9 @@
 import jadx.api.ResourceFile;
 import jadx.api.ResourceType;
 import jadx.gui.JadxWrapper;
+import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.panel.HtmlPanel;
-import jadx.gui.ui.TabbedPane;
 import jadx.gui.utils.CertificateManager;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -1,8 +1,8 @@
 package jadx.gui.treemodel;
 
-import javax.swing.*;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
 
-import jadx.gui.ui.panel.ContentPanel;
 import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
 import org.jetbrains.annotations.Nullable;
 
@@ -15,6 +15,7 @@
 import jadx.core.dex.info.AccessInfo;
 import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.codearea.ClassCodeContentPanel;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -9,8 +9,8 @@
 import jadx.api.ICodeInfo;
 import jadx.api.JadxDecompiler;
 import jadx.api.JavaNode;
-import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.TabbedPane;
+import jadx.gui.ui.panel.ContentPanel;
 
 public abstract class JNode extends DefaultMutableTreeNode {
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java
Patch:
@@ -4,7 +4,8 @@
 import java.util.Collections;
 import java.util.List;
 
-import javax.swing.*;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
 
 import org.jetbrains.annotations.NotNull;
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResSearchNode.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.treemodel;
 
-import javax.swing.*;
+import javax.swing.Icon;
 
 import jadx.core.utils.StringUtils;
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JSources.java
Patch:
@@ -8,7 +8,8 @@
 import java.util.Map;
 import java.util.Set;
 
-import javax.swing.*;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
 
 import jadx.api.JavaPackage;
 import jadx.gui.JadxWrapper;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.treemodel;
 
-import javax.swing.*;
+import javax.swing.Icon;
 
 import jadx.api.JavaNode;
 import jadx.api.JavaVariable;
@@ -49,5 +49,4 @@ public String makeString() {
 	public boolean canRename() {
 		return true;
 	}
-
 }

File: jadx-gui/src/main/java/jadx/gui/treemodel/TextNode.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.treemodel;
 
-import javax.swing.*;
+import javax.swing.Icon;
 
 public class TextNode extends JNode {
 

File: jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.gui.ui;
 
-import java.awt.*;
+import java.awt.Color;
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
-import javax.swing.*;
 import javax.swing.FocusManager;
+import javax.swing.JProgressBar;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java
Patch:
@@ -32,8 +32,8 @@
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.MainWindow;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.utils.DefaultPopupMenuListener;
 import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.NLS;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeContentPanel.java
Patch:
@@ -1,8 +1,8 @@
 package jadx.gui.ui.codearea;
 
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.TabbedPane;
+import jadx.gui.ui.panel.ContentPanel;
 
 /**
  * The abstract base class for a content panel that show text based code or a.g. a resource
@@ -15,5 +15,4 @@ protected AbstractCodeContentPanel(TabbedPane panel, JNode jnode) {
 	}
 
 	public abstract AbstractCodeArea getCodeArea();
-
 }

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeContentPanel.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.ui.codearea;
 
-import java.awt.*;
+import java.awt.BorderLayout;
 
 import jadx.gui.treemodel.JNode;
 import jadx.gui.ui.TabbedPane;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java
Patch:
@@ -3,7 +3,8 @@
 import java.awt.event.ActionEvent;
 import java.awt.event.KeyEvent;
 
-import javax.swing.*;
+import javax.swing.AbstractAction;
+import javax.swing.KeyStroke;
 
 import org.jetbrains.annotations.Nullable;
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java
Patch:
@@ -3,7 +3,8 @@
 import java.awt.event.ActionEvent;
 import java.awt.event.KeyEvent;
 
-import javax.swing.*;
+import javax.swing.AbstractAction;
+import javax.swing.KeyStroke;
 
 import org.jetbrains.annotations.Nullable;
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java
Patch:
@@ -2,7 +2,8 @@
 
 import java.awt.event.ActionEvent;
 
-import javax.swing.*;
+import javax.swing.AbstractAction;
+import javax.swing.KeyStroke;
 import javax.swing.event.PopupMenuEvent;
 
 import org.jetbrains.annotations.Nullable;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java
Patch:
@@ -38,9 +38,6 @@
 import javax.swing.table.TableColumn;
 import javax.swing.table.TableColumnModel;
 
-import jadx.gui.ui.MainWindow;
-import jadx.gui.ui.panel.ProgressPanel;
-import jadx.gui.ui.TabbedPane;
 import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
 import org.fife.ui.rtextarea.SearchContext;
 import org.fife.ui.rtextarea.SearchEngine;
@@ -51,7 +48,10 @@
 
 import jadx.gui.treemodel.JNode;
 import jadx.gui.treemodel.JResSearchNode;
+import jadx.gui.ui.MainWindow;
+import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.codearea.AbstractCodeArea;
+import jadx.gui.ui.panel.ProgressPanel;
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.NLS;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java
Patch:
@@ -23,9 +23,6 @@
 import javax.swing.SwingConstants;
 import javax.swing.WindowConstants;
 
-import jadx.gui.ui.panel.ContentPanel;
-import jadx.gui.ui.MainWindow;
-import jadx.gui.ui.TabbedPane;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -52,8 +49,11 @@
 import jadx.gui.treemodel.JNode;
 import jadx.gui.treemodel.JPackage;
 import jadx.gui.treemodel.JVariable;
+import jadx.gui.ui.MainWindow;
+import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.codearea.ClassCodeContentPanel;
 import jadx.gui.ui.codearea.CodeArea;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.JNodeCache;
 import jadx.gui.utils.NLS;

File: jadx-gui/src/main/java/jadx/gui/ui/panel/ContentPanel.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.gui.ui.panel;
 
-import javax.swing.*;
+import javax.swing.JPanel;
 
-import jadx.gui.ui.TabbedPane;
 import org.jetbrains.annotations.Nullable;
 
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.TabbedPane;
 
 public abstract class ContentPanel extends JPanel {
 
@@ -33,7 +33,7 @@ public JNode getNode() {
 	/**
 	 * Allows to show a tool tip on the tab e.g. for displaying a long path of the
 	 * selected entry inside the APK file.
-	 *
+	 * <p>
 	 * If <code>null</code> is returned no tool tip will be displayed.
 	 */
 	@Nullable

File: jadx-gui/src/main/java/jadx/gui/ui/panel/IDebugController.java
Patch:
@@ -1,7 +1,6 @@
 package jadx.gui.ui.panel;
 
 import jadx.core.dex.instructions.args.ArgType;
-import jadx.gui.ui.panel.JDebuggerPanel;
 import jadx.gui.ui.panel.JDebuggerPanel.ValueTreeNode;
 
 public interface IDebugController {

File: jadx-gui/src/main/java/jadx/gui/ui/panel/ImagePanel.java
Patch:
@@ -1,12 +1,11 @@
 package jadx.gui.ui.panel;
 
-import java.awt.*;
+import java.awt.BorderLayout;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayInputStream;
 
 import javax.imageio.ImageIO;
 
-import jadx.gui.ui.TabbedPane;
 import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
 
 import hu.kazocsaba.imageviewer.ImageViewer;
@@ -18,6 +17,7 @@
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.xmlgen.ResContainer;
 import jadx.gui.treemodel.JResource;
+import jadx.gui.ui.TabbedPane;
 import jadx.gui.ui.codearea.AbstractCodeArea;
 
 public class ImagePanel extends ContentPanel {

File: jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.gui.utils;
 
-import java.awt.*;
+import java.awt.Font;
+import java.awt.GraphicsEnvironment;
 import java.io.InputStream;
 
 import javax.swing.text.StyleContext;

File: jadx-gui/src/main/java/jadx/gui/utils/OverlayIcon.java
Patch:
@@ -1,11 +1,12 @@
 package jadx.gui.utils;
 
-import java.awt.*;
+import java.awt.Component;
+import java.awt.Graphics;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import javax.swing.*;
+import javax.swing.Icon;
 
 public class OverlayIcon implements Icon {
 

File: jadx-gui/src/main/java/jadx/gui/utils/RectangleTypeAdapter.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.utils;
 
-import java.awt.*;
+import java.awt.Rectangle;
 import java.io.IOException;
 
 import com.google.gson.TypeAdapter;

File: jadx-gui/src/test/java/jadx/gui/TestI18n.java
Patch:
@@ -48,7 +48,6 @@ public void filesExactlyMatch() throws IOException {
 				} else {
 					compareToReference(p);
 				}
-
 			} catch (IOException e) {
 				Assertions.fail("Error " + e.getMessage());
 			}

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -80,7 +80,7 @@ public static boolean handleAppResField(ICodeWriter code, ClassGen clsGen, Class
 	@SuppressWarnings("RedundantCast")
 	public static boolean handleResourceFieldValue(ClassNode cls, ICodeWriter code, EncodedValue encodedValue) {
 		if (encodedValue.getType() == EncodedType.ENCODED_INT && isResourceClass(cls)) {
-			code.add(String.format("0x%X", ((Integer) encodedValue.getValue())));
+			code.add(String.format("0x%08x", ((Integer) encodedValue.getValue())));
 			return true;
 		}
 		return false;

File: jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java
Patch:
@@ -35,7 +35,7 @@ public static ICodeInfo makeXmlDump(ICodeWriter writer, ResourceStorage resStora
 		Set<String> addedValues = new HashSet<>();
 		for (ResourceEntry ri : resStorage.getResources()) {
 			if (addedValues.add(ri.getTypeName() + '.' + ri.getKeyName())) {
-				String format = String.format("<public type=\"%s\" name=\"%s\" id=\"0x%X\" />",
+				String format = String.format("<public type=\"%s\" name=\"%s\" id=\"0x%08x\" />",
 						ri.getTypeName(), ri.getKeyName(), ri.getId());
 				writer.startLine(format);
 			}

File: jadx-core/src/main/java/jadx/core/xmlgen/entry/ResourceEntry.java
Patch:
@@ -33,7 +33,7 @@ public ResourceEntry copy(String newKeyName) {
 	}
 
 	public ResourceEntry copyWithId() {
-		return copy(keyName + "_RES_" + id);
+		return copy(String.format("%s_res_0x%08x",keyName,id));
 	}
 
 	public int getId() {

File: jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java
Patch:
@@ -22,9 +22,9 @@
 import jadx.gui.device.debugger.smali.Smali;
 import jadx.gui.device.debugger.smali.SmaliRegister;
 import jadx.gui.treemodel.JClass;
-import jadx.gui.ui.IDebugController;
-import jadx.gui.ui.JDebuggerPanel;
-import jadx.gui.ui.JDebuggerPanel.*;
+import jadx.gui.ui.panel.IDebugController;
+import jadx.gui.ui.panel.JDebuggerPanel;
+import jadx.gui.ui.panel.JDebuggerPanel.*;
 
 import static jadx.gui.device.debugger.SmaliDebugger.RuntimeType;
 

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java
Patch:
@@ -16,7 +16,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.gui.ui.MainWindow;
-import jadx.gui.ui.ProgressPanel;
+import jadx.gui.ui.panel.ProgressPanel;
 import jadx.gui.utils.UiUtils;
 
 /**

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java
Patch:
@@ -16,8 +16,8 @@
 
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.ContentPanel;
-import jadx.gui.ui.HtmlPanel;
+import jadx.gui.ui.panel.ContentPanel;
+import jadx.gui.ui.panel.HtmlPanel;
 import jadx.gui.ui.TabbedPane;
 import jadx.gui.utils.UiUtils;
 
@@ -29,7 +29,7 @@ public class QuarkReportNode extends JNode {
 
 	private static final Gson GSON = new GsonBuilder().create();
 
-	private static final ImageIcon ICON = UiUtils.openIcon("icon_quark");
+	private static final ImageIcon ICON = UiUtils.openSvgIcon("ui/analyze");
 	private final Path apkFile;
 
 	private String errorContent;

File: jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java
Patch:
@@ -38,7 +38,7 @@
 import jadx.gui.JadxWrapper;
 import jadx.gui.jobs.BackgroundExecutor;
 import jadx.gui.treemodel.JMethod;
-import jadx.gui.ui.ContentPanel;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.ui.TabbedPane;
 import jadx.gui.utils.JNodeCache;

File: jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java
Patch:
@@ -19,8 +19,8 @@
 import jadx.api.ResourceFile;
 import jadx.api.ResourceType;
 import jadx.gui.JadxWrapper;
-import jadx.gui.ui.ContentPanel;
-import jadx.gui.ui.HtmlPanel;
+import jadx.gui.ui.panel.ContentPanel;
+import jadx.gui.ui.panel.HtmlPanel;
 import jadx.gui.ui.TabbedPane;
 import jadx.gui.utils.CertificateManager;
 import jadx.gui.utils.NLS;
@@ -31,7 +31,7 @@ public class ApkSignature extends JNode {
 
 	private static final Logger LOG = LoggerFactory.getLogger(ApkSignature.class);
 
-	private static final ImageIcon CERTIFICATE_ICON = UiUtils.openIcon("certificate_obj");
+	private static final ImageIcon CERTIFICATE_ICON = UiUtils.openSvgIcon("nodes/styleKeyPack");
 
 	private final transient File openFile;
 	private String content;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.api.ICodeInfo;
 import jadx.api.JadxDecompiler;
 import jadx.api.JavaNode;
-import jadx.gui.ui.ContentPanel;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.TabbedPane;
 
 public abstract class JNode extends DefaultMutableTreeNode {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java
Patch:
@@ -16,7 +16,7 @@
 public class JPackage extends JNode implements Comparable<JPackage> {
 	private static final long serialVersionUID = -4120718634156839804L;
 
-	private static final ImageIcon PACKAGE_ICON = UiUtils.openIcon("package_obj");
+	private static final ImageIcon PACKAGE_ICON = UiUtils.openSvgIcon("nodes/package");
 
 	private String fullName;
 	private String name;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -22,7 +22,7 @@
 public class JRoot extends JNode {
 	private static final long serialVersionUID = 8888495789773527342L;
 
-	private static final ImageIcon ROOT_ICON = UiUtils.openIcon("java_model_obj");
+	private static final ImageIcon ROOT_ICON = UiUtils.openSvgIcon("nodes/rootPackageFolder");
 
 	private final transient JadxWrapper wrapper;
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JSources.java
Patch:
@@ -18,7 +18,7 @@
 public class JSources extends JNode {
 	private static final long serialVersionUID = 8962924556824862801L;
 
-	private static final ImageIcon ROOT_ICON = UiUtils.openIcon("packagefolder_obj");
+	private static final ImageIcon ROOT_ICON = UiUtils.openSvgIcon("nodes/packageClasses");
 
 	private final transient JadxWrapper wrapper;
 	private final transient boolean flatPackages;

File: jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java
Patch:
@@ -12,14 +12,15 @@
 
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
 
 public class TabComponent extends JPanel {
 	private static final long serialVersionUID = -8147035487543610321L;
 
-	private static final ImageIcon ICON_CLOSE = UiUtils.openIcon("cross");
-	private static final ImageIcon ICON_CLOSE_INACTIVE = UiUtils.openIcon("cross_grayed");
+	private static final ImageIcon ICON_CLOSE = UiUtils.openSvgIcon("ui/closeHovered");
+	private static final ImageIcon ICON_CLOSE_INACTIVE = UiUtils.openSvgIcon("ui/close");
 
 	private final TabbedPane tabbedPane;
 	private final ContentPanel contentPanel;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeContentPanel.java
Patch:
@@ -1,7 +1,7 @@
 package jadx.gui.ui.codearea;
 
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.ContentPanel;
+import jadx.gui.ui.panel.ContentPanel;
 import jadx.gui.ui.TabbedPane;
 
 /**

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java
Patch:
@@ -22,7 +22,7 @@
 import jadx.api.data.impl.JadxNodeRef;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.CommentDialog;
+import jadx.gui.ui.dialog.CommentDialog;
 import jadx.gui.utils.CodeLinesInfo;
 import jadx.gui.utils.DefaultPopupMenuListener;
 import jadx.gui.utils.NLS;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentSearchAction.java
Patch:
@@ -7,7 +7,7 @@
 import javax.swing.Action;
 import javax.swing.KeyStroke;
 
-import jadx.gui.ui.SearchDialog;
+import jadx.gui.ui.dialog.SearchDialog;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java
Patch:
@@ -8,7 +8,7 @@
 import org.jetbrains.annotations.Nullable;
 
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.UsageDialog;
+import jadx.gui.ui.dialog.UsageDialog;
 import jadx.gui.utils.NLS;
 
 import static javax.swing.KeyStroke.getKeyStroke;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java
Patch:
@@ -10,7 +10,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.RenameDialog;
+import jadx.gui.ui.dialog.RenameDialog;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
 

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/AboutDialog.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.gui.ui;
+package jadx.gui.ui.dialog;
 
 import java.awt.*;
 import java.net.URL;
@@ -9,7 +9,7 @@
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
 
-class AboutDialog extends JDialog {
+public class AboutDialog extends JDialog {
 	private static final long serialVersionUID = 5763493590584039096L;
 
 	public AboutDialog() {

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.gui.ui;
+package jadx.gui.ui.dialog;
 
 import java.awt.BorderLayout;
 import java.awt.Component;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.gui.ui;
+package jadx.gui.ui.dialog;
 
 import java.awt.*;
 import java.awt.event.KeyAdapter;
@@ -21,6 +21,7 @@
 import javax.swing.event.DocumentEvent;
 import javax.swing.event.DocumentListener;
 
+import jadx.gui.ui.MainWindow;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/SetValueDialog.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.gui.ui;
+package jadx.gui.ui.dialog;
 
 import java.awt.*;
 import java.awt.event.ActionEvent;
@@ -11,7 +11,8 @@
 
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.utils.exceptions.JadxRuntimeException;
-import jadx.gui.ui.JDebuggerPanel.ValueTreeNode;
+import jadx.gui.ui.panel.JDebuggerPanel.ValueTreeNode;
+import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.TextStandardActions;
 import jadx.gui.utils.UiUtils;

File: jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java
Patch:
@@ -1,10 +1,11 @@
-package jadx.gui.ui;
+package jadx.gui.ui.dialog;
 
 import java.awt.*;
 
 import javax.swing.*;
 
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.CodeUsageInfo;
 import jadx.gui.utils.NLS;
 

File: jadx-gui/src/main/java/jadx/gui/ui/panel/ContentPanel.java
Patch:
@@ -1,7 +1,8 @@
-package jadx.gui.ui;
+package jadx.gui.ui.panel;
 
 import javax.swing.*;
 
+import jadx.gui.ui.TabbedPane;
 import org.jetbrains.annotations.Nullable;
 
 import jadx.gui.treemodel.JClass;

File: jadx-gui/src/main/java/jadx/gui/ui/panel/HtmlPanel.java
Patch:
@@ -1,11 +1,12 @@
-package jadx.gui.ui;
+package jadx.gui.ui.panel;
 
 import java.awt.*;
 
 import javax.swing.*;
 
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.TabbedPane;
 
 public final class HtmlPanel extends ContentPanel {
 	private static final long serialVersionUID = -6251262855835426245L;

File: jadx-gui/src/main/java/jadx/gui/ui/panel/IDebugController.java
Patch:
@@ -1,7 +1,8 @@
-package jadx.gui.ui;
+package jadx.gui.ui.panel;
 
 import jadx.core.dex.instructions.args.ArgType;
-import jadx.gui.ui.JDebuggerPanel.ValueTreeNode;
+import jadx.gui.ui.panel.JDebuggerPanel;
+import jadx.gui.ui.panel.JDebuggerPanel.ValueTreeNode;
 
 public interface IDebugController {
 	boolean startDebugger(JDebuggerPanel panel, String[] args);

File: jadx-gui/src/main/java/jadx/gui/ui/panel/ImagePanel.java
Patch:
@@ -1,11 +1,12 @@
-package jadx.gui.ui;
+package jadx.gui.ui.panel;
 
 import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayInputStream;
 
 import javax.imageio.ImageIO;
 
+import jadx.gui.ui.TabbedPane;
 import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
 
 import hu.kazocsaba.imageviewer.ImageViewer;

File: jadx-gui/src/main/java/jadx/gui/ui/panel/ProgressPanel.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.gui.ui;
+package jadx.gui.ui.panel;
 
 import java.awt.Dimension;
 import java.beans.PropertyChangeEvent;
@@ -13,13 +13,14 @@
 import javax.swing.JProgressBar;
 import javax.swing.SwingWorker;
 
+import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.UiUtils;
 
 public class ProgressPanel extends JPanel implements PropertyChangeListener {
 
 	private static final long serialVersionUID = -3238438119672015733L;
 
-	private static final Icon ICON_CANCEL = UiUtils.openIcon("cross");
+	private static final Icon ICON_CANCEL = UiUtils.openSvgIcon("ui/close");
 
 	private final JProgressBar progressBar;
 	private final JLabel progressLabel;

File: jadx-gui/src/main/java/jadx/gui/utils/CacheObject.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.gui.jobs.IndexService;
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.treemodel.JRoot;
-import jadx.gui.ui.SearchDialog;
+import jadx.gui.ui.dialog.SearchDialog;
 import jadx.gui.utils.search.CommentsIndex;
 import jadx.gui.utils.search.TextSearchIndex;
 

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -147,6 +147,7 @@ public void addClassDeclaration(ICodeWriter clsCode) {
 
 		annotationGen.addForClass(clsCode);
 		insertRenameInfo(clsCode, cls);
+		CodeGenUtils.addInputFileInfo(clsCode, cls);
 		clsCode.startLineWithNum(cls.getSourceLine()).add(af.makeString());
 		if (af.isInterface()) {
 			if (af.isAnnotation()) {

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -39,7 +39,7 @@ public void test() {
 
 		ClassNode cls = getClassNode(TestCls.class);
 		Map<Integer, Integer> lineMapping = cls.getCode().getLineMapping();
-		assertEquals("{5=17, 8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}",
+		assertEquals("{6=17, 9=18, 12=22, 13=23, 14=24, 15=28, 17=25, 18=26, 19=28, 22=31, 23=32}",
 				lineMapping.toString());
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java
Patch:
@@ -94,7 +94,7 @@ public static String typeFormatHtml(String name, ArgType type) {
 	}
 
 	public static String escapeHtml(String str) {
-		return str.replace("<", "&lt;");
+		return str.replace("<", "&lt;").replace(">", "&gt;");
 	}
 
 	public static String typeStr(ArgType type) {

File: jadx-gui/src/main/java/jadx/gui/ui/ContentPanel.java
Patch:
@@ -34,8 +34,6 @@ public JNode getNode() {
 	 * selected entry inside the APK file.
 	 *
 	 * If <code>null</code> is returned no tool tip will be displayed.
-	 *
-	 * @return
 	 */
 	@Nullable
 	public String getTabTooltip() {

File: jadx-gui/src/main/java/jadx/gui/ui/ImagePanel.java
Patch:
@@ -22,7 +22,7 @@
 public class ImagePanel extends ContentPanel {
 	private static final long serialVersionUID = 4071356367073142688L;
 
-	ImagePanel(TabbedPane panel, JResource res) {
+	public ImagePanel(TabbedPane panel, JResource res) {
 		super(panel, res);
 		setLayout(new BorderLayout());
 		try {

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java
Patch:
@@ -398,8 +398,8 @@ private static boolean checkBlocksTree(BlockNode dupBlock, BlockNode finallyBloc
 			InsnsSlice dupSlice, FinallyExtractInfo extractInfo) {
 		InsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();
 
-		List<BlockNode> finallyCS = finallyBlock.getSuccessors();
-		List<BlockNode> dupCS = dupBlock.getSuccessors();
+		List<BlockNode> finallyCS = finallyBlock.getCleanSuccessors();
+		List<BlockNode> dupCS = dupBlock.getCleanSuccessors();
 		if (finallyCS.size() == dupCS.size()) {
 			for (int i = 0; i < finallyCS.size(); i++) {
 				BlockNode finSBlock = finallyCS.get(i);

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -22,6 +22,8 @@ public class Consts {
 	public static final String DALVIK_THROWS = "Ldalvik/annotation/Throws;";
 	public static final String DALVIK_ANNOTATION_DEFAULT = "Ldalvik/annotation/AnnotationDefault;";
 
+	public static final String OVERRIDE_ANNOTATION = "Ljava/lang/Override;";
+
 	public static final String DEFAULT_PACKAGE_NAME = "defpackage";
 	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";
 

File: jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java
Patch:
@@ -69,7 +69,7 @@ private void add(IAttributeNode node, ICodeWriter code) {
 		}
 		for (IAnnotation a : aList.getAll()) {
 			String aCls = a.getAnnotationClass();
-			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {
+			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG) && !aCls.equals(Consts.OVERRIDE_ANNOTATION)) {
 				code.startLine();
 				formatAnnotation(code, a);
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java
Patch:
@@ -56,7 +56,7 @@ private void processCls(ClassNode cls) {
 	}
 
 	private void processMth(ClassNode cls, List<ArgType> superTypes, MethodNode mth) {
-		if (mth.isConstructor() || mth.getAccessFlags().isStatic()) {
+		if (mth.isConstructor() || mth.getAccessFlags().isStatic() || mth.getAccessFlags().isPrivate()) {
 			return;
 		}
 		MethodOverrideAttr attr = processOverrideMethods(cls, mth, superTypes);

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -192,12 +192,13 @@ private void processConstructorInsn(ClassNode cls, EnumField enumField, MethodNo
 		if (ctrMth != null) {
 			markArgsForSkip(ctrMth);
 		}
-		if (co.getResult().getSVar().getUseList().size() <= 2) {
+		RegisterArg coResArg = co.getResult();
+		if (coResArg == null || coResArg.getSVar().getUseList().size() <= 2) {
 			InsnRemover.removeWithoutUnbind(classInitMth, staticBlock, co);
 		} else {
 			// constructor result used in other places -> replace constructor with enum field get (SGET)
 			IndexInsnNode enumGet = new IndexInsnNode(InsnType.SGET, enumField.getField().getFieldInfo(), 0);
-			enumGet.setResult(co.getResult().duplicate());
+			enumGet.setResult(coResArg.duplicate());
 			BlockUtils.replaceInsn(classInitMth, staticBlock, co, enumGet);
 		}
 	}

File: jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java
Patch:
@@ -177,7 +177,7 @@ public Set<String> getSuperTypes(String clsName) {
 	private Set<String> putInSuperTypesCache(String clsName, Set<String> result) {
 		if (result.isEmpty()) {
 			Set<String> empty = Collections.emptySet();
-			superTypesCache.put(clsName, result);
+			superTypesCache.put(clsName, empty);
 			return empty;
 		}
 		superTypesCache.put(clsName, result);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -7,6 +7,7 @@
 import jadx.core.dex.attributes.annotations.AnnotationsList;
 import jadx.core.dex.attributes.annotations.MethodParameters;
 import jadx.core.dex.attributes.fldinit.FieldInitAttr;
+import jadx.core.dex.attributes.nodes.ClassTypeVarsAttr;
 import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;
 import jadx.core.dex.attributes.nodes.EdgeInsnAttr;
 import jadx.core.dex.attributes.nodes.EnumClassAttr;
@@ -58,6 +59,7 @@ public class AType<T extends IAttribute> {
 	public static final AType<SourceFileAttr> SOURCE_FILE = new AType<>();
 	public static final AType<EnumClassAttr> ENUM_CLASS = new AType<>();
 	public static final AType<EnumMapAttr> ENUM_MAP = new AType<>();
+	public static final AType<ClassTypeVarsAttr> CLASS_TYPE_VARS = new AType<>();
 
 	// field
 	public static final AType<FieldInitAttr> FIELD_INIT = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.function.Function;
 
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.jetbrains.annotations.TestOnly;
 
 import jadx.core.Consts;
@@ -823,6 +824,7 @@ public boolean isVoid() {
 	 * Recursively visit all subtypes of this type.
 	 * To exit return non-null value.
 	 */
+	@Nullable
 	public <R> R visitTypes(Function<ArgType, R> visitor) {
 		R r = visitor.apply(this);
 		if (r != null) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -72,6 +72,7 @@ public enum AFlag {
 	INCONSISTENT_CODE, // warning about incorrect decompilation
 
 	REQUEST_IF_REGION_OPTIMIZE, // run if region visitor again
+	RERUN_SSA_TRANSFORM,
 
 	// Class processing flags
 	RESTART_CODEGEN, // codegen must be executed again

File: jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java
Patch:
@@ -61,6 +61,9 @@ public ArgType expandTypeVariables(MethodNode mth, ArgType type) {
 	}
 
 	private void expandTypeVar(NotificationAttrNode node, ArgType type, Collection<ArgType> typeVars) {
+		if (typeVars.isEmpty()) {
+			return;
+		}
 		boolean allExtendsEmpty = true;
 		for (ArgType argType : typeVars) {
 			if (notEmpty(argType.getExtendTypes())) {

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -70,7 +70,9 @@ public void inheritUsedNames(NameGen otherNameGen) {
 	private void addNamesUsedInClass() {
 		ClassNode parentClass = mth.getParentClass();
 		for (FieldNode field : parentClass.getFields()) {
-			varNames.add(field.getAlias());
+			if (field.isStatic()) {
+				varNames.add(field.getAlias());
+			}
 		}
 		for (ClassNode innerClass : parentClass.getInnerClasses()) {
 			varNames.add(innerClass.getClassInfo().getAliasShortName());

File: jadx-core/src/main/java/jadx/api/impl/InMemoryCodeCache.java
Patch:
@@ -29,6 +29,6 @@ public void remove(String clsFullName) {
 
 	@Override
 	public String toString() {
-		return "InMemoryCodeCache";
+		return "InMemoryCodeCache: size=" + storage.size();
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/jobs/IBackgroundTask.java
Patch:
@@ -8,7 +8,7 @@ public interface IBackgroundTask {
 
 	List<Runnable> scheduleJobs();
 
-	void onFinish(TaskStatus status);
+	void onFinish(TaskStatus status, long skipped);
 
 	default boolean canBeCanceled() {
 		return false;

File: jadx-gui/src/main/java/jadx/gui/jobs/TaskStatus.java
Patch:
@@ -6,5 +6,6 @@ public enum TaskStatus {
 	COMPLETE,
 	CANCEL_BY_USER,
 	CANCEL_BY_TIMEOUT,
-	CANCEL_BY_MEMORY
+	CANCEL_BY_MEMORY,
+	ERROR
 }

File: jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java
Patch:
@@ -41,7 +41,6 @@
 import jadx.core.dex.visitors.RenameVisitor;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
-import jadx.gui.jobs.IndexJob;
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JField;
@@ -244,7 +243,7 @@ private void processPackage(List<JavaNode> toUpdate) {
 	private void refreshJClass(JClass cls) {
 		try {
 			cls.reload();
-			IndexJob.refreshIndex(cache, cls.getCls());
+			cache.getIndexService().refreshIndex(cls.getCls());
 		} catch (Exception e) {
 			LOG.error("Failed to reload class: {}", cls.getFullName(), e);
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -153,7 +153,7 @@ protected void openInit() {
 	}
 
 	private TextSearchIndex checkIndex() {
-		if (!cache.getIndexJob().isComplete()) {
+		if (!cache.getIndexService().isComplete()) {
 			if (isFullIndexNeeded()) {
 				prepare();
 			}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -18,7 +18,6 @@
 import jadx.api.CodePosition;
 import jadx.api.JadxDecompiler;
 import jadx.api.JavaNode;
-import jadx.gui.jobs.IndexJob;
 import jadx.gui.settings.JadxProject;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
@@ -222,7 +221,7 @@ public void refreshClass() {
 				caretFix.save();
 
 				cls.reload();
-				IndexJob.refreshIndex(getMainWindow().getCacheObject(), cls.getCls());
+				getMainWindow().getCacheObject().getIndexService().refreshIndex(cls.getCls());
 
 				ClassCodeContentPanel codeContentPanel = (ClassCodeContentPanel) this.contentPanel;
 				codeContentPanel.getTabbedPane().refresh(cls);

File: jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java
Patch:
@@ -35,7 +35,7 @@ public static ICodeInfo makeXmlDump(ICodeWriter writer, ResourceStorage resStora
 		Set<String> addedValues = new HashSet<>();
 		for (ResourceEntry ri : resStorage.getResources()) {
 			if (addedValues.add(ri.getTypeName() + '.' + ri.getKeyName())) {
-				String format = String.format("<public type=\"%s\" name=\"%s\" id=\"%s\" />",
+				String format = String.format("<public type=\"%s\" name=\"%s\" id=\"0x%X\" />",
 						ri.getTypeName(), ri.getKeyName(), ri.getId());
 				writer.startLine(format);
 			}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -85,9 +85,9 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {
 		List<IDexTreeVisitor> passes = new ArrayList<>();
 		passes.add(new SignatureProcessor());
 		passes.add(new OverrideMethodVisitor());
-		passes.add(new ProcessAnonymous());
 		passes.add(new RenameVisitor());
 		passes.add(new UsageInfoVisitor());
+		passes.add(new ProcessAnonymous());
 		return passes;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -68,8 +68,6 @@ public void saveAll(File dir, ProgressMonitor progressMonitor) {
 			decompiler.getArgs().setRootDir(dir);
 			decompiler.save(500, (done, total) -> progressMonitor.setProgress((int) (done * 100.0 / total)));
 			progressMonitor.close();
-			LOG.info("decompilation complete, freeing memory ...");
-			decompiler.getClasses().forEach(JavaClass::unload);
 			LOG.info("done");
 		};
 		new Thread(save).start();

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java
Patch:
@@ -120,9 +120,6 @@ private void initLineNumbers() {
 		if (codeArea instanceof SmaliArea) {
 			return;
 		}
-		LineNumbers numbers = new LineNumbers(codeArea);
-		numbers.setUseSourceLines(isUseSourceLines());
-		codeScrollPane.setRowHeaderView(numbers);
 		initLineNumbers(isUseSourceLines());
 	}
 

File: jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java
Patch:
@@ -166,7 +166,7 @@ protected String getFullMthRawID() {
 
 		@Override
 		public int hashCode() {
-			return (int) (31 * codeOffset + 31 * cls.hashCode() + 31 * mth.hashCode());
+			return Objects.hash(codeOffset, cls, mth);
 		}
 
 		@Override

File: jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java
Patch:
@@ -660,8 +660,8 @@ private void fmtCols(InsnData insn, LineInfo line) {
 	private void formatByteCode(StringBuilder smali, byte[] bytes) {
 		int maxLen = Math.min(bytes.length, 4 * 2); // limit to 4 units
 		StringBuilder inHex = new StringBuilder();
-		for (int i = 0; i < maxLen; i++) {
-			int temp = ((bytes[i++] & 0xff) << 8) | (bytes[i] & 0xff);
+		for (int i = 0; i < maxLen - 1; i += 2) {
+			int temp = ((bytes[i] & 0xff) << 8) | (bytes[i + 1] & 0xff);
 			inHex.append(String.format("%04x ", temp));
 		}
 		smali.append(String.format(FMT_BYTECODE_COL, inHex));

File: jadx-gui/src/main/java/jadx/gui/ui/ADBDialog.java
Patch:
@@ -624,7 +624,8 @@ private String forwardJDWP() {
 						}
 					}
 					resultDesc = rst.desc;
-				} while (false);
+					break;
+				} while (true);
 			} catch (IOException e) {
 				e.printStackTrace();
 			}

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -173,10 +173,11 @@ public String decode(String attrName, long value) {
 		} else if (attr.getType() == MAttrType.FLAG) {
 			StringBuilder sb = new StringBuilder();
 			for (Map.Entry<Long, String> entry : attr.getValues().entrySet()) {
-				if (value == entry.getKey()) {
+				long key = entry.getKey();
+				if (value == key) {
 					sb = new StringBuilder(entry.getValue() + '|');
 					break;
-				} else if ((value & entry.getKey()) == entry.getKey()) {
+				} else if ((key != 0) && ((value & key) == key)) {
 					sb.append(entry.getValue()).append('|');
 				}
 			}

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -95,7 +95,9 @@ public CommonSearchDialog(MainWindow mainWindow) {
 	protected abstract void loadStart();
 
 	public void loadWindowPos() {
-		mainWindow.getSettings().loadWindowPos(this);
+		if (!mainWindow.getSettings().loadWindowPos(this)) {
+			setSize(800, 500);
+		}
 	}
 
 	public void prepare() {

File: jadx-gui/src/main/java/jadx/gui/utils/layout/WrapLayout.java
Patch:
@@ -128,10 +128,10 @@ private Dimension layoutSize(Container target, boolean preferred) {
 
 				if (m.isVisible()) {
 					Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();
+					int width = d.width;
 
 					// Can't add the component to current row. Start a new row.
-
-					if (rowWidth + d.width > maxWidth) {
+					if (rowWidth + width >= maxWidth) {
 						addRow(dim, rowWidth, rowHeight);
 						rowWidth = 0;
 						rowHeight = 0;
@@ -143,7 +143,7 @@ private Dimension layoutSize(Container target, boolean preferred) {
 						rowWidth += hgap;
 					}
 
-					rowWidth += d.width;
+					rowWidth += width;
 					rowHeight = Math.max(rowHeight, d.height);
 				}
 			}

File: jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java
Patch:
@@ -109,7 +109,8 @@ public void remove(JavaClass cls) {
 		this.codeIndex.removeForCls(cls);
 	}
 
-	public Flowable<JNode> buildSearch(String text, Set<SearchDialog.SearchOptions> options) {
+	public Flowable<JNode> buildSearch(String text, Set<SearchDialog.SearchOptions> options)
+			throws SearchSettings.InvalidSearchTermException {
 		boolean ignoreCase = options.contains(IGNORE_CASE);
 		boolean useRegex = options.contains(USE_REGEX);
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -463,8 +463,8 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 				SSAVar sVar = reg.getSVar();
 				if (sVar != null) {
 					sVar.getCodeVar().setFinal(true);
-					sVar.getAssign().add(AFlag.DONT_INLINE);
 				}
+				reg.add(AFlag.DONT_INLINE);
 				reg.add(AFlag.SKIP_ARG);
 			}
 		}

File: jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java
Patch:
@@ -91,7 +91,7 @@ public void indexCode(JavaClass cls, CodeLinesInfo linesInfo, List<StringRef> li
 				JavaNode node = linesInfo.getJavaNodeByLine(lineNum);
 				JavaNode javaNode = node == null ? cls : node;
 				JNode nodeAtLine = nodeCache.makeFrom(javaNode);
-				codeIndex.put(new CodeNode(nodeAtLine, line, lineNum, javaNode.getDefPos()));
+				codeIndex.put(new CodeNode(nodeAtLine, line, lineNum, line.getOffset()));
 			}
 		} catch (Exception e) {
 			LOG.warn("Failed to index class: {}", cls, e);

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -14,6 +14,7 @@
 import jadx.core.dex.visitors.AttachCommentsVisitor;
 import jadx.core.dex.visitors.AttachMethodDetails;
 import jadx.core.dex.visitors.AttachTryCatchVisitor;
+import jadx.core.dex.visitors.CheckCode;
 import jadx.core.dex.visitors.ClassModifier;
 import jadx.core.dex.visitors.ConstInlineVisitor;
 import jadx.core.dex.visitors.ConstructorVisitor;
@@ -96,6 +97,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 		}
 
 		List<IDexTreeVisitor> passes = new ArrayList<>();
+		passes.add(new CheckCode());
 		if (args.isDebugInfo()) {
 			passes.add(new DebugInfoAttachVisitor());
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -97,6 +97,8 @@ public class AType<T extends IAttribute> {
 
 	public static final Set<AType<?>> SKIP_ON_UNLOAD = new HashSet<>(Arrays.asList(
 			SOURCE_FILE,
+			ANNOTATION_LIST,
+			ANNOTATION_MTH_PARAMETERS,
 			FIELD_INIT,
 			FIELD_REPLACE,
 			METHOD_INLINE,

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -54,7 +54,7 @@ public InsnNode[] process(ICodeReader codeReader) {
 	}
 
 	@NotNull
-	private InsnNode decode(InsnData insn) throws DecodeException {
+	protected InsnNode decode(InsnData insn) throws DecodeException {
 		switch (insn.getOpcode()) {
 			case NOP:
 				return new InsnNode(InsnType.NOP, 0);

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/IClassData.java
Patch:
@@ -31,6 +31,4 @@ public interface IClassData {
 	List<IAnnotation> getAnnotations();
 
 	String getDisassembledCode();
-
-	String getDisassembledCodeV2();
 }

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -19,7 +19,7 @@
 
 public class JadxCLIArgs {
 
-	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc)")
+	@Parameter(description = "<input files> (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab)")
 	protected List<String> files = new ArrayList<>(1);
 
 	@Parameter(names = { "-d", "--output-dir" }, description = "output directory")

File: jadx-core/src/main/java/jadx/api/ResourceType.java
Patch:
@@ -41,6 +41,9 @@ public String[] getExts() {
 	}
 
 	public static ResourceType getFileType(String fileName) {
+		if (fileName.matches("[^/]+/resources.pb")) {
+			return ARSC;
+		}
 		int dot = fileName.lastIndexOf('.');
 		if (dot != -1) {
 			String ext = fileName.substring(dot).toLowerCase(Locale.ROOT);

File: jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java
Patch:
@@ -21,6 +21,7 @@ private XmlDeobf() {
 
 	@Nullable
 	public static String deobfClassName(RootNode rootNode, String potencialClassName, String packageName) {
+		potencialClassName = potencialClassName.replace('$', '.');
 		if (packageName != null && potencialClassName.startsWith(".")) {
 			potencialClassName = packageName + potencialClassName;
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -279,7 +279,7 @@ private JFileChooser buildFileChooser(boolean addFiles, String toolTipText) {
 		if (addFiles) {
 			exts = new String[] { "apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc" };
 		} else {
-			exts = new String[] { JadxProject.PROJECT_EXTENSION, "apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc" };
+			exts = new String[] { JadxProject.PROJECT_EXTENSION, "apk", "dex", "jar", "class", "smali", "zip", "aar", "arsc", "aab" };
 		}
 		String description = "Supported files: (" + Utils.arrayToStr(exts) + ')';
 

File: jadx-core/src/main/java/jadx/api/JavaNode.java
Patch:
@@ -14,5 +14,7 @@ public interface JavaNode {
 
 	int getDecompiledLine();
 
+	int getDefPos();
+
 	List<JavaNode> getUseIn();
 }

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -33,7 +33,6 @@ private static ICodeInfo process(ClassNode cls, boolean codegen) {
 			try {
 				if (cls.contains(AFlag.CLASS_DEEP_RELOAD)) {
 					cls.remove(AFlag.CLASS_DEEP_RELOAD);
-					cls.unload();
 					cls.deepUnload();
 					cls.root().runPreDecompileStageForClass(cls);
 				}

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -121,8 +121,9 @@ public void addClassCode(ICodeWriter code) throws CodegenException {
 		if (Consts.DEBUG_USAGE) {
 			addClassUsageInfo(code, cls);
 		}
-		CodeGenUtils.addComments(code, cls);
 		insertDecompilationProblems(code, cls);
+		CodeGenUtils.addSourceFileInfo(code, cls);
+		CodeGenUtils.addComments(code, cls);
 		addClassDeclaration(code);
 		addClassBody(code);
 	}
@@ -145,7 +146,6 @@ public void addClassDeclaration(ICodeWriter clsCode) {
 
 		annotationGen.addForClass(clsCode);
 		insertRenameInfo(clsCode, cls);
-		CodeGenUtils.addSourceFileInfo(clsCode, cls);
 		clsCode.startLineWithNum(cls.getSourceLine()).add(af.makeString());
 		if (af.isInterface()) {
 			if (af.isAnnotation()) {

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -135,9 +135,6 @@ private String makeArgName(CodeVar var) {
 		if (!NameMapper.isValidAndPrintable(name)) {
 			name = getFallbackName(var);
 		}
-		if (Consts.DEBUG) {
-			name += '_' + getFallbackName(var);
-		}
 		return name;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -42,6 +42,9 @@
 @SuppressWarnings("InstantiationOfUtilityClass")
 public class AType<T extends IAttribute> {
 
+	// class, method, field, insn
+	public static final AType<AttrList<String>> CODE_COMMENTS = new AType<>();
+
 	// class, method, field
 	public static final AType<AnnotationsList> ANNOTATION_LIST = new AType<>();
 	public static final AType<RenameReasonAttr> RENAME_REASON = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/NotificationAttrNode.java
Patch:
@@ -35,11 +35,9 @@ public void addWarnComment(String warn, @Nullable Throwable exc) {
 
 	public void addComment(String commentStr) {
 		addAttr(AType.COMMENTS, commentStr);
-		LOG.info("{} in {}", commentStr, this);
 	}
 
 	public void addDebugComment(String commentStr) {
 		addAttr(AType.COMMENTS, "JADX DEBUG: " + commentStr);
-		LOG.debug("{} in {}", commentStr, this);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -608,5 +608,6 @@ private static void processMoveException(MethodNode mth, BlockNode block, InsnNo
 			excHandler.setArg(namedArg);
 			replaceInsn(mth, block, 0, moveInsn);
 		}
+		block.copyAttributeFrom(insn, AType.CODE_COMMENTS); // save comment
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -749,7 +749,9 @@ private static boolean splitReturn(MethodNode mth, BlockNode exitBlock) {
 				first = false;
 			} else {
 				for (InsnNode oldInsn : exitBlock.getInstructions()) {
-					newRetBlock.getInstructions().add(oldInsn.copyWithoutSsa());
+					InsnNode copyInsn = oldInsn.copyWithoutSsa();
+					copyInsn.add(AFlag.SYNTHETIC);
+					newRetBlock.getInstructions().add(copyInsn);
 				}
 			}
 			BlockSplitter.replaceConnection(pred, exitBlock, newRetBlock);

File: jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java
Patch:
@@ -6,6 +6,8 @@
 import jadx.api.JavaVariable;
 
 public class JVariable extends JNode {
+	private static final long serialVersionUID = -3002100457834453783L;
+
 	JClass cls;
 	JavaVariable var;
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/ClassCodeContentPanel.java
Patch:
@@ -1,8 +1,8 @@
 package jadx.gui.ui.codearea;
 
-import java.awt.*;
+import java.awt.BorderLayout;
 
-import javax.swing.*;
+import javax.swing.JTabbedPane;
 import javax.swing.border.EmptyBorder;
 
 import jadx.gui.treemodel.JNode;
@@ -86,5 +86,4 @@ public AbstractCodeArea getCurrentCodeArea() {
 	public AbstractCodeArea getSmaliCodeArea() {
 		return smaliCodePanel.getCodeArea();
 	}
-
 }

File: jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java
Patch:
@@ -64,7 +64,7 @@ private void addUsage(JNode jNode, JavaClass javaClass,
 		JavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(line);
 		StringRef codeLine = lines.get(line - 1);
 		JNode node = nodeCache.makeFrom(javaNodeByLine == null ? javaClass : javaNodeByLine);
-		CodeNode codeNode = new CodeNode(node, line, codeLine).setPrecisePos(codePosition.getUsagePosition());
+		CodeNode codeNode = new CodeNode(node, codeLine, line, codePosition.getPos());
 		usageInfo.addUsage(codeNode);
 	}
 

File: jadx-gui/src/test/java/jadx/gui/utils/JumpManagerTest.java
Patch:
@@ -118,6 +118,6 @@ public void addSame() {
 	}
 
 	private JumpPosition makeJumpPos() {
-		return new JumpPosition(new TextNode(""), 0);
+		return new JumpPosition(new TextNode(""), 0, 0);
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -58,7 +58,7 @@ public MethodGen(ClassGen classGen, MethodNode mth) {
 		this.mth = mth;
 		this.classGen = classGen;
 		this.annotationGen = classGen.getAnnotationGen();
-		this.nameGen = new NameGen(mth, classGen.isFallbackMode());
+		this.nameGen = new NameGen(mth, classGen);
 	}
 
 	public ClassGen getClassGen() {

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -426,6 +426,8 @@ private void addEnumFields(ICodeWriter code) throws CodegenException {
 		InsnGen igen = null;
 		for (Iterator<EnumField> it = enumFields.getFields().iterator(); it.hasNext();) {
 			EnumField f = it.next();
+
+			CodeGenUtils.addComments(code, f.getField());
 			code.startLine(f.getField().getAlias());
 			ConstructorInsn constrInsn = f.getConstrInsn();
 			MethodNode callMth = cls.root().resolveMethod(constrInsn.getCallMth());

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -6,6 +6,7 @@
 import jadx.api.JadxArgs;
 import jadx.api.JadxDecompiler;
 import jadx.api.impl.NoOpCodeCache;
+import jadx.api.impl.SimpleCodeWriter;
 import jadx.core.utils.exceptions.JadxArgsValidateException;
 import jadx.core.utils.files.FileUtils;
 
@@ -38,6 +39,7 @@ public static int execute(String[] args) {
 
 	private static int processAndSave(JadxArgs jadxArgs) {
 		jadxArgs.setCodeCache(new NoOpCodeCache());
+		jadxArgs.setCodeWriterProvider(SimpleCodeWriter::new);
 		try (JadxDecompiler jadx = new JadxDecompiler(jadxArgs)) {
 			jadx.load();
 			jadx.save();

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -17,7 +17,6 @@
 import jadx.api.ResourceFile.ZipRef;
 import jadx.api.impl.SimpleCodeInfo;
 import jadx.api.plugins.utils.ZipSecurity;
-import jadx.core.codegen.CodeWriter;
 import jadx.core.utils.Utils;
 import jadx.core.utils.android.Res9patchStreamDecoder;
 import jadx.core.utils.exceptions.JadxException;
@@ -83,7 +82,7 @@ static ResContainer loadContent(JadxDecompiler jadxRef, ResourceFile rf) {
 			return decodeStream(rf, (size, is) -> loadContent(jadxRef, rf, is));
 		} catch (JadxException e) {
 			LOG.error("Decode error", e);
-			CodeWriter cw = new CodeWriter();
+			ICodeWriter cw = jadxRef.getRoot().makeCodeWriter();
 			cw.add("Error decode ").add(rf.getType().toString().toLowerCase());
 			Utils.appendStackTrace(cw, e.getCause());
 			return ResContainer.textResource(rf.getDeobfName(), cw.finish());

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.utils.Utils;
 
 public class AttrList<T> implements IAttribute {
@@ -26,6 +26,6 @@ public AType<AttrList<T>> getType() {
 
 	@Override
 	public String toString() {
-		return Utils.listToString(list, CodeWriter.NL);
+		return Utils.listToString(list, ICodeWriter.NL);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java
Patch:
@@ -4,7 +4,7 @@
 
 import org.jetbrains.annotations.NotNull;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.utils.Utils;
 
 public class JadxError implements Comparable<JadxError> {
@@ -59,7 +59,7 @@ public String toString() {
 			str.append(cause.getClass());
 			str.append(':');
 			str.append(cause.getMessage());
-			str.append(CodeWriter.NL);
+			str.append(ICodeWriter.NL);
 			str.append(Utils.getStackTrace(cause));
 		}
 		return str.toString();

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LocalVarsDebugInfoAttr.java
Patch:
@@ -2,13 +2,12 @@
 
 import java.util.List;
 
+import jadx.api.ICodeWriter;
 import jadx.api.plugins.input.data.ILocalVar;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.utils.Utils;
 
-import static jadx.core.codegen.CodeWriter.NL;
-
 public class LocalVarsDebugInfoAttr implements IAttribute {
 	private final List<ILocalVar> localVars;
 
@@ -27,6 +26,6 @@ public AType<LocalVarsDebugInfoAttr> getType() {
 
 	@Override
 	public String toString() {
-		return "Debug Info:" + NL + "  " + Utils.listToString(localVars, NL + "  ");
+		return "Debug Info:" + ICodeWriter.NL + "  " + Utils.listToString(localVars, ICodeWriter.NL + "  ");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.instructions.PhiInsn;
@@ -29,7 +29,7 @@ public String toString() {
 			sb.append('r').append(phiInsn.getResult().getRegNum()).append(' ');
 		}
 		for (PhiInsn phiInsn : list) {
-			sb.append(CodeWriter.NL).append("  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
+			sb.append(ICodeWriter.NL).append("  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
 		}
 		return sb.toString();
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -8,8 +8,8 @@
 
 import org.jetbrains.annotations.Nullable;
 
+import jadx.api.ICodeWriter;
 import jadx.api.plugins.input.insns.InsnData;
-import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.instructions.InsnType;
@@ -477,9 +477,9 @@ protected void appendArgs(StringBuilder sb) {
 			sb.append(argsStr);
 		} else {
 			// wrap args
-			String separator = CodeWriter.NL + "  ";
+			String separator = ICodeWriter.NL + "  ";
 			sb.append(separator).append(Utils.listToString(arguments, separator));
-			sb.append(CodeWriter.NL);
+			sb.append(ICodeWriter.NL);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.IBranchRegion;
 import jadx.core.dex.nodes.IContainer;
@@ -84,7 +84,7 @@ public String toString() {
 		for (CaseInfo caseInfo : cases) {
 			List<String> keyStrings = Utils.collectionMap(caseInfo.getKeys(),
 					k -> k == DEFAULT_CASE_KEY ? "default" : k.toString());
-			sb.append(CodeWriter.NL).append(" case ")
+			sb.append(ICodeWriter.NL).append(" case ")
 					.append(Utils.listToString(keyStrings))
 					.append(" -> ").append(caseInfo.getContainer());
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java
Patch:
@@ -6,6 +6,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.api.ICodeWriter;
 import jadx.api.plugins.input.data.IDebugInfo;
 import jadx.api.plugins.input.data.ILocalVar;
 import jadx.core.dex.attributes.nodes.LocalVarsDebugInfoAttr;
@@ -24,8 +25,6 @@
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxException;
 
-import static jadx.core.codegen.CodeWriter.NL;
-
 @JadxVisitor(
 		name = "Debug Info Parser",
 		desc = "Attach debug information (variable names and types, instruction lines)",
@@ -48,7 +47,7 @@ public void visit(MethodNode mth) throws JadxException {
 		} catch (Exception e) {
 			mth.addComment("JADX WARNING: Error to parse debug info: "
 					+ ErrorsCounter.formatMsg(mth, e.getMessage())
-					+ NL + Utils.getStackTrace(e));
+					+ ICodeWriter.NL + Utils.getStackTrace(e));
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/Utils.java
Patch:
@@ -16,8 +16,8 @@
 
 import org.jetbrains.annotations.Nullable;
 
+import jadx.api.ICodeWriter;
 import jadx.api.JadxDecompiler;
-import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.visitors.DepthTraversal;
 
 public class Utils {
@@ -124,7 +124,7 @@ public static String getStackTrace(Throwable throwable) {
 		return sw.getBuffer().toString();
 	}
 
-	public static void appendStackTrace(CodeWriter code, Throwable throwable) {
+	public static void appendStackTrace(ICodeWriter code, Throwable throwable) {
 		if (throwable == null) {
 			return;
 		}

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -9,11 +9,11 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.api.ICodeWriter;
 import jadx.api.plugins.input.data.AccessFlags;
 import jadx.api.plugins.input.data.annotations.EncodedType;
 import jadx.api.plugins.input.data.annotations.EncodedValue;
 import jadx.core.codegen.ClassGen;
-import jadx.core.codegen.CodeWriter;
 import jadx.core.deobf.NameMapper;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
@@ -63,7 +63,7 @@ public static ClassNode searchAppResClass(RootNode root, ResourceStorage resStor
 		return newResCls;
 	}
 
-	public static boolean handleAppResField(CodeWriter code, ClassGen clsGen, ClassInfo declClass) {
+	public static boolean handleAppResField(ICodeWriter code, ClassGen clsGen, ClassInfo declClass) {
 		ClassInfo parentClass = declClass.getParentClass();
 		if (parentClass != null && parentClass.getShortName().equals("R")) {
 			clsGen.useClass(code, parentClass);

File: jadx-core/src/main/java/jadx/core/utils/exceptions/JadxRuntimeException.java
Patch:
@@ -2,10 +2,9 @@
 
 import java.util.Arrays;
 
+import jadx.api.ICodeWriter;
 import jadx.core.utils.Utils;
 
-import static jadx.core.codegen.CodeWriter.NL;
-
 public class JadxRuntimeException extends RuntimeException {
 
 	private static final long serialVersionUID = -7410848445429898248L;
@@ -15,7 +14,7 @@ public JadxRuntimeException(String message) {
 	}
 
 	public JadxRuntimeException(String... lines) {
-		super(Utils.listToString(Arrays.asList(lines), NL + "  "));
+		super(Utils.listToString(Arrays.asList(lines), ICodeWriter.NL + "  "));
 	}
 
 	public JadxRuntimeException(String message, Throwable cause) {

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -14,7 +14,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.api.ICodeInfo;
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.deobf.NameMapper;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.nodes.FieldNode;
@@ -95,7 +95,7 @@ public ResContainer decodeFiles(InputStream inputStream) throws IOException {
 	}
 
 	public ICodeInfo makeXmlDump() {
-		CodeWriter writer = new CodeWriter();
+		ICodeWriter writer = root.makeCodeWriter();
 		writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
 		writer.startLine("<resources>");
 		writer.incIndent();

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -26,10 +26,10 @@
 import org.junit.jupiter.api.BeforeEach;
 
 import jadx.api.ICodeInfo;
+import jadx.api.ICodeWriter;
 import jadx.api.JadxArgs;
 import jadx.api.JadxDecompiler;
 import jadx.api.JadxInternalAccess;
-import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.AttrList;
@@ -240,7 +240,7 @@ private void printSmali(ClassNode cls) {
 	private void printCodeWithLineNumbers(ICodeInfo code) {
 		String codeStr = code.getCodeStr();
 		Map<Integer, Integer> lineMapping = code.getLineMapping();
-		String[] lines = codeStr.split(CodeWriter.NL);
+		String[] lines = codeStr.split(ICodeWriter.NL);
 		for (int i = 0; i < lines.length; i++) {
 			String line = lines[i];
 			int curLine = i + 1;

File: jadx-core/src/test/java/jadx/tests/api/utils/JadxMatchers.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.hamcrest.Matcher;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 
 public class JadxMatchers {
 
@@ -17,7 +17,7 @@ public static Matcher<String> containsOne(String substring) {
 	public static Matcher<String> containsLines(String... lines) {
 		StringBuilder sb = new StringBuilder();
 		for (String line : lines) {
-			sb.append(line).append(CodeWriter.NL);
+			sb.append(line).append(ICodeWriter.NL);
 		}
 		return countString(1, sb.toString());
 	}
@@ -30,7 +30,7 @@ public static Matcher<String> containsLines(int commonIndent, String... lines) {
 				sb.append(indent);
 				sb.append(line);
 			}
-			sb.append(CodeWriter.NL);
+			sb.append(ICodeWriter.NL);
 		}
 		return countString(1, sb.toString());
 	}

File: jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.assertj.core.api.AbstractStringAssert;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.tests.api.utils.TestUtils;
 
 public class JadxCodeAssertions extends AbstractStringAssert<JadxCodeAssertions> {
@@ -52,7 +52,7 @@ public JadxCodeAssertions containsLines(int commonIndent, String... lines) {
 				if (first) {
 					first = false;
 				} else {
-					sb.append(CodeWriter.NL);
+					sb.append(ICodeWriter.NL);
 				}
 				sb.append(indent);
 				sb.append(line);

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.FieldNode;
@@ -61,7 +61,7 @@ public void test() {
 		assertEquals(testClassLine + 20, innerFunc3.getSourceLine());
 
 		// check decompiled lines
-		String[] lines = code.split(CodeWriter.NL);
+		String[] lines = code.split(ICodeWriter.NL);
 		checkLine(lines, field, "int field;");
 		checkLine(lines, func, "public void func() {");
 		checkLine(lines, inner, "public static class Inner {");

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestReturnSourceLine.java
Patch:
@@ -4,7 +4,7 @@
 
 import jadx.NotYetImplemented;
 import jadx.api.ICodeInfo;
-import jadx.core.codegen.CodeWriter;
+import jadx.api.ICodeWriter;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.MethodNode;
@@ -54,7 +54,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		ICodeInfo codeInfo = cls.getCode();
 		String code = codeInfo.toString();
-		String[] lines = code.split(CodeWriter.NL);
+		String[] lines = code.split(ICodeWriter.NL);
 
 		MethodNode test1 = cls.searchMethodByShortId("test1(Z)I");
 		checkLine(lines, codeInfo, test1, 3, "return 1;");
@@ -69,7 +69,7 @@ public void test2() {
 		ClassNode cls = getClassNode(TestCls.class);
 		ICodeInfo codeInfo = cls.getCode();
 		String code = codeInfo.toString();
-		String[] lines = code.split(CodeWriter.NL);
+		String[] lines = code.split(ICodeWriter.NL);
 
 		MethodNode test3 = cls.searchMethodByShortId("test3(I)I");
 		checkLine(lines, codeInfo, test3, 3, "return v;");

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.stream.Collectors;
 
-import javax.swing.*;
+import javax.swing.ProgressMonitor;
 
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;

File: jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java
Patch:
@@ -6,8 +6,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.api.ICodeWriter;
 import jadx.api.JavaClass;
-import jadx.core.codegen.CodeWriter;
 import jadx.gui.JadxWrapper;
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.CodeLinesInfo;
@@ -77,7 +77,7 @@ public static void refreshIndex(CacheObject cache, JavaClass cls) {
 
 	@NotNull
 	protected static List<StringRef> splitLines(JavaClass cls) {
-		List<StringRef> lines = StringRef.split(cls.getCode(), CodeWriter.NL);
+		List<StringRef> lines = StringRef.split(cls.getCode(), ICodeWriter.NL);
 		int size = lines.size();
 		for (int i = 0; i < size; i++) {
 			lines.set(i, lines.get(i).trim());

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java
Patch:
@@ -12,6 +12,7 @@
 import org.jetbrains.annotations.Nullable;
 
 import jadx.api.ICodeInfo;
+import jadx.api.ICodeWriter;
 import jadx.api.ResourceFile;
 import jadx.api.ResourceFileContent;
 import jadx.api.ResourceType;
@@ -23,8 +24,6 @@
 import jadx.gui.utils.OverlayIcon;
 import jadx.gui.utils.UiUtils;
 
-import static jadx.core.codegen.CodeWriter.NL;
-
 public class JResource extends JLoadableNode implements Comparable<JResource> {
 	private static final long serialVersionUID = -201018424302612434L;
 
@@ -154,7 +153,7 @@ private ICodeInfo loadCurrentSingleRes(ResContainer rc) {
 						return ResourcesLoader.loadToCodeWriter(is);
 					});
 				} catch (Exception e) {
-					return new SimpleCodeInfo("Failed to load resource file:" + NL + Utils.getStackTrace(e));
+					return new SimpleCodeInfo("Failed to load resource file:" + ICodeWriter.NL + Utils.getStackTrace(e));
 				}
 
 			case DECODED_DATA:

File: jadx-gui/src/main/java/jadx/gui/ui/ImagePanel.java
Patch:
@@ -10,6 +10,7 @@
 
 import hu.kazocsaba.imageviewer.ImageViewer;
 
+import jadx.api.ICodeWriter;
 import jadx.api.ResourceFile;
 import jadx.api.ResourcesLoader;
 import jadx.core.utils.Utils;
@@ -18,8 +19,6 @@
 import jadx.gui.treemodel.JResource;
 import jadx.gui.ui.codearea.AbstractCodeArea;
 
-import static jadx.core.codegen.CodeWriter.NL;
-
 public class ImagePanel extends ContentPanel {
 	private static final long serialVersionUID = 4071356367073142688L;
 
@@ -32,7 +31,7 @@ public class ImagePanel extends ContentPanel {
 			add(imageViewer.getComponent());
 		} catch (Exception e) {
 			RSyntaxTextArea textArea = AbstractCodeArea.getDefaultArea(panel.getMainWindow());
-			textArea.setText("Image load error:" + NL + Utils.getStackTrace(e));
+			textArea.setText("Image load error:" + ICodeWriter.NL + Utils.getStackTrace(e));
 			add(textArea);
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java
Patch:
@@ -212,13 +212,13 @@ private void refreshSettings() {
 					extSet.add(ext);
 				}
 			}
-			ZipFile zipFile = getZipFile(cache.getJRoot());
-			traverseTree(cache.getJRoot(), zipFile); // reindex
 			try {
+				ZipFile zipFile = getZipFile(cache.getJRoot());
+				traverseTree(cache.getJRoot(), zipFile); // reindex
 				if (zipFile != null) {
 					zipFile.close();
 				}
-			} catch (IOException e) {
+			} catch (Exception e) {
 				e.printStackTrace();
 			}
 		}

File: jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java
Patch:
@@ -24,7 +24,7 @@ public static void registerBundledFonts() {
 	}
 
 	public static Font loadByStr(String fontDesc) {
-		String[] parts = fontDesc.split("-");
+		String[] parts = fontDesc.split("/");
 		if (parts.length != 3) {
 			throw new JadxRuntimeException("Unsupported font description format: " + fontDesc);
 		}
@@ -42,8 +42,8 @@ public static Font loadByStr(String fontDesc) {
 
 	public static String convertToStr(Font font) {
 		return font.getFontName()
-				+ '-' + convertFontStyleToString(font.getStyle())
-				+ '-' + font.getSize();
+				+ '/' + convertFontStyleToString(font.getStyle())
+				+ '/' + font.getSize();
 	}
 
 	public static String convertFontStyleToString(int style) {

File: jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaStatic.java
Patch:
@@ -61,7 +61,8 @@ public void test() {
 				.containsLines(2,
 						"return () -> {",
 						indent() + "return str;",
-						"};");
+						"};")
+				.containsOne("return Integer::parseInt;");
 	}
 
 	@Test

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally.java
Patch:
@@ -49,7 +49,7 @@ public void test() {
 		assertThat(code, containsOne("} catch (Exception e) {"));
 		assertThat(code, containsOne("e.printStackTrace();"));
 		assertThat(code, containsOne("} finally {"));
-		assertThat(code, containsOne("this.f = true;"));
+		// assertThat(code, containsOne("this.f = true;")); // TODO: fix registers in duplicated code
 		assertThat(code, containsOne("return this.f;"));
 	}
 }

File: jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java
Patch:
@@ -82,9 +82,11 @@ private static void processAars(List<Path> input, ConvertResult result) {
 				.filter(aarMatcher::matches)
 				.forEach(path -> ZipSecurity.readZipEntries(path.toFile(), (entry, in) -> {
 					try {
-						if (entry.getName().endsWith(".jar")) {
+						String entryName = entry.getName();
+						if (entryName.endsWith(".jar")) {
 							Path tempJar = saveInputStreamToFile(in, ".jar");
 							result.addTempPath(tempJar);
+							LOG.debug("Loading jar: {} ...", entryName);
 							convertJar(result, tempJar);
 						}
 					} catch (Exception e) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java
Patch:
@@ -30,8 +30,6 @@ public abstract class AbstractCodeArea extends RSyntaxTextArea {
 
 	private static final Logger LOG = LoggerFactory.getLogger(AbstractCodeArea.class);
 
-	public static final Color MARK_ALL_HIGHLIGHT_COLOR = Color.decode("#FFED89");
-
 	protected final ContentPanel contentPanel;
 	protected final JNode node;
 
@@ -45,7 +43,6 @@ public AbstractCodeArea(ContentPanel contentPanel) {
 		loadSettings();
 		JadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();
 		setLineWrap(settings.isCodeAreaLineWrap());
-		setMarkAllHighlightColor(MARK_ALL_HIGHLIGHT_COLOR);
 
 		JPopupMenu popupMenu = getPopupMenu();
 		popupMenu.addSeparator();

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorTheme.java
Patch:
@@ -10,7 +10,8 @@ public final class EditorTheme {
 					new EditorTheme("idea"),
 					new EditorTheme("vs"),
 					new EditorTheme("dark"),
-					new EditorTheme("monokai")
+					new EditorTheme("monokai"),
+					new EditorTheme("druid")
 			};
 
 	public static EditorTheme[] getAllThemes() {

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -448,7 +448,7 @@ JavaNode convertNode(Object obj) {
 		}
 		if (obj instanceof VariableNode) {
 			VariableNode varNode = (VariableNode) obj;
-			return new JavaVariable(getJavaClassByNode(varNode.getClassNode()), varNode);
+			return new JavaVariable(getJavaClassByNode(varNode.getClassNode().getTopParentClass()), varNode);
 		}
 		throw new JadxRuntimeException("Unexpected node type: " + obj);
 	}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -92,7 +92,6 @@ public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenExc
 			if (codeVar != null) {
 				VariableNode node = mth.getVariable(codeVar.getIndex());
 				if (node != null) {
-					node.useVar(code, codeVar);
 					code.attachAnnotation(node);
 				}
 			}
@@ -653,7 +652,6 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code) throws Codeg
 		if (insn.isSuper()) {
 			code.add("super");
 		} else if (insn.isThis()) {
-			code.attachAnnotation(mth.getParentClass());
 			code.add("this");
 		} else {
 			code.add("new ");

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -145,7 +145,8 @@ public JumpPosition getDefPosForNodeAtOffset(int offset) {
 			return null;
 		}
 		JNode jNode = convertJavaNode(foundNode);
-		return new JumpPosition(jNode.getRootClass(), pos.getLine());
+		return new JumpPosition(jNode.getRootClass(), pos.getLine())
+				.setPrecise(JumpPosition.getDefPos(jNode));
 	}
 
 	private JNode convertJavaNode(JavaNode javaNode) {

File: jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java
Patch:
@@ -64,7 +64,7 @@ private void addUsage(JNode jNode, JavaClass javaClass,
 		JavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(line);
 		StringRef codeLine = lines.get(line - 1);
 		JNode node = nodeCache.makeFrom(javaNodeByLine == null ? javaClass : javaNodeByLine);
-		CodeNode codeNode = new CodeNode(node, line, codeLine);
+		CodeNode codeNode = new CodeNode(node, line, codeLine).setPrecisePos(codePosition.getUsagePosition());
 		usageInfo.addUsage(codeNode);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java
Patch:
@@ -35,7 +35,9 @@ public Flowable<CodeNode> search(final SearchSettings searchSettings) {
 		return Flowable.create(emitter -> {
 			LOG.debug("Code search started: {} ...", searchSettings.getSearchString());
 			for (CodeNode node : values) {
-				if (isMatched(node.getLineStr(), searchSettings)) {
+				int pos = searchSettings.find(node.getLineStr());
+				node.setPos(pos);
+				if (pos > -1) {
 					emitter.onNext(node);
 				}
 				if (emitter.isCancelled()) {

File: jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java
Patch:
@@ -158,7 +158,7 @@ private int searchNext(FlowableEmitter<CodeNode> emitter, JavaNode javaClass, St
 		int lineStart = 1 + code.lastIndexOf(CodeWriter.NL, pos);
 		int lineEnd = code.indexOf(CodeWriter.NL, pos + searchSettings.getSearchString().length());
 		StringRef line = StringRef.subString(code, lineStart, lineEnd == -1 ? code.length() : lineEnd);
-		emitter.onNext(new CodeNode(nodeCache.makeFrom(javaClass), -pos, line.trim()));
+		emitter.onNext(new CodeNode(nodeCache.makeFrom(javaClass), -pos, line.trim()).setPos(pos));
 		return lineEnd;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java
Patch:
@@ -46,7 +46,6 @@ public final class CodeArea extends AbstractCodeArea {
 		CodeLinkGenerator codeLinkGenerator = new CodeLinkGenerator(this);
 		setLinkGenerator(codeLinkGenerator);
 		addMouseListener(new MouseAdapter() {
-			@SuppressWarnings("deprecation")
 			@Override
 			public void mouseClicked(MouseEvent e) {
 				if (e.getClickCount() % 2 == 0 || e.isControlDown()) {
@@ -60,6 +59,7 @@ public void mouseClicked(MouseEvent e) {
 		}
 	}
 
+	@SuppressWarnings("deprecation")
 	private void navToDecl(Point point, CodeLinkGenerator codeLinkGenerator) {
 		int offs = viewToModel(point);
 		JumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(CodeArea.this, offs);

File: jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java
Patch:
@@ -39,6 +39,7 @@ private FillArrayData(Object data, int size, int elemSize) {
 	private static ArgType getElementType(int elementWidthUnit) {
 		switch (elementWidthUnit) {
 			case 1:
+			case 0:
 				return ONE_BYTE_TYPE;
 			case 2:
 				return TWO_BYTES_TYPE;

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -313,7 +313,8 @@ private void preProcessClass(ClassNode cls) {
 		} else {
 			if (!clsMap.containsKey(classInfo)) {
 				String clsShortName = classInfo.getShortName();
-				boolean badName = shouldRename(clsShortName) || reservedClsNames.contains(clsShortName);
+				boolean badName = shouldRename(clsShortName)
+						|| (args.isRenameValid() && reservedClsNames.contains(clsShortName));
 				makeClsAlias(cls, badName);
 			}
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -58,6 +58,7 @@ public abstract class CommonSearchDialog extends JDialog {
 
 	protected String highlightText;
 	protected boolean highlightTextCaseInsensitive = false;
+	protected boolean highlightTextUseRegex = false;
 
 	public CommonSearchDialog(MainWindow mainWindow) {
 		super(mainWindow);
@@ -466,6 +467,7 @@ private Component makeCell(JNode node, int column) {
 				SearchContext searchContext = new SearchContext(highlightText);
 				searchContext.setMatchCase(!highlightTextCaseInsensitive);
 				searchContext.setMarkAll(true);
+				searchContext.setRegularExpression(highlightTextUseRegex);
 				SearchEngine.markAll(textArea, searchContext);
 			}
 			return textArea;

File: jadx-gui/src/main/java/jadx/gui/ui/JPackagePopupMenu.java
Patch:
@@ -79,7 +79,7 @@ private String concat(List<String> parts, int n) {
 
 	private void rename(JPackage pkg) {
 		LOG.debug("Renaming package: fullName={}, name={}", pkg.getFullName(), pkg.getName());
-		new RenameDialog(mainWindow, pkg).setVisible(true);
+		RenameDialog.rename(mainWindow, pkg);
 	}
 
 	private List<String> splitPackage(String rawPackage) {

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -655,8 +655,7 @@ private void nodeClickAction(@Nullable Object obj) {
 	}
 
 	private void rename(JNode node) {
-		RenameDialog renameDialog = new RenameDialog(this, node);
-		renameDialog.setVisible(true);
+		RenameDialog.rename(this, node);
 	}
 
 	private void treeRightClickAction(MouseEvent e) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java
Patch:
@@ -33,8 +33,7 @@ public void actionPerformed(ActionEvent e) {
 			LOG.info("node == null!");
 			return;
 		}
-		RenameDialog renameDialog = new RenameDialog(codeArea.getMainWindow(), node);
-		renameDialog.setVisible(true);
+		RenameDialog.rename(codeArea.getMainWindow(), node);
 	}
 
 	@Nullable

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -150,6 +150,7 @@ private void initUI() {
 
 		Container contentPane = getContentPane();
 		JScrollPane scrollPane = new JScrollPane(panel);
+		scrollPane.getVerticalScrollBar().setUnitIncrement(16);
 		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
 		contentPane.add(scrollPane, BorderLayout.CENTER);
 		contentPane.add(buttonPane, BorderLayout.PAGE_END);

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java
Patch:
@@ -11,7 +11,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import jadx.gui.utils.JumpPosition;
+import jadx.api.JavaNode;
 
 class MouseHoverHighlighter extends MouseMotionAdapter {
 	private static final Logger LOG = LoggerFactory.getLogger(MouseHoverHighlighter.class);
@@ -50,8 +50,8 @@ private boolean addHighlight(MouseEvent e) {
 				// don't repaint highlight
 				return true;
 			}
-			JumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(codeArea, tokenOffset);
-			if (jump == null) {
+			JavaNode nodeAtOffset = codeLinkGenerator.getNodeAtOffset(codeArea, tokenOffset);
+			if (nodeAtOffset == null) {
 				return false;
 			}
 			removeHighlight();

File: jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java
Patch:
@@ -60,7 +60,7 @@ public static void main(String[] args) throws Exception {
 		set.loadFrom(root);
 		set.save(output);
 
-		LOG.info("Output: {}, file size: {}B", output, output.toFile().length());
+		LOG.info("Output: {}", output);
 		LOG.info("done");
 	}
 }

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -81,6 +81,7 @@ public static List<IDexTreeVisitor> getFallbackPassesList() {
 	public static List<IDexTreeVisitor> getPreDecompilePassesList() {
 		List<IDexTreeVisitor> passes = new ArrayList<>();
 		passes.add(new SignatureProcessor());
+		passes.add(new OverrideMethodVisitor());
 		passes.add(new RenameVisitor());
 		passes.add(new UsageInfoVisitor());
 		return passes;
@@ -107,7 +108,6 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 		passes.add(new BlockFinish());
 
 		passes.add(new AttachMethodDetails());
-		passes.add(new OverrideMethodVisitor());
 
 		passes.add(new SSATransform());
 		passes.add(new MoveInlineVisitor());

File: jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java
Patch:
@@ -91,7 +91,7 @@ public IMethodDetails getMethodDetails(MethodInfo methodInfo) {
 				}
 			}
 		}
-		// all other methods in known ClspClass are 'simple'
+		// unknown method
 		return new SimpleMethodDetails(methodInfo);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -97,5 +97,6 @@ public class AType<T extends IAttribute> {
 			FIELD_INIT,
 			FIELD_REPLACE,
 			METHOD_INLINE,
+			METHOD_OVERRIDE,
 			SKIP_MTH_ARGS));
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/IMethodDetails.java
Patch:
@@ -22,6 +22,8 @@ public interface IMethodDetails extends IAttribute {
 
 	boolean isVarArg();
 
+	int getRawAccessFlags();
+
 	@Override
 	default AType<IMethodDetails> getType() {
 		return AType.METHOD_DETAILS;

File: jadx-core/src/main/java/jadx/core/dex/visitors/AttachMethodDetails.java
Patch:
@@ -17,8 +17,7 @@
 		runBefore = {
 				CodeShrinkVisitor.class,
 				TypeInferenceVisitor.class,
-				MethodInvokeVisitor.class,
-				OverrideMethodVisitor.class
+				MethodInvokeVisitor.class
 		}
 )
 public class AttachMethodDetails extends AbstractVisitor {

File: jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java
Patch:
@@ -23,7 +23,7 @@ public synchronized void put(CodeNode value) {
 		values.add(value);
 	}
 
-	public void removeForCls(JavaClass cls) {
+	public synchronized void removeForCls(JavaClass cls) {
 		values.removeIf(v -> v.getJavaNode().getTopParentClass().equals(cls));
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -53,7 +53,7 @@
 @JadxVisitor(
 		name = "EnumVisitor",
 		desc = "Restore enum classes",
-		runAfter = { CodeShrinkVisitor.class, ModVisitor.class },
+		runAfter = { CodeShrinkVisitor.class, ModVisitor.class, ReSugarCode.class },
 		runBefore = { ExtractFieldInit.class }
 )
 public class EnumVisitor extends AbstractVisitor {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java
Patch:
@@ -91,11 +91,11 @@ private static boolean process(MethodNode mth, List<InsnNode> instructions, int
 	 */
 	private static boolean processNewArray(MethodNode mth, NewArrayNode newArrayInsn,
 			List<InsnNode> instructions, InsnRemover remover) {
-		InsnArg arrLenArg = newArrayInsn.getArg(0);
-		if (!arrLenArg.isLiteral()) {
+		Object arrayLenConst = InsnUtils.getConstValueByArg(mth.root(), newArrayInsn.getArg(0));
+		if (!(arrayLenConst instanceof LiteralArg)) {
 			return false;
 		}
-		int len = (int) ((LiteralArg) arrLenArg).getLiteral();
+		int len = (int) ((LiteralArg) arrayLenConst).getLiteral();
 		if (len == 0) {
 			return false;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java
Patch:
@@ -339,7 +339,7 @@ private static boolean removeUnreachableBlocks(MethodNode mth) {
 		Set<BlockNode> toRemove = new LinkedHashSet<>();
 		for (BlockNode block : mth.getBasicBlocks()) {
 			if (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {
-				collectSuccessors(block, toRemove);
+				collectSuccessors(block, mth.getEnterBlock(), toRemove);
 			}
 		}
 		if (toRemove.isEmpty()) {
@@ -390,15 +390,15 @@ private static boolean canRemoveBlock(BlockNode block) {
 				&& !block.contains(AFlag.MTH_ENTER_BLOCK);
 	}
 
-	private static void collectSuccessors(BlockNode startBlock, Set<BlockNode> toRemove) {
+	private static void collectSuccessors(BlockNode startBlock, BlockNode methodEnterBlock, Set<BlockNode> toRemove) {
 		Deque<BlockNode> stack = new ArrayDeque<>();
 		stack.add(startBlock);
 		while (!stack.isEmpty()) {
 			BlockNode block = stack.pop();
 			if (!toRemove.contains(block)) {
 				toRemove.add(block);
 				for (BlockNode successor : block.getSuccessors()) {
-					if (toRemove.containsAll(successor.getPredecessors())) {
+					if (successor != methodEnterBlock && toRemove.containsAll(successor.getPredecessors())) {
 						stack.push(successor);
 					}
 				}

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java
Patch:
@@ -4,7 +4,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;
@@ -23,11 +22,11 @@ public void test() {
 		}
 	}
 
-	@NotYetImplemented
 	@Test
 	public void test() {
 		assertThat(getClassNode(TestCls.class))
 				.code()
-				.containsOnlyOnce("while");
+				.containsOne("while")
+				.containsLines(2, "while (this.it.hasNext() && this.it.next() != null) {", "}");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -594,6 +594,8 @@ private BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNo
 				List<BlockNode> list = BlockUtils.buildSimplePath(exitBlock);
 				if (list.isEmpty() || !list.get(list.size() - 1).getSuccessors().isEmpty()) {
 					stack.addExit(exitBlock);
+					// we can still try using this as an exit block to make sure it's visited.
+					exit = exitBlock;
 				}
 			}
 		}

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
@@ -34,7 +33,6 @@ int test() {
 	}
 
 	@Test
-	@NotYetImplemented
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-core/src/main/java/jadx/core/utils/StringUtils.java
Patch:
@@ -217,9 +217,9 @@ private static String escapeWhiteSpaceChar(char c) {
 	}
 
 	private static void commonEscapeAndAppend(StringBuilder sb, char c) {
-		String replace = escapeXmlChar(c);
+		String replace = escapeWhiteSpaceChar(c);
 		if (replace == null) {
-			replace = escapeWhiteSpaceChar(c);
+			replace = escapeXmlChar(c);
 		}
 		if (replace != null) {
 			sb.append(replace);

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -9,6 +9,7 @@ protected ParserConstants() {
 	}
 
 	protected static final String ANDROID_NS_URL = "http://schemas.android.com/apk/res/android";
+	protected static final String ANDROID_NS_VALUE = "android";
 
 	/**
 	 * Chunk types

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -110,7 +110,7 @@ public boolean addDefinition(CodeWriter code) {
 		if (Consts.DEBUG) {
 			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");
 		}
-		if (clsAccFlags.isInterface() && !mth.isNoCode()) {
+		if (clsAccFlags.isInterface() && !mth.isNoCode() && !mth.getAccessFlags().isStatic()) {
 			// add 'default' for method with code in interface
 			code.add("default ");
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -173,7 +173,7 @@ private void updateObfuscatedFiles(ResTableParser parser, List<ResourceFile> res
 		long start = System.currentTimeMillis();
 		int renamedCount = 0;
 		ResourceStorage resStorage = parser.getResStorage();
-		ValuesParser valuesParser = new ValuesParser(this, parser.getStrings(), resStorage.getResourcesNames());
+		ValuesParser valuesParser = new ValuesParser(parser.getStrings(), resStorage.getResourcesNames());
 		Map<String, ResourceEntry> entryNames = new HashMap<>();
 		for (ResourceEntry resEntry : resStorage.getResources()) {
 			String val = valuesParser.getSimpleValueString(resEntry);

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -117,7 +117,7 @@ void decode() throws IOException {
 					break;
 				case RES_STRING_POOL_TYPE:
 					strings = parseStringPoolNoType();
-					valuesParser = new ValuesParser(rootNode, strings, resNames);
+					valuesParser = new ValuesParser(strings, resNames);
 					break;
 				case RES_XML_RESOURCE_MAP_TYPE:
 					parseResourceMap();

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -73,7 +73,7 @@ public void decode(InputStream inputStream) throws IOException {
 	public ResContainer decodeFiles(InputStream inputStream) throws IOException {
 		decode(inputStream);
 
-		ValuesParser vp = new ValuesParser(root, strings, resStorage.getResourcesNames());
+		ValuesParser vp = new ValuesParser(strings, resStorage.getResourcesNames());
 		ResXmlGen resGen = new ResXmlGen(resStorage, vp);
 
 		ICodeInfo content = makeXmlDump();

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -92,6 +92,8 @@ public class AType<T extends IAttribute> {
 	public static final AType<RegDebugInfoAttr> REG_DEBUG_INFO = new AType<>();
 
 	public static final Set<AType<?>> SKIP_ON_UNLOAD = new HashSet<>(Arrays.asList(
+			SOURCE_FILE,
+			FIELD_INIT,
 			FIELD_REPLACE,
 			METHOD_INLINE,
 			SKIP_MTH_ARGS));

File: jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java
Patch:
@@ -18,7 +18,6 @@ public void test() {
 				.doesNotContain("z2 | 2")
 				.containsOne("(z2 ? 1 : 0) | 2")
 				.containsOne("if (z2 && formatCurrency != null) {")
-				.containsOne("i = 1;")
-				.containsOne("spannable = null;");
+				.containsOne("i = 1;");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -69,8 +69,7 @@ private static void processBlocksTree(MethodNode mth) {
 			updateExitBlocks(mth);
 
 			if (i++ > 100) {
-				mth.addWarn("CFG modification limit reached, blocks count: " + mth.getBasicBlocks().size());
-				break;
+				throw new JadxRuntimeException("CFG modification limit reached, blocks count: " + mth.getBasicBlocks().size());
 			}
 		}
 		checkForUnreachableBlocks(mth);

File: jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java
Patch:
@@ -103,7 +103,7 @@ private void parseMethodSignature(MethodNode mth) {
 		}
 		try {
 			List<ArgType> typeParameters = sp.consumeGenericTypeParameters();
-			List<ArgType> parsedArgTypes = sp.consumeMethodArgs();
+			List<ArgType> parsedArgTypes = sp.consumeMethodArgs(mth.getMethodInfo().getArgsCount());
 			ArgType parsedRetType = sp.consumeType();
 
 			if (!validateParsedType(parsedRetType, mth.getMethodInfo().getReturnType())) {

File: jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java
Patch:
@@ -17,6 +17,8 @@ public void test() {
 				.doesNotContain("z2 == 0")
 				.doesNotContain("z2 | 2")
 				.containsOne("(z2 ? 1 : 0) | 2")
-				.containsOne("if (z2 && formatCurrency != null) {");
+				.containsOne("if (z2 && formatCurrency != null) {")
+				.containsOne("i = 1;")
+				.containsOne("spannable = null;");
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -843,7 +843,7 @@ private void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) th
 		InsnArg first = insn.getArg(0);
 		InsnArg second = insn.getArg(1);
 		ConditionGen condGen = new ConditionGen(this);
-		if (first.equals(LiteralArg.TRUE) && second.equals(LiteralArg.FALSE)) {
+		if (first.isTrue() && second.isFalse()) {
 			condGen.add(code, insn.getCondition());
 		} else {
 			condGen.wrap(code, insn.getCondition());

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java
Patch:
@@ -4,7 +4,6 @@
 
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.args.InsnArg;
-import jadx.core.dex.instructions.args.LiteralArg;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.regions.conditions.IfCondition;
@@ -18,7 +17,7 @@ public TernaryInsn(IfCondition condition, RegisterArg result, InsnArg th, InsnAr
 		this();
 		setResult(result);
 
-		if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {
+		if (th.isFalse() && els.isTrue()) {
 			// inverted
 			this.condition = IfCondition.invert(condition);
 			addArg(els);

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/Compare.java
Patch:
@@ -39,8 +39,8 @@ public Compare invert() {
 	 * Change 'a != false' to 'a == true'
 	 */
 	public void normalize() {
-		if (getOp() == IfOp.NE && getB().isLiteral() && getB().equals(LiteralArg.FALSE)) {
-			insn.changeCondition(IfOp.EQ, getA(), LiteralArg.TRUE);
+		if (getOp() == IfOp.NE && getB().isFalse()) {
+			insn.changeCondition(IfOp.EQ, getA(), LiteralArg.litTrue());
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java
Patch:
@@ -153,7 +153,7 @@ public static IfCondition simplify(IfCondition cond) {
 			if (i != null) {
 				return i;
 			}
-			if (c.getOp() == IfOp.EQ && c.getB().isLiteral() && c.getB().equals(LiteralArg.FALSE)) {
+			if (c.getOp() == IfOp.EQ && c.getB().isFalse()) {
 				cond = not(new IfCondition(c.invert()));
 			} else {
 				c.normalize();
@@ -234,8 +234,8 @@ private static IfCondition simplifyCmpOp(Compare c) {
 						Mode mode = isTrue && arithOp == ArithOp.OR
 								|| !isTrue && arithOp == ArithOp.AND ? Mode.OR : Mode.AND;
 
-						IfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.FALSE);
-						IfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.FALSE);
+						IfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.litFalse());
+						IfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.litFalse());
 						return new IfCondition(mode,
 								Arrays.asList(new IfCondition(new Compare(if1)),
 										new IfCondition(new Compare(if2))));

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -253,16 +253,16 @@ private static void fixPrimitiveCast(MethodNode mth, BlockNode block, int i, Ins
 	}
 
 	public static TernaryInsn makeBooleanConvertInsn(RegisterArg result, InsnArg castArg, ArgType type) {
-		InsnArg zero = new LiteralArg(0, type);
+		InsnArg zero = LiteralArg.make(0, type);
 		long litVal = 1;
 		if (type == ArgType.DOUBLE) {
 			litVal = DOUBLE_TO_BITS;
 		} else if (type == ArgType.FLOAT) {
 			litVal = FLOAT_TO_BITS;
 		}
-		InsnArg one = new LiteralArg(litVal, type);
+		InsnArg one = LiteralArg.make(litVal, type);
 
-		IfNode ifNode = new IfNode(IfOp.EQ, -1, castArg, LiteralArg.TRUE);
+		IfNode ifNode = new IfNode(IfOp.EQ, -1, castArg, LiteralArg.litTrue());
 		IfCondition condition = IfCondition.fromIfNode(ifNode);
 		return new TernaryInsn(condition, result, one, zero);
 	}

File: jadx-core/src/main/java/jadx/core/utils/EncodedValueUtils.java
Patch:
@@ -25,7 +25,7 @@ public static Object convertToConstValue(RootNode root, EncodedValue encodedValu
 			case ENCODED_NULL:
 				return InsnArg.lit(0, ArgType.OBJECT);
 			case ENCODED_BOOLEAN:
-				return Boolean.TRUE.equals(value) ? LiteralArg.TRUE : LiteralArg.FALSE;
+				return Boolean.TRUE.equals(value) ? LiteralArg.litTrue() : LiteralArg.litFalse();
 			case ENCODED_BYTE:
 				return InsnArg.lit((Byte) value, ArgType.BYTE);
 			case ENCODED_SHORT:

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -67,7 +67,7 @@ public enum AFlag {
 	 */
 	EXPLICIT_PRIMITIVE_TYPE,
 	EXPLICIT_CAST,
-	SOFT_CAST, // synthetic cast to help type inference
+	SOFT_CAST, // synthetic cast to help type inference (allow unchecked casts for generics)
 
 	INCONSISTENT_CODE, // warning about incorrect decompilation
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -29,7 +29,6 @@
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.InsnWrapArg;
-import jadx.core.dex.instructions.args.LiteralArg;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.instructions.args.SSAVar;
 import jadx.core.dex.instructions.mods.ConstructorInsn;
@@ -209,7 +208,7 @@ private List<EnumField> extractEnumFieldsFromInsn(ClassNode cls, BlockNode stati
 
 			case NEW_ARRAY:
 				InsnArg arg = wrappedInsn.getArg(0);
-				if (arg.isLiteral() && ((LiteralArg) arg).getLiteral() == 0) {
+				if (arg.isZeroLiteral()) {
 					// empty enum
 					return Collections.emptyList();
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -260,8 +260,7 @@ private static void simplifyIf(IfNode insn) {
 		if (f.isInsnWrap()) {
 			InsnNode wi = ((InsnWrapArg) f).getWrapInsn();
 			if (wi.getType() == InsnType.CMP_L || wi.getType() == InsnType.CMP_G) {
-				if (insn.getArg(1).isLiteral()
-						&& ((LiteralArg) insn.getArg(1)).getLiteral() == 0) {
+				if (insn.getArg(1).isZeroLiteral()) {
 					insn.changeCondition(insn.getOp(), wi.getArg(0), wi.getArg(1));
 				} else {
 					LOG.warn("TODO: cmp {}", insn);

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -96,7 +96,7 @@ private static ResContainer loadContent(JadxDecompiler jadxRef, ResourceFile rf,
 			case MANIFEST:
 			case XML:
 				ICodeInfo content = jadxRef.getXmlParser().parse(inputStream);
-				return ResContainer.textResource(rf.getOriginalName(), content);
+				return ResContainer.textResource(rf.getDeobfName(), content);
 
 			case ARSC:
 				return new ResTableParser(jadxRef.getRoot()).decodeFiles(inputStream);

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -586,7 +586,7 @@ public void setLoadStage(LoadStage loadStage) {
 	public void reloadAtCodegenStage() {
 		ClassNode topCls = this.getTopParentClass();
 		if (topCls.getLoadStage() == LoadStage.CODEGEN_STAGE) {
-			throw new JadxRuntimeException("Class not yet loaded at codegen stage");
+			throw new JadxRuntimeException("Class not yet loaded at codegen stage: " + topCls);
 		}
 		topCls.add(AFlag.RELOAD_AT_CODEGEN_STAGE);
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java
Patch:
@@ -57,15 +57,15 @@ private void processInvokeInsn(MethodNode mth, BlockNode block, InvokeNode insn)
 			MethodInlineAttr mia = MarkMethodsForInline.process(callMth);
 			if (mia == null) {
 				// method not yet loaded => will retry at codegen stage
-				mth.getParentClass().reloadAtCodegenStage();
+				callMth.getParentClass().reloadAtCodegenStage();
 				return;
 			}
 			if (mia.notNeeded()) {
 				return;
 			}
 			inlineMethod(mth, callMth, mia, block, insn);
 		} catch (Exception e) {
-			throw new JadxRuntimeException("Failed to process method for inline", e);
+			throw new JadxRuntimeException("Failed to process method for inline: " + callMthInfo, e);
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -88,7 +88,9 @@
 import jadx.gui.settings.JadxSettingsWindow;
 import jadx.gui.treemodel.ApkSignature;
 import jadx.gui.treemodel.JClass;
+import jadx.gui.treemodel.JField;
 import jadx.gui.treemodel.JLoadableNode;
+import jadx.gui.treemodel.JMethod;
 import jadx.gui.treemodel.JNode;
 import jadx.gui.treemodel.JPackage;
 import jadx.gui.treemodel.JResource;
@@ -614,7 +616,7 @@ private void treeRightClickAction(MouseEvent e) {
 		if (obj instanceof JPackage) {
 			JPackagePopupMenu menu = new JPackagePopupMenu(this, (JPackage) obj);
 			menu.show(e.getComponent(), e.getX(), e.getY());
-		} else if (obj != null) {
+		} else if (obj instanceof JClass || obj instanceof JField || obj instanceof JMethod) {
 			JPopupMenu menu = new JPopupMenu();
 			JMenuItem jmi = new JMenuItem(NLS.str("popup.rename"));
 			jmi.addActionListener(action -> rename(obj));

File: jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java
Patch:
@@ -34,7 +34,7 @@ public static void main(String[] args) throws IOException {
 			usage();
 			System.exit(1);
 		}
-		List<Path> inputPaths = Stream.of(args).map(s -> Paths.get(s)).collect(Collectors.toList());
+		List<Path> inputPaths = Stream.of(args).map(Paths::get).collect(Collectors.toList());
 		Path output = inputPaths.remove(0);
 
 		JadxPluginManager pluginManager = new JadxPluginManager();

File: jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java
Patch:
@@ -25,7 +25,7 @@ public class HeapUsageBar extends JProgressBar {
 
 	private static final Logger LOG = LoggerFactory.getLogger(HeapUsageBar.class);
 
-	private static final double GB = 1024 * 1024 * 1024;
+	private static final double GB = 1024 * 1024 * 1024d;
 
 	private static final Color GREEN = new Color(0, 180, 0);
 	private static final Color RED = new Color(200, 0, 0);

File: jadx-gui/src/main/java/jadx/gui/ui/JPackagePopupMenu.java
Patch:
@@ -87,8 +87,9 @@ private List<String> splitPackage(String rawPackage) {
 	}
 
 	private String getRawPackage(JPackage pkg) {
-		for (JClass cls : pkg.getClasses()) {
-			return cls.getRootClass().getCls().getClassNode().getClassInfo().getPackage();
+		List<JClass> classes = pkg.getClasses();
+		if (!classes.isEmpty()) {
+			return classes.get(0).getRootClass().getCls().getClassNode().getClassInfo().getPackage();
 		}
 		for (JPackage innerPkg : pkg.getInnerPackages()) {
 			String rawPackage = getRawPackage(innerPkg);

File: jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java
Patch:
@@ -159,13 +159,13 @@ private List<String> updateDeobfMap(List<String> deobfMap, String alias) {
 		int i = 0;
 		while (i < deobfMap.size()) {
 			if (deobfMap.get(i).startsWith(id)) {
-				LOG.debug("updateDeobfMap(): Removing entry " + deobfMap.get(i));
+				LOG.debug("updateDeobfMap(): Removing entry {}", deobfMap.get(i));
 				deobfMap.remove(i);
 			} else {
 				i++;
 			}
 		}
-		LOG.debug("updateDeobfMap(): Placing alias = " + alias);
+		LOG.debug("updateDeobfMap(): Placing alias = {}", alias);
 		deobfMap.add(alias);
 		return deobfMap;
 	}
@@ -272,7 +272,7 @@ private void refreshJClass(JClass cls) {
 		try {
 			cls.reload();
 			IndexJob.refreshIndex(cache, cls.getCls());
-		} catch (Throwable e) {
+		} catch (Exception e) {
 			LOG.error("Failed to reload class: {}", cls, e);
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java
Patch:
@@ -155,7 +155,7 @@ static void append(StringBuilder str, String name, String value) {
 
 	public static String getThumbPrint(X509Certificate cert, String type)
 			throws NoSuchAlgorithmException, CertificateEncodingException {
-		MessageDigest md = MessageDigest.getInstance(type);
+		MessageDigest md = MessageDigest.getInstance(type); // lgtm [java/weak-cryptographic-algorithm]
 		byte[] der = cert.getEncoded();
 		md.update(der);
 		byte[] digest = md.digest();

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -1116,6 +1116,7 @@ private void closeWindow() {
 		settings.setMainWindowExtendedState(getExtendedState());
 		cancelBackgroundJobs();
 		wrapper.close();
+		heapUsageBar.reset();
 		dispose();
 
 		FileUtils.deleteTempRootDir();

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -512,7 +512,7 @@ public void initTree() {
 	}
 
 	private void clearTree() {
-		tabbedPane.closeAllTabs();
+		tabbedPane.reset();
 		resetCache();
 		treeRoot = null;
 		treeModel.setRoot(null);

File: jadx-core/src/main/java/jadx/api/ResourceFile.java
Patch:
@@ -72,7 +72,7 @@ void setZipRef(ZipRef zipRef) {
 
 	public void setAlias(ResourceEntry ri) {
 		int index = name.lastIndexOf('.');
-		deobfName = String.format("%s%s/%s%s",
+		deobfName = String.format("res/%s%s/%s%s",
 				ri.getTypeName(),
 				ri.getConfig(),
 				ri.getKeyName(),

File: jadx-core/src/main/java/jadx/api/ResourceFileContent.java
Patch:
@@ -12,6 +12,6 @@ public ResourceFileContent(String name, ResourceType type, ICodeInfo content) {
 
 	@Override
 	public ResContainer loadContent() {
-		return ResContainer.textResource(getName(), content);
+		return ResContainer.textResource(getDeobfName(), content);
 	}
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java
Patch:
@@ -30,7 +30,7 @@ public static ResContainer decodedData(String name, byte[] data) {
 	}
 
 	public static ResContainer resourceFileLink(ResourceFile resFile) {
-		return new ResContainer(resFile.getName(), Collections.emptyList(), resFile, DataType.RES_LINK);
+		return new ResContainer(resFile.getDeobfName(), Collections.emptyList(), resFile, DataType.RES_LINK);
 	}
 
 	public static ResContainer resourceTable(String name, List<ResContainer> subFiles, ICodeInfo rootContent) {

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -211,7 +211,7 @@ private void addSimpleValue(CodeWriter cw, String typeName, String itemTag, Stri
 
 	private String getFileName(ResourceEntry ri) {
 		StringBuilder sb = new StringBuilder();
-		String qualifiers = ri.getConfig().getQualifiers();
+		String qualifiers = ri.getConfig();
 		sb.append("res/values");
 		if (!qualifiers.isEmpty()) {
 			sb.append(qualifiers);

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -243,7 +243,7 @@ private void insertResources(RootNode root) {
 			Integer id = entry.getKey();
 			String name = entry.getValue();
 			String[] parts = name.split("\\.");
-			resStorage.add(new ResourceEntry(id, "", parts[0], parts[1]));
+			resStorage.add(new ResourceEntry(id, "", parts[0], parts[1], ""));
 		}
 		root.processResources(resStorage);
 	}

File: jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java
Patch:
@@ -33,7 +33,7 @@ public class ApkSignature extends JNode {
 	public static ApkSignature getApkSignature(JadxWrapper wrapper) {
 		// Only show the ApkSignature node if an AndroidManifest.xml is present.
 		// Without a manifest the Google ApkVerifier refuses to work.
-		if (wrapper.getResources().stream().noneMatch(r -> "AndroidManifest.xml".equals(r.getName()))) {
+		if (wrapper.getResources().stream().noneMatch(r -> "AndroidManifest.xml".equals(r.getOriginalName()))) {
 			return null;
 		}
 		File openFile = wrapper.getOpenFile();

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java
Patch:
@@ -218,7 +218,7 @@ public String getSyntaxName() {
 				return SyntaxConstants.SYNTAX_STYLE_XML;
 
 			default:
-				String syntax = getSyntaxByExtension(resFile.getName());
+				String syntax = getSyntaxByExtension(resFile.getDeobfName());
 				if (syntax != null) {
 					return syntax;
 				}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -52,9 +52,9 @@ private List<JResource> getHierarchyResources(List<ResourceFile> resources) {
 		for (ResourceFile rf : resources) {
 			String rfName;
 			if (rf.getZipRef() != null) {
-				rfName = rf.getName();
+				rfName = rf.getDeobfName();
 			} else {
-				rfName = new File(rf.getName()).getName();
+				rfName = new File(rf.getDeobfName()).getName();
 			}
 			String[] parts = new File(rfName).getPath().split(splitPathStr);
 			JResource curRf = root;

File: jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java
Patch:
@@ -137,8 +137,8 @@ private void writeDeobfMapFile(Path deobfMapPath, List<String> deobfMap) throws
 		File tmpFile = File.createTempFile("deobf_tmp_", ".txt");
 		try (FileOutputStream fileOut = new FileOutputStream(tmpFile)) {
 			for (String entry : deobfMap) {
-				fileOut.write(entry.getBytes());
-				fileOut.write(System.lineSeparator().getBytes());
+				fileOut.write(entry.getBytes(StandardCharsets.UTF_8));
+				fileOut.write(System.lineSeparator().getBytes(StandardCharsets.UTF_8));
 			}
 		}
 		File oldMap = File.createTempFile("deobf_bak_", ".txt");

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -57,7 +57,7 @@ public void decompile() {
 		cls.decompile();
 	}
 
-	public synchronized void refresh() {
+	public synchronized void reload() {
 		listsLoaded = false;
 		cls.reloadCode();
 	}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -59,8 +59,8 @@ public synchronized void load() {
 		update();
 	}
 
-	public synchronized void refresh() {
-		cls.refresh();
+	public synchronized void reload() {
+		cls.reload();
 		loaded = true;
 		update();
 		cls.unload();

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexClassData.java
Patch:
@@ -29,7 +29,7 @@ public DexClassData(SectionReader sectionReader, AnnotationsParser annotationsPa
 
 	@Override
 	public IClassData copy() {
-		return new DexClassData(in.copy(), annotationsParser);
+		return new DexClassData(in.copy(), annotationsParser.copy());
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -25,7 +25,6 @@ public class JRoot extends JNode {
 
 	public JRoot(JadxWrapper wrapper) {
 		this.wrapper = wrapper;
-		update();
 	}
 
 	public final void update() {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java
Patch:
@@ -25,7 +25,7 @@ public void actionPerformed(ActionEvent e) {
 			LOG.info("node == null!");
 			return;
 		}
-		RenameDialog renameDialog = new RenameDialog(codeArea, node);
+		RenameDialog renameDialog = new RenameDialog(codeArea.getMainWindow(), node);
 		renameDialog.setVisible(true);
 	}
 

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -59,9 +59,7 @@ public void decompile() {
 
 	public synchronized void refresh() {
 		listsLoaded = false;
-		cls.unload();
-		cls.deepUnload();
-		cls.reRunDecompile();
+		cls.reloadCode();
 	}
 
 	public synchronized String getSmali() {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -75,4 +75,6 @@ public enum AFlag {
 	INCONSISTENT_CODE, // warning about incorrect decompilation
 
 	REQUEST_IF_REGION_OPTIMIZE, // run if region visitor again
+
+	DONT_UNLOAD_CLASS, // don't unload class after code generation (only for tests and debug!)
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java
Patch:
@@ -58,11 +58,10 @@ public boolean visit(ClassNode cls) throws JadxException {
 
 	@Override
 	public void visit(MethodNode mth) throws JadxException {
-		List<BlockNode> blocks = mth.getBasicBlocks();
-		if (blocks == null) {
+		if (mth.isNoCode()) {
 			return;
 		}
-		for (BlockNode block : blocks) {
+		for (BlockNode block : mth.getBasicBlocks()) {
 			if (block.contains(AFlag.DONT_GENERATE)) {
 				continue;
 			}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -73,4 +73,6 @@ public enum AFlag {
 	SOFT_CAST, // synthetic cast to help type inference
 
 	INCONSISTENT_CODE, // warning about incorrect decompilation
+
+	REQUEST_IF_REGION_OPTIMIZE, // run if region visitor again
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java
Patch:
@@ -26,7 +26,10 @@ public void visit(MethodNode mth) {
 		if (mth.isNoCode()) {
 			return;
 		}
+		process(mth);
+	}
 
+	public static void process(MethodNode mth) {
 		DepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);
 		DepthRegionTraversal.traverse(mth, PROCESS_IF_REGION_VISITOR);
 		DepthRegionTraversal.traverseIterative(mth, REMOVE_REDUNDANT_ELSE_VISITOR);

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -65,6 +65,7 @@ public abstract class ArgType {
 	public static final ArgType WIDE = unknown(PrimitiveType.LONG, PrimitiveType.DOUBLE);
 
 	public static final ArgType INT_FLOAT = unknown(PrimitiveType.INT, PrimitiveType.FLOAT);
+	public static final ArgType INT_BOOLEAN = unknown(PrimitiveType.INT, PrimitiveType.BOOLEAN);
 
 	protected int hash;
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/MethodTypeVarsAttr.java
Patch:
@@ -39,6 +39,9 @@ public AType<MethodTypeVarsAttr> getType() {
 
 	@Override
 	public String toString() {
+		if (this == EMPTY) {
+			return "TYPE_VARS: EMPTY";
+		}
 		return "TYPE_VARS: " + typeVars;
 	}
 }

File: jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java
Patch:
@@ -15,10 +15,10 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
 
 import static javax.tools.JavaCompiler.CompilationTask;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.fail;
 
 public class DynamicCompiler {
 
@@ -71,8 +71,8 @@ public Object invoke(ClassNode cls, String methodName, Class<?>[] types, Object[
 			Method reflMth = getMethod(inst, methodName, types);
 			assertNotNull(reflMth, "Failed to get method " + methodName + '(' + Arrays.toString(types) + ')');
 			return reflMth.invoke(inst, args);
-		} catch (Exception e) {
-			fail(e.getMessage(), e);
+		} catch (Throwable e) {
+			IntegrationTest.rethrow("Invoke error", e);
 			return null;
 		}
 	}

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -2,6 +2,7 @@
 
 public class Consts {
 	public static final boolean DEBUG = false;
+	public static final boolean DEBUG_WITH_ERRORS = false; // TODO: fix errors
 	public static final boolean DEBUG_USAGE = false;
 	public static final boolean DEBUG_TYPE_INFERENCE = false;
 	public static final boolean DEBUG_OVERLOADED_CASTS = false;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -22,7 +22,9 @@ public enum AFlag {
 
 	HIDDEN, // instruction used inside other instruction but not listed in args
 
-	RESTART_CODEGEN,
+	RESTART_CODEGEN, // codegen must be executed again
+	RELOAD_AT_CODEGEN_STAGE, // class can't be analyzed at 'process' stage => unload before 'codegen' stage
+
 	DONT_RENAME, // do not rename during deobfuscation
 	ADDED_TO_REGION,
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java
Patch:
@@ -83,7 +83,7 @@ private int fixClassVisibility(ClassNode cls) {
 		if (!accessFlags.isPublic()) {
 			// if class is used in inlinable method => make it public
 			for (MethodNode useMth : cls.getUseInMth()) {
-				boolean canInline = MethodInlineVisitor.canInline(useMth) || useMth.contains(AType.METHOD_INLINE);
+				boolean canInline = MarkMethodsForInline.canInline(useMth) || useMth.contains(AType.METHOD_INLINE);
 				if (canInline && !useMth.getUseIn().isEmpty()) {
 					return AccessFlags.PUBLIC;
 				}

File: jadx-core/src/main/java/jadx/core/utils/InsnRemover.java
Patch:
@@ -135,7 +135,7 @@ private static void removeSsaVar(MethodNode mth, SSAVar ssaVar) {
 			mth.removeSVar(ssaVar);
 			return;
 		}
-		if (Consts.DEBUG) { // TODO: enable this
+		if (Consts.DEBUG_WITH_ERRORS) {
 			throw new JadxRuntimeException("Can't remove SSA var, still in use, count: " + useCount + ", list:"
 					+ NL + "  " + ssaVar.getUseList().stream()
 							.map(arg -> arg + " from " + arg.getParentInsn())
@@ -172,7 +172,7 @@ private static void removeAll(List<InsnNode> insns, List<InsnNode> toRemove) {
 					break;
 				}
 			}
-			if (!found && Consts.DEBUG) { // TODO: enable this
+			if (!found && Consts.DEBUG_WITH_ERRORS) {
 				throw new JadxRuntimeException("Can't remove insn:"
 						+ NL + "  " + rem
 						+ NL + " not found in list:"

File: jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java
Patch:
@@ -14,7 +14,7 @@
 
 public final class FillArrayData extends InsnNode {
 
-	private static final ArgType ONE_BYTE_TYPE = ArgType.unknown(PrimitiveType.BOOLEAN, PrimitiveType.BYTE);
+	private static final ArgType ONE_BYTE_TYPE = ArgType.unknown(PrimitiveType.BYTE, PrimitiveType.BOOLEAN);
 	private static final ArgType TWO_BYTES_TYPE = ArgType.unknown(PrimitiveType.SHORT, PrimitiveType.CHAR);
 	private static final ArgType FOUR_BYTES_TYPE = ArgType.unknown(PrimitiveType.INT, PrimitiveType.FLOAT);
 	private static final ArgType EIGHT_BYTES_TYPE = ArgType.unknown(PrimitiveType.LONG, PrimitiveType.DOUBLE);

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -100,8 +100,8 @@ public void load() {
 		root.loadClasses(loadedInputs);
 		root.initClassPath();
 		root.loadResources(getResources());
-		root.initPasses();
 		root.runPreDecompileStage();
+		root.initPasses();
 	}
 
 	private void loadInputFiles() {

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -37,6 +37,7 @@
 import jadx.core.dex.visitors.ReSugarCode;
 import jadx.core.dex.visitors.RenameVisitor;
 import jadx.core.dex.visitors.ShadowFieldVisitor;
+import jadx.core.dex.visitors.SignatureProcessor;
 import jadx.core.dex.visitors.SimplifyVisitor;
 import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;
 import jadx.core.dex.visitors.blocksmaker.BlockFinish;
@@ -78,6 +79,7 @@ public static List<IDexTreeVisitor> getFallbackPassesList() {
 
 	public static List<IDexTreeVisitor> getPreDecompilePassesList() {
 		List<IDexTreeVisitor> passes = new ArrayList<>();
+		passes.add(new SignatureProcessor());
 		passes.add(new RenameVisitor());
 		passes.add(new UsageInfoVisitor());
 		return passes;

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestClassSignature.java
Patch:
@@ -15,6 +15,7 @@ public class TestClassSignature extends SmaliTest {
 
 	@Test
 	public void test() {
+		allowWarnInCode();
 		assertThat(getClassNodeFromSmali())
 				.code()
 				.containsOne("Incorrect class signature")

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -15,6 +15,7 @@ public enum AFlag {
 
 	DONT_WRAP,
 	DONT_INLINE,
+	DONT_INLINE_CONST,
 	DONT_GENERATE, // process as usual, but don't output to generated code
 	COMMENT_OUT, // process as usual, but comment insn in generated code
 	REMOVE, // can be completely removed

File: jadx-core/src/main/java/jadx/core/utils/Utils.java
Patch:
@@ -58,7 +58,7 @@ public static String listToString(Iterable<?> objects, String joiner) {
 		if (objects == null) {
 			return "";
 		}
-		return listToString(objects, joiner, Object::toString);
+		return listToString(objects, joiner, Objects::toString);
 	}
 
 	public static <T> String listToString(Iterable<T> objects, Function<T, String> toStr) {

File: jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java
Patch:
@@ -26,6 +26,8 @@ public boolean test(int i) {
 	public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
-				.containsOne("synchronized (this.obj) {");
+				.containsOne("synchronized (this.obj) {")
+				.containsOne("return call(this.obj, i);")
+				.containsOne("return getField() == null;");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.core.dex.regions;
 
-import java.util.LinkedList;
+import java.util.ArrayList;
 import java.util.List;
 
 import jadx.core.dex.nodes.IContainer;
@@ -10,7 +10,7 @@
 public final class SynchronizedRegion extends AbstractRegion {
 
 	private final InsnNode enterInsn;
-	private final List<InsnNode> exitInsns = new LinkedList<>();
+	private final List<InsnNode> exitInsns = new ArrayList<>();
 	private final Region region;
 
 	public SynchronizedRegion(IRegion parent, InsnNode insn) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java
Patch:
@@ -92,8 +92,9 @@ public Set<ArgType> getKnownTypeVarsAtMethod(MethodNode mth) {
 			return typeVarsAttr.getTypeVars();
 		}
 		Set<ArgType> typeVars = collectKnownTypeVarsAtMethod(mth);
-		mth.addAttr(new MethodTypeVarsAttr(typeVars));
-		return typeVars;
+		MethodTypeVarsAttr varsAttr = MethodTypeVarsAttr.build(typeVars);
+		mth.addAttr(varsAttr);
+		return varsAttr.getTypeVars();
 	}
 
 	private static Set<ArgType> collectKnownTypeVarsAtMethod(MethodNode mth) {

File: jadx-core/src/main/java/jadx/api/ResourceFile.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.io.File;
 
-import jadx.core.utils.files.ZipSecurity;
+import jadx.api.plugins.utils.ZipSecurity;
 import jadx.core.xmlgen.ResContainer;
 
 public class ResourceFile {

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -17,12 +17,12 @@
 
 import jadx.api.ResourceFile.ZipRef;
 import jadx.api.impl.SimpleCodeInfo;
+import jadx.api.plugins.utils.ZipSecurity;
 import jadx.core.codegen.CodeWriter;
 import jadx.core.utils.Utils;
 import jadx.core.utils.android.Res9patchStreamDecoder;
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.files.FileUtils;
-import jadx.core.utils.files.ZipSecurity;
 import jadx.core.xmlgen.ResContainer;
 import jadx.core.xmlgen.ResTableParser;
 

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -27,6 +27,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.api.plugins.utils.ZipSecurity;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.info.MethodInfo;
@@ -37,7 +38,6 @@
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
-import jadx.core.utils.files.ZipSecurity;
 
 import static jadx.core.utils.Utils.notEmpty;
 

File: jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java
Patch:
@@ -68,7 +68,7 @@ private JsonClass processCls(ClassNode cls, @Nullable ClassGen parentCodeGen) {
 
 		JsonClass jsonCls = new JsonClass();
 		jsonCls.setPkg(classInfo.getAliasPkg());
-		jsonCls.setDex(cls.getInputPath().toString());
+		jsonCls.setDex(cls.getInputFileName());
 		jsonCls.setName(classInfo.getFullName());
 		if (classInfo.hasAlias()) {
 			jsonCls.setAlias(classInfo.getAliasFullName());

File: jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java
Patch:
@@ -1,6 +1,5 @@
 package jadx.core.dex.nodes;
 
-import java.nio.file.Path;
 import java.util.Collections;
 import java.util.List;
 
@@ -88,8 +87,8 @@ public String typeName() {
 	}
 
 	@Override
-	public Path getInputPath() {
-		return parentClass.getInputPath();
+	public String getInputFileName() {
+		return parentClass.getInputFileName();
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/nodes/IDexNode.java
Patch:
@@ -1,12 +1,10 @@
 package jadx.core.dex.nodes;
 
-import java.nio.file.Path;
-
 public interface IDexNode {
 
 	String typeName();
 
 	RootNode root();
 
-	Path getInputPath();
+	String getInputFileName();
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -1,6 +1,5 @@
 package jadx.core.dex.nodes;
 
-import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -598,8 +597,8 @@ public String typeName() {
 	}
 
 	@Override
-	public Path getInputPath() {
-		return parentClass.getInputPath();
+	public String getInputFileName() {
+		return parentClass.getInputFileName();
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java
Patch:
@@ -8,11 +8,11 @@
 
 import jadx.api.ICodeInfo;
 import jadx.api.JadxArgs;
+import jadx.api.plugins.utils.ZipSecurity;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
-import jadx.core.utils.files.ZipSecurity;
 
 public class SaveCode {
 	private static final Logger LOG = LoggerFactory.getLogger(SaveCode.class);

File: jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java
Patch:
@@ -9,11 +9,11 @@
 
 import jadx.api.ResourceFile;
 import jadx.api.ResourcesLoader;
+import jadx.api.plugins.utils.ZipSecurity;
 import jadx.core.dex.visitors.SaveCode;
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
-import jadx.core.utils.files.ZipSecurity;
 
 public class ResourcesSaver implements Runnable {
 	private static final Logger LOG = LoggerFactory.getLogger(ResourcesSaver.class);

File: jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java
Patch:
@@ -100,7 +100,7 @@ private boolean processCls(@Nullable String mthPattern, ClassNode classNode) {
 			throw new JadxRuntimeException("Class process failed", e);
 		}
 		LOG.info("----------------------------------------------------------------");
-		LOG.info("Print class: {}, {}", classNode.getFullName(), classNode.getInputPath());
+		LOG.info("Print class: {} from: {}", classNode.getFullName(), classNode.getInputFileName());
 		if (mthPattern != null) {
 			printMethods(classNode, mthPattern);
 		} else {

File: jadx-plugins/jadx-dex-input/src/test/java/jadx/plugins/input/dex/utils/SmaliTestUtils.java
Patch:
@@ -10,7 +10,7 @@
 import org.jf.smali.Smali;
 import org.jf.smali.SmaliOptions;
 
-public class SmaliUtils {
+public class SmaliTestUtils {
 
 	public static Path compileSmaliFromResource(String res) {
 		try {

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.core.utils.files;
+package jadx.api.plugins.utils;
 
 import java.io.File;
 import java.io.IOException;

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -87,7 +87,7 @@ public void loadFromClstFile() throws IOException, DecodeException {
 		if (LOG.isDebugEnabled()) {
 			long time = System.currentTimeMillis() - startTime;
 			int methodsCount = Stream.of(classes).mapToInt(clspClass -> clspClass.getMethodsMap().size()).sum();
-			LOG.debug("Load class set in {}ms, classes: {}, methods: {}", time, classes.length, methodsCount);
+			LOG.debug("Clst file loaded in {}ms, classes: {}, methods: {}", time, classes.length, methodsCount);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -90,6 +90,7 @@ public void loadClasses(List<ILoadResult> loadedInputs) {
 		// sort classes by name, expect top classes before inner
 		classes.sort(Comparator.comparing(ClassNode::getFullName));
 		initInnerClasses();
+		LOG.debug("Classes loaded: {}", classes.size());
 	}
 
 	private void addDummyClass(IClassData classData, Exception exc) {

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -222,7 +222,7 @@ private static String bytesToHex(byte[] bytes) {
 		return new String(hexChars);
 	}
 
-	private static boolean isZipFile(File file) {
+	public static boolean isZipFile(File file) {
 		try (InputStream is = new FileInputStream(file)) {
 			byte[] headers = new byte[4];
 			int read = is.read(headers, 0, 4);

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java
Patch:
@@ -26,7 +26,8 @@ public class DexFileLoader {
 
 	public static List<DexReader> collectDexFiles(List<Path> pathsList) {
 		return pathsList.stream()
-				.map((Path path) -> loadDexFromPath(path, 0))
+				.map(path -> loadDexFromPath(path, 0))
+				.filter(list -> !list.isEmpty())
 				.flatMap(Collection::stream)
 				.peek(dr -> LOG.debug("Loading dex: {}", dr))
 				.collect(Collectors.toList());

File: jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/ILoadResult.java
Patch:
@@ -7,4 +7,6 @@ public interface ILoadResult extends Closeable {
 	void visitClasses(Consumer<IClassData> consumer);
 
 	void visitResources(Consumer<IResourceData> consumer);
+
+	boolean isEmpty();
 }

File: jadx-core/src/main/java/jadx/api/ICodeCache.java
Patch:
@@ -6,6 +6,8 @@ public interface ICodeCache {
 
 	void add(String clsFullName, ICodeInfo codeInfo);
 
+	void remove(String clsFullName);
+
 	@Nullable
 	ICodeInfo get(String clsFullName);
 }

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -699,12 +699,12 @@ private static void addClassUsageInfo(CodeWriter code, ClassNode cls) {
 		List<ClassNode> deps = cls.getDependencies();
 		code.startLine("// deps - ").add(Integer.toString(deps.size()));
 		for (ClassNode depCls : deps) {
-			code.startLine("//  ").add(depCls.getFullName());
+			code.startLine("//  ").add(depCls.getClassInfo().getFullName());
 		}
 		List<ClassNode> useIn = cls.getUseIn();
 		code.startLine("// use in - ").add(Integer.toString(useIn.size()));
 		for (ClassNode useCls : useIn) {
-			code.startLine("//  ").add(useCls.getFullName());
+			code.startLine("//  ").add(useCls.getClassInfo().getFullName());
 		}
 		List<MethodNode> useInMths = cls.getUseInMth();
 		code.startLine("// use in methods - ").add(Integer.toString(useInMths.size()));

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -345,6 +345,9 @@ public void load() {
 
 	@Override
 	public void unload() {
+		if (state == NOT_LOADED) {
+			return;
+		}
 		methods.forEach(MethodNode::unload);
 		innerClasses.forEach(ClassNode::unload);
 		fields.forEach(FieldNode::unloadAttributes);

File: jadx-core/src/main/java/jadx/core/dex/nodes/ICodeNode.java
Patch:
@@ -3,7 +3,7 @@
 import jadx.core.dex.attributes.IAttributeNode;
 import jadx.core.dex.info.AccessInfo;
 
-public interface ICodeNode extends IDexNode, IAttributeNode {
+public interface ICodeNode extends IDexNode, IAttributeNode, IUsageInfoNode {
 	AccessInfo getAccessFlags();
 
 	void setAccessFlags(AccessInfo newAccessFlags);

File: jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.core.clsp;
+package jadx.cli.clst;
 
 import java.io.IOException;
 import java.nio.file.Path;
@@ -16,6 +16,7 @@
 import jadx.api.plugins.JadxPluginManager;
 import jadx.api.plugins.input.JadxInputPlugin;
 import jadx.api.plugins.input.data.ILoadResult;
+import jadx.core.clsp.ClsSet;
 import jadx.core.dex.nodes.RootNode;
 
 /**
@@ -50,6 +51,7 @@ public static void main(String[] args) throws IOException {
 		ClsSet set = new ClsSet(root);
 		set.loadFrom(root);
 		set.save(output);
+
 		LOG.info("Output: {}, file size: {}B", output, output.toFile().length());
 		LOG.info("done");
 	}

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -10,6 +10,7 @@ public class Consts {
 	public static final String CLASS_STRING = "java.lang.String";
 	public static final String CLASS_CLASS = "java.lang.Class";
 	public static final String CLASS_THROWABLE = "java.lang.Throwable";
+	public static final String CLASS_EXCEPTION = "java.lang.Exception";
 	public static final String CLASS_ENUM = "java.lang.Enum";
 
 	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";

File: jadx-core/src/main/java/jadx/core/clsp/SimpleMethodDetails.java
Patch:
@@ -5,7 +5,6 @@
 
 import jadx.core.dex.info.MethodInfo;
 import jadx.core.dex.instructions.args.ArgType;
-import jadx.core.dex.nodes.GenericTypeParameter;
 import jadx.core.dex.nodes.IMethodDetails;
 
 public class SimpleMethodDetails implements IMethodDetails {
@@ -32,7 +31,7 @@ public List<ArgType> getArgTypes() {
 	}
 
 	@Override
-	public List<GenericTypeParameter> getTypeParameters() {
+	public List<ArgType> getTypeParameters() {
 		return Collections.emptyList();
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -185,7 +185,7 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {
 			CodeVar var;
 			if (ssaVar == null) {
 				// null for abstract or interface methods
-				var = CodeVar.fromMthArg(mthArg);
+				var = CodeVar.fromMthArg(mthArg, classGen.isFallbackMode());
 			} else {
 				var = ssaVar.getCodeVar();
 			}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -67,6 +67,7 @@ public enum AFlag {
 	 */
 	EXPLICIT_PRIMITIVE_TYPE,
 	EXPLICIT_CAST,
+	SOFT_CAST, // synthetic cast to help type inference
 
 	INCONSISTENT_CODE, // warning about incorrect decompilation
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/IMethodDetails.java
Patch:
@@ -16,7 +16,7 @@ public interface IMethodDetails extends IAttribute {
 
 	List<ArgType> getArgTypes();
 
-	List<GenericTypeParameter> getTypeParameters();
+	List<ArgType> getTypeParameters();
 
 	List<ArgType> getThrows();
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -153,11 +153,10 @@ public void initClassPath() {
 				ClspGraph newClsp = new ClspGraph(this);
 				newClsp.load();
 				newClsp.addApp(classes);
-
 				this.clsp = newClsp;
 			}
 		} catch (Exception e) {
-			throw new JadxRuntimeException("Error loading classpath", e);
+			throw new JadxRuntimeException("Error loading jadx class set", e);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -327,11 +327,11 @@ private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, Regi
 		ArgType iterableType = iterableArg.getType();
 		ArgType varType = iterVar.getType();
 		if (iterableType.isGeneric()) {
-			ArgType[] genericTypes = iterableType.getGenericTypes();
-			if (genericTypes == null || genericTypes.length != 1) {
+			List<ArgType> genericTypes = iterableType.getGenericTypes();
+			if (genericTypes == null || genericTypes.size() != 1) {
 				return false;
 			}
-			ArgType gType = genericTypes[0];
+			ArgType gType = genericTypes.get(0);
 			if (gType.equals(varType)) {
 				return true;
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -413,6 +413,7 @@ private static void markOneArgAsThis(RegisterArg arg) {
 			return;
 		}
 		arg.add(AFlag.THIS);
+		arg.add(AFlag.IMMUTABLE_TYPE);
 		// mark all moved 'this'
 		InsnNode parentInsn = arg.getParentInsn();
 		if (parentInsn != null

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundInvokeAssign.java
Patch:
@@ -38,7 +38,7 @@ public ArgType getType() {
 
 	private ArgType getReturnType(ArgType instanceType) {
 		ArgType resultGeneric = root.getTypeUtils().replaceClassGenerics(instanceType, genericReturnType);
-		if (resultGeneric != null) {
+		if (resultGeneric != null && !resultGeneric.isWildcard()) {
 			return resultGeneric;
 		}
 		return invokeNode.getCallMth().getReturnType();

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearchVarInfo.java
Patch:
@@ -86,7 +86,6 @@ public void setConstraints(List<ITypeConstraint> constraints) {
 	@Override
 	public String toString() {
 		StringBuilder sb = new StringBuilder();
-		sb.append("TypeSearchVarInfo{");
 		sb.append(var.toShortString());
 		if (typeResolved) {
 			sb.append(", resolved type: ").append(currentType);
@@ -95,7 +94,6 @@ public String toString() {
 			sb.append(", candidateTypes=").append(candidateTypes);
 			sb.append(", constraints=").append(constraints);
 		}
-		sb.append('}');
 		return sb.toString();
 	}
 }

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java
Patch:
@@ -347,7 +347,7 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {
 		public void skip(DexInsnData insn, SectionReader in) {
 			int elemSize = in.readUShort();
 			int size = in.readInt();
-			if (size == 1) {
+			if (elemSize == 1) {
 				in.skip(size + size % 2);
 			} else {
 				in.skip(size * elemSize);

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -4,6 +4,7 @@ public class Consts {
 	public static final boolean DEBUG = false;
 	public static final boolean DEBUG_USAGE = false;
 	public static final boolean DEBUG_TYPE_INFERENCE = false;
+	public static final boolean DEBUG_OVERLOADED_CASTS = false;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";
 	public static final String CLASS_STRING = "java.lang.String";

File: jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java
Patch:
@@ -43,8 +43,9 @@ public void testCharUnescape() {
 		checkCharUnescape('a', "a");
 		checkCharUnescape(' ', " ");
 		checkCharUnescape('\n', "\\n");
-		checkCharUnescape('\'', "\\\'");
-		checkCharUnescape('\0', "\\u0000");
+		checkCharUnescape('\'', "\\'");
+
+		assertThat(stringUtils.unescapeChar('\0'), is("0"));
 	}
 
 	private void checkCharUnescape(char input, String result) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -116,7 +116,7 @@ public static ArgType generic(String obj, ArgType... generics) {
 	}
 
 	public static ArgType outerGeneric(ArgType genericOuterType, ArgType innerType) {
-		return new OuterGenericObject((GenericObject) genericOuterType, (ObjectType) innerType);
+		return new OuterGenericObject((ObjectType) genericOuterType, (ObjectType) innerType);
 	}
 
 	public static ArgType array(@NotNull ArgType vtype) {
@@ -341,10 +341,10 @@ public String toString() {
 	}
 
 	private static class OuterGenericObject extends ObjectType {
-		private final GenericObject outerType;
+		private final ObjectType outerType;
 		private final ObjectType innerType;
 
-		public OuterGenericObject(GenericObject outerType, ObjectType innerType) {
+		public OuterGenericObject(ObjectType outerType, ObjectType innerType) {
 			super(outerType.getObject() + '$' + innerType.getObject());
 			this.outerType = outerType;
 			this.innerType = innerType;

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -51,13 +51,12 @@ private synchronized <N extends IDexNode & IAttributeNode> String addError(N nod
 
 		String msg = formatMsg(node, error);
 		if (PRINT_MTH_SIZE && node instanceof MethodNode) {
-			long insnsCount = ((MethodNode) node).countInsns();
-			msg = "[" + insnsCount + "] " + msg;
+			msg = "[" + ((MethodNode) node).getInsnsCount() + "] " + msg;
 		}
 		if (e == null) {
 			LOG.error(msg);
 		} else if (e instanceof StackOverflowError) {
-			LOG.error(msg);
+			LOG.error("{}, error: StackOverflowError", msg);
 		} else if (e instanceof JadxOverflowException) {
 			// don't print full stack trace
 			String details = e.getMessage();

File: jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java
Patch:
@@ -23,6 +23,7 @@
 import static jadx.core.dex.instructions.args.ArgType.NARROW;
 import static jadx.core.dex.instructions.args.ArgType.NARROW_INTEGRAL;
 import static jadx.core.dex.instructions.args.ArgType.OBJECT;
+import static jadx.core.dex.instructions.args.ArgType.SHORT;
 import static jadx.core.dex.instructions.args.ArgType.STRING;
 import static jadx.core.dex.instructions.args.ArgType.UNKNOWN;
 import static jadx.core.dex.instructions.args.ArgType.UNKNOWN_ARRAY;
@@ -52,8 +53,6 @@ public void init() {
 	public void compareTypes() {
 		firstIsNarrow(INT, UNKNOWN);
 
-		firstIsNarrow(BOOLEAN, INT);
-
 		firstIsNarrow(array(UNKNOWN), UNKNOWN);
 		firstIsNarrow(array(UNKNOWN), NARROW);
 	}
@@ -62,7 +61,9 @@ public void compareTypes() {
 	public void comparePrimitives() {
 		check(INT, UNKNOWN_OBJECT, TypeCompareEnum.CONFLICT);
 		check(INT, OBJECT, TypeCompareEnum.CONFLICT);
+		check(INT, BOOLEAN, TypeCompareEnum.CONFLICT);
 		check(INT, CHAR, TypeCompareEnum.WIDER);
+		check(INT, SHORT, TypeCompareEnum.WIDER);
 
 		firstIsNarrow(CHAR, NARROW_INTEGRAL);
 		firstIsNarrow(array(CHAR), UNKNOWN_OBJECT);

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java
Patch:
@@ -20,7 +20,7 @@ public static class TestCls {
 		private static final String TAG = "Parcel";
 		private static final Map<ClassLoader, Map<String, Parcelable.Creator<?>>> M_CREATORS = new HashMap<>();
 
-		@SuppressWarnings("unchecked")
+		@SuppressWarnings({ "unchecked", "ConstantConditions", "Java8MapApi", "rawtypes" })
 		public final <T extends Parcelable> T test(ClassLoader loader) {
 			String name = readString();
 			if (name == null) {

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver10.java
Patch:
@@ -12,7 +12,7 @@
 
 public class TestTypeResolver10 extends SmaliTest {
 
-	/**
+	/*
 	 * Method argument assigned with different types in separate branches
 	 */
 

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -516,17 +516,15 @@ public void done() {
 		}
 	}
 
-	protected void loadStartCommon() {
+	private void loadStartCommon() {
 		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
 		progressPane.setIndeterminate(true);
 		progressPane.setVisible(true);
-		resultsTable.setEnabled(false);
 		warnLabel.setVisible(false);
 	}
 
 	private void loadFinishedCommon() {
 		setCursor(null);
-		resultsTable.setEnabled(true);
 		progressPane.setVisible(false);
 
 		TextSearchIndex textIndex = cache.getTextIndex();

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -282,11 +282,13 @@ private JCheckBox makeOptionsCheckBox(String name, final SearchOptions opt) {
 
 	@Override
 	protected void loadFinished() {
+		resultsTable.setEnabled(true);
 		searchField.setEnabled(true);
 	}
 
 	@Override
 	protected void loadStart() {
+		resultsTable.setEnabled(false);
 		searchField.setEnabled(false);
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/UsageDialog.java
Patch:
@@ -30,12 +30,13 @@ protected void openInit() {
 
 	@Override
 	protected void loadFinished() {
+		resultsTable.setEnabled(true);
 		performSearch();
 	}
 
 	@Override
 	protected void loadStart() {
-		// no op
+		resultsTable.setEnabled(false);
 	}
 
 	@Override

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexConsts.java
Patch:
@@ -6,6 +6,8 @@ public class DexConsts {
 
 	public static final byte[] ZIP_FILE_MAGIC = { 0x50, 0x4B, 0x03, 0x04 };
 
+	public static final int MAX_MAGIC_SIZE = 4;
+
 	public static final int ENDIAN_CONSTANT = 0x12345678;
 
 	public static final int NO_INDEX = -1;

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -106,9 +106,8 @@ private void addDummyClass(IClassData classData, Exception exc) {
 		if (name == null || name.isEmpty()) {
 			name = "CLASS_" + typeStr;
 		}
-		ClassNode clsNode = new ClassNode(this, name, classData.getAccessFlags());
+		ClassNode clsNode = ClassNode.addSyntheticClass(this, name, classData.getAccessFlags());
 		ErrorsCounter.error(clsNode, "Load error", exc);
-		addClassNode(clsNode);
 	}
 
 	public void addClassNode(ClassNode clsNode) {

File: jadx-core/src/test/java/jadx/tests/integration/android/TestRFieldAccess.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.integration.inner;
+package jadx.tests.integration.android;
 
 import org.junit.jupiter.api.Test;
 

File: jadx-core/src/test/java/jadx/tests/integration/android/TestRFieldRestore2.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.integration.inner;
+package jadx.tests.integration.android;
 
 import java.util.HashMap;
 import java.util.Map;

File: jadx-core/src/test/java/jadx/tests/integration/android/TestRFieldRestore3.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.integration.inner;
+package jadx.tests.integration.android;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -113,9 +113,6 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 		passes.add(new MarkFinallyVisitor());
 		passes.add(new ConstInlineVisitor());
 		passes.add(new TypeInferenceVisitor());
-		if (args.isRawCFGOutput()) {
-			passes.add(DotGraphVisitor.dumpRaw());
-		}
 		if (args.isDebugInfo()) {
 			passes.add(new DebugInfoApplyVisitor());
 		}

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -287,9 +287,9 @@ private void addCaseKey(CodeWriter code, InsnArg arg, Object k) {
 				staticField(code, fn.getFieldInfo());
 				// print original value, sometimes replaced with incorrect field
 				FieldInitAttr valueAttr = fn.get(AType.FIELD_INIT);
-				if (valueAttr != null) {
+				if (valueAttr != null && valueAttr.getValueType() == FieldInitAttr.InitType.CONST) {
 					Object value = valueAttr.getEncodedValue();
-					if (value != null && valueAttr.getValueType() == FieldInitAttr.InitType.CONST) {
+					if (value != null) {
 						code.add(" /*").add(value.toString()).add("*/");
 					}
 				}

File: jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java
Patch:
@@ -72,9 +72,9 @@ public void processConstFields(ClassNode cls, List<FieldNode> staticFields) {
 			if (accFlags.isStatic() && accFlags.isFinal()) {
 				FieldInitAttr fv = f.get(AType.FIELD_INIT);
 				if (fv != null
-						&& fv.getEncodedValue() != null
 						&& fv.getValueType() == FieldInitAttr.InitType.CONST
-						&& fv != FieldInitAttr.NULL_VALUE) {
+						&& fv != FieldInitAttr.NULL_VALUE
+						&& fv.getEncodedValue() != null) {
 					addConstField(cls, f, fv.getEncodedValue().getValue(), accFlags.isPublic());
 				}
 			}

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -3,6 +3,7 @@
 public class Consts {
 	public static final boolean DEBUG = false;
 	public static final boolean DEBUG_USAGE = false;
+	public static final boolean DEBUG_TYPE_INFERENCE = false;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";
 	public static final String CLASS_STRING = "java.lang.String";

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -21,6 +21,7 @@
 import jadx.core.dex.attributes.nodes.LoopLabelAttr;
 import jadx.core.dex.attributes.nodes.MethodInlineAttr;
 import jadx.core.dex.attributes.nodes.MethodOverrideAttr;
+import jadx.core.dex.attributes.nodes.MethodTypeVarsAttr;
 import jadx.core.dex.attributes.nodes.PhiListAttr;
 import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
 import jadx.core.dex.attributes.nodes.RenameReasonAttr;
@@ -64,6 +65,7 @@ public class AType<T extends IAttribute> {
 	public static final AType<MethodParameters> ANNOTATION_MTH_PARAMETERS = new AType<>();
 	public static final AType<SkipMethodArgsAttr> SKIP_MTH_ARGS = new AType<>();
 	public static final AType<MethodOverrideAttr> METHOD_OVERRIDE = new AType<>();
+	public static final AType<MethodTypeVarsAttr> METHOD_TYPE_VARS = new AType<>();
 
 	// region
 	public static final AType<DeclareVariablesAttr> DECLARE_VARIABLES = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -143,7 +143,7 @@ private static int getInsnOffsetByArg(InsnArg arg) {
 	}
 
 	public static void applyDebugInfo(MethodNode mth, SSAVar ssaVar, ArgType type, String varName) {
-		TypeUpdateResult result = mth.root().getTypeUpdate().applyWithWiderAllow(ssaVar, type);
+		TypeUpdateResult result = mth.root().getTypeUpdate().applyWithWiderAllow(mth, ssaVar, type);
 		if (result == TypeUpdateResult.REJECT) {
 			if (Consts.DEBUG) {
 				LOG.debug("Reject debug info of type: {} and name: '{}' for {}, mth: {}", type, varName, ssaVar, mth);

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java
Patch:
@@ -63,7 +63,7 @@ public boolean run() {
 		} else {
 			search(vars);
 			searchSuccess = fullCheck(vars);
-			if (Consts.DEBUG && !searchSuccess) {
+			if (Consts.DEBUG_TYPE_INFERENCE && !searchSuccess) {
 				LOG.warn("Multi-variable search failed in {}", mth);
 			}
 		}
@@ -86,7 +86,7 @@ private boolean applyResolvedVars() {
 				// exclude unknown variables
 				continue;
 			}
-			TypeUpdateResult res = typeUpdate.applyWithWiderIgnSame(var.getVar(), var.getCurrentType());
+			TypeUpdateResult res = typeUpdate.applyWithWiderIgnSame(mth, var.getVar(), var.getCurrentType());
 			if (res == TypeUpdateResult.REJECT) {
 				mth.addComment("JADX DEBUG: Multi-variable search result rejected for " + var);
 				applySuccess = false;
@@ -97,7 +97,7 @@ private boolean applyResolvedVars() {
 
 	private boolean search(List<TypeSearchVarInfo> vars) {
 		int len = vars.size();
-		if (Consts.DEBUG) {
+		if (Consts.DEBUG_TYPE_INFERENCE) {
 			LOG.debug("Run search for {} vars: ", len);
 			StringBuilder sb = new StringBuilder();
 			long count = 1;

File: jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java
Patch:
@@ -293,7 +293,7 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {
 		@Override
 		public void skip(DexInsnData insn, SectionReader in) {
 			int size = in.readUShort();
-			in.skip(4 + size * 4 * 2);
+			in.skip(size * 8);
 			insn.setLength(size * 4 + 2);
 		}
 	};

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -2,6 +2,7 @@
 
 public class Consts {
 	public static final boolean DEBUG = false;
+	public static final boolean DEBUG_USAGE = false;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";
 	public static final String CLASS_STRING = "java.lang.String";

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -17,7 +17,6 @@
 import jadx.core.dex.visitors.ConstInlineVisitor;
 import jadx.core.dex.visitors.ConstructorVisitor;
 import jadx.core.dex.visitors.DeboxingVisitor;
-import jadx.core.dex.visitors.DependencyCollector;
 import jadx.core.dex.visitors.DotGraphVisitor;
 import jadx.core.dex.visitors.EnumVisitor;
 import jadx.core.dex.visitors.ExtractFieldInit;
@@ -55,6 +54,7 @@
 import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;
 import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
+import jadx.core.dex.visitors.usage.UsageInfoVisitor;
 
 public class Jadx {
 	private static final Logger LOG = LoggerFactory.getLogger(Jadx.class);
@@ -79,7 +79,7 @@ public static List<IDexTreeVisitor> getFallbackPassesList() {
 	public static List<IDexTreeVisitor> getPreDecompilePassesList() {
 		List<IDexTreeVisitor> passes = new ArrayList<>();
 		passes.add(new RenameVisitor());
-		passes.add(new DependencyCollector());
+		passes.add(new UsageInfoVisitor());
 		return passes;
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -80,6 +80,9 @@ public boolean addDefinition(CodeWriter code) {
 			code.attachDefinition(mth);
 			return false;
 		}
+		if (Consts.DEBUG_USAGE) {
+			ClassGen.addMthUsageInfo(code, mth);
+		}
 		addOverrideAnnotation(code, mth);
 		annotationGen.addForMethod(code, mth);
 

File: jadx-core/src/test/java/jadx/tests/api/SmaliTest.java
Patch:
@@ -107,6 +107,7 @@ private static boolean compileSmali(File output, List<File> inputFiles) {
 		try {
 			SmaliOptions options = new SmaliOptions();
 			options.outputDexFile = output.getAbsolutePath();
+			options.verboseErrors = true;
 			List<String> inputFileNames = inputFiles.stream().map(File::getAbsolutePath).collect(Collectors.toList());
 			Smali.assemble(options, inputFileNames);
 		} catch (Exception e) {

File: jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxAssertions.java
Patch:
@@ -8,10 +8,12 @@
 public class JadxAssertions extends Assertions {
 
 	public static JadxClassNodeAssertions assertThat(ClassNode actual) {
+		Assertions.assertThat(actual).isNotNull();
 		return new JadxClassNodeAssertions(actual);
 	}
 
 	public static JadxCodeAssertions assertThat(ICodeInfo actual) {
+		Assertions.assertThat(actual).isNotNull();
 		return new JadxCodeAssertions(actual.getCodeStr());
 	}
 }

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -98,6 +98,7 @@ public void load() {
 		root.initClassPath();
 		root.loadResources(getResources());
 		root.initPasses();
+		root.runPreDecompileStage();
 	}
 
 	private void loadInputFiles() {

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -54,8 +54,8 @@ public static ICodeInfo generateCode(ClassNode cls) {
 			return generateCode(topParentClass);
 		}
 		try {
-			process(cls);
 			cls.getDependencies().forEach(ProcessClass::process);
+			process(cls);
 
 			ICodeInfo code = CodeGen.generate(cls);
 			cls.unload();

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java
Patch:
@@ -12,9 +12,9 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.core.Consts;
+import jadx.core.dex.instructions.BaseInvokeNode;
 import jadx.core.dex.instructions.IndexInsnNode;
 import jadx.core.dex.instructions.InsnType;
-import jadx.core.dex.instructions.InvokeNode;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.PrimitiveType;
@@ -277,11 +277,12 @@ private Map<InsnType, ITypeListener> initListenerRegistry() {
 		registry.put(InsnType.NOT, this::suggestAllSameListener);
 		registry.put(InsnType.CHECK_CAST, this::checkCastListener);
 		registry.put(InsnType.INVOKE, this::invokeListener);
+		registry.put(InsnType.CONSTRUCTOR, this::invokeListener);
 		return registry;
 	}
 
 	private TypeUpdateResult invokeListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {
-		InvokeNode invoke = (InvokeNode) insn;
+		BaseInvokeNode invoke = (BaseInvokeNode) insn;
 		if (isAssign(invoke, arg)) {
 			// TODO: implement backward type propagation (from result to instance)
 			return SAME;

File: jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java
Patch:
@@ -52,7 +52,7 @@ private static void initCodeVars(MethodNode mth) {
 		}
 	}
 
-	private static void initCodeVar(SSAVar ssaVar) {
+	public static void initCodeVar(SSAVar ssaVar) {
 		if (ssaVar.isCodeVarSet()) {
 			return;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -23,6 +23,8 @@
 import jadx.core.utils.StringUtils;
 import jadx.core.utils.Utils;
 
+import static jadx.core.codegen.MethodGen.FallbackOption.BLOCK_DUMP;
+
 public class DotGraphVisitor extends AbstractVisitor {
 
 	private static final String NL = "\\l";
@@ -272,7 +274,7 @@ private String insertInsns(MethodNode mth, IBlock block) {
 			} else {
 				CodeWriter code = new CodeWriter();
 				List<InsnNode> instructions = block.getInstructions();
-				MethodGen.addFallbackInsns(code, mth, instructions.toArray(new InsnNode[0]), false);
+				MethodGen.addFallbackInsns(code, mth, instructions.toArray(new InsnNode[0]), BLOCK_DUMP);
 				String str = escape(code.newLine().toString());
 				if (str.startsWith(NL)) {
 					str = str.substring(NL.length());

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -61,7 +61,7 @@ public void processBlock(MethodNode mth, IBlock container) {
 						&& !block.contains(AFlag.ADDED_TO_REGION)
 						&& !block.contains(AFlag.DONT_GENERATE)
 						&& !block.contains(AFlag.REMOVE)) {
-					String blockCode = getBlockInsnStr(mth, block);
+					String blockCode = getBlockInsnStr(mth, block).replace("*/", "*\\/");
 					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);
 				}
 			}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -270,7 +270,6 @@ public String getDetailedVarInfo(MethodNode mth) {
 		if (!types.isEmpty()) {
 			sb.append(", types: ").append(types);
 		}
-		sb.append(", assign insn: ").append(getAssign().getParentInsn());
 		return sb.toString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -57,6 +57,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new BlockExceptionHandler());
 			passes.add(new BlockFinish());
 
+			passes.add(new AttachMethodDetails());
 			passes.add(new OverrideMethodVisitor());
 
 			passes.add(new SSATransform());
@@ -65,7 +66,6 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new InitCodeVariables());
 			passes.add(new MarkFinallyVisitor());
 			passes.add(new ConstInlineVisitor());
-			passes.add(new AttachMethodDetails());
 			passes.add(new TypeInferenceVisitor());
 			if (args.isDebugInfo()) {
 				passes.add(new DebugInfoApplyVisitor());

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -5,6 +5,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import org.jetbrains.annotations.NotNull;
+
 import jadx.core.Consts;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.nodes.ClassNode;
@@ -114,7 +116,7 @@ public static ArgType outerGeneric(ArgType genericOuterType, ArgType innerType)
 		return new OuterGenericObject((GenericObject) genericOuterType, (ObjectType) innerType);
 	}
 
-	public static ArgType array(ArgType vtype) {
+	public static ArgType array(@NotNull ArgType vtype) {
 		return new ArrayArg(vtype);
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestMethodOverride.java
Patch:
@@ -15,6 +15,7 @@ public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
 				.containsOne("String createFromParcel(Parcel parcel) {")
-				.containsOne("@Override");
+				.containsOne("String[] newArray(int i) {")
+				.countString(2, "@Override");
 	}
 }

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -57,6 +57,8 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new BlockExceptionHandler());
 			passes.add(new BlockFinish());
 
+			passes.add(new OverrideMethodVisitor());
+
 			passes.add(new SSATransform());
 			passes.add(new MoveInlineVisitor());
 			passes.add(new ConstructorVisitor());

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -317,7 +317,7 @@ private boolean isMethodsPresents() {
 
 	public void addMethodCode(CodeWriter code, MethodNode mth) throws CodegenException {
 		CodeGenUtils.addComments(code, mth);
-		if (mth.getAccessFlags().isAbstract() || mth.getAccessFlags().isNative()) {
+		if (mth.isNoCode()) {
 			MethodGen mthGen = new MethodGen(this, mth);
 			mthGen.addDefinition(code);
 			code.add(';');

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -20,6 +20,7 @@
 import jadx.core.dex.attributes.nodes.LoopInfo;
 import jadx.core.dex.attributes.nodes.LoopLabelAttr;
 import jadx.core.dex.attributes.nodes.MethodInlineAttr;
+import jadx.core.dex.attributes.nodes.MethodOverrideAttr;
 import jadx.core.dex.attributes.nodes.PhiListAttr;
 import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
 import jadx.core.dex.attributes.nodes.RenameReasonAttr;
@@ -63,6 +64,7 @@ public class AType<T extends IAttribute> {
 	public static final AType<MethodInlineAttr> METHOD_INLINE = new AType<>();
 	public static final AType<MethodParameters> ANNOTATION_MTH_PARAMETERS = new AType<>();
 	public static final AType<SkipMethodArgsAttr> SKIP_MTH_ARGS = new AType<>();
+	public static final AType<MethodOverrideAttr> METHOD_OVERRIDE = new AType<>();
 
 	// region
 	public static final AType<DeclareVariablesAttr> DECLARE_VARIABLES = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -521,7 +521,7 @@ private boolean tryWiderObjects(MethodNode mth, SSAVar var) {
 		}
 		ClspGraph clsp = mth.root().getClsp();
 		for (ArgType objType : objTypes) {
-			for (String ancestor : clsp.getAncestors(objType.getObject())) {
+			for (String ancestor : clsp.getSuperTypes(objType.getObject())) {
 				ArgType ancestorType = ArgType.object(ancestor);
 				TypeUpdateResult result = typeUpdate.applyWithWiderAllow(var, ancestorType);
 				if (result == TypeUpdateResult.CHANGED) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java
Patch:
@@ -281,7 +281,7 @@ private boolean addCandidateType(Set<ITypeBound> bounds, Set<ArgType> collectedT
 	private List<ArgType> getWiderTypes(ArgType type) {
 		if (type.isTypeKnown()) {
 			if (type.isObject()) {
-				Set<String> ancestors = mth.root().getClsp().getAncestors(type.getObject());
+				Set<String> ancestors = mth.root().getClsp().getSuperTypes(type.getObject());
 				return ancestors.stream().map(ArgType::object).collect(Collectors.toList());
 			}
 		} else {

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java
Patch:
@@ -35,16 +35,18 @@ public interface IOperation {
 	@Test
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
-		String code = cls.getCode().toString();
+		String code = removeLineComments(cls);
 
 		assertThat(code, JadxMatchers.containsLines(1,
 				"public enum Operation implements IOperation {",
 				indent(1) + "PLUS {",
+				indent(2) + "@Override",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x + y;",
 				indent(2) + '}',
 				indent(1) + "},",
 				indent(1) + "MINUS {",
+				indent(2) + "@Override",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x - y;",
 				indent(2) + '}',

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -3,12 +3,11 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.instructions.PhiInsn;
 
-import static com.google.common.base.Ascii.NL;
-
 public class PhiListAttr implements IAttribute {
 
 	private final List<PhiInsn> list = new LinkedList<>();
@@ -30,7 +29,7 @@ public String toString() {
 			sb.append('r').append(phiInsn.getResult().getRegNum()).append(' ');
 		}
 		for (PhiInsn phiInsn : list) {
-			sb.append(NL).append("  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
+			sb.append(CodeWriter.NL).append("  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
 		}
 		return sb.toString();
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -297,6 +297,7 @@ private String escape(String string) {
 					.replace("\"", "\\\"")
 					.replace("-", "\\-")
 					.replace("|", "\\|")
+					.replace(CodeWriter.NL, NL)
 					.replace("\n", NL);
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -181,7 +181,7 @@ public void initMethodTypes() {
 			this.retType = mthInfo.getReturnType();
 			this.argTypes = mthInfo.getArgumentsTypes();
 		} else {
-			this.argTypes = types;
+			this.argTypes = Collections.unmodifiableList(types);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java
Patch:
@@ -110,6 +110,9 @@ public ArgType replaceMethodGenerics(BaseInvokeNode invokeInsn, IMethodDetails d
 
 	@Nullable
 	public ArgType replaceTypeVariablesUsingMap(ArgType replaceType, Map<ArgType, ArgType> replaceMap) {
+		if (replaceMap.isEmpty()) {
+			return null;
+		}
 		if (replaceType.isGenericType()) {
 			return replaceMap.get(replaceType);
 		}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -58,6 +58,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new BlockFinish());
 
 			passes.add(new SSATransform());
+			passes.add(new MoveInlineVisitor());
 			passes.add(new ConstructorVisitor());
 			passes.add(new InitCodeVariables());
 			passes.add(new MarkFinallyVisitor());

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java
Patch:
@@ -24,7 +24,7 @@
 @JadxVisitor(
 		name = "ConstructorVisitor",
 		desc = "Replace invoke with constructor call",
-		runAfter = SSATransform.class,
+		runAfter = { SSATransform.class, MoveInlineVisitor.class },
 		runBefore = TypeInferenceVisitor.class
 )
 public class ConstructorVisitor extends AbstractVisitor {

File: jadx-core/src/main/java/jadx/core/utils/InsnRemover.java
Patch:
@@ -210,7 +210,9 @@ public static boolean removeWithoutUnbind(MethodNode mth, BlockNode block, InsnN
 				return true;
 			}
 		}
-		mth.addWarnComment("Failed to remove instruction: " + insn + " from block: " + block);
+		if (!insn.contains(AFlag.WRAPPED)) {
+			mth.addWarnComment("Failed to remove instruction: " + insn + " from block: " + block);
+		}
 		return false;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/SkipMethodArgsAttr.java
Patch:
@@ -44,7 +44,7 @@ public static boolean isSkip(@Nullable MethodNode mth, int argNum) {
 	private final BitSet skipArgs;
 
 	private SkipMethodArgsAttr(MethodNode mth) {
-		this.skipArgs = new BitSet(mth.getArgRegs().size());
+		this.skipArgs = new BitSet(mth.getMethodInfo().getArgsCount());
 	}
 
 	public void skip(int argNum) {

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -49,13 +49,10 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			if (args.isDebugInfo()) {
 				passes.add(new DebugInfoParseVisitor());
 			}
-
-			passes.add(new FindSuperUsageVisitor());
 			passes.add(new BlockSplitter());
 			if (args.isRawCFGOutput()) {
 				passes.add(DotGraphVisitor.dumpRaw());
 			}
-
 			passes.add(new BlockProcessor());
 			passes.add(new BlockExceptionHandler());
 			passes.add(new BlockFinish());
@@ -72,6 +69,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			}
 
 			passes.add(new GenericTypesVisitor());
+			passes.add(new ShadowFieldVisitor());
 			passes.add(new DeboxingVisitor());
 			passes.add(new ModVisitor());
 			passes.add(new CodeShrinkVisitor());

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -71,6 +71,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 				passes.add(new DebugInfoApplyVisitor());
 			}
 
+			passes.add(new GenericTypesVisitor());
 			passes.add(new DeboxingVisitor());
 			passes.add(new ModVisitor());
 			passes.add(new CodeShrinkVisitor());

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -60,7 +60,6 @@ public enum AFlag {
 
 	FALL_THROUGH,
 
-	EXPLICIT_GENERICS,
 	VARARG_CALL,
 
 	/**

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -12,6 +12,7 @@
 import jadx.core.dex.attributes.nodes.EnumMapAttr;
 import jadx.core.dex.attributes.nodes.FieldReplaceAttr;
 import jadx.core.dex.attributes.nodes.ForceReturnAttr;
+import jadx.core.dex.attributes.nodes.GenericInfoAttr;
 import jadx.core.dex.attributes.nodes.IgnoreEdgeAttr;
 import jadx.core.dex.attributes.nodes.JadxError;
 import jadx.core.dex.attributes.nodes.JumpInfo;
@@ -36,6 +37,7 @@
  *
  * @param <T> attribute class implementation
  */
+@SuppressWarnings("InstantiationOfUtilityClass")
 public class AType<T extends IAttribute> {
 
 	// class, method, field
@@ -81,6 +83,7 @@ public class AType<T extends IAttribute> {
 	public static final AType<LoopLabelAttr> LOOP_LABEL = new AType<>();
 	public static final AType<AttrList<JumpInfo>> JUMP = new AType<>();
 	public static final AType<IMethodDetails> METHOD_DETAILS = new AType<>();
+	public static final AType<GenericInfoAttr> GENERIC_INFO = new AType<>();
 
 	// register
 	public static final AType<RegDebugInfoAttr> REG_DEBUG_INFO = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java
Patch:
@@ -1,6 +1,5 @@
 package jadx.core.dex.attributes.nodes;
 
-import java.util.ArrayList;
 import java.util.List;
 
 import jadx.core.dex.attributes.AType;
@@ -53,8 +52,8 @@ public String toString() {
 	private final List<EnumField> fields;
 	private MethodNode staticMethod;
 
-	public EnumClassAttr(int fieldsCount) {
-		this.fields = new ArrayList<>(fieldsCount);
+	public EnumClassAttr(List<EnumField> fields) {
+		this.fields = fields;
 	}
 
 	public List<EnumField> getFields() {

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java
Patch:
@@ -36,7 +36,7 @@ public void setParentInsn(InsnNode parentInsn) {
 
 	@Override
 	public InsnArg duplicate() {
-		InsnWrapArg copy = new InsnWrapArg(wrappedInsn.copy());
+		InsnWrapArg copy = new InsnWrapArg(wrappedInsn.copyWithoutResult());
 		copy.setType(type);
 		return copyCommonParams(copy);
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -270,6 +270,7 @@ public String getDetailedVarInfo(MethodNode mth) {
 		if (!types.isEmpty()) {
 			sb.append(", types: ").append(types);
 		}
+		sb.append(", assign insn: ").append(getAssign().getParentInsn());
 		return sb.toString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -647,7 +647,8 @@ public int getDebugInfoOffset() {
 		return debugInfoOffset;
 	}
 
-	public SSAVar makeNewSVar(int regNum, @NotNull RegisterArg assignArg) {
+	public SSAVar makeNewSVar(@NotNull RegisterArg assignArg) {
+		int regNum = assignArg.getRegNum();
 		return makeNewSVar(regNum, getNextSVarVersion(regNum), assignArg);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java
Patch:
@@ -93,8 +93,7 @@ private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRe
 			String s = ((ConstStringNode) insn).getString();
 			FieldNode f = mth.getParentClass().getConstField(s);
 			if (f == null) {
-				InsnNode copy = insn.copy();
-				copy.setResult(null);
+				InsnNode copy = insn.copyWithoutResult();
 				constArg = InsnArg.wrapArg(copy);
 			} else {
 				InsnNode constGet = new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0);

File: jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java
Patch:
@@ -73,7 +73,7 @@ private static void addInlineAttr(MethodNode mth, InsnNode insn) {
 			if (Consts.DEBUG) {
 				mth.addAttr(AType.COMMENTS, "Removed for inline");
 			} else {
-				InsnNode copy = insn.copy();
+				InsnNode copy = insn.copyWithoutResult();
 				// unbind SSA variables from copy instruction
 				List<RegisterArg> regArgs = new ArrayList<>();
 				copy.getRegisterArgs(regArgs);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -750,7 +750,7 @@ private static boolean splitReturn(MethodNode mth, BlockNode exitBlock) {
 				first = false;
 			} else {
 				for (InsnNode oldInsn : exitBlock.getInstructions()) {
-					newRetBlock.getInstructions().add(oldInsn.copy());
+					newRetBlock.getInstructions().add(oldInsn.copyWithoutSsa());
 				}
 			}
 			BlockSplitter.replaceConnection(pred, exitBlock, newRetBlock);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -422,7 +422,6 @@ private static void markOneArgAsThis(RegisterArg arg) {
 			if (resArg.getRegNum() != arg.getRegNum()
 					&& !resArg.getSVar().isUsedInPhi()) {
 				markThisArgs(resArg);
-				parentInsn.add(AFlag.REMOVE);
 				parentInsn.add(AFlag.DONT_GENERATE);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -404,7 +404,7 @@ private boolean insertMoveForPhi(MethodNode mth, PhiInsn phiInsn, SSAVar var, bo
 				if (apply) {
 					int regNum = reg.getRegNum();
 					RegisterArg resultArg = reg.duplicate(regNum, null);
-					SSAVar newSsaVar = mth.makeNewSVar(regNum, resultArg);
+					SSAVar newSsaVar = mth.makeNewSVar(resultArg);
 					RegisterArg arg = reg.duplicate(regNum, var);
 
 					InsnNode moveInsn = new InsnNode(InsnType.MOVE, 1);
@@ -476,7 +476,7 @@ private void processIncompatiblePrimitives(MethodNode mth, SSAVar var) {
 					castNode.addArg(bound.getArg());
 					castNode.setResult(InsnArg.reg(bound.getArg().getRegNum(), bound.getType()));
 
-					SSAVar newVar = mth.makeNewSVar(castNode.getResult().getRegNum(), castNode.getResult());
+					SSAVar newVar = mth.makeNewSVar(castNode.getResult());
 					CodeVar codeVar = new CodeVar();
 					codeVar.setType(bound.getType());
 					newVar.setCodeVar(codeVar);

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -181,7 +181,7 @@ public static InsnArg getSingleArg(InsnNode insn) {
 	}
 
 	@Nullable
-	public static InsnNode checkInsnType(InsnNode insn, InsnType insnType) {
+	public static InsnNode checkInsnType(@Nullable InsnNode insn, InsnType insnType) {
 		if (insn != null && insn.getType() == insnType) {
 			return insn;
 		}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -225,6 +225,9 @@ public void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {
 	private static final Set<Flags> BODY_ONLY_NOWRAP_FLAGS = EnumSet.of(Flags.BODY_ONLY_NOWRAP);
 
 	protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {
+		if (insn.getType() == InsnType.REGION_ARG) {
+			return;
+		}
 		try {
 			if (flag == Flags.BODY_ONLY || flag == Flags.BODY_ONLY_NOWRAP) {
 				makeInsnBody(code, insn, flag == Flags.BODY_ONLY ? BODY_ONLY_FLAG : BODY_ONLY_NOWRAP_FLAGS);

File: jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.core.dex.instructions;
 
 import jadx.core.dex.nodes.InsnNode;
+import jadx.core.utils.StringUtils;
 
 public final class ConstStringNode extends InsnNode {
 
@@ -34,6 +35,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return super.toString() + " \"" + str + '"';
+		return super.toString() + ' ' + StringUtils.getInstance().unescapeString(str);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java
Patch:
@@ -66,6 +66,9 @@ public enum InsnType {
 	ONE_ARG,
 	PHI,
 
+	// fake insn to keep arguments which will be used in regions codegen
+	REGION_ARG,
+
 	// TODO: now multidimensional arrays created using Array.newInstance function
 	NEW_MULTIDIM_ARRAY
 }

File: jadx-core/src/main/java/jadx/core/utils/InsnRemover.java
Patch:
@@ -182,6 +182,8 @@ public static void remove(MethodNode mth, InsnNode insn) {
 		BlockNode block = BlockUtils.getBlockByInsn(mth, insn);
 		if (block != null) {
 			remove(mth, block, insn);
+		} else {
+			mth.addWarnComment("Not found block with instruction: " + insn);
 		}
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakWithLabel.java
Patch:
@@ -36,7 +36,7 @@ public void check() {
 	}
 
 	@Test
-	public void test() throws Exception {
+	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -7,7 +7,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.visitors.DepthTraversal;
 import jadx.core.dex.visitors.IDexTreeVisitor;
-import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
 import static jadx.core.dex.nodes.ProcessState.LOADED;
@@ -43,7 +42,7 @@ public static void process(ClassNode cls) {
 					cls.setState(PROCESS_COMPLETE);
 				}
 			} catch (Throwable e) {
-				ErrorsCounter.classError(cls, e.getClass().getSimpleName(), e);
+				cls.addError("Class process error: " + e.getClass().getSimpleName(), e);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -268,7 +268,7 @@ private void addInnerClass(CodeWriter code, ClassNode innerCls) {
 			inClGen.addClassCode(code);
 			imports.addAll(inClGen.getImports());
 		} catch (Exception e) {
-			ErrorsCounter.classError(innerCls, "Inner class code generation error", e);
+			innerCls.addError("Inner class code generation error", e);
 		}
 	}
 
@@ -293,7 +293,7 @@ private void addMethod(CodeWriter code, MethodNode mth) {
 				throw new JadxRuntimeException("Method generation error", e);
 			}
 			code.newLine().add("/*");
-			code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));
+			code.newLine().addMultiLine(ErrorsCounter.error(mth, "Method generation error", e));
 			Utils.appendStackTrace(code, e);
 			code.newLine().add("*/");
 			code.setIndent(savedIndent);
@@ -455,7 +455,7 @@ private void addInsnBody(InsnGen insnGen, CodeWriter code, InsnNode insn) {
 		try {
 			insnGen.makeInsn(insn, code, InsnGen.Flags.BODY_ONLY_NOWRAP);
 		} catch (Exception e) {
-			ErrorsCounter.classError(cls, "Failed to generate init code", e);
+			cls.addError("Failed to generate init code", e);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -16,7 +16,6 @@
 import jadx.core.dex.regions.conditions.Compare;
 import jadx.core.dex.regions.conditions.IfCondition;
 import jadx.core.dex.regions.conditions.IfCondition.Mode;
-import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.exceptions.CodegenException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
@@ -123,7 +122,7 @@ private void addCompare(CodeWriter code, CondStack stack, Compare compare) throw
 				wrap(code, firstArg);
 				return;
 			}
-			ErrorsCounter.methodWarn(mth, "Unsupported boolean condition " + op.getSymbol());
+			mth.addWarn("Unsupported boolean condition " + op.getSymbol());
 		}
 
 		addArg(code, firstArg, isArgWrapNeeded(firstArg));

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -39,7 +39,6 @@
 import jadx.core.dex.regions.loops.LoopType;
 import jadx.core.dex.trycatch.ExceptionHandler;
 import jadx.core.utils.BlockUtils;
-import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.RegionUtils;
 import jadx.core.utils.exceptions.CodegenException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
@@ -186,7 +185,7 @@ private CodeWriter makeLoop(LoopRegion region, CodeWriter code) throws CodegenEx
 		if (header != null) {
 			List<InsnNode> headerInsns = header.getInstructions();
 			if (headerInsns.size() > 1) {
-				ErrorsCounter.methodWarn(mth, "Found not inlined instructions from loop header");
+				mth.addWarn("Found not inlined instructions from loop header");
 				int last = headerInsns.size() - 1;
 				for (int i = 0; i < last; i++) {
 					InsnNode insn = headerInsns.get(i);

File: jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java
Patch:
@@ -16,7 +16,6 @@
 import jadx.core.dex.nodes.DexNode;
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.parser.FieldInitAttr;
-import jadx.core.utils.ErrorsCounter;
 
 public class ConstStorage {
 
@@ -155,7 +154,7 @@ private FieldNode getResourceField(Integer value, DexNode dex) {
 				return innerClass.searchFieldByName(fieldName);
 			}
 		}
-		ErrorsCounter.classWarn(appResClass, "Not found resource field with id: " + value + ", name: " + str.replace('/', '.'));
+		appResClass.addWarn("Not found resource field with id: " + value + ", name: " + str.replace('/', '.'));
 		return null;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -25,7 +25,7 @@
 import jadx.core.ProcessClass;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.annotations.Annotation;
-import jadx.core.dex.attributes.nodes.LineAttrNode;
+import jadx.core.dex.attributes.nodes.NotificationAttrNode;
 import jadx.core.dex.attributes.nodes.SourceFileAttr;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.info.AccessInfo.AFType;
@@ -45,7 +45,7 @@
 import static jadx.core.dex.nodes.ProcessState.LOADED;
 import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;
 
-public class ClassNode extends LineAttrNode implements ILoadable, ICodeNode {
+public class ClassNode extends NotificationAttrNode implements ILoadable, ICodeNode {
 	private static final Logger LOG = LoggerFactory.getLogger(ClassNode.class);
 
 	private final DexNode dex;

File: jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java
Patch:
@@ -79,7 +79,7 @@ private void addDummyClass(ClassDef classDef, Exception exc) {
 			name = "CLASS_" + typeIndex;
 		}
 		ClassNode clsNode = new ClassNode(this, name, classDef.getAccessFlags());
-		ErrorsCounter.classError(clsNode, "Load error", exc);
+		ErrorsCounter.error(clsNode, "Load error", exc);
 		addClassNode(clsNode);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -23,7 +23,6 @@
 import jadx.core.dex.trycatch.SplitterBlockAttr;
 import jadx.core.dex.trycatch.TryCatchBlock;
 import jadx.core.utils.BlockUtils;
-import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.RegionUtils;
 
 /**
@@ -105,7 +104,7 @@ private static boolean checkAndWrap(MethodNode mth, Map<BlockNode, TryCatchBlock
 			if (region.getSubBlocks().contains(dominator)) {
 				TryCatchBlock tb = tryBlocksMap.get(dominator);
 				if (!wrapBlocks(region, tb, dominator)) {
-					ErrorsCounter.methodWarn(mth, "Can't wrap try/catch for region: " + region);
+					mth.addWarn("Can't wrap try/catch for region: " + region);
 				}
 				tryBlocksMap.remove(dominator);
 				return true;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -574,7 +574,7 @@ private BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNo
 
 		BlockNode body = getNextBlock(block);
 		if (body == null) {
-			ErrorsCounter.methodWarn(mth, "Unexpected end of synchronized block");
+			mth.addWarn("Unexpected end of synchronized block");
 			return null;
 		}
 		BlockNode exit = null;

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -303,9 +303,7 @@ private void removeEnumMethods(ClassNode cls, ArgType clsType) {
 						|| shortId.equals(enumConstructorAlt)) {
 					mth.add(AFlag.DONT_GENERATE);
 				}
-			} else if (isSynthetic
-					|| shortId.equals(valuesMethod)
-					|| shortId.equals(valuesOfMethod)) {
+			} else if (shortId.equals(valuesMethod) || shortId.equals(valuesOfMethod)) {
 				mth.add(AFlag.DONT_GENERATE);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -33,6 +33,7 @@ public enum AFlag {
 	ANONYMOUS_CLASS,
 
 	THIS,
+	SUPER,
 
 	/**
 	 * RegisterArg attribute for method arguments

File: jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java
Patch:
@@ -68,7 +68,7 @@ public ArgType getMethodGenericReturnType(BaseInvokeNode invokeNode) {
 	}
 
 	public boolean processMethodArgsOverloaded(ArgType startCls, MethodInfo mthInfo, @Nullable List<IMethodDetails> collectedMths) {
-		if (startCls == null) {
+		if (startCls == null || !startCls.isObject()) {
 			return false;
 		}
 		boolean isMthConstructor = mthInfo.isConstructor() || mthInfo.isClassInit();

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import jadx.core.codegen.CodeWriter;
 import jadx.core.utils.Utils;
 
 public class AttrList<T> implements IAttribute {
@@ -25,6 +26,6 @@ public AType<AttrList<T>> getType() {
 
 	@Override
 	public String toString() {
-		return Utils.listToString(list, "\n");
+		return Utils.listToString(list, CodeWriter.NL);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java
Patch:
@@ -4,6 +4,7 @@
 
 import org.jetbrains.annotations.NotNull;
 
+import jadx.core.codegen.CodeWriter;
 import jadx.core.utils.Utils;
 
 public class JadxError implements Comparable<JadxError> {
@@ -58,7 +59,7 @@ public String toString() {
 			str.append(cause.getClass());
 			str.append(':');
 			str.append(cause.getMessage());
-			str.append('\n');
+			str.append(CodeWriter.NL);
 			str.append(Utils.getStackTrace(cause));
 		}
 		return str.toString();

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LocalVarsDebugInfoAttr.java
Patch:
@@ -7,6 +7,8 @@
 import jadx.core.dex.visitors.debuginfo.LocalVar;
 import jadx.core.utils.Utils;
 
+import static jadx.core.codegen.CodeWriter.NL;
+
 public class LocalVarsDebugInfoAttr implements IAttribute {
 	private final List<LocalVar> localVars;
 
@@ -25,6 +27,6 @@ public AType<LocalVarsDebugInfoAttr> getType() {
 
 	@Override
 	public String toString() {
-		return "Debug Info:\n  " + Utils.listToString(localVars, "\n  ");
+		return "Debug Info:" + NL + "  " + Utils.listToString(localVars, NL + "  ");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -7,6 +7,8 @@
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.instructions.PhiInsn;
 
+import static com.google.common.base.Ascii.NL;
+
 public class PhiListAttr implements IAttribute {
 
 	private final List<PhiInsn> list = new LinkedList<>();
@@ -28,7 +30,7 @@ public String toString() {
 			sb.append('r').append(phiInsn.getResult().getRegNum()).append(' ');
 		}
 		for (PhiInsn phiInsn : list) {
-			sb.append("\n  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
+			sb.append(NL).append("  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
 		}
 		return sb.toString();
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -10,6 +10,7 @@
 
 import com.android.dx.io.instructions.DecodedInstruction;
 
+import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.instructions.InsnType;
@@ -408,9 +409,9 @@ protected void appendArgs(StringBuilder sb) {
 			sb.append(argsStr);
 		} else {
 			// wrap args
-			String separator = "\n  ";
+			String separator = CodeWriter.NL + "  ";
 			sb.append(separator).append(Utils.listToString(arguments, separator));
-			sb.append('\n');
+			sb.append(CodeWriter.NL);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParseVisitor.java
Patch:
@@ -20,6 +20,8 @@
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxException;
 
+import static jadx.core.codegen.CodeWriter.NL;
+
 @JadxVisitor(
 		name = "Debug Info Parser",
 		desc = "Parse debug information (variable names and types, instruction lines)",
@@ -42,7 +44,7 @@ public void visit(MethodNode mth) throws JadxException {
 		} catch (Exception e) {
 			mth.addComment("JADX WARNING: Error to parse debug info: "
 					+ ErrorsCounter.formatMsg(mth, e.getMessage())
-					+ '\n' + Utils.getStackTrace(e));
+					+ NL + Utils.getStackTrace(e));
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -26,6 +26,7 @@
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
+import static jadx.core.codegen.CodeWriter.NL;
 import static jadx.core.utils.files.FileUtils.isApkFile;
 import static jadx.core.utils.files.FileUtils.isZipDexFile;
 
@@ -197,7 +198,7 @@ private static List<Path> loadFromJar(Path jar) throws DecodeException {
 			}
 			return pathList;
 		} catch (Exception e) {
-			throw new DecodeException("java class to dex conversion error:\n " + e.getMessage(), e);
+			throw new DecodeException("java class to dex conversion error:" + NL + "  " + e.getMessage(), e);
 		} finally {
 			if (j2d.isError()) {
 				LOG.warn("dx message: {}", j2d.getDxErrors());

File: jadx-gui/src/main/java/jadx/gui/ui/ImagePanel.java
Patch:
@@ -18,6 +18,8 @@
 import jadx.gui.treemodel.JResource;
 import jadx.gui.ui.codearea.AbstractCodeArea;
 
+import static jadx.core.codegen.CodeWriter.NL;
+
 public class ImagePanel extends ContentPanel {
 	private static final long serialVersionUID = 4071356367073142688L;
 
@@ -30,7 +32,7 @@ public class ImagePanel extends ContentPanel {
 			add(imageViewer.getComponent());
 		} catch (Exception e) {
 			RSyntaxTextArea textArea = AbstractCodeArea.getDefaultArea(panel.getMainWindow());
-			textArea.setText("Image load error: \n" + Utils.getStackTrace(e));
+			textArea.setText("Image load error:" + NL + Utils.getStackTrace(e));
 			add(textArea);
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java
Patch:
@@ -1,7 +1,7 @@
 package jadx.gui.utils;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import jadx.api.JavaClass;
 import jadx.api.JavaField;
@@ -15,7 +15,7 @@
 
 public class JNodeCache {
 
-	private final Map<JavaNode, JNode> cache = new HashMap<>();
+	private final Map<JavaNode, JNode> cache = new ConcurrentHashMap<>();
 
 	public JNode makeFrom(JavaNode javaNode) {
 		if (javaNode == null) {

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -105,12 +105,12 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new SimplifyVisitor());
 			passes.add(new CheckRegions());
 
+			passes.add(new EnumVisitor());
 			passes.add(new ExtractFieldInit());
 			passes.add(new FixAccessModifiers());
 			passes.add(new ProcessAnonymous());
 			passes.add(new ClassModifier());
 			passes.add(new MethodInlineVisitor());
-			passes.add(new EnumVisitor());
 			passes.add(new LoopRegionVisitor());
 
 			passes.add(new ProcessVariables());

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -174,6 +174,7 @@ private void loadAnnotations(ClassDef cls) {
 	private void loadStaticValues(ClassDef cls, List<FieldNode> staticFields) throws DecodeException {
 		for (FieldNode f : staticFields) {
 			if (f.getAccessFlags().isFinal()) {
+				// incorrect initialization will be removed if assign found in constructor
 				f.addAttr(FieldInitAttr.NULL_VALUE);
 			}
 		}

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsWithStaticFields.java
Patch:
@@ -14,7 +14,7 @@ public void test() {
 		assertThat(getClassNodeFromSmali())
 				.code()
 				.containsOnlyOnce("INSTANCE;")
-				.containsOnlyOnce("private static c sB;")
+				.containsOnlyOnce("private static c sB")
 				.doesNotContain(" sA")
 				.doesNotContain(" sC")
 				.doesNotContain("private TestEnumsWithStaticFields(String str) {");

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -607,6 +607,7 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)
 		if (cls != null && cls.isAnonymous() && !fallback) {
 			cls.ensureProcessed();
 			inlineAnonymousConstructor(code, cls, insn);
+			mth.getParentClass().addInlinedClass(cls);
 			return;
 		}
 		if (insn.isSelf()) {

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign.java
Patch:
@@ -9,7 +9,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 
-public class TestConditions19 extends IntegrationTest {
+public class TestInnerAssign extends IntegrationTest {
 
 	public static class TestCls {
 		private String result;

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -64,7 +64,7 @@ private static void checkTypes(MethodNode mth) {
 		mth.getSVars().forEach(var -> {
 			ArgType type = var.getTypeInfo().getType();
 			if (!type.isTypeKnown()) {
-				mth.addComment("JADX WARNING: type inference failed for: " + var.getDetailedVarInfo(mth));
+				mth.addWarnComment("Type inference failed for: " + var.getDetailedVarInfo(mth));
 			}
 		});
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -422,6 +422,7 @@ private static void markOneArgAsThis(RegisterArg arg) {
 			if (resArg.getRegNum() != arg.getRegNum()
 					&& !resArg.getSVar().isUsedInPhi()) {
 				markThisArgs(resArg);
+				parentInsn.add(AFlag.REMOVE);
 				parentInsn.add(AFlag.DONT_GENERATE);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -623,7 +623,7 @@ private InsnNode decodeSwitch(DecodedInstruction insn, int offset, boolean packe
 			targets[i] = targets[i] - payloadOffset + offset;
 		}
 		int nextOffset = getNextInsnOffset(insnArr, offset);
-		return new SwitchNode(InsnArg.reg(insn, 0, ArgType.NARROW), keys, targets, nextOffset);
+		return new SwitchNode(InsnArg.reg(insn, 0, ArgType.NARROW), keys, targets, nextOffset, packed);
 	}
 
 	private InsnNode fillArray(DecodedInstruction insn) {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch2.java
Patch:
@@ -17,7 +17,7 @@ public static class TestCls {
 		boolean isScrolling;
 		float multiTouchZoomOldDist;
 
-		void test(int action) {
+		public void test(int action) {
 			switch (action & 255) {
 				case 0:
 					this.isLongtouchable = true;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase.java
Patch:
@@ -47,6 +47,8 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsString("switch (a % 10) {"));
+
+		// case 5: removed
 		assertEquals(5, count(code, "case "));
 		assertEquals(3, count(code, "break;"));
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java
Patch:
@@ -26,6 +26,7 @@ public String test(int a, boolean b, boolean c) {
 						}
 						break;
 					}
+					// fallthrough
 				case 2:
 					if (b) {
 						str += "2";

File: jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java
Patch:
@@ -16,6 +16,7 @@
 
 import javax.swing.*;
 
+import jadx.gui.utils.CodeUsageInfo;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -237,6 +238,8 @@ private void refreshTabs(TabbedPane tabbedPane, Set<JavaClass> updatedClasses) {
 				JavaClass javaClass = rootClass.getCls();
 				if (updatedClasses.contains(javaClass) || node.getRootClass().getCls() == javaClass) {
 					LOG.info("Refreshing rootClass " + javaClass.getRawName());
+					javaClass.unload();
+					javaClass.getClassNode().deepUnload();
 					rootClass.refresh(); // Update code cache
 					ClassCodeContentPanel codePanel = (ClassCodeContentPanel) contentPanel;
 					CodePanel javaPanel = codePanel.getJavaCodePanel();

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -59,7 +59,7 @@ public void decompile() {
 
 	public synchronized void refresh() {
 		listsLoaded = false;
-		cls.reloadCode();
+		cls.reRunDecompile();
 	}
 
 	public synchronized String getSmali() {

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java
Patch:
@@ -14,11 +14,13 @@ public static class TestCls {
 
 		public enum Operation implements IOperation {
 			PLUS {
+				@Override
 				public int apply(int x, int y) {
 					return x + y;
 				}
 			},
 			MINUS {
+				@Override
 				public int apply(int x, int y) {
 					return x - y;
 				}

File: jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java
Patch:
@@ -132,6 +132,7 @@ private boolean writeDeobfMapFile(Path deobfMapPath, List<String> deobfMap) thro
 		Files.copy(deobfMapPath, oldMap.toPath(), StandardCopyOption.REPLACE_EXISTING);
 		Files.copy(tmpFile.toPath(), deobfMapPath, StandardCopyOption.REPLACE_EXISTING);
 		Files.delete(oldMap.toPath());
+		Files.delete(tmpFile.toPath());
 		return true;
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.Objects;
 import java.util.jar.JarEntry;
 import java.util.jar.JarOutputStream;
+import java.util.stream.Stream;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
@@ -92,9 +93,8 @@ public static boolean deleteDir(File dir) {
 	}
 
 	public static void deleteDir(Path dir) {
-		try {
-			Files.walk(dir)
-					.sorted(Comparator.reverseOrder())
+		try (Stream<Path> pathStream = Files.walk(dir)) {
+			pathStream.sorted(Comparator.reverseOrder())
 					.map(Path::toFile)
 					.forEach(File::delete);
 		} catch (Exception e) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java
Patch:
@@ -40,7 +40,6 @@ class SearchBar extends JToolBar {
 
 	private final JCheckBox wholeWordCB;
 	private final JCheckBox matchCaseCB;
-	private ActionListener forwardListener = e -> search(0);
 
 	public SearchBar(RSyntaxTextArea textArea) {
 		rTextArea = textArea;
@@ -81,6 +80,8 @@ public void keyReleased(KeyEvent e) {
 		nextButton.setBorderPainted(false);
 		add(nextButton);
 
+		ActionListener forwardListener = e -> search(0);
+
 		markAllCB = new JCheckBox(NLS.str("search.mark_all"));
 		markAllCB.addActionListener(forwardListener);
 		add(markAllCB);

File: jadx-gui/src/main/java/jadx/gui/utils/SystemInfo.java
Patch:
@@ -17,4 +17,7 @@ public class SystemInfo {
 	public static final boolean IS_WINDOWS = LOWER_OS_NAME.startsWith("windows");
 	public static final boolean IS_MAC = LOWER_OS_NAME.startsWith("mac");
 	public static final boolean IS_LINUX = LOWER_OS_NAME.startsWith("linux");
+
+	private SystemInfo() {
+	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -183,7 +183,7 @@ public static void makeStaticFieldAccess(CodeWriter code, FieldInfo field, Class
 		ClassInfo declClass = field.getDeclClass();
 		// TODO
 		boolean fieldFromThisClass = clsGen.getClassNode().getClassInfo().equals(declClass);
-		if (!fieldFromThisClass) {
+		if (!fieldFromThisClass || !clsGen.isBodyGenStarted()) {
 			// Android specific resources class handler
 			if (!handleAppResField(code, clsGen, declClass)) {
 				clsGen.useClass(code, declClass);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java
Patch:
@@ -118,6 +118,7 @@ public String getAttributesString() {
 		return storage.toString();
 	}
 
+	@Override
 	public boolean isAttrStorageEmpty() {
 		return storage.isEmpty();
 	}

File: jadx-core/src/main/java/jadx/core/dex/attributes/IAttributeNode.java
Patch:
@@ -35,4 +35,6 @@ public interface IAttributeNode {
 	List<String> getAttributesStringsList();
 
 	String getAttributesString();
+
+	boolean isAttrStorageEmpty();
 }

File: jadx-core/src/main/java/jadx/api/ICodeCache.java
Patch:
@@ -8,6 +8,4 @@ public interface ICodeCache {
 
 	@Nullable
 	ICodeInfo get(String clsFullName);
-
-	void remove(String clsFullName);
 }

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -57,8 +57,9 @@ public void decompile() {
 		cls.decompile();
 	}
 
-	public void refresh() {
-		cls.refresh();
+	public synchronized void refresh() {
+		listsLoaded = false;
+		cls.reloadCode();
 	}
 
 	public synchronized String getSmali() {

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java
Patch:
@@ -46,7 +46,7 @@ public RenameReasonAttr notPrintable() {
 	public RenameReasonAttr append(String reason) {
 		if (description.isEmpty()) {
 			description += reason;
-		} else if (!description.contains(reason)) {
+		} else {
 			description += " and " + reason;
 		}
 		return this;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -105,7 +105,7 @@ private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode
 			return false;
 		}
 		List<RegisterArg> args = mth.getArgRegs();
-		if (args.isEmpty()) {
+		if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {
 			return false;
 		}
 		RegisterArg arg = args.get(0);

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java
Patch:
@@ -46,7 +46,7 @@ public RenameReasonAttr notPrintable() {
 	public RenameReasonAttr append(String reason) {
 		if (description.isEmpty()) {
 			description += reason;
-		} else {
+		} else if (!description.contains(reason)) {
 			description += " and " + reason;
 		}
 		return this;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -90,5 +90,7 @@ public class AType<T extends IAttribute> {
 			RENAME_REASON,
 			JADX_WARN,
 			JADX_ERROR,
+			FIELD_INIT,
+			SOURCE_FILE,
 			SKIP_MTH_ARGS));
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -171,7 +171,9 @@ private void loadAnnotations(ClassDef cls) {
 
 	private void loadStaticValues(ClassDef cls, List<FieldNode> staticFields) throws DecodeException {
 		for (FieldNode f : staticFields) {
-			if (f.getAccessFlags().isFinal()) {
+			AccessInfo flags = f.getAccessFlags();
+			if (flags.isStatic() && flags.isFinal()) {
+				LOG.debug("loadStaticValues(): Adding NULL initializer to static final field {}", f.getAlias());
 				f.addAttr(FieldInitAttr.NULL_VALUE);
 			}
 		}

File: jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java
Patch:
@@ -54,10 +54,10 @@ public TextSearchIndex(JNodeCache nodeCache) {
 	public void indexNames(JavaClass cls) {
 		clsNamesIndex.put(cls.getFullName(), nodeCache.makeFrom(cls));
 		for (JavaMethod mth : cls.getMethods()) {
-			mthNamesIndex.put(mth.getFullName(), nodeCache.makeFrom(mth));
+			mthNamesIndex.put(mth.getName(), nodeCache.makeFrom(mth));
 		}
 		for (JavaField fld : cls.getFields()) {
-			fldNamesIndex.put(fld.getFullName(), nodeCache.makeFrom(fld));
+			fldNamesIndex.put(fld.getName(), nodeCache.makeFrom(fld));
 		}
 		for (JavaClass innerCls : cls.getInnerClasses()) {
 			indexNames(innerCls);

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -467,7 +467,9 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro
 			case MONITOR_EXIT:
 				if (isFallback()) {
 					code.add("monitor-exit(");
-					addArg(code, insn.getArg(0));
+					if (insn.getArgsCount() == 1) {
+						addArg(code, insn.getArg(0));
+					}
 					code.add(')');
 				}
 				break;

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java
Patch:
@@ -79,7 +79,7 @@ public void init() {
 
 		@Override
 		protected Boolean doInBackground() throws Exception {
-			progressPane.changeLabel(this, task.getTitle() + ':');
+			progressPane.changeLabel(this, task.getTitle() + "… ");
 			progressPane.changeCancelBtnVisible(this, task.canBeCanceled());
 			progressPane.changeVisibility(this, true);
 
@@ -125,7 +125,8 @@ private boolean waitTermination(ThreadPoolExecutor executor) throws InterruptedE
 				}
 				if (isCancelled()) {
 					executor.shutdownNow();
-					progressPane.changeLabel(this, task.getTitle() + " (Canceling):");
+					progressPane.changeLabel(this, task.getTitle() + " (Canceling)… ");
+					progressPane.changeIndeterminate(this, true);
 					// force termination
 					executor.awaitTermination(5, TimeUnit.SECONDS);
 					return false;

File: jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java
Patch:
@@ -19,6 +19,6 @@ protected void runJob() {
 
 	@Override
 	public String getInfoString() {
-		return NLS.str("progress.decompile");
+		return NLS.str("progress.decompile") + "… ";
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java
Patch:
@@ -68,6 +68,6 @@ protected List<StringRef> splitLines(JavaClass cls) {
 
 	@Override
 	public String getInfoString() {
-		return NLS.str("progress.index");
+		return NLS.str("progress.index") + "… ";
 	}
 }

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -73,7 +73,7 @@ public ClassNode getClassNode() {
 		return cls;
 	}
 
-	private void loadLists() {
+	private synchronized void loadLists() {
 		if (listsLoaded) {
 			return;
 		}

File: jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java
Patch:
@@ -9,7 +9,6 @@
 
 import jadx.api.ICodeInfo;
 import jadx.api.ResourceFile;
-import jadx.core.codegen.CodeWriter;
 
 public class ResContainer implements Comparable<ResContainer> {
 
@@ -34,7 +33,7 @@ public static ResContainer resourceFileLink(ResourceFile resFile) {
 		return new ResContainer(resFile.getName(), Collections.emptyList(), resFile, DataType.RES_LINK);
 	}
 
-	public static ResContainer resourceTable(String name, List<ResContainer> subFiles, CodeWriter rootContent) {
+	public static ResContainer resourceTable(String name, List<ResContainer> subFiles, ICodeInfo rootContent) {
 		return new ResContainer(name, subFiles, rootContent, DataType.RES_TABLE);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java
Patch:
@@ -2,13 +2,15 @@
 
 import jadx.api.JavaClass;
 import jadx.gui.JadxWrapper;
+import jadx.gui.utils.NLS;
 
 public class DecompileJob extends BackgroundJob {
 
 	public DecompileJob(JadxWrapper wrapper, int threadsCount) {
 		super(wrapper, threadsCount);
 	}
 
+	@Override
 	protected void runJob() {
 		for (final JavaClass cls : wrapper.getIncludedClasses()) {
 			addTask(cls::decompile);
@@ -17,6 +19,6 @@ protected void runJob() {
 
 	@Override
 	public String getInfoString() {
-		return "Decompiling: ";
+		return NLS.str("progress.decompile");
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java
Patch:
@@ -13,6 +13,7 @@
 import jadx.gui.utils.CodeLinesInfo;
 import jadx.gui.utils.CodeUsageInfo;
 import jadx.gui.utils.JNodeCache;
+import jadx.gui.utils.NLS;
 import jadx.gui.utils.UiUtils;
 import jadx.gui.utils.search.StringRef;
 import jadx.gui.utils.search.TextSearchIndex;
@@ -27,6 +28,7 @@ public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {
 		this.cache = cache;
 	}
 
+	@Override
 	protected void runJob() {
 		JNodeCache nodeCache = cache.getNodeCache();
 		final TextSearchIndex index = new TextSearchIndex(nodeCache);
@@ -66,6 +68,6 @@ protected List<StringRef> splitLines(JavaClass cls) {
 
 	@Override
 	public String getInfoString() {
-		return "Indexing: ";
+		return NLS.str("progress.index");
 	}
 }

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -163,6 +163,7 @@ private void addEntry(List<ResourceFile> list, File zipFile, ZipEntry entry) {
 		}
 	}
 
+	@SuppressWarnings("CharsetObjectCanBeUsed")
 	public static ICodeInfo loadToCodeWriter(InputStream is) throws IOException {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream(READ_BUFFER_SIZE);
 		copyStream(is, baos);

File: jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java
Patch:
@@ -153,6 +153,7 @@ private CodeWriter addLineIndent() {
 		return this;
 	}
 
+	@SuppressWarnings("StringRepeatCanBeUsed")
 	private void updateIndent() {
 		int curIndent = indent;
 		if (curIndent < INDENT_CACHE.length) {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java
Patch:
@@ -71,7 +71,7 @@ public final void update() {
 		} else {
 			removeAllChildren();
 
-			Comparator<JResource> typeComparator = (r1, r2) -> r1.type.ordinal() - r2.type.ordinal();
+			Comparator<JResource> typeComparator = Comparator.comparingInt(r -> r.type.ordinal());
 			Comparator<JResource> nameComparator = Comparator.comparing(JResource::getName, String.CASE_INSENSITIVE_ORDER);
 
 			files.sort(typeComparator.thenComparing(nameComparator));

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java
Patch:
@@ -91,6 +91,7 @@ private void setCaretAtLine(int line) {
 		}
 	}
 
+	@SuppressWarnings("deprecation")
 	public void centerCurrentLine() {
 		JViewport viewport = (JViewport) SwingUtilities.getAncestorOfClass(JViewport.class, this);
 		if (viewport == null) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java
Patch:
@@ -11,6 +11,7 @@
 import org.jetbrains.annotations.Nullable;
 
 public abstract class JNodeMenuAction<T> extends AbstractAction implements PopupMenuListener {
+	private static final long serialVersionUID = -2600154727884853550L;
 
 	protected final transient CodeArea codeArea;
 	@Nullable

File: jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java
Patch:
@@ -182,6 +182,7 @@ public static void setWindowIcons(Window window) {
 
 	public static final int CTRL_BNT_KEY = getCtrlButton();
 
+	@SuppressWarnings("deprecation")
 	@MagicConstant(flagsFromClass = InputEvent.class)
 	private static int getCtrlButton() {
 		if (System.getProperty("os.name").toLowerCase().contains("mac")) {

File: jadx-samples/src/main/java/jadx/samples/TestTypeResolver2.java
Patch:
@@ -9,6 +9,7 @@ public class TestTypeResolver2 extends AbstractTest {
 
 	private static String result = "";
 
+	@SuppressWarnings({ "UnnecessaryBoxing", "CachedNumberConstructorCall", "deprecation" })
 	public void testOverloadedMethods() {
 		Object s1 = "The";
 		Object s2 = "answer";

File: jadx-gui/src/main/java/jadx/gui/utils/NLS.java
Patch:
@@ -34,6 +34,7 @@ public class NLS {
 		LANG_LOCALES.add(new LangLocale("en", "US")); // As default language
 		LANG_LOCALES.add(new LangLocale("zh", "CN"));
 		LANG_LOCALES.add(new LangLocale("es", "ES"));
+		LANG_LOCALES.add(new LangLocale("de", "DE"));
 
 		LANG_LOCALES.forEach(NLS::load);
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -608,6 +608,7 @@ private static void traverseMonitorExits(SynchronizedRegion region, InsnArg arg,
 		visited.add(block);
 		for (InsnNode insn : block.getInstructions()) {
 			if (insn.getType() == InsnType.MONITOR_EXIT
+					&& insn.getArgsCount() > 0
 					&& insn.getArg(0).equals(arg)) {
 				exits.add(block);
 				region.getExitInsns().add(insn);

File: jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java
Patch:
@@ -16,6 +16,8 @@ public JadxCodeAssertions code() {
 		isNotNull();
 		ICodeInfo code = actual.getCode();
 		assertThat(code).isNotNull();
-		return new JadxCodeAssertions(code.getCodeStr());
+		String codeStr = code.getCodeStr();
+		assertThat(codeStr).isNotBlank();
+		return new JadxCodeAssertions(codeStr);
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -660,7 +660,7 @@ public void actionPerformed(ActionEvent e) {
 		Action exitAction = new AbstractAction(NLS.str("file.exit"), ICON_CLOSE) {
 			@Override
 			public void actionPerformed(ActionEvent e) {
-				dispose();
+				closeWindow();
 			}
 		};
 

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -41,7 +41,7 @@ public class BinaryXMLParser extends CommonBinaryParser {
 
 	private final Map<Integer, String> styleMap = new HashMap<>();
 	private final Map<Integer, String> resNames;
-	private final Map<String, String> nsMap = new HashMap<>();
+	private Map<String, String> nsMap;
 	private Set<String> nsMapGenerated;
 	private final Map<String, String> tagAttrDeobfNames = new HashMap<>();
 
@@ -86,11 +86,13 @@ public synchronized CodeWriter parse(InputStream inputStream) throws IOException
 			return ResourcesLoader.loadToCodeWriter(inputStream);
 		}
 		nsMapGenerated = new HashSet<>();
+		nsMap = new HashMap<>();
 		writer = new CodeWriter();
 		writer.add("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
 		firstElement = true;
 		decode();
 		writer.finish();
+		nsMap = null;
 		return writer;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -655,6 +655,9 @@ private BlockNode processIf(IRegion currentRegion, BlockNode block, IfNode ifnod
 		}
 
 		IfInfo currentIf = makeIfInfo(block);
+		if (currentIf == null) {
+			return null;
+		}
 		IfInfo mergedIf = mergeNestedIfNodes(currentIf);
 		if (mergedIf != null) {
 			currentIf = mergedIf;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions19.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
@@ -41,13 +40,13 @@ public void check() {
 	}
 
 	@Test
-	@NotYetImplemented("Inner assignment or labeled block with break")
 	public void test() {
 		noDebugInfo();
 
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
+		assertThat(code, containsOne("str.length()"));
 		assertThat(code, containsOne("System.out.println(\"done\");"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java
Patch:
@@ -23,6 +23,7 @@
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.RootNode;
+import jadx.core.utils.files.FileUtils;
 import jadx.core.utils.files.InputFile;
 
 public class RenameVisitor extends AbstractVisitor {
@@ -35,9 +36,7 @@ public void init(RootNode root) {
 		}
 		InputFile firstInputFile = dexNodes.get(0).getDexFile().getInputFile();
 		Path inputFilePath = firstInputFile.getFile().getAbsoluteFile().toPath();
-
-		String inputName = inputFilePath.getFileName().toString();
-		String baseName = inputName.substring(0, inputName.lastIndexOf('.'));
+		String baseName = FileUtils.getPathBaseName(inputFilePath);
 		Path deobfMapPath = inputFilePath.getParent().resolve(baseName + ".jobf");
 
 		JadxArgs args = root.getArgs();

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -39,7 +39,7 @@ public void test() {
 
 		ClassNode cls = getClassNode(TestCls.class);
 		Map<Integer, Integer> lineMapping = cls.getCode().getLineMapping();
-		assertEquals("{8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}",
+		assertEquals("{5=17, 8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}",
 				lineMapping.toString());
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java
Patch:
@@ -19,7 +19,9 @@ public static CodeVar fromMthArg(RegisterArg mthArg) {
 		var.setName(mthArg.getName());
 		var.setDeclared(true);
 		var.setThis(mthArg.isThis());
-		var.setSsaVars(Collections.singletonList(new SSAVar(mthArg.getRegNum(), 0, mthArg)));
+		SSAVar ssaVar = new SSAVar(mthArg.getRegNum(), 0, mthArg);
+		ssaVar.setCodeVar(var);
+		var.setSsaVars(Collections.singletonList(ssaVar));
 		return var;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -323,7 +323,9 @@ public boolean isDeepEquals(InsnNode other) {
 	}
 
 	protected final <T extends InsnNode> T copyCommonParams(T copy) {
-		copy.setResult(result);
+		if (result != null) {
+			copy.setResult(result.duplicate());
+		}
 		if (copy.getArgsCount() == 0) {
 			for (InsnArg arg : this.getArguments()) {
 				if (arg.isInsnWrap()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -677,7 +677,7 @@ private static InsnNode duplicateReturnInsn(InsnNode returnInsn) {
 		InsnNode insn = new InsnNode(returnInsn.getType(), returnInsn.getArgsCount());
 		if (returnInsn.getArgsCount() == 1) {
 			RegisterArg arg = (RegisterArg) returnInsn.getArg(0);
-			insn.addArg(InsnArg.reg(arg.getRegNum(), arg.getInitType()));
+			insn.addArg(arg.duplicate());
 		}
 		insn.copyAttributesFrom(returnInsn);
 		insn.setOffset(returnInsn.getOffset());

File: jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java
Patch:
@@ -39,11 +39,10 @@ public void test() {
 		assertThat(code, containsOne("l = 0L;"));
 
 		// checks for 'check' method
-		assertThat(code, containsOne("test(null)"));
+		assertThat(code, containsOne("test((Long) null)")); // TODO: cast not needed
 		assertThat(code, containsOne("test(0L)"));
 		assertThat(code, countString(2, "is(0L)"));
 		assertThat(code, containsOne("test(7L)"));
 		assertThat(code, containsOne("is(7L)"));
-
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -54,8 +54,8 @@ private JadxSettingsAdapter() {
 	}
 
 	public static JadxSettings load() {
+		String jsonSettings = PREFS.get(JADX_GUI_KEY, "");
 		try {
-			String jsonSettings = PREFS.get(JADX_GUI_KEY, "");
 			JadxSettings settings = fromString(jsonSettings);
 			if (settings == null) {
 				LOG.debug("Created new settings.");
@@ -68,7 +68,7 @@ public static JadxSettings load() {
 			}
 			return settings;
 		} catch (Exception e) {
-			LOG.error("Error load settings", e);
+			LOG.error("Error load settings. Settings will reset.\n Loaded json string: {}", jsonSettings, e);
 			return new JadxSettings();
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.core.dex.attributes;
 
 public enum AFlag {
+	MTH_ENTER_BLOCK,
 	TRY_ENTER,
 	TRY_LEAVE,
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -39,7 +39,7 @@ public class BlockProcessor extends AbstractVisitor {
 
 	@Override
 	public void visit(MethodNode mth) {
-		if (mth.isNoCode()) {
+		if (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {
 			return;
 		}
 		processBlocksTree(mth);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -39,7 +39,7 @@ public class RegionMakerVisitor extends AbstractVisitor {
 
 	@Override
 	public void visit(MethodNode mth) throws JadxException {
-		if (mth.isNoCode()) {
+		if (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {
 			return;
 		}
 		RegionMaker rm = new RegionMaker(mth);

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -14,7 +14,6 @@
 import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;
 import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;
 import static jadx.core.dex.nodes.ProcessState.PROCESS_STARTED;
-import static jadx.core.dex.nodes.ProcessState.UNLOADED;
 
 public final class ProcessClass {
 
@@ -27,8 +26,7 @@ public static void process(ClassNode cls) {
 			process(topParentClass);
 			return;
 		}
-		if (cls.getState() == PROCESS_COMPLETE
-				|| cls.getState() == UNLOADED) {
+		if (cls.getState().isProcessed()) {
 			// nothing to do
 			return;
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -276,7 +276,6 @@ public List<ArgType> getMethodArgTypes(MethodInfo callMth) {
 	public List<GenericInfo> getClassGenerics(ArgType type) {
 		ClassNode classNode = resolveClass(ClassInfo.fromType(this, type));
 		if (classNode != null) {
-			classNode.loadAndProcess();
 			return classNode.getGenerics();
 		}
 		NClass clsDetails = getClsp().getClsDetails(type);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -275,7 +275,6 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 		if (!mth.getParentClass().getInnerClasses().contains(classNode)) {
 			return;
 		}
-		classNode.loadAndProcess();
 		Map<InsnArg, FieldNode> argsMap = getArgsToFieldsMapping(callMthNode, co);
 		if (argsMap.isEmpty() && !callMthNode.getArgRegs().isEmpty()) {
 			return;

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -27,6 +27,7 @@
 import jadx.api.JadxArgs;
 import jadx.api.JadxDecompiler;
 import jadx.api.JadxInternalAccess;
+import jadx.core.ProcessClass;
 import jadx.core.codegen.CodeGen;
 import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.AFlag;
@@ -223,7 +224,7 @@ private void insertResources(RootNode root) {
 	}
 
 	protected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {
-		cls.loadAndProcess();
+		ProcessClass.process(cls);
 		generateClsCode(cls);
 		// don't unload class
 	}

File: jadx-gui/src/main/java/jadx/gui/JadxGUI.java
Patch:
@@ -5,6 +5,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.cli.LogHelper;
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.settings.JadxSettingsAdapter;
 import jadx.gui.ui.MainWindow;
@@ -18,6 +19,7 @@ public static void main(String[] args) {
 		try {
 			LogCollector.register();
 			final JadxSettings settings = JadxSettingsAdapter.load();
+			settings.setLogLevel(LogHelper.LogLevelEnum.INFO);
 			// overwrite loaded settings by command line arguments
 			if (!settings.overrideProvided(args)) {
 				return;

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java
Patch:
@@ -184,7 +184,7 @@ private ArgType consumeObjectType(boolean incompleteType) {
 				if (inner == null) {
 					throw new JadxRuntimeException("No inner type found: " + debugString());
 				}
-				return ArgType.genericInner(genericType, inner.getObject(), inner.getGenericTypes());
+				return ArgType.outerGeneric(genericType, inner);
 			} else {
 				consume(';');
 				return genericType;

File: jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java
Patch:
@@ -1,12 +1,15 @@
 package jadx.core.dex.instructions;
 
+import org.jetbrains.annotations.Nullable;
+
 import jadx.core.dex.info.MethodInfo;
 import jadx.core.dex.instructions.args.RegisterArg;
 
 public interface CallMthInterface {
 
 	MethodInfo getCallMth();
 
+	@Nullable
 	RegisterArg getInstanceArg();
 
 	/**

File: jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java
Patch:
@@ -35,6 +35,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return super.toString() + ' ' + clsType;
+		return super.toString() + ' ' + clsType + ".class";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 
-public class ConstructorInsn extends InsnNode implements CallMthInterface {
+public final class ConstructorInsn extends InsnNode implements CallMthInterface {
 
 	private final MethodInfo callMth;
 	private final CallType callType;

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundInvokeAssign.java
Patch:
@@ -4,6 +4,7 @@
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.RootNode;
+import jadx.core.utils.TypeUtils;
 
 /**
  * Special dynamic bound for invoke with generics.
@@ -37,7 +38,7 @@ public ArgType getType() {
 	}
 
 	private ArgType getReturnType(ArgType instanceType) {
-		ArgType resultGeneric = TypeUpdate.getResultGeneric(root, instanceType, genericReturnType);
+		ArgType resultGeneric = TypeUtils.replaceClassGenerics(root, instanceType, genericReturnType);
 		if (resultGeneric != null) {
 			return resultGeneric;
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -244,12 +244,12 @@ private void initArguments(List<ArgType> args) {
 			return;
 		}
 		argsList = new ArrayList<>(args.size());
-		for (ArgType arg : args) {
-			RegisterArg regArg = InsnArg.reg(pos, arg);
+		for (ArgType argType : args) {
+			RegisterArg regArg = InsnArg.reg(pos, argType);
 			regArg.add(AFlag.METHOD_ARGUMENT);
 			regArg.add(AFlag.IMMUTABLE_TYPE);
 			argsList.add(regArg);
-			pos += arg.getRegCount();
+			pos += argType.getRegCount();
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java
Patch:
@@ -134,8 +134,7 @@ private boolean isNeedExplicitCast(RegisterArg resArg, ArgType primitiveType, Ar
 
 	private boolean canChangeTypeToPrimitive(RegisterArg arg) {
 		for (SSAVar ssaVar : arg.getSVar().getCodeVar().getSsaVars()) {
-			RegisterArg assignArg = ssaVar.getAssign();
-			if (assignArg.contains(AFlag.IMMUTABLE_TYPE)) {
+			if (ssaVar.isTypeImmutable()) {
 				return false;
 			}
 			for (RegisterArg useArg : ssaVar.getUseList()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 import java.util.stream.Collectors;
 
@@ -89,8 +90,8 @@ private static void setCodeVar(SSAVar ssaVar, CodeVar codeVar) {
 	private static void setCodeVarType(CodeVar codeVar, Set<SSAVar> vars) {
 		if (vars.size() > 1) {
 			List<ArgType> imTypes = vars.stream()
-					.filter(var -> var.contains(AFlag.IMMUTABLE_TYPE))
-					.map(var -> var.getTypeInfo().getType())
+					.map(SSAVar::getImmutableType)
+					.filter(Objects::nonNull)
 					.filter(ArgType::isTypeKnown)
 					.distinct()
 					.collect(Collectors.toList());

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -294,7 +294,7 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 				SSAVar sVar = reg.getSVar();
 				if (sVar != null) {
 					sVar.getCodeVar().setFinal(true);
-					sVar.add(AFlag.DONT_INLINE);
+					sVar.getAssign().add(AFlag.DONT_INLINE);
 				}
 				reg.add(AFlag.SKIP_ARG);
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -793,8 +793,7 @@ && isBadCasesOrder(blocksMap, fallThroughCases)) {
 			LOG.debug("Fixing incorrect switch cases order, method: {}", mth);
 			blocksMap = reOrderSwitchCases(blocksMap, fallThroughCases);
 			if (isBadCasesOrder(blocksMap, fallThroughCases)) {
-				LOG.error("Can't fix incorrect switch cases order, method: {}", mth);
-				mth.add(AFlag.INCONSISTENT_CODE);
+				mth.addWarn("Can't fix incorrect switch cases order");
 			}
 		}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java
Patch:
@@ -75,7 +75,7 @@ private static void shrinkBlock(MethodNode mth, BlockNode block) {
 	private static void checkInline(MethodNode mth, BlockNode block, InsnList insnList,
 			List<WrapInfo> wrapList, ArgsInfo argsInfo, RegisterArg arg) {
 		SSAVar sVar = arg.getSVar();
-		if (sVar == null || sVar.contains(AFlag.DONT_INLINE)) {
+		if (sVar == null || sVar.getAssign().contains(AFlag.DONT_INLINE)) {
 			return;
 		}
 		// allow inline only one use arg

File: jadx-core/src/main/java/jadx/core/clsp/NMethod.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.clsp;
 
+import java.util.Arrays;
+
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -82,7 +84,7 @@ public int compareTo(@NotNull NMethod other) {
 	@Override
 	public String toString() {
 		return "NMethod{'" + shortId + '\''
-				+ ", argTypes=" + genericArgs
+				+ ", argTypes=" + Arrays.toString(genericArgs)
 				+ ", retType=" + retType
 				+ ", varArgs=" + varArgs
 				+ '}';

File: jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java
Patch:
@@ -193,7 +193,7 @@ private List<JsonCodeLine> fillMthCode(MethodNode mth, MethodGen mthGen) {
 			jsonCodeLine.setSourceLine(lineMapping.get(line));
 			Object obj = annotations.get(new CodePosition(line, 0));
 			if (obj instanceof InsnNode) {
-				int offset = ((InsnNode) obj).getOffset();
+				long offset = ((InsnNode) obj).getOffset();
 				jsonCodeLine.setOffset("0x" + Long.toHexString(mthCodeOffset + offset * 2));
 			}
 			codeLines.add(jsonCodeLine);

File: jadx-core/src/main/java/jadx/core/utils/android/Res9patchStreamDecoder.java
Patch:
@@ -50,12 +50,12 @@ public void decode(InputStream in, OutputStream out) throws JadxException {
 			drawVLine(im2, w + 1, np.padTop + 1, h - np.padBottom);
 
 			int[] xDivs = np.xDivs;
-			for (int i = 0; i < xDivs.length; i += 2) {
+			for (int i = 0; i < xDivs.length - 1; i += 2) {
 				drawHLine(im2, 0, xDivs[i] + 1, xDivs[i + 1]);
 			}
 
 			int[] yDivs = np.yDivs;
-			for (int i = 0; i < yDivs.length; i += 2) {
+			for (int i = 0; i < yDivs.length - 1; i += 2) {
 				drawVLine(im2, 0, yDivs[i] + 1, yDivs[i + 1]);
 			}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -143,7 +143,7 @@ protected InsnArg removeArg(int index) {
 		return arg;
 	}
 
-	protected int getArgIndex(InsnArg arg) {
+	public int getArgIndex(InsnArg arg) {
 		int count = getArgsCount();
 		for (int i = 0; i < count; i++) {
 			if (arg == arguments.get(i)) {

File: jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing3.java
Patch:
@@ -55,6 +55,5 @@ public void testFull() {
 
 		assertThat(code, containsOne("Pair<Long, String> pair = this.cache.get(id);"));
 		assertThat(code, containsOne("return pair.first + l > System.currentTimeMillis();"));
-
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java
Patch:
@@ -38,7 +38,7 @@ public static void changeVisibility(ICodeNode node, int newVisFlag) {
 		AccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);
 		if (newAccFlags != accessFlags) {
 			node.setAccessFlags(newAccFlags);
-			node.addAttr(AType.COMMENTS, "access modifiers changed from: " + accessFlags.getVisibility().rawString());
+			node.addAttr(AType.COMMENTS, "access modifiers changed from: " + accessFlags.visibilityName());
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -132,6 +132,9 @@ private String makeArgName(CodeVar var) {
 		if (!NameMapper.isValidAndPrintable(varName)) {
 			varName = getFallbackName(var);
 		}
+		if (Consts.DEBUG) {
+			varName += '_' + getFallbackName(var);
+		}
 		return varName;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -165,7 +165,7 @@ private static void simplifyStringConstructor(RootNode root, ConstructorInsn ins
 						}
 					}
 					if (printable >= arr.length - printable) {
-						InsnWrapArg wa = new InsnWrapArg(new ConstStringNode(new String(arr)));
+						InsnArg wa = InsnArg.wrapArg(new ConstStringNode(new String(arr)));
 						if (insn.getArgsCount() == 1) {
 							insn.setArg(0, wa);
 						} else {
@@ -176,7 +176,7 @@ private static void simplifyStringConstructor(RootNode root, ConstructorInsn ins
 									ArgType.array(ArgType.BYTE));
 							InvokeNode in = new InvokeNode(mi, InvokeType.VIRTUAL, 1);
 							in.addArg(wa);
-							insn.setArg(0, new InsnWrapArg(in));
+							insn.setArg(0, InsnArg.wrapArg(in));
 						}
 					}
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java
Patch:
@@ -37,7 +37,7 @@ public class BlockSplitter extends AbstractVisitor {
 			InsnType.MONITOR_EXIT,
 			InsnType.THROW);
 
-	public static boolean makeSeparate(InsnType insnType) {
+	public static boolean isSeparate(InsnType insnType) {
 		return SEPARATE_INSNS.contains(insnType);
 	}
 
@@ -89,7 +89,7 @@ private static void splitBasicBlocks(MethodNode mth) {
 				InsnType type = prevInsn.getType();
 				if (type == InsnType.GOTO
 						|| type == InsnType.THROW
-						|| makeSeparate(type)) {
+						|| isSeparate(type)) {
 
 					if (type == InsnType.RETURN || type == InsnType.THROW) {
 						mth.addExitBlock(curBlock);
@@ -102,7 +102,7 @@ private static void splitBasicBlocks(MethodNode mth) {
 					startNew = true;
 				} else {
 					startNew = isSplitByJump(prevInsn, insn)
-							|| makeSeparate(insn.getType())
+							|| isSeparate(insn.getType())
 							|| isDoWhile(blocksMap, curBlock, insn)
 							|| insn.contains(AType.EXC_HANDLER)
 							|| prevInsn.contains(AFlag.TRY_LEAVE)

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java
Patch:
@@ -77,7 +77,7 @@ private void checkCodeVars(MethodNode mth, List<CodeVar> codeVars) {
 						.forEach(ssaVar -> {
 							ArgType ssaType = ssaVar.getAssign().getInitType();
 							if (ssaType.isTypeKnown()) {
-								TypeCompare comparator = mth.root().getTypeUpdate().getComparator();
+								TypeCompare comparator = mth.root().getTypeUpdate().getTypeCompare();
 								TypeCompareEnum result = comparator.compareTypes(ssaType, codeVarType);
 								if (result == TypeCompareEnum.CONFLICT || result.isNarrow()) {
 									mth.addWarn("Incorrect type for immutable var: ssa=" + ssaType

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables2.java
Patch:
@@ -11,7 +11,7 @@
 public class TestVariables2 extends IntegrationTest {
 
 	public static class TestCls {
-		Object test(Object s) {
+		public Object test(Object s) {
 			Object store = s != null ? s : null;
 			if (store == null) {
 				store = new Object();

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -602,7 +602,7 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)
 			code.add("new ");
 			useClass(code, insn.getClassType());
 			ArgType argType = insn.getResult().getSVar().getCodeVar().getType();
-			if (argType.isGeneric()) {
+			if (argType != null && argType.isGeneric()) {
 				code.add('<');
 				if (insn.contains(AFlag.EXPLICIT_GENERICS)) {
 					boolean first = true;

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -165,11 +165,12 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {
 				code.add("final ");
 			}
 			ArgType argType;
-			if (var.getType() == ArgType.UNKNOWN) {
+			ArgType varType = var.getType();
+			if (varType == null || varType == ArgType.UNKNOWN) {
 				// occur on decompilation errors
 				argType = mthArg.getInitType();
 			} else {
-				argType = var.getType();
+				argType = varType;
 			}
 			if (!it.hasNext() && mth.getAccessFlags().isVarArgs()) {
 				// change last array argument to varargs

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -330,7 +330,7 @@ protected final <T extends InsnNode> T copyCommonParams(T copy) {
 					InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();
 					copy.addArg(InsnArg.wrapArg(wrapInsn.copy()));
 				} else {
-					copy.addArg(arg);
+					copy.addArg(arg.duplicate());
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -43,6 +43,7 @@
 import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.InsnRemover;
 import jadx.core.utils.RegionUtils;
+import jadx.core.utils.exceptions.JadxOverflowException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
 import static jadx.core.dex.visitors.regions.IfMakerHelper.confirmMerge;
@@ -86,7 +87,7 @@ public Region makeRegion(BlockNode startBlock, RegionStack stack) {
 			next = traverse(r, next, stack);
 			regionsCount++;
 			if (regionsCount > regionsLimit) {
-				throw new JadxRuntimeException("Regions count limit reached");
+				throw new JadxOverflowException("Regions count limit reached");
 			}
 		}
 		return r;

File: jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java
Patch:
@@ -43,9 +43,12 @@ public void visit(MethodNode mth) {
 			return;
 		}
 		try {
+			mth.clearExceptionHandlers();
+
 			for (ExceptionHandler excHandler : mth.getExceptionHandlers()) {
 				processExceptionHandler(mth, excHandler);
 			}
+			mth.clearExceptionHandlers();
 		} catch (Exception e) {
 			LOG.warn("Undo finally extract visitor, mth: {}", mth, e);
 			try {

File: jadx-core/src/main/java/jadx/api/ResourceType.java
Patch:
@@ -5,8 +5,9 @@ public enum ResourceType {
 	MANIFEST("AndroidManifest.xml"),
 	XML(".xml"),
 	ARSC(".arsc"),
-	FONT(".ttf"),
+	FONT(".ttf", ".otf"),
 	IMG(".png", ".gif", ".jpg"),
+	MEDIA(".mp3", ".wav"),
 	LIB(".so"),
 	UNKNOWN;
 
@@ -23,7 +24,7 @@ public String[] getExts() {
 	public static ResourceType getFileType(String fileName) {
 		for (ResourceType type : ResourceType.values()) {
 			for (String ext : type.getExts()) {
-				if (fileName.endsWith(ext)) {
+				if (fileName.toLowerCase().endsWith(ext)) {
 					return type;
 				}
 			}

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -15,7 +15,7 @@ public class ConstructorInsn extends InsnNode implements CallMthInterface {
 	private final CallType callType;
 	private final RegisterArg instanceArg;
 
-	private enum CallType {
+	public enum CallType {
 		CONSTRUCTOR, // just new instance
 		SUPER, // super call
 		THIS, // call constructor from other constructor

File: jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java
Patch:
@@ -37,6 +37,6 @@ public void test() {
 		ClassNode cls = getClassNodeFromSmaliFiles("B");
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("// checkNull(str);"));
+		assertThat(code, containsOne("checkNull(str);"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeThis.java
Patch:
@@ -35,6 +35,6 @@ public void test() {
 		ClassNode cls = getClassNodeFromSmali();
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("// checkNull(str);"));
+		assertThat(code, containsOne("checkNull(str);"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -119,7 +119,8 @@ private static void printInsns(MethodNode mth, String indent, IBlock block) {
 				CodeWriter code = new CodeWriter();
 				ig.makeInsn(insn, code);
 				String insnStr = code.toString().substring(CodeWriter.NL.length());
-				LOG.debug("{}|> {}\t{}", indent, insnStr, insn.getAttributesString());
+				String attrStr = insn.isAttrStorageEmpty() ? "" : '\t' + insn.getAttributesString();
+				LOG.debug("{}|> {}{}", indent, insnStr, attrStr);
 			} catch (CodegenException e) {
 				LOG.debug("{}|>!! {}", indent, insn);
 			}

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -164,10 +164,8 @@ private void addEntry(List<ResourceFile> list, File zipFile, ZipEntry entry) {
 	}
 
 	public static CodeWriter loadToCodeWriter(InputStream is) throws IOException {
-		CodeWriter cw = new CodeWriter();
 		ByteArrayOutputStream baos = new ByteArrayOutputStream(READ_BUFFER_SIZE);
 		copyStream(is, baos);
-		cw.add(baos.toString("UTF-8"));
-		return cw;
+		return new CodeWriter(baos.toString("UTF-8"));
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -32,7 +32,7 @@
 import jadx.gui.jobs.BackgroundWorker;
 import jadx.gui.jobs.DecompileJob;
 import jadx.gui.treemodel.JNode;
-import jadx.gui.ui.codearea.CodeArea;
+import jadx.gui.ui.codearea.AbstractCodeArea;
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.NLS;
@@ -403,7 +403,7 @@ protected class ResultsTableCellRenderer implements TableCellRenderer {
 		private final Map<Integer, Component> componentCache = new HashMap<>();
 
 		public ResultsTableCellRenderer() {
-			RSyntaxTextArea area = CodeArea.getDefaultArea(mainWindow);
+			RSyntaxTextArea area = AbstractCodeArea.getDefaultArea(mainWindow);
 			this.font = area.getFont();
 			this.codeSelectedColor = area.getSelectionColor();
 			this.codeBackground = area.getBackground();
@@ -455,7 +455,7 @@ private Component makeCell(JNode node, int column) {
 			if (!node.hasDescString()) {
 				return emptyLabel;
 			}
-			RSyntaxTextArea textArea = CodeArea.getDefaultArea(mainWindow);
+			RSyntaxTextArea textArea = AbstractCodeArea.getDefaultArea(mainWindow);
 			textArea.setLayout(new GridLayout(1, 1));
 			textArea.setEditable(false);
 			textArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);

File: jadx-gui/src/main/java/jadx/gui/ui/ImagePanel.java
Patch:
@@ -16,7 +16,7 @@
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.xmlgen.ResContainer;
 import jadx.gui.treemodel.JResource;
-import jadx.gui.ui.codearea.CodeArea;
+import jadx.gui.ui.codearea.AbstractCodeArea;
 
 public class ImagePanel extends ContentPanel {
 	private static final long serialVersionUID = 4071356367073142688L;
@@ -29,7 +29,7 @@ public class ImagePanel extends ContentPanel {
 			ImageViewer imageViewer = new ImageViewer(img);
 			add(imageViewer.getComponent());
 		} catch (Exception e) {
-			RSyntaxTextArea textArea = CodeArea.getDefaultArea(panel.getMainWindow());
+			RSyntaxTextArea textArea = AbstractCodeArea.getDefaultArea(panel.getMainWindow());
 			textArea.setText("Image load error: \n" + Utils.getStackTrace(e));
 			add(textArea);
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java
Patch:
@@ -9,7 +9,7 @@
 import ch.qos.logback.classic.Level;
 
 import jadx.gui.settings.JadxSettings;
-import jadx.gui.ui.codearea.CodeArea;
+import jadx.gui.ui.codearea.AbstractCodeArea;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.logs.ILogListener;
 import jadx.gui.utils.logs.LogCollector;
@@ -31,7 +31,7 @@ public LogViewer(MainWindow mainWindow) {
 	}
 
 	public final void initUI(MainWindow mainWindow) {
-		textPane = CodeArea.getDefaultArea(mainWindow);
+		textPane = AbstractCodeArea.getDefaultArea(mainWindow);
 		textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));
 
 		JPanel controlPane = new JPanel();

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeContentPanel.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.gui.ui.codearea;
 
-import java.awt.BorderLayout;
+import java.awt.*;
 
 import jadx.gui.treemodel.JNode;
 import jadx.gui.ui.TabbedPane;
@@ -13,7 +13,7 @@ public final class CodeContentPanel extends AbstractCodeContentPanel {
 	public CodeContentPanel(TabbedPane panel, JNode jnode) {
 		super(panel, jnode);
 		setLayout(new BorderLayout());
-		codePanel = new CodePanel(this, new CodeArea(this));
+		codePanel = new CodePanel(new CodeArea(this));
 		add(codePanel, BorderLayout.CENTER);
 		codePanel.load();
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java
Patch:
@@ -49,7 +49,7 @@ public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
 		if (pos != null) {
 			Token token = codeArea.viewToToken(pos);
 			if (token != null) {
-				node = codeArea.getJavaNodeAtOffset(jCls, token.getOffset());
+				node = codeArea.getJavaNodeAtOffset(token.getOffset());
 			}
 		}
 		setEnabled(node != null);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java
Patch:
@@ -99,6 +99,7 @@ private static boolean makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {
 			RegisterArg resArg;
 			if (thenPhi.getArgsCount() == 2) {
 				resArg = thenPhi.getResult();
+				InsnRemover.unbindResult(mth, thenInsn);
 			} else {
 				resArg = thenResArg;
 				thenPhi.removeArg(elseResArg);
@@ -107,6 +108,8 @@ private static boolean makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {
 					resArg, InsnArg.wrapArg(thenInsn), InsnArg.wrapArg(elseInsn));
 			ternInsn.setSourceLine(thenInsn.getSourceLine());
 
+			InsnRemover.unbindResult(mth, elseInsn);
+
 			// remove 'if' instruction
 			header.getInstructions().clear();
 			header.getInstructions().add(ternInsn);

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java
Patch:
@@ -17,7 +17,7 @@ public static boolean test(Object a, Object b) {
 			if (r) {
 				return false;
 			}
-			System.out.println("1");
+			System.out.println("r=" + r);
 			return true;
 		}
 	}
@@ -29,6 +29,6 @@ public void test() {
 
 		assertThat(code, containsOne("boolean r = a == null ? b != null : !a.equals(b);"));
 		assertThat(code, containsOne("if (r) {"));
-		assertThat(code, containsOne("System.out.println(\"1\");"));
+		assertThat(code, containsOne("System.out.println(\"r=\" + r);"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java
Patch:
@@ -11,7 +11,6 @@ protected String[] parseStringPool() throws IOException {
 		return parseStringPoolNoType();
 	}
 
-	@SuppressWarnings("unused")
 	protected String[] parseStringPoolNoType() throws IOException {
 		long start = is.getPos() - 2;
 		is.checkInt16(0x001c, "String pool header size not 0x001c");
@@ -56,6 +55,9 @@ protected String[] parseStringPoolNoType() throws IOException {
 	}
 
 	private static String extractString8(byte[] strArray, int offset) {
+		if (offset >= strArray.length) {
+			return "STRING_DECODE_ERROR";
+		}
 		int start = offset + skipStrLen8(strArray, offset);
 		int len = strArray[start++];
 		if (len == 0) {

File: jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java
Patch:
@@ -22,7 +22,7 @@ public static void addRenamedComment(CodeWriter code, AttrNode node, String orig
 		code.startLine("/* renamed from: ").add(origName);
 		RenameReasonAttr renameReasonAttr = node.get(AType.RENAME_REASON);
 		if (renameReasonAttr != null) {
-			code.add(" reason: ");
+			code.add("  reason: ");
 			code.add(renameReasonAttr.getDescription());
 		}
 		code.add(" */");

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinallyExtract.java
Patch:
@@ -36,7 +36,7 @@ private String call() {
 
 		public void check() {
 			test();
-			assertEquals(result, 1);
+			assertEquals(1, result);
 		}
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally9.java
Patch:
@@ -6,7 +6,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
@@ -33,14 +32,14 @@ public String test() throws IOException {
 	}
 
 	@Test
-	@NotYetImplemented("finally extraction")
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
 		assertThat(code, not(containsString("JADX INFO: finally extract failed")));
-		assertThat(code, not(containsString("throw")));
+		assertThat(code, not(containsString(indent() + "throw ")));
 		assertThat(code, containsOne("} finally {"));
 		assertThat(code, containsOne("if (input != null) {"));
+		assertThat(code, containsOne("input.close();"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -165,6 +165,7 @@ public static InsnNode getLastInsn(@Nullable IBlock block) {
 		return insns.get(insns.size() - 1);
 	}
 
+	@Nullable
 	public static BlockNode getBlockByInsn(MethodNode mth, InsnNode insn) {
 		if (insn instanceof PhiInsn) {
 			return searchBlockWithPhi(mth, (PhiInsn) insn);

File: jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.integration;
+package jadx.tests.integration.others;
 
 import org.junit.jupiter.api.Test;
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination2.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.integration;
+package jadx.tests.integration.others;
 
 import org.junit.jupiter.api.Test;
 

File: jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java
Patch:
@@ -2,12 +2,12 @@
 
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 class ArgTypeTest {
 
 	@Test
-	void testEqualsOfGenericTypes() {
+	public void testEqualsOfGenericTypes() {
 		ArgType first = ArgType.generic("java.lang.List", ArgType.STRING);
 		ArgType second = ArgType.generic("Ljava/lang/List;", ArgType.STRING);
 

File: jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java
Patch:
@@ -49,7 +49,7 @@ public static void main(String[] args) throws IOException, DecodeException {
 		root.load(inputFiles);
 
 		ClsSet set = new ClsSet();
-		set.load(root);
+		set.loadFrom(root);
 		set.save(output);
 		LOG.info("Output: {}", output);
 		LOG.info("done");

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -99,7 +99,7 @@ public boolean addDefinition(CodeWriter code) {
 			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");
 		}
 
-		if (classGen.addGenericMap(code, mth.getGenericMap(), false)) {
+		if (classGen.addGenericMap(code, mth.getGenerics(), false)) {
 			code.add(' ');
 		}
 		if (ai.isConstructor()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java
Patch:
@@ -259,11 +259,11 @@ public void processBlock(MethodNode mth, IBlock container) {
 
 		private void addMethodMsg(MethodNode mth) {
 			if (commentedCount > 0) {
-				String msg = "JADX WARN: Illegal instructions before constructor call commented (this can break semantics)";
+				String msg = "Illegal instructions before constructor call commented (this can break semantics)";
 				if (brokenCode || regionDepth > 1) {
 					mth.addWarn(msg);
 				} else {
-					mth.addComment(msg);
+					mth.addComment("JADX WARN: " + msg);
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -327,7 +327,7 @@ private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, Regi
 			LOG.warn("Generic type differs: '{}' and '{}' in {}", gType, varType, mth);
 			return false;
 		}
-		if (!iterableArg.isRegister()) {
+		if (!iterableArg.isRegister() || !iterableType.isObject()) {
 			return true;
 		}
 		// TODO: add checks

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -353,7 +353,7 @@ public Object invoke(ClassNode cls, String methodName, Class<?>[] types, Object.
 		return dynamicCompiler.invoke(cls, methodName, types, args);
 	}
 
-	public File getJarForClass(Class<?> cls) throws IOException {
+	private File getJarForClass(Class<?> cls) throws IOException {
 		List<File> files = compileClass(cls);
 		assertThat("File list is empty", files, not(empty()));
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops2.java
Patch:
@@ -32,6 +32,6 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("for (int i = 0; i < list.size(); i++) {"));
-		assertThat(code, containsOne("while (j < ((String) list.get(i)).length()) {"));
+		assertThat(code, containsOne("while (j < list.get(i).length()) {"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java
Patch:
@@ -33,6 +33,7 @@ public void checkNull(Object o) {
 
 	@Test
 	public void test() {
+		allowWarnInCode();
 		ClassNode cls = getClassNodeFromSmaliFiles("B");
 		String code = cls.getCode().toString();
 

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -227,6 +227,9 @@ protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws Codeg
 					if (attachInsns) {
 						code.attachLineAnnotation(insn);
 					}
+					if (insn.contains(AFlag.COMMENT_OUT)) {
+						code.add("// ");
+					}
 				}
 				if (insn.getResult() != null) {
 					SSAVar var = insn.getResult().getSVar();

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -15,9 +15,11 @@ public enum AFlag {
 	DONT_WRAP,
 	DONT_INLINE,
 	DONT_GENERATE, // process as usual, but don't output to generated code
+	COMMENT_OUT, // process as usual, but comment insn in generated code
+	REMOVE, // can be completely removed
+
 	RESTART_CODEGEN,
 	DONT_RENAME, // do not rename during deobfuscation
-	REMOVE, // can be completely removed
 	ADDED_TO_REGION,
 
 	FINALLY_INSNS,

File: jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java
Patch:
@@ -50,6 +50,6 @@ private void commonChecks() {
 		assertThat(code, containsOne("this.f0fieldName"));
 
 		assertThat(code, containsOne("public Object run() {"));
-		assertThat(code, containsOne("public String m1run() {"));
+		assertThat(code, containsOne("public String m0run() {"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -954,6 +954,9 @@ public IRegion processTryCatchBlocks(MethodNode mth) {
 			Set<BlockNode> exits = new HashSet<>();
 			for (BlockNode splitter : splitters) {
 				for (BlockNode handler : blocks) {
+					if (handler.contains(AFlag.REMOVE)) {
+						continue;
+					}
 					List<BlockNode> s = splitter.getSuccessors();
 					if (s.isEmpty()) {
 						LOG.debug(ErrorsCounter.formatMsg(mth, "No successors for splitter: " + splitter));

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -432,6 +432,9 @@ public static BlockNode getPathCross(MethodNode mth, BlockNode b1, BlockNode b2)
 		if (b1 == null || b2 == null) {
 			return null;
 		}
+		if (b1.getDomFrontier() == null || b2.getDomFrontier() == null) {
+			return null;
+		}
 		BitSet b = new BitSet();
 		b.or(b1.getDomFrontier());
 		b.and(b2.getDomFrontier());

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -234,14 +234,15 @@ public void addFallbackMethodCode(CodeWriter code) {
 			code.startLine("// Can't load method instructions.");
 			return;
 		}
+		code.incIndent();
 		if (mth.getThisArg() != null) {
 			code.startLine(nameGen.useArg(mth.getThisArg())).add(" = this;");
 		}
 		addFallbackInsns(code, mth, insnArr, true);
+		code.decIndent();
 	}
 
 	public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, boolean addLabels) {
-		code.incIndent();
 		InsnGen insnGen = new InsnGen(getFallbackMethodGen(mth), true);
 		InsnNode prevInsn = null;
 		for (InsnNode insn : insnArr) {
@@ -276,7 +277,6 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]
 			}
 			prevInsn = insn;
 		}
-		code.decIndent();
 	}
 
 	private static boolean needLabel(InsnNode insn, InsnNode prevInsn) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -678,8 +678,9 @@ private BlockNode processIf(IRegion currentRegion, BlockNode block, IfNode ifnod
 		}
 		confirmMerge(currentIf);
 
-		IfRegion ifRegion = new IfRegion(currentRegion, block);
+		IfRegion ifRegion = new IfRegion(currentRegion);
 		ifRegion.setCondition(currentIf.getCondition());
+		ifRegion.setConditionBlocks(currentIf.getMergedBlocks());
 		currentRegion.getSubBlocks().add(ifRegion);
 
 		BlockNode outBlock = currentIf.getOutBlock();

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions4.java
Patch:
@@ -24,7 +24,7 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsString("num >= 59 && num <= 66"));
-		assertThat(code, containsString("return inRange ? num + 1 : num;"));
+		assertThat(code, containsString("? num + 1 : num;"));
 		assertThat(code, not(containsString("else")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java
Patch:
@@ -42,6 +42,6 @@ public void test() {
 		assertThat(code, containsOne("int c3 = b;"));
 		assertThat(code, containsOne("int b2 = b + 1;"));
 		assertThat(code, containsOne("b = c3"));
-		assertThat(code, containsOne("a++;"));
+		assertThat(code, containsOne("a++"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -12,7 +12,6 @@
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.InsnNode;
-import jadx.core.utils.InsnRemover;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
@@ -76,7 +75,7 @@ public boolean removeArg(InsnArg arg) {
 	protected RegisterArg removeArg(int index) {
 		RegisterArg reg = (RegisterArg) super.removeArg(index);
 		blockBinds.remove(index);
-		InsnRemover.fixUsedInPhiFlag(reg);
+		reg.getSVar().updateUsedInPhiList();
 		return reg;
 	}
 
@@ -98,7 +97,7 @@ public boolean replaceArg(InsnArg from, InsnArg to) {
 
 		RegisterArg reg = (RegisterArg) to;
 		bindArg(reg, pred);
-		reg.getSVar().setUsedInPhi(this);
+		reg.getSVar().addUsedInPhi(this);
 		return true;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -203,8 +203,7 @@ private static void fixLinesForReturn(MethodNode mth) {
 
 	private static void fixNamesForPhiInsns(MethodNode mth) {
 		mth.getSVars().forEach(ssaVar -> {
-			PhiInsn phiInsn = ssaVar.getUsedInPhi();
-			if (phiInsn != null) {
+			for (PhiInsn phiInsn : ssaVar.getUsedInPhi()) {
 				Set<String> names = new HashSet<>(1 + phiInsn.getArgsCount());
 				addArgName(phiInsn.getResult(), names);
 				phiInsn.getArguments().forEach(arg -> addArgName(arg, names));

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -193,8 +193,7 @@ private static void checkPHI(MethodNode mth) {
 			}
 		}
 		for (SSAVar ssaVar : mth.getSVars()) {
-			PhiInsn usedInPhi = ssaVar.getUsedInPhi();
-			if (usedInPhi != null) {
+			for (PhiInsn usedInPhi : ssaVar.getUsedInPhi()) {
 				boolean found = false;
 				for (RegisterArg useArg : ssaVar.getUseList()) {
 					InsnNode parentInsn = useArg.getParentInsn();

File: jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java
Patch:
@@ -64,6 +64,9 @@ public void initBlocks(BlockNode curBlock) {
 
 	@Override
 	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {
+		if (targetBlocks == null) {
+			return false;
+		}
 		int count = 0;
 		int len = targetBlocks.length;
 		for (int i = 0; i < len; i++) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.IBranchRegion;
@@ -167,6 +168,7 @@ private static boolean isHandlerPath(TryCatchBlock tb, IContainer cont) {
 		for (ExceptionHandler h : tb.getHandlers()) {
 			BlockNode handlerBlock = h.getHandlerBlock();
 			if (handlerBlock != null
+					&& !handlerBlock.contains(AFlag.REMOVE)
 					&& RegionUtils.hasPathThroughBlock(handlerBlock, cont)) {
 				return true;
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -1022,6 +1022,9 @@ private void processExcHandler(MethodNode mth, ExceptionHandler handler, Set<Blo
 			dom = start;
 			stack.addExits(exits);
 		}
+		if (dom.contains(AFlag.REMOVE)) {
+			return;
+		}
 		BitSet domFrontier = dom.getDomFrontier();
 		List<BlockNode> handlerExits = BlockUtils.bitSetToBlocks(this.mth, domFrontier);
 		boolean inLoop = this.mth.getLoopForBlock(start) != null;

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -270,6 +270,9 @@ public static BitSet blocksToBitSet(MethodNode mth, List<BlockNode> blocks) {
 	}
 
 	public static List<BlockNode> bitSetToBlocks(MethodNode mth, BitSet bs) {
+		if (bs == null) {
+			return Collections.emptyList();
+		}
 		int size = bs.cardinality();
 		if (size == 0) {
 			return Collections.emptyList();

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -50,7 +50,6 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.RootNode;
-import jadx.core.utils.DebugUtils;
 import jadx.core.utils.RegionUtils;
 import jadx.core.utils.exceptions.CodegenException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
@@ -560,7 +559,6 @@ private void oneArgInsn(CodeWriter code, InsnNode insn, Set<Flags> state, char o
 
 	private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {
 		if (!fallback) {
-			DebugUtils.dump(mth, "fallback");
 			throw new CodegenException(insn.getType() + " can be used only in fallback mode");
 		}
 	}

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -206,6 +206,9 @@ public void addInstructions(CodeWriter code) throws CodegenException {
 				classGen.insertDecompilationProblems(code, mth);
 				addInstructions(code);
 			} catch (Exception e) {
+				if (mth.getParentClass().getTopParentClass().contains(AFlag.RESTART_CODEGEN)) {
+					throw e;
+				}
 				mth.addError("Method code generation error", e);
 				classGen.insertDecompilationProblems(code, mth);
 				addInstructions(code);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -15,6 +15,7 @@ public enum AFlag {
 	DONT_WRAP,
 	DONT_INLINE,
 	DONT_GENERATE, // process as usual, but don't output to generated code
+	RESTART_CODEGEN,
 	DONT_RENAME, // do not rename during deobfuscation
 	REMOVE, // can be completely removed
 	ADDED_TO_REGION,

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -183,6 +183,9 @@ private static List<Path> loadFromJar(Path jar) throws DecodeException {
 			if (pathList.isEmpty()) {
 				throw new JadxException("Empty dx output");
 			}
+			if (LOG.isDebugEnabled()) {
+				LOG.debug("result dex files: {}", pathList);
+			}
 			return pathList;
 		} catch (Exception e) {
 			throw new DecodeException("java class to dex conversion error:\n " + e.getMessage(), e);

File: jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java
Patch:
@@ -41,7 +41,7 @@ public List<Path> convert(Path jar) throws JadxException {
 		try (ByteArrayOutputStream out = new ByteArrayOutputStream();
 				ByteArrayOutputStream errOut = new ByteArrayOutputStream()) {
 			DxContext context = new DxContext(out, errOut);
-			Path dir = FileUtils.createTempDir(jar.getFileName().toString());
+			Path dir = FileUtils.createTempDir("jar-to-dex-");
 			DxArgs args = new DxArgs(
 					context,
 					dir.toAbsolutePath().toString(),
@@ -58,7 +58,6 @@ public List<Path> convert(Path jar) throws JadxException {
 					child.toFile().deleteOnExit();
 				}
 			}
-			dir.toFile().deleteOnExit();
 			return list;
 		} catch (Exception e) {
 			throw new JadxException("dx exception: " + e.getMessage(), e);

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -329,10 +329,10 @@ private void addMethod(CodeWriter code, MethodNode mth) throws CodegenException
 		}
 	}
 
-	private void insertDecompilationProblems(CodeWriter code, AttrNode node) {
+	public void insertDecompilationProblems(CodeWriter code, AttrNode node) {
 		List<JadxError> errors = node.getAll(AType.JADX_ERROR);
 		if (!errors.isEmpty()) {
-			errors.stream().sorted().forEach(err -> {
+			errors.stream().distinct().sorted().forEach(err -> {
 				code.startLine("/*  JADX ERROR: ").add(err.getError());
 				Throwable cause = err.getCause();
 				if (cause != null) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -143,7 +143,7 @@ private static int getInsnOffsetByArg(InsnArg arg) {
 	public static void applyDebugInfo(MethodNode mth, SSAVar ssaVar, ArgType type, String varName) {
 		TypeUpdateResult result = mth.root().getTypeUpdate().applyWithWiderAllow(ssaVar, type);
 		if (result == TypeUpdateResult.REJECT) {
-			if (LOG.isDebugEnabled()) {
+			if (Consts.DEBUG) {
 				LOG.debug("Reject debug info of type: {} and name: '{}' for {}, mth: {}", type, varName, ssaVar, mth);
 			}
 		} else {

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java
Patch:
@@ -232,7 +232,9 @@ private void fillTypeCandidates(SSAVar ssaVar) {
 		int size = candidateTypes.size();
 		if (size == 0) {
 			throw new JadxRuntimeException("No candidate types for var: " + ssaVar.getDetailedVarInfo(mth)
-					+ "\n  assigns: " + assigns + "\n  uses: " + uses);
+					+ "\n  assigns: " + assigns
+					+ "\n  uses: " + uses
+					+ "\n  mth insns count: " + mth.countInsns());
 		}
 		if (size == 1) {
 			varInfo.setTypeResolved(true);

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -162,9 +162,6 @@ private static void checkPHI(MethodNode mth) {
 				if (insn.getType() == InsnType.PHI) {
 					PhiInsn phi = (PhiInsn) insn;
 					phis.add(phi);
-					if (phi.getArgsCount() != phi.getBlockBinds().size()) {
-						throw new JadxRuntimeException("Incorrect args and binds in PHI");
-					}
 					if (phi.getArgsCount() == 0) {
 						throw new JadxRuntimeException("No args and binds in PHI");
 					}

File: jadx-core/src/main/java/jadx/api/JavaField.java
Patch:
@@ -39,7 +39,7 @@ public AccessInfo getAccessFlags() {
 	}
 
 	public ArgType getType() {
-		return field.getType();
+		return ArgType.tryToResolveClassAlias(field.dex(), field.getType());
 	}
 
 	public int getDecompiledLine() {

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -91,9 +91,8 @@ public void unload() {
 		if (noCode) {
 			return;
 		}
-		retType = null;
+		// don't unload retType and argsList, will be used in jadx-gui after class unload
 		thisArg = null;
-		argsList = Collections.emptyList();
 		sVars = Collections.emptyList();
 		genericMap = null;
 		instructions = null;

File: jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java
Patch:
@@ -32,7 +32,7 @@ public void init(RootNode root) {
 			return;
 		}
 		InputFile firstInputFile = dexNodes.get(0).getDexFile().getInputFile();
-		Path inputFilePath = firstInputFile.getFile().toPath();
+		Path inputFilePath = firstInputFile.getFile().getAbsoluteFile().toPath();
 
 		String inputName = inputFilePath.getFileName().toString();
 		String baseName = inputName.substring(0, inputName.lastIndexOf('.'));

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java
Patch:
@@ -89,6 +89,9 @@ private boolean applyResolvedVars() {
 				applySuccess = false;
 			}
 		}
+		if (!applySuccess) {
+			LOG.warn("Multi-variable search result apply rejected in {}", mth);
+		}
 		return applySuccess;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java
Patch:
@@ -157,7 +157,7 @@ private TypeUpdateResult requestUpdate(TypeUpdateInfo updateInfo, InsnArg arg, A
 				updateInfo.rollbackUpdate(arg);
 			}
 			return result;
-		} catch (StackOverflowError overflow) {
+		} catch (StackOverflowError | BootstrapMethodError error) {
 			throw new JadxOverflowException("Type update terminated with stack overflow, arg: " + arg);
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java
Patch:
@@ -117,8 +117,8 @@ public void codeJump(JumpPosition pos) {
 	@Nullable
 	private JumpPosition getCurrentPosition() {
 		ContentPanel selectedCodePanel = getSelectedCodePanel();
-		if (selectedCodePanel instanceof CodeContentPanel) {
-			return ((CodeContentPanel) selectedCodePanel).getCodeArea().getCurrentPosition();
+		if (selectedCodePanel instanceof AbstractCodeContentPanel) {
+			return ((AbstractCodeContentPanel) selectedCodePanel).getCodeArea().getCurrentPosition();
 		}
 		return null;
 	}

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java
Patch:
@@ -35,11 +35,11 @@ public RenameReasonAttr(AttrNode node, boolean notValid, boolean notPrintable) {
 		}
 	}
 
-	private RenameReasonAttr notValid() {
+	public RenameReasonAttr notValid() {
 		return append("not valid java name");
 	}
 
-	private RenameReasonAttr notPrintable() {
+	public RenameReasonAttr notPrintable() {
 		return append("contains not printable characters");
 	}
 

File: jadx-cli/src/test/java/jadx/cli/RenameConverterTest.java
Patch:
@@ -42,8 +42,8 @@ public void wrong() {
 				() -> converter.convert("wrong"),
 				"Expected convert() to throw, but it didn't");
 
-		assertEquals("wrong is unknown for parameter someParam, "
-				+ "possible values are 'case', 'valid' and 'printable'",
+		assertEquals("'wrong' is unknown for parameter someParam, "
+				+ "possible values are 'case', 'valid', 'printable'",
 				thrown.getMessage());
 	}
 }

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -98,7 +98,7 @@ private static ResContainer loadContent(JadxDecompiler jadxRef, ResourceFile rf,
 				return ResContainer.textResource(rf.getName(), content);
 
 			case ARSC:
-				return new ResTableParser().decodeFiles(inputStream);
+				return new ResTableParser(jadxRef.getRoot()).decodeFiles(inputStream);
 
 			case IMG:
 				return decodeImage(rf, inputStream);

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -25,6 +25,7 @@
 import jadx.core.dex.trycatch.CatchAttr;
 import jadx.core.dex.visitors.DepthTraversal;
 import jadx.core.dex.visitors.FallbackModeVisitor;
+import jadx.core.utils.CodeGenUtils;
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.CodegenException;
@@ -84,7 +85,7 @@ public boolean addDefinition(CodeWriter code) {
 		}
 
 		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {
-			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");
+			CodeGenUtils.addRenamedComment(code, mth, mth.getName());
 		}
 		code.startLineWithNum(mth.getSourceLine());
 		code.add(ai.makeString());

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -129,7 +129,7 @@ private String makeArgName(CodeVar var) {
 		if (NameMapper.isReserved(varName)) {
 			varName = varName + 'R';
 		}
-		if (!NameMapper.isValidIdentifier(varName)) {
+		if (!NameMapper.isValidAndPrintable(varName)) {
 			varName = getFallbackName(var);
 		}
 		return varName;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -17,6 +17,7 @@
 import jadx.core.dex.attributes.nodes.MethodInlineAttr;
 import jadx.core.dex.attributes.nodes.PhiListAttr;
 import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;
+import jadx.core.dex.attributes.nodes.RenameReasonAttr;
 import jadx.core.dex.attributes.nodes.SourceFileAttr;
 import jadx.core.dex.nodes.parser.FieldInitAttr;
 import jadx.core.dex.trycatch.CatchAttr;
@@ -55,6 +56,7 @@ public class AType<T extends IAttribute> {
 	public static final AType<DeclareVariablesAttr> DECLARE_VARIABLES = new AType<>();
 	public static final AType<LoopLabelAttr> LOOP_LABEL = new AType<>();
 	public static final AType<IgnoreEdgeAttr> IGNORE_EDGE = new AType<>();
+	public static final AType<RenameReasonAttr> RENAME_REASON = new AType<>();
 
 	// method
 	public static final AType<LocalVarsDebugInfoAttr> LOCAL_VARS_DEBUG_INFO = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -87,7 +87,7 @@ public void loadResources(List<ResourceFile> resources) {
 		}
 		try {
 			ResourceStorage resStorage = ResourcesLoader.decodeStream(arsc, (size, is) -> {
-				ResTableParser parser = new ResTableParser();
+				ResTableParser parser = new ResTableParser(this);
 				parser.decode(is);
 				return parser.getResStorage();
 			});

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -152,8 +152,8 @@ public boolean visit(ClassNode cls) throws JadxException {
 			String name = getConstString(cls.dex(), co.getArg(0));
 			if (name != null
 					&& !fieldInfo.getAlias().equals(name)
-					&& NameMapper.isValidIdentifier(name)) {
-				// LOG.debug("Rename enum field: '{}' to '{}' in {}", fieldInfo.getName(), name, cls);
+					&& NameMapper.isValidAndPrintable(name)
+					&& cls.root().getArgs().isRenameValid()) {
 				fieldInfo.setAlias(name);
 			}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -147,7 +147,7 @@ public static void applyDebugInfo(MethodNode mth, SSAVar ssaVar, ArgType type, S
 				LOG.debug("Reject debug info of type: {} and name: '{}' for {}, mth: {}", type, varName, ssaVar, mth);
 			}
 		} else {
-			if (NameMapper.isValidIdentifier(varName)) {
+			if (NameMapper.isValidAndPrintable(varName)) {
 				ssaVar.setName(varName);
 			}
 			detachDebugInfo(ssaVar.getAssign());

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -124,7 +124,8 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora
 			FieldNode fieldNode = resFieldsMap.get(resource.getId());
 			if (fieldNode != null
 					&& !fieldNode.getName().equals(resName)
-					&& NameMapper.isValidIdentifier(resName)) {
+					&& NameMapper.isValidAndPrintable(resName)
+					&& resCls.root().getArgs().isRenameValid()) {
 				fieldNode.add(AFlag.DONT_RENAME);
 				fieldNode.getFieldInfo().setAlias(resName);
 			}

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -115,7 +115,7 @@ void decode() throws IOException {
 					break;
 				case RES_STRING_POOL_TYPE:
 					strings = parseStringPoolNoType();
-					valuesParser = new ValuesParser(strings, resNames);
+					valuesParser = new ValuesParser(rootNode, strings, resNames);
 					break;
 				case RES_XML_RESOURCE_MAP_TYPE:
 					parseResourceMap();

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java
Patch:
@@ -14,16 +14,17 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.gui.treemodel.JClass;
+import jadx.gui.ui.ContentPanel;
 import jadx.gui.utils.JumpPosition;
 
 public class CodeLinkGenerator implements LinkGenerator, HyperlinkListener {
 	private static final Logger LOG = LoggerFactory.getLogger(CodeLinkGenerator.class);
 
-	private final CodePanel contentPanel;
+	private final ContentPanel contentPanel;
 	private final CodeArea codeArea;
 	private final JClass jCls;
 
-	public CodeLinkGenerator(CodePanel contentPanel, CodeArea codeArea, JClass cls) {
+	public CodeLinkGenerator(ContentPanel contentPanel, CodeArea codeArea, JClass cls) {
 		this.contentPanel = contentPanel;
 		this.codeArea = codeArea;
 		this.jCls = cls;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java
Patch:
@@ -12,20 +12,21 @@
 import jadx.api.JavaNode;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.ContentPanel;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.ui.UsageDialog;
 import jadx.gui.utils.NLS;
 
 public final class FindUsageAction extends AbstractAction implements PopupMenuListener {
 	private static final long serialVersionUID = 4692546569977976384L;
 
-	private final transient CodePanel contentPanel;
+	private final transient ContentPanel contentPanel;
 	private final transient CodeArea codeArea;
 	private final transient JClass jCls;
 
 	private transient JavaNode node;
 
-	public FindUsageAction(CodePanel contentPanel, CodeArea codeArea, JClass jCls) {
+	public FindUsageAction(ContentPanel contentPanel, CodeArea codeArea, JClass jCls) {
 		super(NLS.str("popup.find_usage"));
 		this.contentPanel = contentPanel;
 		this.codeArea = codeArea;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java
Patch:
@@ -12,19 +12,20 @@
 import jadx.api.JavaNode;
 import jadx.gui.treemodel.JClass;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.ContentPanel;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.NLS;
 
 public final class GoToDeclarationAction extends AbstractAction implements PopupMenuListener {
 	private static final long serialVersionUID = -1186470538894941301L;
-	private final transient CodePanel contentPanel;
+	private final transient ContentPanel contentPanel;
 	private final transient CodeArea codeArea;
 	private final transient JClass jCls;
 
 	private transient JavaNode node;
 
-	public GoToDeclarationAction(CodePanel contentPanel, CodeArea codeArea, JClass jCls) {
+	public GoToDeclarationAction(ContentPanel contentPanel, CodeArea codeArea, JClass jCls) {
 		super(NLS.str("popup.go_to_declaration"));
 		this.contentPanel = contentPanel;
 		this.codeArea = codeArea;

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -653,7 +653,7 @@ private void makeInvoke(InvokeNode insn, CodeWriter code) throws CodegenExceptio
 				break;
 
 			case STATIC:
-				ClassInfo insnCls = mth.getParentClass().getAlias();
+				ClassInfo insnCls = mth.getParentClass().getClassInfo();
 				ClassInfo declClass = callMth.getDeclClass();
 				if (!insnCls.equals(declClass)) {
 					useClass(code, declClass);
@@ -673,7 +673,7 @@ private void makeInvoke(InvokeNode insn, CodeWriter code) throws CodegenExceptio
 	@Nullable
 	private ClassInfo getClassForSuperCall(CodeWriter code, MethodInfo callMth) {
 		ClassNode useCls = mth.getParentClass();
-		ClassInfo insnCls = useCls.getAlias();
+		ClassInfo insnCls = useCls.getClassInfo();
 		ClassInfo declClass = callMth.getDeclClass();
 		if (insnCls.equals(declClass)) {
 			return null;

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -187,7 +187,7 @@ public void addInstructions(CodeWriter code) throws CodegenException {
 			code.startLine("*/");
 
 			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: ")
-					.add(mth.getParentClass().getAlias().makeFullName())
+					.add(mth.getParentClass().getClassInfo().getAliasFullName())
 					.add('.')
 					.add(mth.getAlias())
 					.add('(')

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -65,7 +65,7 @@ private void addNamesUsedInClass() {
 			varNames.add(field.getAlias());
 		}
 		for (ClassNode innerClass : parentClass.getInnerClasses()) {
-			varNames.add(innerClass.getAlias().getShortName());
+			varNames.add(innerClass.getClassInfo().getAliasShortName());
 		}
 		// add all root package names to avoid collisions with full class names
 		varNames.addAll(mth.root().getCacheStorage().getRootPkgs());
@@ -259,10 +259,10 @@ private String makeNameFromInvoke(MethodInfo callMth) {
 		if (name.startsWith("get") || name.startsWith("set")) {
 			return fromName(name.substring(3));
 		}
-		ArgType declType = callMth.getDeclClass().getAlias().getType();
 		if ("iterator".equals(name)) {
 			return "it";
 		}
+		ArgType declType = callMth.getDeclClass().getType();
 		if ("toString".equals(name)) {
 			return makeNameForType(declType);
 		}

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -126,7 +126,7 @@ public static boolean isAllCharsPrintable(String str) {
 	 * <p>
 	 */
 	public static String removeInvalidCharsMiddle(String name) {
-		if (isValidIdentifier(name)) {
+		if (isValidIdentifier(name) && isAllCharsPrintable(name)) {
 			return name;
 		}
 		int len = name.length();

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -116,7 +116,7 @@ public void process(MethodNode mth) {
 					+ (useRegions ? ".regions" : "")
 					+ (rawInsn ? ".raw" : "")
 					+ ".dot";
-			dot.save(dir, mth.getParentClass().getClassInfo().getFullPath() + "_graphs", fileName);
+			dot.save(dir, mth.getParentClass().getClassInfo().getAliasFullPath() + "_graphs", fileName);
 		}
 
 		private void processMethodRegion(MethodNode mth) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java
Patch:
@@ -154,7 +154,8 @@ private static void removeParenthesis(IfCondition cond) {
 	private static void modifyArith(BlockNode block) {
 		List<InsnNode> list = block.getInstructions();
 		for (InsnNode insn : list) {
-			if (insn.getType() == InsnType.ARITH) {
+			if (insn.getType() == InsnType.ARITH
+					&& !insn.contains(AFlag.DECLARE_VAR)) { // TODO: move this modify before ProcessVariable
 				RegisterArg res = insn.getResult();
 				InsnArg arg = insn.getArg(0);
 				boolean replace = false;

File: jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java
Patch:
@@ -21,7 +21,7 @@ public static void save(File dir, JadxArgs args, ClassNode cls) {
 		if (clsCode == null) {
 			throw new JadxRuntimeException("Code not generated for class " + cls.getFullName());
 		}
-		String fileName = cls.getClassInfo().getFullPath() + ".java";
+		String fileName = cls.getClassInfo().getAliasFullPath() + ".java";
 		if (args.isFallbackMode()) {
 			fileName += ".jadx";
 		}

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -74,7 +74,7 @@ public static boolean handleAppResField(CodeWriter code, ClassGen clsGen, ClassI
 		if (parentClass != null && parentClass.getShortName().equals("R")) {
 			clsGen.useClass(code, parentClass);
 			code.add('.');
-			code.add(declClass.getAlias().getShortName());
+			code.add(declClass.getAliasShortName());
 			return true;
 		}
 		return false;

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -18,7 +18,6 @@
 import jadx.api.JavaClass;
 import jadx.api.JavaPackage;
 import jadx.api.ResourceFile;
-import jadx.core.utils.files.FileUtils;
 import jadx.gui.settings.JadxSettings;
 
 public class JadxWrapper {
@@ -37,8 +36,6 @@ public void openFile(File file) {
 		try {
 			JadxArgs jadxArgs = settings.toJadxArgs();
 			jadxArgs.setInputFile(file);
-			// output folder not known yet => use input dir as a best choice
-			jadxArgs.setFsCaseSensitive(FileUtils.isCaseSensitiveFS(file.getParentFile()));
 
 			this.decompiler = new JadxDecompiler(jadxArgs);
 			this.decompiler.load();

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -370,7 +370,7 @@ private void addFields(CodeWriter code) throws CodegenException {
 			if (fv != null) {
 				code.add(" = ");
 				if (fv.getValue() == null) {
-					code.add(TypeGen.literalToString(0, f.getType(), cls));
+					code.add(TypeGen.literalToString(0, f.getType(), cls, fallback));
 				} else {
 					if (fv.getValueType() == InitType.CONST) {
 						annotationGen.encodeValue(code, fv.getValue());

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -138,7 +138,7 @@ public void declareVar(CodeWriter code, CodeVar codeVar) {
 	}
 
 	private String lit(LiteralArg arg) {
-		return TypeGen.literalToString(arg.getLiteral(), arg.getType(), mth);
+		return TypeGen.literalToString(arg.getLiteral(), arg.getType(), mth, fallback);
 	}
 
 	private void instanceField(CodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -266,7 +266,7 @@ private CodeWriter makeSwitch(SwitchRegion sw, CodeWriter code) throws CodegenEx
 						}
 					}
 				} else if (k instanceof Integer) {
-					code.add(TypeGen.literalToString((Integer) k, arg.getType(), mth));
+					code.add(TypeGen.literalToString((Integer) k, arg.getType(), mth, fallback));
 				} else {
 					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : null));
 				}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java
Patch:
@@ -70,7 +70,7 @@ public boolean equals(Object o) {
 	@Override
 	public String toString() {
 		try {
-			String value = TypeGen.literalToString(literal, getType(), DEF_STRING_UTILS);
+			String value = TypeGen.literalToString(literal, getType(), DEF_STRING_UTILS, true);
 			if (getType().equals(ArgType.BOOLEAN) && (value.equals("true") || value.equals("false"))) {
 				return value;
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -103,7 +103,9 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion
 		}
 		RegisterArg initArg = phiInsn.getArg(0);
 		InsnNode initInsn = initArg.getAssignInsn();
-		if (initInsn == null || initArg.getSVar().getUseCount() != 1) {
+		if (initInsn == null
+				|| initInsn.contains(AFlag.DONT_GENERATE)
+				|| initArg.getSVar().getUseCount() != 1) {
 			return false;
 		}
 		if (!usedOnlyInLoop(mth, loopRegion, arg)) {

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java
Patch:
@@ -44,6 +44,6 @@ public void test() {
 		assertThat(code, containsOne("ONE(1)"));
 		// assertThat(code, containsOne("THREE(three)"));
 		// assertThat(code, containsOne("assertTrue(Numbers.ONE.getNum() == 1);"));
-		assertThat(code, containsOne("private Numbers(int n) {"));
+		assertThat(code, containsOne("Numbers(int n) {"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/api/SmaliTest.java
Patch:
@@ -56,9 +56,7 @@ protected List<ClassNode> loadFromSmaliFiles() {
 		JadxDecompiler d = loadFiles(Collections.singletonList(outDex));
 		RootNode root = JadxInternalAccess.getRoot(d);
 		List<ClassNode> classes = root.getClasses(false);
-		for (ClassNode cls : classes) {
-			decompileAndCheckCls(d, cls);
-		}
+		decompileAndCheck(d, classes);
 		return classes;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -46,6 +46,7 @@ public InvokeType getInvokeType() {
 		return type;
 	}
 
+	@Override
 	public MethodInfo getCallMth() {
 		return mth;
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -81,6 +81,7 @@ void setSVar(@NotNull SSAVar sVar) {
 		}
 	}
 
+	@Override
 	public String getName() {
 		if (isThis()) {
 			return THIS_ARG_NAME;
@@ -91,6 +92,7 @@ public String getName() {
 		return sVar.getName();
 	}
 
+	@Override
 	public void setName(String name) {
 		if (sVar != null && name != null) {
 			sVar.setName(name);

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -967,6 +967,7 @@ private void closeWindow() {
 		settings.setMainWindowExtendedState(getExtendedState());
 		cancelBackgroundJobs();
 		dispose();
+		System.exit(0);
 	}
 
 	public JadxWrapper getWrapper() {

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -168,7 +168,7 @@ void save(Path path) throws IOException {
 				save(outputStream);
 			}
 		} else if (outputName.endsWith(".jar")) {
-			Path temp = Files.createTempFile("jadx", ".zip");
+			Path temp = FileUtils.createTempFile(".zip");
 			Files.copy(path, temp, StandardCopyOption.REPLACE_EXISTING);
 
 			try (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(path));
@@ -185,8 +185,6 @@ void save(Path path) throws IOException {
 					entry = in.getNextEntry();
 				}
 			}
-			Files.delete(temp);
-
 		} else {
 			throw new JadxRuntimeException("Unknown file format: " + outputName);
 		}

File: jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java
Patch:
@@ -66,7 +66,7 @@ private void checkOutDirs(String outDir, String srcDir, String resDir) {
 
 	private JadxArgs makeArgs() {
 		JadxArgs args = new JadxArgs();
-		args.getInputFiles().add(FileUtils.createTempFile("some.apk"));
+		args.getInputFiles().add(FileUtils.createTempFile("some.apk").toFile());
 		return args;
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -9,6 +9,7 @@
 import java.io.InputStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.List;
@@ -134,7 +135,7 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {
 							case ".jar":
 								index++;
 								Path jarFile = Files.createTempFile(entryName, ".jar");
-								Files.copy(inputStream, jarFile);
+								Files.copy(inputStream, jarFile, StandardCopyOption.REPLACE_EXISTING);
 								for (Dex dex : loadFromJar(jarFile)) {
 									addDexFile(entryName, dex);
 								}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.IdentityHashMap;
 import java.util.List;

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -32,7 +32,6 @@
 import jadx.core.dex.nodes.parser.FieldInitAttr;
 import jadx.core.dex.nodes.parser.SignatureParser;
 import jadx.core.dex.nodes.parser.StaticValuesParser;
-import jadx.core.utils.RegionUtils;
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java
Patch:
@@ -1,7 +1,6 @@
 package jadx.core.dex.visitors.regions.variables;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass15.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.gui.settings;
 
+import java.awt.Rectangle;
 import java.lang.reflect.Modifier;
 import java.nio.file.Path;
 import java.util.prefs.Preferences;
@@ -15,6 +16,7 @@
 
 import jadx.gui.JadxGUI;
 import jadx.gui.utils.PathTypeAdapter;
+import jadx.gui.utils.RectangleTypeAdapter;
 
 public class JadxSettingsAdapter {
 
@@ -40,6 +42,7 @@ public boolean shouldSkipClass(Class<?> clazz) {
 	private static final GsonBuilder GSON_BUILDER = new GsonBuilder()
 			.setExclusionStrategies(EXCLUDE_FIELDS)
 			.registerTypeHierarchyAdapter(Path.class, PathTypeAdapter.singleton())
+			.registerTypeHierarchyAdapter(Rectangle.class, RectangleTypeAdapter.singleton())
 			;
 	private static final Gson GSON = GSON_BUILDER.create();
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -17,7 +17,6 @@
 import jadx.gui.utils.FontUtils;
 import jadx.gui.utils.LangLocale;
 import jadx.gui.utils.NLS;
-import jadx.gui.utils.Utils;
 
 public class JadxSettingsWindow extends JDialog {
 	private static final long serialVersionUID = -1804570470377354148L;

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java
Patch:
@@ -3,7 +3,6 @@
 import javax.swing.*;
 import java.awt.*;
 import java.awt.event.ActionEvent;
-import java.awt.event.InputEvent;
 import java.awt.event.KeyEvent;
 
 import jadx.gui.treemodel.JClass;

File: jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java
Patch:
@@ -6,7 +6,6 @@
 import java.awt.*;
 import java.awt.datatransfer.DataFlavor;
 import java.awt.event.ActionEvent;
-import java.awt.event.InputEvent;
 import java.awt.event.KeyEvent;
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;

File: jadx-gui/src/main/java/jadx/gui/utils/Utils.java
Patch:
@@ -6,13 +6,10 @@
 import java.awt.datatransfer.StringSelection;
 import java.awt.datatransfer.Transferable;
 import java.awt.event.InputEvent;
-import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.LinkedList;
 import java.util.Queue;
 
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.ArithNode;
 import jadx.core.dex.instructions.IfOp;
 import jadx.core.dex.instructions.InsnType;
@@ -155,7 +156,7 @@ private void addAndOr(CodeWriter code, CondStack stack, IfCondition condition) t
 	}
 
 	private boolean isWrapNeeded(IfCondition condition) {
-		if (condition.isCompare()) {
+		if (condition.isCompare() || condition.contains(AFlag.DONT_WRAP)) {
 			return false;
 		}
 		return condition.getMode() != Mode.NOT;

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -14,6 +14,7 @@
 
 import jadx.gui.ui.MainWindow;
 import jadx.gui.ui.codearea.EditorTheme;
+import jadx.gui.utils.FontUtils;
 import jadx.gui.utils.LangLocale;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.Utils;
@@ -267,7 +268,7 @@ public void mouseClicked(MouseEvent e) {
 
 	private String getFontLabelStr() {
 		Font font = settings.getFont();
-		String fontStyleName = Utils.getFontStyleName(font.getStyle());
+		String fontStyleName = FontUtils.convertFontStyleToString(font.getStyle());
 		return NLS.str("preferences.font") + ": " + font.getFontName() + ' ' + fontStyleName + ' ' + font.getSize();
 	}
 

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -232,7 +232,7 @@ private void processClass(ClassNode cls) {
 		ClassInfo clsInfo = cls.getClassInfo();
 		String fullName = getClassFullName(clsInfo);
 		if (!fullName.equals(clsInfo.getFullName())) {
-			clsInfo.rename(cls.dex().root(), fullName);
+			clsInfo.rename(cls.root(), fullName);
 		}
 		for (FieldNode field : cls.getFields()) {
 			if (field.contains(AFlag.DONT_RENAME)) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java
Patch:
@@ -114,8 +114,8 @@ private static void processCustomInsn(DexNode dex, Set<ClassNode> depList, InsnN
 
 	private static void addDep(DexNode dex, Set<ClassNode> depList, ArgType type) {
 		if (type != null) {
-			if (type.isObject()) {
-				addDep(dex, depList, ClassInfo.fromName(dex.root(), type.getObject()));
+			if (type.isObject() && !type.isGenericType()) {
+				addDep(dex, depList, ClassInfo.fromType(dex.root(), type));
 				ArgType[] genericTypes = type.getGenericTypes();
 				if (type.isGeneric() && genericTypes != null) {
 					for (ArgType argType : genericTypes) {

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -332,7 +332,7 @@ private void addMethod(CodeWriter code, MethodNode mth) throws CodegenException
 	private void insertDecompilationProblems(CodeWriter code, AttrNode node) {
 		List<JadxError> errors = node.getAll(AType.JADX_ERROR);
 		if (!errors.isEmpty()) {
-			errors.forEach(err -> {
+			errors.stream().sorted().forEach(err -> {
 				code.startLine("/*  JADX ERROR: ").add(err.getError());
 				Throwable cause = err.getCause();
 				if (cause != null) {
@@ -345,8 +345,8 @@ private void insertDecompilationProblems(CodeWriter code, AttrNode node) {
 		}
 		List<String> warns = node.getAll(AType.JADX_WARN);
 		if (!warns.isEmpty()) {
-			warns.stream().distinct()
-					.forEach(warn -> code.startLine("/* JADX WARNING: ").addMultiLine(warn).add(" */"));
+			warns.stream().distinct().sorted()
+				.forEach(warn -> code.startLine("/* JADX WARNING: ").addMultiLine(warn).add(" */"));
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.IdentityHashMap;
 import java.util.List;
@@ -121,6 +122,7 @@ public String toString() {
 		if (list.isEmpty()) {
 			return "";
 		}
+		list.sort(String::compareTo);
 		return "A[" + Utils.listToString(list) + ']';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java
Patch:
@@ -298,7 +298,7 @@ public boolean equals(Object obj) {
 		if (mode != other.mode) {
 			return false;
 		}
-		return Objects.equals(other.args, other.args)
+		return Objects.equals(args, other.args)
 			&& Objects.equals(compare, other.compare);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java
Patch:
@@ -32,7 +32,7 @@ public CodePanel(TabbedPane panel, JNode jnode) {
 		add(searchBar, BorderLayout.NORTH);
 		add(scrollPane);
 
-		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_DOWN_MASK);
+		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, Utils.ctrlButton());
 		Utils.addKeyBinding(codeArea, key, "SearchAction", new SearchAction());
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java
Patch:
@@ -100,9 +100,9 @@ void addPopupItems() {
 	}
 
 	private void addKeyActions() {
-		KeyStroke undoKey = KeyStroke.getKeyStroke(KeyEvent.VK_Z, InputEvent.CTRL_DOWN_MASK);
+		KeyStroke undoKey = KeyStroke.getKeyStroke(KeyEvent.VK_Z, Utils.ctrlButton());
 		textComponent.getInputMap().put(undoKey, undoAction);
-		KeyStroke redoKey = KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.CTRL_DOWN_MASK);
+		KeyStroke redoKey = KeyStroke.getKeyStroke(KeyEvent.VK_R, Utils.ctrlButton());
 		textComponent.getInputMap().put(redoKey, redoAction);
 	}
 

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -221,6 +221,9 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, EntryConfig c
 		int resRef = pkg.getId() << 24 | typeId << 16 | entryId;
 		String typeName = pkg.getTypeStrings()[typeId - 1];
 		String keyName = pkg.getKeyStrings()[key];
+		if(keyName.isEmpty()) {
+			keyName = "RES_" + resRef; // autogenerate key name
+		}
 		ResourceEntry ri = new ResourceEntry(resRef, pkg.getName(), typeName, keyName);
 		ri.setConfig(config);
 

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -249,7 +249,7 @@ public List<JavaPackage> getPackages() {
 		}
 		Collections.sort(packages);
 		for (JavaPackage pkg : packages) {
-			pkg.getClasses().sort(Comparator.comparing(JavaClass::getName));
+			pkg.getClasses().sort(Comparator.comparing(JavaClass::getName, String.CASE_INSENSITIVE_ORDER));
 		}
 		return Collections.unmodifiableList(packages);
 	}

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops4.java
Patch:
@@ -16,7 +16,7 @@ public int testFor() {
                     for (int j = 0; j < 54; j += 4) {
                         if (i < j) {
                             for (int k = j; k < j + 4; k++) {
-                                if (tmp> k) {
+                                if (tmp > k) {
                                     return 0;
                                 }
                             }

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -48,5 +48,7 @@ public enum AFlag {
 
 	FALL_THROUGH,
 
+	EXPLICIT_GENERICS,
+
 	INCONSISTENT_CODE, // warning about incorrect decompilation
 }

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotationsMix.java
Patch:
@@ -10,7 +10,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
@@ -112,8 +111,7 @@ public void testNoDebug() {
 	}
 
 	@Test
-	@NotYetImplemented
-	public void testNYI() {
+	public void testDeclaration() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass13.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.junit.jupiter.api.Test;
 
-import jadx.NotYetImplemented;
 import jadx.tests.api.IntegrationTest;
 
 public class TestAnonymousClass13 extends IntegrationTest {
@@ -16,7 +15,6 @@ public void test() {
 	}
 
 	@Test
-	@NotYetImplemented
 	public void test() {
 		getClassNode(TestCls.class);
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -83,7 +83,7 @@ public static ArgType generic(String sign) {
 		return new SignatureParser(sign).consumeType();
 	}
 
-	public static ArgType generic(String obj, ArgType[] generics) {
+	public static ArgType generic(String obj, ArgType... generics) {
 		return new GenericObject(obj, generics);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -326,7 +326,7 @@ private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, Regi
 			return true;
 		}
 		// TODO: add checks
-		iterableType = ArgType.generic(iterableType.getObject(), new ArgType[]{varType});
+		iterableType = ArgType.generic(iterableType.getObject(), varType);
 		iterableArg.setType(iterableType);
 		return true;
 	}

File: jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java
Patch:
@@ -76,7 +76,7 @@ public void compareGenerics() {
 
 		ArgType keyType = ArgType.genericType("K");
 		ArgType valueType = ArgType.genericType("V");
-		ArgType mapGeneric = ArgType.generic(mapCls.getObject(), new ArgType[]{keyType, valueType});
+		ArgType mapGeneric = ArgType.generic(mapCls.getObject(), keyType, valueType);
 
 		check(mapGeneric, mapCls, TypeCompareEnum.NARROW_BY_GENERIC);
 		check(mapCls, mapGeneric, TypeCompareEnum.WIDER_BY_GENERIC);

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java
Patch:
@@ -55,7 +55,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("call((ArrayList<String>) new ArrayList());"));
+		assertThat(code, containsOne("call(new ArrayList());"));
 		assertThat(code, containsOne("call((List<String>) new ArrayList());"));
 
 		assertThat(code, containsOne("call((String) obj);"));

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java
Patch:
@@ -15,6 +15,7 @@ public class TestVariablesUsageWithLoops extends IntegrationTest {
 
 	public static class TestEnhancedFor {
 
+		@SuppressWarnings("rawtypes")
 		public void test() {
 			List list;
 			synchronized (this) {

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass2.java
Patch:
@@ -33,7 +33,7 @@ public void run() {
 					}
 				};
 			}
-			/*
+
 			public Runnable test3() {
 				final int i = f + 2;
 				return new Runnable() {
@@ -43,7 +43,6 @@ public void run() {
 					}
 				};
 			}
-			*/
 		}
 	}
 
@@ -55,7 +54,7 @@ public void test() {
 		assertThat(code, not(containsString("synthetic")));
 		assertThat(code, not(containsString("AnonymousClass_")));
 		assertThat(code, containsString("f = 1;"));
-//		assertThat(code, containsString("f = i;"));
+		assertThat(code, containsString("f = i;"));
 		assertThat(code, not(containsString("Inner obj = ;")));
 		assertThat(code, containsString("Inner.this;"));
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java
Patch:
@@ -51,7 +51,8 @@ private static void checkStaticFieldsInit(ClassNode cls) {
 		MethodNode clinit = cls.getClassInitMth();
 		if (clinit == null
 				|| !clinit.getAccessFlags().isStatic()
-				|| clinit.isNoCode()) {
+				|| clinit.isNoCode()
+				|| clinit.getBasicBlocks() == null) {
 			return;
 		}
 
@@ -235,7 +236,7 @@ private static List<MethodNode> getConstructorsList(ClassNode cls) {
 	}
 
 	private static List<InsnNode> getFieldAssigns(MethodNode mth, FieldNode field, InsnType putInsn) {
-		if (mth.isNoCode()) {
+		if (mth.isNoCode() || mth.getBasicBlocks() == null) {
 			return Collections.emptyList();
 		}
 		List<InsnNode> assignInsns = new ArrayList<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java
Patch:
@@ -218,7 +218,7 @@ private static void processEnumSwitch(MethodNode mth, SwitchNode insn) {
 
 	private static void initClsEnumMap(ClassNode enumCls) {
 		MethodNode clsInitMth = enumCls.getClassInitMth();
-		if (clsInitMth == null || clsInitMth.isNoCode()) {
+		if (clsInitMth == null || clsInitMth.isNoCode() || clsInitMth.getBasicBlocks() == null) {
 			return;
 		}
 		EnumMapAttr mapAttr = new EnumMapAttr();

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java
Patch:
@@ -18,7 +18,7 @@ public boolean test1(boolean a, boolean b, boolean c) {
 		}
 
 		public int test2(boolean a, boolean b, boolean c) {
-			return (a ? b : c) ? 1 : 2;
+			return (!a ? c : b) ? 1 : 2;
 		}
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java
Patch:
@@ -11,7 +11,8 @@ public class TestArrayInitField extends IntegrationTest {
 
 	public static class TestCls {
 
-		byte[] bytes = new byte[]{10, 20, 30};
+		static byte[] a = new byte[]{10, 20, 30};
+		byte[] b = new byte[]{40, 50, 60};
 	}
 
 	@Test
@@ -20,5 +21,6 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsString("= {10, 20, 30};"));
+		assertThat(code, containsString("= {40, 50, 60};"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java
Patch:
@@ -82,6 +82,6 @@ public void test3() {
 		ClassNode cls = getClassNode(TestCls3.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("public static final String[] a = new String[]{\"a\"};"));
+		assertThat(code, containsOne("public static final String[] a = {\"a\"};"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java
Patch:
@@ -156,7 +156,7 @@ private FieldNode getResourceField(Integer value, DexNode dex) {
 		String typeName = parts[0];
 		String fieldName = parts[1];
 		for (ClassNode innerClass : appResClass.getInnerClasses()) {
-			if (innerClass.getShortName().equals(typeName)) {
+			if (innerClass.getClassInfo().getShortName().equals(typeName)) {
 				return innerClass.searchFieldByName(fieldName);
 			}
 		}

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java
Patch:
@@ -29,7 +29,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("int[] a = new int[]{1, 2, 4, 6, 8};"));
+		assertThat(code, containsOne("int[] a = {1, 2, 4, 6, 8};"));
 		assertThat(code, containsOne("for (int i = 0; i < a.length; i += 2) {"));
 		assertThat(code, containsOne("for (long i2 = (long) b; i2 > 0; i2--) {"));
 	}

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -214,6 +214,9 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, EntryConfig c
 		int size = is.readInt16();
 		int flags = is.readInt16();
 		int key = is.readInt32();
+		if (key == -1) {
+			return;
+		}
 
 		int resRef = pkg.getId() << 24 | typeId << 16 | entryId;
 		String typeName = pkg.getTypeStrings()[typeId - 1];

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -125,6 +125,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion
 		// all checks passed
 		initInsn.add(AFlag.DONT_GENERATE);
 		incrInsn.add(AFlag.DONT_GENERATE);
+
 		LoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);
 		if (arrForEach != null) {
 			loopRegion.setType(arrForEach);
@@ -281,6 +282,8 @@ private static boolean checkIterableForEach(MethodNode mth, LoopRegion loopRegio
 		}
 
 		assignInsn.add(AFlag.DONT_GENERATE);
+		assignInsn.getResult().add(AFlag.DONT_GENERATE);
+
 		for (InsnNode insnNode : toSkip) {
 			insnNode.add(AFlag.DONT_GENERATE);
 		}

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -31,6 +31,7 @@ What to do, when Binary XML Manifest is > size(int)?
 	Check Element chunk size
 */
 
+@SuppressWarnings("unused")
 public class BinaryXMLParser extends CommonBinaryParser {
 
 	private static final Logger LOG = LoggerFactory.getLogger(BinaryXMLParser.class);

File: jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java
Patch:
@@ -11,6 +11,7 @@ protected String[] parseStringPool() throws IOException {
 		return parseStringPoolNoType();
 	}
 
+	@SuppressWarnings("unused")
 	protected String[] parseStringPoolNoType() throws IOException {
 		long start = is.getPos() - 2;
 		is.checkInt16(0x001c, "String pool header size not 0x001c");

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -164,6 +164,7 @@ private PackageChunk parsePackage() throws IOException {
 		return pkg;
 	}
 
+	@SuppressWarnings("unused")
 	private void parseTypeSpecChunk() throws IOException {
 		is.checkInt16(0x0010, "Unexpected type spec header size");
 		/*int size = */

File: jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java
Patch:
@@ -14,12 +14,13 @@
 public class TestWrongCode extends IntegrationTest {
 
 	public static class TestCls {
-		private int test() {
+		@SuppressWarnings("null")
+		public int test() {
 			int[] a = null;
 			return a.length;
 		}
 
-		private int test2(int a) {
+		public int test2(int a) {
 			if (a == 0) {
 			}
 			return a;

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java
Patch:
@@ -13,9 +13,9 @@
 public class TestArith3 extends IntegrationTest {
 
 	public static class TestCls {
-		private int vp;
+		public int vp;
 
-		private void test(byte[] buffer) {
+		public void test(byte[] buffer) {
 			int n = ((buffer[3] & 255) + 4) + ((buffer[2] & 15) << 8);
 			while (n + 4 < buffer.length) {
 				int c = buffer[n] & 255;

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -37,7 +37,6 @@ public Object test2() {
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		CodeWriter codeWriter = cls.getCode();
-		String code = codeWriter.toString();
 
 		Map<Integer, Integer> lineMapping = codeWriter.getLineMapping();
 		assertEquals("{8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}",

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics2.java
Patch:
@@ -16,8 +16,8 @@
 public class TestGenerics2 extends IntegrationTest {
 
 	public static class TestCls {
-		private static class ItemReference<V> extends WeakReference<V> {
-			private Object id;
+		public static class ItemReference<V> extends WeakReference<V> {
+			public Object id;
 
 			public ItemReference(V item, Object objId, ReferenceQueue<? super V> queue) {
 				super(item, queue);

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestIssue86.java
Patch:
@@ -24,7 +24,7 @@ public static class TestCls {
 		private static final String WEATHER_TAG = "weather-tag";
 		private static final String DESC_TAG = "desc-tag";
 
-		private List<Day> test(String response) {
+		public List<Day> test(String response) {
 			List<Day> reportList = new ArrayList<>();
 			try {
 				System.out.println(response);

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass12.java
Patch:
@@ -16,8 +16,8 @@ public abstract static class BasicAbstract {
 			public abstract void doSomething();
 		}
 
-		private BasicAbstract outer;
-		private BasicAbstract inner;
+		public BasicAbstract outer;
+		public BasicAbstract inner;
 
 		public void test() {
 			outer = new BasicAbstract() {

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass2.java
Patch:
@@ -13,7 +13,7 @@ public class TestAnonymousClass2 extends IntegrationTest {
 
 	public static class TestCls {
 		public static class Inner {
-			private int f;
+			public int f;
 
 			public Runnable test() {
 				return new Runnable() {
@@ -27,6 +27,7 @@ public void run() {
 			public Runnable test2() {
 				return new Runnable() {
 					@Override
+					@SuppressWarnings("unused")
 					public void run() {
 						Object obj = Inner.this;
 					}

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass3.java
Patch:
@@ -13,7 +13,7 @@ public class TestAnonymousClass3 extends IntegrationTest {
 	public static class TestCls {
 		public static class Inner {
 			private int f;
-			private double d;
+			public double d;
 
 			public void test() {
 				new Thread() {

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass4.java
Patch:
@@ -12,6 +12,7 @@
 public class TestAnonymousClass4 extends IntegrationTest {
 
 	public static class TestCls {
+		@SuppressWarnings("unused")
 		public static class Inner {
 			private int f;
 			private double d;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass4.java
Patch:
@@ -19,7 +19,7 @@ private C() {
 			}
 		}
 
-		private String test() {
+		public String test() {
 			return new C().c;
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestOuterConstructorCall.java
Patch:
@@ -17,6 +17,7 @@ private TestCls(Inner inner) {
 		}
 
 		private class Inner {
+			@SuppressWarnings("unused")
 			private TestCls test() {
 				return new TestCls(this);
 			}

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvoke1.java
Patch:
@@ -16,7 +16,7 @@ public static class TestCls {
 
 		private A is;
 
-		private C test(int start) throws IOException {
+		public C test(int start) throws IOException {
 			int id = is.readInt32();
 			String name = is.readString16Fixed(128);
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvokeInCatch.java
Patch:
@@ -17,7 +17,7 @@ public class TestInvokeInCatch extends IntegrationTest {
 	public static class TestCls {
 		private static final String TAG = "TAG";
 
-		private void test(int[] a, int b) {
+		public void test(int[] a, int b) {
 			try {
 				exc();
 			} catch (IOException e) {

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java
Patch:
@@ -7,7 +7,6 @@
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.anyOf;
 
 public class TestSuperInvokeWithGenerics extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach.java
Patch:
@@ -12,7 +12,7 @@ public class TestArrayForEach extends IntegrationTest {
 
 	public static class TestCls {
 
-		private int test(int[] a) {
+		public int test(int[] a) {
 			int sum = 0;
 			for (int n : a) {
 				sum += n;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach2.java
Patch:
@@ -13,7 +13,7 @@
 public class TestArrayForEach2 extends IntegrationTest {
 
 	public static class TestCls {
-		private void test(String str) {
+		public void test(String str) {
 			for (String s : str.split("\n")) {
 				String t = s.trim();
 				if (t.length() > 0) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEachNegative.java
Patch:
@@ -13,7 +13,7 @@ public class TestArrayForEachNegative extends IntegrationTest {
 
 	public static class TestCls {
 
-		private int test(int[] a, int[] b) {
+		public int test(int[] a, int[] b) {
 			int sum = 0;
 			for (int i = 0; i < a.length; i += 2) {
 				sum += a[i];

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop.java
Patch:
@@ -12,9 +12,9 @@
 public class TestBreakInLoop extends IntegrationTest {
 
 	public static class TestCls {
-		private int f;
+		public int f;
 
-		private void test(int[] a, int b) {
+		public void test(int[] a, int b) {
 			for (int i = 0; i < a.length; i++) {
 				a[i]++;
 				if (i < b) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop.java
Patch:
@@ -11,9 +11,9 @@
 public class TestContinueInLoop extends IntegrationTest {
 
 	public static class TestCls {
-		private int f;
+		public int f;
 
-		private void test(int[] a, int b) {
+		public void test(int[] a, int b) {
 			for (int i = 0; i < a.length; i++) {
 				int v = a[i];
 				if (v < b) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach.java
Patch:
@@ -11,7 +11,7 @@
 public class TestIterableForEach extends IntegrationTest {
 
 	public static class TestCls {
-		private String test(Iterable<String> a) {
+		public String test(Iterable<String> a) {
 			StringBuilder sb = new StringBuilder();
 			for (String s : a) {
 				sb.append(s);

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach3.java
Patch:
@@ -16,7 +16,7 @@ public static class TestCls<T extends String> {
 		private Set<T> a;
 		private Set<T> b;
 
-		private void test(T str) {
+		public void test(T str) {
 			Set<T> set = str.length() == 1 ? a : b;
 			for (T s : set) {
 				if (s.length() == str.length()) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition.java
Patch:
@@ -16,7 +16,7 @@ public static class TestCls {
 		private void setEnabled(boolean r1z) {
 		}
 
-		private void testIfInLoop() {
+		public void testIfInLoop() {
 			int j = 0;
 			for (int i = 0; i < f.length(); i++) {
 				char ch = f.charAt(i);
@@ -31,7 +31,7 @@ private void testIfInLoop() {
 			setEnabled(false);
 		}
 
-		private void testMoreComplexIfInLoop(java.util.ArrayList<String> list) throws Exception {
+		public void testMoreComplexIfInLoop(java.util.ArrayList<String> list) throws Exception {
 			for (int i = 0; i != 16 && i < 255; i++) {
 				list.set(i, "ABC");
 				if (i == 128) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java
Patch:
@@ -13,7 +13,7 @@
 public class TestLoopCondition5 extends SmaliTest {
 
 	public static class TestCls {
-		private static int lastIndexOf(int[] array, int target, int start, int end) {
+		public static int lastIndexOf(int[] array, int target, int start, int end) {
 			for (int i = end - 1; i >= start; i--) {
 				if (array[i] == target) {
 					return i;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopConditionInvoke.java
Patch:
@@ -14,7 +14,7 @@ public static class TestCls {
 		private static final char STOP_CHAR = 0;
 		private int pos;
 
-		private boolean test(char lastChar) {
+		public boolean test(char lastChar) {
 			int startPos = pos;
 			char ch;
 			while ((ch = next()) != STOP_CHAR) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection.java
Patch:
@@ -13,7 +13,7 @@ public class TestLoopDetection extends IntegrationTest {
 
 	public static class TestCls {
 
-		private void test(int[] a, int b) {
+		public void test(int[] a, int b) {
 			int i = 0;
 			while (i < a.length && i < b) {
 				a[i]++;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection3.java
Patch:
@@ -13,7 +13,7 @@ public class TestLoopDetection3 extends IntegrationTest {
 
 	public static class TestCls {
 
-		private void test(TestCls parent, int pos) {
+		public void test(TestCls parent, int pos) {
 			Object item;
 			while (--pos >= 0) {
 				item = parent.get(pos);

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection4.java
Patch:
@@ -16,7 +16,7 @@ public static class TestCls {
 		private Iterator<String> iterator;
 		private SomeCls filter;
 
-		private String test() {
+		public String test() {
 			while (iterator.hasNext()) {
 				String next = iterator.next();
 				String filtered = filter.filter(next);

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops.java
Patch:
@@ -14,7 +14,7 @@ public class TestNestedLoops extends IntegrationTest {
 
 	public static class TestCls {
 
-		private void test(List<String> l1, List<String> l2) {
+		public void test(List<String> l1, List<String> l2) {
 			for (String s1 : l1) {
 				for (String s2 : l2) {
 					if (s1.equals(s2)) {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops2.java
Patch:
@@ -14,7 +14,7 @@ public class TestNestedLoops2 extends IntegrationTest {
 
 	public static class TestCls {
 
-		private boolean test(List<String> list) {
+		public boolean test(List<String> list) {
 			int j = 0;
 			for (int i = 0; i < list.size(); i++) {
 				String s = list.get(i);

File: jadx-core/src/test/java/jadx/tests/integration/names/TestNameAssign2.java
Patch:
@@ -21,7 +21,7 @@ public class TestNameAssign2 extends IntegrationTest {
 
 	public static class TestCls {
 
-		private static void test(MethodNode mth, int regNum, LiveVarAnalysis la) {
+		public static void test(MethodNode mth, int regNum, LiveVarAnalysis la) {
 			List<BlockNode> blocks = mth.getBasicBlocks();
 			int blocksCount = blocks.size();
 			BitSet hasPhi = new BitSet(blocksCount);

File: jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java
Patch:
@@ -19,7 +19,7 @@ public static class TestCls {
 		}
 
 		public static class A {
-			private final String s;
+			public final String s;
 
 			public A() {
 				s = "a";

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit2.java
Patch:
@@ -17,13 +17,13 @@ public interface BasicAbstract {
 			void doSomething();
 		}
 
-		private BasicAbstract x = new BasicAbstract() {
+		public BasicAbstract x = new BasicAbstract() {
 			@Override
 			public void doSomething() {
 				y = 1;
 			}
 		};
-		private int y = 0;
+		public int y = 0;
 
 		public TestCls() {
 		}

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIfInTry.java
Patch:
@@ -15,7 +15,7 @@
 public class TestIfInTry extends IntegrationTest {
 
 	public static class TestCls {
-		private File dir;
+		public File dir;
 
 		public int test() {
 			try {

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIfTryInCatch.java
Patch:
@@ -12,7 +12,7 @@
 public class TestIfTryInCatch extends IntegrationTest {
 
 	public static class TestCls {
-		private Exception exception;
+		public Exception exception;
 		private java.lang.Object data;
 
 		public java.lang.Object test(final Object obj) {

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13b.java
Patch:
@@ -22,9 +22,9 @@ public static class TestCls {
 		private static final String PROPERTIES_FILE = "";
 		private static final String TAG = "";
 		private final CountDownLatch mInitializedLatch = new CountDownLatch(1);
-		private int mC2KServerPort = 0;
+		public int mC2KServerPort = 0;
 		private String mSuplServerHost = "";
-		private int mSuplServerPort = 0;
+		public int mSuplServerPort = 0;
 		private String mC2KServerHost = "";
 
 		public TestCls() {

File: jadx-core/src/test/java/jadx/tests/integration/others/TestLoopInTry2.java
Patch:
@@ -8,7 +8,6 @@
 import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
-import jadx.core.dex.nodes.DexNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.tests.api.IntegrationTest;
@@ -20,8 +19,7 @@ public class TestLoopInTry2 extends IntegrationTest {
 
 	public static class TestCls {
 		private MethodNode method;
-		private DexNode dex;
-		private DecodedInstruction[] insnArr;
+		public DecodedInstruction[] insnArr;
 
 		public void test(Code mthCode) throws DecodeException {
 			short[] encodedInstructions = mthCode.getInstructions();

File: jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized2.java
Patch:
@@ -13,6 +13,7 @@
 public class TestSynchronized2 extends IntegrationTest {
 
 	public static class TestCls {
+		@SuppressWarnings("unused")
 		private static synchronized boolean test(Object obj) {
 			return obj.toString() != null;
 		}

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestNestedTryCatch.java
Patch:
@@ -12,7 +12,7 @@
 public class TestNestedTryCatch extends IntegrationTest {
 
 	public static class TestCls {
-		private void f() {
+		public void f() {
 			try {
 				Thread.sleep(1);
 				try {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch.java
Patch:
@@ -12,7 +12,7 @@
 public class TestTryCatch extends IntegrationTest {
 
 	public static class TestCls {
-		private void f() {
+		public void f() {
 			try {
 				Thread.sleep(50);
 			} catch (InterruptedException e) {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch2.java
Patch:
@@ -13,7 +13,7 @@ public class TestTryCatch2 extends IntegrationTest {
 	public static class TestCls {
 		private final static Object obj = new Object();
 
-		private static boolean test() {
+		public static boolean test() {
 			try {
 				synchronized (obj) {
 					obj.wait(5);

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch4.java
Patch:
@@ -16,7 +16,8 @@
 public class TestTryCatch4 extends IntegrationTest {
 
 	public static class TestCls {
-		private Object test(Object obj) {
+		@SuppressWarnings({ "resource", "unused" })
+		public Object test(Object obj) {
 			FileOutputStream output = null;
 			try {
 				output = new FileOutputStream(new File("f"));

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch7.java
Patch:
@@ -11,7 +11,7 @@
 public class TestTryCatch7 extends IntegrationTest {
 
 	public static class TestCls {
-		private Exception test() {
+		public Exception test() {
 			Exception e = new Exception();
 			try {
 				Thread.sleep(50);

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally5.java
Patch:
@@ -15,7 +15,7 @@
 public class TestTryCatchFinally5 extends IntegrationTest {
 
 	public static class TestCls {
-		private <E> List<E> test(A a, B<E> b) {
+		public <E> List<E> test(A a, B<E> b) {
 			C c = p(a);
 			if (c == null) {
 				return null;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java
Patch:
@@ -16,7 +16,7 @@
 public class TestTryCatchFinally8 extends IntegrationTest {
 
 	public static class TestCls {
-		private Object test(Object obj) {
+		public Object test(Object obj) {
 			File file = new File("r");
 			FileOutputStream output = null;
 			try {

File: jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics.java
Patch:
@@ -11,7 +11,7 @@
 public class TestGenerics extends IntegrationTest {
 
 	public static class TestCls<T> {
-		private T data;
+		public T data;
 
 		public TestCls<T> data(T t) {
 			this.data = t;

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeInheritance.java
Patch:
@@ -25,7 +25,7 @@ public static class B implements IBase {
 			public void b() {}
 		}
 
-		private static void test(boolean z) {
+		public static void test(boolean z) {
 			IBase impl;
 			if (z) {
 				impl = new A();

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver2.java
Patch:
@@ -14,7 +14,7 @@ public class TestTypeResolver2 extends IntegrationTest {
 
 	public static class TestCls {
 
-		private static boolean test(Object obj) throws IOException {
+		public static boolean test(Object obj) throws IOException {
 			if (obj != null) {
 				return true;
 			}

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver6.java
Patch:
@@ -11,7 +11,7 @@
 public class TestTypeResolver6 extends IntegrationTest {
 
 	public static class TestCls {
-		private final Object obj;
+		public final Object obj;
 
 		public TestCls(boolean b) {
 			this.obj = b ? this : makeObj();

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver6a.java
Patch:
@@ -11,7 +11,7 @@
 public class TestTypeResolver6a extends IntegrationTest {
 
 	public static class TestCls implements Runnable {
-		private final Runnable runnable;
+		public final Runnable runnable;
 
 		public TestCls(boolean b) {
 			this.runnable = b ? this : makeRunnable();

File: jadx-core/src/test/java/jadx/tests/integration/usethis/TestDontInlineThis.java
Patch:
@@ -15,7 +15,7 @@ public class TestDontInlineThis extends IntegrationTest {
 	public static class TestCls {
 		public int field = new Random().nextInt();
 
-		private TestCls test() {
+		public TestCls test() {
 			TestCls res;
 			if (field == 7) {
 				res = this;

File: jadx-core/src/test/java/jadx/tests/integration/usethis/TestInlineThis.java
Patch:
@@ -15,7 +15,7 @@ public class TestInlineThis extends IntegrationTest {
 	public static class TestCls {
 		public int field;
 
-		private void test() {
+		public void test() {
 			TestCls something = this;
 			something.method();
 			something.field = 123;

File: jadx-core/src/test/java/jadx/tests/integration/usethis/TestInlineThis2.java
Patch:
@@ -17,7 +17,7 @@ public class TestInlineThis2 extends IntegrationTest {
 	public static class TestCls {
 		public int field;
 
-		private void test() {
+		public void test() {
 			TestCls thisVar = this;
 			if (Objects.isNull(thisVar)) {
 				System.out.println("null");

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables4.java
Patch:
@@ -14,7 +14,7 @@
 public class TestVariables4 extends IntegrationTest {
 
 	public static class TestCls {
-		private static boolean runTest(String clsName) {
+		public static boolean runTest(String clsName) {
 			try {
 				boolean pass = false;
 				String msg = null;

File: jadx-samples/src/main/java/jadx/samples/TestTypeResolver.java
Patch:
@@ -2,7 +2,7 @@
 
 public class TestTypeResolver extends AbstractTest {
 
-	private final int f1;
+	public final int f1;
 
 	public TestTypeResolver() {
 		this.f1 = 2;

File: jadx-samples/src/main/java/jadx/samples/TestTypeResolver2.java
Patch:
@@ -21,11 +21,11 @@ public void testOverloadedMethods() {
 		}
 	}
 
-	private static void doPrint(String s1) {
+	public static void doPrint(String s1) {
 		fail();
 	}
 
-	private static void doPrint(Integer s1) {
+	public static void doPrint(Integer s1) {
 		fail();
 	}
 
@@ -43,6 +43,6 @@ public boolean testRun() throws Exception {
 	}
 
 	public static void main(String[] args) throws Exception {
-		(new TestTypeResolver2()).testRun();
+		new TestTypeResolver2().testRun();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -36,7 +36,7 @@ public InvokeNode(MethodInfo mth, DecodedInstruction insn, InvokeType type, bool
 		}
 	}
 
-	private InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {
+	public InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {
 		super(InsnType.INVOKE, argsCount);
 		this.mth = mth;
 		this.type = invokeType;

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -97,7 +97,7 @@ public static String formatShort(short s) {
 		if (s == Short.MIN_VALUE) {
 			return "Short.MIN_VALUE";
 		}
-		return "(short) " + s;
+		return Short.toString(s);
 	}
 
 	public static String formatByte(byte b) {
@@ -107,7 +107,7 @@ public static String formatByte(byte b) {
 		if (b == Byte.MIN_VALUE) {
 			return "Byte.MIN_VALUE";
 		}
-		return "(byte) " + b;
+		return Byte.toString(b);
 	}
 
 	public static String formatInteger(int i) {

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java
Patch:
@@ -41,7 +41,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("(strArray[end] != (byte) 0 || strArray[end + 1] != (byte) 0)"));
+		assertThat(code, containsOne("(strArray[end] != 0 || strArray[end + 1] != 0)"));
 	}
 
 	@Test

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -756,7 +756,7 @@ public void menuCanceled(MenuEvent e) {
 	}
 
 	private class JPackagePopUp extends JPopupMenu {
-		JMenuItem excludeItem = new JCheckBoxMenuItem("Exclude");
+		JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));
 
 		public JPackagePopUp(JPackage pkg) {
 			excludeItem.setSelected(!pkg.isEnabled());

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -495,7 +495,7 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro
 			case NEW_INSTANCE:
 				// only fallback - make new instance in constructor invoke
 				fallbackOnlyInsn(insn);
-				code.add("new ").add(insn.getResult().getType().toString());
+				code.add("new ").add(insn.getResult().getInitType().toString());
 				break;
 
 			case PHI:

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -11,7 +11,7 @@
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.InsnNode;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
@@ -64,7 +64,7 @@ public boolean removeArg(InsnArg arg) {
 		if (super.removeArg(reg)) {
 			blockBinds.remove(reg);
 			reg.getSVar().removeUse(reg);
-			InstructionRemover.fixUsedInPhiFlag(reg);
+			InsnRemover.fixUsedInPhiFlag(reg);
 			return true;
 		}
 		return false;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -29,7 +29,7 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.utils.BlockUtils;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.core.utils.exceptions.JadxException;
 
 @JadxVisitor(
@@ -131,7 +131,7 @@ private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode
 			return false;
 		}
 		mth.skipFirstArgument();
-		InstructionRemover.remove(mth, block, insn);
+		InsnRemover.remove(mth, block, insn);
 		// other arg usage -> wrap with IGET insn
 		if (arg.getSVar().getUseCount() != 0) {
 			InsnNode iget = new IndexInsnNode(InsnType.IGET, fieldInfo, 1);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java
Patch:
@@ -20,7 +20,7 @@
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.exceptions.JadxOverflowException;
 
@@ -46,7 +46,7 @@ public void visit(MethodNode mth) throws JadxException {
 			for (InsnNode insn : block.getInstructions()) {
 				checkInsn(mth, insn, toRemove);
 			}
-			InstructionRemover.removeAll(mth, block, toRemove);
+			InsnRemover.removeAllAndUnbind(mth, block, toRemove);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java
Patch:
@@ -22,7 +22,7 @@
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.nodes.parser.FieldInitAttr;
 import jadx.core.utils.BlockUtils;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.core.utils.exceptions.JadxException;
 
 @JadxVisitor(
@@ -92,7 +92,7 @@ private static void moveStaticFieldsInit(ClassNode cls) {
 				if (initInsns.size() == 1) {
 					InsnNode insn = initInsns.get(0);
 					if (checkInsn(insn)) {
-						InstructionRemover.remove(classInitMth, insn);
+						InsnRemover.remove(classInitMth, insn);
 						addFieldInitAttr(classInitMth, field, insn);
 					}
 				}
@@ -165,7 +165,7 @@ private static void moveCommonFieldsInit(ClassNode cls) {
 		// all checks passed
 		for (InitInfo info : infoList) {
 			for (InsnNode putInsn : info.getPutInsns()) {
-				InstructionRemover.remove(info.getConstrMth(), putInsn);
+				InsnRemover.remove(info.getConstrMth(), putInsn);
 			}
 		}
 		for (InsnNode insn : common.getPutInsns()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java
Patch:
@@ -16,7 +16,7 @@
 import jadx.core.dex.trycatch.TryCatchBlock;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.BlockUtils;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 
 public class BlockExceptionHandler extends AbstractVisitor {
 
@@ -77,13 +77,13 @@ private static void processExceptionHandlers(MethodNode mth, BlockNode block) {
 		}
 		for (BlockNode excBlock : excHandler.getBlocks()) {
 			// remove 'monitor-exit' from exception handler blocks
-			InstructionRemover remover = new InstructionRemover(mth, excBlock);
+			InsnRemover remover = new InsnRemover(mth, excBlock);
 			for (InsnNode insn : excBlock.getInstructions()) {
 				if (insn.getType() == InsnType.MONITOR_ENTER) {
 					break;
 				}
 				if (insn.getType() == InsnType.MONITOR_EXIT) {
-					remover.add(insn);
+					remover.addAndUnbind(insn);
 				}
 			}
 			remover.perform();

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -41,7 +41,7 @@
 import jadx.core.dex.trycatch.TryCatchBlock;
 import jadx.core.utils.BlockUtils;
 import jadx.core.utils.ErrorsCounter;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.core.utils.RegionUtils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
@@ -567,7 +567,7 @@ private BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNo
 			}
 			exitInsn.add(AFlag.DONT_GENERATE);
 			exitInsn.add(AFlag.REMOVE);
-			InstructionRemover.unbindInsn(mth, exitInsn);
+			InsnRemover.unbindInsn(mth, exitInsn);
 		}
 
 		BlockNode body = getNextBlock(block);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -25,7 +25,7 @@
 import jadx.core.dex.regions.SynchronizedRegion;
 import jadx.core.dex.regions.loops.LoopRegion;
 import jadx.core.dex.visitors.AbstractVisitor;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.core.utils.RegionUtils;
 import jadx.core.utils.exceptions.JadxException;
 
@@ -176,10 +176,10 @@ private static void removeSynchronized(MethodNode mth) {
 			// replace synchronized block with inner region
 			startRegion.getSubBlocks().set(0, synchRegion.getRegion());
 			// remove 'monitor-enter' instruction
-			InstructionRemover.remove(mth, synchInsn);
+			InsnRemover.remove(mth, synchInsn);
 			// remove 'monitor-exit' instruction
 			for (InsnNode exit : synchRegion.getExitInsns()) {
-				InstructionRemover.remove(mth, exit);
+				InsnRemover.remove(mth, exit);
 			}
 			// run region cleaner again
 			CleanRegions.process(mth);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java
Patch:
@@ -28,6 +28,7 @@
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.dex.visitors.regions.DepthRegionTraversal;
 import jadx.core.utils.RegionUtils;
+import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxException;
 
 public class ProcessVariables extends AbstractVisitor {
@@ -148,9 +149,7 @@ private Map<CodeVar, List<VarUsage>> mergeUsageMaps(List<CodeVar> codeVars, Map<
 					list.add(usage);
 				}
 			}
-			if (!list.isEmpty()) {
-				codeVarUsage.put(codeVar, list);
-			}
+			codeVarUsage.put(codeVar, Utils.lockList(list));
 		}
 		return codeVarUsage;
 	}

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop2.java
Patch:
@@ -13,7 +13,7 @@
 import jadx.core.dex.trycatch.ExceptionHandler;
 import jadx.core.dex.trycatch.TryCatchBlock;
 import jadx.core.utils.BlockUtils;
-import jadx.core.utils.InstructionRemover;
+import jadx.core.utils.InsnRemover;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
@@ -33,13 +33,13 @@ private static void test(MethodNode mth, BlockNode block) {
 					excHandler.addBlock(node);
 				}
 				for (BlockNode excBlock : excHandler.getBlocks()) {
-					InstructionRemover remover = new InstructionRemover(mth, excBlock);
+					InsnRemover remover = new InsnRemover(mth, excBlock);
 					for (InsnNode insn : excBlock.getInstructions()) {
 						if (insn.getType() == InsnType.MONITOR_ENTER) {
 							break;
 						}
 						if (insn.getType() == InsnType.MONITOR_EXIT) {
-							remover.add(insn);
+							remover.addAndUnbind(insn);
 						}
 					}
 					remover.perform();

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions.java
Patch:
@@ -12,7 +12,7 @@
 public class TestConditions extends IntegrationTest {
 
 	public static class TestCls {
-		private boolean test(boolean a, boolean b, boolean c) {
+		public boolean test(boolean a, boolean b, boolean c) {
 			return (a && b) || c;
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions15.java
Patch:
@@ -12,7 +12,7 @@ public class TestConditions15 extends IntegrationTest {
 
 	public static class TestCls {
 
-		private static boolean test(final String name) {
+		public static boolean test(final String name) {
 			if (isEmpty(name)) {
 				return false;
 			}

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -110,7 +110,7 @@ public boolean overrideProvided(String[] args) {
 		return process(jcw);
 	}
 
-	private boolean process(JCommanderWrapper<?> jcw) {
+	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {
 		if (printHelp) {
 			jcw.printUsage();
 			return false;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -25,6 +25,6 @@ public AType<AttrList<T>> getType() {
 
 	@Override
 	public String toString() {
-		return Utils.listToString(list);
+		return Utils.listToString(list, "\n");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java
Patch:
@@ -121,6 +121,6 @@ public String toString() {
 		if (list.isEmpty()) {
 			return "";
 		}
-		return "A:{" + Utils.listToString(list) + '}';
+		return "A[" + Utils.listToString(list) + ']';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java
Patch:
@@ -1,5 +1,5 @@
 package jadx.core.dex.attributes;
 
 public interface IAttribute {
-	<T extends IAttribute> AType<T> getType();
+	AType<? extends IAttribute> getType();
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java
Patch:
@@ -12,7 +12,7 @@
 
 public class AnnotationsList implements IAttribute {
 
-	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());
+	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.emptyList());
 
 	private final Map<String, Annotation> map;
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java
Patch:
@@ -36,7 +36,7 @@ public String toString() {
 			str.append(cause.getClass());
 			str.append(':');
 			str.append(cause.getMessage());
-			str.append("\n");
+			str.append('\n');
 			str.append(Utils.getStackTrace(cause));
 		}
 		return str.toString();

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -27,6 +27,9 @@ public String toString() {
 		for (PhiInsn phiInsn : list) {
 			sb.append('r').append(phiInsn.getResult().getRegNum()).append(' ');
 		}
+		for (PhiInsn phiInsn : list) {
+			sb.append("\n  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
+		}
 		return sb.toString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java
Patch:
@@ -66,9 +66,6 @@ public enum InsnType {
 	ONE_ARG,
 	PHI,
 
-	// merge all arguments in one
-	MERGE,
-
 	// TODO: now multidimensional arrays created using Array.newInstance function
 	NEW_MULTIDIM_ARRAY
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -46,11 +46,10 @@ public ConstructorInsn(MethodNode mth, InvokeNode invoke) {
 			instanceArg.getSVar().setAssign(instanceArg);
 		}
 		instanceArg.getSVar().removeUse(instanceArg);
-		for (int i = 1; i < invoke.getArgsCount(); i++) {
+		int argsCount = invoke.getArgsCount();
+		for (int i = 1; i < argsCount; i++) {
 			addArg(invoke.getArg(i));
 		}
-		offset = invoke.getOffset();
-		setSourceLine(invoke.getSourceLine());
 	}
 
 	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -231,7 +231,7 @@ private void addSourceFilenameAttr(String fileName) {
 				return;
 			}
 			if (fileName.contains("$")
-					&& fileName.endsWith("$" + name)) {
+					&& fileName.endsWith('$' + name)) {
 				return;
 			}
 			ClassInfo parentClass = clsInfo.getTopParentClass();

File: jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java
Patch:
@@ -14,7 +14,7 @@ public class FieldNode extends LineAttrNode implements ICodeNode {
 	private final FieldInfo fieldInfo;
 	private AccessInfo accFlags;
 
-	private ArgType type; // store signature
+	private ArgType type;
 
 	public FieldNode(ClassNode cls, Field field) {
 		this(cls, FieldInfo.fromDex(cls.dex(), field.getFieldIndex()),

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java
Patch:
@@ -211,7 +211,7 @@ private ArgType[] consumeGenericArgs() {
 				list.add(type);
 			}
 		} while (type != null && !lookAhead('>'));
-		return list.toArray(new ArgType[list.size()]);
+		return list.toArray(new ArgType[0]);
 	}
 
 	/**

File: jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java
Patch:
@@ -64,7 +64,9 @@ public List<IContainer> getSubBlocks() {
 	public List<IContainer> getBranches() {
 		List<IContainer> branches = new ArrayList<>(cases.size() + 1);
 		branches.addAll(cases);
-		branches.add(defCase);
+		if (defCase != null) {
+			branches.add(defCase);
+		}
 		return Collections.unmodifiableList(branches);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/ForEachLoop.java
Patch:
@@ -10,6 +10,9 @@ public final class ForEachLoop extends LoopType {
 	public ForEachLoop(RegisterArg varArg, InsnArg iterableArg) {
 		this.varArg = varArg;
 		this.iterableArg = iterableArg;
+
+		// will be declared at codegen
+		varArg.getSVar().getCodeVar().setDeclared(true);
 	}
 
 	public RegisterArg getVarArg() {

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java
Patch:
@@ -39,6 +39,7 @@ public ExceptionHandler(int addr, @Nullable ClassInfo type) {
 
 	/**
 	 * Add exception type to catch block
+	 *
 	 * @param type - null for 'all' or 'Throwable' handler
 	 */
 	public void addCatchType(@Nullable ClassInfo type) {

File: jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java
Patch:
@@ -70,7 +70,7 @@ private void unbindHandler(ExceptionHandler handler) {
 		for (BlockNode block : handler.getBlocks()) {
 			// skip synthetic loop exit blocks
 			BlockUtils.skipPredSyntheticPaths(block);
-			block.add(AFlag.SKIP);
+			block.add(AFlag.REMOVE);
 			ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);
 			if (excHandlerAttr != null
 					&& excHandlerAttr.getHandler().equals(handler)) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -26,14 +26,15 @@
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;
 import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.exceptions.JadxException;
 
 @JadxVisitor(
 		name = "EnumVisitor",
 		desc = "Restore enum classes",
-		runAfter = {CodeShrinker.class, ModVisitor.class}
+		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}
 )
 public class EnumVisitor extends AbstractVisitor {
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java
Patch:
@@ -21,6 +21,7 @@
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;
 import jadx.core.utils.exceptions.JadxException;
 
 @JadxVisitor(
@@ -77,7 +78,7 @@ private static void inlineMth(MethodNode mth, BlockNode firstBlock, BlockNode re
 					&& get.getResult().equalRegisterAndType((RegisterArg) retArg)) {
 				RegisterArg retReg = (RegisterArg) retArg;
 				retReg.getSVar().removeUse(retReg);
-				CodeShrinker.shrinkMethod(mth);
+				CodeShrinkVisitor.shrinkMethod(mth);
 
 				insnList = firstBlock.getInstructions();
 				if (insnList.size() == 1) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java
Patch:
@@ -76,6 +76,7 @@ private void checkClassName(ClassNode cls) {
 		String newShortName = fixClsShortName(clsName);
 		if (!newShortName.equals(clsName)) {
 			classInfo.rename(cls.root(), alias.makeFullClsName(newShortName, true));
+			alias = classInfo.getAlias();
 		}
 		if (alias.getPackage().isEmpty()) {
 			String fullName = alias.makeFullClsName(alias.getShortName(), true);

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -14,7 +14,6 @@
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttributeNode;
 import jadx.core.dex.attributes.nodes.JadxError;
-import jadx.core.dex.attributes.nodes.JadxWarn;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.IDexNode;
 import jadx.core.dex.nodes.MethodNode;
@@ -60,7 +59,7 @@ private synchronized <N extends IDexNode & IAttributeNode> String addWarning(N n
 		warnNodes.add(node);
 		warnsCount++;
 
-		node.addAttr(AType.JADX_WARN, new JadxWarn(warn));
+		node.addAttr(AType.JADX_WARN, warn);
 		if (!node.contains(AType.JADX_ERROR)) {
 			node.add(AFlag.INCONSISTENT_CODE);
 		}

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.TreeMap;
 
 import com.android.dx.rop.code.AccessFlags;
-import jadx.core.dex.attributes.AFlag;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
@@ -15,6 +14,7 @@
 import jadx.core.codegen.ClassGen;
 import jadx.core.codegen.CodeWriter;
 import jadx.core.deobf.NameMapper;
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.info.ClassInfo;

File: jadx-core/src/test/java/jadx/NotYetImplemented.java
Patch:
@@ -21,4 +21,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface NotYetImplemented {
+	String value() default "";
 }

File: jadx-core/src/test/java/jadx/NotYetImplementedExtension.java
Patch:
@@ -35,5 +35,4 @@ private static boolean isNotYetImplemented(ExtensionContext context) {
 		return context.getTestMethod().get().getAnnotation(NotYetImplemented.class) != null
 				|| context.getTestClass().get().getAnnotation(NotYetImplemented.class) != null;
 	}
-
 }

File: jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java
Patch:
@@ -7,8 +7,8 @@
 import jadx.core.utils.files.FileUtils;
 
 import static jadx.core.utils.files.FileUtils.toFile;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class JadxArgsValidatorOutDirsTest {
 
@@ -44,8 +44,8 @@ public void checkNone() {
 		setOutDirs(null, null, null);
 		String inputFileBase = args.getInputFiles().get(0).getName().replace(".apk", "");
 		checkOutDirs(inputFileBase,
-				inputFileBase + "/" + JadxArgs.DEFAULT_SRC_DIR,
-				inputFileBase + "/" + JadxArgs.DEFAULT_RES_DIR);
+				inputFileBase + '/' + JadxArgs.DEFAULT_SRC_DIR,
+				inputFileBase + '/' + JadxArgs.DEFAULT_RES_DIR);
 	}
 
 	private void setOutDirs(String outDir, String srcDir, String resDir) {

File: jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java
Patch:
@@ -5,8 +5,8 @@
 import static jadx.core.deobf.NameMapper.isValidIdentifier;
 import static jadx.core.deobf.NameMapper.removeInvalidChars;
 import static jadx.core.deobf.NameMapper.removeInvalidCharsMiddle;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class NameMapperTest {
 

File: jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java
Patch:
@@ -5,9 +5,9 @@
 
 import jadx.core.dex.info.AccessInfo.AFType;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 import static org.junit.jupiter.api.Assertions.assertSame;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class AccessInfoTest {
 

File: jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java
Patch:
@@ -22,7 +22,7 @@ public ClassFileManager(StandardJavaFileManager standardManager) {
 
 	@Override
 	public JavaFileObject getJavaFileForOutput(Location location, String className,
-			Kind kind, FileObject sibling) throws IOException {
+	                                           Kind kind, FileObject sibling) throws IOException {
 		JavaClassObject clsObject = new JavaClassObject(className, kind);
 		classLoader.getClsMap().put(className, clsObject);
 		return clsObject;

File: jadx-core/src/test/java/jadx/tests/api/compiler/StaticCompiler.java
Patch:
@@ -55,7 +55,7 @@ protected StaticFileManager(StandardJavaFileManager fileManager, File outDir) {
 
 		@Override
 		public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,
-				FileObject sibling) throws IOException {
+		                                           FileObject sibling) throws IOException {
 			if (kind == JavaFileObject.Kind.CLASS) {
 				File file = new File(outDir, className.replace('.', '/') + ".class");
 				files.add(file);

File: jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java
Patch:
@@ -32,7 +32,7 @@ public void testStringUnescape() {
 	}
 
 	private void checkStringUnescape(String input, String result) {
-		assertThat(stringUtils.unescapeString(input), is("\"" + result + "\""));
+		assertThat(stringUtils.unescapeString(input), is('"' + result + '"'));
 	}
 
 	@Test
@@ -47,6 +47,6 @@ public void testCharUnescape() {
 	}
 
 	private void checkCharUnescape(char input, String result) {
-		assertThat(stringUtils.unescapeChar(input), is("'" + result + "'"));
+		assertThat(stringUtils.unescapeChar(input), is('\'' + result + '\''));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java
Patch:
@@ -4,8 +4,8 @@
 
 import jadx.core.export.TemplateFile;
 
-import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
 
 public class TemplateFileTest {
 

File: jadx-core/src/test/java/jadx/tests/functional/TestIfCondition.java
Patch:
@@ -19,8 +19,8 @@
 import static jadx.core.dex.regions.conditions.IfCondition.merge;
 import static jadx.core.dex.regions.conditions.IfCondition.not;
 import static jadx.core.dex.regions.conditions.IfCondition.simplify;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class TestIfCondition {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestDuplicateCast.java
Patch:
@@ -12,10 +12,10 @@
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.is;
 import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 /**

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArithNot.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.SmaliTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.hamcrest.Matchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.not;
 
 public class TestArithNot extends SmaliTest {
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions11.java
Patch:
@@ -33,6 +33,5 @@ public void test() {
 		assertThat(code, containsOne("f();"));
 		assertThat(code, not(containsString("return")));
 		assertThat(code, not(containsString("else")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions12.java
Patch:
@@ -65,6 +65,5 @@ public void test() {
 		assertThat(code, containsOne("if (quality >= 30 && autoStop) {"));
 		assertThat(code, containsOne("if (!autoStop && lastValidRaw > -1 && quality < 10) {"));
 		assertThat(code, not(containsString("return")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions13.java
Patch:
@@ -37,6 +37,5 @@ public void test() {
 		assertThat(code, containsOne("qualityReading = false;"));
 		assertThat(code, containsOne("} else if (raw == 0 || quality < 6 || !qualityReading) {"));
 		assertThat(code, not(containsString("return")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java
Patch:
@@ -30,6 +30,5 @@ public void test() {
 		assertThat(code, containsOne("boolean r = a == null ? b != null : !a.equals(b);"));
 		assertThat(code, containsOne("if (r) {"));
 		assertThat(code, containsOne("System.out.println(\"1\");"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions15.java
Patch:
@@ -64,6 +64,5 @@ public void test() {
 
 		assertThat(code, containsOne("\"1\".equals(name)"));
 		assertThat(code, containsOne("\"30\".equals(name)"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions16.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestConditions16 extends IntegrationTest {
@@ -32,6 +32,5 @@ public void test() {
 
 //		assertThat(code, containsOne("return a < 0 || (b % 2 != 0 && a > 28) || b < 0;"));
 		assertThat(code, containsOne("return a < 0 || ((b % 2 != 0 && a > 28) || b < 0);"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions5.java
Patch:
@@ -12,7 +12,7 @@
 public class TestConditions5 extends IntegrationTest {
 
 	public static class TestCls {
-		public static void assertEquals(Object a1, Object a2) {
+		public static void test(Object a1, Object a2) {
 			if (a1 == null) {
 				if (a2 != null) {
 					throw new AssertionError(a1 + " != " + a2);
@@ -22,7 +22,7 @@ public static void assertEquals(Object a1, Object a2) {
 			}
 		}
 
-		public static void assertEquals2(Object a1, Object a2) {
+		public static void test2(Object a1, Object a2) {
 			if (a1 != null) {
 				if (!a1.equals(a2)) {
 					throw new AssertionError(a1 + " != " + a2);

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestNestedIf.java
Patch:
@@ -42,6 +42,5 @@ public void test() {
 		assertThat(code, countString(2, "return false;"));
 		assertThat(code, containsOne("test1();"));
 		assertThat(code, containsOne("return true;"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary.java
Patch:
@@ -22,7 +22,7 @@ public void test2(int a) {
 		}
 
 		public int test3(int a) {
-			return a > 0 ? 1 : (a + 2) * 3;
+			return a > 0 ? a : (a + 2) * 3;
 		}
 	}
 
@@ -34,6 +34,6 @@ public void test() {
 		assertThat(code, not(containsString("else")));
 		assertThat(code, containsString("return a != 2;"));
 		assertThat(code, containsString("assertTrue(a == 3)"));
-		assertThat(code, containsString("return a > 0 ? 1 : (a + 2) * 3;"));
+		assertThat(code, containsString("return a > 0 ? a : (a + 2) * 3;"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers.java
Patch:
@@ -10,8 +10,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestLineNumbers extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums.java
Patch:
@@ -46,10 +46,10 @@ public void test() {
 		assertThat(code, containsLines(1, "public enum EmptyEnum {", "}"));
 		assertThat(code, containsLines(1,
 				"public enum EmptyEnum2 {",
-				indent(1) + ";",
+				indent(1) + ';',
 				"",
 				indent(1) + "public static void mth() {",
-				indent(1) + "}",
+				indent(1) + '}',
 				"}"));
 
 		assertThat(code, containsLines(1, "public enum Direction {",
@@ -64,7 +64,7 @@ public void test() {
 				"",
 				indent(1) + "public String test() {",
 				indent(2) + "return \"\";",
-				indent(1) + "}",
+				indent(1) + '}',
 				"}"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java
Patch:
@@ -38,12 +38,12 @@ public void test() {
 				indent(1) + "PLUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x + y;",
-				indent(2) + "}",
+				indent(2) + '}',
 				indent(1) + "},",
 				indent(1) + "MINUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x - y;",
-				indent(2) + "}",
+				indent(2) + '}',
 				indent(1) + "};",
 				"",
 				indent(1) + "public abstract int apply(int i, int i2);",

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java
Patch:
@@ -40,13 +40,13 @@ public void test() {
 				indent(1) + "PLUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x + y;",
-				indent(2) + "}",
+				indent(2) + '}',
 				indent(1) + "},",
 				indent(1) + "MINUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x - y;",
-				indent(2) + "}",
-				indent(1) + "}",
+				indent(2) + '}',
+				indent(1) + '}',
 				"}"
 		));
 	}

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestSwitchOverEnum.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchOverEnum extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestSwitchOverEnum2.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchOverEnum2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/MissingGenericsTypesTest.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.generics;
 
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.containsString;
-
 import org.junit.jupiter.api.Test;
 
 import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+
 public class MissingGenericsTypesTest extends SmaliTest {
 
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics6.java
Patch:
@@ -25,7 +25,7 @@ public void test2(Collection<? extends A> is) {
 			}
 		}
 
-		private interface  I {
+		private interface I {
 			void f();
 		}
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass10.java
Patch:
@@ -8,9 +8,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass10 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass11.java
Patch:
@@ -8,9 +8,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass11 extends IntegrationTest {
 
@@ -36,7 +36,6 @@ public A(long l) {
 			}
 
 			public abstract void m();
-
 		}
 
 		private void func(A a) {

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass4.java
Patch:
@@ -37,9 +37,9 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne(indent(3) + "new Thread() {"));
-		assertThat(code, containsOne(indent(4) + "{"));
+		assertThat(code, containsOne(indent(4) + '{'));
 		assertThat(code, containsOne("f = 1;"));
-		assertThat(code, countString(2, indent(4) + "}"));
+		assertThat(code, countString(2, indent(4) + '}'));
 		assertThat(code, containsOne(indent(4) + "public void run() {"));
 		assertThat(code, containsOne("d = 7.5"));
 		assertThat(code, containsOne(indent(3) + "}.start();"));

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass5.java
Patch:
@@ -10,11 +10,11 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 import static org.hamcrest.Matchers.sameInstance;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass5 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass6.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass6 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass7.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass7 extends IntegrationTest {
 
@@ -20,7 +20,6 @@ public void run() {
 				}
 			};
 		}
-
 	}
 
 	@Test

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass8.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass8 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass9.java
Patch:
@@ -9,9 +9,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass9 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInner2Samples extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticRename.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 /**
  * Issue: https://github.com/skylot/jadx/issues/336

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestOuterConstructorCall.java
Patch:
@@ -5,9 +5,9 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestOuterConstructorCall extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore.java
Patch:
@@ -9,9 +9,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestRFieldRestore extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestSyntheticMthRename.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 /**
  * Issue: https://github.com/skylot/jadx/issues/397

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java
Patch:
@@ -5,8 +5,8 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
 
 public class TestConstructorInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedMethodInvoke.java
Patch:
@@ -8,8 +8,8 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestOverloadedMethodInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvoke.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSuperInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInComplexIf.java
Patch:
@@ -9,8 +9,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class TestBreakInComplexIf extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInComplexIf2.java
Patch:
@@ -9,8 +9,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class TestBreakInComplexIf2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakWithLabel.java
Patch:
@@ -8,8 +8,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestBreakWithLabel extends IntegrationTest {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java
Patch:
@@ -5,8 +5,8 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
 
 public class TestEndlessLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java
Patch:
@@ -7,8 +7,8 @@
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.hamcrest.Matchers.anyOf;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.anyOf;
 
 public class TestLoopCondition5 extends SmaliTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops3.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestNestedLoops3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.loops;
 
-import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.hamcrest.MatcherAssert.assertThat;
-
 import org.junit.jupiter.api.Test;
 
 import jadx.NotYetImplemented;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
+import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
+
 public class TestSynchronizedInEndlessLoop extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestTryCatchInLoop.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestTryCatchInLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/names/TestNameAssign2.java
Patch:
@@ -13,8 +13,9 @@
 import jadx.core.dex.visitors.ssa.LiveVarAnalysis;
 import jadx.tests.api.IntegrationTest;
 
-import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.not;
 
 public class TestNameAssign2 extends IntegrationTest {
 
@@ -58,7 +59,6 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		// TODO:
-		assertThat(code, containsOne("int id;"));
+		assertThat(code, not(containsString("int id;")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.tests.integration.names;
 
+import java.io.File;
+
 import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
-
-import java.io.File;
 
 public class TestReservedClassNames extends SmaliTest {
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/names/TestReservedNames.java
Patch:
@@ -5,9 +5,9 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestReservedNames extends SmaliTest {
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/others/TestBadMethodAccessModifiers.java
Patch:
@@ -6,9 +6,9 @@
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestBadMethodAccessModifiers extends SmaliTest {
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit.java
Patch:
@@ -10,9 +10,9 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestFieldInit extends IntegrationTest {
 
@@ -24,7 +24,7 @@ public class A {
 		private static List<String> s = new ArrayList<>();
 
 		private A a = new A();
-		private int i =  1 + Random.class.getSimpleName().length();
+		private int i = 1 + Random.class.getSimpleName().length();
 		private int n = 0;
 
 		public TestCls(int z) {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitch extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class TestSwitch3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java
Patch:
@@ -7,8 +7,8 @@
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchContinue extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchInLoop extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchLabels.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.hamcrest.Matchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.not;
 
 public class TestSwitchLabels extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase2.java
Patch:
@@ -1,12 +1,13 @@
 package jadx.tests.integration.switches;
 
+import org.junit.jupiter.api.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
-import org.junit.jupiter.api.Test;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestSwitchReturnFromCase2 extends IntegrationTest {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchSimple.java
Patch:
@@ -7,8 +7,8 @@
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchSimple extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchWithFallThroughCase extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase2.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchWithFallThroughCase2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java
Patch:
@@ -19,6 +19,9 @@ public int test() {
 			File output = null;
 			try {
 				output = File.createTempFile("f", "a", dir);
+				if (!output.exists()) {
+					return 1;
+				}
 				return 0;
 			} catch (Exception e) {
 				if (output != null) {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally7.java
Patch:
@@ -7,11 +7,11 @@
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-public class TestTryCatch3 extends IntegrationTest {
+public class TestTryCatchFinally7 extends IntegrationTest {
 
 	public static class TestCls {
 		private int f = 0;
@@ -63,7 +63,7 @@ public void test() {
 	}
 
 	@Test
-	public void test2() {
+	public void testNoDebug() {
 		noDebugInfo();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java
Patch:
@@ -13,7 +13,7 @@
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-public class TestTryCatch5 extends IntegrationTest {
+public class TestTryCatchFinally8 extends IntegrationTest {
 
 	public static class TestCls {
 		private Object test(Object obj) {
@@ -43,8 +43,8 @@ private Object test(Object obj) {
 	}
 
 	@Test
+	@NotYetImplemented("Fix merged catch blocks (shared code between catches)")
 	public void test() {
-		disableCompilation();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchInIf.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestTryCatchInIf extends IntegrationTest {
 
@@ -23,7 +23,7 @@ private String test(String name, String value) {
 					} else {
 						key = Integer.parseInt(value);
 					}
-					return name + "=" + key;
+					return name + '=' + key;
 				} catch (NumberFormatException e) {
 					return "Failed to parse number";
 				}

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMoveExc.java
Patch:
@@ -8,7 +8,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-public class TestTryCatchNoMove extends SmaliTest {
+public class TestTryCatchNoMoveExc extends SmaliTest {
 
 //	private static void test(AutoCloseable closeable) {
 //		if (closeable != null) {
@@ -21,7 +21,7 @@ public class TestTryCatchNoMove extends SmaliTest {
 
 	@Test
 	public void test() {
-		ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMove");
+		ClassNode cls = getClassNodeFromSmaliWithPkg("trycatch", "TestTryCatchNoMoveExc");
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("if (autoCloseable != null) {"));

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMoveExc2.java
Patch:
@@ -26,7 +26,7 @@ public class TestTryCatchNoMoveExc2 extends SmaliTest {
 
 	@Test
 	public void test() {
-		ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMoveExc2");
+		ClassNode cls = getClassNodeFromSmaliWithPkg("trycatch", "TestTryCatchNoMoveExc2");
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("try {"));

File: jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java
Patch:
@@ -8,8 +8,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class TestTypeResolver4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables4.java
Patch:
@@ -37,7 +37,7 @@ private static boolean runTest(String clsName) {
 					msg = "not extends AbstractTest";
 				}
 				System.err.println(">> "
-						+ (pass ? "PASS" : "FAIL") + "\t"
+						+ (pass ? "PASS" : "FAIL") + '\t'
 						+ clsName
 						+ (msg == null ? "" : "\t - " + msg));
 				if (exc != null) {

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDefinitions.java
Patch:
@@ -22,7 +22,7 @@ public static class TestCls {
 		private ClassNode cls;
 		private List<IDexTreeVisitor> passes;
 
-		public void run() {
+		public void test() {
 			try {
 				cls.load();
 				for (IDexTreeVisitor pass : this.passes) {
@@ -41,5 +41,6 @@ public void test() {
 
 		assertThat(code, containsOne(indent(3) + "for (IDexTreeVisitor pass : this.passes) {"));
 		assertThat(code, not(containsString("iterator;")));
+		assertThat(code, not(containsString("Iterator")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesIfElseChain.java
Patch:
@@ -6,8 +6,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.hamcrest.Matchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
 
 public class TestVariablesIfElseChain extends IntegrationTest {
 

File: jadx-samples/src/main/java/jadx/samples/RunTests.java
Patch:
@@ -65,7 +65,7 @@ private static boolean runTest(String clsName) {
 				msg = "not extends AbstractTest";
 			}
 			System.err.println(">> "
-					+ (pass ? "PASS" : "FAIL") + "\t"
+					+ (pass ? "PASS" : "FAIL") + '\t'
 					+ clsName
 					+ (msg == null ? "" : "\t - " + msg));
 			if (exc != null) {

File: jadx-samples/src/main/java/jadx/samples/TestStringProcessing.java
Patch:
@@ -12,7 +12,7 @@ public void testStringEscape() {
 
 	public void testStringConcat() {
 		String s = "1";
-		assertEquals("a" + s, "a1");
+		assertEquals('a' + s, "a1");
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -57,7 +57,8 @@ public ArgType getType() {
 		if (sVar != null) {
 			return sVar.getTypeInfo().getType();
 		}
-		throw new JadxRuntimeException("Register type unknown, SSA variable not initialized: r" + regNum);
+		LOG.warn("Register type unknown, SSA variable not initialized: r{}", regNum);
+		return type;
 	}
 
 	public ArgType getInitType() {

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -277,7 +277,8 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro
 				break;
 
 			case NOT:
-				oneArgInsn(code, insn, state, '~');
+				char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';
+				oneArgInsn(code, insn, state, op);
 				break;
 
 			case RETURN:

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -195,7 +195,7 @@ private static void processInvoke(MethodNode mth, BlockNode block, int insnNumbe
 		if (co.isSuper() && (co.getArgsCount() == 0 || parentClass.isEnum())) {
 			remove = true;
 		} else if (co.isThis() && co.getArgsCount() == 0) {
-			MethodNode defCo = parentClass.searchMethodByName(callMth.getShortId());
+			MethodNode defCo = parentClass.searchMethodByShortId(callMth.getShortId());
 			if (defCo == null || defCo.isNoCode()) {
 				// default constructor not implemented
 				remove = true;
@@ -347,7 +347,7 @@ private static ConstructorInsn processConstructor(MethodNode mth, ConstructorIns
 		}
 		boolean passThis = co.getArgsCount() >= 1 && co.getArg(0).isThis();
 		String ctrId = "<init>(" + (passThis ? TypeGen.signature(co.getArg(0).getType()) : "") + ")V";
-		MethodNode defCtr = classNode.searchMethodByName(ctrId);
+		MethodNode defCtr = classNode.searchMethodByShortId(ctrId);
 		if (defCtr == null) {
 			return null;
 		}

File: jadx-core/src/test/java/jadx/tests/integration/deobf/TestMthRename.java
Patch:
@@ -30,10 +30,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsString("public abstract void mo1a();"));
 		assertThat(code, not(containsString("public abstract void a();")));
-
-		assertThat(code, containsString(".mo1a();"));
 		assertThat(code, not(containsString(".a();")));
 	}
 }

File: jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java
Patch:
@@ -90,7 +90,7 @@ private void addDefaultValue(JadxCLIArgs args, Field f, StringBuilder opt) {
 		if (fieldType == int.class) {
 			try {
 				int val = f.getInt(args);
-				opt.append(" (default: ").append(val).append(")");
+				opt.append(" (default: ").append(val).append(')');
 			} catch (Exception e) {
 				// ignore
 			}

File: jadx-core/src/main/java/jadx/api/CodePosition.java
Patch:
@@ -57,6 +57,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return line + ":" + offset + (node != null ? " " + node : "");
+		return line + ':' + offset + (node != null ? " " + node : "");
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -499,12 +499,12 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro
 
 			case PHI:
 				fallbackOnlyInsn(insn);
-				code.add(insn.getType().toString()).add("(");
+				code.add(insn.getType().toString()).add('(');
 				for (InsnArg insnArg : insn.getArguments()) {
 					addArg(code, insnArg);
 					code.add(' ');
 				}
-				code.add(")");
+				code.add(')');
 				break;
 
 			default:

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -184,9 +184,9 @@ public void addInstructions(CodeWriter code) throws CodegenException {
 
 			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: ")
 					.add(clsAlias.makeFullClsName(clsAlias.getShortName(), true))
-					.add(".")
+					.add('.')
 					.add(mth.getAlias())
-					.add("(")
+					.add('(')
 					.add(Utils.listToString(mth.getMethodInfo().getArgumentsTypes()))
 					.add("):")
 					.add(mth.getMethodInfo().getReturnType().toString())

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -129,7 +129,7 @@ public static String formatLong(long l) {
 		}
 		String str = Long.toString(l);
 		if (Math.abs(l) >= Integer.MAX_VALUE) {
-			str += "L";
+			str += 'L';
 		}
 		return str;
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java
Patch:
@@ -169,7 +169,7 @@ private ArgType consumeObjectType(boolean incompleteType) {
 			// generic type start ('<')
 			String obj = slice();
 			if (!incompleteType) {
-				obj += ";";
+				obj += ';';
 			}
 			ArgType[] genArr = consumeGenericArgs();
 			consume('>');
@@ -211,7 +211,7 @@ private ArgType[] consumeGenericArgs() {
 				list.add(type);
 			}
 		} while (type != null && !lookAhead('>'));
-		return list.toArray(new ArgType[list.size()]);
+		return list.toArray(new ArgType[0]);
 	}
 
 	/**

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -67,7 +67,7 @@ public static void makeDirs(@Nullable File dir) {
 	public static File createTempFile(String suffix) {
 		File temp;
 		try {
-			temp = File.createTempFile("jadx-tmp-", System.nanoTime() + "-" + suffix);
+			temp = File.createTempFile("jadx-tmp-", System.nanoTime() + '-' + suffix);
 			temp.deleteOnExit();
 		} catch (IOException e) {
 			throw new JadxRuntimeException("Failed to create temp file with suffix: " + suffix);

File: jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java
Patch:
@@ -49,7 +49,7 @@ public String getName() {
 	}
 
 	public String getFileName() {
-		return name.replace("/", File.separator);
+		return name.replace('/', File.separatorChar);
 	}
 
 	public List<ResContainer> getSubFiles() {

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -182,9 +182,9 @@ private void addSimpleValue(CodeWriter cw, String typeName, String itemTag, Stri
 		cw.add('<').add(itemTag);
 		if (attrName != null && attrValue != null) {
 			if (typeName.equals("attr")) {
-				cw.add(' ').add("name=\"").add(attrName.replace("id.", "")).add("\" value=\"").add(attrValue).add("\"");
+				cw.add(' ').add("name=\"").add(attrName.replace("id.", "")).add("\" value=\"").add(attrValue).add('"');
 			} else if (typeName.equals("style")) {
-				cw.add(' ').add("name=\"").add(attrName.replace("attr.", "")).add("\"");
+				cw.add(' ').add("name=\"").add(attrName.replace("attr.", "")).add('"');
 			} else {
 				cw.add(' ').add(attrName).add("=\"").add(attrValue).add('"');
 			}

File: jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java
Patch:
@@ -44,8 +44,8 @@ public void checkNone() {
 		setOutDirs(null, null, null);
 		String inputFileBase = args.getInputFiles().get(0).getName().replace(".apk", "");
 		checkOutDirs(inputFileBase,
-				inputFileBase + "/" + JadxArgs.DEFAULT_SRC_DIR,
-				inputFileBase + "/" + JadxArgs.DEFAULT_RES_DIR);
+				inputFileBase + '/' + JadxArgs.DEFAULT_SRC_DIR,
+				inputFileBase + '/' + JadxArgs.DEFAULT_RES_DIR);
 	}
 
 	private void setOutDirs(String outDir, String srcDir, String resDir) {

File: jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java
Patch:
@@ -122,7 +122,7 @@ private void firstIsNarrow(ArgType first, ArgType second) {
 
 	private void check(ArgType first, ArgType second, TypeCompareEnum expectedResult) {
 		TypeCompareEnum result = compare.compareTypes(first, second);
-		assertThat("Compare '" + first + "' vs '" + second + "'",
+		assertThat("Compare '" + first + "' vs '" + second + '\'',
 				result, is(expectedResult));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -317,7 +317,7 @@ public File getJarForClass(Class<?> cls) throws IOException {
 		File temp = createTempFile(".jar");
 		try (JarOutputStream jo = new JarOutputStream(new FileOutputStream(temp))) {
 			for (File file : list) {
-				addFileToJar(jo, file, path + "/" + file.getName());
+				addFileToJar(jo, file, path + '/' + file.getName());
 			}
 		}
 		return temp;
@@ -340,7 +340,7 @@ protected File createTempFile(String suffix) {
 
 	private static File createTempDir(String prefix) throws IOException {
 		File baseDir = new File(System.getProperty("java.io.tmpdir"));
-		String baseName = prefix + "-" + System.nanoTime();
+		String baseName = prefix + '-' + System.nanoTime();
 		for (int counter = 1; counter < 1000; counter++) {
 			File tempDir = new File(baseDir, baseName + counter);
 			if (tempDir.mkdir()) {
@@ -360,7 +360,7 @@ private List<File> getClassFilesWithInners(Class<?> cls) {
 				File directory = new File(pkgResource.toURI());
 				String[] files = directory.list();
 				for (String file : files) {
-					String fullName = pkgName + "." + file;
+					String fullName = pkgName + '.' + file;
 					if (fullName.startsWith(clsName)) {
 						list.add(new File(directory, file));
 					}

File: jadx-core/src/test/java/jadx/tests/api/SmaliTest.java
Patch:
@@ -44,7 +44,7 @@ protected ClassNode getClassNodeFromSmaliWithPkg(String pkg, String clsName) {
 	protected ClassNode getClassNodeFromSmaliFiles(String pkg, String testName, String clsName) {
 		File outDex = createTempFile(".dex");
 		compileSmali(outDex, collectSmaliFiles(pkg, testName));
-		return getClassNodeFromFile(outDex, pkg + "." + clsName);
+		return getClassNodeFromFile(outDex, pkg + '.' + clsName);
 	}
 
 	protected JadxDecompiler loadSmaliFile(String pkg, String smaliFileName) {

File: jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java
Patch:
@@ -32,7 +32,7 @@ public void testStringUnescape() {
 	}
 
 	private void checkStringUnescape(String input, String result) {
-		assertThat(stringUtils.unescapeString(input), is("\"" + result + "\""));
+		assertThat(stringUtils.unescapeString(input), is('"' + result + '"'));
 	}
 
 	@Test
@@ -47,6 +47,6 @@ public void testCharUnescape() {
 	}
 
 	private void checkCharUnescape(char input, String result) {
-		assertThat(stringUtils.unescapeChar(input), is("'" + result + "'"));
+		assertThat(stringUtils.unescapeChar(input), is('\'' + result + '\''));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/TestStringBuilderElimination2.java
Patch:
@@ -18,7 +18,7 @@ public class TestStringBuilderElimination2 extends IntegrationTest {
 
 	public static class TestCls1 {
 		public String test() {
-			return new StringBuilder("[init]").append("a1").append('c').append(2).append(0l).append(1.0f).
+			return new StringBuilder("[init]").append("a1").append('c').append(2).append(0L).append(1.0f).
 					append(2.0d).append(true).toString();
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums.java
Patch:
@@ -46,10 +46,10 @@ public void test() {
 		assertThat(code, containsLines(1, "public enum EmptyEnum {", "}"));
 		assertThat(code, containsLines(1,
 				"public enum EmptyEnum2 {",
-				indent(1) + ";",
+				indent(1) + ';',
 				"",
 				indent(1) + "public static void mth() {",
-				indent(1) + "}",
+				indent(1) + '}',
 				"}"));
 
 		assertThat(code, containsLines(1, "public enum Direction {",
@@ -64,7 +64,7 @@ public void test() {
 				"",
 				indent(1) + "public String test() {",
 				indent(2) + "return \"\";",
-				indent(1) + "}",
+				indent(1) + '}',
 				"}"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java
Patch:
@@ -38,12 +38,12 @@ public void test() {
 				indent(1) + "PLUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x + y;",
-				indent(2) + "}",
+				indent(2) + '}',
 				indent(1) + "},",
 				indent(1) + "MINUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x - y;",
-				indent(2) + "}",
+				indent(2) + '}',
 				indent(1) + "};",
 				"",
 				indent(1) + "public abstract int apply(int i, int i2);",

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java
Patch:
@@ -40,13 +40,13 @@ public void test() {
 				indent(1) + "PLUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x + y;",
-				indent(2) + "}",
+				indent(2) + '}',
 				indent(1) + "},",
 				indent(1) + "MINUS {",
 				indent(2) + "public int apply(int x, int y) {",
 				indent(3) + "return x - y;",
-				indent(2) + "}",
-				indent(1) + "}",
+				indent(2) + '}',
+				indent(1) + '}',
 				"}"
 		));
 	}

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass4.java
Patch:
@@ -37,9 +37,9 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne(indent(3) + "new Thread() {"));
-		assertThat(code, containsOne(indent(4) + "{"));
+		assertThat(code, containsOne(indent(4) + '{'));
 		assertThat(code, containsOne("f = 1;"));
-		assertThat(code, countString(2, indent(4) + "}"));
+		assertThat(code, countString(2, indent(4) + '}'));
 		assertThat(code, containsOne(indent(4) + "public void run() {"));
 		assertThat(code, containsOne("d = 7.5"));
 		assertThat(code, containsOne(indent(3) + "}.start();"));

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach2.java
Patch:
@@ -35,7 +35,7 @@ public void test() {
 				indent(1) + "String t = s.trim();",
 				indent(1) + "if (t.length() > 0) {",
 				indent(2) + "System.out.println(t);",
-				indent(1) + "}",
+				indent(1) + '}',
 				"}"
 		));
 	}

File: jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized.java
Patch:
@@ -38,7 +38,7 @@ public void test() {
 		assertThat(code, containsOne("return this.f"));
 		assertThat(code, containsOne("synchronized (this.o) {"));
 
-		assertThat(code, not(containsString(indent(3) + ";")));
+		assertThat(code, not(containsString(indent(3) + ';')));
 		assertThat(code, not(containsString("try {")));
 		assertThat(code, not(containsString("} catch (Throwable th) {")));
 		assertThat(code, not(containsString("throw th;")));

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch7.java
Patch:
@@ -43,8 +43,8 @@ public void testNoDebug() {
 	private void check(String code, String excVarName, String catchExcVarName) {
 		assertThat(code, containsOne("Exception " + excVarName + " = new Exception();"));
 		assertThat(code, containsOne("} catch (Exception " + catchExcVarName + ") {"));
-		assertThat(code, containsOne(excVarName + " = " + catchExcVarName + ";"));
+		assertThat(code, containsOne(excVarName + " = " + catchExcVarName + ';'));
 		assertThat(code, containsOne(excVarName + ".printStackTrace();"));
-		assertThat(code, containsOne("return " + excVarName + ";"));
+		assertThat(code, containsOne("return " + excVarName + ';'));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally6.java
Patch:
@@ -44,7 +44,7 @@ public void test() {
 				"} finally {",
 				indent(1) + "if (is != null) {",
 				indent(2) + "is.close();",
-				indent(1) + "}",
+				indent(1) + '}',
 				"}"
 		));
 	}
@@ -63,7 +63,7 @@ public void testNoDebug() {
 				"} finally {",
 				indent() + "if (fileInputStream != null) {",
 				indent() + indent() + "fileInputStream.close();",
-				indent() + "}",
+				indent() + '}',
 				"}"
 		));
 	}

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchInIf.java
Patch:
@@ -23,7 +23,7 @@ private String test(String name, String value) {
 					} else {
 						key = Integer.parseInt(value);
 					}
-					return name + "=" + key;
+					return name + '=' + key;
 				} catch (NumberFormatException e) {
 					return "Failed to parse number";
 				}

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables4.java
Patch:
@@ -37,7 +37,7 @@ private static boolean runTest(String clsName) {
 					msg = "not extends AbstractTest";
 				}
 				System.err.println(">> "
-						+ (pass ? "PASS" : "FAIL") + "\t"
+						+ (pass ? "PASS" : "FAIL") + '\t'
 						+ clsName
 						+ (msg == null ? "" : "\t - " + msg));
 				if (exc != null) {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -211,7 +211,7 @@ public void mouseClicked(MouseEvent e) {
 	private String getFontLabelStr() {
 		Font font = settings.getFont();
 		String fontStyleName = Utils.getFontStyleName(font.getStyle());
-		return NLS.str("preferences.font") + ": " + font.getFontName() + " " + fontStyleName + " " + font.getSize();
+		return NLS.str("preferences.font") + ": " + font.getFontName() + ' ' + fontStyleName + ' ' + font.getSize();
 	}
 
 	private SettingsGroup makeDecompilationGroup() {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java
Patch:
@@ -94,7 +94,7 @@ public String makeString() {
 
 	@Override
 	public String makeLongString() {
-		String name = mth.getDeclaringClass().getFullName() + "." + makeBaseString();
+		String name = mth.getDeclaringClass().getFullName() + '.' + makeBaseString();
 		return Utils.typeFormat(name, getReturnType());
 	}
 

File: jadx-gui/src/main/java/jadx/gui/treemodel/JSources.java
Patch:
@@ -66,7 +66,7 @@ List<JPackage> getHierarchyPackages(List<JavaPackage> packages) {
 					pkg.getInnerPackages().clear();
 					pkg.getInnerPackages().addAll(innerPkg.getInnerPackages());
 					pkg.getClasses().addAll(innerPkg.getClasses());
-					pkg.setName(pkg.getName() + "." + innerPkg.getName());
+					pkg.setName(pkg.getName() + '.' + innerPkg.getName());
 
 					innerPkg.getInnerPackages().clear();
 					innerPkg.getClasses().clear();

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java
Patch:
@@ -44,7 +44,7 @@ class SearchBar extends JToolBar {
 	public SearchBar(RSyntaxTextArea textArea) {
 		rTextArea = textArea;
 
-		JLabel findLabel = new JLabel(NLS.str("search.find") + ":");
+		JLabel findLabel = new JLabel(NLS.str("search.find") + ':');
 		add(findLabel);
 
 		searchField = new JTextField(30);

File: jadx-samples/src/main/java/jadx/samples/RunTests.java
Patch:
@@ -65,7 +65,7 @@ private static boolean runTest(String clsName) {
 				msg = "not extends AbstractTest";
 			}
 			System.err.println(">> "
-					+ (pass ? "PASS" : "FAIL") + "\t"
+					+ (pass ? "PASS" : "FAIL") + '\t'
 					+ clsName
 					+ (msg == null ? "" : "\t - " + msg));
 			if (exc != null) {

File: jadx-samples/src/main/java/jadx/samples/TestStringProcessing.java
Patch:
@@ -12,7 +12,7 @@ public void testStringEscape() {
 
 	public void testStringConcat() {
 		String s = "1";
-		assertEquals("a" + s, "a1");
+		assertEquals('a' + s, "a1");
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/api/JadxArgsValidator.java
Patch:
@@ -77,7 +77,7 @@ private static File makeDirFromInput(JadxArgs args) {
 		if (pos != -1) {
 			outDirName = name.substring(0, pos);
 		} else {
-			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;
+			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;
 		}
 		LOG.info("output directory: {}", outDirName);
 		outDir = new File(outDirName);

File: jadx-core/src/main/java/jadx/api/JavaField.java
Patch:
@@ -21,7 +21,7 @@ public String getName() {
 
 	@Override
 	public String getFullName() {
-		return parent.getFullName() + "." + getName();
+		return parent.getFullName() + '.' + getName();
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/api/ResourceFile.java
Patch:
@@ -70,6 +70,6 @@ public ZipRef getZipRef() {
 
 	@Override
 	public String toString() {
-		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";
+		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';
 	}
 }

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -119,7 +119,7 @@ void save(File output) throws IOException {
 			} else if (outputName.endsWith(".jar")) {
 				ZipOutputStream out = new ZipOutputStream(outputStream);
 				try {
-					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + "/" + CLST_FILENAME));
+					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + '/' + CLST_FILENAME));
 					save(out);
 				} finally {
 					close(out);

File: jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java
Patch:
@@ -151,7 +151,7 @@ public void encodeValue(CodeWriter code, Object val) {
 			InsnGen.makeStaticFieldAccess(code, field, classGen);
 		} else if (val instanceof Iterable) {
 			code.add('{');
-			Iterator<?> it = ((Iterable) val).iterator();
+			Iterator<?> it = ((Iterable<?>) val).iterator();
 			while (it.hasNext()) {
 				Object obj = it.next();
 				encodeValue(code, obj);
@@ -164,7 +164,7 @@ public void encodeValue(CodeWriter code, Object val) {
 			formatAnnotation(code, (Annotation) val);
 		} else {
 			// TODO: also can be method values
-			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ")");
+			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ')');
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -92,7 +92,7 @@ public boolean addDefinition(CodeWriter code) {
 			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");
 		}
 
-		if (classGen.addGenericMap(code, mth.getGenericMap())) {
+		if (classGen.addGenericMap(code, mth.getGenericMap(), false)) {
 			code.add(' ');
 		}
 		if (ai.isConstructor()) {
@@ -230,7 +230,7 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]
 			}
 			if (addLabels && needLabel(insn, prevInsn)) {
 				code.decIndent();
-				code.startLine(getLabelName(insn.getOffset()) + ":");
+				code.startLine(getLabelName(insn.getOffset()) + ':');
 				code.incIndent();
 			}
 			try {

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -126,7 +126,7 @@ private String makeArgName(CodeVar var) {
 		String name = var.getName();
 		String varName = name != null ? name : guessName(var);
 		if (NameMapper.isReserved(varName)) {
-			varName = varName + "R";
+			varName = varName + 'R';
 		}
 		if (!NameMapper.isValidIdentifier(varName)) {
 			varName = getFallbackName(var);

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -153,7 +153,7 @@ public static String formatDouble(double d) {
 		if (d == Double.MIN_NORMAL) {
 			return "Double.MIN_NORMAL";
 		}
-		return Double.toString(d) + "d";
+		return Double.toString(d) + 'd';
 	}
 
 	public static String formatFloat(float f) {
@@ -175,6 +175,6 @@ public static String formatFloat(float f) {
 		if (f == Float.MIN_NORMAL) {
 			return "Float.MIN_NORMAL";
 		}
-		return Float.toString(f) + "f";
+		return Float.toString(f) + 'f';
 	}
 }

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -126,7 +126,7 @@ public static boolean isAllCharsPrintable(String str) {
 	 * </ul><p>
 	 */
 	public static String removeInvalidCharsMiddle(String name) {
-		if (isValidIdentifier(name) && isAllCharsPrintable(name)) {
+		if (isValidIdentifier(name)) {
 			return name;
 		}
 		int len = name.length();

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -15,6 +15,7 @@ public enum AFlag {
 	DONT_WRAP,
 	DONT_INLINE,
 	DONT_GENERATE, // process as usual, but don't output to generated code
+	DONT_RENAME, // do not rename during deobfuscation
 	REMOVE, // can be completely removed
 	ADDED_TO_REGION,
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -61,7 +61,4 @@ public class AType<T extends IAttribute> {
 
 	// registers
 	public static final AType<RegDebugInfoAttr> REG_DEBUG_INFO = new AType<>();
-
-	private AType() {
-	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java
Patch:
@@ -121,6 +121,6 @@ public String toString() {
 		if (list.isEmpty()) {
 			return "";
 		}
-		return "A[" + Utils.listToString(list) + "]";
+		return "A[" + Utils.listToString(list) + ']';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java
Patch:
@@ -42,6 +42,6 @@ public Object getDefaultValue() {
 
 	@Override
 	public String toString() {
-		return "Annotation[" + visibility + ", " + atype + ", " + values + "]";
+		return "Annotation[" + visibility + ", " + atype + ", " + values + ']';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java
Patch:
@@ -12,7 +12,7 @@
 
 public class AnnotationsList implements IAttribute {
 
-	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());
+	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.emptyList());
 
 	private final Map<String, Annotation> map;
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EdgeInsnAttr.java
Patch:
@@ -43,6 +43,6 @@ public InsnNode getInsn() {
 
 	@Override
 	public String toString() {
-		return "EDGE_INSN: " + start + "->" + end + " " + insn;
+		return "EDGE_INSN: " + start + "->" + end + ' ' + insn;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/FieldReplaceAttr.java
Patch:
@@ -44,6 +44,6 @@ public AType<FieldReplaceAttr> getType() {
 
 	@Override
 	public String toString() {
-		return "REPLACE: " + replaceType + " " + replaceObj;
+		return "REPLACE: " + replaceType + ' ' + replaceObj;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java
Patch:
@@ -34,9 +34,9 @@ public String toString() {
 		}
 		if (cause != null) {
 			str.append(cause.getClass());
-			str.append(":");
+			str.append(':');
 			str.append(cause.getMessage());
-			str.append("\n");
+			str.append('\n');
 			str.append(Utils.getStackTrace(cause));
 		}
 		return str.toString();

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -25,10 +25,10 @@ public String toString() {
 		StringBuilder sb = new StringBuilder();
 		sb.append("PHI: ");
 		for (PhiInsn phiInsn : list) {
-			sb.append('r').append(phiInsn.getResult().getRegNum()).append(" ");
+			sb.append('r').append(phiInsn.getResult().getRegNum()).append(' ');
 		}
 		for (PhiInsn phiInsn : list) {
-			sb.append("\n  ").append(phiInsn).append(" ").append(phiInsn.getAttributesString());
+			sb.append("\n  ").append(phiInsn).append(' ').append(phiInsn.getAttributesString());
 		}
 		return sb.toString();
 	}

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RegDebugInfoAttr.java
Patch:
@@ -53,6 +53,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return "D('" + name + "' " + type + ")";
+		return "D('" + name + "' " + type + ')';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java
Patch:
@@ -203,6 +203,6 @@ public String rawString() {
 
 	@Override
 	public String toString() {
-		return "AccessInfo: " + type + " 0x" + Integer.toHexString(accFlags) + " (" + rawString() + ")";
+		return "AccessInfo: " + type + " 0x" + Integer.toHexString(accFlags) + " (" + rawString() + ')';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -91,7 +91,7 @@ private void splitNames(RootNode root, boolean canBeInner) {
 
 		int sep = clsName.lastIndexOf('$');
 		if (canBeInner && sep > 0 && sep != clsName.length() - 1) {
-			String parClsName = pkg + "." + clsName.substring(0, sep);
+			String parClsName = pkg + '.' + clsName.substring(0, sep);
 			if (pkg.isEmpty()) {
 				parClsName = clsName.substring(0, sep);
 			}
@@ -110,7 +110,7 @@ public String makeFullClsName(String shortName, boolean raw) {
 			String innerSep = raw ? "$" : ".";
 			return parentClass.makeFullClsName(parentClass.getShortName(), raw) + innerSep + shortName;
 		}
-		return pkg.isEmpty() ? shortName : pkg + "." + shortName;
+		return pkg.isEmpty() ? shortName : pkg + '.' + shortName;
 	}
 
 	public String makeRawFullName() {
@@ -148,7 +148,7 @@ public String getNameWithoutPackage() {
 		if (parentClass == null) {
 			return name;
 		}
-		return parentClass.getNameWithoutPackage() + "." + name;
+		return parentClass.getNameWithoutPackage() + '.' + name;
 	}
 
 	public ClassInfo getParentClass() {

File: jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java
Patch:
@@ -54,11 +54,11 @@ public void setAlias(String alias) {
 	}
 
 	public String getFullId() {
-		return declClass.getFullName() + "." + name + ":" + TypeGen.signature(type);
+		return declClass.getFullName() + '.' + name + ':' + TypeGen.signature(type);
 	}
 
 	public String getRawFullId() {
-		return declClass.makeRawFullName() + "." + name + ":" + TypeGen.signature(type);
+		return declClass.makeRawFullName() + '.' + name + ':' + TypeGen.signature(type);
 	}
 
 	public boolean isRenamed() {
@@ -93,6 +93,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return declClass + "." + name + " " + type;
+		return declClass + "." + name + ' ' + type;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java
Patch:
@@ -76,8 +76,8 @@ public String toString() {
 		return InsnUtils.formatOffset(offset) + ": "
 				+ InsnUtils.insnTypeToString(insnType)
 				+ getResult() + " = "
-				+ getArg(0) + " "
-				+ op.getSymbol() + " "
+				+ getArg(0) + ' '
+				+ op.getSymbol() + ' '
 				+ getArg(1);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java
Patch:
@@ -35,6 +35,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return super.toString() + " " + clsType;
+		return super.toString() + ' ' + clsType;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java
Patch:
@@ -34,6 +34,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return super.toString() + " \"" + str + "\"";
+		return super.toString() + " \"" + str + '"';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java
Patch:
@@ -127,7 +127,7 @@ public boolean isSame(InsnNode obj) {
 	public String toString() {
 		return InsnUtils.formatOffset(offset) + ": "
 				+ InsnUtils.insnTypeToString(insnType)
-				+ getArg(0) + " " + op.getSymbol() + " " + getArg(1)
+				+ getArg(0) + ' ' + op.getSymbol() + ' ' + getArg(1)
 				+ "  -> " + (thenBlock != null ? thenBlock : InsnUtils.formatOffset(target));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java
Patch:
@@ -47,7 +47,7 @@ public String toString() {
 						+ Utils.listToString(getArguments());
 
 			default:
-				return super.toString() + " " + InsnUtils.indexToString(index);
+				return super.toString() + ' ' + InsnUtils.indexToString(index);
 		}
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -579,7 +579,7 @@ private InsnNode decode(DecodedInstruction insn, int offset) throws DecodeExcept
 						InsnArg.reg(insn, 0, ArgType.UNKNOWN_OBJECT));
 
 			default:
-				throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");
+				throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + '\'');
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -73,7 +73,7 @@ public String toString() {
 				+ InsnUtils.insnTypeToString(insnType)
 				+ (getResult() == null ? "" : getResult() + " = ")
 				+ Utils.listToString(getArguments())
-				+ " " + mth
+				+ ' ' + mth
 				+ " type: " + type;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java
Patch:
@@ -94,6 +94,6 @@ public void mergeFlagsFrom(CodeVar other) {
 
 	@Override
 	public String toString() {
-		return (isFinal ? "final " : "") + type + " " + name;
+		return (isFinal ? "final " : "") + type + ' ' + name;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java
Patch:
@@ -81,6 +81,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return "(" + field + ")";
+		return "(" + field + ')';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java
Patch:
@@ -62,6 +62,6 @@ public boolean equals(Object o) {
 
 	@Override
 	public String toString() {
-		return "(wrap: " + type + "\n  " + wrappedInsn + ")";
+		return "(wrap: " + type + "\n  " + wrappedInsn + ')';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java
Patch:
@@ -74,10 +74,10 @@ public String toString() {
 			if (getType().equals(ArgType.BOOLEAN) && (value.equals("true") || value.equals("false"))) {
 				return value;
 			}
-			return "(" + value + " " + type + ")";
+			return '(' + value + ' ' + type + ')';
 		} catch (JadxRuntimeException ex) {
 			// can't convert literal to string
-			return "(" + literal + " " + type + ")";
+			return "(" + literal + ' ' + type + ')';
 		}
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/NamedArg.java
Patch:
@@ -44,6 +44,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return "(" + name + " " + type + ")";
+		return '(' + name + ' ' + type + ')';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -160,14 +160,14 @@ public int hashCode() {
 	}
 
 	public String toShortString() {
-		return "r" + regNum + "v" + version;
+		return "r" + regNum + 'v' + version;
 	}
 
 	@Override
 	public String toString() {
 		return toShortString()
 				+ (StringUtils.notEmpty(getName()) ? " '" + getName() + "' " : "")
-				+ " " + typeInfo.getType();
+				+ ' ' + typeInfo.getType();
 	}
 
 	public String getDetailedVarInfo(MethodNode mth) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -106,6 +106,6 @@ public boolean isSame(InsnNode obj) {
 
 	@Override
 	public String toString() {
-		return super.toString() + " " + callMth + " " + callType;
+		return super.toString() + ' ' + callMth + ' ' + callType;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java
Patch:
@@ -192,6 +192,6 @@ public String baseString() {
 
 	@Override
 	public String toString() {
-		return "B:" + id + ":" + InsnUtils.formatOffset(startOffset);
+		return "B:" + id + ':' + InsnUtils.formatOffset(startOffset);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -231,7 +231,7 @@ private void addSourceFilenameAttr(String fileName) {
 				return;
 			}
 			if (fileName.contains("$")
-					&& fileName.endsWith("$" + name)) {
+					&& fileName.endsWith('$' + name)) {
 				return;
 			}
 			ClassInfo parentClass = clsInfo.getTopParentClass();

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -685,7 +685,7 @@ public boolean equals(Object obj) {
 	@Override
 	public String toString() {
 		return parentClass + "." + mthInfo.getName()
-				+ "(" + Utils.listToString(mthInfo.getArgumentsTypes()) + "):"
+				+ '(' + Utils.listToString(mthInfo.getArgumentsTypes()) + "):"
 				+ retType;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/regions/Region.java
Patch:
@@ -53,6 +53,6 @@ public String baseString() {
 
 	@Override
 	public String toString() {
-		return "R" + baseString();
+		return 'R' + baseString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/Compare.java
Patch:
@@ -44,6 +44,6 @@ public void normalize() {
 
 	@Override
 	public String toString() {
-		return getA() + " " + getOp().getSymbol() + " " + getB();
+		return getA() + " " + getOp().getSymbol() + ' ' + getB();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java
Patch:
@@ -226,7 +226,7 @@ public String toString() {
 			case TERNARY:
 				return first() + " ? " + second() + " : " + third();
 			case NOT:
-				return "!(" + first() + ")";
+				return "!(" + first() + ')';
 			case AND:
 			case OR:
 				String op = mode == Mode.OR ? " || " : " && ";

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExcHandlerAttr.java
Patch:
@@ -30,6 +30,6 @@ public ExceptionHandler getHandler() {
 	public String toString() {
 		return "ExcHandler: " + (handler.isFinally()
 				? " FINALLY"
-				: handler.catchTypeStr() + " " + handler.getArg());
+				: handler.catchTypeStr() + ' ' + handler.getArg());
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/helpers/InsnsSlice.java
Patch:
@@ -65,8 +65,8 @@ public void setComplete(boolean complete) {
 	public String toString() {
 		return "{["
 				+ insnsList.stream().map(insn -> insn.getType().toString()).collect(Collectors.joining(", "))
-				+ "]"
+				+ ']'
 				+ (complete ? " complete" : "")
-				+ "}";
+				+ '}';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/LocalVar.java
Patch:
@@ -113,7 +113,7 @@ public int hashCode() {
 	@Override
 	public String toString() {
 		return InsnUtils.formatOffset(startAddr)
-				+ "-" + (isEnd ? InsnUtils.formatOffset(endAddr) : "     ")
+				+ '-' + (isEnd ? InsnUtils.formatOffset(endAddr) : "     ")
 				+ ": r" + regNum + " '" + name + "' " + type;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/VarUsage.java
Patch:
@@ -28,6 +28,6 @@ public List<UsePlace> getUses() {
 
 	@Override
 	public String toString() {
-		return "{" + (var == null ? "-" : var.toShortString()) + ", a:" + assigns + ", u:" + uses + "}";
+		return '{' + (var == null ? "-" : var.toShortString()) + ", a:" + assigns + ", u:" + uses + '}';
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java
Patch:
@@ -137,6 +137,6 @@ ArgsInfo getInlinedInsn() {
 	public String toString() {
 		return "ArgsInfo: |" + inlineBorder
 				+ " ->" + (inlinedInsn == null ? "-" : inlinedInsn.pos)
-				+ " " + args + " : " + insn;
+				+ ' ' + args + " : " + insn;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/AbstractTypeConstraint.java
Patch:
@@ -45,6 +45,6 @@ public List<SSAVar> getRelatedVars() {
 
 	@Override
 	public String toString() {
-		return "(" + insn.getType() + ":" + Utils.listToString(relatedVars, SSAVar::toShortString) + ")";
+		return "(" + insn.getType() + ':' + Utils.listToString(relatedVars, SSAVar::toShortString) + ')';
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -57,7 +57,7 @@ public static String indexToString(Object index) {
 			return "";
 		}
 		if (index instanceof String) {
-			return "\"" + index + "\"";
+			return "\"" + index + '"';
 		}
 		return index.toString();
 	}

File: jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java
Patch:
@@ -44,6 +44,7 @@ public void setBlock(BlockNode block) {
 	public void add(InsnNode insn) {
 		toRemove.add(insn);
 	}
+
 	public void addAndUnbind(MethodNode mth, InsnNode insn) {
 		toRemove.add(insn);
 		unbindInsn(mth, insn);

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -14,6 +14,7 @@
 import jadx.core.codegen.ClassGen;
 import jadx.core.codegen.CodeWriter;
 import jadx.core.deobf.NameMapper;
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.info.ClassInfo;
@@ -124,14 +125,15 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora
 			if (fieldNode != null
 					&& !fieldNode.getName().equals(resName)
 					&& NameMapper.isValidIdentifier(resName)) {
+				fieldNode.add(AFlag.DONT_RENAME);
 				fieldNode.getFieldInfo().setAlias(resName);
 			}
 		}
 	}
 
 	@NotNull
 	private static ClassNode addClassForResType(ClassNode resCls, boolean rClsExists, String typeName) {
-		ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + "$" + typeName,
+		ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + '$' + typeName,
 				AccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC | AccessFlags.ACC_FINAL);
 		resCls.addInnerClass(newTypeCls);
 		if (rClsExists) {

File: jadx-core/src/main/java/jadx/core/utils/files/DexFile.java
Patch:
@@ -27,6 +27,6 @@ public InputFile getInputFile() {
 
 	@Override
 	public String toString() {
-		return inputFile + (name.isEmpty() ? "" : ":" + name);
+		return inputFile + (name.isEmpty() ? "" : ':' + name);
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -77,7 +77,7 @@ public static File createTempFile(String suffix) {
 
 	public static File createTempDir(String suffix) {
 		try {
-			Path path = Files.createTempDirectory("jadx-tmp-" + System.nanoTime() + "-" + suffix);
+			Path path = Files.createTempDirectory("jadx-tmp-" + System.nanoTime() + '-' + suffix);
 			path.toFile().deleteOnExit();
 			return path.toFile();
 		} catch (IOException e) {

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -470,7 +470,7 @@ private String deobfClassName(String className) {
 	private boolean isDeobfCandidateAttr(String shortNsName, String attrName) {
 		String fullName;
 		if (shortNsName != null) {
-			fullName = shortNsName + ":" + attrName;
+			fullName = shortNsName + ':' + attrName;
 		} else {
 			return false;
 		}

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -43,7 +43,7 @@ public Map<Long, String> getValues() {
 
 		@Override
 		public String toString() {
-			return "[" + type + ", " + values + "]";
+			return "[" + type + ", " + values + ']';
 		}
 	}
 
@@ -173,7 +173,7 @@ public String decode(String attrName, long value) {
 			StringBuilder sb = new StringBuilder();
 			for (Map.Entry<Long, String> entry : attr.getValues().entrySet()) {
 				if (value == entry.getKey()) {
-					sb = new StringBuilder(entry.getValue() + "|");
+					sb = new StringBuilder(entry.getValue() + '|');
 					break;
 				} else if ((value & entry.getKey()) == entry.getKey()) {
 					sb.append(entry.getValue()).append('|');

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -138,6 +138,9 @@ protected ParserConstants() {
 	protected static final int FLAG_COMPLEX = 0x0001;
 	// If set, this resource has been declared public, so libraries are allowed to reference it.
 	protected static final int FLAG_PUBLIC = 0x0002;
+	// If set, this is a weak resource and may be overriden by strong resources of the same name/type.
+	// This is only useful during linking with other resource tables.
+	protected static final int FLAG_WEAK = 0x0004;
 
 	/**
 	 * ResTable_map

File: jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java
Patch:
@@ -96,6 +96,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return "Res{" + name + ", type=" + dataType + ", subFiles=" + subFiles + "}";
+		return "Res{" + name + ", type=" + dataType + ", subFiles=" + subFiles + '}';
 	}
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java
Patch:
@@ -47,7 +47,7 @@ public void setAppPackage(String appPackage) {
 	public Map<Integer, String> getResourcesNames() {
 		Map<Integer, String> map = new HashMap<>();
 		for (ResourceEntry entry : list) {
-			map.put(entry.getId(), entry.getTypeName() + "/" + entry.getKeyName());
+			map.put(entry.getId(), entry.getTypeName() + '/' + entry.getKeyName());
 		}
 		return map;
 	}

File: jadx-core/src/main/java/jadx/core/xmlgen/entry/ResourceEntry.java
Patch:
@@ -75,6 +75,6 @@ public EntryConfig getConfig() {
 
 	@Override
 	public String toString() {
-		return "  0x" + Integer.toHexString(id) + " (" + id + ")" + config + " = " + typeName + "." + keyName;
+		return "  0x" + Integer.toHexString(id) + " (" + id + ')' + config + " = " + typeName + '.' + keyName;
 	}
 }

File: jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.api;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import jadx.core.utils.files.FileUtils;
 
 import static jadx.core.utils.files.FileUtils.toFile;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class JadxArgsValidatorOutDirsTest {
 

File: jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.io.File;
 
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 
 public class JadxDecompilerTest {
 
 	@Test
-	@Ignore
+	@Disabled
 	public void testExampleUsage() {
 		JadxArgs args = new JadxArgs();
 		args.getInputFiles().add(new File("test.apk"));

File: jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.deobf;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static jadx.core.deobf.NameMapper.isValidIdentifier;
 import static jadx.core.deobf.NameMapper.removeInvalidChars;
 import static jadx.core.deobf.NameMapper.removeInvalidCharsMiddle;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class NameMapperTest {
 

File: jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.core.dex.info;
 
 import com.android.dx.rop.code.AccessFlags;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.info.AccessInfo.AFType;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 public class AccessInfoTest {
 

File: jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java
Patch:
@@ -22,7 +22,7 @@ public ClassFileManager(StandardJavaFileManager standardManager) {
 
 	@Override
 	public JavaFileObject getJavaFileForOutput(Location location, String className,
-			Kind kind, FileObject sibling) throws IOException {
+	                                           Kind kind, FileObject sibling) throws IOException {
 		JavaClassObject clsObject = new JavaClassObject(className, kind);
 		classLoader.getClsMap().put(className, clsObject);
 		return clsObject;

File: jadx-core/src/test/java/jadx/tests/api/compiler/StaticCompiler.java
Patch:
@@ -55,7 +55,7 @@ protected StaticFileManager(StandardJavaFileManager fileManager, File outDir) {
 
 		@Override
 		public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,
-				FileObject sibling) throws IOException {
+		                                           FileObject sibling) throws IOException {
 			if (kind == JavaFileObject.Kind.CLASS) {
 				File file = new File(outDir, className.replace('.', '/') + ".class");
 				files.add(file);

File: jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java
Patch:
@@ -24,9 +24,9 @@
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.greaterThan;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public abstract class BaseExternalTest extends IntegrationTest {
 	private static final Logger LOG = LoggerFactory.getLogger(BaseExternalTest.class);

File: jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -14,8 +14,8 @@
 import jadx.core.dex.visitors.IDexTreeVisitor;
 import jadx.core.dex.visitors.JadxVisitor;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.empty;
-import static org.junit.Assert.assertThat;
 
 public class JadxVisitorsOrderTest {
 

File: jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.tests.functional;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.export.TemplateFile;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
 
 public class TemplateFileTest {
 

File: jadx-core/src/test/java/jadx/tests/functional/TestIfCondition.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.functional;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.instructions.IfNode;
 import jadx.core.dex.instructions.IfOp;
@@ -19,8 +19,8 @@
 import static jadx.core.dex.regions.conditions.IfCondition.merge;
 import static jadx.core.dex.regions.conditions.IfCondition.not;
 import static jadx.core.dex.regions.conditions.IfCondition.simplify;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestIfCondition {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestArgInline.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArgInline extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestClassGen.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestClassGen extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestFloatValue.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestFloatValue extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestRedundantBrackets.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestRedundantBrackets extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestRedundantReturn.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.fail;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class TestRedundantReturn extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestReturnWrapping.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestReturnWrapping extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/TestStaticMethod.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestStaticMethod extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestStringBuilderElimination.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestStringBuilderElimination extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/TestStringBuilderElimination2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.visitors.SimplifyVisitor;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 /**
  * Test the StringBuilder simplification part of {@link SimplifyVisitor}

File: jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
@@ -9,7 +9,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestWrongCode extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotations.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.annotations;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnnotations extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotations2.java
Patch:
@@ -5,13 +5,13 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnnotations2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestParamAnnotations.java
Patch:
@@ -5,13 +5,13 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestParamAnnotations extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArith.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.arith;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java
Patch:
@@ -5,7 +5,7 @@
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArith2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.arith;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArith3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArithConst.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arith;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArithConst extends SmaliTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArithNot.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.arith;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestArithNot extends SmaliTest {
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arith;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestFieldIncrement extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement3.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.Random;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestFieldIncrement3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestSpecialValues.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arith;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSpecialValues extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrayFill extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFillConstReplace.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrayFillConstReplace extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrays extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrays2 extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays3.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestArrays3 extends IntegrationTest {
 	public static class TestCls {
@@ -21,7 +21,7 @@ public void check() {
 			byte[] inputArr = {1, 2};
 			Object result = test(inputArr);
 			assertThat(result, instanceOf(Object[].class));
-			assertThat(((Object[])result)[0], is(inputArr));
+			assertThat(((Object[]) result)[0], is(inputArr));
 		}
 	}
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays4.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrays4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestMultiDimArrayFill.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestMultiDimArrayFill extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestCmpOp.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestCmpOp extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestCmpOp2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestCmpOp2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestComplexIf extends SmaliTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestComplexIf2 extends SmaliTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditionInLoop.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestConditionInLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions10.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions10 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions11.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions11 extends IntegrationTest {
 
@@ -33,6 +33,5 @@ public void test() {
 		assertThat(code, containsOne("f();"));
 		assertThat(code, not(containsString("return")));
 		assertThat(code, not(containsString("else")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions12.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions12 extends IntegrationTest {
 
@@ -65,6 +65,5 @@ public void test() {
 		assertThat(code, containsOne("if (quality >= 30 && autoStop) {"));
 		assertThat(code, containsOne("if (!autoStop && lastValidRaw > -1 && quality < 10) {"));
 		assertThat(code, not(containsString("return")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions13.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions13 extends IntegrationTest {
 
@@ -37,6 +37,5 @@ public void test() {
 		assertThat(code, containsOne("qualityReading = false;"));
 		assertThat(code, containsOne("} else if (raw == 0 || quality < 6 || !qualityReading) {"));
 		assertThat(code, not(containsString("return")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions14 extends IntegrationTest {
 
@@ -30,6 +30,5 @@ public void test() {
 		assertThat(code, containsOne("boolean r = a == null ? b != null : !a.equals(b);"));
 		assertThat(code, containsOne("if (r) {"));
 		assertThat(code, containsOne("System.out.println(\"1\");"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions15.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions15 extends IntegrationTest {
 
@@ -64,6 +64,5 @@ public void test() {
 
 		assertThat(code, containsOne("\"1\".equals(name)"));
 		assertThat(code, containsOne("\"30\".equals(name)"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions2.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions4.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions6.java
Patch:
@@ -2,14 +2,14 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions6 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions7.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions7 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions8.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions8 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions9.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestConditions9 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestElseIf.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestElseIf extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestNestedIf.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestNestedIf extends IntegrationTest {
 
@@ -42,6 +42,5 @@ public void test() {
 		assertThat(code, countString(2, "return false;"));
 		assertThat(code, containsOne("test1();"));
 		assertThat(code, containsOne("return true;"));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestNestedIf2.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestNestedIf2 extends IntegrationTest {
 
@@ -52,6 +52,5 @@ public void test() {
 		assertThat(code, containsOne("if (executedCount != repeatCount && isRun(delta, object)) {"));
 		assertThat(code, containsOne("if (finished) {"));
 		assertThat(code, not(containsString("else")));
-
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestSimpleConditions.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSimpleConditions extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestTernary extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary3.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.Named;
@@ -11,7 +11,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestTernary3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.conditions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestTernaryInIf extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.debuginfo;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
@@ -10,8 +10,8 @@
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestLineNumbers extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -3,13 +3,13 @@
 import java.lang.ref.WeakReference;
 import java.util.Map;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestLineNumbers2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.debuginfo;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestVariablesNames extends SmaliTest {
 /*

File: jadx-core/src/test/java/jadx/tests/integration/deobf/TestMthRename.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.deobf;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestMthRename extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestEnums extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 import jadx.tests.api.utils.JadxMatchers;
 
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestEnums2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestEnums3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums4.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestEnums4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 import jadx.tests.api.utils.JadxMatchers;
 
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestEnumsInterface extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsWithConsts.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestEnumsWithConsts extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestSwitchOverEnum.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchOverEnum extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestSwitchOverEnum2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.enums;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchOverEnum2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.fallback;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestFallbackMode extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestGenerics extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics3.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestGenerics3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics4.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.generics;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestGenerics4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericsInArgs.java
Patch:
@@ -3,13 +3,13 @@
 import java.util.List;
 import java.util.Set;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
 
 public class TestGenericsInArgs extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInline extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInline2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInline3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline6.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInline6 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInlineInLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestIssue86.java
Patch:
@@ -3,13 +3,13 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIssue86 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticInline.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSyntheticInline extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticInline2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inline;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSyntheticInline2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass.java
Patch:
@@ -3,14 +3,14 @@
 import java.io.File;
 import java.io.FilenameFilter;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass10.java
Patch:
@@ -2,15 +2,15 @@
 
 import java.util.Random;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestAnonymousClass10 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass11.java
Patch:
@@ -2,15 +2,15 @@
 
 import java.util.Random;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestAnonymousClass11 extends IntegrationTest {
 
@@ -36,7 +36,6 @@ public A(long l) {
 			}
 
 			public abstract void m();
-
 		}
 
 		private void func(A a) {

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass12.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass12 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass3.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass4.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestAnonymousClass4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass6.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestAnonymousClass6 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass7.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestAnonymousClass7 extends IntegrationTest {
 
@@ -20,7 +20,6 @@ public void run() {
 				}
 			};
 		}
-
 	}
 
 	@Test

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass8.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestAnonymousClass8 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass9.java
Patch:
@@ -3,15 +3,15 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.FutureTask;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestAnonymousClass9 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestInner2Samples extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInnerClass extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass2.java
Patch:
@@ -3,14 +3,14 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInnerClass2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInnerClass3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass4.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInnerClass4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass5.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestInnerClass5 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInnerClassFakeSyntheticConstructor extends SmaliTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.tests.api.IntegrationTest;
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticRename.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 /**
  * Issue: https://github.com/skylot/jadx/issues/336

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestOuterConstructorCall.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestOuterConstructorCall extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldAccess.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestRFieldAccess extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore.java
Patch:
@@ -3,15 +3,15 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestRFieldRestore extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore2.java
Patch:
@@ -3,13 +3,13 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestRFieldRestore2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.invoke;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
 
 public class TestConstructorInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.invoke;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInheritedStaticInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvoke1.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.io.IOException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInvoke1 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvokeInCatch.java
Patch:
@@ -2,15 +2,15 @@
 
 import java.io.IOException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestInvokeInCatch extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedMethodInvoke.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.tests.integration.invoke;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestOverloadedMethodInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvoke.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.invoke;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSuperInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestVarArg.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.invoke;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestVarArg extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrayForEach extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach2.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestArrayForEach2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEachNegative.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestArrayForEachNegative extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInComplexIf.java
Patch:
@@ -3,14 +3,14 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestBreakInComplexIf extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInComplexIf2.java
Patch:
@@ -3,14 +3,14 @@
 import java.util.Arrays;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestBreakInComplexIf2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestBreakInLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop2.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.anyOf;
 
 public class TestBreakInLoop2 extends IntegrationTest {

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestContinueInLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop2.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.instructions.InsnType;
@@ -19,7 +19,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestContinueInLoop2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestDoWhileBreak extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
 
 public class TestEndlessLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIfInLoop2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIfInLoop2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIfInLoop3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestIfInLoop3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexForLoop.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestIndexForLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIterableForEach extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach2.java
Patch:
@@ -3,13 +3,13 @@
 import java.io.IOException;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIterableForEach2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach3.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.Set;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIterableForEach3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopCondition extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopCondition2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition3.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopCondition3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition4.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopCondition4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.anyOf;
-import static org.junit.Assert.assertThat;
 
 public class TestLoopCondition5 extends SmaliTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopConditionInvoke.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopConditionInvoke extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopDetection extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection2.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopDetection2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection4.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.Iterator;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopDetection4 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestNestedLoops extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops2.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestNestedLoops2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestNestedLoops3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSequentialLoops.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
@@ -9,7 +9,7 @@
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSequentialLoops extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSequentialLoops2.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSequentialLoops2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestTryCatchInLoop.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestTryCatchInLoop extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestTryCatchInLoop2.java
Patch:
@@ -3,13 +3,13 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestTryCatchInLoop2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/names/TestNameAssign2.java
Patch:
@@ -5,17 +5,17 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.visitors.ssa.LiveVarAnalysis;
 import jadx.tests.api.IntegrationTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestNameAssign2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/names/TestReservedNames.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.names;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.SmaliTest;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestReservedNames extends SmaliTest {
 	/*

File: jadx-core/src/test/java/jadx/tests/integration/names/TestSameMethodsNames.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.names;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSameMethodsNames extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.others;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestDefConstructorNotRemoved extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit.java
Patch:
@@ -4,15 +4,15 @@
 import java.util.List;
 import java.util.Random;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestFieldInit extends IntegrationTest {
 
@@ -24,7 +24,7 @@ public class A {
 		private static List<String> s = new ArrayList<>();
 
 		private A a = new A();
-		private int i =  1 + Random.class.getSimpleName().length();
+		private int i = 1 + Random.class.getSimpleName().length();
 		private int n = 0;
 
 		public TestCls(int z) {

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.others;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestFieldInit2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java
Patch:
@@ -3,14 +3,14 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestFieldInitInTryCatch extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIfInTry.java
Patch:
@@ -3,14 +3,14 @@
 import java.io.File;
 import java.io.IOException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIfInTry extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIfTryInCatch.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.others;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIfTryInCatch extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13b.java
Patch:
@@ -6,14 +6,14 @@
 import java.util.Properties;
 import java.util.concurrent.CountDownLatch;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestIssue13b extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestLoopInTry.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.others;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopInTry extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestLoopInTry2.java
Patch:
@@ -5,7 +5,7 @@
 import com.android.dex.Code;
 import com.android.dx.io.instructions.DecodedInstruction;
 import com.android.dx.io.instructions.ShortArrayCodeInput;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.DexNode;
@@ -14,7 +14,7 @@
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestLoopInTry2 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitch extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class TestSwitch2 extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.countString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
 
 public class TestSwitch3 extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchBreak.java
Patch:
@@ -1,16 +1,16 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchBreak extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchContinue extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchInLoop extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchLabels.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertThat;
 
 public class TestSwitchLabels extends IntegrationTest {
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchNoDefault.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchNoDefault extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchReturnFromCase extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchSimple.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchSimple extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchWithFallThroughCase extends IntegrationTest {
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.switches;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class TestSwitchWithFallThroughCase2 extends IntegrationTest {
 

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -138,6 +138,9 @@ protected ParserConstants() {
 	protected static final int FLAG_COMPLEX = 0x0001;
 	// If set, this resource has been declared public, so libraries are allowed to reference it.
 	protected static final int FLAG_PUBLIC = 0x0002;
+	// If set, this is a weak resource and may be overriden by strong resources of the same name/type.
+	// This is only useful during linking with other resource tables.
+	protected static final int FLAG_WEAK = 0x0004;
 
 	/**
 	 * ResTable_map

File: jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java
Patch:
@@ -33,11 +33,14 @@ public void testSrcOption() {
 	@Test
 	public void testOptionsOverride() {
 		assertThat(override(new JadxCLIArgs(), "--no-imports").isUseImports(), is(false));
+		assertThat(override(new JadxCLIArgs(), "--no-debug-info").isDebugInfo(), is(false));
 		assertThat(override(new JadxCLIArgs(), "").isUseImports(), is(true));
 
 		JadxCLIArgs args = new JadxCLIArgs();
 		args.useImports = false;
 		assertThat(override(args, "--no-imports").isUseImports(), is(false));
+		args.debugInfo = false;
+		assertThat(override(args, "--no-debug-info").isDebugInfo(), is(false));
 
 		args = new JadxCLIArgs();
 		args.useImports = false;

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -67,7 +67,9 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new BlockFinish());
 
 			passes.add(new SSATransform());
-			passes.add(new DebugInfoVisitor());
+			if (args.isDebugInfo()) {
+				passes.add(new DebugInfoVisitor());
+			}
 			passes.add(new TypeInference());
 
 			if (args.isRawCFGOutput()) {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java
Patch:
@@ -46,7 +46,8 @@ public JPackage(String name, JadxWrapper wrapper) {
 	private void setEnabled(JadxWrapper wrapper) {
 		List<String> excludedPackages = wrapper.getExcludedPackages();
 		this.enabled = excludedPackages.isEmpty()
-				|| excludedPackages.stream().filter(p -> !p.isEmpty()).noneMatch(p -> name.startsWith(p));
+				|| excludedPackages.stream().filter(p -> !p.isEmpty())
+					.noneMatch(p -> name.equals(p) || name.startsWith(p + '.'));
 	}
 
 	public final void update() {

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -126,7 +126,7 @@ public static boolean isAllCharsPrintable(String str) {
 	 * </ul><p>
 	 */
 	public static String removeInvalidCharsMiddle(String name) {
-		if (isValidIdentifier(name) && isAllCharsPrintable(name)) {
+		if (isValidIdentifier(name)) {
 			return name;
 		}
 		int len = name.length();

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -11,6 +11,7 @@
 import java.util.Set;
 import java.util.TreeSet;
 
+import jadx.core.dex.attributes.AFlag;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
@@ -225,6 +226,8 @@ private void processClass(ClassNode cls) {
 			clsInfo.rename(cls.dex().root(), fullName);
 		}
 		for (FieldNode field : cls.getFields()) {
+			if (field.contains(AFlag.DONT_RENAME))
+			    continue;
 			renameField(field);
 		}
 		for (MethodNode mth : cls.getMethods()) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -19,6 +19,7 @@ public enum AFlag {
 	DONT_SHRINK,
 	DONT_INLINE,
 	DONT_GENERATE,
+	DONT_RENAME, // do not rename during deobfuscation
 	SKIP,
 	REMOVE,
 

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.TreeMap;
 
 import com.android.dx.rop.code.AccessFlags;
+import jadx.core.dex.attributes.AFlag;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
@@ -124,6 +125,7 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora
 			if (fieldNode != null
 					&& !fieldNode.getName().equals(resName)
 					&& NameMapper.isValidIdentifier(resName)) {
+				fieldNode.add(AFlag.DONT_RENAME);
 				fieldNode.getFieldInfo().setAlias(resName);
 			}
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java
Patch:
@@ -34,7 +34,7 @@ public final void initUI() {
 		version.setAlignmentX(0.5f);
 
 		String javaVm = System.getProperty("java.vm.name");
-		String javaVer = System.getProperty("java.vm.version");
+		String javaVer = System.getProperty("java.version");
 
 		javaVm = javaVm == null ? "" : javaVm;
 

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -202,10 +202,10 @@ private void addSimpleValue(CodeWriter cw, String typeName, String itemTag, Stri
 
 	private String getFileName(ResourceEntry ri) {
 		StringBuilder sb = new StringBuilder();
-		String locale = ri.getConfig().getLocale();
+		String qualifiers = ri.getConfig().getQualifiers();
 		sb.append("res/values");
-		if (!locale.isEmpty()) {
-			sb.append('-').append(locale);
+		if (!qualifiers.isEmpty()) {
+			sb.append(qualifiers);
 		}
 		sb.append('/');
 		sb.append(ri.getTypeName());

File: jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java
Patch:
@@ -92,6 +92,9 @@ private String fixClsShortName(String clsName) {
 		if (firstChar == '$') {
 			return 'C' + NameMapper.removeInvalidCharsMiddle(clsName);
 		}
+		if (!NameMapper.isValidIdentifier(clsName)) {
+			return 'C' + clsName;
+		}
 		return NameMapper.removeInvalidChars(clsName, "C");
 	}
 

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -107,7 +107,7 @@ public boolean overrideProvided(String[] args) {
 		return process(jcw);
 	}
 
-	private boolean process(JCommanderWrapper jcw) {
+	private boolean process(JCommanderWrapper<?> jcw) {
 		if (printHelp) {
 			jcw.printUsage();
 			return false;

File: jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java
Patch:
@@ -151,7 +151,7 @@ public void encodeValue(CodeWriter code, Object val) {
 			InsnGen.makeStaticFieldAccess(code, field, classGen);
 		} else if (val instanceof Iterable) {
 			code.add('{');
-			Iterator<?> it = ((Iterable) val).iterator();
+			Iterator<?> it = ((Iterable<?>) val).iterator();
 			while (it.hasNext()) {
 				Object obj = it.next();
 				encodeValue(code, obj);

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -90,7 +90,7 @@ public boolean addDefinition(CodeWriter code) {
 			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");
 		}
 
-		if (classGen.addGenericMap(code, mth.getGenericMap())) {
+		if (classGen.addGenericMap(code, mth.getGenericMap(), false)) {
 			code.add(' ');
 		}
 		if (ai.isConstructor()) {

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -97,7 +97,7 @@ public CodeWriter makeClass() throws CodegenException {
 			imports.clear();
 		}
 		clsCode.add(clsBody);
-		return clsCode;
+		return clsCode.finish();
 	}
 
 	public void addClassCode(CodeWriter code) throws CodegenException {

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -59,8 +59,8 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep
 			loadFromZip(".dex");
 			return;
 		}
-		if (fileName.endsWith(".jar")) {
-			// check if jar contains '.dex' files
+		if (fileName.endsWith(".jar") || fileName.endsWith(".aar")) {
+			// check if jar/aar contains '.dex' files
 			if (loadFromZip(".dex")) {
 				return;
 			}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -140,7 +140,7 @@ private void insertResources(RootNode root) {
 
 	protected void decompile(JadxDecompiler jadx, ClassNode cls) {
 		List<IDexTreeVisitor> passes = JadxInternalAccess.getPassList(jadx);
-		ProcessClass.process(cls, passes, new CodeGen());
+		ProcessClass.process(cls, passes, true);
 	}
 
 	protected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {
@@ -154,7 +154,7 @@ protected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {
 
 	protected void generateClsCode(ClassNode cls) {
 		try {
-			new CodeGen().visit(cls);
+			CodeGen.generate(cls);
 		} catch (Exception e) {
 			e.printStackTrace();
 			fail(e.getMessage());

File: jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java
Patch:
@@ -6,10 +6,8 @@
 import javax.tools.StandardJavaFileManager;
 import java.io.IOException;
 import java.security.SecureClassLoader;
-import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
 
 import static javax.tools.JavaFileObject.Kind;
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java
Patch:
@@ -3,7 +3,6 @@
 import org.junit.Test;
 
 import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
 import jadx.tests.api.SmaliTest;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java
Patch:
@@ -5,7 +5,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase2.java
Patch:
@@ -4,9 +4,7 @@
 import jadx.tests.api.IntegrationTest;
 import org.junit.Test;
 
-import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -333,4 +333,5 @@ private void upgradeSettings(int fromVersion) {
 		settingsVersion = CURRENT_SETTINGS_VERSION;
 		sync();
 	}
+
 }

File: jadx-gui/src/main/java/jadx/gui/treemodel/JSources.java
Patch:
@@ -33,7 +33,7 @@ public final void update() {
 		removeAllChildren();
 		if (flatPackages) {
 			for (JavaPackage pkg : wrapper.getPackages()) {
-				add(new JPackage(pkg));
+				add(new JPackage(pkg, wrapper));
 			}
 		} else {
 			// build packages hierarchy
@@ -54,7 +54,7 @@ public final void update() {
 	List<JPackage> getHierarchyPackages(List<JavaPackage> packages) {
 		Map<String, JPackage> pkgMap = new HashMap<>();
 		for (JavaPackage pkg : packages) {
-			addPackage(pkgMap, new JPackage(pkg));
+			addPackage(pkgMap, new JPackage(pkg, wrapper));
 		}
 		// merge packages without classes
 		boolean repeat;
@@ -114,7 +114,7 @@ private void addPackage(Map<String, JPackage> pkgs, JPackage pkg) {
 			pkg.setName(shortName);
 			JPackage prevPkg = pkgs.get(prevPart);
 			if (prevPkg == null) {
-				prevPkg = new JPackage(prevPart);
+				prevPkg = new JPackage(prevPart, wrapper);
 				addPackage(pkgs, prevPkg);
 			}
 			prevPkg.getInnerPackages().add(pkg);

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -98,7 +98,7 @@ public CodeWriter makeClass() throws CodegenException {
 			imports.clear();
 		}
 		clsCode.add(clsBody);
-		return clsCode;
+		return clsCode.finish();
 	}
 
 	public void addClassCode(CodeWriter code) throws CodegenException {

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -139,7 +139,7 @@ private void insertResources(RootNode root) {
 
 	protected void decompile(JadxDecompiler jadx, ClassNode cls) {
 		List<IDexTreeVisitor> passes = getPassesList(jadx);
-		ProcessClass.process(cls, passes, new CodeGen());
+		ProcessClass.process(cls, passes, true);
 	}
 
 	protected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {
@@ -168,7 +168,7 @@ private List<IDexTreeVisitor> getPassesList(JadxDecompiler jadx) {
 
 	protected void generateClsCode(ClassNode cls) {
 		try {
-			new CodeGen().visit(cls);
+			CodeGen.generate(cls);
 		} catch (Exception e) {
 			e.printStackTrace();
 			fail(e.getMessage());

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -59,8 +59,8 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep
 			loadFromZip(".dex");
 			return;
 		}
-		if (fileName.endsWith(".jar")) {
-			// check if jar contains '.dex' files
+		if (fileName.endsWith(".jar") || fileName.endsWith(".aar")) {
+			// check if jar/aar contains '.dex' files
 			if (loadFromZip(".dex")) {
 				return;
 			}

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -262,6 +262,7 @@ private void addMethods(CodeWriter code) {
 				code.newLine().addMultiLine(Utils.getStackTrace(e));
 				code.newLine().add("*/");
 				code.setIndent(savedIndent);
+				mth.addError("Method generation error: " + e.getMessage(), e);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -116,6 +116,8 @@ public boolean addDefinition(CodeWriter code) {
 			} else {
 				mth.addComment("JADX WARN: Incorrect number of args for enum constructor: " + args.size() + " (expected >= 2)");
 			}
+		} else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {
+			args = args.subList(1, args.size());
 		}
 		addMethodArguments(code, args);
 		code.add(')');

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -248,9 +248,8 @@ public List<RegisterArg> getArguments(boolean includeThis) {
 		return argsList;
 	}
 
-	public RegisterArg removeFirstArgument() {
+	public void skipFirstArgument() {
 		this.add(AFlag.SKIP_FIRST_ARG);
-		return argsList.remove(0);
 	}
 
 	@Nullable

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -120,7 +120,7 @@ private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode
 		if (!fieldInfo.equals(field.getFieldInfo()) || !putInsn.getArg(0).equals(arg)) {
 			return false;
 		}
-		mth.removeFirstArgument();
+		mth.skipFirstArgument();
 		InstructionRemover.remove(mth, block, insn);
 		// other arg usage -> wrap with IGET insn
 		if (arg.getSVar().getUseCount() != 0) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java
Patch:
@@ -29,7 +29,7 @@
 public class BlockSplitter extends AbstractVisitor {
 
 	// leave these instructions alone in block node
-	private static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(
+	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(
 			InsnType.RETURN,
 			InsnType.IF,
 			InsnType.SWITCH,

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java
Patch:
@@ -12,6 +12,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.core.Consts;
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
@@ -278,7 +279,7 @@ private TypeUpdateResult moveListener(TypeUpdateInfo updateInfo, InsnNode insn,
 				return REJECT;
 			}
 		} else {
-			allowReject = false;
+			allowReject = arg.isThis() || arg.contains(AFlag.IMMUTABLE_TYPE);
 		}
 
 		TypeUpdateResult result = updateTypeChecked(updateInfo, changeArg, candidateType);

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -258,8 +258,8 @@ private void addMethods(CodeWriter code) {
 				addMethod(code, mth);
 			} catch (Exception e) {
 				code.newLine().add("/*");
-				code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));
-				code.newLine().add(Utils.getStackTrace(e));
+				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));
+				code.newLine().addMultiLine(Utils.getStackTrace(e));
 				code.newLine().add("*/");
 				code.setIndent(savedIndent);
 			}

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -28,7 +28,7 @@ public PhiInsn(int regNum, int predecessors) {
 	}
 
 	public RegisterArg bindArg(BlockNode pred) {
-		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getType());
+		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getInitType());
 		bindArg(arg, pred);
 		return arg;
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java
Patch:
@@ -6,7 +6,7 @@
 
 public class CodeVar {
 	private String name;
-	private ArgType type; // nullable before type inference, set only for immutable types
+	private ArgType type; // before type inference can be null and set only for immutable types
 	private List<SSAVar> ssaVars = new ArrayList<>(3);
 
 	private boolean isFinal;

File: jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java
Patch:
@@ -78,8 +78,9 @@ private static void setCodeVar(SSAVar ssaVar, CodeVar codeVar) {
 	private static void setCodeVarType(CodeVar codeVar, Set<SSAVar> vars) {
 		if (vars.size() > 1) {
 			List<ArgType> imTypes = vars.stream()
-					.filter(var -> var.contains(AFlag.METHOD_ARGUMENT))
+					.filter(var -> var.contains(AFlag.IMMUTABLE_TYPE))
 					.map(var -> var.getTypeInfo().getType())
+					.filter(ArgType::isTypeKnown)
 					.distinct()
 					.collect(Collectors.toList());
 			int imCount = imTypes.size();

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -299,9 +299,6 @@ private static InsnNode convertFieldArith(MethodNode mth, InsnNode insn) {
 				}
 			}
 			FieldArg fArg = new FieldArg(field, reg);
-			if (reg != null) {
-				fArg.setType(get.getArg(0).getType());
-			}
 			if (wrapType == InsnType.ARITH) {
 				ArithNode ar = (ArithNode) wrap;
 				return new ArithNode(ar.getOp(), fArg, ar.getArg(1));

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java
Patch:
@@ -18,7 +18,6 @@
 import jadx.core.dex.instructions.args.PrimitiveType;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.instructions.args.SSAVar;
-import jadx.core.dex.instructions.args.Typed;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.RootNode;
 import jadx.core.utils.exceptions.JadxOverflowException;
@@ -57,11 +56,11 @@ public TypeUpdateResult apply(SSAVar ssaVar, ArgType candidateType) {
 		if (result == REJECT) {
 			return result;
 		}
-		Map<InsnArg, ArgType> updates = updateInfo.getUpdates();
+		List<TypeUpdateEntry> updates = updateInfo.getUpdates();
 		if (updates.isEmpty()) {
 			return SAME;
 		}
-		updates.forEach(Typed::setType);
+		updates.forEach(TypeUpdateEntry::apply);
 		return CHANGED;
 	}
 

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -96,10 +96,10 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new SimplifyVisitor());
 			passes.add(new CheckRegions());
 
-			passes.add(new MethodInlineVisitor());
 			passes.add(new ExtractFieldInit());
 			passes.add(new FixAccessModifiers());
 			passes.add(new ClassModifier());
+			passes.add(new MethodInlineVisitor());
 			passes.add(new EnumVisitor());
 			passes.add(new LoopRegionVisitor());
 

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -103,11 +103,11 @@ public static NClass[] makeParentsArray(ClassNode cls, Map<String, NClass> names
 	}
 
 	private static NClass getCls(String fullName, Map<String, NClass> names) {
-		NClass id = names.get(fullName);
-		if (id == null && !names.containsKey(fullName)) {
+		NClass cls = names.get(fullName);
+		if (cls == null) {
 			LOG.debug("Class not found: {}", fullName);
 		}
-		return id;
+		return cls;
 	}
 
 	void save(File output) throws IOException {

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -77,8 +77,7 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep
 		if (skipSources) {
 			return;
 		}
-
-		throw new DecodeException("Unsupported input file format: " + file);
+		LOG.warn("No dex files found in {}", file);
 	}
 
 	private void addDexFile(Dex dexBuf) {

File: jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java
Patch:
@@ -46,6 +46,6 @@ private void commonChecks() {
 		assertThat(code, containsOne("this.f0fieldName"));
 
 		assertThat(code, containsOne("public Object run() {"));
-		assertThat(code, containsOne("public String m0run() {"));
+		assertThat(code, containsOne("public String m1run() {"));
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -35,7 +35,7 @@ public void openFile(File file) {
 			this.decompiler.getArgs().setInputFiles(Collections.singletonList(file));
 			this.decompiler.load();
 		} catch (Exception e) {
-			LOG.error("Error load file: {}", file, e);
+			LOG.error("Jadx init error", e);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -95,10 +95,10 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 			passes.add(new SimplifyVisitor());
 			passes.add(new CheckRegions());
 
-			passes.add(new MethodInlineVisitor());
 			passes.add(new ExtractFieldInit());
 			passes.add(new FixAccessModifiers());
 			passes.add(new ClassModifier());
+			passes.add(new MethodInlineVisitor());
 			passes.add(new EnumVisitor());
 			passes.add(new PrepareForCodeGen());
 			passes.add(new LoopRegionVisitor());

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -97,11 +97,11 @@ public static NClass[] makeParentsArray(ClassNode cls, Map<String, NClass> names
 	}
 
 	private static NClass getCls(String fullName, Map<String, NClass> names) {
-		NClass id = names.get(fullName);
-		if (id == null && !names.containsKey(fullName)) {
+		NClass cls = names.get(fullName);
+		if (cls == null) {
 			LOG.debug("Class not found: {}", fullName);
 		}
-		return id;
+		return cls;
 	}
 
 	void save(File output) throws IOException {

File: jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java
Patch:
@@ -46,6 +46,6 @@ private void commonChecks() {
 		assertThat(code, containsOne("this.f0fieldName"));
 
 		assertThat(code, containsOne("public Object run() {"));
-		assertThat(code, containsOne("public String m0run() {"));
+		assertThat(code, containsOne("public String m1run() {"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -77,8 +77,7 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep
 		if (skipSources) {
 			return;
 		}
-
-		throw new DecodeException("Unsupported input file format: " + file);
+		LOG.warn("No dex files found in {}", file);
 	}
 
 	private void addDexFile(Dex dexBuf) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.core.dex.visitors.ssa;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
@@ -111,7 +112,7 @@ private void replaceMerge(MethodNode mth, BlockNode block, InsnNode insn) {
 		if (assignParentInsn != null) {
 			assignParentInsn.setResult(newAssignArg);
 		}
-		for (RegisterArg useArg : oldSVar.getUseList()) {
+		for (RegisterArg useArg : new ArrayList<>(oldSVar.getUseList())) {
 			RegisterArg newUseArg = useArg.duplicate(newRegNum, newSVar);
 			InsnNode parentInsn = useArg.getParentInsn();
 			if (parentInsn != null) {

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -35,7 +35,7 @@ public void openFile(File file) {
 			this.decompiler.getArgs().setInputFiles(Collections.singletonList(file));
 			this.decompiler.load();
 		} catch (Exception e) {
-			LOG.error("Error load file: {}", file, e);
+			LOG.error("Jadx init error", e);
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -74,6 +74,7 @@ private void initUI() {
 		JButton cancelButton = new JButton(NLS.str("preferences.cancel"));
 		cancelButton.addActionListener(event -> {
 			JadxSettingsAdapter.fill(settings, startSettings);
+			mainWindow.loadSettings();
 			dispose();
 		});
 
@@ -87,6 +88,8 @@ private void initUI() {
 			if (res == JOptionPane.YES_OPTION) {
 				String defaults = JadxSettingsAdapter.makeString(JadxSettings.makeDefault());
 				JadxSettingsAdapter.fill(settings, defaults);
+				mainWindow.loadSettings();
+				needReload();
 				getContentPane().removeAll();
 				initUI();
 				pack();
@@ -197,7 +200,6 @@ public void mouseClicked(MouseEvent e) {
 					Font font = fontChooser.getSelectedFont();
 					LOG.debug("Selected Font: {}", font);
 					settings.setFont(font);
-					mainWindow.updateFont(font);
 					mainWindow.loadSettings();
 					fontLabel.setText(getFontLabelStr());
 				}

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -104,7 +104,9 @@ private void initUI() {
 		buttonPane.add(cancelButton);
 
 		Container contentPane = getContentPane();
-		contentPane.add(panel, BorderLayout.CENTER);
+		JScrollPane scrollPane = new JScrollPane(panel);
+		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
+		contentPane.add(scrollPane, BorderLayout.CENTER);
 		contentPane.add(buttonPane, BorderLayout.PAGE_END);
 		getRootPane().setDefaultButton(saveBtn);
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java
Patch:
@@ -6,7 +6,7 @@
 
 public class CodeVar {
 	private String name;
-	private ArgType type;
+	private ArgType type; // nullable before type inference, set only for immutable types
 	private List<SSAVar> ssaVars = new ArrayList<>(3);
 
 	private boolean isFinal;

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -139,6 +139,9 @@ public CodeVar getCodeVar() {
 
 	public void setCodeVar(@NotNull CodeVar codeVar) {
 		this.codeVar = codeVar;
+		if (codeVar.getType() != null && !typeInfo.getType().equals(codeVar.getType())) {
+			throw new JadxRuntimeException("Unmached types for SSA and Code variables: " + this + " and " + codeVar);
+		}
 		codeVar.addSsaVar(this);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInfo.java
Patch:
@@ -1,6 +1,6 @@
 package jadx.core.dex.visitors.typeinference;
 
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.Set;
 
 import org.jetbrains.annotations.NotNull;
@@ -10,7 +10,7 @@
 public class TypeInfo {
 	private ArgType type = ArgType.UNKNOWN;
 
-	private final Set<ITypeBound> bounds = new HashSet<>();
+	private final Set<ITypeBound> bounds = new LinkedHashSet<>();
 
 	@NotNull
 	public ArgType getType() {

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesGeneric.java
Patch:
@@ -24,7 +24,7 @@ public static <T> j a(i<? super T> iVar, c<T> cVar) {
 	@Test
 	public void test() {
 		disableCompilation();
-		ClassNode cls = getClassNodeFromSmaliWithPath("variables", "TestVariablesGeneric");
+		ClassNode cls = getClassNodeFromSmaliWithPkg("variables", "TestVariablesGeneric");
 		String code = cls.getCode().toString();
 
 		assertThat(code, not(containsString("iVar2")));

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -19,6 +19,7 @@
 import jadx.core.dex.visitors.EnumVisitor;
 import jadx.core.dex.visitors.ExtractFieldInit;
 import jadx.core.dex.visitors.FallbackModeVisitor;
+import jadx.core.dex.visitors.FixAccessModifiers;
 import jadx.core.dex.visitors.IDexTreeVisitor;
 import jadx.core.dex.visitors.InitCodeVariables;
 import jadx.core.dex.visitors.MarkFinallyVisitor;
@@ -97,6 +98,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 
 			passes.add(new MethodInlineVisitor());
 			passes.add(new ExtractFieldInit());
+			passes.add(new FixAccessModifiers());
 			passes.add(new ClassModifier());
 			passes.add(new EnumVisitor());
 			passes.add(new LoopRegionVisitor());

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java
Patch:
@@ -39,6 +39,7 @@ public ExceptionHandler(int addr, @Nullable ClassInfo type) {
 
 	/**
 	 * Add exception type to catch block
+	 *
 	 * @param type - null for 'all' or 'Throwable' handler
 	 */
 	public void addCatchType(@Nullable ClassInfo type) {

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -19,7 +19,7 @@ public static class TestCls {
 		public TestCls(TestCls s) {
 		}
 
-		TestCls test(TestCls s) {
+		public TestCls test(TestCls s) {
 			TestCls store = f != null ? f.get() : null;
 			if (store == null) {
 				store = new TestCls(s);

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticRename.java
Patch:
@@ -34,8 +34,8 @@ public void test() {
 		ClassNode cls = getClassNodeFromSmali("inner/TestInnerClassSyntheticRename", "com.github.skylot.testasync.MyAsync");
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("protected List<Uri> doInBackground(Uri... uriArr) {"));
-		assertThat(code, containsOne("protected void onPostExecute(List<Uri> list) {"));
+		assertThat(code, containsOne("List<Uri> doInBackground(Uri... uriArr) {"));
+		assertThat(code, containsOne("void onPostExecute(List<Uri> list) {"));
 		assertThat(code, not(containsString("synthetic")));
 	}
 }

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -19,6 +19,7 @@
 import jadx.core.dex.visitors.EnumVisitor;
 import jadx.core.dex.visitors.ExtractFieldInit;
 import jadx.core.dex.visitors.FallbackModeVisitor;
+import jadx.core.dex.visitors.FixAccessModifiers;
 import jadx.core.dex.visitors.IDexTreeVisitor;
 import jadx.core.dex.visitors.MethodInlineVisitor;
 import jadx.core.dex.visitors.ModVisitor;
@@ -96,6 +97,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {
 
 			passes.add(new MethodInlineVisitor());
 			passes.add(new ExtractFieldInit());
+			passes.add(new FixAccessModifiers());
 			passes.add(new ClassModifier());
 			passes.add(new EnumVisitor());
 			passes.add(new PrepareForCodeGen());

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java
Patch:
@@ -19,7 +19,7 @@ public static class TestCls {
 		public TestCls(TestCls s) {
 		}
 
-		TestCls test(TestCls s) {
+		public TestCls test(TestCls s) {
 			TestCls store = f != null ? f.get() : null;
 			if (store == null) {
 				store = new TestCls(s);

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticRename.java
Patch:
@@ -34,8 +34,8 @@ public void test() {
 		ClassNode cls = getClassNodeFromSmali("inner/TestInnerClassSyntheticRename", "com.github.skylot.testasync.MyAsync");
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsOne("protected List<Uri> doInBackground(Uri... uriArr) {"));
-		assertThat(code, containsOne("protected void onPostExecute(List<Uri> list) {"));
+		assertThat(code, containsOne("List<Uri> doInBackground(Uri... uriArr) {"));
+		assertThat(code, containsOne("void onPostExecute(List<Uri> list) {"));
 		assertThat(code, not(containsString("synthetic")));
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -499,7 +499,6 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro
 				break;
 
 			case PHI:
-			case MERGE:
 				fallbackOnlyInsn(insn);
 				code.add(insn.getType().toString()).add("(");
 				for (InsnArg insnArg : insn.getArguments()) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -27,6 +27,9 @@ public String toString() {
 		for (PhiInsn phiInsn : list) {
 			sb.append('r').append(phiInsn.getResult().getRegNum()).append(" ");
 		}
+		for (PhiInsn phiInsn : list) {
+			sb.append("\n  ").append(phiInsn).append(" ").append(phiInsn.getAttributesString());
+		}
 		return sb.toString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RegDebugInfoAttr.java
Patch:
@@ -30,7 +30,7 @@ public ArgType getRegType() {
 	}
 
 	@Override
-	public AType getType() {
+	public AType<RegDebugInfoAttr> getType() {
 		return AType.REG_DEBUG_INFO;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java
Patch:
@@ -66,9 +66,6 @@ public enum InsnType {
 	ONE_ARG,
 	PHI,
 
-	// merge all arguments in one
-	MERGE,
-
 	// TODO: now multidimensional arrays created using Array.newInstance function
 	NEW_MULTIDIM_ARRAY
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -24,6 +24,7 @@ public PhiInsn(int regNum, int predecessors) {
 		this.blockBinds = new LinkedHashMap<>(predecessors);
 		setResult(InsnArg.reg(regNum, ArgType.UNKNOWN));
 		add(AFlag.DONT_INLINE);
+		add(AFlag.DONT_GENERATE);
 	}
 
 	public RegisterArg bindArg(BlockNode pred) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -30,6 +30,8 @@ public abstract class ArgType {
 
 	public static final ArgType UNKNOWN = unknown(PrimitiveType.values());
 	public static final ArgType UNKNOWN_OBJECT = unknown(PrimitiveType.OBJECT, PrimitiveType.ARRAY);
+	public static final ArgType UNKNOWN_OBJECT_NO_ARRAY = unknown(PrimitiveType.OBJECT);
+	public static final ArgType UNKNOWN_ARRAY = array(UNKNOWN);
 
 	public static final ArgType NARROW = unknown(
 			PrimitiveType.INT, PrimitiveType.FLOAT,

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -139,6 +139,7 @@ public CodeVar getCodeVar() {
 
 	public void setCodeVar(@NotNull CodeVar codeVar) {
 		this.codeVar = codeVar;
+		codeVar.addSsaVar(this);
 	}
 
 	public boolean isCodeVarSet() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -185,9 +185,9 @@ private void processBlock(MethodNode mth, BlockNode block, boolean error) {
 			dot.add("}\"];");
 
 			BlockNode falsePath = null;
-			List<InsnNode> list = block.getInstructions();
-			if (!list.isEmpty() && list.get(0).getType() == InsnType.IF) {
-				falsePath = ((IfNode) list.get(0)).getElseBlock();
+			InsnNode lastInsn = BlockUtils.getLastInsn(block);
+			if (lastInsn != null && lastInsn.getType() == InsnType.IF) {
+				falsePath = ((IfNode) lastInsn).getElseBlock();
 			}
 			for (BlockNode next : block.getSuccessors()) {
 				String style = next == falsePath ? "[style=dashed]" : "";

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -235,7 +235,6 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 				RegisterArg reg = (RegisterArg) arg;
 				SSAVar sVar = reg.getSVar();
 				if (sVar != null) {
-					sVar.add(AFlag.FINAL);
 					sVar.getCodeVar().setFinal(true);
 					sVar.add(AFlag.DONT_INLINE);
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java
Patch:
@@ -36,6 +36,9 @@ public void visit(MethodNode mth) throws JadxException {
 			return;
 		}
 		for (BlockNode block : blocks) {
+			if (block.contains(AFlag.DONT_GENERATE)) {
+				continue;
+			}
 			removeInstructions(block);
 			checkInline(block);
 //			removeParenthesis(block);

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java
Patch:
@@ -26,7 +26,6 @@
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.dex.visitors.JadxVisitor;
-import jadx.core.dex.visitors.ssa.EliminatePhiNodes;
 import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;
 import jadx.core.dex.visitors.typeinference.TypeUpdateResult;
@@ -39,8 +38,7 @@
 		desc = "Apply debug info to registers (type and names)",
 		runAfter = {
 				SSATransform.class,
-				TypeInferenceVisitor.class,
-				EliminatePhiNodes.class
+				TypeInferenceVisitor.class
 		}
 )
 public class DebugInfoApplyVisitor extends AbstractVisitor {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -59,6 +59,7 @@ public void processBlock(MethodNode mth, IBlock container) {
 				if (!blocksInRegions.contains(block)
 						&& !block.getInstructions().isEmpty()
 						&& !block.contains(AFlag.ADDED_TO_REGION)
+						&& !block.contains(AFlag.DONT_GENERATE)
 						&& !block.contains(AFlag.REMOVE)) {
 					String blockCode = getBlockInsnStr(mth, block);
 					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -197,7 +197,6 @@ private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, Ins
 		}
 
 		// array for each loop confirmed
-		len.add(AFlag.DONT_GENERATE);
 		incrInsn.getResult().add(AFlag.DONT_GENERATE);
 		condArg.add(AFlag.DONT_GENERATE);
 		bCondArg.add(AFlag.DONT_GENERATE);
@@ -208,6 +207,8 @@ private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, Ins
 			((RegisterArg) arrayArg).getSVar().removeUse((RegisterArg) arrGetInsn.getArg(0));
 		}
 		CodeShrinker.shrinkMethod(mth);
+		len.add(AFlag.DONT_GENERATE);
+
 		if (arrGetInsn.contains(AFlag.WRAPPED)) {
 			InsnArg wrapArg = BlockUtils.searchWrappedInsnParent(mth, arrGetInsn);
 			if (wrapArg != null && wrapArg.getParentInsn() != null) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java
Patch:
@@ -114,6 +114,9 @@ private TypeCompareEnum compareWithUnknown(ArgType known, ArgType unknown) {
 		if (unknown == ArgType.UNKNOWN_OBJECT && (known.isObject() || known.isArray())) {
 			return NARROW;
 		}
+		if (known.equals(ArgType.OBJECT) && unknown.isArray()) {
+			return WIDER;
+		}
 		PrimitiveType knownPrimitive;
 		if (known.isPrimitive()) {
 			knownPrimitive = known.getPrimitiveType();

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -33,6 +33,7 @@
 import jadx.core.dex.trycatch.ExcHandlerAttr;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.dex.visitors.ConstInlineVisitor;
+import jadx.core.dex.visitors.InitCodeVariables;
 import jadx.core.dex.visitors.JadxVisitor;
 import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.utils.Utils;
@@ -131,7 +132,7 @@ private boolean calculateFromBounds(SSAVar ssaVar) {
 				if (Consts.DEBUG) {
 					if (ssaVar.getTypeInfo().getType().equals(candidateType)) {
 						LOG.info("Same type rejected: {} -> {}, bounds: {}", ssaVar, candidateType, bounds);
-					} else {
+					} else if (candidateType.isTypeKnown()) {
 						LOG.debug("Type set rejected: {} -> {}, bounds: {}", ssaVar, candidateType, bounds);
 					}
 				}
@@ -311,6 +312,7 @@ private boolean tryInsertAdditionalInsn(MethodNode mth, SSAVar var) {
 				for (InsnArg phiArg : phiInsn.getArguments()) {
 					mergePhiBounds(((RegisterArg) phiArg).getSVar());
 				}
+				InitCodeVariables.initCodeVar(newSsaVar);
 				return true;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java
Patch:
@@ -246,7 +246,6 @@ private Map<InsnType, ITypeListener> initListenerRegistry() {
 		registry.put(InsnType.CONST, this::sameFirstArgListener);
 		registry.put(InsnType.MOVE, this::moveListener);
 		registry.put(InsnType.PHI, this::allSameListener);
-		registry.put(InsnType.MERGE, this::allSameListener);
 		registry.put(InsnType.AGET, this::arrayGetListener);
 		registry.put(InsnType.APUT, this::arrayPutListener);
 		registry.put(InsnType.IF, this::ifListener);

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -107,9 +107,9 @@ private static void printInsns(MethodNode mth, String indent, IBlock block) {
 				CodeWriter code = new CodeWriter();
 				ig.makeInsn(insn, code);
 				String insnStr = code.toString().substring(CodeWriter.NL.length());
-				LOG.debug("{}> {}\t{}", indent, insnStr, insn.getAttributesString());
+				LOG.debug("{}|> {}\t{}", indent, insnStr, insn.getAttributesString());
 			} catch (CodegenException e) {
-				LOG.debug("{}>!! {}", indent, insn);
+				LOG.debug("{}|>!! {}", indent, insn);
 			}
 		}
 	}

File: jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java
Patch:
@@ -16,6 +16,7 @@
 import static jadx.core.dex.instructions.args.ArgType.NARROW_INTEGRAL;
 import static jadx.core.dex.instructions.args.ArgType.OBJECT;
 import static jadx.core.dex.instructions.args.ArgType.UNKNOWN;
+import static jadx.core.dex.instructions.args.ArgType.UNKNOWN_ARRAY;
 import static jadx.core.dex.instructions.args.ArgType.UNKNOWN_OBJECT;
 import static jadx.core.dex.instructions.args.ArgType.array;
 import static org.hamcrest.Matchers.is;
@@ -60,6 +61,8 @@ public void compareArrays() {
 
 		firstIsNarrow(array(OBJECT), OBJECT);
 		firstIsNarrow(array(OBJECT), array(UNKNOWN_OBJECT));
+
+		firstIsNarrow(UNKNOWN_ARRAY, OBJECT);
 	}
 
 	@Test

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java
Patch:
@@ -32,8 +32,8 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsString("this.a.f += n;"));
-		assertThat(code, containsString("a.f *= n;"));
-		// TODO
-		// assertThat(code, containsString("this.a.f *= n;"));
+		assertThat(code, containsString("a2.f *= n;"));
+		// TODO:
+		//  assertThat(code, containsString("this.a.f *= n;"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums4.java
Patch:
@@ -24,8 +24,8 @@ public enum ResType {
 
 			private final String[] exts;
 
-			private ResType(String... exts) {
-				this.exts = exts;
+			private ResType(String... extensions) {
+				this.exts = extensions;
 			}
 
 			public String[] getExts() {
@@ -44,7 +44,7 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("CODE(\".dex\", \".class\"),"));
-		assertThat(code, containsOne("ResType(String... exts) {"));
+		assertThat(code, containsOne("ResType(String... extensions) {"));
 //		assertThat(code, not(containsString("private ResType")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics2.java
Patch:
@@ -19,9 +19,9 @@ public static class TestCls {
 		private static class ItemReference<V> extends WeakReference<V> {
 			private Object id;
 
-			public ItemReference(V item, Object id, ReferenceQueue<? super V> queue) {
+			public ItemReference(V item, Object objId, ReferenceQueue<? super V> queue) {
 				super(item, queue);
-				this.id = id;
+				this.id = objId;
 			}
 		}
 
@@ -43,7 +43,7 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsString("public ItemReference(V item, Object id, ReferenceQueue<? super V> queue) {"));
+		assertThat(code, containsString("public ItemReference(V item, Object objId, ReferenceQueue<? super V> queue) {"));
 		assertThat(code, containsString("public V get(Object id) {"));
 		assertThat(code, containsString("WeakReference<V> ref = "));
 		assertThat(code, containsString("return ref.get();"));

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally7.java
Patch:
@@ -11,7 +11,7 @@
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
-public class TestTryCatch3 extends IntegrationTest {
+public class TestTryCatchFinally7 extends IntegrationTest {
 
 	public static class TestCls {
 		private int f = 0;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java
Patch:
@@ -4,6 +4,7 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import jadx.core.dex.nodes.ClassNode;
@@ -12,7 +13,7 @@
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 
-public class TestTryCatch5 extends IntegrationTest {
+public class TestTryCatchFinally8 extends IntegrationTest {
 
 	public static class TestCls {
 		private Object test(Object obj) {
@@ -41,9 +42,9 @@ private Object test(Object obj) {
 		}
 	}
 
+	@Ignore("Fix merged catch blocks (shared code between catches)")
 	@Test
 	public void test() {
-		disableCompilation();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMoveExc.java
Patch:
@@ -8,7 +8,7 @@
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 
-public class TestTryCatchNoMove extends SmaliTest {
+public class TestTryCatchNoMoveExc extends SmaliTest {
 
 //	private static void test(AutoCloseable closeable) {
 //		if (closeable != null) {
@@ -21,7 +21,7 @@ public class TestTryCatchNoMove extends SmaliTest {
 
 	@Test
 	public void test() {
-		ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMove");
+		ClassNode cls = getClassNodeFromSmaliWithPkg("trycatch", "TestTryCatchNoMoveExc");
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("if (autoCloseable != null) {"));

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMoveExc2.java
Patch:
@@ -26,7 +26,7 @@ public class TestTryCatchNoMoveExc2 extends SmaliTest {
 
 	@Test
 	public void test() {
-		ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMoveExc2");
+		ClassNode cls = getClassNodeFromSmaliWithPkg("trycatch", "TestTryCatchNoMoveExc2");
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("try {"));

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -701,7 +701,7 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr
 		ArgType origType;
 		List<RegisterArg> arguments = callMth.getArguments(false);
 		if (arguments == null || arguments.isEmpty()) {
-			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");
+			mth.addComment("JADX INFO: used method not loaded: " + callMth + ", types can be incorrect");
 			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);
 		} else {
 			origType = arguments.get(origPos).getInitType();

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -163,7 +163,7 @@ public int hashCode() {
 	}
 
 	public String toShortString() {
-		return "r" + regNum + ":" + version;
+		return "r" + regNum + "v" + version;
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java
Patch:
@@ -59,6 +59,7 @@ private static void markExceptionHandlers(BlockNode block) {
 				me.add(AFlag.DONT_INLINE);
 				resArg.add(AFlag.CUSTOM_DECLARE);
 				excHandler.setArg(resArg);
+				me.addAttr(handlerAttr);
 				return;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParseVisitor.java
Patch:
@@ -56,7 +56,7 @@ private void attachDebugInfo(MethodNode mth, List<LocalVar> localVars, InsnNode[
 		if (localVars.isEmpty()) {
 			return;
 		}
-		if (Consts.DEBUG && LOG.isDebugEnabled()) {
+		if (Consts.DEBUG) {
 			LOG.debug("Parsed debug info for {}: ", mth);
 			localVars.forEach(v -> LOG.debug("  {}", v));
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java
Patch:
@@ -111,7 +111,7 @@ private void replaceMerge(MethodNode mth, BlockNode block, InsnNode insn) {
 
 		// all checks passed
 		RegisterArg newAssignArg = oldArg.duplicate(newRegNum, null);
-		SSAVar newSVar = mth.makeNewSVar(newRegNum, mth.getNextSVarVersion(newRegNum), newAssignArg);
+		SSAVar newSVar = mth.makeNewSVar(newRegNum, newAssignArg);
 		newSVar.setName(oldSVar.getName());
 		mth.root().getTypeUpdate().apply(newSVar, assignArg.getType());
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInfo.java
Patch:
@@ -3,13 +3,16 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import org.jetbrains.annotations.NotNull;
+
 import jadx.core.dex.instructions.args.ArgType;
 
 public class TypeInfo {
 	private ArgType type = ArgType.UNKNOWN;
 
 	private final Set<ITypeBound> bounds = new HashSet<>();
 
+	@NotNull
 	public ArgType getType() {
 		return type;
 	}

File: jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java
Patch:
@@ -72,7 +72,7 @@ private void processByPatterns(JadxDecompiler jadx, String clsPattern, @Nullable
 		int processed = 0;
 		for (ClassNode classNode : root.getClasses(true)) {
 			String clsFullName = classNode.getClassInfo().getFullName();
-			if (isMatch(clsFullName, clsPattern)) {
+			if (clsFullName.equals(clsPattern)) {
 				if (processCls(mthPattern, passes, classNode)) {
 					processed++;
 				}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -26,6 +26,8 @@ public enum AFlag {
 	ANONYMOUS_CONSTRUCTOR,
 	ANONYMOUS_CLASS,
 	THIS,
+	METHOD_ARGUMENT, // RegisterArg attribute for method arguments
+	CUSTOM_DECLARE, // variable for this register don't need declaration
 
 	ELSE_IF_CHAIN,
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -25,6 +25,6 @@ public AType<AttrList<T>> getType() {
 
 	@Override
 	public String toString() {
-		return Utils.listToString(list);
+		return Utils.listToString(list, "\n");
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java
Patch:
@@ -1,5 +1,5 @@
 package jadx.core.dex.attributes;
 
 public interface IAttribute {
-	<T extends IAttribute> AType<T> getType();
+	AType<? extends IAttribute> getType();
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -230,7 +230,9 @@ private void initArguments(List<ArgType> args) {
 		}
 		argsList = new ArrayList<>(args.size());
 		for (ArgType arg : args) {
-			argsList.add(InsnArg.typeImmutableReg(pos, arg));
+			TypeImmutableArg regArg = InsnArg.typeImmutableReg(pos, arg);
+			regArg.add(AFlag.METHOD_ARGUMENT);
+			argsList.add(regArg);
 			pos += arg.getRegCount();
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/ForEachLoop.java
Patch:
@@ -10,6 +10,9 @@ public final class ForEachLoop extends LoopType {
 	public ForEachLoop(RegisterArg varArg, InsnArg iterableArg) {
 		this.varArg = varArg;
 		this.iterableArg = iterableArg;
+
+		// will be declared at codegen
+		varArg.getSVar().getCodeVar().setDeclared(true);
 	}
 
 	public RegisterArg getVarArg() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -236,6 +236,7 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 				SSAVar sVar = reg.getSVar();
 				if (sVar != null) {
 					sVar.add(AFlag.FINAL);
+					sVar.getCodeVar().setFinal(true);
 					sVar.add(AFlag.DONT_INLINE);
 				}
 				reg.add(AFlag.SKIP_ARG);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java
Patch:
@@ -57,6 +57,7 @@ private static void markExceptionHandlers(BlockNode block) {
 				resArg.copyAttributesFrom(me);
 				me.setResult(resArg);
 				me.add(AFlag.DONT_INLINE);
+				resArg.add(AFlag.CUSTOM_DECLARE);
 				excHandler.setArg(resArg);
 				return;
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -35,7 +35,7 @@
 public class RegionMakerVisitor extends AbstractVisitor {
 	private static final Logger LOG = LoggerFactory.getLogger(RegionMakerVisitor.class);
 
-	private static final PostRegionVisitor POST_REGION_VISITOR = new PostRegionVisitor();
+	private static final IRegionVisitor POST_REGION_VISITOR = new PostRegionVisitor();
 
 	@Override
 	public void visit(MethodNode mth) throws JadxException {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -419,7 +419,6 @@ private static void markOneArgAsThis(RegisterArg arg) {
 			return;
 		}
 		arg.add(AFlag.THIS);
-		arg.setName(RegisterArg.THIS_ARG_NAME);
 		// mark all moved 'this'
 		InsnNode parentInsn = arg.getParentInsn();
 		if (parentInsn != null

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/ITypeListener.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.visitors.typeinference;
 
+import org.jetbrains.annotations.NotNull;
+
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.nodes.InsnNode;
@@ -14,5 +16,5 @@ public interface ITypeListener {
 	 * @param arg           apply suggested type for this arg
 	 * @param candidateType suggest new type
 	 */
-	TypeUpdateResult update(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType);
+	TypeUpdateResult update(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, @NotNull ArgType candidateType);
 }

File: jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java
Patch:
@@ -57,6 +57,9 @@ public void comparePrimitives() {
 	public void compareArrays() {
 		firstIsNarrow(array(CHAR), OBJECT);
 		firstIsNarrow(array(CHAR), array(UNKNOWN));
+
+		firstIsNarrow(array(OBJECT), OBJECT);
+		firstIsNarrow(array(OBJECT), array(UNKNOWN_OBJECT));
 	}
 
 	@Test

File: jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java
Patch:
@@ -97,6 +97,8 @@ private boolean processCls(@Nullable String mthPattern, List<IDexTreeVisitor> pa
 		if (!decompile) {
 			return false;
 		}
+
+//		ProcessClass.process(classNode, passes, new CodeGen());
 		for (IDexTreeVisitor visitor : passes) {
 			DepthTraversal.visit(visitor, classNode);
 		}

File: jadx-core/src/test/java/jadx/tests/integration/names/TestNameAssign2.java
Patch:
@@ -13,7 +13,8 @@
 import jadx.core.dex.visitors.ssa.LiveVarAnalysis;
 import jadx.tests.api.IntegrationTest;
 
-import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.assertThat;
 
 public class TestNameAssign2 extends IntegrationTest {
@@ -58,7 +59,6 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		// TODO:
-		assertThat(code, containsOne("int id;"));
+		assertThat(code, not(containsString("int id;")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch3.java
Patch:
@@ -63,7 +63,7 @@ public void test() {
 	}
 
 	@Test
-	public void test2() {
+	public void testNoDebug() {
 		noDebugInfo();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch7.java
Patch:
@@ -24,7 +24,7 @@ private Exception test() {
 	}
 
 	@Test
-	public void test() {
+	public void testNoDebug() {
 		noDebugInfo();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDefinitions.java
Patch:
@@ -22,7 +22,7 @@ public static class TestCls {
 		private ClassNode cls;
 		private List<IDexTreeVisitor> passes;
 
-		public void run() {
+		public void test() {
 			try {
 				cls.load();
 				for (IDexTreeVisitor pass : this.passes) {
@@ -41,5 +41,6 @@ public void test() {
 
 		assertThat(code, containsOne(indent(3) + "for (IDexTreeVisitor pass : this.passes) {"));
 		assertThat(code, not(containsString("iterator;")));
+		assertThat(code, not(containsString("Iterator")));
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -98,7 +98,7 @@ public void makeRegionIndent(CodeWriter code, IContainer region) throws CodegenE
 
 	private void makeSimpleBlock(IBlock block, CodeWriter code) throws CodegenException {
 		for (InsnNode insn : block.getInstructions()) {
-			if (!insn.contains(AFlag.SKIP)) {
+			if (!insn.contains(AFlag.DONT_GENERATE)) {
 				makeInsn(insn, code);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java
Patch:
@@ -70,7 +70,7 @@ private void unbindHandler(ExceptionHandler handler) {
 		for (BlockNode block : handler.getBlocks()) {
 			// skip synthetic loop exit blocks
 			BlockUtils.skipPredSyntheticPaths(block);
-			block.add(AFlag.SKIP);
+			block.add(AFlag.REMOVE);
 			ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);
 			if (excHandlerAttr != null
 					&& excHandlerAttr.getHandler().equals(handler)) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java
Patch:
@@ -31,7 +31,7 @@ public void visit(MethodNode mth) {
 	}
 
 	public static void shrinkMethod(MethodNode mth) {
-		if (mth.isNoCode() || mth.contains(AFlag.DONT_SHRINK)) {
+		if (mth.isNoCode()) {
 			return;
 		}
 		for (BlockNode block : mth.getBasicBlocks()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -47,7 +47,7 @@ public void processBlock(MethodNode mth, IBlock container) {
 				}
 				if (LOG.isDebugEnabled()
 						&& !block.contains(AFlag.RETURN)
-						&& !block.contains(AFlag.SKIP)
+						&& !block.contains(AFlag.REMOVE)
 						&& !block.contains(AFlag.SYNTHETIC)
 						&& !block.getInstructions().isEmpty()) {
 					LOG.debug("Duplicated block: {} - {}", mth, block);
@@ -58,7 +58,8 @@ public void processBlock(MethodNode mth, IBlock container) {
 			for (BlockNode block : mth.getBasicBlocks()) {
 				if (!blocksInRegions.contains(block)
 						&& !block.getInstructions().isEmpty()
-						&& !block.contains(AFlag.SKIP)) {
+						&& !block.contains(AFlag.ADDED_TO_REGION)
+						&& !block.contains(AFlag.REMOVE)) {
 					String blockCode = getBlockInsnStr(mth, block);
 					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java
Patch:
@@ -291,13 +291,13 @@ static void confirmMerge(IfInfo info) {
 		if (info.getMergedBlocks().size() > 1) {
 			for (BlockNode block : info.getMergedBlocks()) {
 				if (block != info.getIfBlock()) {
-					block.add(AFlag.SKIP);
+					block.add(AFlag.ADDED_TO_REGION);
 				}
 			}
 		}
 		if (!info.getSkipBlocks().isEmpty()) {
 			for (BlockNode block : info.getSkipBlocks()) {
-				block.add(AFlag.SKIP);
+				block.add(AFlag.ADDED_TO_REGION);
 			}
 			info.getSkipBlocks().clear();
 		}
@@ -325,7 +325,7 @@ private static boolean canSelectNext(IfInfo info, BlockNode block) {
 	}
 
 	private static BlockNode getNextIfNode(BlockNode block) {
-		if (block == null || block.contains(AType.LOOP) || block.contains(AFlag.SKIP)) {
+		if (block == null || block.contains(AType.LOOP) || block.contains(AFlag.ADDED_TO_REGION)) {
 			return null;
 		}
 		List<InsnNode> insns = block.getInstructions();

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -122,7 +122,7 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi
 			int len = container.getInstructions().size();
 			for (int i = 0; i < len; i++) {
 				InsnNode insn = container.getInstructions().get(i);
-				if (insn.contains(AFlag.SKIP)) {
+				if (insn.contains(AFlag.DONT_GENERATE)) {
 					continue;
 				}
 				args.clear();

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -126,7 +126,7 @@ private static void processSwitch(MethodNode mth, SwitchRegion sw) {
 				BlockNode bn = (BlockNode) block;
 				for (BlockNode s : bn.getCleanSuccessors()) {
 					if (!blocks.contains(s)
-							&& !bn.contains(AFlag.SKIP)
+							&& !bn.contains(AFlag.ADDED_TO_REGION)
 							&& !s.contains(AFlag.FALL_THROUGH)) {
 						addBreak(mth, c, bn);
 						break;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -429,7 +429,7 @@ private static void markOneArgAsThis(RegisterArg arg) {
 			if (resArg.getRegNum() != arg.getRegNum()
 					&& !resArg.getSVar().isUsedInPhi()) {
 				markThisArgs(resArg);
-				parentInsn.add(AFlag.SKIP);
+				parentInsn.add(AFlag.DONT_GENERATE);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -74,7 +74,7 @@ public static BlockNode selectOtherSafe(BlockNode node, List<BlockNode> blocks)
 	}
 
 	public static boolean isBlockMustBeCleared(BlockNode b) {
-		if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.SKIP)) {
+		if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.REMOVE)) {
 			return true;
 		}
 		if (b.contains(AFlag.SYNTHETIC)) {
@@ -495,7 +495,7 @@ public static void skipPredSyntheticPaths(BlockNode block) {
 			if (pred.contains(AFlag.SYNTHETIC)
 					&& !pred.contains(AType.SPLITTER_BLOCK)
 					&& pred.getInstructions().isEmpty()) {
-				pred.add(AFlag.SKIP);
+				pred.add(AFlag.DONT_GENERATE);
 				skipPredSyntheticPaths(pred);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExcHandlerAttr.java
Patch:
@@ -30,6 +30,6 @@ public ExceptionHandler getHandler() {
 	public String toString() {
 		return "ExcHandler: " + (handler.isFinally()
 				? " FINALLY"
-				: (handler.isCatchAll() ? "all" : handler.getCatchType()) + " " + handler.getArg());
+				: handler.catchTypeStr() + " " + handler.getArg());
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -343,7 +343,7 @@ private static void processMoveException(BlockNode block, InsnNode insn, Instruc
 
 		// result arg used both in this insn and exception handler,
 		RegisterArg resArg = insn.getResult();
-		ArgType type = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();
+		ArgType type = excHandler.getArgType();
 		String name = excHandler.isCatchAll() ? "th" : "e";
 		if (resArg.getName() == null) {
 			resArg.setName(name);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java
Patch:
@@ -48,7 +48,7 @@ private static void markExceptionHandlers(BlockNode block) {
 			return;
 		}
 		ExceptionHandler excHandler = handlerAttr.getHandler();
-		ArgType argType = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();
+		ArgType argType = excHandler.getArgType();
 		if (!block.getInstructions().isEmpty()) {
 			InsnNode me = block.getInstructions().get(0);
 			if (me.getType() == InsnType.MOVE_EXCEPTION) {

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -57,7 +57,7 @@ public List<ResContainer> makeResourcesXml() {
 			content.decIndent();
 			content.startLine("</resources>");
 			content.finish();
-			files.add(ResContainer.singleFile(fileName, content));
+			files.add(ResContainer.textResource(fileName, content));
 		}
 		Collections.sort(files);
 		return files;

File: jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitivesInIf.java
Patch:
@@ -37,7 +37,6 @@ public void test() {
 
 	@Test
 	public void test2() {
-		setOutputCFG();
 		noDebugInfo();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -150,7 +150,6 @@ public boolean loadWindowPos(Window window) {
 		return true;
 	}
 
-
 	public boolean isShowHeapUsageBar() {
 		return showHeapUsageBar;
 	}

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -21,7 +21,7 @@ public class JadxSettingsAdapter {
 
 	private static final Preferences PREFS = Preferences.userNodeForPackage(JadxGUI.class);
 
-	private static ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {
+	private static final ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {
 		@Override
 		public boolean shouldSkipField(FieldAttributes f) {
 			return JadxSettings.SKIP_FIELDS.contains(f.getName())

File: jadx-gui/src/main/java/jadx/gui/treemodel/JSources.java
Patch:
@@ -85,7 +85,7 @@ List<JPackage> getHierarchyPackages(List<JavaPackage> packages) {
 			}
 		}
 		// use identity set for collect inner packages
-		Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<JPackage, Boolean>());
+		Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<>());
 		for (JPackage pkg : pkgMap.values()) {
 			innerPackages.addAll(pkg.getInnerPackages());
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/MainDropTarget.java
Patch:
@@ -59,7 +59,7 @@ public void drop(DropTargetDropEvent dtde) {
 		try {
 			Transferable transferable = dtde.getTransferable();
 			List<File> transferData = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);
-			if (transferData != null && transferData.size() > 0) {
+			if (!transferData.isEmpty()) {
 				dtde.dropComplete(true);
 				// load first file
 				mainWindow.openFile(transferData.get(0));

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -176,6 +176,7 @@ private void searchFieldSubscribe() {
 				.subscribeOn(Schedulers.single())
 				.doOnNext(r -> LOG.debug("search event: {}", r))
 				.switchMap(text -> prepareSearch(text)
+						.doOnError(e -> LOG.error("Error prepare search: {}", e.getMessage(), e))
 						.subscribeOn(Schedulers.single())
 						.toList()
 						.toFlowable(), 1)

File: jadx-gui/src/main/java/jadx/gui/utils/CodeLinesInfo.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.api.JavaNode;
 
 public class CodeLinesInfo {
-	private NavigableMap<Integer, JavaNode> map = new TreeMap<>();
+	private final NavigableMap<Integer, JavaNode> map = new TreeMap<>();
 
 	public CodeLinesInfo(JavaClass cls) {
 		addClass(cls);

File: jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java
Patch:
@@ -5,7 +5,7 @@
 
 public class JumpManager {
 
-	private List<JumpPosition> list = new ArrayList<>();
+	private final List<JumpPosition> list = new ArrayList<>();
 	private int currentPos = 0;
 
 	public void addPosition(JumpPosition pos) {

File: jadx-gui/src/main/java/jadx/gui/utils/LangLocale.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Locale;
 
 public class LangLocale {
-	private Locale locale;
+	private final Locale locale;
 
 	public LangLocale(Locale locale) {
 		this.locale = locale;

File: jadx-gui/src/main/java/jadx/gui/utils/Link.java
Patch:
@@ -16,7 +16,7 @@ public class Link extends JLabel implements MouseListener {
 
 	private static final Logger LOG = LoggerFactory.getLogger(Link.class);
 
-	private String url;
+	private final String url;
 
 	public Link(String text, String url) {
 		super(text);

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -176,6 +176,7 @@ private void searchFieldSubscribe() {
 				.subscribeOn(Schedulers.single())
 				.doOnNext(r -> LOG.debug("search event: {}", r))
 				.switchMap(text -> prepareSearch(text)
+						.doOnError(e -> LOG.error("Error prepare search: {}", e.getMessage(), e))
 						.subscribeOn(Schedulers.single())
 						.toList()
 						.toFlowable(), 1)

File: jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java
Patch:
@@ -57,7 +57,7 @@ public List<ResContainer> makeResourcesXml() {
 			content.decIndent();
 			content.startLine("</resources>");
 			content.finish();
-			files.add(ResContainer.singleFile(fileName, content));
+			files.add(ResContainer.textResource(fileName, content));
 		}
 		Collections.sort(files);
 		return files;

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -10,6 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.api.JadxArgs;
 import jadx.api.JadxDecompiler;
 import jadx.api.JavaClass;
 import jadx.api.JavaPackage;
@@ -105,7 +106,7 @@ public File getOpenFile() {
 		return openFile;
 	}
 
-	public JadxSettings getSettings() {
-		return settings;
+	public JadxArgs getArgs() {
+		return decompiler.getArgs();
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -150,7 +150,6 @@ public boolean loadWindowPos(Window window) {
 		return true;
 	}
 
-
 	public boolean isShowHeapUsageBar() {
 		return showHeapUsageBar;
 	}

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -21,7 +21,7 @@ public class JadxSettingsAdapter {
 
 	private static final Preferences PREFS = Preferences.userNodeForPackage(JadxGUI.class);
 
-	private static ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {
+	private static final ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {
 		@Override
 		public boolean shouldSkipField(FieldAttributes f) {
 			return JadxSettings.SKIP_FIELDS.contains(f.getName())

File: jadx-gui/src/main/java/jadx/gui/treemodel/JSources.java
Patch:
@@ -85,7 +85,7 @@ List<JPackage> getHierarchyPackages(List<JavaPackage> packages) {
 			}
 		}
 		// use identity set for collect inner packages
-		Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<JPackage, Boolean>());
+		Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<>());
 		for (JPackage pkg : pkgMap.values()) {
 			innerPackages.addAll(pkg.getInnerPackages());
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -33,14 +33,14 @@
 import jadx.gui.treemodel.JNode;
 import jadx.gui.ui.codearea.CodeArea;
 import jadx.gui.utils.CacheObject;
-import jadx.gui.utils.NLS;
 import jadx.gui.utils.JumpPosition;
+import jadx.gui.utils.NLS;
 import jadx.gui.utils.search.TextSearchIndex;
 
 public abstract class CommonSearchDialog extends JDialog {
+	private static final long serialVersionUID = 8939332306115370276L;
 
 	private static final Logger LOG = LoggerFactory.getLogger(CommonSearchDialog.class);
-	private static final long serialVersionUID = 8939332306115370276L;
 
 	public static final int RESULTS_PER_PAGE = 100;
 
@@ -399,7 +399,7 @@ protected class ResultsTableCellRenderer implements TableCellRenderer {
 		private final JLabel emptyLabel = new JLabel();
 		private final Color codeSelectedColor;
 		private final Color codeBackground;
-		private Map<Integer, Component> componentCache = new HashMap<>();
+		private final Map<Integer, Component> componentCache = new HashMap<>();
 
 		public ResultsTableCellRenderer() {
 			RSyntaxTextArea area = CodeArea.getDefaultArea(mainWindow);

File: jadx-gui/src/main/java/jadx/gui/ui/MainDropTarget.java
Patch:
@@ -59,7 +59,7 @@ public void drop(DropTargetDropEvent dtde) {
 		try {
 			Transferable transferable = dtde.getTransferable();
 			List<File> transferData = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);
-			if (transferData != null && transferData.size() > 0) {
+			if (!transferData.isEmpty()) {
 				dtde.dropComplete(true);
 				// load first file
 				mainWindow.openFile(transferData.get(0));

File: jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java
Patch:
@@ -21,8 +21,8 @@ public class CertificateManager {
 	private static final Logger LOG = LoggerFactory.getLogger(CertificateManager.class);
 	private static final String CERTIFICATE_TYPE_NAME = "X.509";
 
+	private final Certificate cert;
 	private X509Certificate x509cert;
-	private Certificate cert;
 
 	public static String decode(InputStream in) {
 		StringBuilder strBuild = new StringBuilder();

File: jadx-gui/src/main/java/jadx/gui/utils/CodeLinesInfo.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.api.JavaNode;
 
 public class CodeLinesInfo {
-	private NavigableMap<Integer, JavaNode> map = new TreeMap<>();
+	private final NavigableMap<Integer, JavaNode> map = new TreeMap<>();
 
 	public CodeLinesInfo(JavaClass cls) {
 		addClass(cls);

File: jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java
Patch:
@@ -5,7 +5,7 @@
 
 public class JumpManager {
 
-	private List<JumpPosition> list = new ArrayList<>();
+	private final List<JumpPosition> list = new ArrayList<>();
 	private int currentPos = 0;
 
 	public void addPosition(JumpPosition pos) {

File: jadx-gui/src/main/java/jadx/gui/utils/LangLocale.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Locale;
 
 public class LangLocale {
-	private Locale locale;
+	private final Locale locale;
 
 	public LangLocale(Locale locale) {
 		this.locale = locale;

File: jadx-gui/src/main/java/jadx/gui/utils/Link.java
Patch:
@@ -16,7 +16,7 @@ public class Link extends JLabel implements MouseListener {
 
 	private static final Logger LOG = LoggerFactory.getLogger(Link.class);
 
-	private String url;
+	private final String url;
 
 	public Link(String text, String url) {
 		super(text);

File: jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.gui.ui;
 
 import jadx.gui.utils.NLS;
+import jadx.gui.utils.Utils;
 
 import javax.swing.*;
 import java.awt.*;
@@ -44,7 +45,7 @@ public void update() {
 		setValue(usedKB);
 		setString(String.format(textFormat, (usedKB / TWO_TO_20), maxGB));
 
-		if (used > r.maxMemory() * 0.8) {
+		if ((used + Utils.MIN_FREE_MEMORY) > r.maxMemory()) {
 			setForeground(RED);
 		} else {
 			setForeground(GREEN);

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExcHandlerAttr.java
Patch:
@@ -30,6 +30,6 @@ public ExceptionHandler getHandler() {
 	public String toString() {
 		return "ExcHandler: " + (handler.isFinally()
 				? " FINALLY"
-				: (handler.isCatchAll() ? "all" : handler.getCatchType()) + " " + handler.getArg());
+				: handler.catchTypeStr() + " " + handler.getArg());
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -438,7 +438,7 @@ private static void processMoveException(BlockNode block, InsnNode insn, Instruc
 
 		// result arg used both in this insn and exception handler,
 		RegisterArg resArg = insn.getResult();
-		ArgType type = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();
+		ArgType type = excHandler.getArgType();
 		String name = excHandler.isCatchAll() ? "th" : "e";
 		if (resArg.getName() == null) {
 			resArg.setName(name);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java
Patch:
@@ -48,7 +48,7 @@ private static void markExceptionHandlers(BlockNode block) {
 			return;
 		}
 		ExceptionHandler excHandler = handlerAttr.getHandler();
-		ArgType argType = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();
+		ArgType argType = excHandler.getArgType();
 		if (!block.getInstructions().isEmpty()) {
 			InsnNode me = block.getInstructions().get(0);
 			if (me.getType() == InsnType.MOVE_EXCEPTION) {

File: jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java
Patch:
@@ -35,7 +35,7 @@ public HeapUsageBar() {
 		setMaximum(maxKB);
 		maxGB = maxKB / TWO_TO_20;
 		update();
-		timer = new Timer(1000, this);
+		timer = new Timer(2000, this);
 	}
 
 	public void update() {
@@ -44,7 +44,7 @@ public void update() {
 		setValue(usedKB);
 		setString(String.format(textFormat, (usedKB / TWO_TO_20), maxGB));
 
-		if (used > r.totalMemory() * 0.8) {
+		if (used > r.maxMemory() * 0.8) {
 			setForeground(RED);
 		} else {
 			setForeground(GREEN);

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -695,7 +695,7 @@ private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num)
 	private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {
 		ArgType origType;
 		List<RegisterArg> arguments = callMth.getArguments(false);
-		if (arguments.isEmpty()) {
+		if (arguments == null || arguments.isEmpty()) {
 			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");
 			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);
 		} else {

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.Utils;
 
-public class InvokeNode extends InsnNode {
+public class InvokeNode extends InsnNode implements CallMthInterface {
 
 	private final InvokeType type;
 	private final MethodInfo mth;

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -2,13 +2,14 @@
 
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.info.MethodInfo;
+import jadx.core.dex.instructions.CallMthInterface;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.InvokeNode;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 
-public class ConstructorInsn extends InsnNode {
+public class ConstructorInsn extends InsnNode implements CallMthInterface {
 
 	private final MethodInfo callMth;
 	private final CallType callType;

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundJob.java
Patch:
@@ -44,7 +44,7 @@ public ShutdownTask() {
 				public Boolean call() throws Exception {
 					runJob();
 					executor.shutdown();
-					return executor.awaitTermination(5, TimeUnit.MINUTES);
+					return executor.awaitTermination(5, TimeUnit.DAYS);
 				}
 			});
 		}

File: jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java
Patch:
@@ -10,7 +10,7 @@ public DecompileJob(JadxWrapper wrapper, int threadsCount) {
 	}
 
 	protected void runJob() {
-		for (final JavaClass cls : wrapper.getClasses()) {
+		for (final JavaClass cls : wrapper.getIncludedClasses()) {
 			addTask(new Runnable() {
 				@Override
 				public void run() {

File: jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java
Patch:
@@ -33,7 +33,7 @@ protected void runJob() {
 		final CodeUsageInfo usageInfo = new CodeUsageInfo(nodeCache);
 		cache.setTextIndex(index);
 		cache.setUsageInfo(usageInfo);
-		for (final JavaClass cls : wrapper.getClasses()) {
+		for (final JavaClass cls : wrapper.getIncludedClasses()) {
 			addTask(new Runnable() {
 				@Override
 				public void run() {

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -180,6 +180,7 @@ private void searchFieldSubscribe() {
 						.toList()
 						.toFlowable(), 1)
 				.observeOn(SwingSchedulers.edt())
+				.doOnError(e -> LOG.error("Error while searching: {}", e.getMessage(), e))
 				.subscribe(this::processSearchResults);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java
Patch:
@@ -23,7 +23,7 @@ public void put(String str, T value) {
 	}
 
 	@Override
-	public void put(StringRef str, T value) {
+	public synchronized void put(StringRef str, T value) {
 		if (str == null || str.length() == 0) {
 			return;
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -180,6 +180,7 @@ private void searchFieldSubscribe() {
 						.toList()
 						.toFlowable(), 1)
 				.observeOn(SwingSchedulers.edt())
+				.doOnError(e -> LOG.error("Error while searching: {}", e.getMessage(), e))
 				.subscribe(this::processSearchResults);
 	}
 

File: jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java
Patch:
@@ -23,7 +23,7 @@ public void put(String str, T value) {
 	}
 
 	@Override
-	public void put(StringRef str, T value) {
+	public synchronized void put(StringRef str, T value) {
 		if (str == null || str.length() == 0) {
 			return;
 		}

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -9,7 +9,7 @@
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.Utils;
 
-public class InvokeNode extends InsnNode {
+public class InvokeNode extends InsnNode implements CallMthInterface {
 
 	private final InvokeType type;
 	private final MethodInfo mth;

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -2,13 +2,14 @@
 
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.info.MethodInfo;
+import jadx.core.dex.instructions.CallMthInterface;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.InvokeNode;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 
-public class ConstructorInsn extends InsnNode {
+public class ConstructorInsn extends InsnNode implements CallMthInterface {
 
 	private final MethodInfo callMth;
 	private final CallType callType;

File: jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java
Patch:
@@ -10,7 +10,7 @@ public DecompileJob(JadxWrapper wrapper, int threadsCount) {
 	}
 
 	protected void runJob() {
-		for (final JavaClass cls : wrapper.getClasses()) {
+		for (final JavaClass cls : wrapper.getIncludedClasses()) {
 			addTask(new Runnable() {
 				@Override
 				public void run() {

File: jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java
Patch:
@@ -33,7 +33,7 @@ protected void runJob() {
 		final CodeUsageInfo usageInfo = new CodeUsageInfo(nodeCache);
 		cache.setTextIndex(index);
 		cache.setUsageInfo(usageInfo);
-		for (final JavaClass cls : wrapper.getClasses()) {
+		for (final JavaClass cls : wrapper.getIncludedClasses()) {
 			addTask(new Runnable() {
 				@Override
 				public void run() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java
Patch:
@@ -181,7 +181,6 @@ private boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boun
 				return true;
 
 			case WIDER:
-			case WIDER_BY_GENERIC:
 				return bound.getBound() != BoundEnum.USE;
 
 			case NARROW:
@@ -190,6 +189,7 @@ private boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boun
 				}
 				return true;
 
+			case WIDER_BY_GENERIC:
 			case NARROW_BY_GENERIC:
 				// allow replace object to same object with known generic type
 				// due to incomplete information about external methods and fields

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundJob.java
Patch:
@@ -44,7 +44,7 @@ public ShutdownTask() {
 				public Boolean call() throws Exception {
 					runJob();
 					executor.shutdown();
-					return executor.awaitTermination(5, TimeUnit.MINUTES);
+					return executor.awaitTermination(5, TimeUnit.DAYS);
 				}
 			});
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -60,7 +60,7 @@ public void visit(MethodNode mth) {
 			if (type != null && !type.isTypeKnown()) {
 				boolean changed = tryAllTypes(var, type);
 				if (!changed) {
-					mth.addComment("JADX WARNING: type inference failed for: " + var + ", bounds: " + typeInfo.getBounds());
+					mth.addComment("JADX WARNING: type inference failed for: " + var.getDetailedVarInfo(mth));
 				}
 			}
 		});

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -409,6 +409,9 @@ private String getFieldAlias(FieldNode field) {
 	@Nullable
 	private String getMethodAlias(MethodNode mth) {
 		MethodInfo methodInfo = mth.getMethodInfo();
+		if (methodInfo.isClassInit() || methodInfo.isConstructor()) {
+			return null;
+		}
 		String alias = mthMap.get(methodInfo);
 		if (alias != null) {
 			return alias;

File: jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java
Patch:
@@ -23,6 +23,6 @@ public AType<SplitterBlockAttr> getType() {
 
 	@Override
 	public String toString() {
-		return "Splitter: " + block;
+		return "Splitter:" + block;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java
Patch:
@@ -26,7 +26,7 @@ public void visit(MethodNode mth) {
 
 		for (BlockNode block : mth.getBasicBlocks()) {
 			block.updateCleanSuccessors();
-			fixSplitterBlock(block);
+			fixSplitterBlock(mth, block);
 		}
 
 		mth.finishBasicBlocks();
@@ -36,7 +36,7 @@ public void visit(MethodNode mth) {
 	 * For evey exception handler must be only one splitter block,
 	 * select correct one and remove others if necessary.
 	 */
-	private static void fixSplitterBlock(BlockNode block) {
+	private static void fixSplitterBlock(MethodNode mth, BlockNode block) {
 		ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);
 		if (excHandlerAttr == null) {
 			return;
@@ -58,7 +58,7 @@ private static void fixSplitterBlock(BlockNode block) {
 		}
 		BlockNode topSplitter = BlockUtils.getTopBlock(splitters.keySet());
 		if (topSplitter == null) {
-			LOG.warn("Unknown top splitter block from list: {}", splitters);
+			mth.addWarn("Unknown top exception splitter block from list: " + splitters);
 			return;
 		}
 		for (Map.Entry<BlockNode, SplitterBlockAttr> entry : splitters.entrySet()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -60,7 +60,7 @@ public void processBlock(MethodNode mth, IBlock container) {
 						&& !block.getInstructions().isEmpty()
 						&& !block.contains(AFlag.SKIP)) {
 					String blockCode = getBlockInsnStr(mth, block);
-					mth.addWarn("Missing block: " + block + ", code:" + CodeWriter.NL + blockCode);
+					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java
Patch:
@@ -409,6 +409,9 @@ private String getFieldAlias(FieldNode field) {
 	@Nullable
 	private String getMethodAlias(MethodNode mth) {
 		MethodInfo methodInfo = mth.getMethodInfo();
+		if (methodInfo.isClassInit() || methodInfo.isConstructor()) {
+			return null;
+		}
 		String alias = mthMap.get(methodInfo);
 		if (alias != null) {
 			return alias;

File: jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java
Patch:
@@ -8,7 +8,7 @@ public class CodegenUtils {
 
 	public static void addComments(CodeWriter code, AttrNode node) {
 		for (String comment : node.getAll(AType.COMMENTS)) {
-			code.startLine("/* ").add(comment).add(" */");
+			code.startLine("/* ").addMultiLine(comment).add(" */");
 		}
 	}
 }

File: jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java
Patch:
@@ -112,7 +112,7 @@ private void dumpMapping() throws IOException {
 		for (DeobfClsInfo deobfClsInfo : deobfuscator.getClsMap().values()) {
 			if (deobfClsInfo.getAlias() != null) {
 				list.add(String.format("c %s = %s",
-						deobfClsInfo.getCls().getClassInfo().getFullName(), deobfClsInfo.getAlias()));
+						deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));
 			}
 		}
 		for (FieldInfo fld : deobfuscator.getFldMap().keySet()) {
@@ -136,7 +136,7 @@ private static void dfsPackageName(List<String> list, String prefix, PackageNode
 	}
 
 	public String getForCls(ClassInfo cls) {
-		return clsPresetMap.get(cls.getFullName());
+		return clsPresetMap.get(cls.makeRawFullName());
 	}
 
 	public String getForFld(FieldInfo fld) {

File: jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java
Patch:
@@ -112,7 +112,7 @@ private void dumpMapping() throws IOException {
 		for (DeobfClsInfo deobfClsInfo : deobfuscator.getClsMap().values()) {
 			if (deobfClsInfo.getAlias() != null) {
 				list.add(String.format("c %s = %s",
-						deobfClsInfo.getCls().getClassInfo().getFullName(), deobfClsInfo.getAlias()));
+						deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));
 			}
 		}
 		for (FieldInfo fld : deobfuscator.getFldMap().keySet()) {
@@ -136,7 +136,7 @@ private static void dfsPackageName(List<String> list, String prefix, PackageNode
 	}
 
 	public String getForCls(ClassInfo cls) {
-		return clsPresetMap.get(cls.getFullName());
+		return clsPresetMap.get(cls.makeRawFullName());
 	}
 
 	public String getForFld(FieldInfo fld) {

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -694,7 +694,7 @@ private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num)
 	 * Add additional cast for overloaded method argument.
 	 */
 	private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {
-		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);
+		ArgType origType = callMth.getArguments(false).get(origPos).getInitType();
 		if (!arg.getType().equals(origType)) {
 			code.add('(');
 			useType(code, origType);

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java
Patch:
@@ -193,9 +193,6 @@ public ArgTypeComparator getComparator() {
 		return comparator;
 	}
 
-	/**
-	 *
-	 */
 	private final class ArgTypeComparator implements Comparator<ArgType> {
 		@Override
 		public int compare(ArgType a, ArgType b) {

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java
Patch:
@@ -19,6 +19,9 @@ public int test() {
 			File output = null;
 			try {
 				output = File.createTempFile("f", "a", dir);
+				if (!output.exists()) {
+					return 1;
+				}
 				return 0;
 			} catch (Exception e) {
 				if (output != null) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java
Patch:
@@ -10,6 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import jadx.core.Consts;
 import jadx.core.dex.instructions.IndexInsnNode;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.LiteralArg;
@@ -67,7 +68,7 @@ private void setBestType(SSAVar ssaVar) {
 			if (assignArg.isTypeImmutable()) {
 				ArgType initType = assignArg.getInitType();
 				TypeUpdateResult result = typeUpdate.apply(ssaVar, initType);
-				if (result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {
+				if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {
 					LOG.debug("Initial immutable type set rejected: {} -> {}", ssaVar, initType);
 				}
 			} else {
@@ -85,7 +86,7 @@ private void calculateFromBounds(SSAVar ssaVar) {
 		if (bestTypeOpt.isPresent()) {
 			ArgType candidateType = bestTypeOpt.get();
 			TypeUpdateResult result = typeUpdate.apply(ssaVar, candidateType);
-			if (result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {
+			if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {
 				if (ssaVar.getTypeInfo().getType().equals(candidateType)) {
 					LOG.warn("Same type rejected: {} -> {}, bounds: {}", ssaVar, candidateType, bounds);
 				} else {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java
Patch:
@@ -121,6 +121,6 @@ public String toString() {
 		if (list.isEmpty()) {
 			return "";
 		}
-		return "A:{" + Utils.listToString(list) + "}";
+		return "A[" + Utils.listToString(list) + "]";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -45,11 +45,10 @@ public ConstructorInsn(MethodNode mth, InvokeNode invoke) {
 			instanceArg.getSVar().setAssign(instanceArg);
 		}
 		instanceArg.getSVar().removeUse(instanceArg);
-		for (int i = 1; i < invoke.getArgsCount(); i++) {
+		int argsCount = invoke.getArgsCount();
+		for (int i = 1; i < argsCount; i++) {
 			addArg(invoke.getArg(i));
 		}
-		offset = invoke.getOffset();
-		setSourceLine(invoke.getSourceLine());
 	}
 
 	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java
Patch:
@@ -14,7 +14,7 @@ public class FieldNode extends LineAttrNode {
 	private final FieldInfo fieldInfo;
 	private final AccessInfo accFlags;
 
-	private ArgType type; // store signature
+	private ArgType type;
 
 	public FieldNode(ClassNode cls, Field field) {
 		this(cls, FieldInfo.fromDex(cls.dex(), field.getFieldIndex()),

File: jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java
Patch:
@@ -64,7 +64,9 @@ public List<IContainer> getSubBlocks() {
 	public List<IContainer> getBranches() {
 		List<IContainer> branches = new ArrayList<>(cases.size() + 1);
 		branches.addAll(cases);
-		branches.add(defCase);
+		if (defCase != null) {
+			branches.add(defCase);
+		}
 		return Collections.unmodifiableList(branches);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java
Patch:
@@ -507,7 +507,7 @@ private static boolean sameInsns(InsnNode remInsn, InsnNode fInsn, @Nullable Blo
 					RegisterArg mapReg = removeInfo.getRegMap().get(remArg);
 					if (mapReg == null) {
 						removeInfo.getRegMap().put(remReg, fReg);
-					} else if (!mapReg.equalRegisterAndType(fReg)) {
+					} else if (!mapReg.equalRegister(fReg)) {
 						return false;
 					}
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -87,7 +87,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion
 		PhiInsn phiInsn = incrArg.getSVar().getUsedInPhi();
 		if (phiInsn == null
 				|| phiInsn.getArgsCount() != 2
-				|| !phiInsn.getArg(1).equals(incrArg)
+				|| !phiInsn.containsArg(incrArg)
 				|| incrArg.getSVar().getUseCount() != 1) {
 			return false;
 		}
@@ -289,13 +289,13 @@ private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, Regi
 				iterVar.setType(gType);
 				return true;
 			}
-			if (ArgType.isInstanceOf(mth.dex(), gType, varType)) {
+			if (ArgType.isInstanceOf(mth.root(), gType, varType)) {
 				return true;
 			}
 			ArgType wildcardType = gType.getWildcardType();
 			if (wildcardType != null
 					&& gType.getWildcardBounds() == 1
-					&& ArgType.isInstanceOf(mth.dex(), wildcardType, varType)) {
+					&& ArgType.isInstanceOf(mth.root(), wildcardType, varType)) {
 				return true;
 			}
 			LOG.warn("Generic type differs: '{}' and '{}' in {}", gType, varType, mth);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.core.dex.visitors.ssa;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
@@ -106,12 +107,12 @@ private void replaceMerge(MethodNode mth, BlockNode block, InsnNode insn) {
 		RegisterArg newAssignArg = oldArg.duplicate(newRegNum, null);
 		SSAVar newSVar = mth.makeNewSVar(newRegNum, mth.getNextSVarVersion(newRegNum), newAssignArg);
 		newSVar.setName(oldSVar.getName());
-		newSVar.setType(assignArg.getType());
+		mth.root().getTypeUpdate().apply(newSVar, assignArg.getType());
 
 		if (assignParentInsn != null) {
 			assignParentInsn.setResult(newAssignArg);
 		}
-		for (RegisterArg useArg : oldSVar.getUseList()) {
+		for (RegisterArg useArg : new ArrayList<>(oldSVar.getUseList())) {
 			RegisterArg newUseArg = useArg.duplicate(newRegNum, newSVar);
 			InsnNode parentInsn = useArg.getParentInsn();
 			if (parentInsn != null) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -220,7 +220,7 @@ private static void fixPhiInTryCatch(PhiInsn phi) {
 			if (parentInsn != null
 					&& parentInsn.getResult() != null
 					&& parentInsn.contains(AFlag.TRY_LEAVE)
-					&& phi.removeArg(arg)) {
+					&& phi.removeArg(arg) /* TODO: fix registers removing*/) {
 				argsCount--;
 				continue;
 			}

File: jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java
Patch:
@@ -89,7 +89,7 @@ public static void fixUsedInPhiFlag(RegisterArg useReg) {
 
 	public static void unbindResult(MethodNode mth, InsnNode insn) {
 		RegisterArg r = insn.getResult();
-		if (r != null && r.getSVar() != null) {
+		if (r != null && r.getSVar() != null && mth != null) {
 			mth.removeSVar(r.getSVar());
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -53,7 +53,7 @@ public abstract class IntegrationTest extends TestUtils {
 	/**
 	 * Run auto check method if defined:
 	 * <pre>
-	 *     public static void check()
+	 *     public void check() {}
 	 * </pre>
 	 */
 	public static final String CHECK_METHOD_NAME = "check";

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary.java
Patch:
@@ -22,7 +22,7 @@ public void test2(int a) {
 		}
 
 		public int test3(int a) {
-			return a > 0 ? 1 : (a + 2) * 3;
+			return a > 0 ? a : (a + 2) * 3;
 		}
 	}
 
@@ -34,6 +34,6 @@ public void test() {
 		assertThat(code, not(containsString("else")));
 		assertThat(code, containsString("return a != 2;"));
 		assertThat(code, containsString("assertTrue(a == 3)"));
-		assertThat(code, containsString("return a > 0 ? 1 : (a + 2) * 3;"));
+		assertThat(code, containsString("return a > 0 ? a : (a + 2) * 3;"));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java
Patch:
@@ -3,10 +3,8 @@
 import org.junit.Test;
 
 import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
 import jadx.tests.api.SmaliTest;
 
-import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch7.java
Patch:
@@ -29,8 +29,8 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		String excVarName = "e";
-		String catchExcVarName = "e2";
+		String excVarName = "exception";
+		String catchExcVarName = "e";
 		assertThat(code, containsOne("Exception " + excVarName + " = new Exception();"));
 		assertThat(code, containsOne("} catch (Exception " + catchExcVarName + ") {"));
 		assertThat(code, containsOne(excVarName + " = " + catchExcVarName + ";"));

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -285,6 +285,7 @@ public boolean isDeepEquals(InsnNode other) {
 			return true;
 		}
 		return isSame(other)
+				&& Objects.equals(result, other.result)
 				&& Objects.equals(arguments, other.arguments);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -42,7 +42,8 @@ public boolean visit(ClassNode cls) throws JadxException {
 		}
 		if (cls.getAccessFlags().isSynthetic()
 				&& cls.getFields().isEmpty()
-				&& cls.getMethods().isEmpty()) {
+				&& cls.getMethods().isEmpty()
+				&& cls.getInnerClasses().isEmpty()) {
 			cls.add(AFlag.DONT_GENERATE);
 			return false;
 		}

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -340,7 +340,7 @@ public void actionPerformed(ActionEvent e) {
 				openFile();
 			}
 		};
-		openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open"));
+		openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open_action"));
 		openAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_O, KeyEvent.CTRL_DOWN_MASK));
 
 		Action saveAllAction = new AbstractAction(NLS.str("file.save_all"), ICON_SAVE_ALL) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java
Patch:
@@ -1,5 +1,5 @@
 package jadx.core.dex.attributes;
 
 public interface IAttribute {
-	AType<? extends IAttribute> getType();
+	<T extends IAttribute> AType<T> getType();
 }

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -276,7 +276,7 @@ private void upgradeSettings(int fromVersion) {
 			fromVersion++;
 		}
 		if (fromVersion == 1) {
-			setEditorThemePath(EditorTheme.ALL_THEMES[0].getPath());
+			setEditorThemePath(EditorTheme.getDefaultTheme().getPath());
 			fromVersion++;
 		}
 		if (fromVersion == 2) {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -190,7 +190,7 @@ public void mouseClicked(MouseEvent e) {
 			}
 		});
 
-		EditorTheme[] editorThemes = EditorTheme.ALL_THEMES;
+		EditorTheme[] editorThemes = EditorTheme.getAllThemes();
 		JComboBox<EditorTheme> themesCbx = new JComboBox<>(editorThemes);
 		for (EditorTheme theme : editorThemes) {
 			if (theme.getPath().equals(settings.getEditorThemePath())) {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -12,8 +12,8 @@
 import org.slf4j.LoggerFactory;
 import say.swing.JFontChooser;
 
-import jadx.gui.ui.codearea.EditorTheme;
 import jadx.gui.ui.MainWindow;
+import jadx.gui.ui.codearea.EditorTheme;
 import jadx.gui.utils.LangLocale;
 import jadx.gui.utils.NLS;
 
@@ -94,7 +94,7 @@ private void initUI() {
 					NLS.str("preferences.reset_title"),
 					JOptionPane.YES_NO_OPTION);
 			if (res == JOptionPane.YES_OPTION) {
-				String defaults = JadxSettingsAdapter.makeString(new JadxSettings());
+				String defaults = JadxSettingsAdapter.makeString(JadxSettings.makeDefault());
 				JadxSettingsAdapter.fill(settings, defaults);
 				getContentPane().removeAll();
 				initUI();

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -341,7 +341,7 @@ private void insertDecompilationProblems(CodeWriter code, AttrNode node) {
 			});
 		}
 		if (!warns.isEmpty()) {
-			warns.forEach(warn -> code.startLine("/* JADX WARNING: ").add(warn.getWarn()).add(" */"));
+			warns.forEach(warn -> code.startLine("/* JADX WARNING: ").addMultiLine(warn.getWarn()).add(" */"));
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/JadxGUI.java
Patch:
@@ -19,7 +19,7 @@ public static void main(String[] args) {
 			LogCollector.register();
 			final JadxSettings settings = JadxSettingsAdapter.load();
 			// overwrite loaded settings by command line arguments
-			if (!settings.processArgs(args)) {
+			if (!settings.overrideProvided(args)) {
 				return;
 			}
 			if (!tryDefaultLookAndFeel()) {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -182,7 +182,7 @@ public void mouseClicked(MouseEvent e) {
 				int result = fontChooser.showDialog(JadxSettingsWindow.this);
 				if (result == JFontChooser.OK_OPTION) {
 					Font font = fontChooser.getSelectedFont();
-					LOG.info("Selected Font : {}", font);
+					LOG.debug("Selected Font: {}", font);
 					settings.setFont(font);
 					mainWindow.updateFont(font);
 					mainWindow.loadSettings();

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -15,7 +15,7 @@
 
 import jadx.api.JadxArgs;
 import jadx.cli.JadxCLIArgs;
-import jadx.gui.ui.CodeArea;
+import jadx.gui.ui.codearea.EditorTheme;
 import jadx.gui.utils.LangLocale;
 import jadx.gui.utils.NLS;
 
@@ -263,7 +263,7 @@ private void upgradeSettings(int fromVersion) {
 			fromVersion++;
 		}
 		if (fromVersion == 1) {
-			setEditorThemePath(CodeArea.getAllThemes()[0].getPath());
+			setEditorThemePath(EditorTheme.ALL_THEMES[0].getPath());
 			fromVersion++;
 		}
 		if (fromVersion == 2) {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java
Patch:
@@ -12,8 +12,7 @@
 import org.slf4j.LoggerFactory;
 import say.swing.JFontChooser;
 
-import jadx.gui.ui.CodeArea;
-import jadx.gui.ui.CodeArea.EditorTheme;
+import jadx.gui.ui.codearea.EditorTheme;
 import jadx.gui.ui.MainWindow;
 import jadx.gui.utils.LangLocale;
 import jadx.gui.utils.NLS;
@@ -191,7 +190,7 @@ public void mouseClicked(MouseEvent e) {
 			}
 		});
 
-		EditorTheme[] editorThemes = CodeArea.getAllThemes();
+		EditorTheme[] editorThemes = EditorTheme.ALL_THEMES;
 		JComboBox<EditorTheme> themesCbx = new JComboBox<>(editorThemes);
 		for (EditorTheme theme : editorThemes) {
 			if (theme.getPath().equals(settings.getEditorThemePath())) {

File: jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java
Patch:
@@ -6,6 +6,7 @@
 import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
 
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.codearea.CodeArea;
 
 public final class CertificatePanel extends ContentPanel {
 	private static final long serialVersionUID = 8566591625905036877L;

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -31,9 +31,10 @@
 import jadx.gui.jobs.BackgroundWorker;
 import jadx.gui.jobs.DecompileJob;
 import jadx.gui.treemodel.JNode;
+import jadx.gui.ui.codearea.CodeArea;
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.NLS;
-import jadx.gui.utils.Position;
+import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.search.TextSearchIndex;
 
 public abstract class CommonSearchDialog extends JDialog {
@@ -106,7 +107,7 @@ protected void openSelectedItem() {
 			return;
 		}
 		JNode node = (JNode) resultsModel.getValueAt(selectedId, 0);
-		tabbedPane.codeJump(new Position(node.getRootClass(), node.getLine()));
+		tabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine()));
 
 		dispose();
 	}

File: jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java
Patch:
@@ -7,6 +7,7 @@
 import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
 
 import jadx.gui.settings.JadxSettings;
+import jadx.gui.ui.codearea.CodeArea;
 import jadx.gui.utils.NLS;
 import jadx.gui.utils.logs.ILogListener;
 import jadx.gui.utils.logs.LogCollector;

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -51,7 +51,7 @@
 import jadx.gui.utils.CacheObject;
 import jadx.gui.utils.Link;
 import jadx.gui.utils.NLS;
-import jadx.gui.utils.Position;
+import jadx.gui.utils.JumpPosition;
 import jadx.gui.utils.Utils;
 
 import static javax.swing.KeyStroke.getKeyStroke;
@@ -300,7 +300,7 @@ private void treeClickAction() {
 				JNode node = (JNode) obj;
 				JClass cls = node.getRootClass();
 				if (cls != null) {
-					tabbedPane.codeJump(new Position(cls, node.getLine()));
+					tabbedPane.codeJump(new JumpPosition(cls, node.getLine()));
 				}
 			}
 		} catch (Exception e) {

File: jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.gui.ui;
+package jadx.gui.ui.codearea;
 
 import javax.swing.*;
 import javax.swing.border.Border;

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -78,7 +78,7 @@ public boolean addDefinition(CodeWriter code) {
 			ai = ai.remove(AccessFlags.ACC_PUBLIC);
 		}
 
-		if (mth.getMethodInfo().isRenamed()) {
+		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {
 			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");
 		}
 		code.startLineWithNum(mth.getSourceLine());
@@ -87,7 +87,7 @@ public boolean addDefinition(CodeWriter code) {
 		if (classGen.addGenericMap(code, mth.getGenericMap())) {
 			code.add(' ');
 		}
-		if (mth.getAccessFlags().isConstructor()) {
+		if (ai.isConstructor()) {
 			code.attachDefinition(mth);
 			code.add(classGen.getClassNode().getShortName()); // constructor
 		} else {

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -79,12 +79,14 @@ public static boolean isReserved(String str) {
 
 	public static boolean isValidIdentifier(String str) {
 		return notEmpty(str)
+				&& !isReserved(str)
 				&& VALID_JAVA_IDENTIFIER.matcher(str).matches()
 				&& isAllCharsPrintable(str);
 	}
 
 	public static boolean isValidFullIdentifier(String str) {
 		return notEmpty(str)
+				&& !isReserved(str)
 				&& VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches()
 				&& isAllCharsPrintable(str);
 	}

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -175,12 +175,12 @@ private ExecutorService getSaveExecutor(boolean saveSources, boolean saveResourc
 			sourcesOutDir = args.getOutDirSrc();
 			resOutDir = args.getOutDirRes();
 		}
-		if (saveSources) {
-			appendSourcesSave(executor, sourcesOutDir);
-		}
 		if (saveResources) {
 			appendResourcesSave(executor, resOutDir);
 		}
+		if (saveSources) {
+			appendSourcesSave(executor, sourcesOutDir);
+		}
 		return executor;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -114,7 +114,7 @@ public void addRecentFile(String filePath) {
 		recentFiles.add(0, filePath);
 		int count = recentFiles.size();
 		if (count > RECENT_FILES_COUNT) {
-			recentFiles.subList(0, count - RECENT_FILES_COUNT).clear();
+			recentFiles.subList(RECENT_FILES_COUNT, count).clear();
 		}
 		sync();
 	}

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -36,6 +36,7 @@ public class AType<T extends IAttribute> {
 
 	public static final AType<AttrList<JadxError>> JADX_ERROR = new AType<>();
 	public static final AType<AttrList<JadxWarn>> JADX_WARN = new AType<>();
+	public static final AType<AttrList<String>> COMMENTS = new AType<>();
 
 	public static final AType<ExcHandlerAttr> EXC_HANDLER = new AType<>();
 	public static final AType<CatchAttr> CATCH_BLOCK = new AType<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -52,7 +52,7 @@ public boolean visit(ClassNode cls) throws JadxException {
 			}
 		}
 		if (staticMethod == null) {
-			ErrorsCounter.classError(cls, "Enum class init method not found");
+			ErrorsCounter.classWarn(cls, "Enum class init method not found");
 			return true;
 		}
 

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -74,8 +74,8 @@ public static String classError(ClassNode cls, String errorMsg, Throwable e) {
 		return cls.dex().root().getErrorsCounter().addError(cls, errorMsg, e);
 	}
 
-	public static String classError(ClassNode cls, String errorMsg) {
-		return classError(cls, errorMsg, null);
+	public static String classWarn(ClassNode cls, String warnMsg) {
+		return cls.dex().root().getErrorsCounter().addWarning(cls, warnMsg);
 	}
 
 	public static String methodError(MethodNode mth, String errorMsg, Throwable e) {

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -91,7 +91,6 @@ public void load() {
 
 		root.initClassPath();
 		root.loadResources(getResources());
-		root.initAppResClass();
 
 		initVisitors();
 	}

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -42,7 +42,7 @@
  * jadx.load();
  * jadx.save();
  * </code></pre>
- *
+ * <p>
  * Instead of 'save()' you can iterate over decompiled classes:
  * <pre><code>
  *  for(JavaClass cls : jadx.getClasses()) {

File: jadx-core/src/main/java/jadx/api/ResourceFile.java
Patch:
@@ -65,9 +65,9 @@ public ZipRef getZipRef() {
 	public String toString() {
 		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";
 	}
-	
+
 	public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {
-		if(!ZipSecurity.isValidZipEntryName(name)) {
+		if (!ZipSecurity.isValidZipEntryName(name)) {
 			return null;
 		}
 		return new ResourceFile(decompiler, name, type);

File: jadx-core/src/main/java/jadx/api/ResourceFileContent.java
Patch:
@@ -17,9 +17,9 @@ private ResourceFileContent(String name, ResourceType type, CodeWriter content)
 	public ResContainer loadContent() {
 		return ResContainer.singleFile(getName(), content);
 	}
-	
+
 	public static ResourceFileContent createResourceFileContentInstance(String name, ResourceType type, CodeWriter content) {
-		if(!ZipSecurity.isValidZipEntryName(name)) {
+		if (!ZipSecurity.isValidZipEntryName(name)) {
 			return null;
 		}
 		return new ResourceFileContent(name, type, content);

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -100,7 +100,7 @@ private static ResContainer loadContent(JadxDecompiler jadxRef, ResourceFile rf,
 
 			case ARSC:
 				return new ResTableParser()
-					.decodeFiles(inputStream);
+						.decodeFiles(inputStream);
 
 			case IMG:
 				return ResContainer.singleImageFile(rf.getName(), inputStream);

File: jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java
Patch:
@@ -289,14 +289,14 @@ public String toString() {
 	}
 
 	public void save(File dir, String subDir, String fileName) {
-		if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {
+		if (!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {
 			return;
 		}
 		save(dir, new File(subDir, fileName).getPath());
 	}
 
 	public void save(File dir, String fileName) {
-		if(!ZipSecurity.isValidZipEntryName(fileName)) {
+		if (!ZipSecurity.isValidZipEntryName(fileName)) {
 			return;
 		}
 		save(new File(dir, fileName));

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -659,7 +659,7 @@ private void makeInvoke(InvokeNode insn, CodeWriter code) throws CodegenExceptio
 	}
 
 	void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,
-			@Nullable MethodNode callMth) throws CodegenException {
+	                             @Nullable MethodNode callMth) throws CodegenException {
 		int k = startArgNum;
 		if (callMth != null && callMth.contains(AFlag.SKIP_FIRST_ARG)) {
 			k++;

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java
Patch:
@@ -44,5 +44,4 @@ public Object getDefaultValue() {
 	public String toString() {
 		return "Annotation[" + visibility + ", " + atype + ", " + values + "]";
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java
Patch:
@@ -48,5 +48,4 @@ public AType<AnnotationsList> getType() {
 	public String toString() {
 		return Utils.listToString(map.values());
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java
Patch:
@@ -28,5 +28,4 @@ public AType<MethodParameters> getType() {
 	public String toString() {
 		return Utils.listToString(paramList);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java
Patch:
@@ -78,5 +78,4 @@ public AType<EnumClassAttr> getType() {
 	public String toString() {
 		return "Enum fields: " + fields;
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ForceReturnAttr.java
Patch:
@@ -26,5 +26,4 @@ public AType<ForceReturnAttr> getType() {
 	public String toString() {
 		return "FORCE_RETURN " + Utils.listToString(returnInsn.getArguments());
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java
Patch:
@@ -146,5 +146,4 @@ public String toString() {
 		return declClass.getFullName() + "." + name
 				+ "(" + Utils.listToString(args) + "):" + retType;
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java
Patch:
@@ -80,5 +80,4 @@ public String toString() {
 				+ op.getSymbol() + " "
 				+ getArg(1);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/NamedArg.java
Patch:
@@ -35,7 +35,6 @@ public boolean equals(Object o) {
 			return false;
 		}
 		return name.equals(((NamedArg) o).name);
-
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/nodes/Edge.java
Patch:
@@ -27,7 +27,6 @@ public boolean equals(Object o) {
 		}
 		Edge edge = (Edge) o;
 		return source.equals(edge.source) && target.equals(edge.target);
-
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java
Patch:
@@ -9,5 +9,4 @@ public interface IBranchRegion extends IRegion {
 	 * NOTE: Contains 'null' elements for indicate empty branches.
 	 */
 	List<IContainer> getBranches();
-
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -276,6 +276,7 @@ public boolean isSame(InsnNode other) {
 		}
 		return true;
 	}
+
 	/**
 	 * 'Hard' equals, compare all arguments
 	 */

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java
Patch:
@@ -24,7 +24,7 @@ public IfInfo(IfInfo info, BlockNode thenBlock, BlockNode elseBlock) {
 	}
 
 	private IfInfo(IfCondition condition, BlockNode thenBlock, BlockNode elseBlock,
-			Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {
+	               Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {
 		this.condition = condition;
 		this.thenBlock = thenBlock;
 		this.elseBlock = elseBlock;

File: jadx-core/src/main/java/jadx/core/dex/trycatch/CatchAttr.java
Patch:
@@ -24,5 +24,4 @@ public TryCatchBlock getTryBlock() {
 	public String toString() {
 		return tryBlock.toString();
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java
Patch:
@@ -120,5 +120,4 @@ public String toString() {
 		return (catchType == null ? "all"
 				: catchType.getShortName()) + " -> " + InsnUtils.formatOffset(handleOffset);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java
Patch:
@@ -25,5 +25,4 @@ public AType<SplitterBlockAttr> getType() {
 	public String toString() {
 		return "Splitter: " + block;
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java
Patch:
@@ -260,7 +260,7 @@ private static boolean inline(RegisterArg arg, InsnNode insn, BlockNode block) {
 	}
 
 	private static boolean canMoveBetweenBlocks(InsnNode assignInsn, BlockNode assignBlock,
-			BlockNode useBlock, InsnNode useInsn) {
+	                                            BlockNode useBlock, InsnNode useInsn) {
 		if (!BlockUtils.isPathExists(assignBlock, useBlock)) {
 			return false;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -207,7 +207,6 @@ private static InsnNode convertInvoke(MethodNode mth, InsnNode insn) {
 						return concatInsn;
 					} // end of if constructor is for StringBuilder
 				} // end of if we found a constructor early in the chain
-
 			} catch (Exception e) {
 				LOG.warn("Can't convert string concatenation: {} insn: {}", mth, insn, e);
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java
Patch:
@@ -18,5 +18,4 @@ public void processBlock(MethodNode mth, IBlock container) {
 	@Override
 	public void leaveRegion(MethodNode mth, IRegion region) {
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java
Patch:
@@ -61,7 +61,7 @@ private static void traverseInternal(MethodNode mth, IRegionVisitor visitor, ICo
 	}
 
 	private static boolean traverseIterativeStepInternal(MethodNode mth, IRegionIterativeVisitor visitor,
-			IContainer container) {
+	                                                     IContainer container) {
 		if (container instanceof IRegion) {
 			IRegion region = (IRegion) container;
 			if (visitor.visitRegion(mth, region)) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IRegionIterativeVisitor.java
Patch:
@@ -9,5 +9,4 @@ public interface IRegionIterativeVisitor {
 	 * If return 'true' traversal will be restarted.
 	 */
 	boolean visitRegion(MethodNode mth, IRegion region);
-
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IRegionVisitor.java
Patch:
@@ -14,5 +14,4 @@ public interface IRegionVisitor {
 	boolean enterRegion(MethodNode mth, IRegion region);
 
 	void leaveRegion(MethodNode mth, IRegion region);
-
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -126,7 +126,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion
 	}
 
 	private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, InsnNode incrInsn,
-			IfCondition condition) {
+	                                          IfCondition condition) {
 		if (!(incrInsn instanceof ArithNode)) {
 			return null;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/SelectTypeVisitor.java
Patch:
@@ -27,5 +27,4 @@ private static void selectType(DexNode dex, InsnArg arg) {
 		ArgType newType = ArgType.merge(dex, t, t.selectFirst());
 		arg.setType(newType);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/utils/StringUtils.java
Patch:
@@ -149,7 +149,7 @@ public static String escapeResStrValue(String str) {
 	}
 
 	private static String escapeXmlChar(char c) {
-		if(c >= 0 && c <= 0x1F) {
+		if (c >= 0 && c <= 0x1F) {
 			return "\\" + (int) c;
 		}
 		switch (c) {

File: jadx-core/src/main/java/jadx/core/utils/exceptions/CodegenException.java
Patch:
@@ -30,5 +30,4 @@ public CodegenException(MethodNode mth, String msg) {
 	public CodegenException(MethodNode mth, String msg, Throwable th) {
 		super(mth, msg, th);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/utils/exceptions/DecodeException.java
Patch:
@@ -21,5 +21,4 @@ public DecodeException(MethodNode mth, String msg) {
 	public DecodeException(MethodNode mth, String msg, Throwable th) {
 		super(mth, msg, th);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/utils/exceptions/JadxException.java
Patch:
@@ -23,5 +23,4 @@ public JadxException(ClassNode cls, String msg, Throwable th) {
 	public JadxException(MethodNode mth, String msg, Throwable th) {
 		super(ErrorsCounter.formatMsg(mth, msg), th);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -74,7 +74,9 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep
 			}
 			return;
 		}
-		if (skipSources) return;
+		if (skipSources) {
+			return;
+		}
 
 		throw new DecodeException("Unsupported input file format: " + file);
 	}

File: jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java
Patch:
@@ -24,13 +24,12 @@ private static boolean isInSubDirectoryInternal(File baseDir, File canonFile) {
 		}
 		return isInSubDirectoryInternal(baseDir, canonFile.getParentFile());
 	}
-	
+
 	public static boolean isInSubDirectory(File baseDir, File file) {
 		try {
 			file = file.getCanonicalFile();
 			baseDir = baseDir.getCanonicalFile();
-		}
-		catch(IOException e) {
+		} catch (IOException e) {
 			return false;
 		}
 		return isInSubDirectoryInternal(baseDir, file);

File: jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java
Patch:
@@ -96,5 +96,4 @@ protected void die(String message) throws IOException {
 		throw new IOException("Decode error: " + message
 				+ ", position: 0x" + Long.toHexString(is.getPos()));
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -8,7 +8,6 @@ public class ParserConstants {
 	protected ParserConstants() {
 	}
 
-
 	protected static final String ANDROID_NS_URL = "http://schemas.android.com/apk/res/android";
 
 	/**

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -84,7 +84,7 @@ public CodeWriter makeDump() {
 		writer.finish();
 		return writer;
 	}
-	
+
 	public CodeWriter makeXmlDump() {
 		CodeWriter writer = new CodeWriter();
 		writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
@@ -93,7 +93,7 @@ public CodeWriter makeXmlDump() {
 
 		Set<String> addedValues = new HashSet<>();
 		for (ResourceEntry ri : resStorage.getResources()) {
-			if(addedValues.add(ri.getTypeName() + "." + ri.getKeyName())) {
+			if (addedValues.add(ri.getTypeName() + "." + ri.getKeyName())) {
 				String format = String.format("<public type=\"%s\" name=\"%s\" id=\"%s\" />",
 						ri.getTypeName(), ri.getKeyName(), ri.getId());
 				writer.startLine(format);

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java
Patch:
@@ -92,5 +92,4 @@ private void runJob(BackgroundJob job) {
 	protected void done() {
 		progressPane.setVisible(false);
 	}
-
 }

File: jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java
Patch:
@@ -24,5 +24,4 @@ public void run() {
 	public String getInfoString() {
 		return "Decompiling: ";
 	}
-
 }

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -158,7 +158,7 @@ public void setShowInconsistentCode(boolean showInconsistentCode) {
 		this.showInconsistentCode = showInconsistentCode;
 	}
 
-	public LangLocale getLangLocale(){
+	public LangLocale getLangLocale() {
 		return this.langLocale;
 	}
 

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -82,7 +82,7 @@ public static void fill(JadxSettings settings, String jsonStr) {
 
 	private static <T> void populate(GsonBuilder builder, String json, Class<T> type, final T into) {
 		builder.registerTypeAdapter(type, (InstanceCreator<T>) t -> into)
-						.create()
-						.fromJson(json, type);
+				.create()
+				.fromJson(json, type);
 	}
 }

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java
Patch:
@@ -205,7 +205,7 @@ private String getSyntaxByExtension(String name) {
 		if (ext.equals("html")) {
 			return SyntaxConstants.SYNTAX_STYLE_HTML;
 		}
-		if(ext.equals("arsc")) {
+		if (ext.equals("arsc")) {
 			return SyntaxConstants.SYNTAX_STYLE_XML;
 		}
 		return null;

File: jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java
Patch:
@@ -302,8 +302,8 @@ private int getHeight(@Nullable Component nodeComp) {
 	protected static class ResultsModel extends AbstractTableModel {
 		private static final long serialVersionUID = -7821286846923903208L;
 		private static final String[] COLUMN_NAMES = {
-						NLS.str("search_dialog.col_node"),
-						NLS.str("search_dialog.col_code")
+				NLS.str("search_dialog.col_node"),
+				NLS.str("search_dialog.col_code")
 		};
 
 		private final transient ArrayList<JNode> rows = new ArrayList<>();

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -293,11 +293,10 @@ private void treeClickAction() {
 				if (resFile != null && JResource.isSupportedForView(resFile.getType())) {
 					tabbedPane.showResource(res);
 				}
-			}else if (obj instanceof JCertificate) {
+			} else if (obj instanceof JCertificate) {
 				JCertificate cert = (JCertificate) obj;
 				tabbedPane.showCertificate(cert);
-			}
-			else if (obj instanceof JNode) {
+			} else if (obj instanceof JNode) {
 				JNode node = (JNode) obj;
 				JClass cls = node.getRootClass();
 				if (cls != null) {

File: jadx-gui/src/main/java/jadx/gui/update/data/Asset.java
Patch:
@@ -67,7 +67,7 @@ public void setCreatedAt(String createdAt) {
 	@Override
 	public String toString() {
 		return name
-				+ ", size: " + String.format("%.2fMB", size / 1024. /1024.)
+				+ ", size: " + String.format("%.2fMB", size / 1024. / 1024.)
 				+ ", downloads count: " + downloadCount
 				+ ", url: " + downloadUrl
 				+ ", date: " + createdAt;

File: jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java
Patch:
@@ -41,7 +41,7 @@ public void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<Stri
 	}
 
 	private void addUsage(JNode jNode, JavaClass javaClass,
-			CodeLinesInfo linesInfo, CodePosition codePosition, List<StringRef> lines) {
+	                      CodeLinesInfo linesInfo, CodePosition codePosition, List<StringRef> lines) {
 		UsageInfo usageInfo = usageMap.get(jNode);
 		if (usageInfo == null) {
 			usageInfo = new UsageInfo();

File: jadx-gui/src/main/java/jadx/gui/utils/logs/LogCollector.java
Patch:
@@ -18,6 +18,7 @@ public class LogCollector extends AppenderBase<ILoggingEvent> {
 	public static final int BUFFER_SIZE = 5000;
 
 	private static final LogCollector INSTANCE = new LogCollector();
+
 	public static LogCollector getInstance() {
 		return INSTANCE;
 	}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -224,7 +224,7 @@ protected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws Co
 					code.add(';');
 				}
 			}
-		} catch (Throwable th) {
+		} catch (Exception th) {
 			throw new CodegenException(mth, "Error generate insn: " + insn, th);
 		}
 		return true;

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -7,7 +7,6 @@
 
 import jadx.core.Consts;
 import jadx.core.deobf.NameMapper;
-import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.nodes.LoopLabelAttr;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.info.MethodInfo;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -53,4 +53,7 @@ public class AType<T extends IAttribute> {
 	public static final AType<DeclareVariablesAttr> DECLARE_VARIABLES = new AType<>();
 	public static final AType<LoopLabelAttr> LOOP_LABEL = new AType<>();
 	public static final AType<IgnoreEdgeAttr> IGNORE_EDGE = new AType<>();
+
+	private AType() {
+	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -15,7 +15,6 @@
 import com.android.dex.Dex;
 import com.android.dx.rop.code.AccessFlags;
 import org.jetbrains.annotations.Nullable;
-import org.jetbrains.annotations.TestOnly;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -3,6 +3,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.jetbrains.annotations.Nullable;
+
 import jadx.core.codegen.TypeGen;
 import jadx.core.deobf.NameMapper;
 import jadx.core.dex.attributes.AFlag;
@@ -27,7 +29,6 @@
 import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.exceptions.JadxException;
-import org.jetbrains.annotations.Nullable;
 
 @JadxVisitor(
 		name = "EnumVisitor",

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -1,7 +1,6 @@
 package jadx.gui.settings;
 
 import java.lang.reflect.Modifier;
-import java.lang.reflect.Type;
 import java.util.prefs.Preferences;
 
 import com.google.gson.ExclusionStrategy;

File: jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.gui.ui;
 
-import jadx.gui.treemodel.JNode;
-
 import javax.swing.*;
 import java.awt.*;
 
+import jadx.gui.treemodel.JNode;
+
 public class CertificatePanel extends ContentPanel {
     CertificatePanel(TabbedPane panel, JNode jnode) {
         super(panel, jnode);

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -122,7 +122,7 @@ private void addCompare(CodeWriter code, CondStack stack, Compare compare) throw
 				wrap(code, firstArg);
 				return;
 			}
-			ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());
+			ErrorsCounter.methodWarn(mth, "Unsupported boolean condition " + op.getSymbol());
 		}
 
 		addArg(code, firstArg, isArgWrapNeeded(firstArg));

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -580,7 +580,7 @@ private void inlineAnonymousConstr(CodeWriter code, ClassNode cls, ConstructorIn
 		// anonymous class construction
 		if (cls.contains(AFlag.DONT_GENERATE)) {
 			code.add("/* anonymous class already generated */");
-			ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);
+			ErrorsCounter.methodWarn(mth, "Anonymous class already generated: " + cls);
 			return;
 		}
 		ArgType parent;

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -153,7 +153,7 @@ private CodeWriter makeLoop(LoopRegion region, CodeWriter code) throws CodegenEx
 		if (header != null) {
 			List<InsnNode> headerInsns = header.getInstructions();
 			if (headerInsns.size() > 1) {
-				ErrorsCounter.methodError(mth, "Found not inlined instructions from loop header");
+				ErrorsCounter.methodWarn(mth, "Found not inlined instructions from loop header");
 				int last = headerInsns.size() - 1;
 				for (int i = 0; i < last; i++) {
 					InsnNode insn = headerInsns.get(i);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.core.dex.attributes;
 
-import java.util.LinkedList;
+import java.util.ArrayList;
 import java.util.List;
 
 import jadx.core.utils.Utils;
 
 public class AttrList<T> implements IAttribute {
 
 	private final AType<AttrList<T>> type;
-	private final List<T> list = new LinkedList<>();
+	private final List<T> list = new ArrayList<>();
 
 	public AttrList(AType<AttrList<T>> type) {
 		this.type = type;

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -55,7 +55,7 @@ public String getName() {
 	}
 
 	public void setName(String name) {
-		if (sVar != null) {
+		if (sVar != null && name != null) {
 			sVar.setName(name);
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/IDexNode.java
Patch:
@@ -2,6 +2,8 @@
 
 public interface IDexNode {
 
+	String typeName();
+
 	DexNode dex();
 
 	RootNode root();

File: jadx-core/src/main/java/jadx/core/dex/visitors/DebugInfoVisitor.java
Patch:
@@ -26,7 +26,7 @@ public void visit(MethodNode mth) throws JadxException {
 				processDebugInfo(mth, debugOffset);
 			}
 		} catch (Exception e) {
-			LOG.error("Error in debug info parser: {}", ErrorsCounter.formatErrorMsg(mth, e.getMessage()), e);
+			LOG.error("Error in debug info parser: {}", ErrorsCounter.formatMsg(mth, e.getMessage()), e);
 		} finally {
 			mth.unloadInsnArr();
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -259,8 +259,7 @@ private String insertInsns(MethodNode mth, IBlock block) {
 			} else {
 				CodeWriter code = new CodeWriter();
 				List<InsnNode> instructions = block.getInstructions();
-				MethodGen.addFallbackInsns(code, mth,
-						instructions.toArray(new InsnNode[instructions.size()]), false);
+				MethodGen.addFallbackInsns(code, mth, instructions.toArray(new InsnNode[0]), false);
 				String str = escape(code.newLine().toString());
 				if (str.startsWith(NL)) {
 					str = str.substring(NL.length());

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -366,7 +366,7 @@ private static InsnNode makeFilledArrayInsn(MethodNode mth, FillArrayNode insn)
 			elType = insnElementType;
 		}
 		if (!elType.equals(insnElementType) && !insnArrayType.equals(ArgType.OBJECT)) {
-			ErrorsCounter.methodError(mth,
+			ErrorsCounter.methodWarn(mth,
 					"Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset())
 							+ ", element type: " + elType + ", insn element type: " + insnElementType
 			);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java
Patch:
@@ -529,7 +529,7 @@ private static boolean applyRemove(MethodNode mth, BlocksRemoveInfo removeInfo)
 			return false;
 		}
 		if (removeInfo.getOuts().isEmpty()) {
-			ErrorsCounter.methodError(mth, "Failed to extract finally block: empty outs");
+			ErrorsCounter.methodWarn(mth, "Failed to extract finally block: empty outs");
 			return false;
 		}
 		// safe checks finished, altering blocks tree

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -93,7 +93,7 @@ private static void searchTryCatchDominators(MethodNode mth, Map<BlockNode, TryC
 			}
 			TryCatchBlock prevTB = tryBlocksMap.put(domBlock, tb);
 			if (prevTB != null) {
-				ErrorsCounter.methodError(mth, "Failed to process nested try/catch");
+				ErrorsCounter.methodWarn(mth, "Failed to process nested try/catch");
 			}
 		}
 	}
@@ -105,7 +105,7 @@ private static boolean checkAndWrap(MethodNode mth, Map<BlockNode, TryCatchBlock
 			if (region.getSubBlocks().contains(dominator)) {
 				TryCatchBlock tb = tryBlocksMap.get(dominator);
 				if (!wrapBlocks(region, tb, dominator)) {
-					ErrorsCounter.methodError(mth, "Can't wrap try/catch for " + region);
+					ErrorsCounter.methodWarn(mth, "Can't wrap try/catch for " + region);
 				}
 				tryBlocksMap.remove(dominator);
 				return true;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -532,7 +532,7 @@ private BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNo
 
 		BlockNode body = getNextBlock(block);
 		if (body == null) {
-			ErrorsCounter.methodError(mth, "Unexpected end of synchronized block");
+			ErrorsCounter.methodWarn(mth, "Unexpected end of synchronized block");
 			return null;
 		}
 		BlockNode exit = null;
@@ -904,15 +904,15 @@ public IRegion processTryCatchBlocks(MethodNode mth) {
 					blocks.add(handlerBlock);
 					splitters.addAll(handlerBlock.getPredecessors());
 				} else {
-					LOG.debug(ErrorsCounter.formatErrorMsg(mth, "No exception handler block: " + handler));
+					LOG.debug(ErrorsCounter.formatMsg(mth, "No exception handler block: " + handler));
 				}
 			}
 			Set<BlockNode> exits = new HashSet<>();
 			for (BlockNode splitter : splitters) {
 				for (BlockNode handler : blocks) {
 					List<BlockNode> s = splitter.getSuccessors();
 					if (s.isEmpty()) {
-						LOG.debug(ErrorsCounter.formatErrorMsg(mth, "No successors for splitter: " + splitter));
+						LOG.debug(ErrorsCounter.formatMsg(mth, "No successors for splitter: " + splitter));
 						continue;
 					}
 					BlockNode ss = s.get(0);

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/CheckTypeVisitor.java
Patch:
@@ -23,6 +23,6 @@ public static void visit(MethodNode mth, InsnNode insn) {
 	}
 
 	private static void error(String msg, MethodNode mth, InsnNode insn) {
-		ErrorsCounter.methodError(mth, msg + ": " + insn);
+		ErrorsCounter.methodWarn(mth, msg + ": " + insn);
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/exceptions/JadxException.java
Patch:
@@ -17,11 +17,11 @@ public JadxException(String message, Throwable cause) {
 	}
 
 	public JadxException(ClassNode cls, String msg, Throwable th) {
-		super(ErrorsCounter.formatErrorMsg(cls, msg), th);
+		super(ErrorsCounter.formatMsg(cls, msg), th);
 	}
 
 	public JadxException(MethodNode mth, String msg, Throwable th) {
-		super(ErrorsCounter.formatErrorMsg(mth, msg), th);
+		super(ErrorsCounter.formatMsg(mth, msg), th);
 	}
 
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java
Patch:
@@ -140,7 +140,6 @@ public static InsnArg wrapArg(InsnNode insn) {
 	}
 
 	public boolean isThis() {
-		// must be implemented in RegisterArg
-		return false;
+		return contains(AFlag.THIS);
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java
Patch:
@@ -57,7 +57,7 @@ public static boolean isZipBomb(ZipEntry entry) {
 		long compressedSize = entry.getCompressedSize();
 		long uncompressedSize = entry.getSize();
 		if (compressedSize < 0 || uncompressedSize < 0) {
-			LOG.error("Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
+			LOG.error("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
 					compressedSize, uncompressedSize, entry.getName());
 			return true;
 		}

File: jadx-gui/src/main/java/jadx/gui/utils/NLS.java
Patch:
@@ -31,6 +31,7 @@ public class NLS {
 
 		i18nLocales.add(new LangLocale("en", "US")); // As default language
 		i18nLocales.add(new LangLocale("zh", "CN"));
+		i18nLocales.add(new LangLocale("es", "ES"));
 
 		i18nLocales.forEach(NLS::load);
 

File: jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java
Patch:
@@ -57,7 +57,7 @@ public static boolean isZipBomb(ZipEntry entry) {
 		long compressedSize = entry.getCompressedSize();
 		long uncompressedSize = entry.getSize();
 		if (compressedSize < 0 || uncompressedSize < 0) {
-			LOG.error("Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
+			LOG.error("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
 					compressedSize, uncompressedSize, entry.getName());
 			return true;
 		}

File: jadx-gui/src/main/java/jadx/gui/utils/NLS.java
Patch:
@@ -31,6 +31,7 @@ public class NLS {
 
 		i18nLocales.add(new LangLocale("en", "US")); // As default language
 		i18nLocales.add(new LangLocale("zh", "CN"));
+		i18nLocales.add(new LangLocale("es", "ES"));
 
 		i18nLocales.forEach(NLS::load);
 

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -42,7 +42,7 @@
  * jadx.load();
  * jadx.save();
  * </code></pre>
- * <p/>
+ *
  * Instead of 'save()' you can iterate over decompiled classes:
  * <pre><code>
  *  for(JavaClass cls : jadx.getClasses()) {

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -78,7 +78,7 @@ public static Object getConstValueByInsn(DexNode dex, InsnNode insn) {
 				return ((ConstClassNode) insn).getClsType();
 			case SGET:
 				FieldInfo f = (FieldInfo) ((IndexInsnNode) insn).getIndex();
-				FieldNode fieldNode = dex.resolveField(f);
+				FieldNode fieldNode = dex.root().deepResolveField(f);
 				if (fieldNode == null) {
 					LOG.warn("Field {} not found in dex {}", f, dex);
 					return null;

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -454,7 +454,8 @@ private static boolean splitReturn(MethodNode mth) {
 		}
 		BlockNode exitBlock = mth.getExitBlocks().get(0);
 		if (exitBlock.getInstructions().size() != 1
-				|| exitBlock.contains(AFlag.SYNTHETIC)) {
+				|| exitBlock.contains(AFlag.SYNTHETIC)
+				|| exitBlock.contains(AType.SPLITTER_BLOCK)) {
 			return false;
 		}
 		List<BlockNode> preds = exitBlock.getPredecessors();

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -46,7 +46,8 @@ public static JadxSettings load() {
 			String jsonSettings = PREFS.get(JADX_GUI_KEY, "");
 			JadxSettings settings = fromString(jsonSettings);
 			if (settings == null) {
-				return new JadxSettings();
+				LOG.debug("Created new settings.");
+				settings = new JadxSettings();
 			}
 			settings.fixOnLoad();
 			LOG.debug("Loaded settings: {}", makeString(settings));

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -396,14 +396,14 @@ private static InsnNode makeFilledArrayInsn(MethodNode mth, FillArrayNode insn)
 		return filledArr;
 	}
 
-	private static boolean allArgsNull(InsnNode insn) {
+	private static boolean allArgsNull(ConstructorInsn insn) {
 		for (InsnArg insnArg : insn.getArguments()) {
 			if (insnArg.isLiteral()) {
 				LiteralArg lit = (LiteralArg) insnArg;
 				if (lit.getLiteral() != 0) {
 					return false;
 				}
-			} else if (!insnArg.isThis()) {
+			} else {
 				return false;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -157,7 +157,7 @@ public boolean equalRegisterAndType(RegisterArg arg) {
 
 	@Override
 	public int hashCode() {
-		return regNum * 31 + type.hashCode();
+		return regNum;
 	}
 
 	@Override

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -64,7 +64,7 @@ public class JadxCLIArgs {
 	protected boolean deobfuscationOn = false;
 
 	@Parameter(names = {"--deobf-min"}, description = "min length of name, renamed if shorter")
-	protected int deobfuscationMinLength = 4;
+	protected int deobfuscationMinLength = 3;
 
 	@Parameter(names = {"--deobf-max"}, description = "max length of name, renamed if longer")
 	protected int deobfuscationMaxLength = 64;

File: jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java
Patch:
@@ -193,7 +193,7 @@ public static String hexify(byte bytes[]) {
 		char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
 				'A', 'B', 'C', 'D', 'E', 'F'};
 
-		StringBuffer buf = new StringBuffer(bytes.length * 3);
+		StringBuilder buf = new StringBuilder(bytes.length * 3);
 
 		for (int i = 0; i < bytes.length; ++i) {
 			buf.append(hexDigits[(bytes[i] & 0xf0) >> 4]);

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -57,7 +57,7 @@ public static void makeDirsForFile(File file) {
 	public static void makeDirs(@Nullable File dir) {
 		if (dir != null) {
 			synchronized (MKDIR_SYNC) {
-				if (!dir.exists() && !dir.mkdirs()) {
+				if (!dir.mkdirs() && !dir.isDirectory()) {
 					throw new JadxRuntimeException("Can't create directory " + dir);
 				}
 			}

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -57,7 +57,7 @@ public static void makeDirsForFile(File file) {
 	public static void makeDirs(@Nullable File dir) {
 		if (dir != null) {
 			synchronized (MKDIR_SYNC) {
-				if (!dir.exists() && !dir.mkdirs()) {
+				if (!dir.mkdirs() && !dir.isDirectory()) {
 					throw new JadxRuntimeException("Can't create directory " + dir);
 				}
 			}

File: jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java
Patch:
@@ -193,7 +193,7 @@ public static String hexify(byte bytes[]) {
 		char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
 				'A', 'B', 'C', 'D', 'E', 'F'};
 
-		StringBuffer buf = new StringBuffer(bytes.length * 3);
+		StringBuilder buf = new StringBuilder(bytes.length * 3);
 
 		for (int i = 0; i < bytes.length; ++i) {
 			buf.append(hexDigits[(bytes[i] & 0xf0) >> 4]);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -418,8 +418,9 @@ private static boolean checkLoops(MethodNode mth, BlockNode block) {
 				boolean change = false;
 				for (Edge edge : edges) {
 					BlockNode target = edge.getTarget();
-					if (!target.contains(AFlag.SYNTHETIC)) {
-						BlockSplitter.insertBlockBetween(mth, edge.getSource(), target);
+					BlockNode source = edge.getSource();
+					if (!target.contains(AFlag.SYNTHETIC) && !source.contains(AFlag.SYNTHETIC)) {
+						BlockSplitter.insertBlockBetween(mth, source, target);
 						change = true;
 					}
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java
Patch:
@@ -91,6 +91,7 @@ private static void splitBasicBlocks(MethodNode mth) {
 					startNew = isSplitByJump(prevInsn, insn)
 							|| SEPARATE_INSNS.contains(insn.getType())
 							|| isDoWhile(blocksMap, curBlock, insn)
+							|| insn.contains(AType.EXC_HANDLER)
 							|| prevInsn.contains(AFlag.TRY_LEAVE)
 							|| prevInsn.getType() == InsnType.MOVE_EXCEPTION;
 					if (startNew) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java
Patch:
@@ -5,7 +5,7 @@
 
 public class GotoNode extends TargetInsnNode {
 
-	protected int target;
+	protected final int target;
 
 	public GotoNode(int target) {
 		this(InsnType.GOTO, target, 0);

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -240,7 +240,6 @@ private void addSourceFilenameAttr(String fileName) {
 			}
 		}
 		this.addAttr(new SourceFileAttr(fileName));
-		LOG.debug("Class '{}' compiled from '{}'", this, fileName);
 	}
 
 	@Override
@@ -486,7 +485,6 @@ public boolean equals(Object o) {
 			return clsInfo.equals(other.clsInfo);
 		}
 		return false;
-
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java
Patch:
@@ -142,11 +142,10 @@ public static IfCondition simplify(IfCondition cond) {
 			Compare c = cond.getCompare();
 			simplifyCmpOp(c);
 			if (c.getOp() == IfOp.EQ && c.getB().isLiteral() && c.getB().equals(LiteralArg.FALSE)) {
-				return not(new IfCondition(c.invert()));
+				cond = not(new IfCondition(c.invert()));
 			} else {
 				c.normalize();
 			}
-			return cond;
 		}
 		List<IfCondition> args = null;
 		for (int i = 0; i < cond.getArgs().size(); i++) {
@@ -225,7 +224,7 @@ public String toString() {
 			case TERNARY:
 				return first() + " ? " + second() + " : " + third();
 			case NOT:
-				return "!" + first();
+				return "!(" + first() + ")";
 			case AND:
 			case OR:
 				String op = mode == Mode.OR ? " || " : " && ";

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -79,7 +79,6 @@ private static boolean canRemoveBlock(BlockNode block) {
 
 	private static boolean removeEmptyBlock(BlockNode block) {
 		if (canRemoveBlock(block)) {
-			LOG.debug("Removing empty block: {}", block);
 			if (block.getSuccessors().size() == 1) {
 				BlockNode successor = block.getSuccessors().get(0);
 				block.getPredecessors().forEach(pred -> {

File: jadx-gui/src/main/java/jadx/gui/JadxGUI.java
Patch:
@@ -8,7 +8,7 @@
 import jadx.gui.settings.JadxSettings;
 import jadx.gui.settings.JadxSettingsAdapter;
 import jadx.gui.ui.MainWindow;
-import jadx.gui.utils.LogCollector;
+import jadx.gui.utils.logs.LogCollector;
 
 public class JadxGUI {
 	private static final Logger LOG = LoggerFactory.getLogger(JadxGUI.class);

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -67,9 +67,7 @@ private static void removeSyntheticFields(ClassNode cls) {
 				ClassInfo clsInfo = ClassInfo.fromType(cls.root(), field.getType());
 				ClassNode fieldsCls = cls.dex().resolveClass(clsInfo);
 				ClassInfo parentClass = cls.getClassInfo().getParentClass();
-				if (fieldsCls != null
-						&& parentClass.equals(fieldsCls.getClassInfo())
-						&& field.getName().startsWith("this$") /* TODO: don't check name */) {
+				if (fieldsCls != null && parentClass.equals(fieldsCls.getClassInfo())) {
 					int found = 0;
 					for (MethodNode mth : cls.getMethods()) {
 						if (removeFieldUsageFromConstructor(mth, field, fieldsCls)) {

File: jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java
Patch:
@@ -41,7 +41,7 @@ class TabbedPane extends JTabbedPane {
 	private transient JumpManager jumps = new JumpManager();
 
 	TabbedPane(MainWindow window) {
-		mainWindow = window;
+		this.mainWindow = window;
 
 		setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
 

File: jadx-core/src/main/java/jadx/core/codegen/CodeGen.java
Patch:
@@ -1,12 +1,10 @@
 package jadx.core.codegen;
 
 import jadx.core.dex.nodes.ClassNode;
-import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.exceptions.CodegenException;
 
-public class CodeGen extends AbstractVisitor {
+public class CodeGen {
 
-	@Override
 	public boolean visit(ClassNode cls) throws CodegenException {
 		ClassGen clsGen = new ClassGen(cls, cls.root().getArgs());
 		CodeWriter clsCode = clsGen.makeClass();

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -39,6 +39,8 @@
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
+import static jadx.core.dex.nodes.ProcessState.UNLOADED;
+
 public class ClassNode extends LineAttrNode implements ILoadable, IDexNode {
 	private static final Logger LOG = LoggerFactory.getLogger(ClassNode.class);
 
@@ -264,6 +266,7 @@ public void unload() {
 		for (ClassNode innerCls : getInnerClasses()) {
 			innerCls.unload();
 		}
+		setState(UNLOADED);
 	}
 
 	private void buildCache() {

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -52,6 +52,8 @@ public void run() {
 						Thread.sleep(500);
 					}
 					progressMonitor.close();
+					LOG.info("decompilation complete, freeing memory ...");
+					decompiler.getClasses().forEach(JavaClass::unload);
 					LOG.info("done");
 				} catch (InterruptedException e) {
 					LOG.error("Save interrupted", e);

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -51,6 +51,7 @@ public void loadNode() {
 	public synchronized void load() {
 		if (!loaded) {
 			cls.decompile();
+			cls.unload();
 			loaded = true;
 		}
 		update();

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -170,7 +170,7 @@ public void addInstructions(CodeWriter code) throws CodegenException {
 				if (cause != null) {
 					code.newLine();
 					code.add("/*");
-					code.newLine().add("Error: ").add(Utils.getStackTrace(cause));
+					code.newLine().add("Error: ").addMultiLine(Utils.getStackTrace(cause));
 					code.add("*/");
 				}
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -86,8 +86,7 @@ private static void searchTryCatchDominators(MethodNode mth, Map<BlockNode, TryC
 			if (domBlocks.size() != 1) {
 				domBlock = BlockUtils.getTopBlock(domBlocks);
 				if (domBlock == null) {
-					throw new JadxRuntimeException(
-							"Exception block dominator not found, method:" + mth + ". bs: " + domBlocks);
+					throw new JadxRuntimeException("Exception block dominator not found, method:" + mth + ", dom blocks: " + domBlocks);
 				}
 			} else {
 				domBlock = domBlocks.get(0);

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -208,8 +208,8 @@ private static InsnNode convertInvoke(MethodNode mth, InsnNode insn) {
 					} // end of if constructor is for StringBuilder
 				} // end of if we found a constructor early in the chain
 
-			} catch (Throwable e) {
-				LOG.debug("Can't convert string concatenation: {} insn: {}", mth, insn, e);
+			} catch (Exception e) {
+				LOG.warn("Can't convert string concatenation: {} insn: {}", mth, insn, e);
 			}
 		}
 		return null;

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.jetbrains.annotations.TestOnly;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -32,6 +33,7 @@
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
 @Deprecated
+@TestOnly
 public class DebugUtils {
 	private static final Logger LOG = LoggerFactory.getLogger(DebugUtils.class);
 

File: jadx-gui/src/main/java/jadx/gui/ui/CodePanel.java
Patch:
@@ -30,7 +30,7 @@ class CodePanel extends ContentPanel {
 		add(searchBar, BorderLayout.NORTH);
 		add(scrollPane);
 
-		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_MASK);
+		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_DOWN_MASK);
 		Utils.addKeyBinding(codeArea, key, "SearchAction", new SearchAction());
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -99,7 +99,7 @@ private static void printInsns(MethodNode mth, String indent, IBlock block) {
 				CodeWriter code = new CodeWriter();
 				ig.makeInsn(insn, code);
 				String insnStr = code.toString().substring(CodeWriter.NL.length());
-				LOG.debug("{}> {}", indent, insnStr);
+				LOG.debug("{}> {}\t{}", indent, insnStr, insn.getAttributesString());
 			} catch (CodegenException e) {
 				LOG.debug("{}>!! {}", indent, insn);
 			}

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop2.java
Patch:
@@ -9,6 +9,7 @@
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
+import static org.hamcrest.Matchers.anyOf;
 
 public class TestBreakInLoop2 extends IntegrationTest {
 
@@ -43,7 +44,7 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("while (true) {"));
-		assertThat(code, containsOne("break;"));
+		assertThat(code, anyOf(containsOne("break;"), containsOne("return;")));
 		assertThat(code, containsOne("throw ex;"));
 		assertThat(code, containsOne("data.clear();"));
 		assertThat(code, containsOne("Thread.sleep(100);"));

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopConditionInvoke.java
Patch:
@@ -37,7 +37,7 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsOne("do {"));
-		assertThat(code, containsOne("if (ch == '\\u0000') {"));
+		assertThat(code, containsOne("if (ch == 0) {"));
 		assertThat(code, containsOne("this.pos = startPos;"));
 		assertThat(code, containsOne("return false;"));
 		assertThat(code, containsOne("} while (ch != lastChar);"));

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSequentialLoops.java
Patch:
@@ -14,7 +14,7 @@
 public class TestSequentialLoops extends IntegrationTest {
 
 	public static class TestCls {
-		public int test7(int a, int b) {
+		public int test(int a, int b) {
 			int c = b;
 			int z;
 

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -56,8 +56,6 @@ public static Object getSyncObj(ClassNode cls) {
 	}
 
 	private static void processDependencies(ClassNode cls, List<IDexTreeVisitor> passes) {
-		for (ClassNode depCls : cls.getDependencies()) {
-			process(depCls, passes, null);
-		}
+		cls.getDependencies().forEach(depCls -> process(depCls, passes, null));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java
Patch:
@@ -6,6 +6,8 @@ public interface IRegion extends IContainer {
 
 	IRegion getParent();
 
+	void setParent(IRegion parent);
+
 	List<IContainer> getSubBlocks();
 
 	boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock);

File: jadx-core/src/main/java/jadx/core/dex/regions/Region.java
Patch:
@@ -21,9 +21,7 @@ public List<IContainer> getSubBlocks() {
 	}
 
 	public void add(IContainer region) {
-		if (region instanceof AbstractRegion) {
-			((AbstractRegion) region).setParent(this);
-		}
+		updateParent(region, this);
 		blocks.add(region);
 	}
 
@@ -32,6 +30,7 @@ public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {
 		int i = blocks.indexOf(oldBlock);
 		if (i != -1) {
 			blocks.set(i, newBlock);
+			updateParent(newBlock, this);
 			return true;
 		}
 		return false;

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfRegion.java
Patch:
@@ -105,10 +105,12 @@ public List<IContainer> getBranches() {
 	public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {
 		if (oldBlock == thenRegion) {
 			thenRegion = newBlock;
+			updateParent(thenRegion, this);
 			return true;
 		}
 		if (oldBlock == elseRegion) {
 			elseRegion = newBlock;
+			updateParent(elseRegion, this);
 			return true;
 		}
 		return false;
@@ -128,6 +130,6 @@ public String baseString() {
 
 	@Override
 	public String toString() {
-		return "IF " + header + " then " + thenRegion + " else " + elseRegion;
+		return "IF " + header + " then (" + thenRegion + ") else (" + elseRegion + ")";
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java
Patch:
@@ -54,9 +54,7 @@ private static void traverseInternal(MethodNode mth, IRegionVisitor visitor, ICo
 		} else if (container instanceof IRegion) {
 			IRegion region = (IRegion) container;
 			if (visitor.enterRegion(mth, region)) {
-				for (IContainer subCont : region.getSubBlocks()) {
-					traverseInternal(mth, visitor, subCont);
-				}
+				region.getSubBlocks().forEach(subCont -> traverseInternal(mth, visitor, subCont));
 			}
 			visitor.leaveRegion(mth, region);
 		}

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -76,7 +76,7 @@ public static void printRegions(MethodNode mth, boolean printInsns) {
 	}
 
 	private static void printRegion(MethodNode mth, IRegion region, String indent, boolean printInsns) {
-		LOG.debug("{}{}", indent, region);
+		LOG.debug("{}{} {}", indent, region, region.getAttributesString());
 		indent += "|  ";
 		for (IContainer container : region.getSubBlocks()) {
 			if (container instanceof IRegion) {
@@ -99,9 +99,9 @@ private static void printInsns(MethodNode mth, String indent, IBlock block) {
 				CodeWriter code = new CodeWriter();
 				ig.makeInsn(insn, code);
 				String insnStr = code.toString().substring(CodeWriter.NL.length());
-				LOG.debug("{} - {}", indent, insnStr);
+				LOG.debug("{}> {}", indent, insnStr);
 			} catch (CodegenException e) {
-				LOG.debug("{} - {}", indent, insn);
+				LOG.debug("{}>!! {}", indent, insn);
 			}
 		}
 	}

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -64,7 +64,7 @@ public class JadxCLIArgs {
 	protected boolean deobfuscationOn = false;
 
 	@Parameter(names = {"--deobf-min"}, description = "min length of name, renamed if shorter")
-	protected int deobfuscationMinLength = 2;
+	protected int deobfuscationMinLength = 4;
 
 	@Parameter(names = {"--deobf-max"}, description = "max length of name, renamed if longer")
 	protected int deobfuscationMaxLength = 64;
@@ -73,7 +73,7 @@ public class JadxCLIArgs {
 	protected boolean deobfuscationForceSave = false;
 
 	@Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias")
-	protected boolean deobfuscationUseSourceNameAsAlias = false;
+	protected boolean deobfuscationUseSourceNameAsAlias = true;
 
 	@Parameter(names = {"--cfg"}, description = "save methods control flow graph to dot file")
 	protected boolean cfgOutput = false;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JLoadableNode.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.gui.treemodel;
 
 public abstract class JLoadableNode extends JNode {
+	private static final long serialVersionUID = 5543590584166374958L;
+
 	public abstract void loadNode();
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java
Patch:
@@ -210,7 +210,7 @@ public int getDexId() {
 
 	@Override
 	public String toString() {
-		return "DEX";
+		return "DEX: " + file;
 	}
 
 }

File: jadx-core/src/test/java/jadx/tests/api/SmaliTest.java
Patch:
@@ -37,7 +37,7 @@ private static File getSmaliFile(String clsName) {
 		if (smaliFile.exists()) {
 			return smaliFile;
 		}
-		throw new AssertionError("Smali file not found: " + SMALI_TESTS_DIR + "/" + clsName + SMALI_TESTS_EXT);
+		throw new AssertionError("Smali file not found: " + smaliFile.getAbsolutePath());
 	}
 
 	private static boolean compileSmali(File input, File output) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/DebugInfoVisitor.java
Patch:
@@ -22,7 +22,7 @@ public class DebugInfoVisitor extends AbstractVisitor {
 	public void visit(MethodNode mth) throws JadxException {
 		try {
 			int debugOffset = mth.getDebugInfoOffset();
-			if (debugOffset > 0) {
+			if (debugOffset > 0 && mth.dex().checkOffset(debugOffset)) {
 				processDebugInfo(mth, debugOffset);
 			}
 		} catch (Exception e) {

File: jadx-core/src/main/java/jadx/core/deobf/OverridedMethodsNode.java
Patch:
@@ -4,7 +4,7 @@
 
 import jadx.core.dex.info.MethodInfo;
 
-/* package */ class OverridedMethodsNode {
+class OverridedMethodsNode {
 
 	private Set<MethodInfo> methods;
 

File: jadx-core/src/test/java/jadx/tests/integration/deobf/TestMthRename.java
Patch:
@@ -30,10 +30,10 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		assertThat(code, containsString("public abstract void m0a();"));
+		assertThat(code, containsString("public abstract void mo1a();"));
 		assertThat(code, not(containsString("public abstract void a();")));
 
-		assertThat(code, containsString(".m0a();"));
+		assertThat(code, containsString(".mo1a();"));
 		assertThat(code, not(containsString(".a();")));
 	}
 }

File: jadx-core/src/main/java/jadx/api/JavaMethod.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.api;
 
+import java.util.List;
+
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.MethodNode;
 
-import java.util.List;
-
 public final class JavaMethod implements JavaNode {
 	private final MethodNode mth;
 	private final JavaClass parent;

File: jadx-core/src/main/java/jadx/api/ResourceFile.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.api;
 
+import java.io.File;
+
 import jadx.core.utils.files.ZipSecurity;
 import jadx.core.xmlgen.ResContainer;
 
-import java.io.File;
-
 public class ResourceFile {
 
 	public static final class ZipRef {

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -1,5 +1,8 @@
 package jadx.core.codegen;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import jadx.api.JadxArgs;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.PrimitiveType;
@@ -8,9 +11,6 @@
 import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 public class TypeGen {
 	private static final Logger LOG = LoggerFactory.getLogger(TypeGen.class);
 

File: jadx-core/src/main/java/jadx/core/deobf/OverridedMethodsNode.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.core.deobf;
 
-import jadx.core.dex.info.MethodInfo;
-
 import java.util.Set;
 
+import jadx.core.dex.info.MethodInfo;
+
 /* package */ class OverridedMethodsNode {
 
 	private Set<MethodInfo> methods;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.core.dex.attributes;
 
-import jadx.core.utils.Utils;
-
 import java.util.LinkedList;
 import java.util.List;
 
+import jadx.core.utils.Utils;
+
 public class AttrList<T> implements IAttribute {
 
 	private final AType<AttrList<T>> type;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.core.dex.attributes;
 
-import jadx.core.dex.attributes.annotations.Annotation;
-
 import java.util.List;
 
+import jadx.core.dex.attributes.annotations.Annotation;
+
 public abstract class AttrNode implements IAttributeNode {
 
 	private static final AttributeStorage EMPTY_ATTR_STORAGE = new EmptyAttrStorage();

File: jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.core.dex.attributes;
 
-import jadx.core.dex.attributes.annotations.Annotation;
-
 import java.util.Collections;
 import java.util.List;
 
+import jadx.core.dex.attributes.annotations.Annotation;
+
 public final class EmptyAttrStorage extends AttributeStorage {
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/attributes/IAttributeNode.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.core.dex.attributes;
 
-import jadx.core.dex.attributes.annotations.Annotation;
-
 import java.util.List;
 
+import jadx.core.dex.attributes.annotations.Annotation;
+
 public interface IAttributeNode {
 
 	void add(AFlag flag);

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.core.dex.attributes.annotations;
 
-import jadx.core.dex.instructions.args.ArgType;
-
 import java.util.Map;
 
+import jadx.core.dex.instructions.args.ArgType;
+
 public class Annotation {
 
 	public enum Visibility {

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.dex.attributes.annotations;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.utils.Utils;
 
-import java.util.ArrayList;
-import java.util.List;
-
 public class MethodParameters implements IAttribute {
 
 	private final List<AnnotationsList> paramList;

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/DeclareVariablesAttr.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.core.dex.attributes.nodes;
 
+import java.util.LinkedList;
+import java.util.List;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.utils.Utils;
 
-import java.util.LinkedList;
-import java.util.List;
-
 /**
  * List of variables to be declared at region start.
  */

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.core.dex.attributes.nodes;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.info.FieldInfo;
 import jadx.core.dex.instructions.mods.ConstructorInsn;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.MethodNode;
 
-import java.util.ArrayList;
-import java.util.List;
-
 public class EnumClassAttr implements IAttribute {
 
 	public static class EnumField {

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.core.dex.attributes.nodes;
 
+import java.util.HashSet;
+import java.util.Set;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.utils.Utils;
 
-import java.util.HashSet;
-import java.util.Set;
-
 public class IgnoreEdgeAttr implements IAttribute {
 
 	private final Set<BlockNode> blocks = new HashSet<>(3);

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.dex.attributes.nodes;
 
+import java.util.LinkedList;
+import java.util.List;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.IAttribute;
 import jadx.core.dex.instructions.PhiInsn;
 
-import java.util.LinkedList;
-import java.util.List;
-
 public class PhiListAttr implements IAttribute {
 
 	private final List<PhiInsn> list = new LinkedList<>();

File: jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.core.dex.info;
 
+import com.android.dex.FieldId;
+
 import jadx.core.codegen.TypeGen;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.DexNode;
 
-import com.android.dex.FieldId;
-
 public final class FieldInfo {
 
 	private final ClassInfo declClass;

File: jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.core.dex.info;
 
-import jadx.core.dex.instructions.args.ArgType;
-import jadx.core.dex.nodes.DexNode;
-
 import java.util.HashMap;
 import java.util.Map;
 
+import jadx.core.dex.instructions.args.ArgType;
+import jadx.core.dex.nodes.DexNode;
+
 public class InfoStorage {
 
 	private final Map<ArgType, ClassInfo> classes = new HashMap<>();

File: jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.core.dex.instructions;
 
+import com.android.dx.io.instructions.DecodedInstruction;
+
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.InsnUtils;
 
-import com.android.dx.io.instructions.DecodedInstruction;
-
 public class ArithNode extends InsnNode {
 
 	private final ArithOp op;

File: jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.core.dex.instructions;
 
+import org.jetbrains.annotations.NotNull;
+
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.InsnNode;
 
-import org.jetbrains.annotations.NotNull;
-
 public class FilledNewArrayNode extends InsnNode {
 
 	private final ArgType elemType;

File: jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.core.dex.instructions;
 
+import com.android.dx.io.instructions.DecodedInstruction;
+
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.PrimitiveType;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.InsnUtils;
 
-import com.android.dx.io.instructions.DecodedInstruction;
-
 import static jadx.core.utils.BlockUtils.getBlockByOffset;
 import static jadx.core.utils.BlockUtils.selectOther;
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.core.dex.instructions;
 
+import com.android.dx.io.instructions.DecodedInstruction;
+
 import jadx.core.dex.info.MethodInfo;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.Utils;
 
-import com.android.dx.io.instructions.DecodedInstruction;
-
 public class InvokeNode extends InsnNode {
 
 	private final InvokeType type;

File: jadx-core/src/main/java/jadx/core/dex/instructions/NewArrayNode.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.dex.instructions;
 
+import org.jetbrains.annotations.NotNull;
+
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.InsnNode;
 
-import org.jetbrains.annotations.NotNull;
-
 public class NewArrayNode extends InsnNode {
 
 	private final ArgType arrType;

File: jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.core.dex.instructions;
 
+import java.util.Arrays;
+
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.InsnUtils;
 
-import java.util.Arrays;
-
 public class SwitchNode extends InsnNode {
 
 	private final Object[] keys;

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.core.dex.instructions.args;
 
-import jadx.core.dex.info.FieldInfo;
-
 import org.jetbrains.annotations.Nullable;
 
+import jadx.core.dex.info.FieldInfo;
+
 // TODO: don't extend RegisterArg (now used as a result of instruction)
 public final class FieldArg extends RegisterArg {
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.core.dex.instructions.args;
 
+import org.jetbrains.annotations.NotNull;
+
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
-import org.jetbrains.annotations.NotNull;
-
 public final class InsnWrapArg extends InsnArg {
 
 	private final InsnNode wrappedInsn;

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.core.dex.instructions.args;
 
-import jadx.core.dex.attributes.AttrNode;
-import jadx.core.dex.instructions.PhiInsn;
-
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import jadx.core.dex.attributes.AttrNode;
+import jadx.core.dex.instructions.PhiInsn;
+
 public class SSAVar extends AttrNode {
 
 	private final int regNum;

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.instructions.mods;
 
+import java.util.Collection;
+
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.LiteralArg;
@@ -9,8 +11,6 @@
 import jadx.core.utils.InsnUtils;
 import jadx.core.utils.Utils;
 
-import java.util.Collection;
-
 public final class TernaryInsn extends InsnNode {
 
 	private IfCondition condition;

File: jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.core.dex.nodes;
 
+import com.android.dex.ClassData.Field;
+
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.info.AccessInfo.AFType;
 import jadx.core.dex.info.FieldInfo;
 import jadx.core.dex.instructions.args.ArgType;
 
-import com.android.dex.ClassData.Field;
-
 public class FieldNode extends LineAttrNode {
 
 	private final ClassNode parent;

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.core.dex.nodes;
 
-import jadx.core.dex.attributes.AttrNode;
-
 import java.util.List;
 
+import jadx.core.dex.attributes.AttrNode;
+
 public class InsnContainer extends AttrNode implements IBlock {
 
 	private final List<InsnNode> insns;

File: jadx-core/src/main/java/jadx/core/dex/nodes/ResRefField.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.core.dex.nodes;
 
+import com.android.dx.rop.code.AccessFlags;
+
 import jadx.core.dex.info.FieldInfo;
 import jadx.core.dex.instructions.args.ArgType;
 
-import com.android.dx.rop.code.AccessFlags;
-
 public class ResRefField extends FieldNode {
 
 	public ResRefField(DexNode dex, String str) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/LocalVar.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.core.dex.nodes.parser;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.DexNode;
 import jadx.core.utils.InsnUtils;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 final class LocalVar {
 	private static final Logger LOG = LoggerFactory.getLogger(LocalVar.class);
 

File: jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.dex.regions;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import jadx.core.dex.attributes.AttrNode;
 import jadx.core.dex.nodes.IContainer;
 import jadx.core.dex.nodes.IRegion;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 public abstract class AbstractRegion extends AttrNode implements IRegion {
 	private static final Logger LOG = LoggerFactory.getLogger(AbstractRegion.class);
 

File: jadx-core/src/main/java/jadx/core/dex/regions/Region.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.core.dex.regions;
 
-import jadx.core.dex.nodes.IContainer;
-import jadx.core.dex.nodes.IRegion;
-
 import java.util.ArrayList;
 import java.util.List;
 
+import jadx.core.dex.nodes.IContainer;
+import jadx.core.dex.nodes.IRegion;
+
 public final class Region extends AbstractRegion {
 
 	private final List<IContainer> blocks;

File: jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.dex.regions;
 
+import java.util.LinkedList;
+import java.util.List;
+
 import jadx.core.dex.nodes.IContainer;
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.InsnNode;
 
-import java.util.LinkedList;
-import java.util.List;
-
 public final class SynchronizedRegion extends AbstractRegion {
 
 	private final InsnNode enterInsn;

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.core.dex.regions.conditions;
 
-import jadx.core.dex.nodes.BlockNode;
-
 import java.util.HashSet;
 import java.util.Set;
 
+import jadx.core.dex.nodes.BlockNode;
+
 public final class IfInfo {
 	private final IfCondition condition;
 	private final Set<BlockNode> mergedBlocks;

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java
Patch:
@@ -4,6 +4,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import org.jetbrains.annotations.Nullable;
+
 import jadx.core.dex.attributes.nodes.LoopInfo;
 import jadx.core.dex.instructions.IfNode;
 import jadx.core.dex.instructions.args.RegisterArg;
@@ -13,7 +15,6 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.regions.AbstractRegion;
 import jadx.core.dex.regions.conditions.IfCondition;
-import org.jetbrains.annotations.Nullable;
 
 public final class LoopRegion extends AbstractRegion {
 

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.core.dex.trycatch;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import jadx.core.Consts;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.IContainer;
 import jadx.core.utils.InsnUtils;
 
-import java.util.ArrayList;
-import java.util.List;
-
 public class ExceptionHandler {
 
 	private final ClassInfo catchType;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.visitors;
 
+import java.util.List;
+
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.attributes.nodes.FieldReplaceAttr;
@@ -22,8 +24,6 @@
 import jadx.core.utils.InstructionRemover;
 import jadx.core.utils.exceptions.JadxException;
 
-import java.util.List;
-
 @JadxVisitor(
 		name = "ClassModifier",
 		desc = "Remove synthetic classes, methods and fields",

File: jadx-core/src/main/java/jadx/core/dex/visitors/DebugInfoVisitor.java
Patch:
@@ -1,5 +1,8 @@
 package jadx.core.dex.visitors;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.BlockNode;
@@ -11,9 +14,6 @@
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.core.utils.exceptions.JadxException;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 public class DebugInfoVisitor extends AbstractVisitor {
 
 	private static final Logger LOG = LoggerFactory.getLogger(DebugInfoVisitor.class);

File: jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.visitors;
 
+import java.util.Set;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.info.FieldInfo;
@@ -17,8 +19,6 @@
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.utils.exceptions.JadxException;
 
-import java.util.Set;
-
 public class DependencyCollector extends AbstractVisitor {
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.visitors;
 
+import java.util.List;
+
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.nodes.MethodInlineAttr;
 import jadx.core.dex.info.AccessInfo;
@@ -12,8 +14,6 @@
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.utils.exceptions.JadxException;
 
-import java.util.List;
-
 /**
  * Inline synthetic methods.
  */

File: jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java
Patch:
@@ -9,13 +9,10 @@
 
 import jadx.api.JadxArgs;
 import jadx.core.Consts;
-import jadx.core.codegen.TypeGen;
 import jadx.core.deobf.Deobfuscator;
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.info.FieldInfo;
-import jadx.core.dex.info.MethodInfo;
-import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.DexNode;
 import jadx.core.dex.nodes.FieldNode;

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/helpers/BlocksRemoveInfo.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.core.dex.visitors.blocksmaker.helpers;
 
-import jadx.core.dex.instructions.args.RegisterArg;
-import jadx.core.dex.nodes.BlockNode;
-
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.jetbrains.annotations.Nullable;
 
+import jadx.core.dex.instructions.args.RegisterArg;
+import jadx.core.dex.nodes.BlockNode;
+
 public final class BlocksRemoveInfo {
 	private final Set<BlocksPair> processed = new HashSet<>();
 	private final Set<BlocksPair> outs = new HashSet<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.visitors.regions;
 
+import java.util.List;
+
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.IBlock;
@@ -13,8 +15,6 @@
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.RegionUtils;
 
-import java.util.List;
-
 import static jadx.core.utils.RegionUtils.insnsCount;
 
 public class IfRegionVisitor extends AbstractVisitor implements IRegionVisitor, IRegionIterativeVisitor {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java
Patch:
@@ -1,5 +1,8 @@
 package jadx.core.dex.visitors.regions;
 
+import java.util.List;
+import java.util.ListIterator;
+
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.BlockNode;
@@ -15,9 +18,6 @@
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
-import java.util.List;
-import java.util.ListIterator;
-
 /**
  * Remove unnecessary return instructions for void methods
  */

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java
Patch:
@@ -1,5 +1,8 @@
 package jadx.core.dex.visitors.regions;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.PhiInsn;
@@ -17,9 +20,6 @@
 import jadx.core.dex.visitors.CodeShrinker;
 import jadx.core.utils.InsnList;
 
-import java.util.HashMap;
-import java.util.Map;
-
 public class TernaryMod {
 
 	private TernaryMod() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TracedRegionVisitor.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.core.dex.visitors.regions;
 
+import java.util.ArrayDeque;
+import java.util.Deque;
+
 import jadx.core.dex.nodes.IBlock;
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.MethodNode;
 
-import java.util.ArrayDeque;
-import java.util.Deque;
-
 public abstract class TracedRegionVisitor implements IRegionVisitor {
 
 	protected final Deque<IRegion> regionStack = new ArrayDeque<>();

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.visitors.typeinference;
 
+import java.util.List;
+
 import jadx.core.dex.info.MethodInfo;
 import jadx.core.dex.instructions.IndexInsnNode;
 import jadx.core.dex.instructions.InvokeNode;
@@ -11,8 +13,6 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 
-import java.util.List;
-
 public class PostTypeInference {
 
 	private PostTypeInference() {

File: jadx-core/src/main/java/jadx/core/export/TemplateFile.java
Patch:
@@ -1,7 +1,5 @@
 package jadx.core.export;
 
-import jadx.core.utils.exceptions.JadxRuntimeException;
-
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -16,6 +14,8 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import jadx.core.utils.exceptions.JadxRuntimeException;
+
 import static jadx.core.utils.files.FileUtils.close;
 
 /**

File: jadx-core/src/main/java/jadx/core/utils/InsnList.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.core.utils;
 
-import jadx.core.dex.nodes.BlockNode;
-import jadx.core.dex.nodes.InsnNode;
-
 import java.util.Iterator;
 import java.util.List;
 
+import jadx.core.dex.nodes.BlockNode;
+import jadx.core.dex.nodes.InsnNode;
+
 public final class InsnList implements Iterable<InsnNode> {
 
 	private final List<InsnNode> list;

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -9,7 +9,6 @@
 import java.io.OutputStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.nio.file.attribute.FileAttribute;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.List;
@@ -233,5 +232,4 @@ public static File toFile(String path) {
 		}
 		return new File(path);
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -1,7 +1,5 @@
 package jadx.core.xmlgen;
 
-import jadx.core.utils.exceptions.JadxRuntimeException;
-
 import javax.xml.parsers.DocumentBuilder;
 import java.io.InputStream;
 import java.util.HashMap;
@@ -15,6 +13,8 @@
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
+import jadx.core.utils.exceptions.JadxRuntimeException;
+
 public class ManifestAttributes {
 	private static final Logger LOG = LoggerFactory.getLogger(ManifestAttributes.class);
 

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -435,7 +435,7 @@ public void useType(CodeWriter code, ArgType type) {
 	}
 
 	public void useClass(CodeWriter code, ArgType type) {
-		useClass(code, ClassInfo.extCls(cls.dex(), type));
+		useClass(code, ClassInfo.extCls(cls.root(), type));
 		ArgType[] generics = type.getGenericTypes();
 		if (generics != null) {
 			code.add('<');

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -612,7 +612,7 @@ private void makeInvoke(InvokeNode insn, CodeWriter code) throws CodegenExceptio
 		MethodInfo callMth = insn.getCallMth();
 
 		// inline method
-		MethodNode callMthNode = mth.dex().deepResolveMethod(callMth);
+		MethodNode callMthNode = mth.root().deepResolveMethod(callMth);
 		if (callMthNode != null) {
 			if (inlineMethod(callMthNode, insn, code)) {
 				return;

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -159,7 +159,7 @@ private String makeNameForObject(ArgType type) {
 			if (alias != null) {
 				return alias;
 			}
-			ClassInfo extClsInfo = ClassInfo.extCls(mth.dex(), type);
+			ClassInfo extClsInfo = ClassInfo.extCls(mth.root(), type);
 			String shortName = extClsInfo.getShortName();
 			String vName = fromName(shortName);
 			if (vName != null) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -63,7 +63,7 @@ private static void removeSyntheticFields(ClassNode cls) {
 		// remove fields if it is synthetic and type is a outer class
 		for (FieldNode field : cls.getFields()) {
 			if (field.getAccessFlags().isSynthetic() && field.getType().isObject()) {
-				ClassInfo clsInfo = ClassInfo.fromType(cls.dex(), field.getType());
+				ClassInfo clsInfo = ClassInfo.fromType(cls.root(), field.getType());
 				ClassNode fieldsCls = cls.dex().resolveClass(clsInfo);
 				ClassInfo parentClass = cls.getClassInfo().getParentClass();
 				if (fieldsCls != null

File: jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java
Patch:
@@ -96,7 +96,7 @@ private static void processCustomInsn(DexNode dex, Set<ClassNode> depList, InsnN
 	private static void addDep(DexNode dex, Set<ClassNode> depList, ArgType type) {
 		if (type != null) {
 			if (type.isObject()) {
-				addDep(dex, depList, ClassInfo.fromName(dex, type.getObject()));
+				addDep(dex, depList, ClassInfo.fromName(dex.root(), type.getObject()));
 				ArgType[] genericTypes = type.getGenericTypes();
 				if (type.isGeneric() && genericTypes != null) {
 					for (ArgType argType : genericTypes) {

File: jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java
Patch:
@@ -55,8 +55,7 @@ private static ClassNode makeClass(RootNode root, String clsName) {
 		if (dexNodes.isEmpty()) {
 			return null;
 		}
-		DexNode firstDex = dexNodes.get(0);
-		ClassInfo r = ClassInfo.fromName(firstDex, clsName);
-		return new ClassNode(firstDex, r);
+		ClassInfo r = ClassInfo.fromName(root, clsName);
+		return new ClassNode(dexNodes.get(0), r);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java
Patch:
@@ -142,6 +142,7 @@ private static void modifyArith(BlockNode block) {
 				}
 				if (replace) {
 					insn.add(AFlag.ARITH_ONEARG);
+					insn.getResult().mergeName(arg);
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -22,7 +22,6 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions10.java
Patch:
@@ -14,7 +14,7 @@ public class TestConditions10 extends IntegrationTest {
 
 	public static class TestCls {
 
-		public void test(boolean a, int b) throws Exception {
+		public void test(boolean a, int b) {
 			if (a || b > 2) {
 				b++;
 			}

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -176,7 +176,7 @@ private static Dex loadFromClassFile(File file) throws IOException, DecodeExcept
 		File outFile = FileUtils.createTempFile("cls.jar");
 		try (JarOutputStream jo = new JarOutputStream(new FileOutputStream(outFile))) {
 			String clsName = AsmUtils.getNameFromClassFile(file);
-			if (clsName == null || ZipSecurity.isValidZipEntryName(clsName)) {
+			if (clsName == null || !ZipSecurity.isValidZipEntryName(clsName)) {
 				throw new IOException("Can't read class name from file: " + file);
 			}
 			FileUtils.addFileToJar(jo, file, clsName + ".class");

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -171,7 +171,7 @@ public void printUsage() {
 			}
 			StringBuilder opt = new StringBuilder();
 			opt.append("  ").append(p.getNames());
-			addSpaces(opt, maxNamesLen - opt.length() + 2);
+			addSpaces(opt, maxNamesLen - opt.length() + 3);
 			opt.append("- ").append(p.getDescription());
 			out.println(opt);
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java
Patch:
@@ -34,4 +34,7 @@ public static void visit(IDexTreeVisitor visitor, MethodNode mth) {
 					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);
 		}
 	}
+
+	private DepthTraversal() {
+	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java
Patch:
@@ -17,7 +17,7 @@ public static void visit(IDexTreeVisitor visitor, ClassNode cls) {
 					visit(visitor, mth);
 				}
 			}
-		} catch (Throwable e) {
+		} catch (Exception e) {
 			ErrorsCounter.classError(cls,
 					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);
 		}
@@ -29,7 +29,7 @@ public static void visit(IDexTreeVisitor visitor, MethodNode mth) {
 		}
 		try {
 			visitor.visit(mth);
-		} catch (Throwable e) {
+		} catch (Exception e) {
 			ErrorsCounter.methodError(mth,
 					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);
 		}

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -26,12 +27,12 @@ public int getErrorCount() {
 		return errorsCount;
 	}
 
-	private void addError(IAttributeNode node, String msg, Throwable e) {
+	private synchronized void addError(IAttributeNode node, String msg, @Nullable Throwable e) {
 		errorNodes.add(node);
 		errorsCount++;
 
 		if (e != null) {
-			if (e.getClass() == JadxOverflowException.class) {
+			if (e instanceof JadxOverflowException) {
 				// don't print full stack trace
 				e = new JadxOverflowException(e.getMessage());
 				LOG.error("{}, message: {}", msg, e.getMessage());

File: jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java
Patch:
@@ -195,8 +195,8 @@ public static boolean isCaseSensitiveFS(File testDir) {
 				makeDirs(testDir);
 				if (caseCheckUpper.createNewFile()) {
 					boolean caseSensitive = !caseCheckLow.exists();
-					LOG.debug("Filesystem at {} is {} case-sensitive", testDir.getAbsolutePath(),
-							(caseSensitive ? "" : "NOT"));
+					LOG.debug("Filesystem at {} is {}case-sensitive", testDir.getAbsolutePath(),
+							(caseSensitive ? "" : "NOT "));
 					return caseSensitive;
 				} else {
 					LOG.debug("Failed to create file: {}", caseCheckUpper.getAbsolutePath());

File: jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java
Patch:
@@ -7,7 +7,7 @@
 public class CodeIndex<T> implements SearchIndex<T> {
 
 	private final List<StringRef> keys = new ArrayList<>();
-	private final List<T> values = new ArrayList<T>();
+	private final List<T> values = new ArrayList<>();
 
 	@Override
 	public void put(String str, T value) {

File: jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java
Patch:
@@ -7,7 +7,7 @@
 public class SimpleIndex<T> implements SearchIndex<T> {
 
 	private final List<String> keys = new ArrayList<>();
-	private final List<T> values = new ArrayList<T>();
+	private final List<T> values = new ArrayList<>();
 
 	@Override
 	public void put(String str, T value) {

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -8,6 +8,9 @@ public class ParserConstants {
 	protected ParserConstants() {
 	}
 
+
+	protected static final String ANDROID_NS_URL = "http://schemas.android.com/apk/res/android";
+
 	/**
 	 * Chunk types
 	 */

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -21,4 +21,7 @@ public class Consts {
 	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";
 
 	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";
+
+	private Consts() {
+	}
 }

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -56,7 +56,7 @@ public static ManifestAttributes getInstance() {
 			try {
 				instance = new ManifestAttributes();
 			} catch (Exception e) {
-				e.printStackTrace();
+				LOG.error("Failed to create ManifestAttributes", e);
 			}
 		}
 		return instance;

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -22,7 +22,7 @@ public class JadxWrapper {
 	private final JadxDecompiler decompiler;
 	private File openFile;
 
-	public JadxWrapper(IJadxArgs jadxArgs) {
+	public JadxWrapper(IJadxArgs jadxArgs) throws JadxException {
 		this.decompiler = new JadxDecompiler(jadxArgs);
 	}
 
@@ -53,7 +53,7 @@ public void run() {
 					}
 					progressMonitor.close();
 					LOG.info("done");
-				} catch (InterruptedException e) {
+				} catch (InterruptedException|JadxException e) {
 					LOG.error("Save interrupted", e);
 					Thread.currentThread().interrupt();
 				}

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -32,6 +32,7 @@
 import org.slf4j.LoggerFactory;
 
 import jadx.api.ResourceFile;
+import jadx.core.utils.exceptions.JadxException;
 import jadx.gui.JadxWrapper;
 import jadx.gui.jobs.BackgroundWorker;
 import jadx.gui.jobs.DecompileJob;
@@ -100,7 +101,7 @@ public class MainWindow extends JFrame {
 	private transient ProgressPanel progressPane;
 	private transient BackgroundWorker backgroundWorker;
 
-	public MainWindow(JadxSettings settings) {
+	public MainWindow(JadxSettings settings) throws JadxException {
 		this.wrapper = new JadxWrapper(settings);
 		this.settings = settings;
 		this.cacheObject = new CacheObject();

File: jadx-gui/src/test/java/jadx/gui/treemodel/JSourcesTest.java
Patch:
@@ -12,6 +12,7 @@
 import jadx.api.JavaClass;
 import jadx.api.JavaPackage;
 import jadx.core.dex.nodes.ClassNode;
+import jadx.core.utils.exceptions.JadxException;
 import jadx.gui.JadxWrapper;
 
 import static org.junit.Assert.assertEquals;
@@ -24,7 +25,7 @@ public class JSourcesTest {
 	private JadxDecompiler decompiler;
 
 	@Before
-	public void init() {
+	public void init() throws JadxException {
 		JRoot root = mock(JRoot.class);
 		when(root.isFlatPackages()).thenReturn(false);
 		JadxWrapper wrapper = mock(JadxWrapper.class);

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -83,8 +83,9 @@ public ClassNode getClassNode(Class<?> clazz) {
 	}
 
 	public ClassNode getClassNodeFromFile(File file, String clsName) {
-		JadxDecompiler d = new JadxDecompiler(args);
+		JadxDecompiler d = null;
 		try {
+			d = new JadxDecompiler(args);
 			d.loadFile(file);
 		} catch (JadxException e) {
 			e.printStackTrace();

File: jadx-core/src/main/java/jadx/api/IJadxArgs.java
Patch:
@@ -14,6 +14,8 @@ public interface IJadxArgs {
 	boolean isFallbackMode();
 
 	boolean isShowInconsistentCode();
+	
+	boolean isUsingImports();
 
 	boolean isVerbose();
 

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -245,7 +245,7 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]
 	 * Return fallback variant of method codegen
 	 */
 	public static MethodGen getFallbackMethodGen(MethodNode mth) {
-		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true, true);
+		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true, true, true);
 		return new MethodGen(clsGen, mth);
 	}
 

File: jadx-core/src/main/java/jadx/api/ResourceFile.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.api;
 
-import java.io.File;
-
 import jadx.core.xmlgen.ResContainer;
 
+import java.io.File;
+
 public class ResourceFile {
 
 	public static final class ZipRef {

File: jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java
Patch:
@@ -30,7 +30,7 @@ public static void main(String[] args) throws IOException, DecodeException {
 		}
 		File output = new File(args[0]);
 
-		List<InputFile> inputFiles = new ArrayList<InputFile>(args.length - 1);
+		List<InputFile> inputFiles = new ArrayList<>(args.length - 1);
 		for (int i = 1; i < args.length; i++) {
 			File f = new File(args[i]);
 			if (f.isDirectory()) {

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -26,7 +26,7 @@ public class ConditionGen extends InsnGen {
 	private static final Logger LOG = LoggerFactory.getLogger(ConditionGen.class);
 
 	private static class CondStack {
-		private final Queue<IfCondition> stack = new LinkedList<IfCondition>();
+		private final Queue<IfCondition> stack = new LinkedList<>();
 
 		public Queue<IfCondition> getStack() {
 			return stack;

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -752,7 +752,7 @@ private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter
 			}
 			// replace args
 			InsnNode inlCopy = inl.copy();
-			List<RegisterArg> inlArgs = new ArrayList<RegisterArg>();
+			List<RegisterArg> inlArgs = new ArrayList<>();
 			inlCopy.getRegisterArgs(inlArgs);
 			for (RegisterArg r : inlArgs) {
 				int regNum = r.getRegNum();

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -81,7 +81,7 @@ public boolean addDefinition(CodeWriter code) {
 			ai = ai.remove(AccessFlags.ACC_PUBLIC);
 		}
 
-		if(mth.getMethodInfo().isRenamed()) {
+		if (mth.getMethodInfo().isRenamed()) {
 			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");
 		}
 		code.startLineWithNum(mth.getSourceLine());
@@ -133,7 +133,7 @@ private void addMethodArguments(CodeWriter argsCode, List<RegisterArg> args) {
 				annotationGen.addForParameter(argsCode, paramsAnnotation, i);
 			}
 			SSAVar argSVar = arg.getSVar();
-			if (argSVar!= null && argSVar.contains(AFlag.FINAL)) {
+			if (argSVar != null && argSVar.contains(AFlag.FINAL)) {
 				argsCode.add("final ");
 			}
 			if (!it.hasNext() && mth.getAccessFlags().isVarArgs()) {

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -13,7 +13,7 @@ public class NameMapper {
 	private static final Pattern VALID_JAVA_FULL_IDENTIFIER = Pattern.compile(
 			"(" + VALID_JAVA_IDENTIFIER + "\\.)*" + VALID_JAVA_IDENTIFIER);
 
-	private static final Set<String> RESERVED_NAMES = new HashSet<String>(
+	private static final Set<String> RESERVED_NAMES = new HashSet<>(
 			Arrays.asList(new String[]{
 					"abstract",
 					"assert",

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttrList.java
Patch:
@@ -8,7 +8,7 @@
 public class AttrList<T> implements IAttribute {
 
 	private final AType<AttrList<T>> type;
-	private final List<T> list = new LinkedList<T>();
+	private final List<T> list = new LinkedList<>();
 
 	public AttrList(AType<AttrList<T>> type) {
 		this.type = type;

File: jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java
Patch:
@@ -1,7 +1,5 @@
 package jadx.core.dex.attributes;
 
 public interface IAttribute {
-
-	AType<?> getType();
-
+	AType<? extends IAttribute> getType();
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java
Patch:
@@ -17,7 +17,7 @@ public class AnnotationsList implements IAttribute {
 	private final Map<String, Annotation> map;
 
 	public AnnotationsList(List<Annotation> anList) {
-		map = new HashMap<String, Annotation>(anList.size());
+		map = new HashMap<>(anList.size());
 		for (Annotation a : anList) {
 			map.put(a.getAnnotationClass(), a);
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java
Patch:
@@ -12,7 +12,7 @@ public class MethodParameters implements IAttribute {
 	private final List<AnnotationsList> paramList;
 
 	public MethodParameters(int paramCount) {
-		paramList = new ArrayList<AnnotationsList>(paramCount);
+		paramList = new ArrayList<>(paramCount);
 	}
 
 	public List<AnnotationsList> getParamList() {

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/DeclareVariablesAttr.java
Patch:
@@ -13,7 +13,7 @@
  */
 public class DeclareVariablesAttr implements IAttribute {
 
-	private final List<RegisterArg> vars = new LinkedList<RegisterArg>();
+	private final List<RegisterArg> vars = new LinkedList<>();
 
 	public Iterable<RegisterArg> getVars() {
 		return vars;

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java
Patch:
@@ -54,7 +54,7 @@ public String toString() {
 	private MethodNode staticMethod;
 
 	public EnumClassAttr(int fieldsCount) {
-		this.fields = new ArrayList<EnumField>(fieldsCount);
+		this.fields = new ArrayList<>(fieldsCount);
 	}
 
 	public List<EnumField> getFields() {

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java
Patch:
@@ -10,7 +10,7 @@
 public class EnumMapAttr implements IAttribute {
 
 	public static class KeyValueMap {
-		private final Map<Object, Object> map = new HashMap<Object, Object>();
+		private final Map<Object, Object> map = new HashMap<>();
 
 		public Object get(Object key) {
 			return map.get(key);
@@ -21,7 +21,7 @@ void put(Object key, Object value) {
 		}
 	}
 
-	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();
+	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<>();
 
 	public KeyValueMap getMap(FieldNode field) {
 		return fieldsMap.get(field);

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java
Patch:
@@ -10,7 +10,7 @@
 
 public class IgnoreEdgeAttr implements IAttribute {
 
-	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);
+	private final Set<BlockNode> blocks = new HashSet<>(3);
 
 	public Set<BlockNode> getBlocks() {
 		return blocks;

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LoopInfo.java
Patch:
@@ -43,7 +43,7 @@ public Set<BlockNode> getLoopBlocks() {
 	 * Exit nodes belongs to loop (contains in {@code loopBlocks})
 	 */
 	public Set<BlockNode> getExitNodes() {
-		Set<BlockNode> nodes = new HashSet<BlockNode>();
+		Set<BlockNode> nodes = new HashSet<>();
 		Set<BlockNode> blocks = getLoopBlocks();
 		for (BlockNode block : blocks) {
 			// exit: successor node not from this loop, (don't change to getCleanSuccessors)
@@ -60,7 +60,7 @@ public Set<BlockNode> getExitNodes() {
 	 * Return loop exit edges.
 	 */
 	public List<Edge> getExitEdges() {
-		List<Edge> edges = new LinkedList<Edge>();
+		List<Edge> edges = new LinkedList<>();
 		Set<BlockNode> blocks = getLoopBlocks();
 		for (BlockNode block : blocks) {
 			for (BlockNode s : block.getSuccessors()) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/PhiListAttr.java
Patch:
@@ -9,7 +9,7 @@
 
 public class PhiListAttr implements IAttribute {
 
-	private final List<PhiInsn> list = new LinkedList<PhiInsn>();
+	private final List<PhiInsn> list = new LinkedList<>();
 
 	@Override
 	public AType<PhiListAttr> getType() {

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -89,7 +89,7 @@ private void splitNames(DexNode dex, boolean canBeInner) {
 		int sep = clsName.lastIndexOf('$');
 		if (canBeInner && sep > 0 && sep != clsName.length() - 1) {
 			String parClsName = pkg + "." + clsName.substring(0, sep);
-			if(pkg.length() == 0) {
+			if (pkg.isEmpty()) {
 				parClsName = clsName.substring(0, sep);
 			}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java
Patch:
@@ -66,7 +66,7 @@ public void mergeElementType(DexNode dex, ArgType foundElemType) {
 	}
 
 	public List<LiteralArg> getLiteralArgs() {
-		List<LiteralArg> list = new ArrayList<LiteralArg>(size);
+		List<LiteralArg> list = new ArrayList<>(size);
 		Object array = data;
 		if (array instanceof int[]) {
 			for (int b : (int[]) array) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -21,7 +21,7 @@ public final class PhiInsn extends InsnNode {
 
 	public PhiInsn(int regNum, int predecessors) {
 		super(InsnType.PHI, predecessors);
-		this.blockBinds = new IdentityHashMap<RegisterArg, BlockNode>(predecessors);
+		this.blockBinds = new IdentityHashMap<>(predecessors);
 		setResult(InsnArg.reg(regNum, ArgType.UNKNOWN));
 		add(AFlag.DONT_INLINE);
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java
Patch:
@@ -101,7 +101,7 @@ public InsnArg wrapInstruction(InsnNode insn) {
 	}
 
 	public static void updateParentInsn(InsnNode fromInsn, InsnNode toInsn) {
-		List<RegisterArg> args = new ArrayList<RegisterArg>();
+		List<RegisterArg> args = new ArrayList<>();
 		fromInsn.getRegisterArgs(args);
 		for (RegisterArg reg : args) {
 			reg.setParentInsn(toInsn);

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java
Patch:
@@ -20,7 +20,7 @@ public class SSAVar extends AttrNode {
 
 	@NotNull
 	private RegisterArg assign;
-	private final List<RegisterArg> useList = new ArrayList<RegisterArg>(2);
+	private final List<RegisterArg> useList = new ArrayList<>(2);
 	@Nullable
 	private PhiInsn usedInPhi;
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/ILoadable.java
Patch:
@@ -6,14 +6,11 @@ public interface ILoadable {
 
 	/**
 	 * On demand loading
-	 *
-	 * @throws DecodeException
 	 */
 	void load() throws DecodeException;
 
 	/**
 	 * Free resources
 	 */
 	void unload();
-
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -42,7 +42,7 @@ public InsnNode(InsnType type, int argsCount) {
 		if (argsCount == 0) {
 			this.arguments = Collections.emptyList();
 		} else {
-			this.arguments = new ArrayList<InsnArg>(argsCount);
+			this.arguments = new ArrayList<>(argsCount);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java
Patch:
@@ -79,7 +79,7 @@ private AnnotationsList readAnnotationSet(int offset) throws DecodeException {
 		if (size == 0) {
 			return AnnotationsList.EMPTY;
 		}
-		List<Annotation> list = new ArrayList<Annotation>(size);
+		List<Annotation> list = new ArrayList<>(size);
 		for (int i = 0; i < size; i++) {
 			Section anSection = dex.openSection(section.readInt());
 			Annotation a = readAnnotation(dex, anSection, true);
@@ -97,7 +97,7 @@ public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisi
 		}
 		int typeIndex = s.readUleb128();
 		int size = s.readUleb128();
-		Map<String, Object> values = new LinkedHashMap<String, Object>(size);
+		Map<String, Object> values = new LinkedHashMap<>(size);
 		for (int i = 0; i < size; i++) {
 			String name = dex.getString(s.readUleb128());
 			values.put(name, parser.parseValue());

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java
Patch:
@@ -83,7 +83,7 @@ public Object parseValue() throws DecodeException {
 
 			case ENCODED_ARRAY:
 				int count = Leb128.readUnsignedLeb128(in);
-				List<Object> values = new ArrayList<Object>(count);
+				List<Object> values = new ArrayList<>(count);
 				for (int i = 0; i < count; i++) {
 					values.add(parseValue());
 				}

File: jadx-core/src/main/java/jadx/core/dex/regions/Region.java
Patch:
@@ -12,7 +12,7 @@ public final class Region extends AbstractRegion {
 
 	public Region(IRegion parent) {
 		super(parent);
-		this.blocks = new ArrayList<IContainer>(1);
+		this.blocks = new ArrayList<>(1);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java
Patch:
@@ -10,7 +10,7 @@
 public final class SynchronizedRegion extends AbstractRegion {
 
 	private final InsnNode enterInsn;
-	private final List<InsnNode> exitInsns = new LinkedList<InsnNode>();
+	private final List<InsnNode> exitInsns = new LinkedList<>();
 	private final Region region;
 
 	public SynchronizedRegion(IRegion parent, InsnNode insn) {

File: jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java
Patch:
@@ -28,7 +28,7 @@ public TryCatchRegion(IRegion parent, IContainer tryRegion) {
 	public void setTryCatchBlock(TryCatchBlock tryCatchBlock) {
 		this.tryCatchBlock = tryCatchBlock;
 		int count = tryCatchBlock.getHandlersCount();
-		this.catchRegions = new LinkedHashMap<ExceptionHandler, IContainer>(count);
+		this.catchRegions = new LinkedHashMap<>(count);
 		for (ExceptionHandler handler : tryCatchBlock.getHandlers()) {
 			IContainer handlerRegion = handler.getHandlerRegion();
 			if (handlerRegion != null) {
@@ -63,7 +63,7 @@ public void setFinallyRegion(IContainer finallyRegion) {
 
 	@Override
 	public List<IContainer> getSubBlocks() {
-		List<IContainer> all = new ArrayList<IContainer>(2 + catchRegions.size());
+		List<IContainer> all = new ArrayList<>(2 + catchRegions.size());
 		all.add(tryRegion);
 		all.addAll(catchRegions.values());
 		if (finallyRegion != null) {

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfRegion.java
Patch:
@@ -82,7 +82,7 @@ public int getSourceLine() {
 
 	@Override
 	public List<IContainer> getSubBlocks() {
-		List<IContainer> all = new ArrayList<IContainer>(3);
+		List<IContainer> all = new ArrayList<>(3);
 		all.add(header);
 		if (thenRegion != null) {
 			all.add(thenRegion);
@@ -95,7 +95,7 @@ public List<IContainer> getSubBlocks() {
 
 	@Override
 	public List<IContainer> getBranches() {
-		List<IContainer> branches = new ArrayList<IContainer>(2);
+		List<IContainer> branches = new ArrayList<>(2);
 		branches.add(thenRegion);
 		branches.add(elseRegion);
 		return Collections.unmodifiableList(branches);

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java
Patch:
@@ -136,7 +136,7 @@ public void setType(LoopType type) {
 
 	@Override
 	public List<IContainer> getSubBlocks() {
-		List<IContainer> all = new ArrayList<IContainer>(3);
+		List<IContainer> all = new ArrayList<>(3);
 		if (preCondition != null) {
 			all.add(preCondition);
 		}

File: jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java
Patch:
@@ -16,7 +16,7 @@ public class ExceptionHandler {
 	private final int handleOffset;
 
 	private BlockNode handlerBlock;
-	private final List<BlockNode> blocks = new ArrayList<BlockNode>();
+	private final List<BlockNode> blocks = new ArrayList<>();
 	private IContainer handlerRegion;
 	private InsnArg arg;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/AbstractVisitor.java
Patch:
@@ -9,15 +9,17 @@ public class AbstractVisitor implements IDexTreeVisitor {
 
 	@Override
 	public void init(RootNode root) throws JadxException {
+		// no op implementation
 	}
 
 	@Override
 	public boolean visit(ClassNode cls) throws JadxException {
+		// no op implementation
 		return true;
 	}
 
 	@Override
 	public void visit(MethodNode mth) throws JadxException {
+		// no op implementation
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java
Patch:
@@ -57,7 +57,7 @@ public ArgsInfo(InsnNode insn, List<ArgsInfo> argsList, int pos) {
 		}
 
 		public static List<RegisterArg> getArgs(InsnNode insn) {
-			List<RegisterArg> args = new LinkedList<RegisterArg>();
+			List<RegisterArg> args = new LinkedList<>();
 			addArgs(insn, args);
 			return args;
 		}
@@ -191,11 +191,11 @@ private static void shrinkBlock(MethodNode mth, BlockNode block) {
 		}
 		InsnList insnList = new InsnList(block.getInstructions());
 		int insnCount = insnList.size();
-		List<ArgsInfo> argsList = new ArrayList<ArgsInfo>(insnCount);
+		List<ArgsInfo> argsList = new ArrayList<>(insnCount);
 		for (int i = 0; i < insnCount; i++) {
 			argsList.add(new ArgsInfo(insnList.get(i), argsList, i));
 		}
-		List<WrapInfo> wrapList = new ArrayList<WrapInfo>();
+		List<WrapInfo> wrapList = new ArrayList<>();
 		for (ArgsInfo argsInfo : argsList) {
 			List<RegisterArg> args = argsInfo.getArgs();
 			if (args.isEmpty()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java
Patch:
@@ -31,7 +31,7 @@ public void visit(MethodNode mth) throws JadxException {
 		if (mth.isNoCode()) {
 			return;
 		}
-		List<InsnNode> toRemove = new ArrayList<InsnNode>();
+		List<InsnNode> toRemove = new ArrayList<>();
 		for (BlockNode block : mth.getBasicBlocks()) {
 			toRemove.clear();
 			for (InsnNode insn : block.getInstructions()) {
@@ -99,7 +99,7 @@ private static boolean checkObjectInline(SSAVar sVar) {
 
 	private static boolean replaceConst(MethodNode mth, InsnNode constInsn, long literal) {
 		SSAVar sVar = constInsn.getResult().getSVar();
-		List<RegisterArg> use = new ArrayList<RegisterArg>(sVar.getUseList());
+		List<RegisterArg> use = new ArrayList<>(sVar.getUseList());
 		int replaceCount = 0;
 		for (RegisterArg arg : use) {
 			InsnNode useInsn = arg.getParentInsn();

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -64,7 +64,7 @@ public boolean visit(ClassNode cls) throws JadxException {
 		String valuesMethod = "values()" + TypeGen.signature(ArgType.array(clsType));
 
 		// collect enum fields, remove synthetic
-		List<FieldNode> enumFields = new ArrayList<FieldNode>();
+		List<FieldNode> enumFields = new ArrayList<>();
 		for (FieldNode f : cls.getFields()) {
 			if (f.getAccessFlags().isEnum()) {
 				enumFields.add(f);
@@ -101,7 +101,7 @@ public boolean visit(ClassNode cls) throws JadxException {
 
 		// move enum specific instruction from static method to separate list
 		BlockNode staticBlock = staticMethod.getBasicBlocks().get(0);
-		List<InsnNode> enumPutInsns = new ArrayList<InsnNode>();
+		List<InsnNode> enumPutInsns = new ArrayList<>();
 		List<InsnNode> list = staticBlock.getInstructions();
 		int size = list.size();
 		for (int i = 0; i < size; i++) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/IDexTreeVisitor.java
Patch:
@@ -19,14 +19,11 @@ public interface IDexTreeVisitor {
 	 * Visit class
 	 *
 	 * @return false for disable child methods and inner classes traversal
-	 * @throws JadxException
 	 */
 	boolean visit(ClassNode cls) throws JadxException;
 
 	/**
 	 * Visit method
-	 *
-	 * @throws JadxException
 	 */
 	void visit(MethodNode mth) throws JadxException;
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -298,7 +298,7 @@ private static InsnNode convertFieldArith(MethodNode mth, InsnNode insn) {
 	}
 
 	private static List<InsnNode> flattenInsnChain(InsnNode insn) {
-		List<InsnNode> chain = new ArrayList<InsnNode>();
+		List<InsnNode> chain = new ArrayList<>();
 		InsnArg i = insn.getArg(0);
 		while (i.isInsnWrap()) {
 			InsnNode wrapInsn = ((InsnWrapArg) i).getWrapInsn();

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java
Patch:
@@ -63,7 +63,7 @@ private static void fixSplitterBlock(BlockNode block) {
 		if (handlerBlock.getPredecessors().size() < 2) {
 			return;
 		}
-		Map<BlockNode, SplitterBlockAttr> splitters = new HashMap<BlockNode, SplitterBlockAttr>();
+		Map<BlockNode, SplitterBlockAttr> splitters = new HashMap<>();
 		for (BlockNode pred : handlerBlock.getPredecessors()) {
 			pred = BlockUtils.skipSyntheticPredecessor(pred);
 			SplitterBlockAttr splitterAttr = pred.get(AType.SPLITTER_BLOCK);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java
Patch:
@@ -292,7 +292,7 @@ private static boolean modifyBlocksTree(MethodNode mth) {
 				BlockNode loopEnd = loop.getEnd();
 				if (loopEnd.getPredecessors().size() > 1) {
 					boolean change = false;
-					List<BlockNode> nodes = new ArrayList<BlockNode>(loopEnd.getPredecessors());
+					List<BlockNode> nodes = new ArrayList<>(loopEnd.getPredecessors());
 					for (BlockNode pred : nodes) {
 						if (!pred.contains(AFlag.SYNTHETIC)) {
 							BlockSplitter.insertBlockBetween(mth, pred, loopEnd);

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java
Patch:
@@ -47,7 +47,7 @@ public void visit(MethodNode mth) {
 
 	private static void splitBasicBlocks(MethodNode mth) {
 		InsnNode prevInsn = null;
-		Map<Integer, BlockNode> blocksMap = new HashMap<Integer, BlockNode>();
+		Map<Integer, BlockNode> blocksMap = new HashMap<>();
 		BlockNode curBlock = startNewBlock(mth, 0);
 		mth.setEnterBlock(curBlock);
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/helpers/BlocksRemoveInfo.java
Patch:
@@ -11,9 +11,9 @@
 import org.jetbrains.annotations.Nullable;
 
 public final class BlocksRemoveInfo {
-	private final Set<BlocksPair> processed = new HashSet<BlocksPair>();
-	private final Set<BlocksPair> outs = new HashSet<BlocksPair>();
-	private final Map<RegisterArg, RegisterArg> regMap = new HashMap<RegisterArg, RegisterArg>();
+	private final Set<BlocksPair> processed = new HashSet<>();
+	private final Set<BlocksPair> outs = new HashSet<>();
+	private final Map<RegisterArg, RegisterArg> regMap = new HashMap<>();
 
 	private BlocksPair start;
 	private BlocksPair end;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -29,7 +29,7 @@ public void visit(MethodNode mth) throws JadxException {
 		}
 
 		// check if all blocks included in regions
-		final Set<BlockNode> blocksInRegions = new HashSet<BlockNode>();
+		Set<BlockNode> blocksInRegions = new HashSet<>();
 		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {
 			@Override
 			public void processBlock(MethodNode mth, IBlock container) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java
Patch:
@@ -49,8 +49,8 @@ static IfInfo searchNestedIf(IfInfo info) {
 	}
 
 	static IfInfo restructureIf(MethodNode mth, BlockNode block, IfInfo info) {
-		final BlockNode thenBlock = info.getThenBlock();
-		final BlockNode elseBlock = info.getElseBlock();
+		BlockNode thenBlock = info.getThenBlock();
+		BlockNode elseBlock = info.getElseBlock();
 
 		// select 'then', 'else' and 'exit' blocks
 		if (thenBlock.contains(AFlag.RETURN) && elseBlock.contains(AFlag.RETURN)) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java
Patch:
@@ -110,7 +110,7 @@ private static boolean isIfRegion(IContainer container) {
 	private static void moveReturnToThenBlock(MethodNode mth, IfRegion ifRegion) {
 		if (!mth.getReturnType().equals(ArgType.VOID)
 				&& hasSimpleReturnBlock(ifRegion.getElseRegion())
-				/*&& insnsCount(ifRegion.getThenRegion()) < 2*/) {
+			/*&& insnsCount(ifRegion.getThenRegion()) < 2*/) {
 			invertIfRegion(ifRegion);
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -105,7 +105,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion
 			return false;
 		}
 		// can't make loop if argument from increment instruction is assign in loop
-		List<RegisterArg> args = new LinkedList<RegisterArg>();
+		List<RegisterArg> args = new LinkedList<>();
 		incrInsn.getRegisterArgs(args);
 		for (RegisterArg iArg : args) {
 			if (assignOnlyInLoop(mth, loopRegion, iArg)) {
@@ -230,7 +230,7 @@ private static boolean checkIterableForEach(MethodNode mth, LoopRegion loopRegio
 				|| !checkInvoke(nextCall, "java.util.Iterator", "next()Ljava/lang/Object;", 0)) {
 			return false;
 		}
-		List<InsnNode> toSkip = new LinkedList<InsnNode>();
+		List<InsnNode> toSkip = new LinkedList<>();
 		RegisterArg iterVar = nextCall.getResult();
 		if (iterVar == null) {
 			return false;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -41,7 +41,7 @@ public static void process(MethodNode mth) {
 			return;
 		}
 
-		final Map<BlockNode, TryCatchBlock> tryBlocksMap = new HashMap<BlockNode, TryCatchBlock>(2);
+		Map<BlockNode, TryCatchBlock> tryBlocksMap = new HashMap<>(2);
 		searchTryCatchDominators(mth, tryBlocksMap);
 
 		IRegionIterativeVisitor visitor = new IRegionIterativeVisitor() {
@@ -55,7 +55,7 @@ public boolean visitRegion(MethodNode mth, IRegion region) {
 	}
 
 	private static void searchTryCatchDominators(MethodNode mth, Map<BlockNode, TryCatchBlock> tryBlocksMap) {
-		Set<TryCatchBlock> tryBlocks = new HashSet<TryCatchBlock>();
+		Set<TryCatchBlock> tryBlocks = new HashSet<>();
 		// collect all try/catch blocks
 		for (BlockNode block : mth.getBasicBlocks()) {
 			CatchAttr c = block.get(AType.CATCH_BLOCK);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -113,7 +113,7 @@ private static void processSwitch(MethodNode mth, SwitchRegion sw) {
 			if (!(c instanceof Region)) {
 				continue;
 			}
-			Set<IBlock> blocks = new HashSet<IBlock>();
+			Set<IBlock> blocks = new HashSet<>();
 			RegionUtils.getAllRegionBlocks(c, blocks);
 			if (blocks.isEmpty()) {
 				addBreakToContainer((Region) c);
@@ -151,7 +151,7 @@ private static void addBreakToContainer(Region c) {
 		if (RegionUtils.hasExitEdge(c)) {
 			return;
 		}
-		List<InsnNode> insns = new ArrayList<InsnNode>(1);
+		List<InsnNode> insns = new ArrayList<>(1);
 		insns.add(new InsnNode(InsnType.BREAK, 0));
 		c.add(new InsnContainer(insns));
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionStack.java
Patch:
@@ -31,11 +31,11 @@ private static final class State {
 		IRegion region;
 
 		public State() {
-			exits = new HashSet<BlockNode>(4);
+			exits = new HashSet<>(4);
 		}
 
 		private State(State c) {
-			exits = new HashSet<BlockNode>(c.exits);
+			exits = new HashSet<>(c.exits);
 		}
 
 		public State copy() {
@@ -55,7 +55,7 @@ public RegionStack(MethodNode mth) {
 		if (DEBUG) {
 			LOG.debug("New RegionStack: {}", mth);
 		}
-		this.stack = new ArrayDeque<State>();
+		this.stack = new ArrayDeque<>();
 		this.curState = new State();
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java
Patch:
@@ -160,7 +160,7 @@ private static boolean checkLineStats(InsnNode t, InsnNode e) {
 		if (tPhi == null || ePhi == null || tPhi != ePhi) {
 			return false;
 		}
-		Map<Integer, Integer> map = new HashMap<Integer, Integer>(tPhi.getArgsCount());
+		Map<Integer, Integer> map = new HashMap<>(tPhi.getArgsCount());
 		for (InsnArg arg : tPhi.getArguments()) {
 			if (!arg.isRegister()) {
 				continue;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TracedRegionVisitor.java
Patch:
@@ -9,7 +9,7 @@
 
 public abstract class TracedRegionVisitor implements IRegionVisitor {
 
-	protected final Deque<IRegion> regionStack = new ArrayDeque<IRegion>();
+	protected final Deque<IRegion> regionStack = new ArrayDeque<>();
 
 	@Override
 	public boolean enterRegion(MethodNode mth, IRegion region) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java
Patch:
@@ -149,5 +149,4 @@ private static boolean fixArrayTypes(DexNode dex, InsnArg array, InsnArg elem) {
 		}
 		return change;
 	}
-
 }

File: jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java
Patch:
@@ -21,7 +21,7 @@ public class ExportGradleProject {
 
 	private static final Logger LOG = LoggerFactory.getLogger(ExportGradleProject.class);
 
-	private static final Set<String> IGNORE_CLS_NAMES = new HashSet<String>(Arrays.asList(
+	private static final Set<String> IGNORE_CLS_NAMES = new HashSet<>(Arrays.asList(
 			"R",
 			"BuildConfig"
 	));

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -20,7 +20,7 @@
 public class ErrorsCounter {
 	private static final Logger LOG = LoggerFactory.getLogger(ErrorsCounter.class);
 
-	private final Set<Object> errorNodes = new HashSet<Object>();
+	private final Set<Object> errorNodes = new HashSet<>();
 	private int errorsCount;
 
 	public int getErrorCount() {
@@ -69,7 +69,7 @@ public static String methodError(MethodNode mth, String errorMsg) {
 	public void printReport() {
 		if (getErrorCount() > 0) {
 			LOG.error("{} errors occurred in following nodes:", getErrorCount());
-			List<Object> nodes = new ArrayList<Object>(errorNodes);
+			List<Object> nodes = new ArrayList<>(errorNodes);
 			Collections.sort(nodes, new Comparator<Object>() {
 				@Override
 				public int compare(Object o1, Object o2) {

File: jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java
Patch:
@@ -36,7 +36,7 @@ public InstructionRemover(MethodNode mth) {
 
 	public InstructionRemover(MethodNode mth, BlockNode block) {
 		this.mth = mth;
-		this.toRemove = new ArrayList<InsnNode>();
+		this.toRemove = new ArrayList<>();
 		if (block != null) {
 			this.instrList = block.getInstructions();
 		}

File: jadx-core/src/main/java/jadx/core/utils/RegionUtils.java
Patch:
@@ -185,7 +185,7 @@ public static List<IContainer> getExcHandlersForRegion(IContainer region) {
 		CatchAttr cb = region.get(AType.CATCH_BLOCK);
 		if (cb != null) {
 			TryCatchBlock tb = cb.getTryBlock();
-			List<IContainer> list = new ArrayList<IContainer>(tb.getHandlersCount());
+			List<IContainer> list = new ArrayList<>(tb.getHandlersCount());
 			for (ExceptionHandler eh : tb.getHandlers()) {
 				list.add(eh.getHandlerRegion());
 			}

File: jadx-core/src/main/java/jadx/core/utils/files/DexFile.java
Patch:
@@ -27,6 +27,6 @@ public InputFile getInputFile() {
 
 	@Override
 	public String toString() {
-		return inputFile.toString() + (name.isEmpty() ? "" : ":" + name);
+		return inputFile + (name.isEmpty() ? "" : ":" + name);
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.core.utils.files;
 
+import jadx.core.utils.exceptions.JadxException;
+
 import java.io.ByteArrayOutputStream;
 
 import com.android.dx.command.dexer.DxContext;
 import com.android.dx.command.dexer.Main;
 import com.android.dx.command.dexer.Main.Arguments;
 
-import jadx.core.utils.exceptions.JadxException;
-
 import static jadx.core.utils.files.FileUtils.close;
 
 public class JavaToDex {

File: jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java
Patch:
@@ -20,7 +20,7 @@ public int compare(ResourceEntry a, ResourceEntry b) {
 		}
 	};
 
-	private final List<ResourceEntry> list = new ArrayList<ResourceEntry>();
+	private final List<ResourceEntry> list = new ArrayList<>();
 	private String appPackage;
 
 	public Collection<ResourceEntry> getResources() {
@@ -53,7 +53,7 @@ public void setAppPackage(String appPackage) {
 	}
 
 	public Map<Integer, String> getResourcesNames() {
-		Map<Integer, String> map = new HashMap<Integer, String>();
+		Map<Integer, String> map = new HashMap<>();
 		for (ResourceEntry entry : list) {
 			map.put(entry.getId(), entry.getTypeName() + "/" + entry.getKeyName());
 		}

File: jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java
Patch:
@@ -34,8 +34,8 @@ public ClassLoader getClassLoader(Location location) {
 	}
 
 	private class DynamicClassLoader extends SecureClassLoader {
-		private final Map<String, JavaClassObject> clsMap = new HashMap<String, JavaClassObject>();
-		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();
+		private final Map<String, JavaClassObject> clsMap = new HashMap<>();
+		private final Map<String, Class<?>> clsCache = new HashMap<>();
 
 		@Override
 		protected Class<?> findClass(String name) throws ClassNotFoundException {

File: jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java
Patch:
@@ -1,7 +1,5 @@
 package jadx.tests.api.compiler;
 
-import jadx.core.dex.nodes.ClassNode;
-
 import javax.tools.JavaCompiler;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
@@ -10,6 +8,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import jadx.core.dex.nodes.ClassNode;
+
 import static javax.tools.JavaCompiler.CompilationTask;
 
 public class DynamicCompiler {
@@ -31,7 +31,7 @@ public boolean compile() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 		fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));
 
-		List<JavaFileObject> jFiles = new ArrayList<JavaFileObject>(1);
+		List<JavaFileObject> jFiles = new ArrayList<>(1);
 		jFiles.add(new CharSequenceJavaFileObject(fullName, code));
 
 		CompilationTask compilerTask = compiler.getTask(null, fileManager, null, null, null, jFiles);

File: jadx-core/src/test/java/jadx/tests/api/utils/JadxMatchers.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.tests.api.utils;
 
-import jadx.core.codegen.CodeWriter;
-
 import org.hamcrest.Matcher;
 
+import jadx.core.codegen.CodeWriter;
+
 public class JadxMatchers {
 
 	public static Matcher<String> countString(int count, String substring) {

File: jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java
Patch:
@@ -6,11 +6,11 @@ public class TestUtils {
 
 	public static String indent(int indent) {
 		if (indent == 1) {
-			return CodeWriter.INDENT;
+			return CodeWriter.INDENT_STR;
 		}
-		StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT.length());
+		StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT_STR.length());
 		for (int i = 0; i < indent; i++) {
-			sb.append(CodeWriter.INDENT);
+			sb.append(CodeWriter.INDENT_STR);
 		}
 		return sb.toString();
 	}

File: jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java
Patch:
@@ -1,9 +1,9 @@
 package jadx.tests.functional;
 
-import jadx.core.export.TemplateFile;
-
 import org.junit.Test;
 
+import jadx.core.export.TemplateFile;
+
 import static org.hamcrest.Matchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/functional/TestIfCondition.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.tests.functional;
 
+import org.junit.Test;
+
 import jadx.core.dex.instructions.IfNode;
 import jadx.core.dex.instructions.IfOp;
 import jadx.core.dex.instructions.args.ArgType;
@@ -8,8 +10,6 @@
 import jadx.core.dex.regions.conditions.Compare;
 import jadx.core.dex.regions.conditions.IfCondition;
 
-import org.junit.Test;
-
 import static jadx.core.dex.regions.conditions.IfCondition.Mode;
 import static jadx.core.dex.regions.conditions.IfCondition.merge;
 import static jadx.core.dex.regions.conditions.IfCondition.not;

File: jadx-core/src/test/java/jadx/tests/integration/TestArgInline.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestClassGen.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestFloatValue.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestRedundantBrackets.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestRedundantReturn.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestReturnWrapping.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/TestStaticFieldsInit.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestStaticMethod.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/TestStringBuilderElimination.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotations.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.annotations;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotations2.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.tests.integration.annotations;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/annotations/TestParamAnnotations.java
Patch:
@@ -1,15 +1,15 @@
 package jadx.tests.integration.annotations;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArith.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arith;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arith;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arith;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arith;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement3.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.arith;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Random;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arith/TestSpecialValues.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arith;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arrays;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arrays;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFillConstReplace.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arrays;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arrays;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arrays;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.arrays;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestCmpOp.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestCmpOp2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions10.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions11.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions12.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions13.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions15.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions16.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 public class TestConditions2 extends IntegrationTest {
 
 	public static class TestCls {

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 import java.util.regex.Pattern;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions4.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions5.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions6.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.conditions;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions7.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions8.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions9.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestElseIf.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestNestedIf.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestNestedIf2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestSimpleConditions.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary3.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.Named;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.conditions;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.debuginfo;
 
+import org.junit.Test;
+
 import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.FieldNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestReturnSourceLine.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.debuginfo;
 
+import org.junit.Test;
+
 import jadx.core.codegen.CodeWriter;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java
Patch:
@@ -1,11 +1,11 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 import jadx.tests.api.utils.JadxMatchers;
 
-import org.junit.Test;
-
 import static org.junit.Assert.assertThat;
 
 public class TestEnums2 extends IntegrationTest {

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums4.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java
Patch:
@@ -1,9 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 import jadx.tests.api.utils.JadxMatchers;
-import org.junit.Test;
 
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsWithConsts.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestSwitchOverEnum.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/enums/TestSwitchOverEnum2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.enums;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.fallback;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.generics;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics2.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.generics;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.Map;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics3.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.generics;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics4.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.generics;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics6.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.generics;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Collection;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inline;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inline;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inline;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInline6.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inline;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inline;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticInline.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inline;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.File;
 import java.io.FilenameFilter;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass10.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Random;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass11.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.inner;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Random;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass12.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass4.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass6.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass7.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass8.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass9.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.concurrent.Callable;
 import java.util.concurrent.FutureTask;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.inner;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Timer;
 import java.util.TimerTask;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass4.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClass5.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldAccess.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.inner;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.invoke;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.Matchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvoke1.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.invoke;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.IOException;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvokeInCatch.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.invoke;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.IOException;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedMethodInvoke.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.invoke;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvoke.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.invoke;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/invoke/TestVarArg.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.invoke;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEachNegative.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInComplexIf2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Arrays;
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakWithLabel.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.lang.reflect.Method;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop2.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.nodes.BlockNode;
@@ -14,8 +16,6 @@
 import jadx.core.utils.InstructionRemover;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIfInLoop2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIfInLoop3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexForLoop.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach2.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.IOException;
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach3.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Set;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition4.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopConditionInvoke.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection4.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.Iterator;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops2.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.loops;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.util.List;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestSequentialLoops.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.hamcrest.CoreMatchers.containsString;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestTryCatchInLoop.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.loops;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/names/TestSameMethodsNames.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.names;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.others;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.others;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.net.MalformedURLException;
 import java.net.URL;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIfInTry.java
Patch:
@@ -1,13 +1,13 @@
 package jadx.tests.integration.others;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.File;
 import java.io.IOException;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIfTryInCatch.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.others;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13b.java
Patch:
@@ -1,8 +1,5 @@
 package jadx.tests.integration.others;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -11,6 +8,9 @@
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/others/TestLoopInTry.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.others;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchBreak.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertEquals;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertEquals;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchLabels.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchNoDefault.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
 
 public class TestSwitchNoDefault extends IntegrationTest {

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertEquals;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchSimple.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertEquals;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithTryCatch.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.switches;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.countString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.synchronize;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.synchronize;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.synchronize;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsLines;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.trycatch;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.trycatch;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinallyExtract.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.trycatch;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.IOException;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.trycatch;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.File;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestNestedTryCatch.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.trycatch;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.trycatch;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch2.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.trycatch;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch3.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.trycatch;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertEquals;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch4.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.trycatch;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertThat;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch5.java
Patch:
@@ -1,14 +1,14 @@
 package jadx.tests.integration.trycatch;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertThat;
 

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch6.java
Patch:
@@ -1,12 +1,12 @@
 package jadx.tests.integration.trycatch;
 
-import jadx.core.dex.nodes.ClassNode;
-import jadx.tests.api.IntegrationTest;
-
 import java.io.IOException;
 
 import org.junit.Test;
 
+import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.IntegrationTest;
+
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch7.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.tests.integration.trycatch;
 
+import org.junit.Test;
+
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Test;
-
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
 import static org.junit.Assert.assertThat;
 

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -11,7 +11,7 @@
 public class JadxCLI {
 	private static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);
 
-	public static void main(String[] args) throws JadxException {
+	public static void main(String[] args) {
 		try {
 			JadxCLIArgs jadxArgs = new JadxCLIArgs();
 			if (processArgs(jadxArgs, args)) {

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -50,6 +50,7 @@ public static JadxSettings load() {
 				return new JadxSettings();
 			}
 			LOG.debug("Loaded settings: {}", makeString(settings));
+			settings.fixOnLoad();
 			return settings;
 		} catch (Exception e) {
 			LOG.error("Error load settings", e);

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -66,9 +66,9 @@ public final class JadxDecompiler {
 
 	private BinaryXMLParser xmlParser;
 
-	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();
-	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();
-	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();
+	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();
+	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();
+	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();
 
 	public JadxDecompiler() {
 		this(new JadxArgs());

File: jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java
Patch:
@@ -23,7 +23,7 @@
 public class ClspGraph {
 	private static final Logger LOG = LoggerFactory.getLogger(ClspGraph.class);
 
-	private final Map<String, Set<String>> ancestorCache = new WeakHashMap<String, Set<String>>();
+	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());
 	private Map<String, NClass> nameMap;
 
 	private final Set<String> missingClasses = new HashSet<String>();

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -164,6 +164,7 @@ private String makeNameForObject(ArgType type) {
 			if (vName != null) {
 				return vName;
 			}
+			return StringUtils.escape(shortName.toLowerCase());
 		}
 		return StringUtils.escape(type.toString());
 	}

File: jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java
Patch:
@@ -22,7 +22,7 @@ private FieldInfo(ClassInfo declClass, String name, ArgType type) {
 
 	public static FieldInfo from(DexNode dex, ClassInfo declClass, String name, ArgType type) {
 		FieldInfo field = new FieldInfo(declClass, name, type);
-		return dex.getInfoStorage().getField(field);
+		return dex.root().getInfoStorage().getField(field);
 	}
 
 	public static FieldInfo fromDex(DexNode dex, int index) {

File: jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java
Patch:
@@ -34,12 +34,12 @@ private MethodInfo(DexNode dex, int mthIndex) {
 	}
 
 	public static MethodInfo fromDex(DexNode dex, int mthIndex) {
-		MethodInfo mth = dex.getInfoStorage().getMethod(mthIndex);
+		MethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);
 		if (mth != null) {
 			return mth;
 		}
 		mth = new MethodInfo(dex, mthIndex);
-		return dex.getInfoStorage().putMethod(mthIndex, mth);
+		return dex.root().getInfoStorage().putMethod(dex, mthIndex, mth);
 	}
 
 	public String makeSignature(boolean includeRetType) {

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -6,6 +6,7 @@
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 import jadx.core.utils.files.FileUtils;
+import jadx.core.utils.files.ZipSecurity;
 
 import java.io.BufferedOutputStream;
 import java.io.DataInputStream;
@@ -173,7 +174,7 @@ public void load(File input) throws IOException, DecodeException {
 				try {
 					ZipEntry entry = in.getNextEntry();
 					while (entry != null) {
-						if (entry.getName().endsWith(CLST_EXTENSION)) {
+						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {
 							load(in);
 						}
 						entry = in.getNextEntry();

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -3,7 +3,6 @@
 import jadx.core.utils.exceptions.JadxException;
 
 import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -72,7 +71,7 @@ private Document loadXML(String xml) throws JadxException, ParserConfigurationEx
 			if (xmlStream == null) {
 				throw new JadxException(xml + " not found in classpath");
 			}
-			DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+			DocumentBuilder dBuilder = XmlSecurity.getSecureDbf().newDocumentBuilder();
 			doc = dBuilder.parse(xmlStream);
 		} finally {
 			close(xmlStream);

File: jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java
Patch:
@@ -23,7 +23,7 @@
 public class ClspGraph {
 	private static final Logger LOG = LoggerFactory.getLogger(ClspGraph.class);
 
-	private final Map<String, Set<String>> ancestorCache = new WeakHashMap<String, Set<String>>();
+	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());
 	private Map<String, NClass> nameMap;
 
 	private final Set<String> missingClasses = new HashSet<String>();

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -66,9 +66,9 @@ public final class JadxDecompiler {
 
 	private BinaryXMLParser xmlParser;
 
-	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();
-	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();
-	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();
+	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();
+	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();
+	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();
 
 	public JadxDecompiler() {
 		this(new JadxArgs());

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -35,12 +35,12 @@ public static ClassInfo fromType(DexNode dex, ArgType type) {
 		if (type.isArray()) {
 			type = ArgType.OBJECT;
 		}
-		ClassInfo cls = dex.getInfoStorage().getCls(type);
+		ClassInfo cls = dex.root().getInfoStorage().getCls(type);
 		if (cls != null) {
 			return cls;
 		}
 		cls = new ClassInfo(dex, type);
-		return dex.getInfoStorage().putCls(cls);
+		return dex.root().getInfoStorage().putCls(cls);
 	}
 
 	public static ClassInfo fromDex(DexNode dex, int clsIndex) {

File: jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java
Patch:
@@ -22,7 +22,7 @@ private FieldInfo(ClassInfo declClass, String name, ArgType type) {
 
 	public static FieldInfo from(DexNode dex, ClassInfo declClass, String name, ArgType type) {
 		FieldInfo field = new FieldInfo(declClass, name, type);
-		return dex.getInfoStorage().getField(field);
+		return dex.root().getInfoStorage().getField(field);
 	}
 
 	public static FieldInfo fromDex(DexNode dex, int index) {

File: jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java
Patch:
@@ -34,12 +34,12 @@ private MethodInfo(DexNode dex, int mthIndex) {
 	}
 
 	public static MethodInfo fromDex(DexNode dex, int mthIndex) {
-		MethodInfo mth = dex.getInfoStorage().getMethod(mthIndex);
+		MethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);
 		if (mth != null) {
 			return mth;
 		}
 		mth = new MethodInfo(dex, mthIndex);
-		return dex.getInfoStorage().putMethod(mthIndex, mth);
+		return dex.root().getInfoStorage().putMethod(dex, mthIndex, mth);
 	}
 
 	public String makeSignature(boolean includeRetType) {

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -164,6 +164,7 @@ private String makeNameForObject(ArgType type) {
 			if (vName != null) {
 				return vName;
 			}
+			return StringUtils.escape(shortName.toLowerCase());
 		}
 		return StringUtils.escape(type.toString());
 	}

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore.java
Patch:
@@ -9,6 +9,8 @@
 import org.junit.Test;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.assertThat;
 
 public class TestRFieldRestore extends IntegrationTest {
@@ -31,5 +33,6 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 		assertThat(code, containsOne("return R.id.Button;"));
+		assertThat(code, not(containsString("import R;")));
 	}
 }

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -121,7 +121,8 @@ private static Dex loadFromJar(File jarFile) throws DecodeException {
 			byte[] ba = j2d.convert(jarFile.getAbsolutePath());
 			if (ba.length == 0) {
 				throw new JadxException(j2d.isError() ? j2d.getDxErrors() : "Empty dx output");
-			} else if (j2d.isError()) {
+			}
+			if (j2d.isError()) {
 				LOG.warn("dx message: {}", j2d.getDxErrors());
 			}
 			return new Dex(ba);

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java
Patch:
@@ -60,9 +60,7 @@ protected Void doInBackground() throws Exception {
 			LOG.debug("Memory usage: After gc: {}", Utils.memoryInfo());
 
 			TextSearchIndex searchIndex = cache.getTextIndex();
-			if (cache.getIndexJob().isUseFastSearch()
-					&& searchIndex != null
-					&& searchIndex.getSkippedCount() > 0) {
+			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {
 				LOG.warn("Indexing of some classes skipped, count: {}, low memory: {}",
 						searchIndex.getSkippedCount(), Utils.memoryInfo());
 			}

File: jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java
Patch:
@@ -200,7 +200,7 @@ protected void resetCache() {
 		// TODO: decompilation freezes sometime with several threads
 		int threadsCount = 1; // settings.getThreadsCount();
 		cacheObject.setDecompileJob(new DecompileJob(wrapper, threadsCount));
-		cacheObject.setIndexJob(new IndexJob(wrapper, cacheObject, threadsCount, settings.isUseFastSearch()));
+		cacheObject.setIndexJob(new IndexJob(wrapper, cacheObject, threadsCount));
 	}
 
 	private synchronized void runBackgroundJobs() {

File: jadx-core/src/main/java/jadx/api/ResourceType.java
Patch:
@@ -1,10 +1,10 @@
 package jadx.api;
 
 public enum ResourceType {
-	CODE(".dex", ".class"),
+	CODE(".dex", ".jar", ".class"),
 	MANIFEST("AndroidManifest.xml"),
-	XML(".xml"), // TODO binary or not?
-	ARSC(".arsc"), // TODO decompile !!!
+	XML(".xml"),
+	ARSC(".arsc"),
 	FONT(".ttf"),
 	IMG(".png", ".gif", ".jpg"),
 	LIB(".so"),

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -81,11 +81,13 @@ private synchronized void performSearch() {
 		resultsModel.clear();
 		String text = searchField.getText();
 		if (text == null || text.isEmpty() || options.isEmpty()) {
+			resultsTable.updateTable();
 			return;
 		}
 		cache.setLastSearch(text);
 		TextSearchIndex index = cache.getTextIndex();
 		if (index == null) {
+			resultsTable.updateTable();
 			return;
 		}
 		if (options.contains(SearchOptions.CLASS)) {

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -167,7 +167,7 @@ public void addInstructions(CodeWriter code) throws CodegenException {
 				if (cause != null) {
 					code.newLine();
 					code.add("/*");
-					code.startLine("Error: ").add(Utils.getStackTrace(cause));
+					code.newLine().add("Error: ").add(Utils.getStackTrace(cause));
 					code.add("*/");
 				}
 			}

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java
Patch:
@@ -65,6 +65,9 @@ public enum InsnType {
 	ONE_ARG,
 	PHI,
 
+	// merge all arguments in one
+	MERGE,
+
 	// TODO: now multidimensional arrays created using Array.newInstance function
 	NEW_MULTIDIM_ARRAY
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java
Patch:
@@ -103,7 +103,9 @@ private static boolean replaceConst(MethodNode mth, InsnNode constInsn, long lit
 		int replaceCount = 0;
 		for (RegisterArg arg : use) {
 			InsnNode useInsn = arg.getParentInsn();
-			if (useInsn == null || useInsn.getType() == InsnType.PHI) {
+			if (useInsn == null
+					|| useInsn.getType() == InsnType.PHI
+					|| useInsn.getType() == InsnType.MERGE) {
 				continue;
 			}
 			LiteralArg litArg;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java
Patch:
@@ -24,7 +24,7 @@
 import org.slf4j.LoggerFactory;
 
 import static jadx.core.dex.visitors.regions.RegionMaker.isEqualPaths;
-import static jadx.core.dex.visitors.regions.RegionMaker.isReturnBlocks;
+import static jadx.core.dex.visitors.regions.RegionMaker.isEqualReturnBlocks;
 import static jadx.core.utils.BlockUtils.getNextBlock;
 import static jadx.core.utils.BlockUtils.isPathExists;
 
@@ -277,7 +277,7 @@ private static BlockNode getCrossBlock(BlockNode first, BlockNode second) {
 	}
 
 	private static boolean isSameBlocks(BlockNode first, BlockNode second) {
-		return first == second || isReturnBlocks(first, second);
+		return first == second || isEqualReturnBlocks(first, second);
 	}
 
 	static void confirmMerge(IfInfo info) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -256,17 +256,17 @@ && canDeclareInRegion(u, assignRegion, regionsOrder)) {
 				continue;
 			}
 			IRegion parent = region;
-			boolean declare = false;
+			boolean declared = false;
 			while (parent != null) {
 				if (canDeclareInRegion(u, region, regionsOrder)) {
 					declareVar(region, u.getArg());
-					declare = true;
+					declared = true;
 					break;
 				}
 				region = parent;
 				parent = region.getParent();
 			}
-			if (!declare) {
+			if (!declared) {
 				declareVar(mth.getRegion(), u.getArg());
 			}
 		}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -247,7 +247,7 @@ void compile(ClassNode cls) {
 	}
 
 	public Object invoke(String method) throws Exception {
-		return invoke(method, new Class[0]);
+		return invoke(method, new Class<?>[0]);
 	}
 
 	public Object invoke(String method, Class[] types, Object... args) throws Exception {

File: jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java
Patch:
@@ -35,7 +35,7 @@ public ClassLoader getClassLoader(Location location) {
 
 	private class DynamicClassLoader extends SecureClassLoader {
 		private final Map<String, JavaClassObject> clsMap = new HashMap<String, JavaClassObject>();
-		private final Map<String, Class> clsCache = new HashMap<String, Class>();
+		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();
 
 		@Override
 		protected Class<?> findClass(String name) throws ClassNotFoundException {
@@ -55,7 +55,7 @@ public Class<?> loadClass(String name) throws ClassNotFoundException {
 		}
 
 		public Class<?> replaceClass(String name) throws ClassNotFoundException {
-			Class cacheCls = clsCache.get(name);
+			Class<?> cacheCls = clsCache.get(name);
 			if (cacheCls != null) {
 				return cacheCls;
 			}

File: jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java
Patch:
@@ -58,7 +58,7 @@ private Object getInstance() throws Exception {
 	}
 
 	public Method getMethod(String method, Class[] types) throws Exception {
-		for (Class type : types) {
+		for (Class<?> type : types) {
 			checkType(type);
 		}
 		return getInstance().getClass().getMethod(method, types);
@@ -68,7 +68,7 @@ public Object invoke(Method mth, Object... args) throws Exception {
 		return mth.invoke(getInstance(), args);
 	}
 
-	private Class<?> checkType(Class type) throws ClassNotFoundException {
+	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {
 		if (type.isPrimitive()) {
 			return type;
 		}

File: jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java
Patch:
@@ -34,7 +34,7 @@ public void testOrder() {
 	}
 
 	private static List<String> check(List<IDexTreeVisitor> passes) {
-		List<Class> classList = new ArrayList<Class>(passes.size());
+		List<Class<?>> classList = new ArrayList<Class<?>>(passes.size());
 		for (IDexTreeVisitor pass : passes) {
 			classList.add(pass.getClass());
 		}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -71,7 +71,7 @@ private JResource getResourceByName(JResource rf, String name) {
 	}
 
 	public JNode searchClassInTree(JNode node) {
-		Enumeration en = this.breadthFirstEnumeration();
+		Enumeration<?> en = this.breadthFirstEnumeration();
 		while (en.hasMoreElements()) {
 			Object obj = en.nextElement();
 			if (node.equals(obj)) {

File: jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java
Patch:
@@ -41,6 +41,7 @@ public final void initUI() {
 
 		JPanel controlPane = new JPanel();
 		controlPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
+		@SuppressWarnings("unchecked")
 		final JComboBox cb = new JComboBox(LEVEL_ITEMS);
 		cb.setSelectedItem(level);
 		cb.addActionListener(new ActionListener() {

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -247,7 +247,7 @@ void compile(ClassNode cls) {
 	}
 
 	public Object invoke(String method) throws Exception {
-		return invoke(method, new Class[0]);
+		return invoke(method, new Class<?>[0]);
 	}
 
 	public Object invoke(String method, Class[] types, Object... args) throws Exception {

File: jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java
Patch:
@@ -35,7 +35,7 @@ public ClassLoader getClassLoader(Location location) {
 
 	private class DynamicClassLoader extends SecureClassLoader {
 		private final Map<String, JavaClassObject> clsMap = new HashMap<String, JavaClassObject>();
-		private final Map<String, Class> clsCache = new HashMap<String, Class>();
+		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();
 
 		@Override
 		protected Class<?> findClass(String name) throws ClassNotFoundException {
@@ -55,7 +55,7 @@ public Class<?> loadClass(String name) throws ClassNotFoundException {
 		}
 
 		public Class<?> replaceClass(String name) throws ClassNotFoundException {
-			Class cacheCls = clsCache.get(name);
+			Class<?> cacheCls = clsCache.get(name);
 			if (cacheCls != null) {
 				return cacheCls;
 			}

File: jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java
Patch:
@@ -58,7 +58,7 @@ private Object getInstance() throws Exception {
 	}
 
 	public Method getMethod(String method, Class[] types) throws Exception {
-		for (Class type : types) {
+		for (Class<?> type : types) {
 			checkType(type);
 		}
 		return getInstance().getClass().getMethod(method, types);
@@ -68,7 +68,7 @@ public Object invoke(Method mth, Object... args) throws Exception {
 		return mth.invoke(getInstance(), args);
 	}
 
-	private Class<?> checkType(Class type) throws ClassNotFoundException {
+	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {
 		if (type.isPrimitive()) {
 			return type;
 		}

File: jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java
Patch:
@@ -34,7 +34,7 @@ public void testOrder() {
 	}
 
 	private static List<String> check(List<IDexTreeVisitor> passes) {
-		List<Class> classList = new ArrayList<Class>(passes.size());
+		List<Class<?>> classList = new ArrayList<Class<?>>(passes.size());
 		for (IDexTreeVisitor pass : passes) {
 			classList.add(pass.getClass());
 		}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -71,7 +71,7 @@ private JResource getResourceByName(JResource rf, String name) {
 	}
 
 	public JNode searchClassInTree(JNode node) {
-		Enumeration en = this.breadthFirstEnumeration();
+		Enumeration<?> en = this.breadthFirstEnumeration();
 		while (en.hasMoreElements()) {
 			Object obj = en.nextElement();
 			if (node.equals(obj)) {

File: jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java
Patch:
@@ -41,6 +41,7 @@ public final void initUI() {
 
 		JPanel controlPane = new JPanel();
 		controlPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
+		@SuppressWarnings("unchecked")
 		final JComboBox cb = new JComboBox(LEVEL_ITEMS);
 		cb.setSelectedItem(level);
 		cb.addActionListener(new ActionListener() {

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -29,7 +29,7 @@ public class JadxCLIArgs implements IJadxArgs {
 	protected String outDirName;
 
 	@Parameter(names = {"-j", "--threads-count"}, description = "processing threads count")
-	protected int threadsCount = Runtime.getRuntime().availableProcessors();
+	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);
 
 	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)")
 	protected boolean fallbackMode = false;

File: jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java
Patch:
@@ -2,7 +2,7 @@
 
 import jadx.gui.ui.ProgressPanel;
 import jadx.gui.utils.CacheObject;
-import jadx.gui.utils.TextSearchIndex;
+import jadx.gui.utils.search.TextSearchIndex;
 import jadx.gui.utils.Utils;
 
 import javax.swing.SwingUtilities;

File: jadx-gui/src/main/java/jadx/gui/ui/ContentArea.java
Patch:
@@ -214,7 +214,8 @@ public void actionPerformed(ActionEvent e) {
 				return;
 			}
 			MainWindow mainWindow = contentPanel.getTabbedPane().getMainWindow();
-			UsageDialog usageDialog = new UsageDialog(mainWindow, JNode.makeFrom(node));
+			JNode jNode = mainWindow.getCacheObject().getNodeCache().makeFrom(node);
+			UsageDialog usageDialog = new UsageDialog(mainWindow, jNode);
 			usageDialog.setVisible(true);
 		}
 

File: jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java
Patch:
@@ -1,7 +1,7 @@
 package jadx.gui.ui;
 
 import jadx.gui.utils.NLS;
-import jadx.gui.utils.TextSearchIndex;
+import jadx.gui.utils.search.TextSearchIndex;
 import jadx.gui.utils.TextStandardActions;
 
 import javax.swing.BorderFactory;

File: jadx-gui/src/main/java/jadx/gui/utils/Utils.java
Patch:
@@ -99,10 +99,11 @@ public static String memoryInfo() {
 		long allocatedMemory = runtime.totalMemory();
 		long freeMemory = runtime.freeMemory();
 
-		sb.append("free: ").append(format(freeMemory));
+		sb.append("heap: ").append(format(allocatedMemory - freeMemory));
 		sb.append(", allocated: ").append(format(allocatedMemory));
-		sb.append(", max: ").append(format(maxMemory));
+		sb.append(", free: ").append(format(freeMemory));
 		sb.append(", total free: ").append(format(freeMemory + maxMemory - allocatedMemory));
+		sb.append(", max: ").append(format(maxMemory));
 
 		return sb.toString();
 	}

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -148,6 +148,7 @@ public void addClassDeclaration(CodeWriter clsCode) {
 		} else {
 			clsCode.add("class ");
 		}
+		clsCode.attachDefinition(cls);
 		clsCode.add(cls.getShortName());
 
 		addGenericMap(clsCode, cls.getGenericMap());
@@ -179,7 +180,6 @@ public void addClassDeclaration(CodeWriter clsCode) {
 				clsCode.add(' ');
 			}
 		}
-		clsCode.attachDefinition(cls);
 	}
 
 	public boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {
@@ -340,6 +340,7 @@ private void addFields(CodeWriter code) throws CodegenException {
 			code.startLine(f.getAccessFlags().makeString());
 			useType(code, f.getType());
 			code.add(' ');
+			code.attachDefinition(f);
 			code.add(f.getAlias());
 			FieldInitAttr fv = f.get(AType.FIELD_INIT);
 			if (fv != null) {
@@ -356,7 +357,6 @@ private void addFields(CodeWriter code) throws CodegenException {
 				}
 			}
 			code.add(';');
-			code.attachDefinition(f);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -79,9 +79,9 @@ private boolean isFallback() {
 	}
 
 	public void addArgDot(CodeWriter code, InsnArg arg) throws CodegenException {
-		int len = code.length();
+		int len = code.bufLength();
 		addArg(code, arg, true);
-		if (len != code.length()) {
+		if (len != code.bufLength()) {
 			code.add('.');
 		}
 	}

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -57,8 +57,8 @@ public MethodNode getMethodNode() {
 
 	public boolean addDefinition(CodeWriter code) {
 		if (mth.getMethodInfo().isClassInit()) {
-			code.startLine("static");
 			code.attachDefinition(mth);
+			code.startLine("static");
 			return true;
 		}
 		if (mth.contains(AFlag.ANONYMOUS_CONSTRUCTOR)) {
@@ -87,10 +87,12 @@ public boolean addDefinition(CodeWriter code) {
 			code.add(' ');
 		}
 		if (mth.getAccessFlags().isConstructor()) {
+			code.attachDefinition(mth);
 			code.add(classGen.getClassNode().getShortName()); // constructor
 		} else {
 			classGen.useType(code, mth.getReturnType());
 			code.add(' ');
+			code.attachDefinition(mth);
 			code.add(mth.getAlias());
 		}
 		code.add('(');
@@ -113,7 +115,6 @@ public boolean addDefinition(CodeWriter code) {
 		code.add(')');
 
 		annotationGen.addThrows(mth, code);
-		code.attachDefinition(mth);
 		return true;
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -57,8 +57,8 @@ public static String classError(ClassNode cls, String errorMsg, Throwable e) {
 		return msg;
 	}
 
-	public static String classError(ClassNode mth, String errorMsg) {
-		return classError(mth, errorMsg, null);
+	public static String classError(ClassNode cls, String errorMsg) {
+		return classError(cls, errorMsg, null);
 	}
 
 	public static String methodError(MethodNode mth, String errorMsg, Throwable e) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.Set;
 
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -442,6 +443,7 @@ public void registerLoop(LoopInfo loop) {
 		loops.add(loop);
 	}
 
+	@Nullable
 	public LoopInfo getLoopForBlock(BlockNode block) {
 		if (loops.isEmpty()) {
 			return null;

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -3,6 +3,7 @@
 import jadx.core.dex.attributes.annotations.AnnotationsList;
 import jadx.core.dex.attributes.annotations.MethodParameters;
 import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;
+import jadx.core.dex.attributes.nodes.EdgeInsnAttr;
 import jadx.core.dex.attributes.nodes.EnumClassAttr;
 import jadx.core.dex.attributes.nodes.EnumMapAttr;
 import jadx.core.dex.attributes.nodes.FieldReplaceAttr;
@@ -30,6 +31,7 @@ public class AType<T extends IAttribute> {
 
 	public static final AType<AttrList<JumpInfo>> JUMP = new AType<AttrList<JumpInfo>>();
 	public static final AType<AttrList<LoopInfo>> LOOP = new AType<AttrList<LoopInfo>>();
+	public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<AttrList<EdgeInsnAttr>>();
 
 	public static final AType<ExcHandlerAttr> EXC_HANDLER = new AType<ExcHandlerAttr>();
 	public static final AType<CatchAttr> CATCH_BLOCK = new AType<CatchAttr>();

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -64,7 +64,7 @@ public static void printRegion(MethodNode mth, IRegion region, boolean printInsn
 	}
 
 	public static void printRegions(MethodNode mth, boolean printInsns) {
-		LOG.debug("|{}", mth.toString());
+		LOG.debug("|{}", mth);
 		printRegion(mth, mth.getRegion(), "|  ", printInsns);
 	}
 
@@ -75,7 +75,7 @@ private static void printRegion(MethodNode mth, IRegion region, String indent, b
 			if (container instanceof IRegion) {
 				printRegion(mth, (IRegion) container, indent, printInsns);
 			} else {
-				LOG.debug("{}{}", indent, container);
+				LOG.debug("{}{} {}", indent, container, container.getAttributesString());
 				if (printInsns && container instanceof IBlock) {
 					IBlock block = (IBlock) container;
 					printInsns(mth, indent, block);

File: jadx-core/src/main/java/jadx/api/IJadxArgs.java
Patch:
@@ -28,4 +28,6 @@ public interface IJadxArgs {
 	int getDeobfuscationMaxLength();
 
 	boolean isDeobfuscationForceSave();
+
+	boolean useSourceNameAsClassAlias();
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -86,10 +86,10 @@ public ClassNode(DexNode dex, ClassDef cls) throws DecodeException {
 				fields = new ArrayList<FieldNode>(fieldsCount);
 
 				for (Method mth : clsData.getDirectMethods()) {
-					methods.add(new MethodNode(this, mth));
+					methods.add(new MethodNode(this, mth, false));
 				}
 				for (Method mth : clsData.getVirtualMethods()) {
-					methods.add(new MethodNode(this, mth));
+					methods.add(new MethodNode(this, mth, true));
 				}
 
 				for (Field f : clsData.getStaticFields()) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -86,10 +86,10 @@ public ClassNode(DexNode dex, ClassDef cls) throws DecodeException {
 				fields = new ArrayList<FieldNode>(fieldsCount);
 
 				for (Method mth : clsData.getDirectMethods()) {
-					methods.add(new MethodNode(this, mth));
+					methods.add(new MethodNode(this, mth, false));
 				}
 				for (Method mth : clsData.getVirtualMethods()) {
-					methods.add(new MethodNode(this, mth));
+					methods.add(new MethodNode(this, mth, true));
 				}
 
 				for (Field f : clsData.getStaticFields()) {

File: jadx-core/src/main/java/jadx/api/IJadxArgs.java
Patch:
@@ -28,4 +28,6 @@ public interface IJadxArgs {
 	int getDeobfuscationMaxLength();
 
 	boolean isDeobfuscationForceSave();
+
+	boolean useSourceNameAsClassAlias();
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -640,6 +640,7 @@ void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,
 		}
 		int argsCount = insn.getArgsCount();
 		code.add('(');
+		boolean firstArg = true;
 		if (k < argsCount) {
 			boolean overloaded = callMth != null && callMth.isArgsOverload();
 			for (int i = k; i < argsCount; i++) {
@@ -651,14 +652,15 @@ void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,
 				if (callArg != null && callArg.contains(AFlag.SKIP_ARG)) {
 					continue;
 				}
-				if (i != k) {
+				if (!firstArg) {
 					code.add(", ");
 				}
 				boolean cast = overloaded && processOverloadedArg(code, callMth, arg, i - startArgNum);
 				if (!cast && i == argsCount - 1 && processVarArg(code, callMth, arg)) {
 					continue;
 				}
 				addArg(code, arg, false);
+				firstArg = false;
 			}
 		}
 		code.add(')');

File: jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java
Patch:
@@ -6,6 +6,7 @@
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.utils.BlockUtils;
 import jadx.core.utils.Utils;
 
 import java.util.ArrayList;
@@ -63,6 +64,8 @@ public void removeHandler(MethodNode mth, ExceptionHandler handler) {
 
 	private void unbindHandler(ExceptionHandler handler) {
 		for (BlockNode block : handler.getBlocks()) {
+			// skip synthetic loop exit blocks
+			BlockUtils.skipPredSyntheticPaths(block);
 			block.add(AFlag.SKIP);
 			ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);
 			if (excHandlerAttr != null) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -79,6 +79,7 @@ public void mergeDebugInfo(ArgType type, String name) {
 	public RegisterArg duplicate() {
 		RegisterArg dup = new RegisterArg(getRegNum(), getType());
 		dup.setSVar(sVar);
+		dup.copyAttributesFrom(this);
 		return dup;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/Typed.java
Patch:
@@ -1,8 +1,9 @@
 package jadx.core.dex.instructions.args;
 
+import jadx.core.dex.attributes.AttrNode;
 import jadx.core.dex.nodes.DexNode;
 
-public abstract class Typed {
+public abstract class Typed extends AttrNode {
 
 	protected ArgType type;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -277,8 +277,8 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn
 				if (sVar != null) {
 					sVar.add(AFlag.FINAL);
 					sVar.add(AFlag.DONT_INLINE);
-					sVar.add(AFlag.SKIP_ARG);
 				}
+				reg.add(AFlag.SKIP_ARG);
 			}
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java
Patch:
@@ -46,7 +46,7 @@ public static JadxSettings load() {
 			if (settings == null) {
 				return new JadxSettings();
 			}
-			LOG.info("Loaded settings: {}", makeString(settings));
+			LOG.debug("Loaded settings: {}", makeString(settings));
 			return settings;
 		} catch (Exception e) {
 			LOG.error("Error load settings", e);

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass2.java
Patch:
@@ -3,7 +3,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.containsString;
@@ -48,7 +47,6 @@ public void run() {
 	}
 
 	@Test
-	@Ignore
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass4.java
Patch:
@@ -3,7 +3,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.tests.api.IntegrationTest;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import static jadx.tests.api.utils.JadxMatchers.containsOne;
@@ -33,7 +32,6 @@ public void run() {
 	}
 
 	@Test
-	@Ignore
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -114,7 +114,6 @@ void save(File output) throws IOException {
 				try {
 					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + "/" + CLST_FILENAME));
 					save(out);
-					out.closeEntry();
 				} finally {
 					out.close();
 				}

File: jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java
Patch:
@@ -4,6 +4,7 @@
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.LiteralArg;
 import jadx.core.dex.instructions.args.PrimitiveType;
+import jadx.core.dex.nodes.DexNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
@@ -57,8 +58,8 @@ public ArgType getElementType() {
 		return elemType;
 	}
 
-	public void mergeElementType(ArgType foundElemType) {
-		ArgType r = ArgType.merge(elemType, foundElemType);
+	public void mergeElementType(DexNode dex, ArgType foundElemType) {
+		ArgType r = ArgType.merge(dex, elemType, foundElemType);
 		if (r != null) {
 			elemType = r;
 		}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java
Patch:
@@ -17,7 +17,7 @@ public LiteralArg(long value, ArgType type) {
 			} else if (!type.isTypeKnown()
 					&& !type.contains(PrimitiveType.LONG)
 					&& !type.contains(PrimitiveType.DOUBLE)) {
-				ArgType m = ArgType.merge(type, ArgType.NARROW_NUMBERS);
+				ArgType m = ArgType.merge(null, type, ArgType.NARROW_NUMBERS);
 				if (m != null) {
 					type = m;
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -108,9 +108,9 @@ private static void replaceStep(MethodNode mth, InstructionRemover remover) {
 						if (next < size) {
 							InsnNode ni = block.getInstructions().get(next);
 							if (ni.getType() == InsnType.FILL_ARRAY) {
-								ni.getResult().merge(insn.getResult());
+								ni.getResult().merge(mth.dex(), insn.getResult());
 								ArgType arrType = ((NewArrayNode) insn).getArrayType();
-								((FillArrayNode) ni).mergeElementType(arrType.getArrayElement());
+								((FillArrayNode) ni).mergeElementType(mth.dex(), arrType.getArrayElement());
 								remover.add(insn);
 							}
 						}
@@ -263,7 +263,7 @@ private static InsnNode makeFilledArrayInsn(MethodNode mth, FillArrayNode insn)
 				throw new JadxRuntimeException("Null array element type");
 			}
 		}
-		insn.mergeElementType(elType);
+		insn.mergeElementType(mth.dex(), elType);
 		elType = insn.getElementType();
 
 		List<LiteralArg> list = insn.getLiteralArgs();

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -88,7 +88,7 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {
 					}
 				}
 				ArgType castToType = (ArgType) ((IndexInsnNode) insn).getIndex();
-				if (!ArgType.isCastNeeded(argType, castToType)) {
+				if (!ArgType.isCastNeeded(mth.dex(), argType, castToType)) {
 					InsnNode insnNode = new InsnNode(InsnType.MOVE, 1);
 					insnNode.setOffset(insn.getOffset());
 					insnNode.setResult(insn.getResult());

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/FinishTypeInference.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.core.dex.visitors.typeinference;
 
 import jadx.core.dex.nodes.BlockNode;
+import jadx.core.dex.nodes.DexNode;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.visitors.AbstractVisitor;
@@ -31,9 +32,10 @@ public void visit(MethodNode mth) {
 		} while (change);
 
 		// last chance to set correct value (just use first type from 'possible' list)
+		DexNode dex = mth.dex();
 		for (BlockNode block : mth.getBasicBlocks()) {
 			for (InsnNode insn : block.getInstructions()) {
-				SelectTypeVisitor.visit(insn);
+				SelectTypeVisitor.visit(dex, insn);
 			}
 		}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java
Patch:
@@ -5,12 +5,15 @@
 import jadx.core.utils.Utils;
 
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class AnnotationsList implements IAttribute {
 
+	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());
+
 	private final Map<String, Annotation> map;
 
 	public AnnotationsList(List<Annotation> anList) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java
Patch:
@@ -5,6 +5,7 @@
 import jadx.core.dex.attributes.AttrNode;
 import jadx.core.dex.attributes.nodes.IgnoreEdgeAttr;
 import jadx.core.dex.attributes.nodes.LoopInfo;
+import jadx.core.utils.EmptyBitSet;
 import jadx.core.utils.InsnUtils;
 
 import java.util.ArrayList;
@@ -24,7 +25,7 @@ public class BlockNode extends AttrNode implements IBlock {
 	private List<BlockNode> cleanSuccessors;
 
 	// all dominators
-	private BitSet doms;
+	private BitSet doms = EmptyBitSet.EMPTY;
 	// dominance frontier
 	private BitSet domFrontier;
 	// immediate dominator

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java
Patch:
@@ -88,8 +88,10 @@ public static boolean process(MethodNode mth, InsnNode insn) {
 			case CHECK_CAST: {
 				ArgType castType = (ArgType) ((IndexInsnNode) insn).getIndex();
 				RegisterArg result = insn.getResult();
+				ArgType resultType = result.getType();
 				// don't override generic types of same base class
-				boolean skip = castType.isObject() && castType.getObject().equals(result.getType().getObject());
+				boolean skip = castType.isObject() && resultType.isObject()
+						&& castType.getObject().equals(resultType.getObject());
 				if (!skip) {
 					// workaround for compiler bug (see TestDuplicateCast)
 					result.getSVar().setType(castType);

File: jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java
Patch:
@@ -18,7 +18,7 @@ public class JadxSettings extends JadxCLIArgs {
 	private static final Font DEFAULT_FONT = new JLabel().getFont();
 
 	static final Set<String> SKIP_FIELDS = new HashSet<String>(Arrays.asList(
-			"files", "input", "outputDir", "printHelp"
+			"files", "input", "outputDir", "verbose", "printHelp"
 	));
 
 	private String lastOpenFilePath = USER_HOME;

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -152,7 +152,7 @@ private void loadAnnotations(ClassDef cls) {
 		if (offset != 0) {
 			try {
 				new AnnotationsParser(this).parse(offset);
-			} catch (DecodeException e) {
+			} catch (Exception e) {
 				LOG.error("Error parsing annotations in {}", this, e);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/codegen/CodeGen.java
Patch:
@@ -15,7 +15,7 @@ public CodeGen(IJadxArgs args) {
 
 	@Override
 	public boolean visit(ClassNode cls) throws CodegenException {
-		ClassGen clsGen = new ClassGen(cls, null, args);
+		ClassGen clsGen = new ClassGen(cls, args);
 		CodeWriter clsCode = clsGen.makeClass();
 		clsCode.finish();
 		cls.setCode(clsCode);

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -554,7 +554,7 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)
 				useClass(code, parent);
 			}
 			code.add("() ");
-			new ClassGen(cls, mgen.getClassGen().getParentGen(), fallback).addClassBody(code);
+			new ClassGen(cls, mgen.getClassGen().getParentGen()).addClassBody(code);
 			return;
 		}
 		if (insn.isSelf()) {

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -235,7 +235,7 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]
 	 * Return fallback variant of method codegen
 	 */
 	public static MethodGen getFallbackMethodGen(MethodNode mth) {
-		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true);
+		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true, true);
 		return new MethodGen(clsGen, mth);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.core.dex.visitors;
 
+import jadx.core.dex.attributes.AType;
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
@@ -39,7 +40,7 @@ private static void processClass(ClassNode cls, DexNode dex, Set<ClassNode> depL
 		}
 		// TODO: process annotations and generics
 		for (MethodNode methodNode : cls.getMethods()) {
-			if (methodNode.isNoCode()) {
+			if (methodNode.isNoCode() || methodNode.contains(AType.JADX_ERROR)) {
 				continue;
 			}
 			processMethod(dex, depList, methodNode);

File: jadx-core/src/main/java/jadx/core/utils/RegionUtils.java
Patch:
@@ -271,7 +271,7 @@ public static boolean isDominatedBy(BlockNode dom, IContainer cont) {
 		}
 	}
 
-	public static boolean hasPathThruBlock(BlockNode block, IContainer cont) {
+	public static boolean hasPathThroughBlock(BlockNode block, IContainer cont) {
 		if (block == cont) {
 			return true;
 		}
@@ -282,7 +282,7 @@ public static boolean hasPathThruBlock(BlockNode block, IContainer cont) {
 		} else if (cont instanceof IRegion) {
 			IRegion region = (IRegion) cont;
 			for (IContainer c : region.getSubBlocks()) {
-				if (!hasPathThruBlock(block, c)) {
+				if (!hasPathThroughBlock(block, c)) {
 					return false;
 				}
 			}

File: jadx-core/src/main/java/jadx/api/ResourceType.java
Patch:
@@ -10,7 +10,7 @@ public enum ResourceType {
 	LIB(".so"),
 	UNKNOWN;
 
-	private String[] exts;
+	private final String[] exts;
 
 	ResourceType(String... exts) {
 		this.exts = exts;

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -28,7 +28,7 @@ public final class ResourcesLoader {
 	private static final int READ_BUFFER_SIZE = 8 * 1024;
 	private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;
 
-	private JadxDecompiler jadxRef;
+	private final JadxDecompiler jadxRef;
 
 	ResourcesLoader(JadxDecompiler jadxRef) {
 		this.jadxRef = jadxRef;

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java
Patch:
@@ -10,7 +10,7 @@
 public class EnumMapAttr implements IAttribute {
 
 	public static class KeyValueMap {
-		private Map<Object, Object> map = new HashMap<Object, Object>();
+		private final Map<Object, Object> map = new HashMap<Object, Object>();
 
 		public Object get(Object key) {
 			return map.get(key);
@@ -21,7 +21,7 @@ void put(Object key, Object value) {
 		}
 	}
 
-	private Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();
+	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();
 
 	public KeyValueMap getMap(FieldNode field) {
 		return fieldsMap.get(field);

File: jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java
Patch:
@@ -32,9 +32,9 @@ public AccessInfo remove(int flag) {
 	}
 
 	public AccessInfo getVisibility() {
-		int f = (accFlags & AccessFlags.ACC_PUBLIC)
-				| (accFlags & AccessFlags.ACC_PROTECTED)
-				| (accFlags & AccessFlags.ACC_PRIVATE);
+		int f = accFlags & AccessFlags.ACC_PUBLIC
+				| accFlags & AccessFlags.ACC_PROTECTED
+				| accFlags & AccessFlags.ACC_PRIVATE;
 		return new AccessInfo(f, type);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java
Patch:
@@ -47,7 +47,7 @@ public boolean isInteger() {
 
 	@Override
 	public int hashCode() {
-		return (int) (literal ^ (literal >>> 32)) + 31 * getType().hashCode();
+		return (int) (literal ^ literal >>> 32) + 31 * getType().hashCode();
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java
Patch:
@@ -1,5 +1,7 @@
 package jadx.core.dex.instructions.args;
 
+import org.jetbrains.annotations.NotNull;
+
 public class TypeImmutableArg extends RegisterArg {
 
 	private boolean isThis;
@@ -36,7 +38,7 @@ public String getName() {
 	}
 
 	@Override
-	void setSVar(SSAVar sVar) {
+	void setSVar(@NotNull SSAVar sVar) {
 		if (isThis) {
 			sVar.setName("this");
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -282,7 +282,7 @@ public FieldNode getConstField(Object obj, boolean searchGlobal) {
 			field = cn.constFields.get(obj);
 		}
 		while (field == null
-				&& (cn.clsInfo.getParentClass() != null)
+				&& cn.clsInfo.getParentClass() != null
 				&& (cn = dex.resolveClass(cn.clsInfo.getParentClass())) != null);
 
 		if (field == null && searchGlobal) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -74,7 +74,8 @@ public InsnArg getArg(int n) {
 
 	public boolean containsArg(RegisterArg arg) {
 		for (InsnArg a : arguments) {
-			if (a == arg || (a.isRegister() && ((RegisterArg) a).getRegNum() == arg.getRegNum())) {
+			if (a == arg
+					|| a.isRegister() && ((RegisterArg) a).getRegNum() == arg.getRegNum()) {
 				return true;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -75,8 +75,8 @@ public MethodNode(ClassNode classNode, Method mthData) {
 		this.mthInfo = MethodInfo.fromDex(classNode.dex(), mthData.getMethodIndex());
 		this.parentClass = classNode;
 		this.accFlags = new AccessInfo(mthData.getAccessFlags(), AFType.METHOD);
-		this.noCode = (mthData.getCodeOffset() == 0);
-		this.methodData = (noCode ? null : mthData);
+		this.noCode = mthData.getCodeOffset() == 0;
+		this.methodData = noCode ? null : mthData;
 	}
 
 	@Override
@@ -527,7 +527,7 @@ public boolean isDefaultConstructor() {
 					defaultArgCount = 1;
 				}
 			}
-			result = (argsList == null) || (argsList.size() == defaultArgCount);
+			result = argsList == null || argsList.size() == defaultArgCount;
 		}
 		return result;
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java
Patch:
@@ -149,7 +149,7 @@ public void process() throws DecodeException {
 						int adjustedOpcode = c - DBG_FIRST_SPECIAL;
 						int addrInc = adjustedOpcode / DBG_LINE_RANGE;
 						addr = addrChange(addr, addrInc, line);
-						line += DBG_LINE_BASE + (adjustedOpcode % DBG_LINE_RANGE);
+						line += DBG_LINE_BASE + adjustedOpcode % DBG_LINE_RANGE;
 						setLine(addr, line);
 					} else {
 						throw new DecodeException("Unknown debug insn code: " + c);
@@ -263,8 +263,8 @@ private static void merge(InsnArg arg, LocalVar var) {
 			int localStart = var.getStartAddr();
 			int localEnd = var.getEndAddr();
 
-			boolean isIntersected = !((localEnd < ssaStart) || (ssaEnd < localStart));
-			if (isIntersected && (ssaEnd <= localEnd)) {
+			boolean isIntersected = !(localEnd < ssaStart || ssaEnd < localStart);
+			if (isIntersected && ssaEnd <= localEnd) {
 				mergeRequired = true;
 			}
 		} else {

File: jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java
Patch:
@@ -210,7 +210,7 @@ private static void shrinkBlock(MethodNode mth, BlockNode block) {
 //				}
 				SSAVar sVar = arg.getSVar();
 				// allow inline only one use arg or 'this'
-				if (sVar == null || (sVar.getVariableUseCount() != 1 && !arg.isThis())) {
+				if (sVar == null || sVar.getVariableUseCount() != 1 && !arg.isThis()) {
 					continue;
 				}
 				InsnNode assignInsn = sVar.getAssign().getParentInsn();

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -249,7 +249,7 @@ private static InsnNode convertFieldArith(MethodNode mth, InsnNode insn) {
 		}
 		InsnNode wrap = ((InsnWrapArg) arg).getWrapInsn();
 		InsnType wrapType = wrap.getType();
-		if ((wrapType != InsnType.ARITH && wrapType != InsnType.STR_CONCAT)
+		if (wrapType != InsnType.ARITH && wrapType != InsnType.STR_CONCAT
 				|| !wrap.getArg(0).isInsnWrap()) {
 			return null;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java
Patch:
@@ -194,7 +194,7 @@ private static boolean isSplitByJump(InsnNode prevInsn, InsnNode currentInsn) {
 	private static boolean isDoWhile(Map<Integer, BlockNode> blocksMap, BlockNode curBlock, InsnNode insn) {
 		// split 'do-while' block (last instruction: 'if', target this block)
 		if (insn.getType() == InsnType.IF) {
-			IfNode ifs = (IfNode) (insn);
+			IfNode ifs = (IfNode) insn;
 			BlockNode targetBlock = blocksMap.get(ifs.getTarget());
 			if (targetBlock == curBlock) {
 				return true;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -195,7 +195,7 @@ private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, Ins
 		CodeShrinker.shrinkMethod(mth);
 		if (arrGetInsn.contains(AFlag.WRAPPED)) {
 			InsnArg wrapArg = BlockUtils.searchWrappedInsnParent(mth, arrGetInsn);
-			if (wrapArg != null) {
+			if (wrapArg != null && wrapArg.getParentInsn() != null) {
 				wrapArg.getParentInsn().replaceArg(wrapArg, iterVar);
 			} else {
 				LOG.debug(" checkArrayForEach: Wrapped insn not found: {}, mth: {}", arrGetInsn, mth);
@@ -233,7 +233,7 @@ private static boolean checkIterableForEach(MethodNode mth, LoopRegion loopRegio
 		RegisterArg iterVar = nextCall.getResult();
 		if (nextCall.contains(AFlag.WRAPPED)) {
 			InsnArg wrapArg = BlockUtils.searchWrappedInsnParent(mth, nextCall);
-			if (wrapArg != null) {
+			if (wrapArg != null && wrapArg.getParentInsn() != null) {
 				InsnNode parentInsn = wrapArg.getParentInsn();
 				if (parentInsn.getType() != InsnType.CHECK_CAST) {
 					parentInsn.replaceArg(wrapArg, iterVar);

File: jadx-core/src/main/java/jadx/core/utils/DebugUtils.java
Patch:
@@ -103,7 +103,7 @@ public static void checkSSA(MethodNode mth) {
 				}
 				for (InsnArg arg : insn.getArguments()) {
 					if (arg instanceof RegisterArg) {
-						checkSSAVar(mth, insn, ((RegisterArg) arg));
+						checkSSAVar(mth, insn, (RegisterArg) arg);
 					}
 				}
 			}
@@ -131,7 +131,7 @@ private static void checkPHI(MethodNode mth) {
 			List<PhiInsn> phis = new ArrayList<PhiInsn>();
 			for (InsnNode insn : block.getInstructions()) {
 				if (insn.getType() == InsnType.PHI) {
-					PhiInsn phi = ((PhiInsn) insn);
+					PhiInsn phi = (PhiInsn) insn;
 					phis.add(phi);
 					if (phi.getArgsCount() != phi.getBlockBinds().size()) {
 						throw new JadxRuntimeException("Incorrect args and binds in PHI");

File: jadx-core/src/main/java/jadx/core/utils/RegionUtils.java
Patch:
@@ -189,7 +189,7 @@ private static boolean isRegionContainsExcHandlerRegion(IContainer container, IR
 			for (IContainer b : r.getSubBlocks()) {
 				// process try block
 				CatchAttr cb = b.get(AType.CATCH_BLOCK);
-				if (cb != null && (b instanceof IRegion)) {
+				if (cb != null && b instanceof IRegion) {
 					TryCatchBlock tb = cb.getTryBlock();
 					for (ExceptionHandler eh : tb.getHandlers()) {
 						if (isRegionContainsRegion(eh.getHandlerRegion(), region)) {

File: jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java
Patch:
@@ -209,7 +209,7 @@ private void parseElement() throws IOException {
 		for (int i = 0; i < attributeCount; i++) {
 			parseAttribute(i);
 			writer.add('"');
-			if ((i + 1) < attributeCount) {
+			if (i + 1 < attributeCount) {
 				writer.add(" ");
 			}
 		}
@@ -267,7 +267,7 @@ private void decodeAttribute(int attributeNS, int attrValDataType, int attrValDa
 			}
 		} else {
 			String str = valuesParser.decodeValue(attrValDataType, attrValData);
-			writer.add(str);
+			writer.add(str != null ? str : "null");
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java
Patch:
@@ -61,7 +61,7 @@ private static String extractString8(byte[] strArray, int offset) {
 			return "";
 		}
 		if ((len & 0x80) != 0) {
-			len = ((len & 0x7F) << 8) | (strArray[start++] & 0xFF);
+			len = (len & 0x7F) << 8 | strArray[start++] & 0xFF;
 		}
 		byte[] arr = Arrays.copyOfRange(strArray, start, start + len);
 		return new String(arr, ParserStream.STRING_CHARSET_UTF8);

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java
Patch:
@@ -150,11 +150,11 @@ public class ParserConstants {
 	protected static final int ATTR_MANY = ResMakeInternal(9);
 
 	private static int ResMakeInternal(int entry) {
-		return 0x01000000 | (entry & 0xFFFF);
+		return 0x01000000 | entry & 0xFFFF;
 	}
 
 	protected static boolean isResInternalId(int resid) {
-		return ((resid & 0xFFFF0000) != 0 && (resid & 0xFF0000) == 0);
+		return (resid & 0xFFFF0000) != 0 && (resid & 0xFF0000) == 0;
 	}
 
 	// Bit mask of allowed types, for use with ATTR_TYPE.

File: jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java
Patch:
@@ -34,7 +34,7 @@ public int readInt16() throws IOException {
 		readPos += 2;
 		int b1 = input.read();
 		int b2 = input.read();
-		return (b2 & 0xFF) << 8 | (b1 & 0xFF);
+		return (b2 & 0xFF) << 8 | b1 & 0xFF;
 	}
 
 	public int readInt32() throws IOException {
@@ -44,7 +44,7 @@ public int readInt32() throws IOException {
 		int b2 = in.read();
 		int b3 = in.read();
 		int b4 = in.read();
-		return b4 << 24 | (b3 & 0xFF) << 16 | (b2 & 0xFF) << 8 | (b1 & 0xFF);
+		return b4 << 24 | (b3 & 0xFF) << 16 | (b2 & 0xFF) << 8 | b1 & 0xFF;
 	}
 
 	public long readUInt32() throws IOException {

File: jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java
Patch:
@@ -113,8 +113,8 @@ private String decodeNameRef(int nameRef) {
 	}
 
 	private String decodeComplex(int data, boolean isFraction) {
-		double value = (data & (COMPLEX_MANTISSA_MASK << COMPLEX_MANTISSA_SHIFT))
-				* RADIX_MULTS[(data >> COMPLEX_RADIX_SHIFT) & COMPLEX_RADIX_MASK];
+		double value = (data & COMPLEX_MANTISSA_MASK << COMPLEX_MANTISSA_SHIFT)
+				* RADIX_MULTS[data >> COMPLEX_RADIX_SHIFT & COMPLEX_RADIX_MASK];
 		int unitType = data & COMPLEX_UNIT_MASK;
 		String unit;
 		if (isFraction) {

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -57,7 +57,7 @@ public final class JadxCLIArgs implements IJadxArgs {
 	protected int deobfuscationMinLength = 2;
 
 	@Parameter(names = {"--deobf-max"}, description = "max length of name")
-	protected int deobfuscationMaxLength = 40;
+	protected int deobfuscationMaxLength = 64;
 
 	@Parameter(names = {"--deobf-rewrite-cfg"}, description = "force to save deobfuscation map")
 	protected boolean deobfuscationForceSave = false;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -53,7 +53,8 @@ private static void removeSyntheticFields(ClassNode cls) {
 				ClassNode fieldsCls = cls.dex().resolveClass(ClassInfo.fromType(field.getType()));
 				ClassInfo parentClass = cls.getClassInfo().getParentClass();
 				if (fieldsCls != null
-						&& parentClass.equals(fieldsCls.getClassInfo())) {
+						&& parentClass.equals(fieldsCls.getClassInfo())
+						&& field.getName().startsWith("this$") /* TODO: don't check name */) {
 					int found = 0;
 					for (MethodNode mth : cls.getMethods()) {
 						if (removeFieldUsageFromConstructor(mth, field, fieldsCls)) {
@@ -75,7 +76,7 @@ private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode
 			return false;
 		}
 		List<RegisterArg> args = mth.getArguments(false);
-		if (args.isEmpty()) {
+		if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {
 			return false;
 		}
 		RegisterArg arg = args.get(0);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -548,7 +548,7 @@ private static void traverseMonitorExits(SynchronizedRegion region, InsnArg arg,
 				return;
 			}
 		}
-		for (BlockNode node : block.getCleanSuccessors()) {
+		for (BlockNode node : block.getSuccessors()) {
 			if (!visited.contains(node)) {
 				traverseMonitorExits(region, arg, node, exits, visited);
 			}

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -234,7 +234,7 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]
 	/**
 	 * Return fallback variant of method codegen
 	 */
-	static MethodGen getFallbackMethodGen(MethodNode mth) {
+	public static MethodGen getFallbackMethodGen(MethodNode mth) {
 		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true);
 		return new MethodGen(clsGen, mth);
 	}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -4,7 +4,7 @@
 import jadx.core.codegen.CodeGen;
 import jadx.core.dex.visitors.ClassModifier;
 import jadx.core.dex.visitors.CodeShrinker;
-import jadx.core.dex.visitors.ConstInlinerVisitor;
+import jadx.core.dex.visitors.ConstInlineVisitor;
 import jadx.core.dex.visitors.DebugInfoVisitor;
 import jadx.core.dex.visitors.DotGraphVisitor;
 import jadx.core.dex.visitors.EnumVisitor;
@@ -73,7 +73,7 @@ public static List<IDexTreeVisitor> getPassesList(IJadxArgs args, File outDir) {
 				passes.add(DotGraphVisitor.dumpRaw(outDir));
 			}
 
-			passes.add(new ConstInlinerVisitor());
+			passes.add(new ConstInlineVisitor());
 			passes.add(new FinishTypeInference());
 			passes.add(new EliminatePhiNodes());
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -12,6 +12,7 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.parser.FieldValueAttr;
 
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -44,7 +45,7 @@ public SSAVar getSVar() {
 		return sVar;
 	}
 
-	void setSVar(SSAVar sVar) {
+	void setSVar(@NotNull SSAVar sVar) {
 		this.sVar = sVar;
 	}
 
@@ -162,7 +163,7 @@ public boolean equalRegisterAndType(RegisterArg arg) {
 
 	@Override
 	public int hashCode() {
-		return (regNum * 31 + type.hashCode()) * 31 + (sVar != null ? sVar.hashCode() : 0);
+		return regNum * 31 + type.hashCode();
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/FallbackModeVisitor.java
Patch:
@@ -33,7 +33,7 @@ public void visit(MethodNode mth) throws JadxException {
 					case CONST_CLASS:
 					case CMP_L:
 					case CMP_G:
-						catchAttr.getTryBlock().removeInsn(insn);
+						catchAttr.getTryBlock().removeInsn(mth, insn);
 						break;
 
 					default:

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -878,7 +878,6 @@ public void processTryCatchBlocks(MethodNode mth) {
 		}
 	}
 
-	// TODO add blocks common for several handlers to some region
 	private void processExcHandler(ExceptionHandler handler, Set<BlockNode> exits) {
 		BlockNode start = handler.getHandlerBlock();
 		if (start == null) {

File: jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java
Patch:
@@ -154,6 +154,6 @@ public String decode(String attrName, int value) {
 				return sb.deleteCharAt(sb.length() - 1).toString();
 			}
 		}
-		return "UNKNOWN_DATA_" + Integer.toHexString(value);
+		return "UNKNOWN_DATA_0x" + Integer.toHexString(value);
 	}
 }

File: jadx-core/src/test/java/jadx/tests/integration/TestArgInline.java
Patch:
@@ -13,7 +13,7 @@ public class TestArgInline extends IntegrationTest {
 
 	public static class TestCls {
 
-		public void method(int a) {
+		public void test(int a) {
 			while (a < 10) {
 				int b = a + 1;
 				a = b;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestContinueInLoop2.java
Patch:
@@ -52,7 +52,7 @@ private static void test(MethodNode mth, BlockNode block) {
 								TryCatchBlock catchBlock = catchAttr.getTryBlock();
 								if (handlerBlock != catchBlock) {
 									handlerBlock.merge(mth, catchBlock);
-									catchBlock.removeInsn(insn);
+									catchBlock.removeInsn(mth, insn);
 								}
 							}
 						}

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -222,8 +222,8 @@ public void load() {
 		for (MethodNode mth : getMethods()) {
 			try {
 				mth.load();
-			} catch (DecodeException e) {
-				LOG.error("Method load error", e);
+			} catch (Exception e) {
+				LOG.error("Method load error:", e);
 				mth.addAttr(new JadxErrorAttr(e));
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -156,7 +156,8 @@ private static void removeEmptyMethods(ClassNode cls) {
 			// remove public empty constructors
 			if (af.isConstructor()
 					&& af.isPublic()
-					&& mth.getArguments(false).isEmpty()) {
+					&& mth.getArguments(false).isEmpty()
+					&& !mth.contains(AType.JADX_ERROR)) {
 				List<BlockNode> bb = mth.getBasicBlocks();
 				if (bb == null || bb.isEmpty() || allBlocksEmpty(bb)) {
 					mth.add(AFlag.DONT_GENERATE);

File: jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary3.java
Patch:
@@ -41,9 +41,8 @@ public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 
-		// TODO:
-		assertThat(code, containsOne("return (n == null || !(arg instanceof Named)) "
-				+ "? false : n.equals(((Named) arg).getName());"));
+		assertThat(code, containsOne("if (n == null || !(arg instanceof Named)) {"));
+		assertThat(code, containsOne("return n.equals(((Named) arg).getName());"));
 
 		assertThat(code, not(containsString("if ((arg instanceof RegisterArg)) {")));
 	}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -20,6 +20,7 @@
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.InvokeNode;
 import jadx.core.dex.instructions.InvokeType;
+import jadx.core.dex.instructions.NewArrayNode;
 import jadx.core.dex.instructions.SwitchNode;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.FieldArg;
@@ -341,7 +342,7 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro
 				break;
 
 			case NEW_ARRAY: {
-				ArgType arrayType = insn.getResult().getType();
+				ArgType arrayType = ((NewArrayNode) insn).getArrayType();
 				code.add("new ");
 				useType(code, arrayType.getArrayRootElement());
 				code.add('[');

File: jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java
Patch:
@@ -3,11 +3,13 @@
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.nodes.InsnNode;
 
+import org.jetbrains.annotations.NotNull;
+
 public class FilledNewArrayNode extends InsnNode {
 
 	private final ArgType elemType;
 
-	public FilledNewArrayNode(ArgType elemType, int size) {
+	public FilledNewArrayNode(@NotNull ArgType elemType, int size) {
 		super(InsnType.FILLED_NEW_ARRAY, size);
 		this.elemType = elemType;
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -535,8 +535,9 @@ private InsnNode decode(DecodedInstruction insn, int offset) throws DecodeExcept
 						InsnArg.reg(insn, 0, dex.getType(insn.getIndex())));
 
 			case Opcodes.NEW_ARRAY:
-				return insn(InsnType.NEW_ARRAY,
-						InsnArg.reg(insn, 0, dex.getType(insn.getIndex())),
+				ArgType arrType = dex.getType(insn.getIndex());
+				return new NewArrayNode(arrType,
+						InsnArg.reg(insn, 0, arrType),
 						InsnArg.reg(insn, 1, ArgType.INT));
 
 			case Opcodes.FILL_ARRAY_DATA:

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java
Patch:
@@ -222,7 +222,9 @@ private static void fixTypes(MethodNode mth, InsnNode insn, LiteralArg litArg) {
 				break;
 
 			case NEW_ARRAY:
-				litArg.merge(ArgType.INT);
+				if (litArg == insn.getArg(0)) {
+					litArg.merge(ArgType.INT);
+				}
 				break;
 
 			default:

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -12,6 +12,7 @@
 import jadx.core.dex.instructions.IndexInsnNode;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.InvokeNode;
+import jadx.core.dex.instructions.NewArrayNode;
 import jadx.core.dex.instructions.SwitchNode;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
@@ -108,7 +109,8 @@ private static void replaceStep(MethodNode mth, InstructionRemover remover) {
 							InsnNode ni = block.getInstructions().get(next);
 							if (ni.getType() == InsnType.FILL_ARRAY) {
 								ni.getResult().merge(insn.getResult());
-								((FillArrayNode) ni).mergeElementType(insn.getResult().getType().getArrayElement());
+								ArgType arrType = ((NewArrayNode) insn).getArrayType();
+								((FillArrayNode) ni).mergeElementType(arrType.getArrayElement());
 								remover.add(insn);
 							}
 						}

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -115,9 +115,7 @@ private String makeArgName(RegisterArg arg) {
 	}
 
 	private String getFallbackName(RegisterArg arg) {
-		String name = arg.getName();
-		String base = "r" + arg.getRegNum();
-		return name != null ? base + "_" + name : base;
+		return "r" + arg.getRegNum();
 	}
 
 	private static String makeNameForType(ArgType type) {

File: jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java
Patch:
@@ -30,7 +30,7 @@ public void test() {
 		String code = cls.getCode().toString();
 
 		assertThat(code, containsString("public int test(int r2) {"));
-		assertThat(code, containsString("r1_this = this;"));
+		assertThat(code, containsString("r1 = this;"));
 		assertThat(code, containsString("L_0x0004:"));
 		assertThat(code, not(containsString("throw new UnsupportedOperationException")));
 	}

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -18,7 +18,7 @@ public static void main(String[] args) throws JadxException {
 				processAndSave(jadxArgs);
 			}
 		} catch (Throwable e) {
-			LOG.error("jadx error: " + e.getMessage(), e);
+			LOG.error("jadx error: {}", e.getMessage(), e);
 			System.exit(1);
 		}
 	}
@@ -56,7 +56,7 @@ static boolean processArgs(JadxCLIArgs jadxArgs, String[] args) throws JadxExcep
 			} else {
 				outDirName = name + "-jadx-out";
 			}
-			LOG.info("output directory: " + outDirName);
+			LOG.info("output directory: {}", outDirName);
 			outputDir = new File(outDirName);
 			jadxArgs.setOutputDir(outputDir);
 		}

File: jadx-core/src/main/java/jadx/api/JavaPackage.java
Patch:
@@ -2,6 +2,8 @@
 
 import java.util.List;
 
+import org.jetbrains.annotations.NotNull;
+
 public final class JavaPackage implements JavaNode, Comparable<JavaPackage> {
 	private final String name;
 	private final List<JavaClass> classes;
@@ -32,7 +34,7 @@ public JavaClass getDeclaringClass() {
 	}
 
 	@Override
-	public int compareTo(JavaPackage o) {
+	public int compareTo(@NotNull JavaPackage o) {
 		return name.compareTo(o.name);
 	}
 

File: jadx-core/src/main/java/jadx/api/ResourcesLoader.java
Patch:
@@ -42,7 +42,7 @@ List<ResourceFile> load(List<InputFile> inputFiles) {
 		return list;
 	}
 
-	public static interface ResourceDecoder {
+	public interface ResourceDecoder {
 		Object decode(long size, InputStream is) throws IOException;
 	}
 
@@ -72,7 +72,7 @@ public static Object decodeStream(ResourceFile rf, ResourceDecoder decoder) thro
 					inputStream.close();
 				}
 			} catch (Exception e) {
-				LOG.debug("Error close zip file: " + zipRef, e);
+				LOG.debug("Error close zip file: {}", zipRef, e);
 			}
 		}
 	}
@@ -130,7 +130,7 @@ private void loadFile(List<ResourceFile> list, File file) {
 				try {
 					zip.close();
 				} catch (Exception e) {
-					LOG.error("Zip file close error: " + file.getAbsolutePath(), e);
+					LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -257,7 +257,7 @@ private CodeWriter makeSwitch(SwitchRegion sw, CodeWriter code) throws CodegenEx
 				} else if (k instanceof Integer) {
 					code.add(TypeGen.literalToString((Integer) k, arg.getType()));
 				} else {
-					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));
+					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : null));
 				}
 				code.add(':');
 			}

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -63,7 +63,7 @@ public static String literalToString(long lit, ArgType type) {
 			case OBJECT:
 			case ARRAY:
 				if (lit != 0) {
-					LOG.warn("Wrong object literal: " + lit + " for type: " + type);
+					LOG.warn("Wrong object literal: {} for type: {}", lit, type);
 					return Long.toString(lit);
 				}
 				return "null";

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -94,17 +94,17 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion current
 	}
 
 	private void printRegion(MethodNode mth) {
-		LOG.debug("|" + mth.toString());
+		LOG.debug("|{}", mth.toString());
 		printRegion(mth, mth.getRegion(), "| ");
 	}
 
 	private void printRegion(MethodNode mth, IRegion region, String indent) {
-		LOG.debug(indent + region);
+		LOG.debug("{}{}", indent, region);
 		for (IContainer container : region.getSubBlocks()) {
 			if (container instanceof IRegion) {
 				printRegion(mth, (IRegion) container, indent + "  ");
 			} else {
-				LOG.debug(indent + "  " + container);
+				LOG.debug("{}  {}", indent, container);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -40,7 +40,7 @@ private void addError(IAttributeNode node, String msg, Throwable e) {
 			if (e.getClass() == JadxOverflowException.class) {
 				// don't print full stack trace
 				e = new JadxOverflowException(e.getMessage());
-				LOG.error(msg + ", message: " + e.getMessage());
+				LOG.error("{}, message: {}", msg, e.getMessage());
 			} else {
 				LOG.error(msg, e);
 			}

File: jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java
Patch:
@@ -273,7 +273,7 @@ private String parseLocale() throws IOException {
 			if ((b1 & 0x80) == 0) {
 				str = new String(new char[]{(char) b1, (char) b2});
 			} else {
-				LOG.warn("TODO: parse locale: 0x" + Integer.toHexString(b1) + Integer.toHexString(b1));
+				LOG.warn("TODO: parse locale: 0x{}{}", Integer.toHexString(b1), Integer.toHexString(b2));
 			}
 		}
 		return str;

File: jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java
Patch:
@@ -92,7 +92,7 @@ public String decodeValue(int dataType, int data) {
 				return decodeComplex(data, true);
 
 			default:
-				LOG.warn("Unknown data type: 0x" + Integer.toHexString(dataType) + " " + data);
+				LOG.warn("Unknown data type: 0x{} {}", Integer.toHexString(dataType), data);
 				return "  ?0x" + Integer.toHexString(dataType) + " " + data;
 		}
 	}

File: jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDefinitions.java
Patch:
@@ -29,7 +29,7 @@ public void run() {
 					DepthTraversal.visit(pass, cls);
 				}
 			} catch (Exception e) {
-				LOG.error("Decode exception: " + cls, e);
+				LOG.error("Decode exception: {}", cls, e);
 			}
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/JadxGUI.java
Patch:
@@ -38,7 +38,7 @@ public void run() {
 				}
 			});
 		} catch (Throwable e) {
-			LOG.error("Error: " + e.getMessage());
+			LOG.error("Error: {}", e.getMessage());
 			System.exit(1);
 		}
 	}

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -31,9 +31,9 @@ public void openFile(File file) {
 		try {
 			this.decompiler.loadFile(file);
 		} catch (DecodeException e) {
-			LOG.error("Error decode file: " + file, e);
+			LOG.error("Error decode file: {}", file, e);
 		} catch (JadxException e) {
-			LOG.error("Error open file: " + file, e);
+			LOG.error("Error open file: {}", file, e);
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/ContentArea.java
Patch:
@@ -150,7 +150,7 @@ private void setCaretAtLine(int line) {
 		try {
 			setCaretPosition(getLineStartOffset(line));
 		} catch (BadLocationException e) {
-			LOG.debug("Can't scroll to " + line, e);
+			LOG.debug("Can't scroll to {}", line, e);
 		}
 	}
 

File: jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java
Patch:
@@ -26,7 +26,7 @@
 class SearchBar extends JToolBar {
 	private static final long serialVersionUID = 1836871286618633003L;
 
-	private static final Logger LOG = LoggerFactory.getLogger(SearchDialog.class);
+	private static final Logger LOG = LoggerFactory.getLogger(SearchBar.class);
 
 	private static final Color COLOR_BG_ERROR = new Color(0xFFDFDE);
 	private static final Color COLOR_BG_WARN = new Color(0xFFFDD9);

File: jadx-gui/src/main/java/jadx/gui/utils/Link.java
Patch:
@@ -20,7 +20,7 @@
 public class Link extends JLabel implements MouseListener {
 	private static final long serialVersionUID = 3655322136444908178L;
 
-	private static final Logger LOG = LoggerFactory.getLogger(JLabel.class);
+	private static final Logger LOG = LoggerFactory.getLogger(Link.class);
 
 	private String url;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -693,7 +693,7 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchNo
 		// check cases order if fall through case exists
 		if (!fallThroughCases.isEmpty()) {
 			if (isBadCasesOrder(blocksMap, fallThroughCases)) {
-				LOG.debug("Fixing incorrect switch cases order");
+				LOG.debug("Fixing incorrect switch cases order, method: {}", mth);
 				blocksMap = reOrderSwitchCases(blocksMap, fallThroughCases);
 				if (isBadCasesOrder(blocksMap, fallThroughCases)) {
 					LOG.error("Can't fix incorrect switch cases order, method: {}", mth);

File: jadx-core/src/main/java/jadx/api/ResourceType.java
Patch:
@@ -36,13 +36,13 @@ public static boolean isSupportedForUnpack(ResourceType type) {
 			case CODE:
 			case ARSC:
 			case LIB:
-			case XML:
 			case FONT:
 			case IMG:
 			case UNKNOWN:
 				return false;
 
 			case MANIFEST:
+			case XML:
 				return true;
 		}
 		return false;

File: jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java
Patch:
@@ -144,14 +144,14 @@ public Icon getIcon() {
 	private boolean isSupportedForView(ResourceType type) {
 		switch (type) {
 			case CODE:
-			case XML:
 			case ARSC:
 			case FONT:
 			case IMG:
 			case LIB:
 				return false;
 
 			case MANIFEST:
+			case XML:
 			case UNKNOWN:
 				return true;
 		}

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -11,6 +11,7 @@
 import jadx.core.dex.instructions.args.InsnWrapArg;
 import jadx.core.dex.instructions.mods.TernaryInsn;
 import jadx.core.dex.nodes.BlockNode;
+import jadx.core.dex.nodes.IBlock;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.regions.conditions.IfCondition;
@@ -133,13 +134,13 @@ public static boolean blockContains(BlockNode block, InsnNode insn) {
 		return false;
 	}
 
-	public static boolean checkLastInsnType(BlockNode block, InsnType expectedType) {
+	public static boolean checkLastInsnType(IBlock block, InsnType expectedType) {
 		InsnNode insn = getLastInsn(block);
 		return insn != null && insn.getType() == expectedType;
 	}
 
 	@Nullable
-	public static InsnNode getLastInsn(BlockNode block) {
+	public static InsnNode getLastInsn(IBlock block) {
 		List<InsnNode> insns = block.getInstructions();
 		if (insns.isEmpty()) {
 			return null;

File: jadx-core/src/test/java/jadx/tests/api/utils/CountString.java
Patch:
@@ -24,8 +24,7 @@ protected String relationship() {
 
 	@Override
 	public void describeMismatchSafely(String item, Description mismatchDescription) {
-		mismatchDescription.appendText("found ").appendValue(count(item))
-				.appendText(" in \"").appendText(item).appendText("\"");
+		mismatchDescription.appendText("found ").appendValue(count(item));
 	}
 
 	private int count(String string) {

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -272,7 +272,7 @@ private void makeCaseBlock(IContainer c, CodeWriter code) throws CodegenExceptio
 		boolean addBreak = true;
 		if (RegionUtils.notEmpty(c)) {
 			makeRegionIndent(code, c);
-			if (!RegionUtils.hasExitEdge(c)) {
+			if (RegionUtils.hasExitEdge(c)) {
 				addBreak = false;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java
Patch:
@@ -55,8 +55,7 @@ public boolean equals(Object obj) {
 		if (!super.equals(obj)) {
 			return false;
 		}
-		TypeImmutableArg that = (TypeImmutableArg) obj;
-		return isThis == that.isThis;
+		return isThis == ((TypeImmutableArg) obj).isThis;
 	}
 
 	@Override

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -42,6 +42,7 @@ public void saveAll(final File dir, final ProgressMonitor progressMonitor) {
 			public void run() {
 				try {
 					decompiler.setOutputDir(dir);
+					decompiler.parseAndSaveXML();
 					ThreadPoolExecutor ex = (ThreadPoolExecutor) decompiler.getSaveExecutor();
 					ex.shutdown();
 					while (ex.isTerminating()) {

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -42,6 +42,7 @@ public void saveAll(final File dir, final ProgressMonitor progressMonitor) {
 			public void run() {
 				try {
 					decompiler.setOutputDir(dir);
+					decompiler.parseAndSaveXML();
 					ThreadPoolExecutor ex = (ThreadPoolExecutor) decompiler.getSaveExecutor();
 					ex.shutdown();
 					while (ex.isTerminating()) {

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -47,7 +47,7 @@ public final class JadxCLIArgs implements IJadxArgs {
 	@Parameter(names = {"-h", "--help"}, description = "print this help", help = true)
 	protected boolean printHelp = false;
 
-	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir")
+	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml")
 	protected boolean xmlTest = false;
 
 	private final List<File> input = new ArrayList<File>(1);

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -8,15 +8,17 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import jadx.core.xmlgen.BinaryXMLParser;
+//import jadx.core.xmlgen.BinaryXMLParser;
 
 public class JadxCLI {
 	private static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);
 
 	public static void main(String[] args) throws JadxException {
+/*
 		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);
 		bxp.parse();
 		System.exit(4);
+*/
 		try {
 			JadxCLIArgs jadxArgs = new JadxCLIArgs();
 			if (processArgs(jadxArgs, args)) {

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -10,7 +10,7 @@
 import javax.swing.tree.DefaultMutableTreeNode;
 
 public abstract class JNode extends DefaultMutableTreeNode {
-
+	private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse
 	public static JNode makeFrom(JavaNode node) {
 		if (node instanceof JavaClass) {
 			JClass p = (JClass) makeFrom(node.getDeclaringClass());

File: jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java
Patch:
@@ -124,7 +124,7 @@ private void addPackage(Map<String, JPackage> pkgs, JPackage pkg) {
 	}
 
 	public JClass searchClassInTree(JClass node) {
-		Enumeration en = this.breadthFirstEnumeration();
+		Enumeration<?> en = this.breadthFirstEnumeration();
 		while (en.hasMoreElements()) {
 			Object obj = en.nextElement();
 			if (node.equals(obj)) {

File: jadx-gui/src/main/java/jadx/gui/utils/Link.java
Patch:
@@ -18,6 +18,7 @@
 import static java.awt.Desktop.Action;
 
 public class Link extends JLabel implements MouseListener {
+	private static final long serialVersionUID = 0L; // TODO: Generate random serialvers with serialver/eclipse
 	private static final Logger LOG = LoggerFactory.getLogger(JLabel.class);
 
 	private String url;

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java
Patch:
@@ -156,7 +156,7 @@ public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {
 
 	@Override
 	public String baseString() {
-		return body.baseString();
+		return body == null ? "-" : body.baseString();
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -535,6 +535,9 @@ private String makeArrayElements(FillArrayNode insn) throws CodegenException {
 		if (!elType.isTypeKnown()) {
 			LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);
 			elType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();
+			if (elType == null) {
+				throw new JadxRuntimeException("Null array element type");
+			}
 		}
 		insn.mergeElementType(elType);
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -20,6 +21,7 @@ public abstract class InsnArg extends Typed {
 
 	private static final Logger LOG = LoggerFactory.getLogger(InsnArg.class);
 
+	@Nullable("Null for method arguments")
 	protected InsnNode parentInsn;
 
 	public static RegisterArg reg(int regNum, ArgType type) {
@@ -70,6 +72,7 @@ public boolean isField() {
 		return false;
 	}
 
+	@Nullable
 	public InsnNode getParentInsn() {
 		return parentInsn;
 	}

File: jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java
Patch:
@@ -102,7 +102,7 @@ private static <T> T get(String url, Type type) throws IOException {
 		HttpURLConnection con = (HttpURLConnection) obj.openConnection();
 		con.setRequestMethod("GET");
 		if (con.getResponseCode() == 200) {
-			Reader reader = new InputStreamReader(con.getInputStream());
+			Reader reader = new InputStreamReader(con.getInputStream(), "UTF-8");
 			return GSON.fromJson(reader, type);
 		}
 		return null;

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java
Patch:
@@ -10,7 +10,7 @@
 
 public class IgnoreEdgeAttr implements IAttribute {
 
-	private final Set<BlockNode> blocks = new HashSet<BlockNode>();
+	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);
 
 	public Set<BlockNode> getBlocks() {
 		return blocks;

File: jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinallyExtract.java
Patch:
@@ -30,7 +30,6 @@ public String test() throws IOException {
 
 	@Test
 	public void test() {
-		setOutputCFG();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java
Patch:
@@ -45,6 +45,8 @@ public void visit(MethodNode mth) {
 		if (mth.isNoCode()) {
 			return;
 		}
+		mth.checkInstructions();
+
 		mth.initBasicBlocks();
 		splitBasicBlocks(mth);
 		processBlocksTree(mth);

File: jadx-core/src/test/java/jadx/tests/api/SmaliTest.java
Patch:
@@ -25,7 +25,7 @@ protected ClassNode getClassNodeFromSmali(String clsName) {
 		return getClassNodeFromFile(outDex, fullClsName);
 	}
 
-	private File getSmaliFile(String clsName) {
+	private static File getSmaliFile(String clsName) {
 		File smaliFile = new File(SMALI_TESTS_DIR, clsName + SMALI_TESTS_EXT);
 		if (smaliFile.exists()) {
 			return smaliFile;
@@ -38,7 +38,7 @@ private File getSmaliFile(String clsName) {
 		return null;
 	}
 
-	public boolean compileSmali(File input, File output) {
+	private static boolean compileSmali(File input, File output) {
 		List<String> args = new ArrayList<String>();
 		args.add(input.getAbsolutePath());
 

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -82,7 +82,6 @@ public static List<IDexTreeVisitor> getPassesList(IJadxArgs args, File outDir) {
 
 			passes.add(new CodeShrinker());
 			passes.add(new SimplifyVisitor());
-			passes.add(new ProcessVariables());
 			passes.add(new CheckRegions());
 
 			if (args.isCFGOutput()) {
@@ -93,6 +92,7 @@ public static List<IDexTreeVisitor> getPassesList(IJadxArgs args, File outDir) {
 			passes.add(new ClassModifier());
 			passes.add(new PrepareForCodeGen());
 			passes.add(new LoopRegionVisitor());
+			passes.add(new ProcessVariables());
 		}
 		passes.add(new CodeGen(args));
 		return passes;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -140,9 +140,8 @@ private BlockNode traverse(IRegion r, BlockNode block, RegionStack stack) {
 		}
 		if (next != null && !stack.containsExit(block) && !stack.containsExit(next)) {
 			return next;
-		} else {
-			return null;
 		}
+		return null;
 	}
 
 	private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stack) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java
Patch:
@@ -175,6 +175,8 @@ && isPathExists(nextIf.getElseBlock(), otherBranchBlock)) {
 				if (isInversionNeeded(currentIf, nextIf)) {
 					nextIf = IfInfo.invert(nextIf);
 				}
+			} else {
+				return currentIf;
 			}
 		}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java
Patch:
@@ -15,6 +15,7 @@ public enum AFlag {
 	DONT_WRAP,
 
 	DONT_SHRINK,
+	DONT_INLINE,
 	DONT_GENERATE,
 	SKIP,
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.core.dex.instructions;
 
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.instructions.args.ArgType;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.RegisterArg;
@@ -14,6 +15,7 @@ public PhiInsn(int regNum, int predecessors) {
 		for (int i = 0; i < predecessors; i++) {
 			addReg(regNum, ArgType.UNKNOWN);
 		}
+		add(AFlag.DONT_INLINE);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.core.dex.visitors;
 
+import jadx.core.dex.attributes.AFlag;
 import jadx.core.dex.attributes.AType;
 import jadx.core.dex.instructions.IfNode;
 import jadx.core.dex.instructions.InsnType;
@@ -59,6 +60,7 @@ private static void markExceptionHandlers(BlockNode block) {
 		RegisterArg resArg = me.getResult();
 		resArg = InsnArg.reg(resArg.getRegNum(), type);
 		me.setResult(resArg);
+		me.add(AFlag.DONT_INLINE);
 
 		excHandler.setArg(resArg);
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java
Patch:
@@ -107,7 +107,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion
 		List<RegisterArg> args = new LinkedList<RegisterArg>();
 		incrInsn.getRegisterArgs(args);
 		for (RegisterArg iArg : args) {
-			if (assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {
+			if (assignOnlyInLoop(mth, loopRegion, iArg)) {
 				return false;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -40,7 +40,7 @@ private void addError(IAttributeNode node, String msg, Throwable e) {
 			if (e.getClass() == JadxOverflowException.class) {
 				// don't print full stack trace
 				e = new JadxOverflowException(e.getMessage());
-				LOG.error(msg);
+				LOG.error(msg + ", message: " + e.getMessage());
 			} else {
 				LOG.error(msg, e);
 			}

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -201,6 +201,7 @@ void compile(ClassNode cls) {
 			dynamicCompiler = new DynamicCompiler(cls);
 			boolean result = dynamicCompiler.compile();
 			assertTrue("Compilation failed", result);
+			System.out.println("Compilation: PASSED");
 		} catch (Exception e) {
 			e.printStackTrace();
 			fail(e.getMessage());

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -22,7 +22,7 @@ public static void process(ClassNode cls, List<IDexTreeVisitor> passes) {
 				DepthTraversal.visit(visitor, cls);
 			}
 		} catch (Exception e) {
-			LOG.error("Class process exception: " + cls, e);
+			LOG.error("Class process exception: {}", cls, e);
 		} finally {
 			cls.unload();
 		}

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -96,7 +96,7 @@ public static NClass[] makeParentsArray(ClassNode cls, Map<String, NClass> names
 	private static NClass getCls(String fullName, Map<String, NClass> names) {
 		NClass id = names.get(fullName);
 		if (id == null && !names.containsKey(fullName)) {
-			LOG.warn("Class not found: " + fullName);
+			LOG.warn("Class not found: {}", fullName);
 		}
 		return id;
 	}
@@ -132,7 +132,7 @@ public void save(OutputStream output) throws IOException {
 			out.writeBytes(JADX_CLS_SET_HEADER);
 			out.writeByte(VERSION);
 
-			LOG.info("Classes count: " + classes.length);
+			LOG.info("Classes count: {}", classes.length);
 			out.writeInt(classes.length);
 			for (NClass cls : classes) {
 				writeString(out, cls.getName());

File: jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java
Patch:
@@ -39,7 +39,7 @@ public static void main(String[] args) throws IOException, DecodeException {
 			}
 		}
 		for (InputFile inputFile : inputFiles) {
-			LOG.info("Loaded: " + inputFile.getFile());
+			LOG.info("Loaded: {}", inputFile.getFile());
 		}
 
 		RootNode root = new RootNode();
@@ -48,7 +48,7 @@ public static void main(String[] args) throws IOException, DecodeException {
 		ClsSet set = new ClsSet();
 		set.load(root);
 		set.save(output);
-		LOG.info("Output: " + output);
+		LOG.info("Output: {}", output);
 		LOG.info("done");
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java
Patch:
@@ -150,9 +150,9 @@ public void encodeValue(CodeWriter code, Object val) {
 			// must be a static field
 			FieldInfo field = (FieldInfo) val;
 			InsnGen.makeStaticFieldAccess(code, field, classGen);
-		} else if (val instanceof List) {
+		} else if (val instanceof Iterable) {
 			code.add('{');
-			Iterator<?> it = ((List) val).iterator();
+			Iterator<?> it = ((Iterable) val).iterator();
 			while (it.hasNext()) {
 				Object obj = it.next();
 				encodeValue(code, obj);

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -25,7 +25,7 @@
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.InsnWrapArg;
 import jadx.core.dex.instructions.args.LiteralArg;
-import jadx.core.dex.instructions.args.NamedArg;
+import jadx.core.dex.instructions.args.Named;
 import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.instructions.mods.ConstructorInsn;
 import jadx.core.dex.instructions.mods.TernaryInsn;
@@ -98,7 +98,7 @@ public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenExc
 			Flags flag = wrap ? Flags.BODY_ONLY : Flags.BODY_ONLY_NOWRAP;
 			makeInsn(((InsnWrapArg) arg).getWrapInsn(), code, flag);
 		} else if (arg.isNamed()) {
-			code.add(((NamedArg) arg).getName());
+			code.add(((Named) arg).getName());
 		} else if (arg.isField()) {
 			FieldArg f = (FieldArg) arg;
 			if (f.isStatic()) {

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -292,7 +292,7 @@ private void makeTryCatch(TryCatchRegion region, CodeWriter code) throws Codegen
 				makeCatchBlock(code, handler);
 			} else {
 				if (allHandler != null) {
-					LOG.warn("Several 'all' handlers in try/catch block in " + mth);
+					LOG.warn("Several 'all' handlers in try/catch block in {}", mth);
 				}
 				allHandler = handler;
 			}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java
Patch:
@@ -15,6 +15,7 @@ public boolean isTypeImmutable() {
 
 	@Override
 	public void setType(ArgType type) {
+		// not allowed
 	}
 
 	public void markAsThis() {

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -132,7 +132,7 @@ private void loadAnnotations(ClassDef cls) {
 			try {
 				new AnnotationsParser(this).parse(offset);
 			} catch (DecodeException e) {
-				LOG.error("Error parsing annotations in " + this, e);
+				LOG.error("Error parsing annotations in {}", this, e);
 			}
 		}
 	}
@@ -184,7 +184,7 @@ private void parseClassSignature() {
 				}
 			}
 		} catch (JadxRuntimeException e) {
-			LOG.error("Class signature parse error: " + this, e);
+			LOG.error("Class signature parse error: {}", this, e);
 		}
 	}
 
@@ -198,7 +198,7 @@ private void setFieldsTypesFromSignature() {
 						field.setType(gType);
 					}
 				} catch (JadxRuntimeException e) {
-					LOG.error("Field signature parse error: " + field, e);
+					LOG.error("Field signature parse error: {}", field, e);
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -147,8 +147,7 @@ private boolean parseSignature() {
 					return false;
 				}
 				if (!mthInfo.isConstructor()) {
-					LOG.warn("Wrong signature parse result: " + sp + " -> " + argsTypes
-							+ ", not generic version: " + mthArgs);
+					LOG.warn("Wrong signature parse result: {} -> {}, not generic version: {}", sp, argsTypes, mthArgs);
 					return false;
 				} else if (getParentClass().getAccessFlags().isEnum()) {
 					// TODO:
@@ -164,7 +163,7 @@ private boolean parseSignature() {
 			}
 			initArguments(argsTypes);
 		} catch (JadxRuntimeException e) {
-			LOG.error("Method signature parse error: " + this, e);
+			LOG.error("Method signature parse error: {}", this, e);
 			return false;
 		}
 		return true;

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/LocalVar.java
Patch:
@@ -41,7 +41,7 @@ private void init(String name, ArgType type, String sign) {
 					type = gType;
 				}
 			} catch (Exception e) {
-				LOG.error("Can't parse signature for local variable: " + sign, e);
+				LOG.error("Can't parse signature for local variable: {}", sign, e);
 			}
 		}
 		this.name = name;

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -104,7 +104,7 @@ private static void simplifyIf(IfNode insn) {
 						&& ((LiteralArg) insn.getArg(1)).getLiteral() == 0) {
 					insn.changeCondition(insn.getOp(), wi.getArg(0), wi.getArg(1));
 				} else {
-					LOG.warn("TODO: cmp" + insn);
+					LOG.warn("TODO: cmp {}", insn);
 				}
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -100,7 +100,7 @@ private static void searchTryCatchDominators(MethodNode mth, Map<BlockNode, TryC
 
 			TryCatchBlock prevTB = tryBlocksMap.put(domBlock, tb);
 			if (prevTB != null) {
-				LOG.info("!!! TODO: merge try blocks in " + mth);
+				LOG.info("!!! TODO: merge try blocks in {}", mth);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -73,7 +73,7 @@ public static String methodError(MethodNode mth, String errorMsg) {
 
 	public void printReport() {
 		if (getErrorCount() > 0) {
-			LOG.error(getErrorCount() + " errors occurred in following nodes:");
+			LOG.error("{} errors occurred in following nodes:", getErrorCount());
 			List<Object> nodes = new ArrayList<Object>(errorNodes);
 			Collections.sort(nodes, new Comparator<Object>() {
 				@Override
@@ -83,7 +83,7 @@ public int compare(Object o1, Object o2) {
 			});
 			for (Object node : nodes) {
 				String nodeName = node.getClass().getSimpleName().replace("Node", "");
-				LOG.error("  " + nodeName + ": " + node);
+				LOG.error("  {}: {}", nodeName, node);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/utils/files/InputFile.java
Patch:
@@ -66,7 +66,7 @@ private static Dex loadFromJar(File jarFile) throws DecodeException {
 			if (ba.length == 0) {
 				throw new JadxException(j2d.isError() ? j2d.getDxErrors() : "Empty dx output");
 			} else if (j2d.isError()) {
-				LOG.warn("dx message: " + j2d.getDxErrors());
+				LOG.warn("dx message: {}", j2d.getDxErrors());
 			}
 			return new Dex(ba);
 		} catch (Throwable e) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java
Patch:
@@ -9,6 +9,7 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.regions.SwitchRegion;
+import jadx.core.dex.regions.TryCatchRegion;
 import jadx.core.dex.regions.conditions.IfRegion;
 import jadx.core.dex.regions.loops.LoopRegion;
 import jadx.core.dex.visitors.AbstractVisitor;
@@ -72,7 +73,8 @@ private boolean noTrailInstructions(BlockNode block) {
 			for (IRegion region : regionStack) {
 				// ignore paths on other branches
 				if (region instanceof IfRegion
-						|| region instanceof SwitchRegion) {
+						|| region instanceof SwitchRegion
+						|| region instanceof TryCatchRegion) {
 					curContainer = region;
 					continue;
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -45,7 +45,6 @@ private static void process(MethodNode mth) {
 		if (removeUselessPhi(mth)) {
 			renameVariables(mth);
 		}
-
 	}
 
 	private static void placePhi(MethodNode mth, int regNum, LiveVarAnalysis la) {

File: jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java
Patch:
@@ -82,7 +82,9 @@ public ClassNode getClassNodeFromFile(File file, String clsName) {
 		}
 		// don't unload class
 
+		System.out.println("-----------------------------------------------------------");
 		System.out.println(cls.getCode());
+		System.out.println("-----------------------------------------------------------");
 
 		checkCode(cls);
 		compile(cls);
@@ -163,6 +165,7 @@ private void runAutoCheck(String clsName) {
 			} catch (InvocationTargetException ie) {
 				rethrow("Decompiled check failed", ie);
 			}
+			System.out.println("Auto check: PASSED");
 		} catch (Exception e) {
 			e.printStackTrace();
 			fail("Auto check exception: " + e.getMessage());

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java
Patch:
@@ -72,7 +72,7 @@ public <T> List<T> getAll(AType<AttrList<T>> type) {
 		if (attrList == null) {
 			return Collections.emptyList();
 		}
-		return attrList.getList();
+		return Collections.unmodifiableList(attrList.getList());
 	}
 
 	public void remove(AFlag flag) {

File: jadx-core/src/test/java/jadx/tests/api/compiler/StaticCompiler.java
Patch:
@@ -13,7 +13,6 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -73,7 +72,7 @@ private static class ClassFileObject extends SimpleJavaFileObject {
 		private File file;
 
 		protected ClassFileObject(File file, Kind kind) {
-			super(URI.create("file://" + file.getAbsolutePath()), kind);
+			super(file.toURI(), kind);
 			this.file = file;
 		}
 

File: jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java
Patch:
@@ -43,7 +43,7 @@ public void addForField(CodeWriter code, FieldNode field) {
 
 	public void addForParameter(CodeWriter code, MethodParameters paramsAnnotations, int n) {
 		AnnotationsList aList = paramsAnnotations.getParamList().get(n);
-		if (aList == null || aList.size() == 0) {
+		if (aList == null || aList.isEmpty()) {
 			return;
 		}
 		for (Annotation a : aList.getAll()) {
@@ -54,7 +54,7 @@ public void addForParameter(CodeWriter code, MethodParameters paramsAnnotations,
 
 	private void add(IAttributeNode node, CodeWriter code) {
 		AnnotationsList aList = node.get(AType.ANNOTATION_LIST);
-		if (aList == null || aList.size() == 0) {
+		if (aList == null || aList.isEmpty()) {
 			return;
 		}
 		for (Annotation a : aList.getAll()) {

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -8,6 +8,9 @@
 
 public class TypeGen {
 
+	private TypeGen() {
+	}
+
 	public static String signature(ArgType type) {
 		PrimitiveType stype = type.getPrimitiveType();
 		if (stype == PrimitiveType.OBJECT) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -12,8 +12,6 @@
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.utils.exceptions.DecodeException;
 
-import java.io.EOFException;
-
 import com.android.dex.Code;
 import com.android.dx.io.OpcodeInfo;
 import com.android.dx.io.Opcodes;

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java
Patch:
@@ -38,11 +38,11 @@ public boolean isLiteral() {
 
 	public boolean isInteger() {
 		PrimitiveType type = this.type.getPrimitiveType();
-		return (type == PrimitiveType.INT
+		return type == PrimitiveType.INT
 				|| type == PrimitiveType.BYTE
 				|| type == PrimitiveType.CHAR
 				|| type == PrimitiveType.SHORT
-				|| type == PrimitiveType.LONG);
+				|| type == PrimitiveType.LONG;
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java
Patch:
@@ -162,7 +162,7 @@ public void process() throws DecodeException {
 
 		for (LocalVar var : locals) {
 			if (var != null && !var.isEnd()) {
-				var.end(mth.getCodeSize()-1, line);
+				var.end(mth.getCodeSize() - 1, line);
 				setVar(var);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java
Patch:
@@ -28,7 +28,7 @@ public IfInfo(IfInfo info, BlockNode thenBlock, BlockNode elseBlock) {
 	}
 
 	private IfInfo(IfCondition condition, BlockNode thenBlock, BlockNode elseBlock,
-	              Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {
+	               Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {
 		this.condition = condition;
 		this.thenBlock = thenBlock;
 		this.elseBlock = elseBlock;

File: jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java
Patch:
@@ -126,7 +126,6 @@ public void mergePreCondition() {
 		}
 	}
 
-
 	public LoopType getType() {
 		return type;
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -125,7 +125,7 @@ private static void removeSyntheticMethods(ClassNode cls) {
 				List<InsnNode> insns = mth.getBasicBlocks().get(0).getInstructions();
 				if (insns.size() == 1 && insns.get(0).getType() == InsnType.CONSTRUCTOR) {
 					ConstructorInsn constr = (ConstructorInsn) insns.get(0);
-					if (constr.isThis() && mth.getArguments(false).size() >= 1) {
+					if (constr.isThis() && !mth.getArguments(false).isEmpty()) {
 						mth.removeFirstArgument();
 						mth.add(AFlag.DONT_GENERATE);
 					}
@@ -167,7 +167,7 @@ private static void removeEmptyMethods(ClassNode cls) {
 
 	private static boolean allBlocksEmpty(List<BlockNode> blocks) {
 		for (BlockNode block : blocks) {
-			if (block.getInstructions().size() != 0) {
+			if (!block.getInstructions().isEmpty()) {
 				return false;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java
Patch:
@@ -150,7 +150,7 @@ private static void fixTypes(MethodNode mth, InsnNode insn, LiteralArg litArg) {
 				InvokeNode inv = (InvokeNode) insn;
 				List<ArgType> types = inv.getCallMth().getArgumentsTypes();
 				int count = insn.getArgsCount();
-				int k = (types.size() == count ? 0 : -1);
+				int k = types.size() == count ? 0 : -1;
 				for (int i = 0; i < count; i++) {
 					InsnArg arg = insn.getArg(i);
 					if (!arg.getType().isTypeKnown()) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -244,7 +244,7 @@ private static void processExceptionHandler(MethodNode mth, BlockNode block) {
 				InstructionRemover.remove(mth, excBlock, size - 1);
 
 				// move not removed instructions to 'finally' block
-				if (insns.size() != 0) {
+				if (!insns.isEmpty()) {
 					// TODO: support instructions from several blocks
 					// tryBlock.setFinalBlockFromInsns(mth, insns);
 					// TODO: because of incomplete realization don't extract final block,
@@ -255,14 +255,13 @@ private static void processExceptionHandler(MethodNode mth, BlockNode block) {
 		}
 
 		List<InsnNode> blockInsns = block.getInstructions();
-		if (blockInsns.size() > 0) {
+		if (!blockInsns.isEmpty()) {
 			InsnNode insn = blockInsns.get(0);
 			if (insn.getType() == InsnType.MOVE_EXCEPTION
 					&& insn.getResult().getSVar().getUseCount() == 0) {
 				InstructionRemover.remove(mth, block, 0);
 			}
 		}
-
 		int totalSize = 0;
 		for (BlockNode excBlock : excHandler.getBlocks()) {
 			totalSize += excBlock.getInstructions().size();

File: jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java
Patch:
@@ -218,7 +218,7 @@ public static EnumMapInfo checkEnumMapAccess(MethodNode mth, InsnNode checkInsn)
 		if (!(index instanceof FieldInfo)) {
 			return null;
 		}
-		FieldNode enumMapField = mth.dex().resolveField(((FieldInfo) index));
+		FieldNode enumMapField = mth.dex().resolveField((FieldInfo) index);
 		if (enumMapField == null || !enumMapField.getAccessFlags().isSynthetic()) {
 			return null;
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java
Patch:
@@ -6,10 +6,10 @@
 import jadx.core.dex.nodes.IContainer;
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.dex.regions.Region;
 import jadx.core.dex.regions.conditions.IfCondition;
 import jadx.core.dex.regions.conditions.IfCondition.Mode;
 import jadx.core.dex.regions.conditions.IfRegion;
-import jadx.core.dex.regions.Region;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.RegionUtils;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -12,8 +12,8 @@
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
-import jadx.core.dex.regions.conditions.IfRegion;
 import jadx.core.dex.regions.SwitchRegion;
+import jadx.core.dex.regions.conditions.IfRegion;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.RegionUtils;
 import jadx.core.utils.exceptions.JadxException;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -4,9 +4,9 @@
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
-import jadx.core.dex.regions.loops.LoopRegion;
 import jadx.core.dex.regions.Region;
 import jadx.core.dex.regions.SynchronizedRegion;
+import jadx.core.dex.regions.loops.LoopRegion;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.InstructionRemover;
 import jadx.core.utils.exceptions.JadxException;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java
Patch:
@@ -8,9 +8,9 @@
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
+import jadx.core.dex.regions.SwitchRegion;
 import jadx.core.dex.regions.conditions.IfRegion;
 import jadx.core.dex.regions.loops.LoopRegion;
-import jadx.core.dex.regions.SwitchRegion;
 import jadx.core.dex.visitors.AbstractVisitor;
 import jadx.core.utils.exceptions.JadxException;
 import jadx.core.utils.exceptions.JadxRuntimeException;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java
Patch:
@@ -12,8 +12,8 @@
 import jadx.core.dex.nodes.IContainer;
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.nodes.MethodNode;
-import jadx.core.dex.regions.conditions.IfRegion;
 import jadx.core.dex.regions.Region;
+import jadx.core.dex.regions.conditions.IfRegion;
 import jadx.core.dex.visitors.CodeShrinker;
 import jadx.core.utils.InsnList;
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/SelectTypeVisitor.java
Patch:
@@ -6,6 +6,9 @@
 
 public class SelectTypeVisitor {
 
+	private SelectTypeVisitor() {
+	}
+
 	public static void visit(InsnNode insn) {
 		InsnArg res = insn.getResult();
 		if (res != null && !res.getType().isTypeKnown()) {

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -66,6 +66,7 @@ public static String methodError(MethodNode mth, String errorMsg, Throwable e) {
 		mth.dex().root().getErrorsCounter().addError(mth, msg, e);
 		return msg;
 	}
+
 	public static String methodError(MethodNode mth, String errorMsg) {
 		return methodError(mth, errorMsg, null);
 	}

File: jadx-core/src/main/java/jadx/core/utils/RegionUtils.java
Patch:
@@ -27,7 +27,7 @@ private RegionUtils() {
 	public static boolean hasExitEdge(IContainer container) {
 		if (container instanceof BlockNode) {
 			BlockNode block = (BlockNode) container;
-			return block.getSuccessors().size() != 0
+			return !block.getSuccessors().isEmpty()
 					&& !block.contains(AFlag.RETURN);
 		} else if (container instanceof IRegion) {
 			IRegion region = (IRegion) container;
@@ -109,7 +109,7 @@ public static boolean isEmpty(IContainer container) {
 
 	public static boolean notEmpty(IContainer container) {
 		if (container instanceof BlockNode) {
-			return ((BlockNode) container).getInstructions().size() != 0;
+			return !((BlockNode) container).getInstructions().isEmpty();
 		} else if (container instanceof IRegion) {
 			IRegion region = (IRegion) container;
 			for (IContainer block : region.getSubBlocks()) {

File: jadx-core/src/test/java/jadx/tests/smali/TestConstructor.java
Patch:
@@ -1,7 +1,7 @@
 package jadx.tests.smali;
 
-import jadx.tests.api.SmaliTest;
 import jadx.core.dex.nodes.ClassNode;
+import jadx.tests.api.SmaliTest;
 
 import org.junit.Test;
 

File: jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java
Patch:
@@ -2,6 +2,9 @@
 
 public class VersionComparator {
 
+	private VersionComparator() {
+	}
+
 	public static int checkAndCompare(String str1, String str2) {
 		try {
 			return compare(clean(str1), clean(str2));

File: jadx-gui/src/test/java/jadx/gui/treemodel/JRootTest.java
Patch:
@@ -1,8 +1,8 @@
 package jadx.gui.treemodel;
 
-import jadx.api.JadxDecompiler;
 import jadx.api.Factory;
 import jadx.api.IJadxArgs;
+import jadx.api.JadxDecompiler;
 import jadx.api.JavaClass;
 import jadx.api.JavaPackage;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -680,7 +680,7 @@ private void generateArguments(CodeWriter code, InsnNode insn, int k, MethodNode
 				if (!arg.getType().equals(origType)) {
 					code.add('(');
 					useType(code, origType);
-					code.add(')');
+					code.add(") ");
 					addArg(code, arg, true);
 				} else {
 					addArg(code, arg, false);

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java
Patch:
@@ -39,6 +39,7 @@ void setSVar(SSAVar sVar) {
 		if (isThis) {
 			sVar.setName("this");
 		}
+		sVar.setTypeImmutable(type);
 		super.setSVar(sVar);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -80,6 +80,7 @@ public void mergeDebugInfo(ArgType type, String name) {
 		setName(name);
 	}
 
+	@Deprecated
 	public void forceType(ArgType type) {
 		this.type = type;
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java
Patch:
@@ -44,8 +44,7 @@ public void visit(MethodNode mth) throws JadxException {
 	private static ArgType processType(SSAVar var) {
 		RegisterArg assign = var.getAssign();
 		List<RegisterArg> useList = var.getUseList();
-		if (assign != null
-				&& (useList.isEmpty() || assign.isTypeImmutable())) {
+		if (assign != null && (useList.isEmpty() || var.isTypeImmutable())) {
 			return assign.getType();
 		}
 		ArgType type;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -356,7 +356,8 @@ private boolean tryInsertBreak(RegionStack stack, BlockNode loopExit, Edge exitE
 		if (loopExit == exit) {
 			// try/catch at loop end
 			BlockNode source = exitEdge.getSource();
-			if (source.contains(AType.CATCH_BLOCK)) {
+			if (source.contains(AType.CATCH_BLOCK)
+					&& source.getSuccessors().size() == 2) {
 				BlockNode other = BlockUtils.selectOther(loopExit, source.getSuccessors());
 				if (other != null && other.contains(AType.EXC_HANDLER)) {
 					insertBlock = source;

File: jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops3.java
Patch:
@@ -62,7 +62,6 @@ public void check() {
 
 	@Test
 	public void test() {
-		setOutputCFG();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -526,7 +526,7 @@ private void fillArray(FillArrayNode insn, CodeWriter code) throws CodegenExcept
 			);
 		}
 		if (!elType.isTypeKnown()) {
-			LOG.warn("Unknown array element type: {} in mth: {}", elType);
+			LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);
 			elType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();
 		}
 		StringBuilder str = new StringBuilder();

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -127,6 +127,9 @@ private static void renameVar(MethodNode mth, SSAVar[] vars, int[] vers, BlockNo
 					throw new JadxRuntimeException("Can't find predecessor for " + block + " " + s);
 				}
 				for (PhiInsn phiInsn : phiList.getList()) {
+					if (j >= phiInsn.getArgsCount()) {
+						continue;
+					}
 					int regNum = phiInsn.getResult().getRegNum();
 					SSAVar var = vars[regNum];
 					if (var == null) {

File: jadx-core/src/main/java/jadx/core/clsp/ClsSet.java
Patch:
@@ -3,9 +3,9 @@
 import jadx.core.dex.info.ClassInfo;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.RootNode;
-import jadx.core.utils.Utils;
 import jadx.core.utils.exceptions.DecodeException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
+import jadx.core.utils.files.FileUtils;
 
 import java.io.BufferedOutputStream;
 import java.io.DataInputStream;
@@ -102,7 +102,7 @@ private static NClass getCls(String fullName, Map<String, NClass> names) {
 	}
 
 	void save(File output) throws IOException {
-		Utils.makeDirsForFile(output);
+		FileUtils.makeDirsForFile(output);
 
 		BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(output));
 		try {

File: jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java
Patch:
@@ -2,7 +2,7 @@
 
 import jadx.api.CodePosition;
 import jadx.core.dex.attributes.nodes.LineAttrNode;
-import jadx.core.utils.Utils;
+import jadx.core.utils.files.FileUtils;
 
 import java.io.File;
 import java.io.PrintWriter;
@@ -288,7 +288,7 @@ public void save(File file) {
 
 		PrintWriter out = null;
 		try {
-			Utils.makeDirsForFile(file);
+			FileUtils.makeDirsForFile(file);
 			out = new PrintWriter(file, "UTF-8");
 			String code = buf.toString();
 			code = removeFirstEmptyLine(code);

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java
Patch:
@@ -171,6 +171,8 @@ public void process() throws DecodeException {
 
 	private int addrChange(int addr, int addrInc, int line) {
 		int newAddr = addr + addrInc;
+		int maxAddr = insnByOffset.length - 1;
+		newAddr = Math.min(newAddr, maxAddr);
 		for (int i = addr + 1; i <= newAddr; i++) {
 			InsnNode insn = insnByOffset[i];
 			if (insn == null) {
@@ -255,7 +257,7 @@ private static void merge(InsnArg arg, LocalVar var) {
 				} else {
 					mergeRequired = true;
 				}
-				
+
 				if (mergeRequired) {
 					reg.mergeDebugInfo(var.getType(), var.getName());
 				}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -80,6 +80,7 @@ private static void addPhi(BlockNode block, int regNum) {
 		}
 		PhiInsn phiInsn = new PhiInsn(regNum, block.getPredecessors().size());
 		phiList.getList().add(phiInsn);
+		phiInsn.setOffset(block.getStartOffset());
 		block.getInstructions().add(0, phiInsn);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -80,6 +80,7 @@ private static void addPhi(BlockNode block, int regNum) {
 		}
 		PhiInsn phiInsn = new PhiInsn(regNum, block.getPredecessors().size());
 		phiList.getList().add(phiInsn);
+		phiInsn.setOffset(block.getStartOffset());
 		block.getInstructions().add(0, phiInsn);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java
Patch:
@@ -47,8 +47,8 @@ static IfInfo restructureIf(MethodNode mth, BlockNode block, IfInfo info) {
 			info.setOutBlock(null);
 			return info;
 		}
-		boolean badThen = !allPathsFromIf(thenBlock, info);
-		boolean badElse = !allPathsFromIf(elseBlock, info);
+		boolean badThen = thenBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(thenBlock, info);
+		boolean badElse = elseBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(elseBlock, info);
 		if (badThen && badElse) {
 			LOG.debug("Stop processing blocks after 'if': {}, method: {}", info.getIfBlock(), mth);
 			return null;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -199,9 +199,11 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac
 			BlockNode thenBlock = condInfo.getThenBlock();
 			out = (thenBlock == loopStart ? condInfo.getElseBlock() : thenBlock);
 			loopStart.remove(AType.LOOP);
+			loop.getEnd().add(AFlag.SKIP);
 			stack.addExit(loop.getEnd());
 			loopRegion.setBody(makeRegion(loopStart, stack));
 			loopStart.addAttr(AType.LOOP, loop);
+			loop.getEnd().remove(AFlag.SKIP);
 		} else {
 			out = condInfo.getElseBlock();
 			if (outerRegion != null

File: jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java
Patch:
@@ -138,6 +138,6 @@ public String baseString() {
 
 	@Override
 	public String toString() {
-		return "LOOP";
+		return "LOOP: " + baseString();
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java
Patch:
@@ -42,9 +42,8 @@ public void visit(MethodNode mth) throws JadxException {
 
 	private static void postProcessRegions(MethodNode mth) {
 		// make try-catch regions
-		if (!mth.isNoExceptionHandlers()) {
-			DepthRegionTraversal.traverse(mth, new ProcessTryCatchRegions(mth));
-		}
+		ProcessTryCatchRegions.process(mth);
+
 		// merge conditions in loops
 		if (mth.getLoopsCount() != 0) {
 			DepthRegionTraversal.traverseAll(mth, new AbstractRegionVisitor() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TracedRegionVisitor.java
Patch:
@@ -12,20 +12,20 @@ public abstract class TracedRegionVisitor implements IRegionVisitor {
 	protected final Deque<IRegion> regionStack = new ArrayDeque<IRegion>();
 
 	@Override
-	public void enterRegion(MethodNode mth, IRegion region) {
+	public final void enterRegion(MethodNode mth, IRegion region) {
 		regionStack.push(region);
 	}
 
 	@Override
-	public void processBlock(MethodNode mth, IBlock container) {
+	public final void processBlock(MethodNode mth, IBlock container) {
 		IRegion curRegion = regionStack.peek();
 		processBlockTraced(mth, container, curRegion);
 	}
 
 	public abstract void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion);
 
 	@Override
-	public void leaveRegion(MethodNode mth, IRegion region) {
+	public final void leaveRegion(MethodNode mth, IRegion region) {
 		regionStack.pop();
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -566,7 +566,7 @@ private void fillArray(FillArrayNode insn, CodeWriter code) throws CodegenExcept
 	private void makeConstructor(ConstructorInsn insn, CodeWriter code)
 			throws CodegenException {
 		ClassNode cls = mth.dex().resolveClass(insn.getClassType());
-		if (cls != null && cls.isAnonymous()) {
+		if (cls != null && cls.isAnonymous() && !fallback) {
 			// anonymous class construction
 			ClassInfo parent;
 			if (cls.getInterfaces().size() == 1) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/LiveVarAnalysis.java
Patch:
@@ -20,7 +20,6 @@ public class LiveVarAnalysis {
 
 	public LiveVarAnalysis(MethodNode mth) {
 		this.mth = mth;
-		runAnalysis();
 	}
 
 	public void runAnalysis() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -231,7 +231,8 @@ private LoopRegion makeLoopRegion(IRegion curRegion, LoopInfo loop, List<BlockNo
 			}
 			LoopRegion loopRegion = new LoopRegion(curRegion, block, block == loop.getEnd());
 			boolean found;
-			if (block == loop.getStart() || block == loop.getEnd()) {
+			if (block == loop.getStart() || block == loop.getEnd()
+					|| BlockUtils.isEmptySimplePath(loop.getStart(), block)) {
 				found = true;
 			} else if (block.getPredecessors().contains(loop.getStart())) {
 				loopRegion.setPreCondition(loop.getStart());

File: jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java
Patch:
@@ -1,7 +1,7 @@
 package jadx.cli;
 
 import jadx.api.IJadxArgs;
-import jadx.core.Consts;
+import jadx.api.JadxDecompiler;
 import jadx.core.utils.exceptions.JadxException;
 
 import java.io.File;
@@ -105,7 +105,7 @@ public void printUsage() {
 		// print usage in not sorted fields order (by default its sorted by description)
 		PrintStream out = System.out;
 		out.println();
-		out.println("jadx - dex to java decompiler, version: " + Consts.JADX_VERSION);
+		out.println("jadx - dex to java decompiler, version: " + JadxDecompiler.getVersion());
 		out.println();
 		out.println("usage: jadx [options] " + jc.getMainParameterDescription());
 		out.println("options:");
@@ -148,6 +148,7 @@ public List<File> getInput() {
 		return input;
 	}
 
+	@Override
 	public File getOutDir() {
 		return outputDir;
 	}

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -1,8 +1,6 @@
 package jadx.core;
 
 public class Consts {
-	public static final String JADX_VERSION = Jadx.getVersion();
-
 	public static final boolean DEBUG = false;
 
 	public static final String CLASS_OBJECT = "java.lang.Object";

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -172,7 +172,7 @@ public static void guessName(RegisterArg arg) {
 		}
 	}
 
-	public static String getAliasForObject(String name) {
+	private static String getAliasForObject(String name) {
 		return OBJ_ALIAS.get(name);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -259,6 +259,7 @@ private void initTryCatches(Code mthCode) {
 					if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {
 						for (ExceptionHandler h : ct1.getHandlers()) {
 							ct2.removeHandler(this, h);
+							h.setTryBlock(ct1);
 						}
 					}
 				}

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -255,7 +255,7 @@ public static BlockNode getPathCross(MethodNode mth, BlockNode b1, BlockNode b2)
 		}
 		BitSet b = new BitSet();
 		b.or(b1.getDomFrontier());
-		b.or(b2.getDomFrontier());
+		b.and(b2.getDomFrontier());
 		b.clear(b1.getId());
 		b.clear(b2.getId());
 		if (b.cardinality() == 1) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -571,8 +571,9 @@ public void processTryCatchBlocks(MethodNode mth) {
 						LOG.debug(ErrorsCounter.formatErrorMsg(mth, "No successors for splitter: " + splitter));
 						continue;
 					}
-					BlockNode cross = BlockUtils.getPathCross(mth, s.get(0), handler);
-					if (cross != null) {
+					BlockNode ss = s.get(0);
+					BlockNode cross = BlockUtils.getPathCross(mth, ss, handler);
+					if (cross != null && cross != ss && cross != handler) {
 						exits.add(cross);
 					}
 				}

File: jadx-core/src/main/java/jadx/core/codegen/NameGen.java
Patch:
@@ -91,7 +91,7 @@ private String makeArgName(RegisterArg arg) {
 		String name = arg.getName();
 		if (fallback) {
 			String base = "r" + arg.getRegNum();
-			if (name != null) {
+			if (name != null && !name.equals("this")) {
 				return base + "_" + name;
 			}
 			return base;

File: jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java
Patch:
@@ -125,7 +125,9 @@ public List<IContainer> getSubBlocks() {
 		if (conditionBlock != null) {
 			all.add(conditionBlock);
 		}
-		all.add(body);
+		if (body != null) {
+			all.add(body);
+		}
 		return Collections.unmodifiableList(all);
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -10,6 +10,7 @@
 import jadx.core.dex.nodes.InsnNode;
 import jadx.core.dex.regions.Compare;
 import jadx.core.dex.regions.IfCondition;
+import jadx.core.dex.regions.IfCondition.Mode;
 import jadx.core.utils.ErrorsCounter;
 import jadx.core.utils.exceptions.CodegenException;
 import jadx.core.utils.exceptions.JadxRuntimeException;
@@ -99,7 +100,7 @@ private void addNot(CodeWriter code, IfCondition condition) throws CodegenExcept
 	}
 
 	private void addAndOr(CodeWriter code, IfCondition condition) throws CodegenException {
-		String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";
+		String mode = condition.getMode() == Mode.AND ? " && " : " || ";
 		Iterator<IfCondition> it = condition.getArgs().iterator();
 		while (it.hasNext()) {
 			wrap(code, it.next());
@@ -110,7 +111,7 @@ private void addAndOr(CodeWriter code, IfCondition condition) throws CodegenExce
 	}
 
 	private boolean isWrapNeeded(IfCondition condition) {
-		return !condition.isCompare() && condition.getMode() != IfCondition.Mode.NOT;
+		return !condition.isCompare() && condition.getMode() != Mode.NOT;
 	}
 
 	private static boolean isArgWrapNeeded(InsnArg arg) {

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -58,7 +58,7 @@ public class InsnGen {
 	protected final RootNode root;
 	protected final boolean fallback;
 
-	private static enum Flags {
+	private enum Flags {
 		BODY_ONLY,
 		BODY_ONLY_NOWRAP,
 	}

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -132,7 +132,7 @@ private void addMethodArguments(CodeWriter argsCode, List<RegisterArg> args) {
 				if (type.isArray()) {
 					ArgType elType = type.getArrayElement();
 					classGen.useType(argsCode, elType);
-					argsCode.add(" ...");
+					argsCode.add("...");
 				} else {
 					LOG.warn(ErrorsCounter.formatErrorMsg(mth, "Last argument in varargs method not array"));
 					classGen.useType(argsCode, arg.getType());

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -9,7 +9,7 @@
 public class TypeGen {
 
 	public static String signature(ArgType type) {
-		final PrimitiveType stype = type.getPrimitiveType();
+		PrimitiveType stype = type.getPrimitiveType();
 		if (stype == PrimitiveType.OBJECT) {
 			return Utils.makeQualifiedObjectName(type.getObject());
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Annotation {
 
-	public static enum Visibility {
+	public enum Visibility {
 		BUILD, RUNTIME, SYSTEM
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java
Patch:
@@ -53,7 +53,7 @@ public String toString() {
 	private MethodNode staticMethod;
 
 	public EnumClassAttr(int fieldsCount) {
-		this.fields = new ArrayList<EnumClassAttr.EnumField>(fieldsCount);
+		this.fields = new ArrayList<EnumField>(fieldsCount);
 	}
 
 	public List<EnumField> getFields() {

File: jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java
Patch:
@@ -8,7 +8,7 @@ public class AccessInfo {
 
 	private final int accFlags;
 
-	public static enum AFType {
+	public enum AFType {
 		CLASS, FIELD, METHOD
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java
Patch:
@@ -17,7 +17,7 @@ public enum ArithOp {
 
 	private final String symbol;
 
-	private ArithOp(String symbol) {
+	ArithOp(String symbol) {
 		this.symbol = symbol;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java
Patch:
@@ -2,7 +2,7 @@
 
 public class MthParameterArg extends RegisterArg {
 
-	private boolean isThis = false;
+	private boolean isThis;
 
 	public MthParameterArg(int rn, ArgType type) {
 		super(rn, type);

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/PrimitiveType.java
Patch:
@@ -16,7 +16,7 @@ public enum PrimitiveType {
 	private final String shortName;
 	private final String longName;
 
-	private PrimitiveType(String shortName, String longName) {
+	PrimitiveType(String shortName, String longName) {
 		this.shortName = shortName;
 		this.longName = longName;
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -14,7 +14,7 @@ public class ConstructorInsn extends InsnNode {
 	private final CallType callType;
 	private final RegisterArg instanceArg;
 
-	private static enum CallType {
+	private enum CallType {
 		CONSTRUCTOR, // just new instance
 		SUPER, // super call
 		THIS, // call constructor from other constructor

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java
Patch:
@@ -20,7 +20,7 @@
 
 public class AnnotationsParser {
 
-	private static final Annotation.Visibility[] VISIBILITIES = {
+	private static final Visibility[] VISIBILITIES = {
 			Visibility.BUILD,
 			Visibility.RUNTIME,
 			Visibility.SYSTEM

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/LocalVar.java
Patch:
@@ -11,7 +11,7 @@
 final class LocalVar {
 	private static final Logger LOG = LoggerFactory.getLogger(LocalVar.class);
 
-	private int regNum;
+	private final int regNum;
 	private String name;
 	private ArgType type;
 

File: jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class IfCondition {
 
-	public static enum Mode {
+	public enum Mode {
 		COMPARE,
 		NOT,
 		AND,

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java
Patch:
@@ -7,6 +7,7 @@
 import jadx.core.dex.nodes.IRegion;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.regions.IfCondition;
+import jadx.core.dex.regions.IfCondition.Mode;
 import jadx.core.dex.regions.IfRegion;
 import jadx.core.dex.regions.Region;
 import jadx.core.dex.visitors.AbstractVisitor;
@@ -58,7 +59,7 @@ private static void processIfRegion(MethodNode mth, IfRegion ifRegion) {
 	private static void simplifyIfCondition(IfRegion ifRegion) {
 		if (ifRegion.simplifyCondition()) {
 			IfCondition condition = ifRegion.getCondition();
-			if (condition.getMode() == IfCondition.Mode.NOT) {
+			if (condition.getMode() == Mode.NOT) {
 				invertIfRegion(ifRegion);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java
Patch:
@@ -403,12 +403,12 @@ private BlockNode processIf(IRegion currentRegion, BlockNode block, IfNode ifnod
 
 			// select 'then', 'else' and 'exit' blocks
 			if (bElse.getPredecessors().size() != 1
-					&& BlockUtils.isPathExists(bThen, bElse)) {
+					&& isPathExists(bThen, bElse)) {
 				thenBlock = bThen;
 				elseBlock = null;
 				out = bElse;
 			} else if (bThen.getPredecessors().size() != 1
-					&& BlockUtils.isPathExists(bElse, bThen)) {
+					&& isPathExists(bElse, bThen)) {
 				ifnode.invertCondition();
 				thenBlock = ifnode.getThenBlock();
 				elseBlock = null;
@@ -511,7 +511,7 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchNo
 			for (BlockNode maybeOut : block.getSuccessors()) {
 				boolean allReached = true;
 				for (BlockNode s : block.getSuccessors()) {
-					if (!BlockUtils.isPathExists(s, maybeOut)) {
+					if (!isPathExists(s, maybeOut)) {
 						allReached = false;
 						break;
 					}

File: jadx-core/src/test/java/jadx/api/TestUtils.java
Patch:
@@ -5,6 +5,9 @@
 public class TestUtils {
 
 	public static String indent(int indent) {
+		if (indent == 1) {
+			return CodeWriter.INDENT;
+		}
 		StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT.length());
 		for (int i = 0; i < indent; i++) {
 			sb.append(CodeWriter.INDENT);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AType.java
Patch:
@@ -25,6 +25,9 @@
  */
 public class AType<T extends IAttribute> {
 
+	private AType() {
+	}
+
 	public static final AType<AttrList<JumpInfo>> JUMP = new AType<AttrList<JumpInfo>>();
 	public static final AType<AttrList<LoopInfo>> LOOP = new AType<AttrList<LoopInfo>>();
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -151,7 +151,7 @@ private Region wrapBlocks(IRegion region, BlockNode dominator) {
 				aReg.setParent(newRegion);
 			}
 		}
-		
+
 		return newRegion;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java
Patch:
@@ -43,7 +43,7 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion current
 				if (insns.size() == 1
 						&& blockNotInLoop(mth, block)
 						&& noTrailInstructions(block)) {
-					insns.remove(insns.size() - 1);
+					insns.remove(0);
 					block.remove(AFlag.RETURN);
 				}
 			}
@@ -96,15 +96,15 @@ private boolean noTrailInstructions(BlockNode block) {
 		/**
 		 * Check if container not contains instructions,
 		 * don't count one 'return' instruction (it will be removed later).
- 		 */
+		 */
 		private static boolean isEmpty(IContainer container) {
 			if (container instanceof BlockNode) {
 				BlockNode block = (BlockNode) container;
 				return block.getInstructions().isEmpty() || block.contains(AFlag.RETURN);
 			} else if (container instanceof IRegion) {
 				IRegion region = (IRegion) container;
 				for (IContainer block : region.getSubBlocks()) {
-					if(!isEmpty(block)) {
+					if (!isEmpty(block)) {
 						return false;
 					}
 				}

File: jadx-core/src/main/java/jadx/core/utils/RegionUtils.java
Patch:
@@ -39,7 +39,7 @@ public static boolean hasExitEdge(IContainer container) {
 	 */
 	public static boolean hasExitBlock(IContainer container) {
 		if (container instanceof BlockNode) {
-			return ((BlockNode) container).getSuccessors().size() == 0;
+			return ((BlockNode) container).getSuccessors().isEmpty();
 		} else if (container instanceof IRegion) {
 			List<IContainer> blocks = ((IRegion) container).getSubBlocks();
 			return !blocks.isEmpty()

File: jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions2.java
Patch:
@@ -8,7 +8,6 @@
 public class TestConditions2 extends InternalJadxTest {
 
 	public static class TestCls {
-
 		int c;
 		String d;
 		String f;

File: jadx-core/src/test/java/jadx/tests/internal/usethis/TestRedundantThis.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.usethis;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;
@@ -30,7 +30,6 @@ public void method2(int field2) {
 	// @Test
 	public void test() {
 		ClassNode cls = getClassNode(TestCls.class);
-
 		String code = cls.getCode().toString();
 
 		assertThat(code, not(containsString("this.f1();")));

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -199,7 +199,7 @@ private CodeWriter makeSwitch(SwitchRegion sw, CodeWriter code) throws CodegenEx
 		SwitchNode insn = (SwitchNode) sw.getHeader().getInstructions().get(0);
 		InsnArg arg = insn.getArg(0);
 		code.startLine("switch (");
-		addArg(code, arg);
+		addArg(code, arg, false);
 		code.add(") {");
 		code.incIndent();
 

File: jadx-core/src/test/java/jadx/tests/internal/switches/TestSwitchLabels.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.switches;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/main/java/jadx/api/JadxDecompiler.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Jadx API usage example:
  * <pre><code>
- *  Decompiler jadx = new Decompiler();
+ *  JadxDecompiler jadx = new JadxDecompiler();
  *  jadx.loadFile(new File("classes.dex"));
  *  jadx.setOutputDir(new File("out"));
  *  jadx.save();

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -101,7 +101,7 @@ public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenExc
 			if (f.isStatic()) {
 				staticField(code, f.getField());
 			} else {
-				instanceField(code, f.getField(), f.getRegisterArg());
+				instanceField(code, f.getField(), f.getInstanceArg());
 			}
 		} else {
 			throw new CodegenException("Unknown arg type " + arg);

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -14,7 +14,6 @@
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.instructions.args.InsnWrapArg;
 import jadx.core.dex.instructions.args.LiteralArg;
-import jadx.core.dex.instructions.args.RegisterArg;
 import jadx.core.dex.instructions.mods.ConstructorInsn;
 import jadx.core.dex.nodes.BlockNode;
 import jadx.core.dex.nodes.InsnNode;
@@ -186,9 +185,9 @@ private static InsnNode convertFieldArith(MethodNode mth, InsnNode insn) {
 			return null;
 		}
 		try {
-			RegisterArg reg = null;
+			InsnArg reg = null;
 			if (getType == InsnType.IGET) {
-				reg = ((RegisterArg) get.getArg(0));
+				reg = get.getArg(0);
 			}
 			FieldArg fArg = new FieldArg(field, reg);
 			if (reg != null) {

File: jadx-core/src/test/java/jadx/tests/internal/arith/TestFieldIncrement.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.arith;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/main/java/jadx/core/utils/Utils.java
Patch:
@@ -16,9 +16,8 @@ public static String cleanObjectName(String obj) {
 		int last = obj.length() - 1;
 		if (obj.charAt(0) == 'L' && obj.charAt(last) == ';') {
 			return obj.substring(1, last).replace('/', '.');
-		} else {
-			return obj;
 		}
+		return obj;
 	}
 
 	public static String makeQualifiedObjectName(String obj) {

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -77,9 +77,10 @@ public boolean addDefinition(CodeWriter code) {
 
 		AccessInfo clsAccFlags = mth.getParentClass().getAccessFlags();
 		AccessInfo ai = mth.getAccessFlags();
-		// don't add 'abstract' to methods in interface
+		// don't add 'abstract' and 'public' to methods in interface
 		if (clsAccFlags.isInterface()) {
 			ai = ai.remove(AccessFlags.ACC_ABSTRACT);
+			ai = ai.remove(AccessFlags.ACC_PUBLIC);
 		}
 		// don't add 'public' for annotations
 		if (clsAccFlags.isAnnotation()) {

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -259,9 +259,9 @@ private void makeTryCatch(IContainer region, TryCatchBlock tryCatchBlock, CodeWr
 		if (allHandler != null) {
 			makeCatchBlock(code, allHandler);
 		}
-		if (tryCatchBlock.getFinalBlock() != null) {
+		if (tryCatchBlock.getFinalRegion() != null) {
 			code.startLine("} finally {");
-			makeRegionIndent(code, tryCatchBlock.getFinalBlock());
+			makeRegionIndent(code, tryCatchBlock.getFinalRegion());
 		}
 		code.startLine('}');
 	}

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -273,7 +273,7 @@ private void initTryCatches(Code mthCode, InsnNode[] insnByOffset) {
 			// each handler must be only in one try/catch block
 			for (TryCatchBlock ct1 : catches) {
 				for (TryCatchBlock ct2 : catches) {
-					if (ct1 != ct2 && ct2.getHandlers().containsAll(ct1.getHandlers())) {
+					if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {
 						for (ExceptionHandler h : ct1.getHandlers()) {
 							ct2.removeHandler(this, h);
 						}

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java
Patch:
@@ -119,8 +119,8 @@ private static void setupConnections(MethodNode mth, Map<Integer, BlockNode> blo
 				List<JumpInfo> jumps = insn.getAll(AType.JUMP);
 				for (JumpInfo jump : jumps) {
 					BlockNode srcBlock = getBlock(jump.getSrc(), blocksMap);
-					BlockNode thisblock = getBlock(jump.getDest(), blocksMap);
-					connect(srcBlock, thisblock);
+					BlockNode thisBlock = getBlock(jump.getDest(), blocksMap);
+					connect(srcBlock, thisBlock);
 				}
 
 				// connect exception handlers

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java
Patch:
@@ -137,7 +137,7 @@ private static void connectHandler(MethodNode mth, ExceptionHandler handler) {
 		for (BlockNode block : mth.getBasicBlocks()) {
 			ExcHandlerAttr bh = block.get(AType.EXC_HANDLER);
 			if (bh != null && bh.getHandler().getHandleOffset() == addr) {
-				handler.setHandleBlock(block);
+				handler.setHandlerBlock(block);
 				break;
 			}
 		}

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -245,7 +245,7 @@ public static BlockNode traverseWhileDominates(BlockNode dom, BlockNode start) {
 		return null;
 	}
 
-	public static BlockNode getPathCrossBlockFor(MethodNode mth, BlockNode b1, BlockNode b2) {
+	public static BlockNode getPathCross(MethodNode mth, BlockNode b1, BlockNode b2) {
 		if (b1 == null || b2 == null) {
 			return null;
 		}

File: jadx-core/src/test/java/jadx/tests/internal/debuginfo/TestLineNumbers2.java
Patch:
@@ -41,7 +41,7 @@ public void test() {
 		System.out.println(code);
 
 		Map<Integer, Integer> lineMapping = codeWriter.getLineMapping();
-		assertEquals("{8=18, 11=22, 13=23, 14=24, 15=28, 17=25, 18=26, 19=28, 22=31, 23=32}",
+		assertEquals("{8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}",
 				lineMapping.toString());
 	}
 }

File: jadx-core/src/test/java/jadx/tests/internal/variables/TestVariablesDefinitions.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.variables;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -86,6 +86,7 @@ public boolean addDefinition(CodeWriter code) {
 			ai = ai.remove(AccessFlags.ACC_PUBLIC);
 		}
 		code.startLine(ai.makeString());
+		code.attachSourceLine(mth.getSourceLine());
 
 		if (classGen.addGenericMap(code, mth.getGenericMap())) {
 			code.add(' ');

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -108,6 +108,7 @@ private void makeIf(IfRegion region, CodeWriter code, boolean newLine) throws Co
 		if (newLine) {
 			code.startLine();
 		}
+		code.attachSourceLine(region.getSourceLine());
 		code.add("if (");
 		new ConditionGen(this).add(code, region.getCondition());
 		code.add(") {");

File: jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java
Patch:
@@ -49,6 +49,7 @@ public ConstructorInsn(MethodNode mth, InvokeNode invoke) {
 			addArg(invoke.getArg(i));
 		}
 		offset = invoke.getOffset();
+		setSourceLine(invoke.getSourceLine());
 	}
 
 	public MethodInfo getCallMth() {

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java
Patch:
@@ -488,6 +488,7 @@ private static InsnNode duplicateReturnInsn(InsnNode returnInsn) {
 		}
 		insn.copyAttributesFrom(returnInsn);
 		insn.setOffset(returnInsn.getOffset());
+		insn.setSourceLine(returnInsn.getSourceLine());
 		return insn;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java
Patch:
@@ -48,6 +48,7 @@ static void makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {
 			RegisterArg resArg = t.getResult().getSVar().getUsedInPhi().getResult();
 			TernaryInsn ternInsn = new TernaryInsn(ifRegion.getCondition(),
 					resArg, InsnArg.wrapArg(t), InsnArg.wrapArg(e));
+			ternInsn.setSourceLine(t.getSourceLine());
 			TernaryRegion tern = new TernaryRegion(ifRegion, header);
 			// TODO: add api for replace regions
 			ifRegion.setTernRegion(tern);
@@ -69,6 +70,7 @@ static void makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {
 			eb.remove(AFlag.RETURN);
 
 			TernaryInsn ternInsn = new TernaryInsn(ifRegion.getCondition(), null, t.getArg(0), e.getArg(0));
+			ternInsn.setSourceLine(t.getSourceLine());
 			InsnNode retInsn = new InsnNode(InsnType.RETURN, 1);
 			retInsn.addArg(InsnArg.wrapArg(ternInsn));
 

File: jadx-core/src/main/java/jadx/core/ProcessClass.java
Patch:
@@ -3,7 +3,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.visitors.DepthTraversal;
 import jadx.core.dex.visitors.IDexTreeVisitor;
-import jadx.core.utils.exceptions.DecodeException;
 
 import java.util.List;
 
@@ -22,8 +21,6 @@ public static void process(ClassNode cls, List<IDexTreeVisitor> passes) {
 			for (IDexTreeVisitor visitor : passes) {
 				DepthTraversal.visit(visitor, cls);
 			}
-		} catch (DecodeException e) {
-			LOG.error("Decode exception: " + cls, e);
 		} catch (Exception e) {
 			LOG.error("Class process exception: " + cls, e);
 		} finally {

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -205,7 +205,7 @@ private void setFieldsTypesFromSignature() {
 	}
 
 	@Override
-	public void load() throws DecodeException {
+	public void load() {
 		for (MethodNode mth : getMethods()) {
 			try {
 				mth.load();

File: jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java
Patch:
@@ -79,7 +79,7 @@ public boolean checkPreCondition() {
 				return false;
 			} else {
 				RegisterArg res = insn.getResult();
-				if (res.getSVar().getUseList().size() > 1) {
+				if (res.getSVar().getUseCount() > 1) {
 					return false;
 				}
 				boolean found = false;

File: jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java
Patch:
@@ -99,11 +99,10 @@ private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode
 		mth.removeFirstArgument();
 		InstructionRemover.remove(mth, block, insn);
 		// other arg usage -> wrap with IGET insn
-		List<RegisterArg> useList = arg.getSVar().getUseList();
-		if (useList.size() > 0) {
+		if (arg.getSVar().getUseCount() != 0) {
 			InsnNode iget = new IndexInsnNode(InsnType.IGET, fieldInfo, 1);
 			iget.addArg(insn.getArg(1));
-			for (InsnArg insnArg : useList) {
+			for (InsnArg insnArg : arg.getSVar().getUseList()) {
 				insnArg.wrapInstruction(iget);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -229,7 +229,7 @@ private static void processExceptionHandler(MethodNode mth, BlockNode block) {
 		if (blockInsns.size() > 0) {
 			InsnNode insn = blockInsns.get(0);
 			if (insn.getType() == InsnType.MOVE_EXCEPTION
-					&& insn.getResult().getSVar().getUseList().isEmpty()) {
+					&& insn.getResult().getSVar().getUseCount() == 0) {
 				InstructionRemover.remove(mth, block, 0);
 			}
 		}
@@ -257,7 +257,7 @@ private static void replaceInsn(BlockNode block, int i, InsnNode insn) {
 	 * In argument not used in other instructions then remove assign instruction.
 	 */
 	private static void removeInsnForArg(InstructionRemover remover, RegisterArg arg) {
-		if (arg.getSVar().getUseList().isEmpty()
+		if (arg.getSVar().getUseCount() == 0
 				&& arg.getAssignInsn() != null) {
 			remover.add(arg.getAssignInsn());
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -40,7 +40,7 @@ public class ProcessTryCatchRegions extends AbstractRegionVisitor {
 	private final Map<BlockNode, TryCatchBlock> tryBlocksMap = new HashMap<BlockNode, TryCatchBlock>(2);
 
 	public ProcessTryCatchRegions(MethodNode mth) {
-		if (mth.isNoCode() || mth.getExceptionHandlers().isEmpty()) {
+		if (mth.isNoCode() || mth.isNoExceptionHandlers()) {
 			return;
 		}
 
@@ -84,7 +84,7 @@ public ProcessTryCatchRegions(MethodNode mth) {
 
 			TryCatchBlock prevTB = tryBlocksMap.put(domBlock, tb);
 			if (prevTB != null) {
-				LOG.info("!!! TODO merge try blocks in " + mth);
+				LOG.info("!!! TODO: merge try blocks in " + mth);
 			}
 		}
 
@@ -134,7 +134,7 @@ private void wrapBlocks(IRegion region, BlockNode dominator) {
 				}
 			}
 		}
-		if (newRegion.getSubBlocks().size() != 0) {
+		if (!newRegion.getSubBlocks().isEmpty()) {
 			if (DEBUG) {
 				LOG.debug("ProcessTryCatchRegions mark: {}", newRegion);
 			}

File: jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java
Patch:
@@ -146,7 +146,7 @@ private void removeUselessPhi(MethodNode mth) {
 		List<PhiInsn> insnToRemove = new ArrayList<PhiInsn>();
 		for (SSAVar var : mth.getSVars()) {
 			// phi result not used
-			if (var.getUseList().isEmpty()) {
+			if (var.getUseCount() == 0) {
 				InsnNode assignInsn = var.getAssign().getParentInsn();
 				if (assignInsn != null && assignInsn.getType() == InsnType.PHI) {
 					insnToRemove.add((PhiInsn) assignInsn);

File: jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java
Patch:
@@ -59,7 +59,7 @@ public static void unbindInsnList(MethodNode mth, List<InsnNode> unbind) {
 	public static void unbindInsn(MethodNode mth, InsnNode insn) {
 		RegisterArg r = insn.getResult();
 		if (r != null && r.getSVar() != null) {
-			if (Consts.DEBUG && !r.getSVar().getUseList().isEmpty()) {
+			if (Consts.DEBUG && r.getSVar().getUseCount() != 0) {
 				LOG.debug("Unbind insn with result: {}", insn);
 			}
 			mth.removeSVar(r.getSVar());

File: jadx-core/src/test/java/jadx/tests/internal/TestVariablesDefinitions.java
Patch:
@@ -4,7 +4,6 @@
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.visitors.DepthTraversal;
 import jadx.core.dex.visitors.IDexTreeVisitor;
-import jadx.core.utils.exceptions.DecodeException;
 
 import java.util.Iterator;
 import java.util.List;
@@ -30,7 +29,7 @@ public void run() {
 				while (iterator.hasNext()) {
 					DepthTraversal.visit(iterator.next(), cls);
 				}
-			} catch (DecodeException e) {
+			} catch (Exception e) {
 				LOG.error("Decode exception: " + cls, e);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java
Patch:
@@ -54,6 +54,9 @@ public static void main(String[] args) throws IOException, DecodeException {
 
 	private static void addFilesFromDirectory(File dir, List<InputFile> inputFiles) throws IOException, DecodeException {
 		File[] files = dir.listFiles();
+		if (files == null) {
+			return;
+		}
 		for (File file : files) {
 			if (file.isDirectory()) {
 				addFilesFromDirectory(file, inputFiles);

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -312,6 +312,7 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, List<InsnNo
 					}
 				}
 			} catch (CodegenException e) {
+				LOG.debug("Error generate fallback instruction: ", e.getCause());
 				code.startLine("// error: " + insn);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java
Patch:
@@ -126,6 +126,9 @@ public boolean isThis() {
 	}
 
 	public InsnNode getAssignInsn() {
+		if (sVar == null) {
+			return null;
+		}
 		RegisterArg assign = sVar.getAssign();
 		if (assign != null) {
 			return assign.getParentInsn();

File: jadx-core/src/main/java/jadx/core/utils/Utils.java
Patch:
@@ -97,7 +97,7 @@ public static String getStackTrace(Throwable throwable) {
 
 	public static void makeDirsForFile(File file) {
 		File dir = file.getParentFile();
-		if (!dir.exists()) {
+		if (dir != null && !dir.exists()) {
 			// if directory already created in other thread mkdirs will return false,
 			// so check dir existence again
 			if (!dir.mkdirs() && !dir.exists()) {

File: jadx-core/src/main/java/jadx/api/Decompiler.java
Patch:
@@ -181,7 +181,6 @@ private void reset() {
 	}
 
 	void processClass(ClassNode cls) {
-		LOG.debug("processing class {} ...", cls);
 		ProcessClass.process(cls, passes);
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -104,7 +104,8 @@ public ClassNode(DexNode dex, ClassDef cls) throws DecodeException {
 			int sfIdx = cls.getSourceFileIndex();
 			if (sfIdx != DexNode.NO_INDEX) {
 				String fileName = dex.getString(sfIdx);
-				if (!this.getFullName().contains(fileName.replace(".java", ""))) {
+				if (!this.getFullName().contains(fileName.replace(".java", ""))
+						&& !fileName.equals("SourceFile")) {
 					this.getAttributes().add(new SourceFileAttr(fileName));
 					LOG.debug("Class '{}' compiled from '{}'", this, fileName);
 				}

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -13,13 +13,13 @@
 import jadx.core.dex.visitors.MethodInlineVisitor;
 import jadx.core.dex.visitors.ModVisitor;
 import jadx.core.dex.visitors.PrepareForCodeGen;
-import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.dex.visitors.SimplifyVisitor;
 import jadx.core.dex.visitors.regions.CheckRegions;
 import jadx.core.dex.visitors.regions.IfRegionVisitor;
 import jadx.core.dex.visitors.regions.ProcessVariables;
 import jadx.core.dex.visitors.regions.RegionMakerVisitor;
 import jadx.core.dex.visitors.ssa.EliminatePhiNodes;
+import jadx.core.dex.visitors.ssa.SSATransform;
 import jadx.core.dex.visitors.typeinference.FinishTypeInference;
 import jadx.core.dex.visitors.typeinference.TypeInference;
 import jadx.core.utils.Utils;

File: jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java
Patch:
@@ -36,6 +36,7 @@ private static void inlineMth(MethodNode mth) {
 			BlockNode block = mth.getBasicBlocks().get(1);
 			InsnNode insn = block.getInstructions().get(0);
 			InsnNode inl = new InsnNode(InsnType.ARGS, 1);
+			// set arg from 'return' instruction
 			inl.addArg(insn.getArg(0));
 			addInlineAttr(mth, inl);
 		} else {

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -200,7 +200,7 @@ public String assignArg(RegisterArg arg) {
 			return name;
 		}
 		name = getUniqVarName(name);
-		arg.getSVar().setName(name);
+		arg.getSVar().setVariableName(name);
 		return name;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -118,6 +118,7 @@ public void load() throws DecodeException {
 				noCode = true;
 				// load without code
 				load();
+				noCode = false;
 			}
 			throw new DecodeException(this, "Load method exception", e);
 		}
@@ -141,7 +142,6 @@ public void unload() {
 		blocks = null;
 		exitBlocks = null;
 		exceptionHandlers.clear();
-		noCode = true;
 	}
 
 	private boolean parseSignature() {

File: jadx-gui/src/main/java/jadx/gui/JadxWrapper.java
Patch:
@@ -43,6 +43,7 @@ public void run() {
 				try {
 					decompiler.setOutputDir(dir);
 					ThreadPoolExecutor ex = decompiler.getSaveExecutor();
+					ex.shutdown();
 					while (ex.isTerminating()) {
 						long total = ex.getTaskCount();
 						long done = ex.getCompletedTaskCount();

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -45,8 +45,8 @@ public synchronized void load() {
 		if (!loaded) {
 			cls.decompile();
 			loaded = true;
-			update();
 		}
+		update();
 	}
 
 	public synchronized void update() {

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -15,9 +15,9 @@
 import jadx.core.dex.visitors.PrepareForCodeGen;
 import jadx.core.dex.visitors.SimplifyVisitor;
 import jadx.core.dex.visitors.regions.CheckRegions;
+import jadx.core.dex.visitors.regions.IfRegionVisitor;
 import jadx.core.dex.visitors.regions.ProcessVariables;
 import jadx.core.dex.visitors.regions.RegionMakerVisitor;
-import jadx.core.dex.visitors.regions.TernaryVisitor;
 import jadx.core.dex.visitors.typeresolver.FinishTypeResolver;
 import jadx.core.dex.visitors.typeresolver.TypeResolver;
 import jadx.core.utils.Utils;
@@ -70,7 +70,7 @@ public static List<IDexTreeVisitor> getPassesList(IJadxArgs args, File outDir) {
 
 			passes.add(new CodeShrinker());
 			passes.add(new RegionMakerVisitor());
-			passes.add(new TernaryVisitor());
+			passes.add(new IfRegionVisitor());
 
 			passes.add(new CodeShrinker());
 			passes.add(new SimplifyVisitor());

File: jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java
Patch:
@@ -8,4 +8,5 @@ public interface IRegion extends IContainer {
 
 	List<IContainer> getSubBlocks();
 
+	boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock);
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java
Patch:
@@ -22,7 +22,8 @@ public void visit(MethodNode mth) throws JadxException {
 				&& accessFlags.isStatic()
 				&& mth.getBasicBlocks().size() == 2) {
 			BlockNode block = mth.getBasicBlocks().get(1);
-			if (block.getAttributes().contains(AttributeFlag.RETURN)) {
+			if (block.getInstructions().isEmpty()
+					|| block.getAttributes().contains(AttributeFlag.RETURN)) {
 				inlineMth(mth);
 			}
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -38,7 +38,7 @@ public void processBlock(MethodNode mth, IBlock container) {
 				}
 			}
 		};
-		DepthRegionTraverser.traverseAll(mth, collectBlocks);
+		DepthRegionTraversal.traverseAll(mth, collectBlocks);
 
 		if (mth.getBasicBlocks().size() != blocksInRegions.size()) {
 			for (BlockNode block : mth.getBasicBlocks()) {
@@ -65,6 +65,6 @@ public void enterRegion(MethodNode mth, IRegion region) {
 				}
 			}
 		};
-		DepthRegionTraverser.traverseAll(mth, checkLoops);
+		DepthRegionTraversal.traverseAll(mth, checkLoops);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java
Patch:
@@ -44,6 +44,6 @@ public void enterRegion(MethodNode mth, IRegion region) {
 				}
 			}
 		};
-		DepthRegionTraverser.traverseAll(mth, removeEmptyBlocks);
+		DepthRegionTraversal.traverseAll(mth, removeEmptyBlocks);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessReturnInsns.java
Patch:
@@ -32,6 +32,7 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion current
 					&& blockNotInLoop(mth, block)
 					&& noTrailInstructions(block)) {
 				insns.remove(insns.size() - 1);
+				block.getAttributes().remove(AttributeFlag.RETURN);
 			}
 		}
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -104,7 +104,7 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi
 				}
 			}
 		};
-		DepthRegionTraverser.traverseAll(mth, collect);
+		DepthRegionTraversal.traverseAll(mth, collect);
 
 		// reduce assigns map
 		List<RegisterArg> mthArgs = mth.getArguments(true);

File: jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions.java
Patch:
@@ -12,7 +12,7 @@
 public class TestConditions extends InternalJadxTest {
 
 	public static class TestCls {
-		private boolean f1(boolean a, boolean b, boolean c) {
+		private boolean test(boolean a, boolean b, boolean c) {
 			return (a && b) || c;
 		}
 	}
@@ -24,7 +24,6 @@ public void test() {
 		System.out.println(code);
 
 		assertThat(code, not(containsString("(!a || !b) && !c")));
-		assertThat(code, containsString("(a && b) || c"));
-//		assertThat(code, containsString("return (a && b) || c;"));
+		assertThat(code, containsString("return (a && b) || c;"));
 	}
 }

File: jadx-samples/src/main/java/jadx/samples/TestConditions.java
Patch:
@@ -1,8 +1,5 @@
 package jadx.samples;
 
-/**
- * Failed tests for current jadx version
- */
 public class TestConditions extends AbstractTest {
 
 	public int test1(int num) {

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java
Patch:
@@ -9,7 +9,6 @@ public enum AttributeFlag {
 
 	SYNTHETIC,
 
-	BREAK,
 	RETURN, // block contains only return instruction
 
 	DECLARE_VAR,

File: jadx-core/src/test/java/jadx/tests/internal/TestSynchronized.java
Patch:
@@ -38,6 +38,6 @@ public void test() {
 		assertThat(code, containsString("return this.f"));
 		assertThat(code, containsString("synchronized (this.o) {"));
 
-		assertThat(code, not(containsString(makeIndent(3) + ";")));
+		assertThat(code, not(containsString(indent(3) + ";")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/internal/TestVariablesDefinitions.java
Patch:
@@ -43,7 +43,7 @@ public void test() {
 		System.out.println(code);
 
 		// 'iterator' variable must be declared inside 'try' block
-		assertThat(code, containsString(makeIndent(3) + "Iterator<IDexTreeVisitor> iterator = "));
+		assertThat(code, containsString(indent(3) + "Iterator<IDexTreeVisitor> iterator = "));
 		assertThat(code, not(containsString("iterator;")));
 	}
 }

File: jadx-core/src/test/java/jadx/tests/internal/inner/TestAnonymousClass3.java
Patch:
@@ -44,8 +44,8 @@ public void test() {
 		String code = cls.getCode().toString();
 		System.out.println(code);
 
-		assertThat(code, containsString(makeIndent(4) + "public void run() {"));
-		assertThat(code, containsString(makeIndent(3) + "}.start();"));
+		assertThat(code, containsString(indent(4) + "public void run() {"));
+		assertThat(code, containsString(indent(3) + "}.start();"));
 
 //		assertThat(code, not(containsString("synthetic")));
 //		assertThat(code, not(containsString("AnonymousClass_")));

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -60,7 +60,7 @@ public Set<IRegion> getUseRegions() {
 
 		@Override
 		public String toString() {
-			return arg + " " + assigns + " " + usage;
+			return arg + ", a:" + assigns + ", u:" + usage;
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -374,7 +374,7 @@ public boolean isPrimitive() {
 	}
 
 	public String getObject() {
-		throw new UnsupportedOperationException("ArgType.getObject()");
+		throw new UnsupportedOperationException("ArgType.getObject(), call class: " + this.getClass());
 	}
 
 	public boolean isObject() {

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java
Patch:
@@ -23,9 +23,9 @@ public class SignatureParser {
 
 	public SignatureParser(String signature) {
 		sign = signature;
+		end = sign.length();
 		pos = -1;
 		mark = 0;
-		end = sign.length();
 	}
 
 	@SuppressWarnings("unchecked")

File: jadx-core/src/test/java/jadx/api/InternalJadxTest.java
Patch:
@@ -71,6 +71,7 @@ public boolean isRawCFGOutput() {
 			assertFalse(cls.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE));
 			return cls;
 		} catch (Exception e) {
+			e.printStackTrace();
 			fail(e.getMessage());
 			return null;
 		}

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -72,7 +72,7 @@ private void splitNames(boolean canBeInner) {
 
 		int sep = clsName.lastIndexOf('$');
 		if (canBeInner && sep > 0 && sep != clsName.length() - 1) {
-			String parClsName = pkg + '.' + clsName.substring(0, sep);
+			String parClsName = pkg + "." + clsName.substring(0, sep);
 			parentClass = fromName(parClsName);
 			clsName = clsName.substring(sep + 1);
 		} else {

File: jadx-core/src/main/java/jadx/core/utils/Utils.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.Iterator;
 
 public class Utils {
-	
+
 	private Utils() {
 	}
 

File: jadx-core/src/test/java/jadx/core/dex/nodes/parser/TestSignatureParser.java
Patch:
@@ -50,7 +50,7 @@ public void testGenericInnerType() {
 						"c", new ArgType[]{ArgType.genericType("V")}));
 
 		assertEquals(p("La<TV;>.LinkedHashIterator<Lb$c<Ls;TV;>;>;").consumeType().getObject(),
-				"a.LinkedHashIterator");
+				"a$LinkedHashIterator");
 
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -81,8 +81,7 @@ private static boolean isWrapNeeded(InsnArg arg) {
 		}
 		InsnNode insn = ((InsnWrapArg) arg).getWrapInsn();
 		if (insn.getType() == InsnType.ARITH) {
-			ArithNode arith = ((ArithNode) insn);
-			switch (arith.getOp()) {
+			switch (((ArithNode) insn).getOp()) {
 				case ADD:
 				case SUB:
 				case MUL:

File: jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java
Patch:
@@ -15,12 +15,12 @@ public enum ArithOp {
 	SHR(">>"),
 	USHR(">>>");
 
+	private final String symbol;
+
 	private ArithOp(String symbol) {
 		this.symbol = symbol;
 	}
 
-	private final String symbol;
-
 	public String getSymbol() {
 		return this.symbol;
 	}

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java
Patch:
@@ -7,8 +7,8 @@ public final class InsnWrapArg extends InsnArg {
 	private final InsnNode wrappedInsn;
 
 	public InsnWrapArg(InsnNode insn) {
-		ArgType type = (insn.getResult() == null ? ArgType.VOID : insn.getResult().getType());
-		this.typedVar = new TypedVar(type);
+		RegisterArg result = insn.getResult();
+		this.typedVar = new TypedVar((result != null ? result.getType() : ArgType.VOID));
 		this.wrappedInsn = insn;
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java
Patch:
@@ -87,7 +87,7 @@ private static List<BlockNode> cleanSuccessors(BlockNode block) {
 				}
 			}
 		}
-		return (nodes.size() == sucList.size() ? sucList : nodes);
+		return nodes.size() == sucList.size() ? sucList : nodes;
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -50,7 +50,7 @@ public class ClassNode extends LineAttrNode implements ILoadable {
 	private Map<Object, FieldNode> constFields = Collections.emptyMap();
 	private List<ClassNode> innerClasses = Collections.emptyList();
 
-	private CodeWriter code; // generated code
+	private CodeWriter code;
 
 	public ClassNode(DexNode dex, ClassDef cls) throws DecodeException {
 		this.dex = dex;

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java
Patch:
@@ -21,7 +21,7 @@ public class CheckRegions extends AbstractVisitor {
 
 	@Override
 	public void visit(MethodNode mth) throws JadxException {
-		if (mth.isNoCode() || mth.getBasicBlocks().size() == 0) {
+		if (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {
 			return;
 		}
 

File: jadx-core/src/main/java/jadx/core/utils/BlockUtils.java
Patch:
@@ -15,6 +15,9 @@
 
 public class BlockUtils {
 
+	private BlockUtils() {
+	}
+
 	public static BlockNode getBlockByOffset(int offset, Iterable<BlockNode> casesBlocks) {
 		for (BlockNode block : casesBlocks) {
 			if (block.getStartOffset() == offset) {

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -7,6 +7,9 @@
 
 public class InsnUtils {
 
+	private InsnUtils() {
+	}
+
 	public static int getArg(DecodedInstruction insn, int arg) {
 		switch (arg) {
 			case 0:

File: jadx-core/src/main/java/jadx/core/utils/RegionUtils.java
Patch:
@@ -14,6 +14,9 @@
 
 public class RegionUtils {
 
+	private RegionUtils() {
+	}
+
 	public static boolean hasExitEdge(IContainer container) {
 		if (container instanceof BlockNode) {
 			BlockNode block = (BlockNode) container;

File: jadx-core/src/main/java/jadx/core/utils/StringUtils.java
Patch:
@@ -2,6 +2,9 @@
 
 public class StringUtils {
 
+	private StringUtils() {
+	}
+
 	public static String unescapeString(String str) {
 		int len = str.length();
 		StringBuilder res = new StringBuilder();

File: jadx-core/src/main/java/jadx/core/utils/Utils.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Iterator;
 
 public class Utils {
+	
 	private Utils() {
 	}
 

File: jadx-core/src/test/java/jadx/tests/internal/TestLineNumbers.java
Patch:
@@ -15,7 +15,7 @@
 
 public class TestLineNumbers extends InternalJadxTest {
 
-	public static class TestCls extends Exception {
+	public static class TestCls {
 		int field;
 
 		public void func() {

File: jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions2.java
Patch:
@@ -11,7 +11,7 @@
 
 public class TestConditions2 extends InternalJadxTest {
 
-	public static class TestCls extends Exception {
+	public static class TestCls {
 		int c;
 		String d;
 		String f;

File: jadx-core/src/test/java/jadx/tests/internal/inline/TestInline.java
Patch:
@@ -10,7 +10,7 @@
 
 public class TestInline extends InternalJadxTest {
 
-	public static class TestCls extends Exception {
+	public static class TestCls {
 		public static void main(String[] args) throws Exception {
 			System.out.println("Test: " + new TestCls().testRun());
 		}

File: jadx-core/src/test/java/jadx/tests/internal/inline/TestInline2.java
Patch:
@@ -10,7 +10,7 @@
 
 public class TestInline2 extends InternalJadxTest {
 
-	public static class TestCls extends Exception {
+	public static class TestCls {
 		public int simple_loops() throws InterruptedException {
 			int[] a = new int[]{1, 2, 4, 6, 8};
 			int b = 0;

File: jadx-core/src/test/java/jadx/tests/internal/inline/TestInline6.java
Patch:
@@ -24,7 +24,6 @@ public void test(int a, int b) {
 
 	@Test
 	public void test() {
-		setOutputCFG();
 		ClassNode cls = getClassNode(TestCls.class);
 		String code = cls.getCode().toString();
 		System.out.println(code);

File: jadx-gui/src/main/java/jadx/gui/treemodel/TextNode.java
Patch:
@@ -3,6 +3,9 @@
 import javax.swing.Icon;
 
 public class TextNode extends JNode {
+
+	private static final long serialVersionUID = 2342749142368352232L;
+
 	private final String label;
 
 	public TextNode(String str) {

File: jadx-core/src/main/java/jadx/core/codegen/ClassGen.java
Patch:
@@ -463,7 +463,7 @@ private void insertSourceFileInfo(CodeWriter code, AttrNode node) {
 	}
 
 	public ClassGen getParentGen() {
-		return parentGen;
+		return parentGen == null ? this : parentGen;
 	}
 
 	public AnnotationGen getAnnotationGen() {

File: jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopCondition.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.loops;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -165,7 +165,7 @@ private String insertInsns(MethodNode mth, BlockNode block) {
 			return str.toString();
 		} else {
 			CodeWriter code = new CodeWriter(0);
-			MethodGen.makeFallbackInsns(code, mth, block.getInstructions(), false);
+			MethodGen.addFallbackInsns(code, mth, block.getInstructions(), false);
 			String str = escape(code.newLine().toString());
 			if (str.startsWith(NL)) {
 				str = str.substring(NL.length());

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java
Patch:
@@ -19,6 +19,7 @@ public enum AttributeType {
 
 	JADX_ERROR(true),
 	METHOD_INLINE(true),
+	FIELD_REPLACE(true),
 
 	ENUM_CLASS(true),
 

File: jadx-core/src/test/java/jadx/tests/internal/inner/TestAnonymousClass.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.inner;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/test/java/jadx/tests/internal/inner/TestInnerClass.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.inner;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/test/java/jadx/tests/internal/inner/TestInnerClass2.java
Patch:
@@ -1,4 +1,4 @@
-package jadx.tests.internal;
+package jadx.tests.internal.inner;
 
 import jadx.api.InternalJadxTest;
 import jadx.core.dex.nodes.ClassNode;

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -71,6 +71,7 @@ public static List<IDexTreeVisitor> getPassesList(IJadxArgs args, File outDir) {
 			passes.add(new RegionMakerVisitor());
 			passes.add(new TernaryVisitor());
 
+			passes.add(new CodeShrinker());
 			passes.add(new SimplifyVisitor());
 			passes.add(new ProcessVariables());
 			passes.add(new CheckRegions());

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -184,7 +184,7 @@ private CodeWriter makeLoop(LoopRegion region, CodeWriter code) throws CodegenEx
 
 	private void makeSynchronizedRegion(SynchronizedRegion cont, CodeWriter code) throws CodegenException {
 		code.startLine("synchronized (");
-		addArg(code, cont.getInsn().getArg(0));
+		addArg(code, cont.getEnterInsn().getArg(0));
 		code.add(") {");
 		makeRegionIndent(code, cont.getRegion());
 		code.startLine('}');

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java
Patch:
@@ -69,6 +69,9 @@ public void setParentInsn(InsnNode parentInsn) {
 
 	public InsnArg wrapInstruction(InsnNode insn) {
 		InsnNode parent = parentInsn;
+		if (parent == null) {
+			return null;
+		}
 		assert parent != insn : "Can't wrap instruction info itself";
 		int count = parent.getArgsCount();
 		for (int i = 0; i < count; i++) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java
Patch:
@@ -102,7 +102,7 @@ private boolean canMove(int from, int to) {
 			if (from > to) {
 				throw new JadxRuntimeException("Invalid inline insn positions: " + from + " - " + to);
 			}
-			for (int i = from; i < to - 1; i++) {
+			for (int i = from; i < to; i++) {
 				ArgsInfo argsInfo = argsList.get(i);
 				if (argsInfo.getInlinedInsn() == this) {
 					continue;

File: jadx-core/src/main/java/jadx/core/Jadx.java
Patch:
@@ -10,7 +10,7 @@
 import jadx.core.dex.visitors.EnumVisitor;
 import jadx.core.dex.visitors.FallbackModeVisitor;
 import jadx.core.dex.visitors.IDexTreeVisitor;
-import jadx.core.dex.visitors.MethodInlinerVisitor;
+import jadx.core.dex.visitors.MethodInlineVisitor;
 import jadx.core.dex.visitors.ModVisitor;
 import jadx.core.dex.visitors.SimplifyVisitor;
 import jadx.core.dex.visitors.regions.CheckRegions;
@@ -79,7 +79,7 @@ public static List<IDexTreeVisitor> getPassesList(IJadxArgs args, File outDir) {
 				passes.add(new DotGraphVisitor(outDir, true));
 			}
 
-			passes.add(new MethodInlinerVisitor());
+			passes.add(new MethodInlineVisitor());
 			passes.add(new ClassModifier());
 		}
 		passes.add(new CodeGen(args));

File: jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java
Patch:
@@ -76,7 +76,7 @@ private CodeWriter formatAnnotation(Annotation a) {
 		code.add('@');
 		code.add(classGen.useClass(a.getType()));
 		Map<String, Object> vl = a.getValues();
-		if (vl.size() != 0) {
+		if (!vl.isEmpty()) {
 			code.add('(');
 			if (vl.size() == 1 && vl.containsKey("value")) {
 				code.add(encValueToString(vl.get("value")));

File: jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java
Patch:
@@ -82,7 +82,7 @@ public CodeWriter add(CodeWriter code) {
 			attachAnnotation(entry.getKey(), line + entry.getValue());
 		}
 		line += code.line;
-		buf.append(code.toString());
+		buf.append(code);
 		return this;
 	}
 
@@ -116,7 +116,7 @@ public CodeWriter indent() {
 		return this;
 	}
 
-	private static final String[] INDENT_CACHE = new String[]{
+	private static final String[] INDENT_CACHE = {
 			"",
 			INDENT,
 			INDENT + INDENT,

File: jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java
Patch:
@@ -42,7 +42,7 @@ static String make(InsnGen insnGen, IfCondition condition) throws CodegenExcepti
 				}
 				return sb.toString();
 			default:
-				return "??" + condition.toString();
+				return "??" + condition;
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -105,7 +105,8 @@ public boolean addDefinition(CodeWriter code) {
 			} else {
 				LOG.warn(ErrorsCounter.formatErrorMsg(mth,
 						"Incorrect number of args for enum constructor: " + args.size()
-								+ " (expected >= 2)"));
+								+ " (expected >= 2)"
+				));
 			}
 		}
 		code.add(makeArguments(args));
@@ -269,7 +270,7 @@ public void makeMethodDump(CodeWriter code) {
 		code.startLine("*/");
 	}
 
-	private void makeFallbackMethod(CodeWriter code, MethodNode mth) {
+	private static void makeFallbackMethod(CodeWriter code, MethodNode mth) {
 		if (mth.getInstructions() == null) {
 			// loadFile original instructions
 			try {

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -61,7 +61,8 @@ public class NameMapper {
 					"void",
 					"volatile",
 					"while",
-			}));
+			})
+	);
 
 	public static boolean isReserved(String str) {
 		return RESERVED_NAMES.contains(str);

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java
Patch:
@@ -12,6 +12,8 @@ public enum AttributeFlag {
 	BREAK,
 	RETURN, // block contains only return instruction
 
+	DECLARE_VAR,
+
 	DONT_SHRINK,
 	DONT_GENERATE,
 	SKIP,

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java
Patch:
@@ -27,7 +27,8 @@ public enum AttributeType {
 
 	SOURCE_FILE(true),
 
-	DECLARE_VARIABLE(true);
+	// for regions
+	DECLARE_VARIABLES(true);
 
 	private static final int NOT_UNIQ_COUNT;
 	private final boolean uniq;

File: jadx-core/src/main/java/jadx/core/dex/attributes/BlockRegState.java
Patch:
@@ -48,7 +48,7 @@ public String toString() {
 				if (str.length() != 0) {
 					str.append(", ");
 				}
-				str.append(reg.toString());
+				str.append(reg);
 			}
 		}
 		return str.toString();

File: jadx-core/src/main/java/jadx/core/dex/attributes/JadxErrorAttr.java
Patch:
@@ -26,7 +26,7 @@ public String toString() {
 		if (cause == null) {
 			str.append("null");
 		} else {
-			str.append(cause.getClass().toString());
+			str.append(cause.getClass());
 			str.append(":");
 			str.append(cause.getMessage());
 			str.append("\n");

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java
Patch:
@@ -229,7 +229,7 @@ boolean internalEquals(Object obj) {
 
 		@Override
 		public String toString() {
-			return arrayElement.toString() + "[]";
+			return arrayElement + "[]";
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/TypedVar.java
Patch:
@@ -51,9 +51,9 @@ public void setName(String name) {
 	}
 
 	public void mergeName(TypedVar arg) {
-		String name = arg.getName();
-		if (name != null) {
-			setName(name);
+		String argName = arg.getName();
+		if (argName != null) {
+			setName(argName);
 		} else if (getName() != null) {
 			arg.setName(getName());
 		}

File: jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java
Patch:
@@ -124,7 +124,7 @@ private void loadAnnotations(ClassDef cls) {
 		int offset = cls.getAnnotationsOffset();
 		if (offset != 0) {
 			try {
-				new AnnotationsParser(this, offset);
+				new AnnotationsParser(this).parse(offset);
 			} catch (DecodeException e) {
 				LOG.error("Error parsing annotations in " + this, e);
 			}

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -47,7 +47,7 @@ public void load(List<InputFile> dexFiles) throws DecodeException {
 		initInnerClasses(classes);
 	}
 
-	private void initClassPath(List<ClassNode> classes) throws IOException, DecodeException {
+	private static void initClassPath(List<ClassNode> classes) throws IOException, DecodeException {
 		ClspGraph clsp = new ClspGraph();
 		clsp.load();
 		clsp.addApp(classes);

File: jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java
Patch:
@@ -15,9 +15,9 @@ public final class LoopRegion extends AbstractRegion {
 
 	// loop header contains one 'if' insn, equals null for infinite loop
 	private IfCondition condition;
-	private BlockNode conditionBlock;
+	private final BlockNode conditionBlock;
 	// instruction which must be executed before condition in every loop
-	private BlockNode preCondition = null;
+	private BlockNode preCondition;
 	private IContainer body;
 	private final boolean conditionAtEnd;
 

File: jadx-core/src/main/java/jadx/core/dex/regions/TernaryRegion.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.List;
 
 public final class TernaryRegion extends AbstractRegion {
-	private IBlock container;
+	private final IBlock container;
 
 	public TernaryRegion(IRegion parent, BlockNode block) {
 		super(parent);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java
Patch:
@@ -69,11 +69,11 @@ public ProcessTryCatchRegions(MethodNode mth) {
 			assert bs != null;
 
 			// intersect to get dominator of dominators
-			List<BlockNode> domBlocks = BlockUtils.bitsetToBlocks(mth, bs);
+			List<BlockNode> domBlocks = BlockUtils.bitSetToBlocks(mth, bs);
 			for (BlockNode block : domBlocks) {
 				bs.andNot(block.getDoms());
 			}
-			domBlocks = BlockUtils.bitsetToBlocks(mth, bs);
+			domBlocks = BlockUtils.bitSetToBlocks(mth, bs);
 			if (domBlocks.size() != 1) {
 				throw new JadxRuntimeException(
 						"Exception block dominator not found, method:" + mth + ". bs: " + bs);

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/TracedRegionVisitor.java
Patch:
@@ -18,7 +18,7 @@ public void enterRegion(MethodNode mth, IRegion region) {
 
 	@Override
 	public void processBlock(MethodNode mth, IBlock container) {
-		final IRegion curRegion = regionStack.peek();
+		IRegion curRegion = regionStack.peek();
 		processBlockTraced(mth, container, curRegion);
 	}
 

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -16,7 +16,7 @@ public class ErrorsCounter {
 	private static final Logger LOG = LoggerFactory.getLogger(ErrorsCounter.class);
 
 	private static final Set<Object> ERROR_NODES = new HashSet<Object>();
-	private static int errorsCount = 0;
+	private static int errorsCount;
 
 	public static int getErrorCount() {
 		return errorsCount;

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -46,7 +46,7 @@ public static String indexToString(Object index) {
 		if (index instanceof String) {
 			return "\"" + index + "\"";
 		} else {
-			return " " + index.toString();
+			return " " + index;
 		}
 	}
 }

File: jadx-core/src/test/java/jadx/api/InternalJadxTest.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.api;
 
 import jadx.core.Jadx;
+import jadx.core.dex.attributes.AttributeFlag;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.MethodNode;
 import jadx.core.dex.visitors.DepthTraverser;
@@ -19,6 +20,7 @@
 import java.util.jar.JarOutputStream;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.fail;
 
@@ -65,6 +67,7 @@ public boolean isRawCFGOutput() {
 			for (IDexTreeVisitor visitor : passes) {
 				DepthTraverser.visit(visitor, cls);
 			}
+			assertFalse(cls.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE));
 			return cls;
 		} catch (Exception e) {
 			fail(e.getMessage());

File: jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java
Patch:
@@ -16,7 +16,5 @@ public JClass getRootClass() {
 
 	public abstract int getLine();
 
-	public abstract void updateChilds();
-
 	public abstract Icon getIcon();
 }

File: jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java
Patch:
@@ -473,7 +473,7 @@ private InsnNode decode(DecodedInstruction insn, int offset) throws DecodeExcept
 			case Opcodes.ARRAY_LENGTH: {
 				InsnNode node = new InsnNode(InsnType.ARRAY_LENGTH, 1);
 				node.setResult(InsnArg.reg(insn, 0, ArgType.INT));
-				node.addArg(InsnArg.reg(insn, 1, ArgType.unknown(PrimitiveType.ARRAY)));
+				node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));
 				return node;
 			}
 

File: jadx-core/src/main/java/jadx/core/Consts.java
Patch:
@@ -21,4 +21,6 @@ public class Consts {
 
 	public static final String DEFAULT_PACKAGE_NAME = "defpackage";
 	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";
+
+	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java
Patch:
@@ -516,8 +516,8 @@ public boolean equals(Object obj) {
 
 	@Override
 	public String toString() {
-		return retType
-				+ " " + parentClass.getFullName() + "." + mthInfo.getName()
-				+ "(" + Utils.listToString(mthInfo.getArgumentsTypes()) + ")";
+		return parentClass.getFullName() + "." + mthInfo.getName()
+				+ "(" + Utils.listToString(mthInfo.getArgumentsTypes()) + "):"
+				+ retType;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java
Patch:
@@ -109,7 +109,7 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {
 			case INVOKE:
 				MethodInfo callMth = ((InvokeNode) insn).getCallMth();
 				if (callMth.getDeclClass().getFullName().equals(Consts.CLASS_STRING_BUILDER)
-						&& callMth.getShortId().equals("toString()")
+						&& callMth.getShortId().equals(Consts.MTH_TOSTRING_SIGNATURE)
 						&& insn.getArg(0).isInsnWrap()) {
 					try {
 						List<InsnNode> chain = flattenInsnChain(insn);

File: jadx-core/src/test/java/jadx/tests/internal/TestAnnotations.java
Patch:
@@ -57,5 +57,8 @@ public void test() {
 		assertThat(code, containsString("@A(a = -11253)"));
 		assertThat(code, containsString("@V(false)"));
 		assertThat(code, not(containsString("@D()")));
+
+		assertThat(code, containsString("int a();"));
+		assertThat(code, containsString("float value() default 1.1f;"));
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeresolver/TypeResolver.java
Patch:
@@ -67,8 +67,7 @@ private void visitBlocks(MethodNode mth) {
 					state.assignReg(insn.getResult());
 			}
 
-			if (block.getSuccessors().size() > 0)
-				block.setEndState(new BlockRegState(state));
+			block.setEndState(new BlockRegState(state));
 		}
 	}
 

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -2,6 +2,7 @@
 
 import jadx.api.Decompiler;
 import jadx.core.utils.ErrorsCounter;
+import jadx.core.utils.exceptions.JadxException;
 
 import java.io.File;
 
@@ -39,7 +40,7 @@ private static void processAndSave(JadxCLIArgs jadxArgs) {
 		System.exit(errorsCount);
 	}
 
-	private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {
+	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {
 		if (jadxArgs.getInput().isEmpty()) {
 			LOG.error("Please specify input file");
 			jadxArgs.printUsage();
@@ -61,7 +62,7 @@ private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {
 			jadxArgs.setOutputDir(outputDir);
 		}
 		if (outputDir.exists() && !outputDir.isDirectory()) {
-			throw new Exception("Output directory exists as file " + outputDir);
+			throw new JadxException("Output directory exists as file " + outputDir);
 		}
 	}
 }

File: jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java
Patch:
@@ -19,7 +19,7 @@ public class CodeWriter {
 	public static final String NL = System.getProperty("line.separator");
 	private static final String INDENT = "\t";
 
-	private StringBuilder buf = new StringBuilder();
+	private final StringBuilder buf = new StringBuilder();
 	private String indentStr;
 	private int indent;
 

File: jadx-core/src/main/java/jadx/core/codegen/MethodGen.java
Patch:
@@ -287,9 +287,9 @@ public static void makeFallbackInsns(CodeWriter code, MethodNode mth, List<InsnN
 			}
 			try {
 				if (insnGen.makeInsn(insn, code)) {
-					CatchAttr _catch = (CatchAttr) attrs.get(AttributeType.CATCH_BLOCK);
-					if (_catch != null)
-						code.add("\t //" + _catch);
+					CatchAttr catchAttr = (CatchAttr) attrs.get(AttributeType.CATCH_BLOCK);
+					if (catchAttr != null)
+						code.add("\t //" + catchAttr);
 				}
 			} catch (CodegenException e) {
 				code.startLine("// error: " + insn);

File: jadx-core/src/main/java/jadx/core/deobf/NameMapper.java
Patch:
@@ -6,7 +6,7 @@
 
 public class NameMapper {
 
-	private static final Set<String> reservedNames = new HashSet<String>(
+	private static final Set<String> RESERVED_NAMES = new HashSet<String>(
 			Arrays.asList(new String[]{
 					"abstract",
 					"assert",
@@ -64,7 +64,7 @@ public class NameMapper {
 			}));
 
 	public static boolean isReserved(String str) {
-		return reservedNames.contains(str);
+		return RESERVED_NAMES.contains(str);
 	}
 
 }

File: jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java
Patch:
@@ -29,7 +29,7 @@ public enum AttributeType {
 
 	DECLARE_VARIABLE(true);
 
-	private static final int notUniqCount;
+	private static final int NOT_UNIQ_COUNT;
 	private final boolean uniq;
 
 	static {
@@ -41,11 +41,11 @@ public enum AttributeType {
 			if (type.notUniq())
 				last = i;
 		}
-		notUniqCount = last + 1;
+		NOT_UNIQ_COUNT = last + 1;
 	}
 
 	public static int getNotUniqCount() {
-		return notUniqCount;
+		return NOT_UNIQ_COUNT;
 	}
 
 	private AttributeType(boolean isUniq) {

File: jadx-core/src/main/java/jadx/core/dex/nodes/IBlock.java
Patch:
@@ -4,5 +4,5 @@
 
 public interface IBlock extends IContainer {
 
-	public List<InsnNode> getInstructions();
+	List<InsnNode> getInstructions();
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/ILoadable.java
Patch:
@@ -9,11 +9,11 @@ public interface ILoadable {
 	 *
 	 * @throws DecodeException
 	 */
-	public void load() throws DecodeException;
+	void load() throws DecodeException;
 
 	/**
 	 * Free resources
 	 */
-	public void unload();
+	void unload();
 
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java
Patch:
@@ -4,8 +4,8 @@
 
 public interface IRegion extends IContainer {
 
-	public IRegion getParent();
+	IRegion getParent();
 
-	public List<IContainer> getSubBlocks();
+	List<IContainer> getSubBlocks();
 
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -15,7 +15,6 @@
 public class RootNode {
 	private final Map<String, ClassNode> names = new HashMap<String, ClassNode>();
 	private List<DexNode> dexNodes;
-	private ClspGraph clsp;
 
 	public void load(List<InputFile> dexFiles) throws DecodeException {
 		dexNodes = new ArrayList<DexNode>(dexFiles.size());
@@ -49,7 +48,7 @@ public void load(List<InputFile> dexFiles) throws DecodeException {
 	}
 
 	private void initClassPath(List<ClassNode> classes) throws IOException, DecodeException {
-		clsp = new ClspGraph();
+		ClspGraph clsp = new ClspGraph();
 		clsp.load();
 		clsp.addApp(classes);
 

File: jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java
Patch:
@@ -4,6 +4,7 @@
 import jadx.core.dex.instructions.IfOp;
 import jadx.core.dex.instructions.args.InsnArg;
 import jadx.core.dex.nodes.BlockNode;
+import jadx.core.utils.exceptions.JadxRuntimeException;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -131,7 +132,7 @@ public IfCondition invert() {
 				}
 				return new IfCondition(mode == Mode.AND ? Mode.OR : Mode.AND, newArgs);
 		}
-		throw new RuntimeException("Unknown mode for invert: " + mode);
+		throw new JadxRuntimeException("Unknown mode for invert: " + mode);
 	}
 
 	@Override

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/IRegionVisitor.java
Patch:
@@ -6,10 +6,10 @@
 
 public interface IRegionVisitor {
 
-	public void processBlock(MethodNode mth, IBlock container);
+	void processBlock(MethodNode mth, IBlock container);
 
-	public void enterRegion(MethodNode mth, IRegion region);
+	void enterRegion(MethodNode mth, IRegion region);
 
-	public void leaveRegion(MethodNode mth, IRegion region);
+	void leaveRegion(MethodNode mth, IRegion region);
 
 }

File: jadx-core/src/main/java/jadx/core/utils/InsnUtils.java
Patch:
@@ -1,6 +1,7 @@
 package jadx.core.utils;
 
 import jadx.core.dex.instructions.InsnType;
+import jadx.core.utils.exceptions.JadxRuntimeException;
 
 import com.android.dx.io.instructions.DecodedInstruction;
 
@@ -19,7 +20,7 @@ public static int getArg(DecodedInstruction insn, int arg) {
 			case 4:
 				return insn.getE();
 		}
-		throw new RuntimeException("Wrong argument number: " + arg);
+		throw new JadxRuntimeException("Wrong argument number: " + arg);
 	}
 
 	public static String formatOffset(int offset) {

File: jadx-gui/src/main/java/jadx/gui/utils/OverlayIcon.java
Patch:
@@ -13,7 +13,7 @@ public class OverlayIcon implements Icon {
 
 	private static final double A = 0.8;
 	private static final double B = 0.2;
-	private static final double[] pos = new double[]{A, B, B, B, A, A, B, A};
+	private static final double[] OVERLAY_POS = new double[]{A, B, B, B, A, A, B, A};
 
 	public OverlayIcon(Icon icon) {
 		this.icon = icon;
@@ -37,8 +37,8 @@ public void paintIcon(Component c, Graphics g, int x, int y) {
 		icon.paintIcon(c, g, x, y);
 		int k = 0;
 		for (Icon icon : icons) {
-			int dx = (int) (pos[k++] * (w - icon.getIconWidth()));
-			int dy = (int) (pos[k++] * (h - icon.getIconHeight()));
+			int dx = (int) (OVERLAY_POS[k++] * (w - icon.getIconWidth()));
+			int dy = (int) (OVERLAY_POS[k++] * (h - icon.getIconHeight()));
 			icon.paintIcon(c, g, x + dx, y + dy);
 		}
 	}

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -148,6 +148,8 @@ private String sfield(FieldInfo field) {
 		String thisClass = mth.getParentClass().getFullName();
 		if (thisClass.startsWith(field.getDeclClass().getFullName())) {
 			return field.getName();
+		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {
+			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();
 		} else {
 			return useClass(field.getDeclClass()) + '.' + field.getName();
 		}

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java
Patch:
@@ -353,7 +353,6 @@ private static boolean modifyBlocksTree(MethodNode mth) {
 		// splice return block if several predecessors presents
 		for (BlockNode block : mth.getExitBlocks()) {
 			if (block.getInstructions().size() == 1
-			&&  block.getInstructions().get(0).getArgsCount() > 0
 			&& !block.getInstructions().get(0).getAttributes().contains(AttributeType.CATCH_BLOCK)
 			&& !block.getAttributes().contains(AttributeFlag.SYNTHETIC)) {
 				List<BlockNode> preds = new ArrayList<BlockNode>(block.getPredecessors());

File: jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java
Patch:
@@ -353,7 +353,6 @@ private static boolean modifyBlocksTree(MethodNode mth) {
 		// splice return block if several predecessors presents
 		for (BlockNode block : mth.getExitBlocks()) {
 			if (block.getInstructions().size() == 1
-			&&  block.getInstructions().get(0).getArgsCount() > 0
 			&& !block.getInstructions().get(0).getAttributes().contains(AttributeType.CATCH_BLOCK)
 			&& !block.getAttributes().contains(AttributeFlag.SYNTHETIC)) {
 				List<BlockNode> preds = new ArrayList<BlockNode>(block.getPredecessors());

File: jadx-core/src/main/java/jadx/core/codegen/InsnGen.java
Patch:
@@ -402,7 +402,7 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, EnumSet<IGState> state
 
 			/* fallback mode instructions */
 			case IF:
-				assert isFallback();
+				assert isFallback() : "if insn in not fallback mode";
 				IfNode ifInsn = (IfNode) insn;
 				String cond = arg(insn.getArg(0)) + " " + ifInsn.getOp().getSymbol() + " "
 						+ (ifInsn.isZeroCmp() ? "0" : arg(insn.getArg(1)));

File: jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java
Patch:
@@ -13,9 +13,9 @@
 import jadx.core.utils.exceptions.JadxException;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -65,7 +65,7 @@ public String toString() {
 
 	@Override
 	public void visit(MethodNode mth) throws JadxException {
-		final Map<RegisterArg, Usage> usageMap = new HashMap<RegisterArg, Usage>();
+		final Map<RegisterArg, Usage> usageMap = new LinkedHashMap<RegisterArg, Usage>();
 
 		// collect all variables usage
 		IRegionVisitor collect = new TracedRegionVisitor() {

File: jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java
Patch:
@@ -125,10 +125,11 @@ public void setOffset(int offset) {
 
 	public void getRegisterArgs(List<RegisterArg> list) {
 		for (InsnArg arg : this.getArguments()) {
-			if (arg.isRegister())
+			if (arg.isRegister()) {
 				list.add((RegisterArg) arg);
-			else if (arg.isInsnWrap())
+			} else if (arg.isInsnWrap()) {
 				((InsnWrapArg) arg).getWrapInsn().getRegisterArgs(list);
+			}
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java
Patch:
@@ -94,7 +94,6 @@ public ClassNode searchClassByName(String fullName) {
 
 	public ClassNode resolveClass(ClassInfo cls) {
 		String fullName = cls.getFullName();
-		ClassNode rCls = searchClassByName(fullName);
-		return rCls;
+		return searchClassByName(fullName);
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java
Patch:
@@ -211,8 +211,9 @@ private static void fillLocals(InsnNode insn, LocalVar var) {
 
 	private static void merge(InsnArg arg, LocalVar var) {
 		if (arg != null && arg.isRegister()) {
-			if (var.getRegNum() == ((RegisterArg) arg).getRegNum())
-				arg.setTypedVar(var.getTypedVar());
+			if (var.getRegNum() == ((RegisterArg) arg).getRegNum()) {
+				arg.mergeDebugInfo(var);
+			}
 		}
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/nodes/parser/LocalVar.java
Patch:
@@ -33,7 +33,7 @@ private void init(String name, ArgType type, String sign) {
 		}
 		TypedVar tv = new TypedVar(type);
 		tv.setName(name);
-		setTypedVar(tv);
+		forceSetTypedVar(tv);
 	}
 
 	public void start(int addr, int line) {

File: jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java
Patch:
@@ -69,7 +69,6 @@ public void visit(MethodNode mth) {
 				+ mth.getParentClass().getFullName() + "." + mth.getName()
 				+ "(" + Utils.listToString(mth.getArguments(true)) + ") ")
 				+ (attrs.length() == 0 ? "" : " | " + attrs)
-				+ (mth.getSuperCall() != null ? "| Super call: " + escape(mth.getSuperCall().toString()) : "")
 				+ "}\"];");
 
 		dot.startLine("MethodNode -> " + makeName(mth.getEnterBlock()) + ";");

File: jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java
Patch:
@@ -30,8 +30,7 @@ public class EnumVisitor extends AbstractVisitor {
 
 	@Override
 	public boolean visit(ClassNode cls) throws JadxException {
-		if (!cls.getAccessFlags().isEnum()
-				|| !cls.getSuperClass().getFullName().equals("java.lang.Enum"))
+		if (!cls.isEnum())
 			return true;
 
 		// collect enum fields, remove synthetic

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeresolver/TypeResolver.java
Patch:
@@ -103,12 +103,12 @@ private boolean connectEdges(MethodNode mth, BlockNode from, BlockNode to, boole
 
 			if (back) {
 				if (er.getTypedVar() == null && sr.getTypedVar() != null) {
-					er.replace(sr);
+					er.replaceTypedVar(sr);
 					changed = true;
 				}
 			} else {
 				if (sr.getTypedVar() != null && er.getTypedVar() != null) {
-					sr.replace(er);
+					sr.replaceTypedVar(er);
 					changed = true;
 				}
 			}

File: jadx-core/src/test/java/jadx/tests/functional/JadxClasspathTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static jadx.core.dex.instructions.args.ArgType.STRING;
 import static jadx.core.dex.instructions.args.ArgType.object;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -37,5 +38,7 @@ public void test() {
 
 		assertFalse(ArgType.isCastNeeded(objExc, objThr));
 		assertTrue(ArgType.isCastNeeded(objThr, objExc));
+
+		assertTrue(ArgType.isCastNeeded(ArgType.OBJECT, STRING));
 	}
 }

File: jadx-samples/src/main/java/jadx/samples/TestTypeResolver.java
Patch:
@@ -20,7 +20,7 @@ public TestTypeResolver(int a1, int a2, int a3, int a4, int a5) {
 	public static class TestTernaryInSuper extends TestTypeResolver {
 
 		public TestTernaryInSuper(int c) {
-			super(c > 0 ? c : -c, 1);
+//			super(c > 0 ? c : -c, 1);
 		}
 	}
 

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -106,9 +106,9 @@ public static String formatLong(long lit) {
 	}
 
 	private static String wrapNegNum(boolean lz, String str) {
-		if (lz)
-			return "(" + str + ")";
-		else
+//		if (lz)
+//			return "(" + str + ")";
+//		else
 			return str;
 	}
 }

File: jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java
Patch:
@@ -5,6 +5,7 @@
 import jadx.core.dex.info.MethodInfo;
 import jadx.core.dex.instructions.ConstClassNode;
 import jadx.core.dex.instructions.ConstStringNode;
+import jadx.core.dex.instructions.FillArrayNode;
 import jadx.core.dex.instructions.IndexInsnNode;
 import jadx.core.dex.instructions.InsnType;
 import jadx.core.dex.instructions.InvokeNode;
@@ -164,6 +165,7 @@ private void removeStep(MethodNode mth) {
 							InsnNode ni = block.getInstructions().get(next);
 							if (ni.getType() == InsnType.FILL_ARRAY) {
 								ni.getResult().merge(insn.getResult());
+								((FillArrayNode) ni).mergeElementType(insn.getResult().getType().getArrayElement());
 								remover.add(insn);
 							}
 						}

File: jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java
Patch:
@@ -1,5 +1,6 @@
 package jadx.core.utils;
 
+import jadx.core.dex.attributes.AttributeFlag;
 import jadx.core.dex.attributes.IAttributeNode;
 import jadx.core.dex.attributes.JadxErrorAttr;
 import jadx.core.dex.nodes.ClassNode;
@@ -40,6 +41,7 @@ private static void addError(IAttributeNode node, String msg, Throwable e) {
 			}
 			node.getAttributes().add(new JadxErrorAttr(e));
 		} else {
+			node.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);
 			LOG.error(msg);
 		}
 	}

File: jadx-core/src/main/java/jadx/core/codegen/TypeGen.java
Patch:
@@ -41,10 +41,11 @@ public static String signature(ArgType type) {
 	public static String literalToString(long lit, ArgType type) {
 		if (type == null || !type.isTypeKnown()) {
 			String n = Long.toString(lit);
-			if (Math.abs(lit) > 100)
+			if (Math.abs(lit) > 100) {
 				n += "; // 0x" + Long.toHexString(lit)
 						+ " float:" + Float.intBitsToFloat((int) lit)
 						+ " double:" + Double.longBitsToDouble(lit);
+			}
 			return n;
 		}
 

File: jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java
Patch:
@@ -107,7 +107,7 @@ public String toString() {
 			case AND:
 				return "&& " + args;
 			case OR:
-				return "||" + args;
+				return "|| " + args;
 		}
 		return "??";
 	}

File: jadx-core/src/main/java/jadx/core/dex/visitors/typeresolver/FinishTypeResolver.java
Patch:
@@ -19,11 +19,11 @@ public void visit(MethodNode mth) {
 		int i = 0;
 		do {
 			change = false;
-			for (BlockNode block : mth.getBasicBlocks())
+			for (BlockNode block : mth.getBasicBlocks()) {
 				for (InsnNode insn : block.getInstructions())
-					if (PostTypeResolver.visit(insn))
+					if (PostTypeResolver.visit(mth, insn))
 						change = true;
-
+			}
 			i++;
 			if (i > 1000)
 				break;

File: jadx-gui/src/main/java/jadx/gui/utils/Utils.java
Patch:
@@ -37,6 +37,9 @@ public static String typeFormat(String name, ArgType type) {
 	}
 
 	public static String typeStr(ArgType type) {
+		if (type == null) {
+			return "null";
+		}
 		if (type.isObject()) {
 			String cls = type.getObject();
 			int dot = cls.lastIndexOf('.');

File: jadx-core/src/main/java/jadx/core/codegen/RegionGen.java
Patch:
@@ -270,7 +270,7 @@ private void makeCatchBlock(CodeWriter code, ExceptionHandler handler)
 			code.startLine("} catch (");
 			code.add(handler.isCatchAll() ? "Throwable" : useClass(handler.getCatchType()));
 			code.add(' ');
-			code.add(mgen.assignArg(handler.getArg()));
+			code.add(mgen.assignNamedArg(handler.getArg()));
 			code.add(") {");
 			makeRegionIndent(code, region);
 		}

File: jadx-core/src/main/java/jadx/core/dex/attributes/BlockRegState.java
Patch:
@@ -32,8 +32,7 @@ public void use(RegisterArg arg) {
 			regType = new TypedVar(arg.getType());
 			regs[arg.getRegNum()].setTypedVar(regType);
 		}
-		arg.replace(regType);
-		regType.getUseList().add(arg);
+		regType.use(arg);
 	}
 
 	public RegisterArg getRegister(int r) {

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java
Patch:
@@ -2,7 +2,7 @@
 
 import jadx.core.dex.nodes.InsnNode;
 
-public class InsnWrapArg extends InsnArg {
+public final class InsnWrapArg extends InsnArg {
 
 	private final InsnNode wrappedInsn;
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java
Patch:
@@ -3,7 +3,7 @@
 import jadx.core.codegen.TypeGen;
 import jadx.core.utils.exceptions.JadxRuntimeException;
 
-public class LiteralArg extends InsnArg {
+public final class LiteralArg extends InsnArg {
 
 	private final long literal;
 

File: jadx-core/src/main/java/jadx/core/dex/instructions/args/Typed.java
Patch:
@@ -29,7 +29,6 @@ public void replace(Typed var) {
 	}
 
 	public void replace(TypedVar newVar) {
-		assert newVar != null;
 		if (typedVar == newVar)
 			return;
 

File: jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java
Patch:
@@ -7,6 +7,7 @@
 import jadx.core.utils.files.InputFile;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -99,7 +100,7 @@ public List<ArgType> readParamList(int parametersOffset) {
 		for (short t : paramList.getTypes()) {
 			args.add(getType(t));
 		}
-		return args;
+		return Collections.unmodifiableList(args);
 	}
 
 	public Code readCode(Method mth) {

File: jadx-cli/src/main/java/jadx/cli/JadxCLI.java
Patch:
@@ -12,7 +12,6 @@ public static void main(String[] args) {
 		JadxArgs jadxArgs = new JadxArgs(args, true);
 		Decompiler jadx = new Decompiler(jadxArgs);
 		jadx.processAndSaveAll();
-		LOG.info("done");
 		System.exit(jadx.getErrorsCount());
 	}
 }

File: jadx-core/src/main/java/jadx/api/Decompiler.java
Patch:
@@ -91,7 +91,7 @@ public List<JavaPackage> getPackages() {
 		return Collections.unmodifiableList(packages);
 	}
 
-	public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {
+	public ThreadPoolExecutor saveAll(File dir) {
 		int threadsCount = args.getThreadsCount();
 		LOG.debug("processing threads count: {}", threadsCount);
 

File: jadx-core/src/main/java/jadx/api/JavaClass.java
Patch:
@@ -1,7 +1,6 @@
 package jadx.api;
 
 import jadx.core.codegen.CodeWriter;
-import jadx.core.dex.attributes.AttributeFlag;
 import jadx.core.dex.info.AccessInfo;
 import jadx.core.dex.nodes.ClassNode;
 import jadx.core.dex.nodes.FieldNode;
@@ -51,7 +50,7 @@ public final class JavaClass {
 		} else {
 			List<JavaMethod> mths = new ArrayList<JavaMethod>(methodsCount);
 			for (MethodNode m : cls.getMethods()) {
-				if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {
+				if (!m.getAccessFlags().isSynthetic()) {
 					mths.add(new JavaMethod(m));
 				}
 			}

File: jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java
Patch:
@@ -33,6 +33,7 @@ public JavaClass getCls() {
 
 	@Override
 	public void updateChilds() {
+		removeAllChildren();
 		JClass currentParent = jParrent == null ? this : jParrent;
 		for (JavaClass javaClass : cls.getInnerClasses()) {
 			JClass child = new JClass(javaClass);

File: jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java
Patch:
@@ -135,12 +135,12 @@ public ArgType getType() {
 
 	@Override
 	public String toString() {
-		return getFullName();
+		return fullName;
 	}
 
 	@Override
 	public int hashCode() {
-		return type.hashCode();
+		return fullName.hashCode();
 	}
 
 	@Override

File: src/main/java/jadx/codegen/InsnGen.java
Patch:
@@ -571,7 +571,7 @@ private void makeArith(ArithNode insn, CodeWriter code, EnumSet<InsnGenState> st
 			code.add('(').add(v1).add(' ').add(op.getSymbol()).add(' ').add(v2).add(')');
 		} else {
 			String res = arg(insn.getResult());
-			if (res.equals(v1)) {
+			if (res.equals(v1) && insn.getResult().equals(insn.getArg(0))) {
 				state.add(InsnGenState.NO_RESULT);
 				// "++" or "--"
 				if (insn.getArg(1).isLiteral() && (op == ArithOp.ADD || op == ArithOp.SUB)) {

File: src/main/java/jadx/codegen/MethodGen.java
Patch:
@@ -194,7 +194,7 @@ private String getUniqVarName(String name) {
 		String r;
 		int i = 2;
 		do {
-			r = name + i;
+			r = name + "_" + i;
 			i++;
 		} while (varNames.contains(r));
 		varNames.add(r);

File: src/main/java/jadx/codegen/RegionGen.java
Patch:
@@ -152,7 +152,7 @@ private CodeWriter makeLoop(LoopRegion region, CodeWriter code) throws CodegenEx
 	}
 
 	private void makeSynchronizedRegion(SynchronizedRegion cont, CodeWriter code) throws CodegenException {
-		code.startLine("synchronized(").add(arg(cont.getArg())).add(") {");
+		code.startLine("synchronized(").add(arg(cont.getInsn().getArg(0))).add(") {");
 		makeRegionIndent(code, cont.getRegion());
 		code.startLine('}');
 	}

File: src/main/java/jadx/IJadxArgs.java
Patch:
@@ -18,8 +18,6 @@ public interface IJadxArgs {
 
     boolean isFallbackMode();
 
-    boolean isNotObfuscated();
-
     boolean isVerbose();
 
     boolean isPrintHelp();

File: src/main/java/jadx/dex/nodes/BlockNode.java
Patch:
@@ -19,6 +19,7 @@ public class BlockNode extends AttrNode implements IBlock {
 
 	private List<BlockNode> predecessors = new ArrayList<BlockNode>(1);
 	private List<BlockNode> successors = new ArrayList<BlockNode>(1);
+	private List<BlockNode> cleanSuccessors;
 
 	private BitSet doms; // all dominators
 	private BlockNode idom; // immediate dominator
@@ -48,8 +49,6 @@ public List<BlockNode> getSuccessors() {
 		return successors;
 	}
 
-	private List<BlockNode> cleanSuccessors;
-
 	public List<BlockNode> getCleanSuccessors() {
 		return cleanSuccessors;
 	}

File: src/main/java/jadx/dex/nodes/ClassNode.java
Patch:
@@ -154,10 +154,10 @@ private void parseClassSignature() {
 		if (list != null && !list.isEmpty()) {
 			try {
 				ArgType st = list.remove(0);
-				this.superClass = ClassInfo.fromType(dex, st);
+				this.superClass = ClassInfo.fromType(st);
 				int i = 0;
 				for (ArgType it : list) {
-					ClassInfo interf = ClassInfo.fromType(dex, it);
+					ClassInfo interf = ClassInfo.fromType(it);
 					interfaces.set(i, interf);
 					i++;
 				}

File: src/main/java/jadx/codegen/RegionGen.java
Patch:
@@ -124,9 +124,7 @@ private void makeIf(IfRegion region, CodeWriter code) throws CodegenException {
 			}
 
 			code.add('{');
-			code.incIndent();
-			makeRegion(code, els);
-			code.decIndent();
+			makeRegionIndent(code, els);
 			code.startLine('}');
 		}
 	}

File: src/main/java/jadx/dex/visitors/BlockProcessingHelper.java
Patch:
@@ -48,7 +48,6 @@ private static void markExceptionHandlers(MethodNode mth, BlockNode block) {
 					excArg.getTypedVar().forceSetType(ArgType.THROWABLE);
 				else
 					excArg.getTypedVar().forceSetType(excHandler.getCatchType().getType());
-				// excArg.getTypedVar().merge(excHandler.getCatchType().getType());
 
 				excHandler.setArg(excArg);
 				block.getAttributes().add(handlerAttr);

File: src/main/java/jadx/utils/RegionUtils.java
Patch:
@@ -100,8 +100,7 @@ private static boolean isRegionContainsExcHandlerRegion(IContainer container, IR
 	}
 
 	/**
-	 * Check if region contains in container
-	 * 
+	 * Check if {@code region} contains in {@code container}.<br>
 	 * For simple region (not from exception handlers) search in parents
 	 * otherwise run recursive search because exception handlers can have several parents
 	 */

File: src/main/java/jadx/codegen/MethodGen.java
Patch:
@@ -263,7 +263,7 @@ private void makeFullMethodDump(CodeWriter code, MethodNode mth) {
 	}
 
 	private void makeFallbackMethod(CodeWriter code, MethodNode mth) {
-		if (!mth.getAccessFlags().isStatic()) {
+		if (mth.getThisArg() != null) {
 			code.startLine(getFallbackMethodGen(mth).makeArgName(mth.getThisArg())).add(" = this;");
 		}
 		makeFallbackInsns(code, mth, mth.getInstructions(), true);

File: src/main/java/jadx/utils/Utils.java
Patch:
@@ -49,6 +49,8 @@ public static String escape(String str) {
 				case '>':
 				case ',':
 				case ' ':
+				case '?':
+				case '*':
 					break;
 
 				default:

File: src/main/java/jadx/dex/info/ClassInfo.java
Patch:
@@ -53,7 +53,7 @@ private ClassInfo(DexNode dex, ArgType type) {
 		this.type = type;
 
 		String fullObjectName = type.getObject();
-		assert fullObjectName.indexOf('/') == -1;
+		assert fullObjectName.indexOf('/') == -1 : "Raw type: " + type;
 
 		boolean notObfuscated = dex.root().getJadxArgs().isNotObfuscated();
 		String name;

File: src/samples/java/jadx/samples/TestGenerics.java
Patch:
@@ -9,6 +9,8 @@ public class TestGenerics extends AbstractTest {
 
 	public List<String> strings;
 
+	public Class<?>[] classes;
+
 	public static class GenericClass implements Comparable<String> {
 		@Override
 		public int compareTo(String o) {

File: src/main/java/jadx/Consts.java
Patch:
@@ -12,4 +12,6 @@ public class Consts {
 	public static final String CLASS_CLASS = "java.lang.Class";
 	public static final String CLASS_THROWABLE = "java.lang.Throwable";
 	public static final String CLASS_ENUM = "java.lang.Enum";
+
+	public static final String DALVIK_SIGNATURE = "dalvik.annotation.Signature";
 }

File: src/main/java/jadx/dex/info/ClassInfo.java
Patch:
@@ -49,6 +49,7 @@ public static void clearCache() {
 	}
 
 	private ClassInfo(DexNode dex, ArgType type) {
+		assert type.isObject() : "Not class type: " + type;
 		this.type = type;
 
 		String fullObjectName = type.getObject();

File: src/main/java/jadx/dex/info/FieldInfo.java
Patch:
@@ -1,12 +1,11 @@
 package jadx.dex.info;
 
-import jadx.dex.attributes.AttrNode;
 import jadx.dex.instructions.args.ArgType;
 import jadx.dex.nodes.DexNode;
 
 import com.android.dx.io.FieldId;
 
-public class FieldInfo extends AttrNode {
+public class FieldInfo {
 
 	private final String name;
 	private final ArgType type;

File: src/main/java/jadx/dex/info/LocalVarInfo.java
Patch:
@@ -28,7 +28,7 @@ public LocalVarInfo(DexNode dex, int rn, String name, ArgType type, String sign)
 
 	private void init(String name, ArgType type, String sign) {
 		if (sign != null) {
-			type = ArgType.generic(type.getObject(), sign);
+			type = ArgType.generic(sign);
 		}
 		TypedVar tv = new TypedVar(type);
 		tv.setName(name);

File: src/main/java/jadx/dex/instructions/InsnDecoder.java
Patch:
@@ -401,7 +401,7 @@ private InsnNode decode(DecodedInstruction insn, int offset) throws DecodeExcept
 			case Opcodes.RETURN_OBJECT:
 				return insn(InsnType.RETURN,
 						null,
-						InsnArg.reg(insn, 0, method.getMethodInfo().getReturnType()));
+						InsnArg.reg(insn, 0, method.getReturnType()));
 
 			case Opcodes.INSTANCE_OF: {
 				InsnNode node = new IndexInsnNode(method, InsnType.INSTANCE_OF, dex.getType(insn.getIndex()), 1);

File: src/main/java/jadx/dex/visitors/ConstInlinerVisitor.java
Patch:
@@ -137,7 +137,7 @@ private static void fixTypes(MethodNode mth, InsnNode insn) {
 
 			case RETURN:
 				if (insn.getArgsCount() != 0) {
-					insn.getArg(0).merge(mth.getMethodInfo().getReturnType());
+					insn.getArg(0).merge(mth.getReturnType());
 				}
 				break;
 

File: src/main/java/jadx/dex/visitors/DotGraphVisitor.java
Patch:
@@ -64,7 +64,7 @@ public void visit(MethodNode mth) {
 
 		dot.startLine("MethodNode[shape=record,label=\"{"
 				+ escape(mth.getAccessFlags().makeString())
-				+ escape(mth.getMethodInfo().getReturnType() + " "
+				+ escape(mth.getReturnType() + " "
 						+ mth.getParentClass().getFullName() + "." + mth.getName()
 						+ "(" + Utils.listToString(mth.getArguments(true)) + ") ")
 				+ (attrs.length() == 0 ? "" : " | " + attrs)

File: src/main/java/jadx/dex/visitors/regions/PostRegionVisitor.java
Patch:
@@ -29,7 +29,7 @@ public void visit(MethodNode mth) throws JadxException {
 	 * Remove useless return at end
 	 */
 	private void removeReturn(MethodNode mth) {
-		if (!mth.getMethodInfo().getReturnType().equals(ArgType.VOID))
+		if (!mth.getReturnType().equals(ArgType.VOID))
 			return;
 
 		if (!(mth.getRegion() instanceof Region))

File: src/main/java/jadx/dex/info/LocalVarInfo.java
Patch:
@@ -28,7 +28,7 @@ public LocalVarInfo(DexNode dex, int rn, String name, ArgType type, String sign)
 
 	private void init(String name, ArgType type, String sign) {
 		if (sign != null) {
-			type.setGeneric(sign);
+			type = ArgType.generic(type.getObject(), sign);
 		}
 		TypedVar tv = new TypedVar(type);
 		tv.setName(name);

File: src/main/java/jadx/dex/instructions/args/PrimitiveType.java
Patch:
@@ -45,6 +45,6 @@ public static PrimitiveType getSmaller(PrimitiveType a, PrimitiveType b) {
 
 	@Override
 	public String toString() {
-		return this.name().toLowerCase();
+		return longName;
 	}
 }

File: src/main/java/jadx/dex/nodes/MethodNode.java
Patch:
@@ -109,8 +109,6 @@ public void unload() {
 			return;
 
 		if (instructions != null) instructions.clear();
-		// if (blocks != null) blocks.clear();
-		// if (exitBlocks != null) exitBlocks.clear();
 		blocks = null;
 		exitBlocks = null;
 		if (exceptionHandlers != null) exceptionHandlers.clear();

File: src/main/java/jadx/dex/nodes/MethodNode.java
Patch:
@@ -95,7 +95,7 @@ public void load() throws DecodeException {
 			initJumps(insnByOffset);
 
 			if (mthCode.getDebugInfoOffset() > 0) {
-				DebugInfoParser debugInfo = new DebugInfoParser(this, dex.openSection(mthCode.getDebugInfoOffset()));
+				DebugInfoParser debugInfo = new DebugInfoParser(this, mthCode.getDebugInfoOffset());
 				debugInfo.process(insnByOffset);
 			}
 		} catch (Exception e) {

