File: src/main/java/io/reactivex/rxjava3/core/Scheduler.java
Patch:
@@ -350,7 +350,7 @@ public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initial
      * });
      * </pre>
      *
-     * Slowing down the rate to no more than than 1 a second. This suffers from
+     * Slowing down the rate to no more than 1 a second. This suffers from
      * the same problem as the one above I could find an {@link Flowable}
      * operator that limits the rate without dropping the values (aka leaky
      * bucket algorithm).

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/SchedulerWhen.java
Patch:
@@ -80,7 +80,7 @@
  * }
  * </pre>
  *
- * Slowing down the rate to no more than than 1 a second. This suffers from the
+ * Slowing down the rate to no more than 1 a second. This suffers from the
  * same problem as the one above I could find an {@link Observable} operator
  * that limits the rate without dropping the values (aka leaky bucket
  * algorithm).

File: src/test/java/io/reactivex/rxjava3/disposables/CompositeDisposableTest.java
Patch:
@@ -290,7 +290,7 @@ public void tryRemoveIfNotIn() {
         cd.remove(cd1);
         cd.add(cd2);
 
-        cd.remove(cd1); // try removing agian
+        cd.remove(cd1); // try removing again
     }
 
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/rxjava3/exceptions/TestException.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.rxjava3.exceptions;
 
 /**
- * Exception for testing if unchecked expections propagate as-is without confusing with
+ * Exception for testing if unchecked exceptions propagate as-is without confusing with
  * other type of common exceptions.
  */
 public final class TestException extends RuntimeException {

File: src/test/java/io/reactivex/rxjava3/flowable/FlowableBackpressureTests.java
Patch:
@@ -132,7 +132,7 @@ public void mergeSync() {
         assertEquals(num, ts.values().size());
         // either one can starve the other, but neither should be capable of doing more than 5 batches (taking 4.1)
         // TODO is it possible to make this deterministic rather than one possibly starving the other?
-        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algoritms generally take a performance hit
+        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algorithms generally take a performance hit
         assertTrue(c1.get() < Flowable.bufferSize() * 5);
         assertTrue(c2.get() < Flowable.bufferSize() * 5);
     }
@@ -154,7 +154,7 @@ public void mergeAsync() {
         assertEquals(num, ts.values().size());
         // either one can starve the other, but neither should be capable of doing more than 5 batches (taking 4.1)
         // TODO is it possible to make this deterministic rather than one possibly starving the other?
-        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algoritms generally take a performance hit
+        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algorithms generally take a performance hit
         int max = Flowable.bufferSize() * 7;
         assertTrue("" + c1.get() + " >= " + max, c1.get() < max);
         assertTrue("" + c2.get() + " >= " + max, c2.get() < max);
@@ -206,7 +206,7 @@ public void mergeAsyncThenObserveOn() {
         assertEquals(num, ts.values().size());
         // either one can starve the other, but neither should be capable of doing more than 5 batches (taking 4.1)
         // TODO is it possible to make this deterministic rather than one possibly starving the other?
-        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algoritms generally take a performance hit
+        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algorithms generally take a performance hit
         // akarnokd => run this in a loop over 10k times and never saw values get as high as 7*SIZE, but since observeOn delays the unsubscription non-deterministically, the test will remain unreliable
         assertTrue(c1.get() < Flowable.bufferSize() * 7);
         assertTrue(c2.get() < Flowable.bufferSize() * 7);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -349,9 +349,10 @@ public void onSubscribe(Disposable d) {
 
         @Override
         public void onNext(R t) {
-            if (index == parent.unique) {
+            SimpleQueue<R> q = queue;
+            if (index == parent.unique && q != null) {
                 if (t != null) {
-                    queue.offer(t);
+                    q.offer(t);
                 }
                 parent.drain();
             }

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -16985,7 +16985,7 @@ public final TestObserver<T> test(boolean dispose) { // NoPMD
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
     @NonNull
-    public final <@NonNull R, @NonNull A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {
+    public final <@NonNull R, @Nullable A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {
         Objects.requireNonNull(collector, "collector is null");
         return RxJavaPlugins.onAssembly(new ObservableCollectWithCollectorSingle<>(this, collector));
     }

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -20394,7 +20394,7 @@ public final TestSubscriber<T> test(long initialRequest, boolean cancel) { // No
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
     @NonNull
-    public final <@NonNull R, @NonNull A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {
+    public final <@NonNull R, @Nullable A> Single<R> collect(@NonNull Collector<? super T, A, R> collector) {
         Objects.requireNonNull(collector, "collector is null");
         return RxJavaPlugins.onAssembly(new FlowableCollectWithCollectorSingle<>(this, collector));
     }

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -601,6 +601,7 @@ public static Completable fromCallable(@NonNull Callable<?> callable) {
      * @param future the {@code Future} to react to
      * @return the new {@code Completable} instance
      * @throws NullPointerException if {@code future} is {@code null}
+     * @see #fromCompletionStage(CompletionStage)
      */
     @CheckReturnValue
     @NonNull
@@ -3410,7 +3411,7 @@ public final TestObserver<Void> test(boolean dispose) {
      * <img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.c.png" alt="">
      * <p>
      * Note that the operator takes an already instantiated, running or terminated {@code CompletionStage}.
-     * If the optional is to be created per consumer upon subscription, use {@link #defer(Supplier)}
+     * If the {@code CompletionStage} is to be created per consumer upon subscription, use {@link #defer(Supplier)}
      * around {@code fromCompletionStage}:
      * <pre><code>
      * Maybe.defer(() -&gt; Completable.fromCompletionStage(createCompletionStage()));

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -20033,7 +20033,7 @@ public final TestSubscriber<T> test(long initialRequest, boolean cancel) { // No
      * <img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.f.png" alt="">
      * <p>
      * Note that the operator takes an already instantiated, running or terminated {@code CompletionStage}.
-     * If the optional is to be created per consumer upon subscription, use {@link #defer(Supplier)}
+     * If the {@code CompletionStage} is to be created per consumer upon subscription, use {@link #defer(Supplier)}
      * around {@code fromCompletionStage}:
      * <pre><code>
      * Flowable.defer(() -&gt; Flowable.fromCompletionStage(createCompletionStage()));

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -1109,6 +1109,7 @@ public abstract class Maybe<@NonNull T> implements MaybeSource<T> {
      * @return the new {@code Maybe} instance
      * @throws NullPointerException if {@code future} is {@code null}
      * @see <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
+     * @see #fromCompletionStage(CompletionStage)
      */
     @CheckReturnValue
     @NonNull
@@ -1147,6 +1148,7 @@ public abstract class Maybe<@NonNull T> implements MaybeSource<T> {
      * @return the new {@code Maybe} instance
      * @throws NullPointerException if {@code future} or {@code unit} is {@code null}
      * @see <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
+     * @see #fromCompletionStage(CompletionStage)
      */
     @CheckReturnValue
     @NonNull
@@ -6145,7 +6147,7 @@ public final TestObserver<T> test(boolean dispose) {
      * <img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.s.png" alt="">
      * <p>
      * Note that the operator takes an already instantiated, running or terminated {@code CompletionStage}.
-     * If the optional is to be created per consumer upon subscription, use {@link #defer(Supplier)}
+     * If the {@code CompletionStage} is to be created per consumer upon subscription, use {@link #defer(Supplier)}
      * around {@code fromCompletionStage}:
      * <pre><code>
      * Maybe.defer(() -&gt; Maybe.fromCompletionStage(createCompletionStage()));

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -2020,6 +2020,7 @@ public static int bufferSize() {
      * @return the new {@code Observable} instance
      * @throws NullPointerException if {@code future} is {@code null}
      * @see <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
+     * @see #fromCompletionStage(CompletionStage)
      */
     @CheckReturnValue
     @NonNull
@@ -2062,6 +2063,7 @@ public static int bufferSize() {
      * @return the new {@code Observable} instance
      * @throws NullPointerException if {@code future} or {@code unit} is {@code null}
      * @see <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
+     * @see #fromCompletionStage(CompletionStage)
      */
     @CheckReturnValue
     @NonNull
@@ -16776,7 +16778,7 @@ public final TestObserver<T> test(boolean dispose) { // NoPMD
      * <img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.o.png" alt="">
      * <p>
      * Note that the operator takes an already instantiated, running or terminated {@code CompletionStage}.
-     * If the optional is to be created per consumer upon subscription, use {@link #defer(Supplier)}
+     * If the {@code CompletionStage} is to be created per consumer upon subscription, use {@link #defer(Supplier)}
      * around {@code fromCompletionStage}:
      * <pre><code>
      * Observable.defer(() -&gt; Observable.fromCompletionStage(createCompletionStage()));

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -5598,7 +5598,7 @@ private static <T> Single<T> toSingle(@NonNull Flowable<T> source) {
      * <img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.s.png" alt="">
      * <p>
      * Note that the operator takes an already instantiated, running or terminated {@code CompletionStage}.
-     * If the optional is to be created per consumer upon subscription, use {@link #defer(Supplier)}
+     * If the {@code CompletionStage} is to be created per consumer upon subscription, use {@link #defer(Supplier)}
      * around {@code fromCompletionStage}:
      * <pre><code>
      * Single.defer(() -&gt; Single.fromCompletionStage(createCompletionStage()));

File: src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java
Patch:
@@ -437,8 +437,8 @@ public void checkParallelFlowable() {
         addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "sample", Long.TYPE, TimeUnit.class));
         addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "sample", Long.TYPE, TimeUnit.class, Boolean.TYPE));
         addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "sample", Long.TYPE, TimeUnit.class, Scheduler.class));
-        addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "sample", Long.TYPE, TimeUnit.class, Scheduler.class, Consumer.class));
         addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "sample", Long.TYPE, TimeUnit.class, Scheduler.class, Boolean.TYPE));
+        addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "sample", Long.TYPE, TimeUnit.class, Scheduler.class, Boolean.TYPE, Consumer.class));
 
         // negative time is considered as zero time
         addOverride(new ParamOverride(Observable.class, 0, ParamMode.ANY, "takeLast", Long.TYPE, TimeUnit.class));

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleFirstTimed.java
Patch:
@@ -32,7 +32,7 @@ public final class ObservableThrottleFirstTimed<T> extends AbstractObservableWit
 
     public ObservableThrottleFirstTimed(
             ObservableSource<T> source,
-            long timeout, 
+            long timeout,
             TimeUnit unit,
             Scheduler scheduler,
             Consumer<? super T> onDropped) {
@@ -102,9 +102,9 @@ public void onNext(T t) {
                     onDropped.accept(t);
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
+                    upstream.dispose();
                     downstream.onError(ex);
                     worker.dispose();
-                    upstream.dispose();
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFlatMapStream.java
Patch:
@@ -174,7 +174,7 @@ public void onNext(T t) {
             if (sourceMode != QueueFuseable.ASYNC) {
                 if (!queue.offer(t)) {
                     upstream.cancel();
-                    onError(new MissingBackpressureException("Queue full?!"));
+                    onError(new QueueOverflowException());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcat.java
Patch:
@@ -120,7 +120,7 @@ public void onSubscribe(Subscription s) {
         public void onNext(CompletableSource t) {
             if (sourceFused == QueueSubscription.NONE) {
                 if (!queue.offer(t)) {
-                    onError(new MissingBackpressureException());
+                    onError(new QueueOverflowException());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java
Patch:
@@ -140,7 +140,7 @@ public void onNext(T t) {
             if (!queue.offer(t)) {
                 SubscriptionHelper.cancel(this);
 
-                onError(new MissingBackpressureException("Queue full?!"));
+                onError(new QueueOverflowException());
             } else {
                 signalConsumer();
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -19,7 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.rxjava3.core.*;
-import io.reactivex.rxjava3.exceptions.Exceptions;
+import io.reactivex.rxjava3.exceptions.*;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.subscriptions.*;
 import io.reactivex.rxjava3.internal.util.*;
@@ -152,7 +152,7 @@ public final void onNext(T t) {
             if (sourceMode != QueueSubscription.ASYNC) {
                 if (!queue.offer(t)) {
                     upstream.cancel();
-                    onError(new IllegalStateException("Queue full?!"));
+                    onError(new QueueOverflowException());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapEager.java
Patch:
@@ -200,7 +200,7 @@ public void innerNext(InnerQueuedSubscriber<R> inner, R value) {
                 drain();
             } else {
                 inner.cancel();
-                innerError(inner, new MissingBackpressureException());
+                innerError(inner, MissingBackpressureException.createDefault());
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java
Patch:
@@ -19,7 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.rxjava3.core.*;
-import io.reactivex.rxjava3.exceptions.Exceptions;
+import io.reactivex.rxjava3.exceptions.*;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMap.*;
 import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
@@ -151,7 +151,7 @@ public final void onNext(T t) {
             if (sourceMode != QueueSubscription.ASYNC) {
                 if (!queue.offer(t)) {
                     upstream.cancel();
-                    onError(new IllegalStateException("Queue full?!"));
+                    onError(new QueueOverflowException());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCreate.java
Patch:
@@ -442,7 +442,7 @@ static final class ErrorAsyncEmitter<T> extends NoOverflowBaseAsyncEmitter<T> {
 
         @Override
         void onOverflow() {
-            onError(new MissingBackpressureException("create: could not emit value due to lack of requests"));
+            onError(new MissingBackpressureException("create: " + MissingBackpressureException.DEFAULT_MESSAGE));
         }
 
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -148,7 +148,7 @@ void emit(long idx, T value) {
                     BackpressureHelper.produced(this, 1);
                 } else {
                     cancel();
-                    downstream.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));
+                    downstream.onError(MissingBackpressureException.createDefault());
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -159,7 +159,7 @@ void emit(long idx, T t, DebounceEmitter<T> emitter) {
                     emitter.dispose();
                 } else {
                     cancel();
-                    downstream.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));
+                    downstream.onError(MissingBackpressureException.createDefault());
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -180,7 +180,7 @@ public void onNext(T t) {
                 return;
             }
             if (fusionMode == NONE && !queue.offer(t)) {
-                onError(new MissingBackpressureException("Queue is full?!"));
+                onError(new QueueOverflowException());
                 return;
             }
             drain();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java
Patch:
@@ -276,7 +276,7 @@ void drain() {
                             a.onNext(w);
                             BackpressureHelper.produced(requested, 1);
                         } else {
-                            fail(new MissingBackpressureException("Could not emit value due to lack of requests"), a, q);
+                            fail(MissingBackpressureException.createDefault(), a, q);
                             return;
                         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableInterval.java
Patch:
@@ -93,7 +93,7 @@ public void run() {
                     downstream.onNext(count++);
                     BackpressureHelper.produced(this, 1);
                 } else {
-                    downstream.onError(new MissingBackpressureException("Can't deliver value " + count + " due to lack of requests"));
+                    downstream.onError(new MissingBackpressureException("Could not emit value " + count + " due to lack of requests"));
                     DisposableHelper.dispose(resource);
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableIntervalRange.java
Patch:
@@ -114,7 +114,7 @@ public void run() {
                         decrementAndGet();
                     }
                 } else {
-                    downstream.onError(new MissingBackpressureException("Can't deliver value " + count + " due to lack of requests"));
+                    downstream.onError(new MissingBackpressureException("Could not emit value " + count + " due to lack of requests"));
                     DisposableHelper.dispose(resource);
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoin.java
Patch:
@@ -260,7 +260,7 @@ void drain() {
 
                                 e++;
                             } else {
-                                ExceptionHelper.addThrowable(error, new MissingBackpressureException("Could not emit value due to lack of requests"));
+                                ExceptionHelper.addThrowable(error, MissingBackpressureException.createDefault());
                                 q.clear();
                                 cancelAll();
                                 errorAll(a);
@@ -321,7 +321,7 @@ else if (mode == RIGHT_VALUE) {
 
                                 e++;
                             } else {
-                                ExceptionHelper.addThrowable(error, new MissingBackpressureException("Could not emit value due to lack of requests"));
+                                ExceptionHelper.addThrowable(error, MissingBackpressureException.createDefault());
                                 q.clear();
                                 cancelAll();
                                 errorAll(a);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -113,7 +113,7 @@ public final void onNext(T t) {
             if (!queue.offer(t)) {
                 upstream.cancel();
 
-                error = new MissingBackpressureException("Queue is full?!");
+                error = new QueueOverflowException();
                 done = true;
             }
             trySchedule();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
Patch:
@@ -140,7 +140,7 @@ public void onNext(T t) {
                 }
             } else if (callError) {
                 upstream.cancel();
-                onError(new MissingBackpressureException());
+                onError(MissingBackpressureException.createDefault());
             } else {
                 drain();
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java
Patch:
@@ -66,7 +66,7 @@ public void onNext(T t) {
                 BackpressureHelper.produced(this, 1);
             } else {
                 upstream.cancel();
-                onError(new MissingBackpressureException("could not emit value due to lack of requests"));
+                onError(MissingBackpressureException.createDefault());
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublish.java
Patch:
@@ -226,7 +226,7 @@ public void onSubscribe(Subscription s) {
         public void onNext(T t) {
             // we expect upstream to honor backpressure requests
             if (sourceMode == QueueSubscription.NONE && !queue.offer(t)) {
-                onError(new MissingBackpressureException("Prefetch queue is full?!"));
+                onError(new QueueOverflowException());
                 return;
             }
             // since many things can happen concurrently, we have a common dispatch

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublishMulticast.java
Patch:
@@ -212,7 +212,7 @@ public void onNext(T t) {
             }
             if (sourceMode == QueueSubscription.NONE && !queue.offer(t)) {
                 upstream.get().cancel();
-                onError(new MissingBackpressureException());
+                onError(MissingBackpressureException.createDefault());
                 return;
             }
             drain();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSamplePublisher.java
Patch:
@@ -129,7 +129,7 @@ void emit() {
                     BackpressureHelper.produced(requested, 1);
                 } else {
                     cancel();
-                    downstream.onError(new MissingBackpressureException("Couldn't emit value due to lack of requests!"));
+                    downstream.onError(MissingBackpressureException.createDefault());
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSampleTimed.java
Patch:
@@ -125,7 +125,7 @@ void emit() {
                     BackpressureHelper.produced(requested, 1);
                 } else {
                     cancel();
-                    downstream.onError(new MissingBackpressureException("Couldn't emit value due to lack of requests!"));
+                    downstream.onError(MissingBackpressureException.createDefault());
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSequenceEqual.java
Patch:
@@ -300,7 +300,7 @@ public void onSubscribe(Subscription s) {
         public void onNext(T t) {
             if (sourceMode == QueueSubscription.NONE) {
                 if (!queue.offer(t)) {
-                    onError(new MissingBackpressureException());
+                    onError(MissingBackpressureException.createDefault());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -381,7 +381,7 @@ public void onNext(R t) {
             SwitchMapSubscriber<T, R> p = parent;
             if (index == p.unique) {
                 if (fusionMode == QueueSubscription.NONE && !queue.offer(t)) {
-                    onError(new MissingBackpressureException("Queue full?!"));
+                    onError(new QueueOverflowException());
                     return;
                 }
                 p.drain();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.java
Patch:
@@ -96,7 +96,7 @@ public void onNext(T t) {
                 } else {
                     done = true;
                     cancel();
-                    downstream.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));
+                    downstream.onError(MissingBackpressureException.createDefault());
                     return;
                 }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimer.java
Patch:
@@ -78,7 +78,7 @@ public void run() {
                     downstream.onComplete();
                 } else {
                     lazySet(EmptyDisposable.INSTANCE);
-                    downstream.onError(new MissingBackpressureException("Can't deliver value due to lack of requests"));
+                    downstream.onError(MissingBackpressureException.createDefault());
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundary.java
Patch:
@@ -248,7 +248,7 @@ void drain() {
                         } else {
                             SubscriptionHelper.cancel(upstream);
                             boundarySubscriber.dispose();
-                            errors.tryAddThrowableOrReport(new MissingBackpressureException("Could not deliver a window due to lack of requests"));
+                            errors.tryAddThrowableOrReport(MissingBackpressureException.createDefault());
                             done = true;
                         }
                     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundarySelector.java
Patch:
@@ -272,7 +272,7 @@ void drain() {
                                     upstream.cancel();
                                     startSubscriber.cancel();
                                     resources.dispose();
-                                    error.tryAddThrowableOrReport(new MissingBackpressureException(FlowableWindowTimed.missingBackpressureMessage(emitted)));
+                                    error.tryAddThrowableOrReport(FlowableWindowTimed.missingBackpressureMessage(emitted));
                                     upstreamDone = true;
                                 }
                             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ConcatMapXMainSubscriber.java
Patch:
@@ -18,7 +18,7 @@
 import org.reactivestreams.Subscription;
 
 import io.reactivex.rxjava3.core.FlowableSubscriber;
-import io.reactivex.rxjava3.exceptions.MissingBackpressureException;
+import io.reactivex.rxjava3.exceptions.*;
 import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.rxjava3.internal.util.*;
 import io.reactivex.rxjava3.operators.QueueFuseable;
@@ -99,7 +99,7 @@ public final void onNext(T t) {
         if (t != null) {
             if (!queue.offer(t)) {
                 upstream.cancel();
-                onError(new MissingBackpressureException("queue full?!"));
+                onError(new QueueOverflowException());
                 return;
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/parallel/ParallelFromPublisher.java
Patch:
@@ -204,7 +204,7 @@ public void onNext(T t) {
             if (sourceMode == QueueSubscription.NONE) {
                 if (!queue.offer(t)) {
                     upstream.cancel();
-                    onError(new MissingBackpressureException("Queue is full?"));
+                    onError(new QueueOverflowException());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/parallel/ParallelRunOn.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.core.Scheduler.Worker;
-import io.reactivex.rxjava3.exceptions.MissingBackpressureException;
+import io.reactivex.rxjava3.exceptions.*;
 import io.reactivex.rxjava3.internal.schedulers.SchedulerMultiWorkerSupport;
 import io.reactivex.rxjava3.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback;
 import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
@@ -148,7 +148,7 @@ public final void onNext(T t) {
             }
             if (!queue.offer(t)) {
                 upstream.cancel();
-                onError(new MissingBackpressureException("Queue is full?!"));
+                onError(new QueueOverflowException());
                 return;
             }
             schedule();

File: src/main/java/io/reactivex/rxjava3/internal/subscribers/QueueDrainSubscriber.java
Patch:
@@ -84,7 +84,7 @@ protected final void fastPathEmitMax(U value, boolean delayError, Disposable dis
                 }
             } else {
                 dispose.dispose();
-                s.onError(new MissingBackpressureException("Could not emit buffer due to lack of requests"));
+                s.onError(MissingBackpressureException.createDefault());
                 return;
             }
         } else {
@@ -118,7 +118,7 @@ protected final void fastPathOrderedEmitMax(U value, boolean delayError, Disposa
             } else {
                 cancelled = true;
                 dispose.dispose();
-                s.onError(new MissingBackpressureException("Could not emit buffer due to lack of requests"));
+                s.onError(MissingBackpressureException.createDefault());
                 return;
             }
         } else {

File: src/main/java/io/reactivex/rxjava3/internal/util/QueueDrainHelper.java
Patch:
@@ -78,7 +78,7 @@ public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super
                     if (dispose != null) {
                         dispose.dispose();
                     }
-                    a.onError(new MissingBackpressureException("Could not emit value due to lack of requests."));
+                    a.onError(MissingBackpressureException.createDefault());
                     return;
                 }
             }

File: src/main/java/io/reactivex/rxjava3/processors/BehaviorProcessor.java
Patch:
@@ -590,7 +590,7 @@ public boolean test(Object o) {
                 return false;
             }
             cancel();
-            downstream.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));
+            downstream.onError(MissingBackpressureException.createDefault());
             return true;
         }
 

File: src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java
Patch:
@@ -295,7 +295,7 @@ public void onNext(@NonNull T t) {
             ExceptionHelper.nullCheck(t, "onNext called with a null value.");
             if (!queue.offer(t)) {
                 SubscriptionHelper.cancel(upstream);
-                onError(new MissingBackpressureException());
+                onError(MissingBackpressureException.createDefault());
                 return;
             }
         }

File: src/main/java/io/reactivex/rxjava3/processors/PublishProcessor.java
Patch:
@@ -362,7 +362,7 @@ public void onNext(T t) {
                 BackpressureHelper.producedCancel(this, 1);
             } else {
                 cancel();
-                downstream.onError(new MissingBackpressureException("Could not emit value due to lack of requests"));
+                downstream.onError(MissingBackpressureException.createDefault());
             }
         }
 

File: src/test/java/io/reactivex/rxjava3/flowable/FlowableBackpressureTests.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.rxjava3.core.*;
-import io.reactivex.rxjava3.exceptions.MissingBackpressureException;
+import io.reactivex.rxjava3.exceptions.QueueOverflowException;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.rxjava3.internal.util.BackpressureHelper;
@@ -475,7 +475,7 @@ public Integer apply(Integer v) {
         int vc = ts.values().size();
         assertTrue("10 < " + vc, vc <= 10);
 
-        ts.assertError(MissingBackpressureException.class);
+        ts.assertError(QueueOverflowException.class);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/jdk8/FlowableFlatMapStreamTest.java
Patch:
@@ -274,7 +274,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
             }
             .flatMapStream(v -> Stream.of(1, 2), 1)
             .test(0)
-            .assertFailure(MissingBackpressureException.class);
+            .assertFailure(QueueOverflowException.class);
 
             TestHelper.assertUndeliverable(errors, 0, TestException.class);
         });

File: src/test/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcatTest.java
Patch:
@@ -52,9 +52,9 @@ public void subscribe(Subscriber<? super Completable> s) {
                 }), 1
             )
             .test()
-            .assertFailure(MissingBackpressureException.class);
+            .assertFailure(QueueOverflowException.class);
 
-            TestHelper.assertError(errors, 0, MissingBackpressureException.class);
+            TestHelper.assertError(errors, 0, QueueOverflowException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableToIteratorTest.java
Patch:
@@ -152,7 +152,7 @@ public void emptyThrowsNoSuch() {
         it.next();
     }
 
-    @Test(expected = MissingBackpressureException.class)
+    @Test(expected = QueueOverflowException.class)
     public void overflowQueue() {
         Iterator<Integer> it = new Flowable<Integer>() {
             @Override

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapSchedulerTest.java
Patch:
@@ -624,7 +624,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         }
         .concatMap(Functions.justFunction(Flowable.just(2)), 8, ImmediateThinScheduler.INSTANCE)
         .test(0L)
-        .assertFailure(IllegalStateException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -1291,7 +1291,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         }
         .concatMap(Functions.justFunction(Flowable.just(2)), 8)
         .test(0L)
-        .assertFailure(IllegalStateException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapTest.java
Patch:
@@ -1391,7 +1391,7 @@ protected void subscribeActual(@NonNull Subscriber<@NonNull ? super @NonNull Int
         }
         .flatMap(v -> Flowable.just(v), 1)
         .test(0L)
-        .assertFailure(MissingBackpressureException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test
@@ -1413,7 +1413,7 @@ protected void subscribeActual(@NonNull Subscriber<@NonNull ? super @NonNull Int
             }
         })
         .test()
-        .assertFailure(MissingBackpressureException.class, 1);
+        .assertFailure(QueueOverflowException.class, 1);
     }
 
     @Test
@@ -1430,7 +1430,7 @@ protected void subscribeActual(@NonNull Subscriber<@NonNull ? super @NonNull Int
             }
         }, false, 1, 1)
         .test(0L)
-        .assertFailure(MissingBackpressureException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlattenIterableTest.java
Patch:
@@ -814,7 +814,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         }
         .flatMapIterable(Functions.justFunction(Arrays.asList(1)), 1)
         .test(0L)
-        .assertFailure(MissingBackpressureException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromSourceTest.java
Patch:
@@ -137,7 +137,7 @@ public void normalError() {
         ts.assertError(MissingBackpressureException.class);
         ts.assertNotComplete();
 
-        Assert.assertEquals("create: could not emit value due to lack of requests", ts.errors().get(0).getMessage());
+        Assert.assertEquals("create: " + MissingBackpressureException.DEFAULT_MESSAGE, ts.errors().get(0).getMessage());
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOnTest.java
Patch:
@@ -579,13 +579,13 @@ public void onNext(Integer t) {
         assertEquals(1, errors.size());
         System.out.println("Errors: " + errors);
         Throwable t = errors.get(0);
-        if (t instanceof MissingBackpressureException) {
+        if (t instanceof QueueOverflowException) {
             // success, we expect this
         } else {
-            if (t.getCause() instanceof MissingBackpressureException) {
+            if (t.getCause() instanceof QueueOverflowException) {
                 // this is also okay
             } else {
-                fail("Expecting MissingBackpressureException");
+                fail("Expecting QueueOverflowException");
             }
         }
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublishFunctionTest.java
Patch:
@@ -189,7 +189,7 @@ public void overflowMissingBackpressureException() {
         ts.assertError(MissingBackpressureException.class);
         ts.assertNotComplete();
 
-        Assert.assertEquals("Could not emit value due to lack of requests",
+        Assert.assertEquals(MissingBackpressureException.DEFAULT_MESSAGE,
                 ts.errors().get(0).getMessage());
         Assert.assertFalse("Source has subscribers?", pp.hasSubscribers());
     }
@@ -212,7 +212,7 @@ public void overflowMissingBackpressureExceptionDelayed() {
         ts.assertError(MissingBackpressureException.class);
         ts.assertNotComplete();
 
-        Assert.assertEquals("Could not emit value due to lack of requests", ts.errors().get(0).getMessage());
+        Assert.assertEquals(MissingBackpressureException.DEFAULT_MESSAGE, ts.errors().get(0).getMessage());
         Assert.assertFalse("Source has subscribers?", pp.hasSubscribers());
     }
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublishTest.java
Patch:
@@ -905,9 +905,9 @@ public void subscribe(FlowableEmitter<Object> s) throws Exception {
             .test(0L)
             // 3.x emits errors last, even the full queue errors
             .requestMore(10)
-            .assertFailure(MissingBackpressureException.class, 0, 1, 2, 3, 4, 5, 6, 7);
+            .assertFailure(QueueOverflowException.class, 0, 1, 2, 3, 4, 5, 6, 7);
 
-            TestHelper.assertError(errors, 0, MissingBackpressureException.class);
+            TestHelper.assertError(errors, 0, QueueOverflowException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -1596,7 +1596,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         .refCount()
         .test(0)
         .requestMore(1)
-        .assertFailure(MissingBackpressureException.class, 1);
+        .assertFailure(QueueOverflowException.class, 1);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchTest.java
Patch:
@@ -1076,7 +1076,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
             }
         }), 8)
         .test(1L)
-        .assertFailure(MissingBackpressureException.class, 0);
+        .assertFailure(QueueOverflowException.class, 0);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapCompletableTest.java
Patch:
@@ -285,7 +285,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
                     Functions.justFunction(Completable.never()), 1
             )
             .test()
-            .assertFailure(MissingBackpressureException.class);
+            .assertFailure(QueueOverflowException.class);
 
             TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {

File: src/test/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapMaybeTest.java
Patch:
@@ -249,7 +249,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
                     Functions.justFunction(Maybe.never()), 1
             )
             .test()
-            .assertFailure(MissingBackpressureException.class);
+            .assertFailure(QueueOverflowException.class);
 
             TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {

File: src/test/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapSingleTest.java
Patch:
@@ -167,7 +167,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
                     Functions.justFunction(Single.never()), 1
             )
             .test()
-            .assertFailure(MissingBackpressureException.class);
+            .assertFailure(QueueOverflowException.class);
 
             TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {

File: src/test/java/io/reactivex/rxjava3/parallel/ParallelFromPublisherTest.java
Patch:
@@ -50,7 +50,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         .parallel(1, 1)
         .sequential(1)
         .test(0)
-        .assertFailure(MissingBackpressureException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/parallel/ParallelRunOnTest.java
Patch:
@@ -98,7 +98,7 @@ public void subscribe(Subscriber<? super Integer>[] subscribers) {
         .runOn(ImmediateThinScheduler.INSTANCE, 1)
         .sequential(1)
         .test(0)
-        .assertFailure(MissingBackpressureException.class);
+        .assertFailure(QueueOverflowException.class);
     }
 
     @Test

File: src/main/java/io/reactivex/rxjava3/subjects/BehaviorSubject.java
Patch:
@@ -59,9 +59,9 @@
  *
  * TestObserver&lt;Integer&gt; to1 = observable.test();
  *
- * observable.onNext(1);
+ * subject.onNext(1);
  * // this will "clear" the cache
- * observable.onNext(EMPTY);
+ * subject.onNext(EMPTY);
  *
  * TestObserver&lt;Integer&gt; to2 = observable.test();
  *

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.java
Patch:
@@ -45,7 +45,7 @@ protected void subscribeActual(Subscriber<? super U> s) {
     }
 
     static final class BufferExactBoundarySubscriber<T, U extends Collection<? super T>, B>
-    extends QueueDrainSubscriber<T, U, U> implements FlowableSubscriber<T>, Subscription, Disposable {
+    extends QueueDrainSubscriber<T, U, U> implements Subscription, Disposable {
 
         final Supplier<U> bufferSupplier;
         final Publisher<B> boundary;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -244,8 +244,7 @@ public final boolean isEmpty() {
         }
     }
 
-    static final class ObserveOnSubscriber<T> extends BaseObserveOnSubscriber<T>
-    implements FlowableSubscriber<T> {
+    static final class ObserveOnSubscriber<T> extends BaseObserveOnSubscriber<T> {
 
         private static final long serialVersionUID = -4547113800637756442L;
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java
Patch:
@@ -46,7 +46,7 @@ protected void subscribeActual(Subscriber<? super U> s) {
 
     static final class ToListSubscriber<T, U extends Collection<? super T>>
     extends DeferredScalarSubscription<U>
-    implements FlowableSubscriber<T>, Subscription {
+    implements FlowableSubscriber<T> {
 
         private static final long serialVersionUID = -8134157938864266736L;
         Subscription upstream;

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.java
Patch:
@@ -43,7 +43,7 @@ protected void subscribeActual(Observer<? super U> t) {
     }
 
     static final class BufferExactBoundaryObserver<T, U extends Collection<? super T>, B>
-    extends QueueDrainObserver<T, U, U> implements Observer<T>, Disposable {
+    extends QueueDrainObserver<T, U, U> implements Disposable {
 
         final Supplier<U> bufferSupplier;
         final ObservableSource<B> boundary;

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java
Patch:
@@ -26,7 +26,7 @@
  * worker but doesn't perform task-tracking operations.
  *
  */
-public class NewThreadWorker extends Scheduler.Worker implements Disposable {
+public class NewThreadWorker extends Scheduler.Worker {
     private final ScheduledExecutorService executor;
 
     volatile boolean disposed;

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/TrampolineScheduler.java
Patch:
@@ -62,7 +62,7 @@ public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit uni
         return EmptyDisposable.INSTANCE;
     }
 
-    static final class TrampolineWorker extends Scheduler.Worker implements Disposable {
+    static final class TrampolineWorker extends Scheduler.Worker {
         final PriorityBlockingQueue<TimedRunnable> queue = new PriorityBlockingQueue<>();
 
         private final AtomicInteger wip = new AtomicInteger();

File: src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java
Patch:
@@ -560,6 +560,7 @@ public void checkParallelFlowable() {
         for (Class<?> interfaces : AllFunctionals.class.getInterfaces()) {
             defaultValues.put(interfaces, af);
         }
+        defaultValues.put(Subscriber.class, af);
         defaultValues.put(TimeUnit.class, TimeUnit.SECONDS);
         defaultValues.put(Scheduler.class, Schedulers.single());
         defaultValues.put(BackpressureStrategy.class, BackpressureStrategy.MISSING);
@@ -926,7 +927,7 @@ static final class AllFunctionals
     Function3, Function4, Function5, Function6, Function7, Function8, Function9,
     FlowableOnSubscribe, ObservableOnSubscribe, SingleOnSubscribe, MaybeOnSubscribe, CompletableOnSubscribe,
     FlowableTransformer, ObservableTransformer, SingleTransformer, MaybeTransformer, CompletableTransformer,
-    Subscriber, FlowableSubscriber, Observer, SingleObserver, MaybeObserver, CompletableObserver,
+    FlowableSubscriber, Observer, SingleObserver, MaybeObserver, CompletableObserver,
     FlowableOperator, ObservableOperator, SingleOperator, MaybeOperator, CompletableOperator,
     Comparator, ParallelTransformer
     {

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -110,7 +110,7 @@
  * @since 2.0
  * @see io.reactivex.rxjava3.observers.DisposableMaybeObserver
  */
-public abstract class Maybe<T> implements MaybeSource<T> {
+public abstract class Maybe<@NonNull T> implements MaybeSource<T> {
 
     /**
      * Runs multiple {@link MaybeSource}s provided by an {@link Iterable} sequence and

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -5520,7 +5520,6 @@ public final T blockingFirst(@NonNull T defaultItem) {
      * @see #blockingForEach(Consumer, int)
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    @NonNull
     public final void blockingForEach(@NonNull Consumer<? super T> onNext) {
         blockingForEach(onNext, bufferSize());
     }
@@ -5560,7 +5559,6 @@ public final void blockingForEach(@NonNull Consumer<? super T> onNext) {
      * @see #subscribe(Consumer)
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    @NonNull
     public final void blockingForEach(@NonNull Consumer<? super T> onNext, int capacityHint) {
         Objects.requireNonNull(onNext, "onNext is null");
         Iterator<T> it = blockingIterable(capacityHint).iterator();
@@ -12036,7 +12034,6 @@ public final Observable<T> retryWhen(
      * @throws NullPointerException if {@code observer} is {@code null}
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    @NonNull
     public final void safeSubscribe(@NonNull Observer<? super T> observer) {
         Objects.requireNonNull(observer, "observer is null");
         if (observer instanceof SafeObserver) {

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -10148,7 +10148,7 @@ public final Maybe<T> firstElement() {
      * Returns a {@link Single} that emits only the very first item emitted by this {@code Flowable}, or a default
      * item if this {@code Flowable} completes without emitting anything.
      * <p>
-     * <img width="640" height="285" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png" alt="">
+     * <img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.first.s.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator honors backpressure from downstream and consumes the current {@code Flowable} in a bounded manner.</dd>

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -8953,7 +8953,7 @@ public final Maybe<T> firstElement() {
      * Returns a {@link Single} that emits only the very first item emitted by the current {@code Observable}, or a default item
      * if the current {@code Observable} completes without emitting any items.
      * <p>
-     * <img width="640" height="285" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png" alt="">
+     * <img width="640" height="283" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code first} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/test/java/io/reactivex/rxjava3/testsupport/BaseTestConsumerEx.java
Patch:
@@ -160,7 +160,8 @@ public final U assertErrorMessage(String message) {
             Throwable e = errors.get(0);
             String errorMessage = e.getMessage();
             if (!Objects.equals(message, errorMessage)) {
-                throw fail("Error message differs;\nexpected: " + message + "\ngot: " + errorMessage);
+                throw fail("\nexpected: " + message + "\ngot: " + errorMessage
+                + "; Error message differs");
             }
         } else {
             throw fail("Multiple errors");

File: src/test/java/io/reactivex/rxjava3/testsupport/TestObserverEx.java
Patch:
@@ -254,8 +254,8 @@ public final TestObserverEx<T> assertFusionMode(int mode) {
         int m = establishedFusionMode;
         if (m != mode) {
             if (qd != null) {
-                throw new AssertionError("Fusion mode different.\nexpected: " + fusionModeToString(mode)
-                + "\ngot: " + fusionModeToString(m));
+                throw new AssertionError("\nexpected: " + fusionModeToString(mode)
+                + "\ngot: " + fusionModeToString(m) + "; Fusion mode different");
             } else {
                 throw fail("Upstream is not fuseable");
             }

File: src/test/java/io/reactivex/rxjava3/testsupport/TestSubscriberEx.java
Patch:
@@ -317,8 +317,8 @@ public final TestSubscriberEx<T> assertFusionMode(int mode) {
         int m = establishedFusionMode;
         if (m != mode) {
             if (qs != null) {
-                throw new AssertionError("Fusion mode different. Expected: " + fusionModeToString(mode)
-                + ", actual: " + fusionModeToString(m));
+                throw new AssertionError("\nexpected: " + fusionModeToString(mode)
+                + "\ngot: " + fusionModeToString(m) + "; Fusion mode different");
             } else {
                 throw fail("Upstream is not fuseable");
             }

File: src/main/module/module-info.java
Patch:
@@ -16,15 +16,17 @@
     exports io.reactivex.rxjava3.core;
     exports io.reactivex.rxjava3.disposables;
     exports io.reactivex.rxjava3.exceptions;
+    exports io.reactivex.rxjava3.flowables;
     exports io.reactivex.rxjava3.functions;
     exports io.reactivex.rxjava3.observables;
     exports io.reactivex.rxjava3.observers;
+    exports io.reactivex.rxjava3.operators;
     exports io.reactivex.rxjava3.parallel;
     exports io.reactivex.rxjava3.plugins;
     exports io.reactivex.rxjava3.processors;
     exports io.reactivex.rxjava3.schedulers;
     exports io.reactivex.rxjava3.subjects;
     exports io.reactivex.rxjava3.subscribers;
 
-    requires org.reactivestreams;
+    requires transitive org.reactivestreams;
 }
\ No newline at end of file

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -4735,7 +4735,7 @@ public final Disposable subscribe() {
     @CheckReturnValue
     @NonNull
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Disposable subscribe(@NonNull BiConsumer<? super T, ? super Throwable> onCallback) {
+    public final Disposable subscribe(@NonNull BiConsumer<@Nullable ? super T, @Nullable ? super Throwable> onCallback) {
         Objects.requireNonNull(onCallback, "onCallback is null");
 
         BiConsumerSingleObserver<T> observer = new BiConsumerSingleObserver<>(onCallback);

File: src/test/java/io/reactivex/rxjava3/internal/observers/CallbackCompletableObserverTest.java
Patch:
@@ -24,7 +24,7 @@ public final class CallbackCompletableObserverTest extends RxJavaTest {
 
     @Test
     public void emptyActionShouldReportNoCustomOnError() {
-        CallbackCompletableObserver o = new CallbackCompletableObserver(Functions.EMPTY_ACTION);
+        CallbackCompletableObserver o = new CallbackCompletableObserver(Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);
 
         assertFalse(o.hasCustomOnError());
     }

File: src/main/java/io/reactivex/rxjava3/internal/subscriptions/BasicIntQueueSubscription.java
Patch:
@@ -15,14 +15,15 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.internal.fuseable.QueueSubscription;
 
 /**
  * Base class extending AtomicInteger (wip or request accounting) and QueueSubscription (fusion).
  *
  * @param <T> the value type
  */
-public abstract class BasicIntQueueSubscription<T> extends AtomicInteger implements QueueSubscription<T> {
+public abstract class BasicIntQueueSubscription<@NonNull T> extends AtomicInteger implements QueueSubscription<T> {
 
     private static final long serialVersionUID = -6671519529404341862L;
 

File: src/main/java/io/reactivex/rxjava3/internal/subscriptions/DeferredScalarSubscription.java
Patch:
@@ -15,7 +15,7 @@
 
 import org.reactivestreams.Subscriber;
 
-import io.reactivex.rxjava3.annotations.Nullable;
+import io.reactivex.rxjava3.annotations.*;
 
 /**
  * A subscription that signals a single value eventually.
@@ -33,7 +33,7 @@
  * Where exclusively set means any other bits are 0 when that bit is set.
  * @param <T> the value type
  */
-public class DeferredScalarSubscription<T> extends BasicIntQueueSubscription<T> {
+public class DeferredScalarSubscription<@NonNull T> extends BasicIntQueueSubscription<T> {
 
     private static final long serialVersionUID = -2151279923272604993L;
 

File: src/main/java/io/reactivex/rxjava3/subscribers/SafeSubscriber.java
Patch:
@@ -28,7 +28,7 @@
  *
  * @param <T> the value type
  */
-public final class SafeSubscriber<T> implements FlowableSubscriber<T>, Subscription {
+public final class SafeSubscriber<@NonNull T> implements FlowableSubscriber<T>, Subscription {
     /** The actual Subscriber. */
     final Subscriber<? super T> downstream;
     /** The subscription. */

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -10371,7 +10371,7 @@ public final <R> Observable<R> lift(@NonNull ObservableOperator<? extends R, ? s
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
     @NonNull
-    public final <R> Observable<R> map(@NonNull Function<? super T, ? extends R> mapper) {
+    public final <@NonNull R> Observable<R> map(@NonNull Function<? super T, ? extends R> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return RxJavaPlugins.onAssembly(new ObservableMap<>(this, mapper));
     }

File: src/test/java/io/reactivex/rxjava3/schedulers/ExecutorSchedulerTest.java
Patch:
@@ -93,7 +93,7 @@ public void run() {
 
         System.out.println("Wait before second GC");
         System.out.println("JDK 6 purge is N log N because it removes and shifts one by one");
-        int t = (int)(n * Math.log(n) / 100) + SchedulerPoolFactory.PURGE_PERIOD_SECONDS * 1000;
+        int t = (int)(n * Math.log(n) / 100) + 1000;
         int sleepStep = 100;
         while (t > 0) {
             System.out.printf("  >> Waiting for purge: %.2f s remaining%n", t / 1000d);

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java
Patch:
@@ -572,7 +572,7 @@ public void run() {
         }
     }
 
-    /** Observer for listener on seperate thread. */
+    /** Observer for listener on separate thread. */
     static final class AsyncObserver<T> extends DefaultObserver<T> {
 
         protected CountDownLatch latch = new CountDownLatch(1);

File: src/main/java/io/reactivex/rxjava3/core/CompletableOnSubscribe.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives
- * an instance of a {@link CompletableEmitter} instance that allows pushing
+ * a {@link CompletableEmitter} instance that allows pushing
  * an event in a cancellation-safe manner.
  */
 @FunctionalInterface

File: src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives
- * an instance of a {@link FlowableEmitter} instance that allows pushing
+ * a {@link FlowableEmitter} instance that allows pushing
  * events in a backpressure-safe and cancellation-safe manner.
  *
  * @param <T> the value type pushed

File: src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives
- * an instance of a {@link MaybeEmitter} instance that allows pushing
+ * a {@link MaybeEmitter} instance that allows pushing
  * an event in a cancellation-safe manner.
  *
  * @param <T> the value type pushed

File: src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives
- * an instance of an {@link ObservableEmitter} instance that allows pushing
+ * an {@link ObservableEmitter} instance that allows pushing
  * events in a cancellation-safe manner.
  *
  * @param <T> the value type pushed

File: src/main/java/io/reactivex/rxjava3/core/SingleOnSubscribe.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives
- * an instance of a {@link SingleEmitter} instance that allows pushing
+ * a {@link SingleEmitter} instance that allows pushing
  * an event in a cancellation-safe manner.
  *
  * @param <T> the value type pushed

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -52,7 +52,7 @@
  * Note that as with the {@code Observable} protocol, {@code onError} and {@code onComplete} are mutually exclusive events.
  * <p>
  * Like {@code Observable}, a running {@code Completable} can be stopped through the {@link Disposable} instance
- * provided to consumers through {@link SingleObserver#onSubscribe}.
+ * provided to consumers through {@link CompletableObserver#onSubscribe}.
  * <p>
  * Like an {@code Observable}, a {@code Completable} is lazy, can be either "hot" or "cold", synchronous or
  * asynchronous. {@code Completable} instances returned by the methods of this class are <em>cold</em>

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -621,7 +621,7 @@ public void run() {
         }
     }
 
-    /** Observer for listener on seperate thread. */
+    /** Observer for listener on separate thread. */
     static final class AsyncSubscriber<T> extends DefaultSubscriber<T> {
 
         protected CountDownLatch latch = new CountDownLatch(1);

File: src/test/java/io/reactivex/rxjava3/subjects/UnicastSubjectTest.java
Patch:
@@ -481,9 +481,7 @@ public void fusedNoConcurrentCleanDueToCancel() {
                     us.onNext(i);
                 }
 
-                to
-                .awaitDone(5, TimeUnit.SECONDS)
-                ;
+                to.awaitDone(10, TimeUnit.SECONDS);
 
                 if (!errors.isEmpty()) {
                     throw new CompositeException(errors);

File: src/main/java/io/reactivex/rxjava3/core/Notification.java
Patch:
@@ -26,7 +26,9 @@ public final class Notification<T> {
 
     final Object value;
 
-    /** Not meant to be implemented externally. */
+    /** Not meant to be implemented externally.
+     * @param value the value to carry around in the notification, not {@code null}
+     */
     private Notification(@Nullable Object value) {
         this.value = value;
     }

File: src/main/java/io/reactivex/rxjava3/exceptions/CompositeException.java
Patch:
@@ -229,7 +229,9 @@ private void appendStackTrace(StringBuilder b, Throwable ex, String prefix) {
     }
 
     abstract static class PrintStreamOrWriter {
-        /** Prints the specified string as a line on this StreamOrWriter. */
+        /** Prints the specified string as a line on this StreamOrWriter.
+         * @param o string to print
+         */
         abstract void println(Object o);
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ScalarXMapZHelper.java
Patch:
@@ -78,6 +78,7 @@ static <T> boolean tryAsCompletable(Object source,
      * Try subscribing to a {@link MaybeSource} mapped from
      * a scalar source (which implements {@link Supplier}).
      * @param <T> the upstream value type
+     * @param <R> the downstream value type
      * @param source the source reactive type ({@code Flowable} or {@code Observable})
      *               possibly implementing {@link Supplier}.
      * @param mapper the function that turns the scalar upstream value into a
@@ -117,6 +118,7 @@ static <T, R> boolean tryAsMaybe(Object source,
      * Try subscribing to a {@link SingleSource} mapped from
      * a scalar source (which implements {@link Supplier}).
      * @param <T> the upstream value type
+     * @param <R> the downstream value type
      * @param source the source reactive type ({@code Flowable} or {@code Observable})
      *               possibly implementing {@link Supplier}.
      * @param mapper the function that turns the scalar upstream value into a

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReplay.java
Patch:
@@ -122,6 +122,7 @@ public static <T> ConnectableObservable<T> create(ObservableSource<T> source,
 
     /**
      * Creates a OperatorReplay instance to replay values of the given source observable.
+     * @param <T> the value type
      * @param source the source observable
      * @param bufferFactory the factory to instantiate the appropriate buffer when the observable becomes active
      * @return the connectable observable
@@ -453,6 +454,7 @@ public void dispose() {
         }
         /**
          * Convenience method to auto-cast the index object.
+         * @param <U> type index to be casted to
          * @return the index Object or null
          */
         @SuppressWarnings("unchecked")

File: src/main/java/io/reactivex/rxjava3/internal/util/QueueDrainHelper.java
Patch:
@@ -291,6 +291,7 @@ static boolean isCancelled(BooleanSupplier cancelled) {
     /**
      * Drains the queue based on the outstanding requests in post-completed mode (only!).
      *
+     * @param <T> the value type
      * @param n the current request amount
      * @param actual the target Subscriber to send events to
      * @param queue the queue to drain if in the post-complete state

File: src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java
Patch:
@@ -54,6 +54,9 @@ public abstract class BaseTestConsumer<T, U extends BaseTestConsumer<T, U>> {
      */
     protected boolean timeout;
 
+    /**
+     * Constructs a {@code BaseTestConsumer} with {@code CountDownLatch} set to 1.
+     */
     public BaseTestConsumer() {
         this.values = new VolatileSizeArrayList<>();
         this.errors = new VolatileSizeArrayList<>();

File: src/test/java/io/reactivex/rxjava3/exceptions/CompositeExceptionTest.java
Patch:
@@ -148,7 +148,7 @@ public void compositeExceptionFromTwoDuplicateComposites() {
         cex.getCause().printStackTrace();
     }
 
-    /**
+    /*
      * This hijacks the Throwable.printStackTrace() output and puts it in a string, where we can look for
      * "CIRCULAR REFERENCE" (a String added by Throwable.printEnclosedStackTrace)
      */

File: src/test/java/io/reactivex/rxjava3/schedulers/SchedulerTestHelper.java
Patch:
@@ -28,6 +28,8 @@ private SchedulerTestHelper() {
     /**
      * Verifies that the given Scheduler does not deliver handled errors to its executing Thread's
      * {@link java.lang.Thread.UncaughtExceptionHandler}.
+     *
+     * @param scheduler {@link Scheduler} to verify.
      */
     static void handledErrorIsNotDeliveredToThreadHandler(Scheduler scheduler) throws InterruptedException {
         Thread.UncaughtExceptionHandler originalHandler = Thread.getDefaultUncaughtExceptionHandler();

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -5687,7 +5687,7 @@ public final <R> Flowable<R> flattenStreamAsFlowable(@NonNull Function<? super T
      * <p>
      * The operator closes the {@code Stream} upon cancellation and when it terminates. The exceptions raised when
      * closing a {@code Stream} are routed to the global error handler ({@link RxJavaPlugins#onError(Throwable)}.
-     * If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #flattenAsFlowable(Function)}:
+     * If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #flattenAsObservable(Function)}:
      * <pre><code>
      * source.flattenAsObservable(item -&gt; createStream(item)::iterator);
      * </code></pre>

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java
Patch:
@@ -58,7 +58,7 @@ public Disposable scheduleDirect(@NonNull Runnable run) {
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             if (executor instanceof ExecutorService) {
-                ScheduledDirectTask task = new ScheduledDirectTask(decoratedRun);
+                ScheduledDirectTask task = new ScheduledDirectTask(decoratedRun, interruptibleWorker);
                 Future<?> f = ((ExecutorService)executor).submit(task);
                 task.setFuture(f);
                 return task;
@@ -85,7 +85,7 @@ public Disposable scheduleDirect(@NonNull Runnable run, final long delay, final
         final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         if (executor instanceof ScheduledExecutorService) {
             try {
-                ScheduledDirectTask task = new ScheduledDirectTask(decoratedRun);
+                ScheduledDirectTask task = new ScheduledDirectTask(decoratedRun, interruptibleWorker);
                 Future<?> f = ((ScheduledExecutorService)executor).schedule(task, delay, unit);
                 task.setFuture(f);
                 return task;
@@ -110,7 +110,7 @@ public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initial
         if (executor instanceof ScheduledExecutorService) {
             Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
             try {
-                ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun);
+                ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun, interruptibleWorker);
                 Future<?> f = ((ScheduledExecutorService)executor).scheduleAtFixedRate(task, initialDelay, period, unit);
                 task.setFuture(f);
                 return task;

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java
Patch:
@@ -59,7 +59,7 @@ public Disposable schedule(@NonNull final Runnable action, long delayTime, @NonN
      * @return the ScheduledRunnable instance
      */
     public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) {
-        ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run));
+        ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run), true);
         try {
             Future<?> f;
             if (delayTime <= 0L) {
@@ -104,7 +104,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
 
             return periodicWrapper;
         }
-        ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun);
+        ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun, true);
         try {
             Future<?> f = executor.scheduleAtFixedRate(task, initialDelay, period, unit);
             task.setFuture(f);

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledDirectPeriodicTask.java
Patch:
@@ -24,8 +24,8 @@ public final class ScheduledDirectPeriodicTask extends AbstractDirectTask implem
 
     private static final long serialVersionUID = 1811839108042568751L;
 
-    public ScheduledDirectPeriodicTask(Runnable runnable) {
-        super(runnable);
+    public ScheduledDirectPeriodicTask(Runnable runnable, boolean interruptOnCancel) {
+        super(runnable, interruptOnCancel);
     }
 
     @Override

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledDirectTask.java
Patch:
@@ -26,8 +26,8 @@ public final class ScheduledDirectTask extends AbstractDirectTask implements Cal
 
     private static final long serialVersionUID = 1811839108042568751L;
 
-    public ScheduledDirectTask(Runnable runnable) {
-        super(runnable);
+    public ScheduledDirectTask(Runnable runnable, boolean interruptOnCancel) {
+        super(runnable, interruptOnCancel);
     }
 
     @Override

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/SingleScheduler.java
Patch:
@@ -106,7 +106,7 @@ public Worker createWorker() {
     @NonNull
     @Override
     public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) {
-        ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run));
+        ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run), true);
         try {
             Future<?> f;
             if (delay <= 0L) {
@@ -146,7 +146,7 @@ public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initial
 
             return periodicWrapper;
         }
-        ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun);
+        ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun, true);
         try {
             Future<?> f = executor.get().scheduleAtFixedRate(task, initialDelay, period, unit);
             task.setFuture(f);

File: src/test/java/io/reactivex/rxjava3/internal/operators/completable/CompletableTimerTest.java
Patch:
@@ -37,7 +37,7 @@ public void dispose() {
     public void timerInterruptible() throws Exception {
         ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
         try {
-            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
+            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                 final AtomicBoolean interrupted = new AtomicBoolean();
                 TestObserver<Void> to = Completable.timer(1, TimeUnit.MILLISECONDS, s)
                 .doOnComplete(new Action() {

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimerTest.java
Patch:
@@ -352,7 +352,7 @@ public void timerDelayZero() {
     public void timerInterruptible() throws Exception {
         ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
         try {
-            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
+            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                 final AtomicBoolean interrupted = new AtomicBoolean();
                 TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)
                 .map(new Function<Long, Long>() {

File: src/test/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTimerTest.java
Patch:
@@ -37,7 +37,7 @@ public void dispose() {
     public void timerInterruptible() throws Exception {
         ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
         try {
-            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
+            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                 final AtomicBoolean interrupted = new AtomicBoolean();
                 TestObserver<Long> to = Maybe.timer(1, TimeUnit.MILLISECONDS, s)
                 .map(new Function<Long, Long>() {

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimerTest.java
Patch:
@@ -317,7 +317,7 @@ public void timerDelayZero() {
     public void timerInterruptible() throws Exception {
         ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
         try {
-            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
+            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                 final AtomicBoolean interrupted = new AtomicBoolean();
                 TestObserver<Long> to = Observable.timer(1, TimeUnit.MILLISECONDS, s)
                 .map(new Function<Long, Long>() {

File: src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleTimerTest.java
Patch:
@@ -37,7 +37,7 @@ public void disposed() {
     public void timerInterruptible() throws Exception {
         ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
         try {
-            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
+            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                 final AtomicBoolean interrupted = new AtomicBoolean();
                 TestObserver<Long> to = Single.timer(1, TimeUnit.MILLISECONDS, s)
                 .map(new Function<Long, Long>() {

File: src/test/java/io/reactivex/rxjava3/internal/schedulers/ScheduledDirectPeriodicTaskTest.java
Patch:
@@ -35,7 +35,7 @@ public void runnableThrows() {
                 public void run() {
                     throw new TestException();
                 }
-            });
+            }, true);
 
             try {
                 task.run();

File: src/jmh/java/io/reactivex/rxjava3/core/BinaryFlatMapPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/BlockingGetPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/BlockingPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/CallableAsyncPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/EachTypeFlatMapPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/FlatMapJustPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenCrossMapPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenJustPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenRangePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/FlowableFlatMapCompletableAsyncPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/FlowableFlatMapCompletableSyncPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/JustAsyncPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/LatchedSingleObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/MemoryPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/ObservableFlatMapPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/OperatorFlatMapPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/OperatorMergePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PerfAsyncConsumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PerfBoundedSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PerfConsumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PerfInteropConsumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PerfObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PerfSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/PublishProcessorPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/RangePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/ReducePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/RxVsStreamPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/StrictPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/TakeUntilPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/ToFlowablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/core/XMapYPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/parallel/ParallelPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -109,4 +109,4 @@ public void groupBy(Blackhole bh) {
     public void parallel(Blackhole bh) {
         subscribe(parallel, bh);
     }
-}
\ No newline at end of file
+}

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapCompletablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapMaybeEmptyPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapMaybePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapSinglePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapCompletablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapMaybeEmptyPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapMaybePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapSinglePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapCompletablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapMaybeEmptyPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapMaybePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapSinglePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapCompletablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapMaybeEmptyPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapMaybePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapSinglePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapCompletablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapMaybeEmptyPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapMaybePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapSinglePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapCompletablePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapMaybeEmptyPerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapMaybePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapSinglePerf.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/BackpressureKind.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/BackpressureSupport.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/Beta.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/CheckReturnValue.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/Experimental.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/NonNull.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/Nullable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/annotations/SchedulerSupport.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/BackpressureStrategy.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/core/CompletableConverter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/CompletableEmitter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/CompletableObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/CompletableOnSubscribe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/CompletableOperator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/CompletableSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/CompletableTransformer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Emitter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/core/FlowableConverter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/FlowableEmitter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/FlowableOperator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/FlowableTransformer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/MaybeConverter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/MaybeEmitter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/MaybeObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/MaybeOperator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/MaybeSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/MaybeTransformer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Notification.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/ObservableConverter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/ObservableEmitter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/ObservableOperator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/ObservableSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/ObservableTransformer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Observer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Scheduler.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/SingleConverter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/SingleEmitter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/SingleObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/SingleOnSubscribe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/SingleOperator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/core/SingleSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.core;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/core/SingleTransformer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/disposables/ActionDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.disposables;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/disposables/AutoCloseableDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/disposables/CompositeDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.disposables;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/disposables/Disposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.disposables;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/disposables/DisposableContainer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/disposables/FutureDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.disposables;
 
 import java.util.concurrent.Future;

File: src/main/java/io/reactivex/rxjava3/disposables/ReferenceDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/disposables/RunnableDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.disposables;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/disposables/SerialDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/disposables/SubscriptionDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.disposables;
 
 import org.reactivestreams.Subscription;

File: src/main/java/io/reactivex/rxjava3/exceptions/Exceptions.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/exceptions/MissingBackpressureException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/exceptions/OnErrorNotImplementedException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -50,4 +50,4 @@ public OnErrorNotImplementedException(String message, @NonNull Throwable e) {
     public OnErrorNotImplementedException(@NonNull Throwable e) {
         this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + e, e);
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/rxjava3/exceptions/ProtocolViolationException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/exceptions/UndeliverableException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/flowables/ConnectableFlowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/flowables/GroupedFlowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.flowables;
 
 import io.reactivex.rxjava3.annotations.Nullable;

File: src/main/java/io/reactivex/rxjava3/functions/Action.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/BiConsumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/BiFunction.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/BiPredicate.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/BooleanSupplier.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Cancellable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Consumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function3.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function4.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function5.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function6.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function7.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function8.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Function9.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/IntFunction.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.functions;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/functions/LongConsumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.functions;
 
 /**

File: src/main/java/io/reactivex/rxjava3/functions/Predicate.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/functions/Supplier.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/disposables/ArrayCompositeDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/disposables/CancellableDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/disposables/DisposableHelper.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/disposables/EmptyDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/disposables/ListCompositeDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.disposables;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/internal/disposables/SequentialDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.functions;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/internal/functions/ObjectHelper.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.functions;
 
 import io.reactivex.rxjava3.functions.BiPredicate;

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/AbstractEmptyQueueFuseable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -73,4 +73,4 @@ public void dispose() {
     public boolean isDisposed() {
         return false;
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/CancellableQueueFuseable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -39,4 +39,4 @@ public void dispose() {
     public boolean isDisposed() {
         return disposed;
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/ConditionalSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToFlowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToMaybe.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToObservable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamCompletableSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamMaybeSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamObservableSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamPublisher.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamSingleSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.fuseable;
 
 import java.util.Queue;

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueFuseable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueSubscription.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.fuseable;
 
 import java.util.Queue;

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/ScalarSupplier.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.fuseable;
 
 import io.reactivex.rxjava3.annotations.NonNull;

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/SimplePlainQueue.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/SimpleQueue.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/package-info.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/CompletableFromCompletionStage.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletionStage;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/CompletionStageConsumer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollector.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.Objects;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollectorSingle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.Objects;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFirstStageSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFlatMapStream.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFromCompletionStage.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletionStage;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFromStream.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.Iterator;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableLastStageSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableMapOptional.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableSingleStageSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableStageSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletableFuture;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeFlattenStreamAsFlowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeFlattenStreamAsObservable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeFromCompletionStage.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletionStage;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeMapOptional.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollector.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.Objects;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollectorSingle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.Objects;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFirstStageObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFlatMapStream.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFromCompletionStage.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletionStage;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFromStream.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableLastStageObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableMapOptional.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.*;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableSingleStageObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.NoSuchElementException;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableStageObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletableFuture;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ParallelCollector.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ParallelFlatMapStream.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ParallelMapOptional.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ParallelMapTryOptional.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleFlattenStreamAsFlowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleFlattenStreamAsObservable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleFromCompletionStage.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.jdk8;
 
 import java.util.concurrent.CompletionStage;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleMapOptional.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BasicFuseableObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BasicIntQueueDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BasicQueueDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BiConsumerSingleObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingBaseObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.observers;
 
 import java.util.concurrent.CountDownLatch;

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingDisposableMultiObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingFirstObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingLastObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingMultiObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/CallbackCompletableObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/ConsumerSingleObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/DeferredScalarDisposable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/DeferredScalarObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/DisposableLambdaObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/EmptyCompletableObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/ForEachWhileObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/FutureMultiObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/FutureObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/InnerQueuedObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/InnerQueuedObserverSupport.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/LambdaObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/QueueDrainObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/ResumeSingleObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/SafeCompletableObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/SafeMaybeObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/observers/SafeSingleObserver.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableAmb.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableAndThenCompletable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableCache.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcat.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcatArray.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcatIterable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableCreate.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableDefer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableDelay.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableDetach.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableDisposeOn.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableDoFinally.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableDoOnEvent.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableEmpty.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableError.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableErrorSupplier.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromAction.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromCallable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromPublisher.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromRunnable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromSupplier.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromUnsafeSource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableHide.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableLift.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMaterialize.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMerge.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeArray.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeArrayDelayError.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeDelayErrorIterable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeIterable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableNever.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableObserveOn.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableOnErrorComplete.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableOnErrorReturn.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletablePeek.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableResumeNext.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableSubscribeOn.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableTakeUntilCompletable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableTimeout.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableTimer.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToFlowable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToObservable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToSingle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableUsing.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/AbstractBackpressureThrottlingSubscriber.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/AbstractFlowableWithUpstream.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableLatest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableNext.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAll.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.operators.flowable;
 
 import org.reactivestreams.*;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAllSingle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.operators.flowable;
 
 import org.reactivestreams.Subscription;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAmb.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAny.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.operators.flowable;
 
 import org.reactivestreams.*;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAnySingle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
@@ -10,6 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
+
 package io.reactivex.rxjava3.internal.operators.flowable;
 
 import org.reactivestreams.Subscription;

File: src/main/java/io/reactivex/rxjava3/schedulers/Schedulers.java
Patch:
@@ -367,7 +367,7 @@ public static Scheduler single() {
      * because such circumstances prevent RxJava from progressing flow-related activities correctly.
      * If the {@link Executor#execute(Runnable)} or {@link ExecutorService#submit(Callable)} throws,
      * the {@code RejectedExecutionException} is routed to the global error handler via
-     * {@link RxJavaPlugins#onError(Throwable)}. To avoid shutdown-reladed problems, it is recommended
+     * {@link RxJavaPlugins#onError(Throwable)}. To avoid shutdown-related problems, it is recommended
      * all flows using the returned {@code Scheduler} to be canceled/disposed before the underlying
      * {@code Executor} is shut down. To avoid problems due to the {@code Executor} having a bounded-queue,
      * it is recommended to rephrase the flow to utilize backpressure as the means to limit outstanding work.
@@ -441,7 +441,7 @@ public static Scheduler from(@NonNull Executor executor) {
      * because such circumstances prevent RxJava from progressing flow-related activities correctly.
      * If the {@link Executor#execute(Runnable)} or {@link ExecutorService#submit(Callable)} throws,
      * the {@code RejectedExecutionException} is routed to the global error handler via
-     * {@link RxJavaPlugins#onError(Throwable)}. To avoid shutdown-reladed problems, it is recommended
+     * {@link RxJavaPlugins#onError(Throwable)}. To avoid shutdown-related problems, it is recommended
      * all flows using the returned {@code Scheduler} to be canceled/disposed before the underlying
      * {@code Executor} is shut down. To avoid problems due to the {@code Executor} having a bounded-queue,
      * it is recommended to rephrase the flow to utilize backpressure as the means to limit outstanding work.
@@ -521,7 +521,7 @@ public static Scheduler from(@NonNull Executor executor, boolean interruptibleWo
      * because such circumstances prevent RxJava from progressing flow-related activities correctly.
      * If the {@link Executor#execute(Runnable)} or {@link ExecutorService#submit(Callable)} throws,
      * the {@code RejectedExecutionException} is routed to the global error handler via
-     * {@link RxJavaPlugins#onError(Throwable)}. To avoid shutdown-reladed problems, it is recommended
+     * {@link RxJavaPlugins#onError(Throwable)}. To avoid shutdown-related problems, it is recommended
      * all flows using the returned {@code Scheduler} to be canceled/disposed before the underlying
      * {@code Executor} is shut down. To avoid problems due to the {@code Executor} having a bounded-queue,
      * it is recommended to rephrase the flow to utilize backpressure as the means to limit outstanding work.

File: src/main/java/io/reactivex/rxjava3/schedulers/Schedulers.java
Patch:
@@ -40,6 +40,8 @@
  * <li>{@code rx3.single-priority} (int): sets the thread priority of the {@link #single()} {@code Scheduler}, default is {@link Thread#NORM_PRIORITY}</li>
  * <li>{@code rx3.purge-enabled} (boolean): enables periodic purging of all {@code Scheduler}'s backing thread pools, default is {@code false}</li>
  * <li>{@code rx3.purge-period-seconds} (int): specifies the periodic purge interval of all {@code Scheduler}'s backing thread pools, default is 1 second</li>
+ * <li>{@code rx3.scheduler.use-nanotime} (boolean): {@code true} instructs {@code Scheduler} to use {@link System#nanoTime()} for {@link Scheduler#now(TimeUnit)},
+ * instead of default {@link System#currentTimeMillis()} ({@code false})</li>
  * </ul>
  */
 public final class Schedulers {

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -14677,7 +14677,7 @@ public final <U> Flowable<T> sample(@NonNull Publisher<U> sampler, boolean emitL
     /**
      * Returns a {@code Flowable} that emits the first value emitted by the current {@code Flowable}, then emits one value
      * for each subsequent value emitted by the current {@code Flowable}. Each emission after the first is the result of
-     * applying the specified accumulator function to the previous emission and the corresponding value from the current @{code Flowable}.
+     * applying the specified accumulator function to the previous emission and the corresponding value from the current {@code Flowable}.
      * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scan.v3.png" alt="">
      * <p>
@@ -14710,7 +14710,7 @@ public final Flowable<T> scan(@NonNull BiFunction<T, T, T> accumulator) {
     /**
      * Returns a {@code Flowable} that emits the provided initial (seed) value, then emits one value for each value emitted
      * by the current {@code Flowable}. Each emission after the first is the result of applying the specified accumulator
-     * function to the previous emission and the corresponding value from the current @{code Flowable}.
+     * function to the previous emission and the corresponding value from the current {@code Flowable}.
      * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.v3.png" alt="">
      * <p>
@@ -14763,7 +14763,7 @@ public final Flowable<T> scan(@NonNull BiFunction<T, T, T> accumulator) {
     /**
      * Returns a {@code Flowable} that emits the provided initial (seed) value, then emits one value for each value emitted
      * by the current {@code Flowable}. Each emission after the first is the result of applying the specified accumulator
-     * function to the previous emission and the corresponding value from the current @{code Flowable}.
+     * function to the previous emission and the corresponding value from the current {@code Flowable}.
      * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.v3.png" alt="">
      * <p>

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -12204,7 +12204,7 @@ public final <U> Observable<T> sample(@NonNull ObservableSource<U> sampler, bool
     /**
      * Returns an {@code Observable} that emits the first value emitted by the current {@code Observable}, then emits one value
      * for each subsequent value emitted by the current {@code Observable}. Each emission after the first is the result of
-     * applying the specified accumulator function to the previous emission and the corresponding value from the current @{code Observable}.
+     * applying the specified accumulator function to the previous emission and the corresponding value from the current {@code Observable}.
      * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scan.v3.png" alt="">
      * <p>
@@ -12233,7 +12233,7 @@ public final Observable<T> scan(@NonNull BiFunction<T, T, T> accumulator) {
     /**
      * Returns an {@code Observable} that emits the provided initial (seed) value, then emits one value for each value emitted
      * by the current {@code Observable}. Each emission after the first is the result of applying the specified accumulator
-     * function to the previous emission and the corresponding value from the current @{code Observable}.
+     * function to the previous emission and the corresponding value from the current {@code Observable}.
      * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.v3.png" alt="">
      * <p>
@@ -12282,7 +12282,7 @@ public final <R> Observable<R> scan(@NonNull R initialValue, @NonNull BiFunction
     /**
      * Returns an {@code Observable} that emits the provided initial (seed) value, then emits one value for each value emitted
      * by the current {@code Observable}. Each emission after the first is the result of applying the specified accumulator
-     * function to the previous emission and the corresponding value from the current @{code Observable}.
+     * function to the previous emission and the corresponding value from the current {@code Observable}.
      * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.v3.png" alt="">
      * <p>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.java
Patch:
@@ -345,7 +345,7 @@ public void run() {
                                 continue;
                             } else {
                                 active = true;
-                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));
+                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));
                             }
 
                         } else {
@@ -528,7 +528,7 @@ public void run() {
                                 continue;
                             } else {
                                 active = true;
-                                inner.setSubscription(new WeakScalarSubscription<>(vr, inner));
+                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));
                             }
                         } else {
                             active = true;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java
Patch:
@@ -65,6 +65,7 @@ public void onNext(T t) {
                 downstream.onNext(t);
                 BackpressureHelper.produced(this, 1);
             } else {
+                upstream.cancel();
                 onError(new MissingBackpressureException("could not emit value due to lack of requests"));
             }
         }

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -12770,7 +12770,7 @@ public final Flowable<T> onErrorResumeNext(@NonNull Function<? super Throwable,
      * Resumes the flow with the given {@link Publisher} when the current {@code Flowable} fails instead of
      * signaling the error via {@code onError}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.v3.png" alt="">
+     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeWith.v3.png" alt="">
      * <p>
      * By default, when a {@code Publisher} encounters an error that prevents it from emitting the expected item to
      * its {@link Subscriber}, the {@code Publisher} invokes its {@code Subscriber}'s {@code onError} method, and then quits

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -10691,7 +10691,7 @@ public final Observable<T> onErrorResumeNext(@NonNull Function<? super Throwable
      * Resumes the flow with the given {@link ObservableSource} when the current {@code Observable} fails instead of
      * signaling the error via {@code onError}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.v3.png" alt="">
+     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeWith.v3.png" alt="">
      * <p>
      * By default, when an {@code ObservableSource} encounters an error that prevents it from emitting the expected item to
      * its {@link Observer}, the {@code ObservableSource} invokes its {@code Observer}'s {@code onError} method, and then quits

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java
Patch:
@@ -2667,7 +2667,7 @@ public void issue6974Part2Case2Loop() {
 
     static void issue6974RunPart2NoEvict(int groupByBufferSize, int flatMapMaxConcurrency, int groups,
             boolean notifyOnExplicitEviction) {
-    	
+
         Flowable
         .range(1, 500_000)
         .map(i -> i % groups)

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoinTest.java
Patch:
@@ -79,7 +79,7 @@ public Integer apply(Integer rightValue) throws Throwable {
 
     @Before
     public void before() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoinTest.java
Patch:
@@ -55,7 +55,7 @@ public Flowable<T> apply(Integer t1) {
 
     @Before
     public void before() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoinTest.java
Patch:
@@ -81,7 +81,7 @@ public Integer apply(Integer rightValue) throws Throwable {
 
     @Before
     public void before() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableJoinTest.java
Patch:
@@ -54,7 +54,7 @@ public Observable<T> apply(Integer t1) {
 
     @Before
     public void before() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/testsupport/SuppressUndeliverableRule.java
Patch:
@@ -30,11 +30,10 @@
  */
 public class SuppressUndeliverableRule implements TestRule {
 
-    private static class SuppressUndeliverableRuleStatement extends Statement {
+    static final class SuppressUndeliverableRuleStatement extends Statement {
         private Statement base;
 
-        private SuppressUndeliverableRuleStatement(){}
-        public SuppressUndeliverableRuleStatement(Statement base) {
+        SuppressUndeliverableRuleStatement(Statement base) {
             this.base = base;
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/InstantPeriodicTask.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.internal.functions.Functions;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
@@ -54,12 +53,13 @@ public Void call() {
         runner = Thread.currentThread();
         try {
             task.run();
-            setRest(executor.submit(this));
             runner = null;
+            setRest(executor.submit(this));
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
+            // Exceptions.throwIfFatal(ex); nowhere to go
             runner = null;
             RxJavaPlugins.onError(ex);
+            throw ex;
         }
         return null;
     }

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledDirectPeriodicTask.java
Patch:
@@ -16,7 +16,6 @@
 
 package io.reactivex.rxjava3.internal.schedulers;
 
-import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -39,10 +38,11 @@ public void run() {
             runnable.run();
             runner = null;
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
+            // Exceptions.throwIfFatal(ex); nowhere to go
             runner = null;
-            lazySet(FINISHED);
+            dispose();
             RxJavaPlugins.onError(ex);
+            throw ex;
         }
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java
Patch:
@@ -66,6 +66,7 @@ public void run() {
             } catch (Throwable e) {
                 // Exceptions.throwIfFatal(e); nowhere to go
                 RxJavaPlugins.onError(e);
+                throw e;
             }
         } finally {
             lazySet(THREAD_INDEX, null);

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToFlowable.java
Patch:
@@ -21,7 +21,7 @@
  * the operator goes from Flowable to some other reactive type and then the sequence calls
  * for toFlowable again:
  * <pre>
- * {@code 
+ * {@code
  * Single<Integer> single = Flowable.range(1, 10).reduce((a, b) -> a + b);
  * Flowable<Integer> flowable = single.toFlowable();
  * }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToMaybe.java
Patch:
@@ -21,7 +21,7 @@
  * the operator goes from Maybe to some other reactive type and then the sequence calls
  * for toMaybe again:
  * <pre>
- * {@code 
+ * {@code
  * Single<Integer> single = Maybe.just(1).isEmpty();
  * Maybe<Integer> maybe = single.toMaybe();
  * }

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/SchedulerWhen.java
Patch:
@@ -53,7 +53,7 @@
  * thread pool:
  *
  * <pre>
- * {@code 
+ * {@code
  * Scheduler limitScheduler = Schedulers.computation().when(workers -> {
  *  // use merge max concurrent to limit the number of concurrent
  *  // callbacks two at a time
@@ -73,7 +73,7 @@
  * to the second.
  *
  * <pre>
- * {@code 
+ * {@code
  * Scheduler limitScheduler = Schedulers.computation().when(workers -> {
  *  // use merge max concurrent to limit the number of concurrent
  *  // Observables two at a time
@@ -88,7 +88,7 @@
  * algorithm).
  *
  * <pre>
- * {@code 
+ * {@code
  * Scheduler slowScheduler = Schedulers.computation().when(workers -> {
  *  // use concatenate to make each worker happen one at a time.
  *  return Completable.concat(workers.map(actions -> {

File: src/test/java/io/reactivex/rxjava3/observers/SerializedObserverTest.java
Patch:
@@ -1042,7 +1042,8 @@ public void run() {
                 }
             };
 
-            TestHelper.race(r1, r2);       
+            TestHelper.race(r1, r2);
+
             to.awaitDone(5, TimeUnit.SECONDS)
             .assertError(ex)
             .assertNotComplete();

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableNextTest.java
Patch:
@@ -223,8 +223,8 @@ public void nextWithCallingHasNextMultipleTimes() {
 
     /**
      * Confirm that no buffering or blocking of the Observable onNext calls occurs and it just grabs the next emitted value.
-     * <p/>
-     * This results in output such as => a: 1 b: 2 c: 89
+     * <p>
+     * This results in output such as {@code => a: 1 b: 2 c: 89}
      *
      * @throws Throwable some method call is declared throws
      */

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java
Patch:
@@ -227,8 +227,8 @@ public void nextWithCallingHasNextMultipleTimes() {
 
     /**
      * Confirm that no buffering or blocking of the Observable onNext calls occurs and it just grabs the next emitted value.
-     * <p/>
-     * This results in output such as => a: 1 b: 2 c: 89
+     * <p>
+     * This results in output such as {@code => a: 1 b: 2 c: 89}
      *
      * @throws Throwable some method call is declared throws
      */

File: src/test/java/io/reactivex/rxjava3/subscribers/SerializedSubscriberTest.java
Patch:
@@ -341,11 +341,11 @@ public void onNext(String t) {
      *
      * When using SynchronizedSubscriber we get this output:
      *
-     * p1: 18 p2: 68 => should be close to each other unless we have thread starvation
+     * {@code p1: 18 p2: 68 =>} should be close to each other unless we have thread starvation
      *
      * When using SerializedSubscriber we get:
      *
-     * p1: 1 p2: 2445261 => should be close to each other unless we have thread starvation
+     * {@code p1: 1 p2: 2445261 =>} should be close to each other unless we have thread starvation
      *
      * This demonstrates how SynchronizedSubscriber balances back and forth better, and blocks emission.
      * The real issue in this example is the async buffer-bloat, so we need backpressure.

File: src/test/java/io/reactivex/rxjava3/tck/BaseTck.java
Patch:
@@ -51,7 +51,7 @@ public long maxElementsFromPublisher() {
 
     /**
      * Creates an Iterable with the specified number of elements or an infinite one if
-     * elements > {@link Integer#MAX_VALUE}.
+     * {@code elements >} {@link Integer#MAX_VALUE}.
      * @param elements the number of elements to return, {@link Integer#MAX_VALUE} means an infinite sequence
      * @return the Iterable
      */

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -198,7 +198,6 @@ void drain() {
             for (;;) {
 
                 if (cancelled) {
-                    active.lazySet(null);
                     return;
                 }
 

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -981,7 +981,7 @@ private static Completable merge0(@NonNull Publisher<@NonNull ? extends Completa
     @SafeVarargs
     public static Completable mergeArrayDelayError(@NonNull CompletableSource... sources) {
         Objects.requireNonNull(sources, "sources is null");
-        return RxJavaPlugins.onAssembly(new CompletableMergeDelayErrorArray(sources));
+        return RxJavaPlugins.onAssembly(new CompletableMergeArrayDelayError(sources));
     }
 
     /**

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcat.java
Patch:
@@ -182,9 +182,8 @@ void drain() {
                     boolean empty = cs == null;
 
                     if (d && empty) {
-                        if (once.compareAndSet(false, true)) {
-                            downstream.onComplete();
-                        }
+                        // errors never set done or call drain.
+                        downstream.onComplete();
                         return;
                     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeArray.java
Patch:
@@ -86,9 +86,8 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             if (decrementAndGet() == 0) {
-                if (once.compareAndSet(false, true)) {
-                    downstream.onComplete();
-                }
+                // errors don't decrement this
+                downstream.onComplete();
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeArrayDelayError.java
Patch:
@@ -19,11 +19,11 @@
 import io.reactivex.rxjava3.disposables.*;
 import io.reactivex.rxjava3.internal.util.AtomicThrowable;
 
-public final class CompletableMergeDelayErrorArray extends Completable {
+public final class CompletableMergeArrayDelayError extends Completable {
 
     final CompletableSource[] sources;
 
-    public CompletableMergeDelayErrorArray(CompletableSource[] sources) {
+    public CompletableMergeArrayDelayError(CompletableSource[] sources) {
         this.sources = sources;
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeDelayErrorIterable.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.CompositeDisposable;
 import io.reactivex.rxjava3.exceptions.Exceptions;
-import io.reactivex.rxjava3.internal.operators.completable.CompletableMergeDelayErrorArray.*;
+import io.reactivex.rxjava3.internal.operators.completable.CompletableMergeArrayDelayError.*;
 import io.reactivex.rxjava3.internal.util.AtomicThrowable;
 
 public final class CompletableMergeDelayErrorIterable extends Completable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMergeIterable.java
Patch:
@@ -128,9 +128,8 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             if (wip.decrementAndGet() == 0) {
-                if (compareAndSet(false, true)) {
-                    downstream.onComplete();
-                }
+                // errors don't decrement wip
+                downstream.onComplete();
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapEager.java
Patch:
@@ -318,7 +318,7 @@ public void drain() {
 
                             e++;
 
-                            inner.requestOne();
+                            inner.request(1L);
                         }
 
                         if (e == r) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapCompletable.java
Patch:
@@ -138,9 +138,7 @@ public void onError(Throwable e) {
                     cancelled = true;
                     upstream.cancel();
                     set.dispose();
-                    if (getAndSet(0) > 0) {
-                        errors.tryTerminateConsumer(downstream);
-                    }
+                    errors.tryTerminateConsumer(downstream);
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
Patch:
@@ -146,9 +146,7 @@ public void onError(Throwable e) {
                     disposed = true;
                     upstream.cancel();
                     set.dispose();
-                    if (getAndSet(0) > 0) {
-                        errors.tryTerminateConsumer(downstream);
-                    }
+                    errors.tryTerminateConsumer(downstream);
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java
Patch:
@@ -330,7 +330,7 @@ else if (mode == LEFT_CLOSE) {
                             up.onComplete();
                         }
                     }
-                    else if (mode == RIGHT_CLOSE) {
+                    else {
                         LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;
 
                         rights.remove(end.index);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoin.java
Patch:
@@ -339,7 +339,7 @@ else if (mode == LEFT_CLOSE) {
                         lefts.remove(end.index);
                         disposables.remove(end);
                     }
-                    else if (mode == RIGHT_CLOSE) {
+                    else {
                         LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;
 
                         rights.remove(end.index);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAmb.java
Patch:
@@ -115,9 +115,8 @@ public boolean win(int index) {
                     }
                     return true;
                 }
-                return false;
             }
-            return w == index;
+            return false;
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCreate.java
Patch:
@@ -159,7 +159,7 @@ static final class SerializedEmitter<T>
 
         @Override
         public void onNext(T t) {
-            if (emitter.isDisposed() || done) {
+            if (done || emitter.isDisposed()) {
                 return;
             }
             if (t == null) {
@@ -192,7 +192,7 @@ public void onError(Throwable t) {
 
         @Override
         public boolean tryOnError(Throwable t) {
-            if (emitter.isDisposed() || done) {
+            if (done || emitter.isDisposed()) {
                 return false;
             }
             if (t == null) {
@@ -208,7 +208,7 @@ public boolean tryOnError(Throwable t) {
 
         @Override
         public void onComplete() {
-            if (emitter.isDisposed() || done) {
+            if (done || emitter.isDisposed()) {
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapCompletable.java
Patch:
@@ -116,9 +116,7 @@ public void onError(Throwable e) {
                     disposed = true;
                     upstream.dispose();
                     set.dispose();
-                    if (getAndSet(0) > 0) {
-                        errors.tryTerminateConsumer(downstream);
-                    }
+                    errors.tryTerminateConsumer(downstream);
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapCompletableCompletable.java
Patch:
@@ -122,9 +122,7 @@ public void onError(Throwable e) {
                     disposed = true;
                     upstream.dispose();
                     set.dispose();
-                    if (getAndSet(0) > 0) {
-                        errors.tryTerminateConsumer(downstream);
-                    }
+                    errors.tryTerminateConsumer(downstream);
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.java
Patch:
@@ -319,7 +319,7 @@ else if (mode == LEFT_CLOSE) {
                             up.onComplete();
                         }
                     }
-                    else if (mode == RIGHT_CLOSE) {
+                    else  {
                         LeftRightEndObserver end = (LeftRightEndObserver)val;
 
                         rights.remove(end.index);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableIntervalRange.java
Patch:
@@ -90,8 +90,10 @@ public void run() {
                 downstream.onNext(c);
 
                 if (c == end) {
+                    if (!isDisposed()) {
+                        downstream.onComplete();
+                    }
                     DisposableHelper.dispose(this);
-                    downstream.onComplete();
                     return;
                 }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLast.java
Patch:
@@ -77,9 +77,7 @@ public void onComplete() {
                 }
                 T v = poll();
                 if (v == null) {
-                    if (!cancelled) {
-                        a.onComplete();
-                    }
+                    a.onComplete();
                     return;
                 }
                 a.onNext(v);

File: src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDelayWithObservable.java
Patch:
@@ -56,7 +56,7 @@ static final class OtherSubscriber<T, U>
 
         @Override
         public void onSubscribe(Disposable d) {
-            if (DisposableHelper.set(this, d)) {
+            if (DisposableHelper.setOnce(this, d)) {
 
                 downstream.onSubscribe(this);
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapIterableFlowable.java
Patch:
@@ -154,7 +154,7 @@ void drain() {
                     long e = 0L;
 
                     if (r == Long.MAX_VALUE) {
-                        slowPath(a, iterator);
+                        fastPath(a, iterator);
                         return;
                     }
 
@@ -213,7 +213,7 @@ void drain() {
             }
         }
 
-        void slowPath(Subscriber<? super R> a, Iterator<? extends R> iterator) {
+        void fastPath(Subscriber<? super R> a, Iterator<? extends R> iterator) {
             for (;;) {
                 if (cancelled) {
                     return;

File: src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java
Patch:
@@ -257,9 +257,7 @@ void runFair() {
             }
 
             Runnable run = q.poll();
-            if (run != null) {
-                run.run();
-            }
+            run.run(); // never null because of offer + increment happens first
 
             if (disposed) {
                 q.clear();

File: src/test/java/io/reactivex/rxjava3/internal/functions/FunctionsTest.java
Patch:
@@ -39,12 +39,12 @@ public void utilityClass() {
     public void hashSetCallableEnum() {
         // inlined TestHelper.checkEnum due to access restrictions
         try {
-            Method m = Functions.HashSetCallable.class.getMethod("values");
+            Method m = Functions.HashSetSupplier.class.getMethod("values");
             m.setAccessible(true);
-            Method e = Functions.HashSetCallable.class.getMethod("valueOf", String.class);
+            Method e = Functions.HashSetSupplier.class.getMethod("valueOf", String.class);
             e.setAccessible(true);
 
-            for (Enum<HashSetCallable> o : (Enum<HashSetCallable>[])m.invoke(null)) {
+            for (Enum<HashSetSupplier> o : (Enum<HashSetSupplier>[])m.invoke(null)) {
                 assertSame(o, e.invoke(null, o.name()));
             }
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleInternalHelperTest.java
Patch:
@@ -31,8 +31,8 @@ public void utilityClass() {
 
     @Test
     public void noSuchElementCallableEnum() {
-        assertEquals(1, SingleInternalHelper.NoSuchElementCallable.values().length);
-        assertNotNull(SingleInternalHelper.NoSuchElementCallable.valueOf("INSTANCE"));
+        assertEquals(1, SingleInternalHelper.NoSuchElementSupplier.values().length);
+        assertNotNull(SingleInternalHelper.NoSuchElementSupplier.valueOf("INSTANCE"));
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/parallel/ParallelFlatMapIterableTest.java
Patch:
@@ -14,7 +14,6 @@
 package io.reactivex.rxjava3.parallel;
 
 import java.util.Arrays;
-import java.util.stream.Stream;
 
 import org.junit.Test;
 
@@ -25,7 +24,7 @@ public class ParallelFlatMapIterableTest extends RxJavaTest {
     @Test
     public void subscriberCount() {
         ParallelFlowableTest.checkSubscriberCount(Flowable.range(1, 5).parallel()
-        .flatMapStream(v -> Stream.of(1, 2, 3)));
+        .flatMapIterable(v -> Arrays.asList(1, 2, 3)));
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/validators/OperatorsUseInterfaces.java
Patch:
@@ -17,13 +17,13 @@
 
 import java.lang.reflect.*;
 import java.util.*;
-import java.util.Observable;
 import java.util.concurrent.Callable;
 
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 
 import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.core.Observable;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.parallel.ParallelFlowable;
 

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -1050,6 +1050,7 @@ public static Completable mergeDelayError(@NonNull Publisher<@NonNull ? extends
      *                       at a time to the inner {@code CompletableSource}s
      * @return the new {@code Completable} instance
      * @throws NullPointerException if {@code sources} is {@code null}
+     * @throws IllegalArgumentException if {@code maxConcurrency} is non-positive
      */
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)

File: src/test/java/io/reactivex/rxjava3/internal/util/MarbleDimensions.java
Patch:
@@ -98,7 +98,7 @@ public static void main(String[] args) throws Throwable {
         }
     }
 
-    static final int SLEEP_PER_IMAGE_MILLIS = 100;
+    static final int SLEEP_PER_IMAGE_MILLIS = 25;
 
     static final Class<?>[] CLASSES = {
             Flowable.class, Observable.class, Maybe.class, Single.class, Completable.class, ParallelFlowable.class

File: src/test/java/io/reactivex/rxjava3/validators/ParamValidationNaming.java
Patch:
@@ -527,6 +527,7 @@ static final class ValidatorStrings {
             new ValidatorStrings("itemDelayIndicator", "* @throws NullPointerException"),
             new ValidatorStrings("future", "* @throws NullPointerException"),
 
+            new ValidatorStrings("maxConcurrency", "* @throws IllegalArgumentException"),
             new ValidatorStrings("parallelism", "* @throws IllegalArgumentException"),
             new ValidatorStrings("prefetch", "* @throws IllegalArgumentException"),
             new ValidatorStrings("bufferSize", "* @throws IllegalArgumentException"),

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -401,6 +401,7 @@ public void request(long n) {
         public void cancel() {
             if (cancelled.compareAndSet(false, true)) {
                 cancelParent();
+                drain();
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/parallel/ParallelFlowable.java
Patch:
@@ -1394,7 +1394,7 @@ public final <R> ParallelFlowable<R> concatMapDelayError(
      * Returns a {@code ParallelFlowable} that merges each item emitted by the source on each rail with the values in an
      * {@link Iterable} corresponding to that item that is generated by a selector.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">
+     * <img width="640" height="342" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator honors backpressure from each downstream rail. The source {@code ParallelFlowable}s is
@@ -1427,7 +1427,7 @@ public final <U> ParallelFlowable<U> flatMapIterable(@NonNull Function<? super T
      * Returns a {@code ParallelFlowable} that merges each item emitted by the source {@code ParallelFlowable} with the values in an
      * {@link Iterable} corresponding to that item that is generated by a selector.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">
+     * <img width="640" height="342" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator honors backpressure from each downstream rail. The source {@code ParallelFlowable}s is

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -4467,7 +4467,7 @@ public final Maybe<T> onErrorResumeNext(@NonNull Function<? super Throwable, ? e
      * Ends the flow with a success item returned by a function for the {@link Throwable} error signaled by the current
      * {@code Maybe} instead of signaling the error via {@code onError}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png" alt="">
+     * <img width="640" height="377" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorReturn.png" alt="">
      * <p>
      * You can use this to prevent errors from propagating or to supply fallback data should errors be
      * encountered.
@@ -4494,7 +4494,7 @@ public final Maybe<T> onErrorReturn(@NonNull Function<? super Throwable, ? exten
     /**
      * Ends the flow with the given success item when the current {@code Maybe} fails instead of signaling the error via {@code onError}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png" alt="">
+     * <img width="640" height="377" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorReturnItem.png" alt="">
      * <p>
      * You can use this to prevent errors from propagating or to supply fallback data should errors be
      * encountered.
@@ -4504,7 +4504,7 @@ public final Maybe<T> onErrorReturn(@NonNull Function<? super Throwable, ? exten
      * </dl>
      *
      * @param item
-     *            the value that is emitted as {@code onSuccess} in case this {@code Maybe} signals an {@code onError}
+     *            the value that is emitted as {@code onSuccess} in case the current {@code Maybe} signals an {@code onError}
      * @return the new {@code Maybe} instance
      * @throws NullPointerException if {@code item} is {@code null}
      * @see <a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -1415,7 +1415,7 @@ public static <T> Flowable<T> merge(
     }
 
     /**
-     * Merges an array sequence of {@link MaybeSource} instances into a single {@link Flowable} sequence,
+     * Merges an array of {@link MaybeSource} instances into a single {@link Flowable} sequence,
      * running all {@code MaybeSource}s at once.
      * <p>
      * <img width="640" height="272" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeArray.png" alt="">
@@ -1470,10 +1470,10 @@ public static <T> Flowable<T> mergeArray(MaybeSource<? extends T>... sources) {
      * <img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeArrayDelayError.png" alt="">
      * <p>
      * This behaves like {@link #merge(Publisher)} except that if any of the merged {@code MaybeSource}s notify of an
-     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
+     * error via {@link Subscriber#onError onError}, {@code mergeArrayDelayError} will refrain from propagating that
      * error notification until all of the merged {@code MaybeSource}s have finished emitting items.
      * <p>
-     * Even if multiple merged {@code MaybeSource}s send {@code onError} notifications, {@code mergeDelayError} will only
+     * Even if multiple merged {@code MaybeSource}s send {@code onError} notifications, {@code mergeArrayDelayError} will only
      * invoke the {@code onError} method of its subscribers once.
      * <dl>
      *  <dt><b>Backpressure:</b></dt>

File: src/test/java/io/reactivex/rxjava3/internal/fuseable/CancellableQueueFuseableTest.java
Patch:
@@ -57,7 +57,7 @@ public void dispose() {
 
     @Test
     public void cancel2() {
-        AbstractEmptyQueueFuseable<Object> qs = new AbstractEmptyQueueFuseable<Object>() {};
+        AbstractEmptyQueueFuseable<Object> qs = new AbstractEmptyQueueFuseable<Object>() { };
 
         assertFalse(qs.isDisposed());
 
@@ -66,7 +66,7 @@ public void cancel2() {
 
     @Test
     public void dispose2() {
-        AbstractEmptyQueueFuseable<Object> qs = new AbstractEmptyQueueFuseable<Object>() {};
+        AbstractEmptyQueueFuseable<Object> qs = new AbstractEmptyQueueFuseable<Object>() { };
 
         assertFalse(qs.isDisposed());
 

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -3472,7 +3472,7 @@ public final Maybe<T> doOnSuccess(@NonNull Consumer<? super T> onSuccess) {
      * Filters the success item of the {@code Maybe} via a predicate function and emitting it if the predicate
      * returns {@code true}, completing otherwise.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png" alt="">
+     * <img width="640" height="291" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.filter.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code filter} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -4098,10 +4098,10 @@ public final Maybe<T> observeOn(@NonNull Scheduler scheduler) {
     }
 
     /**
-     * Filters the items emitted by a {@code Maybe}, only emitting its success value if that
+     * Filters the items emitted by the current {@code Maybe}, only emitting its success value if that
      * is an instance of the supplied {@link Class}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.png" alt="">
+     * <img width="640" height="291" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ofType.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code ofType} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -6249,7 +6249,7 @@ public final T blockingSingle(@NonNull T defaultItem) {
     /**
      * Returns a {@link Future} representing the only value emitted by this {@code Flowable}.
      * <p>
-     * <img width="640" height="324" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png" alt="">
+     * <img width="640" height="311" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png" alt="">
      * <p>
      * If the {@code Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an
      * {@link java.lang.IndexOutOfBoundsException}. If the {@code Flowable} is empty, {@link java.util.concurrent.Future}

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -5654,7 +5654,7 @@ public final T blockingSingle(@NonNull T defaultItem) {
     /**
      * Returns a {@link Future} representing the only value emitted by the current {@code Observable}.
      * <p>
-     * <img width="640" height="312" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png" alt="">
+     * <img width="640" height="299" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png" alt="">
      * <p>
      * If the {@code Observable} emits more than one item, {@code Future} will receive an
      * {@link IndexOutOfBoundsException}. If the {@code Observable} is empty, {@code Future}

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -4625,6 +4625,8 @@ public final Flowable<T> toFlowable() {
      * Returns a {@link Future} representing the single value emitted by this {@code Single}.
      * <p>
      * <img width="640" height="467" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Single.toFuture.png" alt="">
+     * <p>
+     * Cancelling the {@code Future} will cancel the subscription to the current {@code Single}.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toFuture} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -4637,7 +4639,7 @@ public final Flowable<T> toFlowable() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @NonNull
     public final Future<T> toFuture() {
-        return subscribeWith(new FutureSingleObserver<>());
+        return subscribeWith(new FutureMultiObserver<>());
     }
 
     /**

File: src/main/java/io/reactivex/rxjava3/schedulers/Timed.java
Patch:
@@ -33,10 +33,10 @@ public final class Timed<T> {
      * @param value the value to hold
      * @param time the time to hold
      * @param unit the time unit, not null
-     * @throws NullPointerException if unit is {@code null}
+     * @throws NullPointerException if {@code value} or {@code unit} is {@code null}
      */
     public Timed(@NonNull T value, long time, @NonNull TimeUnit unit) {
-        this.value = value;
+        this.value = Objects.requireNonNull(value, "value is null");
         this.time = time;
         this.unit = Objects.requireNonNull(unit, "unit is null");
     }
@@ -89,7 +89,7 @@ public boolean equals(Object other) {
 
     @Override
     public int hashCode() {
-         int h = value != null ? value.hashCode() : 0;
+         int h = value.hashCode();
          h = h * 31 + (int)((time >>> 31) ^ time);
          h = h * 31 + unit.hashCode();
          return h;

File: src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java
Patch:
@@ -458,6 +458,7 @@ static String findNotes(String clazzName, String operatorName) {
             "    C throttleLatest                       Always empty thus no items to work with.",
             "  MS  throttleWithTimeout                  At most one item signaled so no subsequent items to work with.",
             "    C throttleWithTimeout                  Always empty thus no items to work with.",
+            "    C timeInterval                         Always empty thus no items to work with.",
             "    C timestamp                            Always empty thus no items to work with.",
             "FO    toCompletionStage                    Use [`firstStage`](#firstStage), [`lastStage`](#lastStage) or [`singleStage`](#singleStage).",
             "F     toFlowable                           Would be no-op.",

File: src/test/java/io/reactivex/rxjava3/schedulers/TimedTest.java
Patch:
@@ -39,7 +39,7 @@ public void hashCodeOf() {
 
         assertEquals(TimeUnit.SECONDS.hashCode() + 31 * (5 + 31 * 1), t1.hashCode());
 
-        Timed<Integer> t2 = new Timed<>(null, 5, TimeUnit.SECONDS);
+        Timed<Integer> t2 = new Timed<>(0, 5, TimeUnit.SECONDS);
 
         assertEquals(TimeUnit.SECONDS.hashCode() + 31 * (5 + 31 * 0), t2.hashCode());
     }

File: src/test/java/io/reactivex/rxjava3/validators/JavadocWording.java
Patch:
@@ -153,12 +153,12 @@ public void maybeDocRefersToMaybeTypes() throws Exception {
                 jdx = 0;
                 for (;;) {
                     int idx = m.javadoc.indexOf("Single", jdx);
-                    if (idx >= 0) {
+                    if (idx >= 0 && m.javadoc.indexOf("Single#", jdx) != idx) {
                         int j = m.javadoc.indexOf("#toSingle", jdx);
                         int k = m.javadoc.indexOf("{@code Single", jdx);
                         if (!m.signature.contains("Single") && (j + 3 != idx && k + 7 != idx)) {
                             e.append("java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core.")
-                            .append("Maybe(Maybe.java:").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(")\r\n\r\n");
+                            .append("Maybe.method(Maybe.java:").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(")\r\n\r\n");
                         }
                         jdx = idx + 6;
                     } else {

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -11960,7 +11960,7 @@ public final <U> Flowable<U> ofType(@NonNull Class<U> clazz) {
      *
      * @return the new {@code Flowable} instance
      * @see <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
-     * #see {@link #onBackpressureBuffer(boolean)}
+     * @see #onBackpressureBuffer(boolean)
      */
     @CheckReturnValue
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -2659,7 +2659,7 @@ public final void blockingSubscribe(@NonNull Consumer<? super T> onSuccess, @Non
      * </dl>
      * @param onSuccess the {@link Consumer} to call if the current {@code Maybe} succeeds
      * @param onError the {@code Consumer} to call if the current {@code Maybe} signals an error
-     * @param onComplete the {@linnk Action} to call if the current {@code Maybe} completes without a value
+     * @param onComplete the {@link Action} to call if the current {@code Maybe} completes without a value
      * @throws NullPointerException if {@code onSuccess}, {@code onError} or {@code onComplete} is {@code null}
      * @since 3.0.0
      */

File: src/main/java/io/reactivex/rxjava3/core/Maybe.java
Patch:
@@ -4084,7 +4084,7 @@ public final Maybe<T> onErrorComplete(@NonNull Predicate<? super Throwable> pred
      * Resumes the flow with the given {@link MaybeSource} when the current {@code Maybe} fails instead of
      * signaling the error via {@code onError}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png" alt="">
+     * <img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorResumeWith.png" alt="">
      * <p>
      * You can use this to prevent errors from propagating or to supply fallback data should errors be
      * encountered.
@@ -4112,7 +4112,7 @@ public final Maybe<T> onErrorResumeWith(@NonNull MaybeSource<? extends T> fallba
      * Resumes the flow with a {@link MaybeSource} returned for the failure {@link Throwable} of the current {@code Maybe} by a
      * function instead of signaling the error via {@code onError}.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png" alt="">
+     * <img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorResumeNext.png" alt="">
      * <p>
      * You can use this to prevent errors from propagating or to supply fallback data should errors be
      * encountered.

File: src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java
Patch:
@@ -289,6 +289,8 @@ public void checkParallelFlowable() {
         // negative time is considered as zero time
         addOverride(new ParamOverride(Maybe.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class));
         addOverride(new ParamOverride(Maybe.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class, Scheduler.class));
+        addOverride(new ParamOverride(Maybe.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class, Boolean.TYPE));
+        addOverride(new ParamOverride(Maybe.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class, Scheduler.class, Boolean.TYPE));
 
         // zero repeat is allowed
         addOverride(new ParamOverride(Maybe.class, 0, ParamMode.NON_NEGATIVE, "repeat", Long.TYPE));

File: src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java
Patch:
@@ -419,6 +419,7 @@ static String findNotes(String clazzName, String operatorName) {
             "    C throttleWithTimeout                  Always empty thus no items to work with.",
             "    C timestamp                            Always empty thus no items to work with.",
             "FO    toCompletionStage                    Use [`firstStage`](#firstStage), [`lastStage`](#lastStage) or [`singleStage`](#singleStage).",
+            "F     toFlowable                           Would be no-op.",
             "  M   toList                               At most one element to collect. Use [`map()`](#map) and [`switchIfEmpty()`](#switchIfEmpty) to transform into a list/collection.",
             "   S  toList                               One element to collect. Use [`map()`](#map) to transform into a list/collection.",
             "    C toList                               Always empty. Use [`andThen()`](#andThen) to bring in a collection.",

File: src/test/java/io/reactivex/rxjava3/validators/ParamValidationNaming.java
Patch:
@@ -203,7 +203,7 @@ static void processFile(Class<?> clazz) throws Exception {
 
                     int quote = line.indexOf('"', comma);
 
-                    String message = line.substring(quote + 1, quote + 2 + paramName.length());
+                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));
 
                     if (line.contains("\"A Disposable")) {
                         continue;

File: src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java
Patch:
@@ -61,7 +61,7 @@ public static void main(String[] args) throws IOException {
         List<String> sortedOperators = new ArrayList<>(operatorSet);
         sortedOperators.sort(Comparator.naturalOrder());
 
-        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get("docs", "Operator-Matrix.md"), StandardOpenOption.CREATE))) {
+        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get("docs", "Operator-Matrix.md"), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING))) {
             out.print("Operator |");
             for (Class<?> clazz : CLASSES) {
                 out.print(" `");

File: src/main/java/io/reactivex/rxjava3/core/CompletableConverter.java
Patch:
@@ -23,13 +23,12 @@
  * @since 2.2
  */
 @FunctionalInterface
-public interface CompletableConverter<R> {
+public interface CompletableConverter<@NonNull R> {
     /**
      * Applies a function to the upstream Completable and returns a converted value of type {@code R}.
      *
      * @param upstream the upstream Completable instance
      * @return the converted value
      */
-    @NonNull
     R apply(@NonNull Completable upstream);
 }

File: src/main/java/io/reactivex/rxjava3/core/Emitter.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @param <T> the value type emitted
  */
-public interface Emitter<T> {
+public interface Emitter<@NonNull T> {
 
     /**
      * Signal a normal value.

File: src/main/java/io/reactivex/rxjava3/core/FlowableConverter.java
Patch:
@@ -24,13 +24,12 @@
  * @since 2.2
  */
 @FunctionalInterface
-public interface FlowableConverter<T, R> {
+public interface FlowableConverter<@NonNull T, @NonNull R> {
     /**
      * Applies a function to the upstream {@link Flowable} and returns a converted value of type {@code R}.
      *
      * @param upstream the upstream {@code Flowable} instance
      * @return the converted value
      */
-    @NonNull
     R apply(@NonNull Flowable<T> upstream);
 }

File: src/main/java/io/reactivex/rxjava3/core/FlowableEmitter.java
Patch:
@@ -15,7 +15,7 @@
 
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.functions.Cancellable;
+import io.reactivex.rxjava3.functions.*;
 
 /**
  * Abstraction over a Reactive Streams {@link org.reactivestreams.Subscriber} that allows associating
@@ -48,7 +48,7 @@
  *
  * @param <T> the value type to emit
  */
-public interface FlowableEmitter<T> extends Emitter<T> {
+public interface FlowableEmitter<@NonNull T> extends Emitter<T> {
 
     /**
      * Sets a Disposable on this emitter; any previous {@link Disposable}

File: src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.java
Patch:
@@ -22,7 +22,7 @@
  * @param <T> the value type pushed
  */
 @FunctionalInterface
-public interface FlowableOnSubscribe<T> {
+public interface FlowableOnSubscribe<@NonNull T> {
 
     /**
      * Called for each {@link org.reactivestreams.Subscriber Subscriber} that subscribes.

File: src/main/java/io/reactivex/rxjava3/core/FlowableOperator.java
Patch:
@@ -24,7 +24,7 @@
  * @param <Upstream> the value type of the upstream
  */
 @FunctionalInterface
-public interface FlowableOperator<Downstream, Upstream> {
+public interface FlowableOperator<@NonNull Downstream, @NonNull Upstream> {
     /**
      * Applies a function to the child {@link Subscriber} and returns a new parent {@code Subscriber}.
      * @param subscriber the child {@code Subscriber} instance

File: src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> the value type
  * @since 2.2
  */
-public interface FlowableSubscriber<T> extends Subscriber<T> {
+public interface FlowableSubscriber<@NonNull T> extends Subscriber<T> {
 
     /**
      * Implementors of this method should make sure everything that needs

File: src/main/java/io/reactivex/rxjava3/core/FlowableTransformer.java
Patch:
@@ -24,7 +24,7 @@
  * @param <Downstream> the downstream value type
  */
 @FunctionalInterface
-public interface FlowableTransformer<Upstream, Downstream> {
+public interface FlowableTransformer<@NonNull Upstream, @NonNull Downstream> {
     /**
      * Applies a function to the upstream {@link Flowable} and returns a {@link Publisher} with
      * optionally different element type.

File: src/main/java/io/reactivex/rxjava3/core/MaybeConverter.java
Patch:
@@ -24,7 +24,7 @@
  * @since 2.2
  */
 @FunctionalInterface
-public interface MaybeConverter<T, R> {
+public interface MaybeConverter<@NonNull T, @NonNull R> {
     /**
      * Applies a function to the upstream {@link Maybe} and returns a converted value of type {@code R}.
      *

File: src/main/java/io/reactivex/rxjava3/core/MaybeEmitter.java
Patch:
@@ -15,7 +15,7 @@
 
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.functions.Cancellable;
+import io.reactivex.rxjava3.functions.*;
 
 /**
  * Abstraction over an RxJava {@link MaybeObserver} that allows associating
@@ -47,7 +47,7 @@
  *
  * @param <T> the value type to emit
  */
-public interface MaybeEmitter<T> {
+public interface MaybeEmitter<@NonNull T> {
 
     /**
      * Signal a success value.

File: src/main/java/io/reactivex/rxjava3/core/MaybeObserver.java
Patch:
@@ -53,7 +53,7 @@
  *          the type of item the MaybeObserver expects to observe
  * @since 2.0
  */
-public interface MaybeObserver<T> {
+public interface MaybeObserver<@NonNull T> {
 
     /**
      * Provides the {@link MaybeObserver} with the means of cancelling (disposing) the

File: src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.java
Patch:
@@ -22,7 +22,7 @@
  * @param <T> the value type pushed
  */
 @FunctionalInterface
-public interface MaybeOnSubscribe<T> {
+public interface MaybeOnSubscribe<@NonNull T> {
 
     /**
      * Called for each {@link MaybeObserver} that subscribes.

File: src/main/java/io/reactivex/rxjava3/core/MaybeOperator.java
Patch:
@@ -21,7 +21,7 @@
  * @param <Upstream> the value type of the upstream
  */
 @FunctionalInterface
-public interface MaybeOperator<Downstream, Upstream> {
+public interface MaybeOperator<@NonNull Downstream, @NonNull Upstream> {
     /**
      * Applies a function to the child {@link MaybeObserver} and returns a new parent {@code MaybeObserver}.
      * @param observer the child {@code MaybeObserver} instance

File: src/main/java/io/reactivex/rxjava3/core/MaybeSource.java
Patch:
@@ -25,7 +25,7 @@
  * @since 2.0
  */
 @FunctionalInterface
-public interface MaybeSource<T> {
+public interface MaybeSource<@NonNull T> {
 
     /**
      * Subscribes the given {@link MaybeObserver} to this {@link MaybeSource} instance.

File: src/main/java/io/reactivex/rxjava3/core/MaybeTransformer.java
Patch:
@@ -22,7 +22,7 @@
  * @param <Downstream> the downstream value type
  */
 @FunctionalInterface
-public interface MaybeTransformer<Upstream, Downstream> {
+public interface MaybeTransformer<@NonNull Upstream, @NonNull Downstream> {
     /**
      * Applies a function to the upstream {@link Maybe} and returns a {@link MaybeSource} with
      * optionally different element type.

File: src/main/java/io/reactivex/rxjava3/core/ObservableConverter.java
Patch:
@@ -24,13 +24,12 @@
  * @since 2.2
  */
 @FunctionalInterface
-public interface ObservableConverter<T, R> {
+public interface ObservableConverter<@NonNull T, @NonNull R> {
     /**
      * Applies a function to the upstream {@link Observable} and returns a converted value of type {@code R}.
      *
      * @param upstream the upstream {@code Observable} instance
      * @return the converted value
      */
-    @NonNull
     R apply(@NonNull Observable<T> upstream);
 }

File: src/main/java/io/reactivex/rxjava3/core/ObservableEmitter.java
Patch:
@@ -15,7 +15,7 @@
 
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.functions.Cancellable;
+import io.reactivex.rxjava3.functions.*;
 
 /**
  * Abstraction over an RxJava {@link Observer} that allows associating
@@ -47,7 +47,7 @@
  *
  * @param <T> the value type to emit
  */
-public interface ObservableEmitter<T> extends Emitter<T> {
+public interface ObservableEmitter<@NonNull T> extends Emitter<T> {
 
     /**
      * Sets a {@link Disposable} on this emitter; any previous {@code Disposable}

File: src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.java
Patch:
@@ -22,7 +22,7 @@
  * @param <T> the value type pushed
  */
 @FunctionalInterface
-public interface ObservableOnSubscribe<T> {
+public interface ObservableOnSubscribe<@NonNull T> {
 
     /**
      * Called for each {@link Observer} that subscribes.

File: src/main/java/io/reactivex/rxjava3/core/ObservableOperator.java
Patch:
@@ -22,7 +22,7 @@
  * @param <Upstream> the value type of the upstream
  */
 @FunctionalInterface
-public interface ObservableOperator<Downstream, Upstream> {
+public interface ObservableOperator<@NonNull Downstream, @NonNull Upstream> {
     /**
      * Applies a function to the child {@link Observer} and returns a new parent {@code Observer}.
      * @param observer the child {@code Observer} instance

File: src/main/java/io/reactivex/rxjava3/core/ObservableSource.java
Patch:
@@ -22,7 +22,7 @@
  * @since 2.0
  */
 @FunctionalInterface
-public interface ObservableSource<T> {
+public interface ObservableSource<@NonNull T> {
 
     /**
      * Subscribes the given {@link Observer} to this {@link ObservableSource} instance.

File: src/main/java/io/reactivex/rxjava3/core/ObservableTransformer.java
Patch:
@@ -22,7 +22,7 @@
  * @param <Downstream> the downstream value type
  */
 @FunctionalInterface
-public interface ObservableTransformer<Upstream, Downstream> {
+public interface ObservableTransformer<@NonNull Upstream, @NonNull Downstream> {
     /**
      * Applies a function to the upstream {@link Observable} and returns an {@link ObservableSource} with
      * optionally different element type.

File: src/main/java/io/reactivex/rxjava3/core/Observer.java
Patch:
@@ -73,7 +73,7 @@
  * @param <T>
  *          the type of item the Observer expects to observe
  */
-public interface Observer<T> {
+public interface Observer<@NonNull T> {
 
     /**
      * Provides the {@link Observer} with the means of cancelling (disposing) the

File: src/main/java/io/reactivex/rxjava3/core/SingleConverter.java
Patch:
@@ -24,13 +24,12 @@
  * @since 2.2
  */
 @FunctionalInterface
-public interface SingleConverter<T, R> {
+public interface SingleConverter<@NonNull T, @NonNull R> {
     /**
      * Applies a function to the upstream {@link Single} and returns a converted value of type {@code R}.
      *
      * @param upstream the upstream {@code Single} instance
      * @return the converted value
      */
-    @NonNull
     R apply(@NonNull Single<T> upstream);
 }

File: src/main/java/io/reactivex/rxjava3/core/SingleEmitter.java
Patch:
@@ -15,7 +15,7 @@
 
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.functions.Cancellable;
+import io.reactivex.rxjava3.functions.*;
 
 /**
  * Abstraction over an RxJava {@link SingleObserver} that allows associating
@@ -47,7 +47,7 @@
  *
  * @param <T> the value type to emit
  */
-public interface SingleEmitter<T> {
+public interface SingleEmitter<@NonNull T> {
 
     /**
      * Signal a success value.

File: src/main/java/io/reactivex/rxjava3/core/SingleObserver.java
Patch:
@@ -50,7 +50,7 @@
  *          the type of item the SingleObserver expects to observe
  * @since 2.0
  */
-public interface SingleObserver<T> {
+public interface SingleObserver<@NonNull T> {
 
     /**
      * Provides the {@link SingleObserver} with the means of cancelling (disposing) the

File: src/main/java/io/reactivex/rxjava3/core/SingleOnSubscribe.java
Patch:
@@ -22,7 +22,7 @@
  * @param <T> the value type pushed
  */
 @FunctionalInterface
-public interface SingleOnSubscribe<T> {
+public interface SingleOnSubscribe<@NonNull T> {
 
     /**
      * Called for each {@link SingleObserver} that subscribes.

File: src/main/java/io/reactivex/rxjava3/core/SingleOperator.java
Patch:
@@ -22,7 +22,7 @@
  * @param <Upstream> the value type of the upstream
  */
 @FunctionalInterface
-public interface SingleOperator<Downstream, Upstream> {
+public interface SingleOperator<@NonNull Downstream, @NonNull Upstream> {
     /**
      * Applies a function to the child {@link SingleObserver} and returns a new parent {@code SingleObserver}.
      * @param observer the child {@code SingleObserver} instance

File: src/main/java/io/reactivex/rxjava3/core/SingleSource.java
Patch:
@@ -25,7 +25,7 @@
  * @since 2.0
  */
 @FunctionalInterface
-public interface SingleSource<T> {
+public interface SingleSource<@NonNull T> {
 
     /**
      * Subscribes the given {@link SingleObserver} to this {@link SingleSource} instance.

File: src/main/java/io/reactivex/rxjava3/core/SingleTransformer.java
Patch:
@@ -22,7 +22,7 @@
  * @param <Downstream> the downstream value type
  */
 @FunctionalInterface
-public interface SingleTransformer<Upstream, Downstream> {
+public interface SingleTransformer<@NonNull Upstream, @NonNull Downstream> {
     /**
      * Applies a function to the upstream {@link Single} and returns a {@link SingleSource} with
      * optionally different element type.

File: src/main/java/io/reactivex/rxjava3/functions/BiConsumer.java
Patch:
@@ -13,13 +13,15 @@
 
 package io.reactivex.rxjava3.functions;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * A functional interface (callback) that accepts two values (of possibly different types).
  * @param <T1> the first value type
  * @param <T2> the second value type
  */
 @FunctionalInterface
-public interface BiConsumer<T1, T2> {
+public interface BiConsumer<@NonNull T1, @NonNull T2> {
 
     /**
      * Performs an operation on the given values.

File: src/main/java/io/reactivex/rxjava3/functions/BiFunction.java
Patch:
@@ -22,7 +22,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface BiFunction<T1, T2, R> {
+public interface BiFunction<@NonNull T1, @NonNull T2, @NonNull R> {
 
     /**
      * Calculate a value based on the input values.
@@ -31,6 +31,5 @@ public interface BiFunction<T1, T2, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2) throws Throwable;
+    R apply(T1 t1, T2 t2) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/BiPredicate.java
Patch:
@@ -21,7 +21,7 @@
  * @param <T2> the second value
  */
 @FunctionalInterface
-public interface BiPredicate<T1, T2> {
+public interface BiPredicate<@NonNull T1, @NonNull T2> {
 
     /**
      * Test the given input values and return a boolean.

File: src/main/java/io/reactivex/rxjava3/functions/Consumer.java
Patch:
@@ -13,12 +13,14 @@
 
 package io.reactivex.rxjava3.functions;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * A functional interface (callback) that accepts a single value.
  * @param <T> the value type
  */
 @FunctionalInterface
-public interface Consumer<T> {
+public interface Consumer<@NonNull T> {
     /**
      * Consume the given value.
      * @param t the value

File: src/main/java/io/reactivex/rxjava3/functions/Function.java
Patch:
@@ -23,12 +23,12 @@
  * @param <R> the output value type
  */
 @FunctionalInterface
-public interface Function<T, R> {
+public interface Function<@NonNull T, @NonNull R> {
     /**
      * Apply some calculation to the input value and return some other value.
      * @param t the input value
      * @return the output value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    R apply(@NonNull T t) throws Throwable;
+    R apply(T t) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function3.java
Patch:
@@ -23,7 +23,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function3<T1, T2, T3, R> {
+public interface Function3<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -32,6 +32,5 @@ public interface Function3<T1, T2, T3, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function4.java
Patch:
@@ -24,7 +24,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function4<T1, T2, T3, T4, R> {
+public interface Function4<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -34,6 +34,5 @@ public interface Function4<T1, T2, T3, T4, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function5.java
Patch:
@@ -25,7 +25,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function5<T1, T2, T3, T4, T5, R> {
+public interface Function5<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -36,6 +36,5 @@ public interface Function5<T1, T2, T3, T4, T5, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function6.java
Patch:
@@ -26,7 +26,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function6<T1, T2, T3, T4, T5, T6, R> {
+public interface Function6<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -38,6 +38,5 @@ public interface Function6<T1, T2, T3, T4, T5, T6, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function7.java
Patch:
@@ -27,7 +27,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {
+public interface Function7<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -40,6 +40,5 @@ public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function8.java
Patch:
@@ -28,7 +28,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
+public interface Function8<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull T8, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -42,6 +42,5 @@ public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7, @NonNull T8 t8) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Function9.java
Patch:
@@ -29,7 +29,7 @@
  * @param <R> the result type
  */
 @FunctionalInterface
-public interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
+public interface Function9<@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull T8, @NonNull T9, @NonNull R> {
     /**
      * Calculate a value based on the input values.
      * @param t1 the first value
@@ -44,6 +44,5 @@ public interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
      * @return the result value
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7, @NonNull T8 t8, @NonNull T9 t9) throws Throwable;
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/IntFunction.java
Patch:
@@ -19,13 +19,12 @@
  * @param <T> the returned value type
  */
 @FunctionalInterface
-public interface IntFunction<T> {
+public interface IntFunction<@NonNull T> {
     /**
      * Calculates a value based on a primitive integer input.
      * @param i the input value
      * @return the result Object
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    @NonNull
     T apply(int i) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Predicate.java
Patch:
@@ -20,12 +20,12 @@
  * @param <T> the first value
  */
 @FunctionalInterface
-public interface Predicate<T> {
+public interface Predicate<@NonNull T> {
     /**
      * Test the given input value and return a boolean.
      * @param t the value
      * @return the boolean result
      * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    boolean test(@NonNull T t) throws Throwable;
+    boolean test(T t) throws Throwable;
 }

File: src/main/java/io/reactivex/rxjava3/functions/Supplier.java
Patch:
@@ -13,6 +13,8 @@
 
 package io.reactivex.rxjava3.functions;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * A functional interface (callback) that provides a single value or
  * throws an exception.
@@ -23,7 +25,7 @@
  * @since 3.0.0
  */
 @FunctionalInterface
-public interface Supplier<T> {
+public interface Supplier<@NonNull T> {
 
     /**
      * Produces a value or throws an exception.

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/ConditionalSubscriber.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.FlowableSubscriber;
 
 /**
@@ -25,12 +26,12 @@
  *
  * @param <T> the value type
  */
-public interface ConditionalSubscriber<T> extends FlowableSubscriber<T> {
+public interface ConditionalSubscriber<@NonNull T> extends FlowableSubscriber<T> {
     /**
      * Conditionally takes the value.
      * @param t the value to deliver
      * @return true if the value has been accepted, false if the value has been rejected
      * and the next value can be sent immediately
      */
-    boolean tryOnNext(T t);
+    boolean tryOnNext(@NonNull T t);
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToFlowable.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.Flowable;
 
 /**
@@ -32,12 +33,13 @@
  *
  * @param <T> the value type
  */
-public interface FuseToFlowable<T> {
+public interface FuseToFlowable<@NonNull T> {
 
     /**
      * Returns a (direct) Flowable for the operator.
      * <p>The implementation should handle the necessary RxJavaPlugins wrapping.
      * @return the Flowable instance
      */
+    @NonNull
     Flowable<T> fuseToFlowable();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToMaybe.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.Maybe;
 
 /**
@@ -32,12 +33,13 @@
  *
  * @param <T> the value type
  */
-public interface FuseToMaybe<T> {
+public interface FuseToMaybe<@NonNull T> {
 
     /**
      * Returns a (direct) Maybe for the operator.
      * <p>The implementation should handle the necessary RxJavaPlugins wrapping.
      * @return the Maybe instance
      */
+    @NonNull
     Maybe<T> fuseToMaybe();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToObservable.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.Observable;
 
 /**
@@ -32,12 +33,13 @@
  *
  * @param <T> the value type
  */
-public interface FuseToObservable<T> {
+public interface FuseToObservable<@NonNull T> {
 
     /**
      * Returns a (direct) Observable for the operator.
      * <p>The implementation should handle the necessary RxJavaPlugins wrapping.
      * @return the Observable instance
      */
+    @NonNull
     Observable<T> fuseToObservable();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamCompletableSource.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.CompletableSource;
 
 /**
@@ -25,5 +26,6 @@ public interface HasUpstreamCompletableSource {
      * <p>Allows discovering the chain of observables.
      * @return the source CompletableSource
      */
+    @NonNull
     CompletableSource source();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamMaybeSource.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.MaybeSource;
 
 /**
@@ -21,11 +22,12 @@
  *
  * @param <T> the value type
  */
-public interface HasUpstreamMaybeSource<T> {
+public interface HasUpstreamMaybeSource<@NonNull T> {
     /**
      * Returns the upstream source of this Maybe.
      * <p>Allows discovering the chain of observables.
      * @return the source MaybeSource
      */
+    @NonNull
     MaybeSource<T> source();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamObservableSource.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.ObservableSource;
 
 /**
@@ -21,11 +22,12 @@
  *
  * @param <T> the value type
  */
-public interface HasUpstreamObservableSource<T> {
+public interface HasUpstreamObservableSource<@NonNull T> {
     /**
      * Returns the upstream source of this Observable.
      * <p>Allows discovering the chain of observables.
      * @return the source ObservableSource
      */
+    @NonNull
     ObservableSource<T> source();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamSingleSource.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.SingleSource;
 
 /**
@@ -21,11 +22,12 @@
  *
  * @param <T> the value type
  */
-public interface HasUpstreamSingleSource<T> {
+public interface HasUpstreamSingleSource<@NonNull T> {
     /**
      * Returns the upstream source of this Single.
      * <p>Allows discovering the chain of observables.
      * @return the source SingleSource
      */
+    @NonNull
     SingleSource<T> source();
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueDisposable.java
Patch:
@@ -14,6 +14,7 @@
 
 import java.util.Queue;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
@@ -51,5 +52,5 @@
  * </ul>
  * @param <T> the value type transmitted through the queue
  */
-public interface QueueDisposable<T> extends QueueFuseable<T>, Disposable {
+public interface QueueDisposable<@NonNull T> extends QueueFuseable<T>, Disposable {
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueFuseable.java
Patch:
@@ -13,11 +13,13 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * Represents a SimpleQueue plus the means and constants for requesting a fusion mode.
  * @param <T> the value type returned by the SimpleQueue.poll()
  */
-public interface QueueFuseable<T> extends SimpleQueue<T> {
+public interface QueueFuseable<@NonNull T> extends SimpleQueue<T> {
     /**
      * Returned by the {@link #requestFusion(int)} if the upstream doesn't support
      * the requested mode.

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueSubscription.java
Patch:
@@ -16,6 +16,8 @@
 
 import org.reactivestreams.Subscription;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * An interface extending Queue and Subscription and allows negotiating
  * the fusion mode between subsequent operators  of the {@code Flowable} base reactive type.
@@ -53,5 +55,5 @@
  * </ul>
  * @param <T> the value type transmitted through the queue
  */
-public interface QueueSubscription<T> extends QueueFuseable<T>, Subscription {
+public interface QueueSubscription<@NonNull T> extends QueueFuseable<T>, Subscription {
 }

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/ScalarSupplier.java
Patch:
@@ -12,6 +12,7 @@
  */
 package io.reactivex.rxjava3.internal.fuseable;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.functions.Supplier;
 
 /**
@@ -30,7 +31,7 @@
  * @param <T> the scalar value type held by the implementing reactive type
  */
 @FunctionalInterface
-public interface ScalarSupplier<T> extends Supplier<T> {
+public interface ScalarSupplier<@NonNull T> extends Supplier<T> {
 
     // overridden to remove the throws Throwable
     @Override

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/SimplePlainQueue.java
Patch:
@@ -13,14 +13,14 @@
 
 package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.rxjava3.annotations.Nullable;
+import io.reactivex.rxjava3.annotations.*;
 
 /**
  * Override of the SimpleQueue interface with no throws Exception on poll().
  *
  * @param <T> the value type to offer and poll, not null
  */
-public interface SimplePlainQueue<T> extends SimpleQueue<T> {
+public interface SimplePlainQueue<@NonNull T> extends SimpleQueue<T> {
 
     @Nullable
     @Override

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/SimpleQueue.java
Patch:
@@ -20,7 +20,7 @@
  *
  * @param <T> the value type to offer and poll, not null
  */
-public interface SimpleQueue<T> {
+public interface SimpleQueue<@NonNull T> {
 
     /**
      * Atomically enqueue a single.

File: src/main/java/io/reactivex/rxjava3/parallel/ParallelTransformer.java
Patch:
@@ -23,7 +23,7 @@
  * @since 2.2
  */
 @FunctionalInterface
-public interface ParallelTransformer<Upstream, Downstream> {
+public interface ParallelTransformer<@NonNull Upstream, @NonNull Downstream> {
     /**
      * Applies a function to the upstream ParallelFlowable and returns a ParallelFlowable with
      * optionally different element type.

File: src/main/java/io/reactivex/rxjava3/plugins/RxJavaPlugins.java
Patch:
@@ -918,7 +918,7 @@ public static void setOnSingleSubscribe(@Nullable BiFunction<? super Single, ? s
      */
     @SuppressWarnings({ "rawtypes", "unchecked" })
     @NonNull
-    public static <T> Subscriber<? super T> onSubscribe(@NonNull Flowable<T> source, @NonNull Subscriber<? super T> subscriber) {
+    public static <T> Subscriber<@NonNull ? super T> onSubscribe(@NonNull Flowable<T> source, @NonNull Subscriber<@NonNull ? super T> subscriber) {
         BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> f = onFlowableSubscribe;
         if (f != null) {
             return apply(f, source, subscriber);

File: src/main/java/io/reactivex/rxjava3/processors/FlowableProcessor.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @param <T> the item value type
  */
-public abstract class FlowableProcessor<T> extends Flowable<T> implements Processor<T, T>, FlowableSubscriber<T> {
+public abstract class FlowableProcessor<@NonNull T> extends Flowable<T> implements Processor<T, T>, FlowableSubscriber<T> {
 
     /**
      * Returns true if the FlowableProcessor has subscribers.

File: src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java
Patch:
@@ -375,7 +375,7 @@ public Throwable getThrowable() {
     }
 
     @Override
-    protected void subscribeActual(@NonNull Subscriber<? super T> s) {
+    protected void subscribeActual(@NonNull Subscriber<@NonNull ? super T> s) {
         MulticastSubscription<T> ms = new MulticastSubscription<>(s, this);
         s.onSubscribe(ms);
         if (add(ms)) {
@@ -593,13 +593,13 @@ static final class MulticastSubscription<T> extends AtomicLong implements Subscr
 
         private static final long serialVersionUID = -363282618957264509L;
 
-        final Subscriber<? super T> downstream;
+        final Subscriber<@NonNull ? super T> downstream;
 
         final MulticastProcessor<T> parent;
 
         long emitted;
 
-        MulticastSubscription(Subscriber<? super T> actual, MulticastProcessor<T> parent) {
+        MulticastSubscription(Subscriber<@NonNull ? super T> actual, MulticastProcessor<T> parent) {
             this.downstream = actual;
             this.parent = parent;
         }

File: src/test/java/io/reactivex/rxjava3/tck/CombineLatestArrayDelayErrorTckTest.java
Patch:
@@ -26,7 +26,7 @@ public class CombineLatestArrayDelayErrorTckTest extends BaseTck<Long> {
     @Override
     public Publisher<Long> createPublisher(long elements) {
         return
-            Flowable.combineLatestDelayError(
+            Flowable.combineLatestArrayDelayError(
                 new Publisher[] { Flowable.just(1L), Flowable.fromIterable(iterate(elements)) },
                 new Function<Object[], Long>() {
                     @Override

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -336,6 +336,7 @@ public static Completable create(@NonNull CompletableOnSubscribe source) {
      * when the {@code Completable} is subscribed to.
      * @return the created {@code Completable} instance
      * @throws NullPointerException if {@code source} is {@code null}
+     * @throws IllegalArgumentException if {@code source} is a {@code Completable}
      */
     @CheckReturnValue
     @NonNull
@@ -364,7 +365,7 @@ public static Completable unsafeCreate(@NonNull CompletableSource source) {
     @NonNull
     @SchedulerSupport(SchedulerSupport.NONE)
     public static Completable defer(@NonNull Supplier<? extends CompletableSource> completableSupplier) {
-        Objects.requireNonNull(completableSupplier, "completableSupplier");
+        Objects.requireNonNull(completableSupplier, "completableSupplier is null");
         return RxJavaPlugins.onAssembly(new CompletableDefer(completableSupplier));
     }
 

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -152,13 +152,15 @@ public static <T> Single<T> amb(@NonNull Iterable<? extends SingleSource<? exten
      * @param sources the array of sources. A subscription to each source will
      *            occur in the same order as in this array.
      * @return the new {@code Single} instance
+     * @throws NullPointerException if {@code sources} is {@code null}
      * @since 2.0
      */
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
     @SafeVarargs
     @NonNull
     public static <T> Single<T> ambArray(@NonNull SingleSource<? extends T>... sources) {
+        Objects.requireNonNull(sources, "sources is null");
         if (sources.length == 0) {
             return error(SingleInternalHelper.emptyThrower());
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBlockingSubscribe.java
Patch:
@@ -39,6 +39,7 @@ private ObservableBlockingSubscribe() {
      * The call to dispose() is composed through.
      * @param observer the subscriber to forward events and calls to in the current thread
      * @param <T> the value type
+     * @throws NullPointerException if {@code observer} is {@code null}
      */
     public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {
         final BlockingQueue<Object> queue = new LinkedBlockingQueue<>();

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipLastTest.java
Patch:
@@ -97,7 +97,7 @@ public void skipLastWithBackpressure() {
 
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void skipLastWithNegativeCount() {
         Flowable.just("one").skipLast(-1);
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTest.java
Patch:
@@ -89,7 +89,7 @@ public void takeLastWithZeroCount() {
         verify(subscriber, times(1)).onComplete();
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void takeLastWithNegativeCount() {
         Flowable.just("one").takeLast(-1);
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimedTest.java
Patch:
@@ -32,7 +32,7 @@
 
 public class FlowableTakeLastTimedTest extends RxJavaTest {
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void takeLastTimedWithNegativeCount() {
         Flowable.just("one").takeLast(-1, 1, TimeUnit.SECONDS);
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatMapEagerTest.java
Patch:
@@ -535,7 +535,7 @@ public void badCapacityHint() throws Exception {
         try {
             Observable.concatEager(Arrays.asList(source, source, source), 1, -99);
         } catch (IllegalArgumentException ex) {
-            assertEquals("prefetch > 0 required but it was -99", ex.getMessage());
+            assertEquals("bufferSize > 0 required but it was -99", ex.getMessage());
         }
 
     }
@@ -547,7 +547,7 @@ public void mappingBadCapacityHint() throws Exception {
         try {
             Observable.just(source, source, source).concatMapEager((Function)Functions.identity(), 10, -99);
         } catch (IllegalArgumentException ex) {
-            assertEquals("prefetch > 0 required but it was -99", ex.getMessage());
+            assertEquals("bufferSize > 0 required but it was -99", ex.getMessage());
         }
 
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSkipLastTest.java
Patch:
@@ -92,7 +92,7 @@ public void skipLastWithBackpressure() {
 
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void skipLastWithNegativeCount() {
         Observable.just("one").skipLast(-1);
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTest.java
Patch:
@@ -83,7 +83,7 @@ public void takeLastWithZeroCount() {
         verify(observer, times(1)).onComplete();
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void takeLastWithNegativeCount() {
         Observable.just("one").takeLast(-1);
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimedTest.java
Patch:
@@ -30,7 +30,7 @@
 
 public class ObservableTakeLastTimedTest extends RxJavaTest {
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void takeLastTimedWithNegativeCount() {
         Observable.just("one").takeLast(-1, 1, TimeUnit.SECONDS);
     }

File: src/test/java/io/reactivex/rxjava3/validators/JavadocWording.java
Patch:
@@ -990,5 +990,5 @@ static void backpressureMentionedWithoutAnnotation(StringBuilder e, RxMethod m,
         }
     }
 
-    static final String[] AT_RETURN_WORDS = { "@return a ", "@return the new ", "@return a new " };
+    static final String[] AT_RETURN_WORDS = { "@return a ", "@return an ", "@return the new ", "@return a new " };
 }

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -689,7 +689,6 @@ public static <T> Single<T> error(@NonNull Throwable exception) {
      * <p>
      * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.from.Future.png" alt="">
      * <p>
-     * <p>
      * The operator calls {@link Future#get(long, TimeUnit)}, which is a blocking method, on the subscription thread.
      * It is recommended applying {@link #subscribeOn(Scheduler)} to move this blocking wait to a
      * background thread, and if the {@link Scheduler} supports it, interrupt the wait when the flow
@@ -4074,7 +4073,7 @@ public final Completable ignoreElement() {
      * <dd>{@code toFlowable} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @return a {@lcode Flowable} that emits a single item T or an error.
+     * @return a {@code Flowable} that emits a single item T or an error.
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @CheckReturnValue

File: src/test/java/io/reactivex/rxjava3/validators/ParamValidationNaming.java
Patch:
@@ -221,7 +221,9 @@ static void processFile(Class<?> clazz) throws Exception {
                     }
 
                     // FIXME enable for other types in separate PR!
-                    if (!baseClassName.equals("Completable") && !baseClassName.equals("Single")) {
+                    if (!baseClassName.equals("Completable")
+                            && !baseClassName.equals("Single")
+                            && !baseClassName.equals("Maybe")) {
                         continue;
                     }
 

File: src/main/java/io/reactivex/rxjava3/core/Observable.java
Patch:
@@ -16342,6 +16342,7 @@ public final Stream<T> blockingStream() {
      *     stream.limit(3).forEach(System.out::println);
      * }
      * </code></pre>
+     * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code blockingStream} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>

File: src/jmh/java/io/reactivex/rxjava3/core/EachTypeFlatMapPerf.java
Patch:
@@ -114,11 +114,11 @@ public void nbpRangeMapRange(Blackhole bh) {
 
     @Benchmark
     public void singleJust(Blackhole bh) {
-        singleJust.subscribe(new LatchedSingleObserver<Integer>(bh));
+        singleJust.subscribe(new LatchedSingleObserver<>(bh));
     }
 
     @Benchmark
     public void singleJustMapJust(Blackhole bh) {
-        singleJustMapJust.subscribe(new LatchedSingleObserver<Integer>(bh));
+        singleJustMapJust.subscribe(new LatchedSingleObserver<>(bh));
     }
 }

File: src/jmh/java/io/reactivex/rxjava3/core/FlatMapJustPerf.java
Patch:
@@ -41,14 +41,14 @@ public void setup() {
 
         flowable = Flowable.fromArray(array).flatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
-            public Publisher<Integer> apply(Integer v) throws Exception {
+            public Publisher<Integer> apply(Integer v) {
                 return Flowable.just(v);
             }
         });
 
         observable = Observable.fromArray(array).flatMap(new Function<Integer, Observable<Integer>>() {
             @Override
-            public Observable<Integer> apply(Integer v) throws Exception {
+            public Observable<Integer> apply(Integer v) {
                 return Observable.just(v);
             }
         });

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenCrossMapPerf.java
Patch:
@@ -47,14 +47,14 @@ public void setup() {
 
         flowable = Flowable.fromArray(array).flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
-            public Iterable<Integer> apply(Integer v) throws Exception {
+            public Iterable<Integer> apply(Integer v) {
                 return list;
             }
         });
 
         observable = Observable.fromArray(array).flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
-            public Iterable<Integer> apply(Integer v) throws Exception {
+            public Iterable<Integer> apply(Integer v) {
                 return list;
             }
         });

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenJustPerf.java
Patch:
@@ -44,14 +44,14 @@ public void setup() {
 
         flowable = Flowable.fromArray(array).flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
-            public Iterable<Integer> apply(Integer v) throws Exception {
+            public Iterable<Integer> apply(Integer v) {
                 return singletonList;
             }
         });
 
         observable = Observable.fromArray(array).flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
-            public Iterable<Integer> apply(Integer v) throws Exception {
+            public Iterable<Integer> apply(Integer v) {
                 return singletonList;
             }
         });

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenRangePerf.java
Patch:
@@ -44,14 +44,14 @@ public void setup() {
 
         flowable = Flowable.fromArray(array).flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
-            public Iterable<Integer> apply(Integer v) throws Exception {
+            public Iterable<Integer> apply(Integer v) {
                 return list;
             }
         });
 
         observable = Observable.fromArray(array).flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
-            public Iterable<Integer> apply(Integer v) throws Exception {
+            public Iterable<Integer> apply(Integer v) {
                 return list;
             }
         });

File: src/jmh/java/io/reactivex/rxjava3/core/FlowableFlatMapCompletableAsyncPerf.java
Patch:
@@ -45,7 +45,7 @@ public class FlowableFlatMapCompletableAsyncPerf implements Action {
     Flowable<Object> flatMap;
 
     @Override
-    public void run() throws Exception {
+    public void run() {
         Blackhole.consumeCPU(work);
     }
 

File: src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java
Patch:
@@ -43,7 +43,7 @@ public void onNext(Integer t) {
         }
     }
 
-    final class IncrementingIterable implements Iterable<Integer> {
+    static final class IncrementingIterable implements Iterable<Integer> {
 
         final class IncrementingIterator implements Iterator<Integer> {
             int i;
@@ -77,7 +77,7 @@ public Iterator<Integer> iterator() {
         }
     }
 
-    final class IncrementingPublisher implements Publisher<Integer> {
+    static final class IncrementingPublisher implements Publisher<Integer> {
 
         final int size;
 

File: src/jmh/java/io/reactivex/rxjava3/core/OperatorFlatMapPerf.java
Patch:
@@ -40,7 +40,7 @@ public int getSize() {
     }
 
     @Benchmark
-    public void flatMapIntPassthruSync(Input input) throws InterruptedException {
+    public void flatMapIntPassthruSync(Input input) {
         input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
             public Publisher<Integer> apply(Integer v) {
@@ -66,7 +66,7 @@ public Publisher<Integer> apply(Integer i) {
     }
 
     @Benchmark
-    public void flatMapTwoNestedSync(final Input input) throws InterruptedException {
+    public void flatMapTwoNestedSync(final Input input) {
         Flowable.range(1, 2).flatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
             public Publisher<Integer> apply(Integer i) {

File: src/jmh/java/io/reactivex/rxjava3/core/PerfSubscriber.java
Patch:
@@ -20,7 +20,7 @@
 
 public class PerfSubscriber implements FlowableSubscriber<Object> {
 
-    public CountDownLatch latch = new CountDownLatch(1);
+    public final CountDownLatch latch = new CountDownLatch(1);
     private final Blackhole bh;
 
     public PerfSubscriber(Blackhole bh) {

File: src/jmh/java/io/reactivex/rxjava3/core/ReducePerf.java
Patch:
@@ -40,7 +40,7 @@ public class ReducePerf implements BiFunction<Integer, Integer, Integer> {
     Maybe<Integer> flowMaybe;
 
     @Override
-    public Integer apply(Integer t1, Integer t2) throws Exception {
+    public Integer apply(Integer t1, Integer t2) {
         return t1 + t2;
     }
 

File: src/jmh/java/io/reactivex/rxjava3/core/ToFlowablePerf.java
Patch:
@@ -48,7 +48,7 @@ public void setup() {
 
         final BiFunction<Integer, Integer, Integer> second = new BiFunction<Integer, Integer, Integer>() {
             @Override
-            public Integer apply(Integer a, Integer b) throws Exception {
+            public Integer apply(Integer a, Integer b) {
                 return b;
             }
         };
@@ -57,7 +57,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
 
         flowableInner = source.concatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
-            public Publisher<Integer> apply(Integer v) throws Exception {
+            public Publisher<Integer> apply(Integer v) {
                 return Flowable.range(1, 50).reduce(second).toFlowable();
             }
         });
@@ -68,7 +68,7 @@ public Publisher<Integer> apply(Integer v) throws Exception {
 
         observableInner = sourceObs.concatMap(new Function<Integer, Observable<Integer>>() {
             @Override
-            public Observable<Integer> apply(Integer v) throws Exception {
+            public Observable<Integer> apply(Integer v) {
                 return Observable.range(1, 50).reduce(second).toObservable();
             }
         });

File: src/main/java/io/reactivex/rxjava3/exceptions/CompositeException.java
Patch:
@@ -63,7 +63,6 @@ public CompositeException(@NonNull Throwable... exceptions) {
      */
     public CompositeException(@NonNull Iterable<? extends Throwable> errors) {
         Set<Throwable> deDupedExceptions = new LinkedHashSet<>();
-        List<Throwable> localExceptions = new ArrayList<>();
         if (errors != null) {
             for (Throwable ex : errors) {
                 if (ex instanceof CompositeException) {
@@ -81,7 +80,7 @@ public CompositeException(@NonNull Iterable<? extends Throwable> errors) {
         if (deDupedExceptions.isEmpty()) {
             throw new IllegalArgumentException("errors is empty");
         }
-        localExceptions.addAll(deDupedExceptions);
+        List<Throwable> localExceptions = new ArrayList<>(deDupedExceptions);
         this.exceptions = Collections.unmodifiableList(localExceptions);
         this.message = exceptions.size() + " exceptions occurred. ";
     }

File: src/main/java/io/reactivex/rxjava3/exceptions/package-info.java
Patch:
@@ -17,7 +17,7 @@
 /**
  * Exception handling utilities ({@link io.reactivex.rxjava3.exceptions.Exceptions Exceptions}),
  * composite exception container ({@link io.reactivex.rxjava3.exceptions.CompositeException CompositeException}) and
- * various lifecycle-reladed ({@link io.reactivex.rxjava3.exceptions.MissingBackpressureException UndeliverableException})
+ * various lifecycle-related ({@link io.reactivex.rxjava3.exceptions.MissingBackpressureException UndeliverableException})
  * and behavior-violation exception types ({@link io.reactivex.rxjava3.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException},
  * {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException MissingBackpressureException}).
  */

File: src/main/java/io/reactivex/rxjava3/internal/disposables/EmptyDisposable.java
Patch:
@@ -95,7 +95,7 @@ public boolean offer(Object v1, Object v2) {
 
     @Nullable
     @Override
-    public Object poll() throws Exception {
+    public Object poll() {
         return null; // always empty
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFlatMapStream.java
Patch:
@@ -112,7 +112,7 @@ public void onNext(@NonNull T t) {
                             done = true;
                             break;
                         }
-                        R value = Objects.requireNonNull(it.next(), "The Stream's Iterator.next retuned a null value");
+                        R value = Objects.requireNonNull(it.next(), "The Stream's Iterator.next returned a null value");
                         if (disposed) {
                             done = true;
                             break;

File: src/main/java/io/reactivex/rxjava3/internal/jdk8/ParallelCollector.java
Patch:
@@ -209,7 +209,6 @@ public void onNext(T t) {
                     Exceptions.throwIfFatal(ex);
                     get().cancel();
                     onError(ex);
-                    return;
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/observers/DeferredScalarDisposable.java
Patch:
@@ -114,7 +114,7 @@ public final void complete() {
 
     @Nullable
     @Override
-    public final T poll() throws Exception {
+    public final T poll() {
         if (get() == FUSED_READY) {
             T v = value;
             value = null;

File: src/main/java/io/reactivex/rxjava3/internal/observers/FutureObserver.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.Observer;
 import io.reactivex.rxjava3.disposables.Disposable;
 import io.reactivex.rxjava3.internal.disposables.DisposableHelper;
@@ -41,7 +42,7 @@ public final class FutureObserver<T> extends CountDownLatch
 
     public FutureObserver() {
         super(1);
-        this.upstream = new AtomicReference<Disposable>();
+        this.upstream = new AtomicReference<>();
     }
 
     @Override
@@ -90,7 +91,7 @@ public T get() throws InterruptedException, ExecutionException {
     }
 
     @Override
-    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+    public T get(long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
         if (getCount() != 0) {
             BlockingHelper.verifyNonBlocking();
             if (!await(timeout, unit)) {

File: src/main/java/io/reactivex/rxjava3/internal/observers/FutureSingleObserver.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.reactivex.rxjava3.annotations.NonNull;
 import io.reactivex.rxjava3.core.SingleObserver;
 import io.reactivex.rxjava3.disposables.Disposable;
 import io.reactivex.rxjava3.internal.disposables.DisposableHelper;
@@ -40,7 +41,7 @@ public final class FutureSingleObserver<T> extends CountDownLatch
 
     public FutureSingleObserver() {
         super(1);
-        this.upstream = new AtomicReference<Disposable>();
+        this.upstream = new AtomicReference<>();
     }
 
     @Override
@@ -89,7 +90,7 @@ public T get() throws InterruptedException, ExecutionException {
     }
 
     @Override
-    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+    public T get(long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
         if (getCount() != 0) {
             BlockingHelper.verifyNonBlocking();
             if (!await(timeout, unit)) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableCache.java
Patch:
@@ -39,7 +39,7 @@ public final class CompletableCache extends Completable implements CompletableOb
 
     public CompletableCache(CompletableSource source) {
         this.source = source;
-        this.observers = new AtomicReference<InnerCompletableCache[]>(EMPTY);
+        this.observers = new AtomicReference<>(EMPTY);
         this.once = new AtomicBoolean();
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableConcat.java
Patch:
@@ -106,9 +106,9 @@ public void onSubscribe(Subscription s) {
                 }
 
                 if (prefetch == Integer.MAX_VALUE) {
-                    queue = new SpscLinkedArrayQueue<CompletableSource>(Flowable.bufferSize());
+                    queue = new SpscLinkedArrayQueue<>(Flowable.bufferSize());
                 } else {
-                    queue = new SpscArrayQueue<CompletableSource>(prefetch);
+                    queue = new SpscArrayQueue<>(prefetch);
                 }
 
                 downstream.onSubscribe(this);

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -26,7 +26,7 @@ public CompletableFromObservable(ObservableSource<T> observable) {
 
     @Override
     protected void subscribeActual(final CompletableObserver observer) {
-        observable.subscribe(new CompletableFromObservableObserver<T>(observer));
+        observable.subscribe(new CompletableFromObservableObserver<>(observer));
     }
 
     static final class CompletableFromObservableObserver<T> implements Observer<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromPublisher.java
Patch:
@@ -29,7 +29,7 @@ public CompletableFromPublisher(Publisher<T> flowable) {
 
     @Override
     protected void subscribeActual(final CompletableObserver downstream) {
-        flowable.subscribe(new FromPublisherSubscriber<T>(downstream));
+        flowable.subscribe(new FromPublisherSubscriber<>(downstream));
     }
 
     static final class FromPublisherSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -26,7 +26,7 @@ public CompletableFromSingle(SingleSource<T> single) {
 
     @Override
     protected void subscribeActual(final CompletableObserver observer) {
-        single.subscribe(new CompletableFromSingleObserver<T>(observer));
+        single.subscribe(new CompletableFromSingleObserver<>(observer));
     }
 
     static final class CompletableFromSingleObserver<T> implements SingleObserver<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMaterialize.java
Patch:
@@ -34,6 +34,6 @@ public CompletableMaterialize(Completable source) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super Notification<T>> observer) {
-        source.subscribe(new MaterializeSingleObserver<T>(observer));
+        source.subscribe(new MaterializeSingleObserver<>(observer));
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToFlowable.java
Patch:
@@ -28,7 +28,7 @@ public CompletableToFlowable(CompletableSource source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        SubscriberCompletableObserver<T> os = new SubscriberCompletableObserver<T>(s);
+        SubscriberCompletableObserver<T> os = new SubscriberCompletableObserver<>(s);
         source.subscribe(os);
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToObservable.java
Patch:
@@ -71,7 +71,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public Void poll() throws Exception {
+        public Void poll() {
             return null; // always empty
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableUsing.java
Patch:
@@ -80,7 +80,7 @@ protected void subscribeActual(CompletableObserver observer) {
             return;
         }
 
-        source.subscribe(new UsingObserver<R>(observer, resource, disposer, eager));
+        source.subscribe(new UsingObserver<>(observer, resource, disposer, eager));
     }
 
     static final class UsingObserver<R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java
Patch:
@@ -38,7 +38,7 @@ public BlockingFlowableIterable(Flowable<T> source, int bufferSize) {
 
     @Override
     public Iterator<T> iterator() {
-        BlockingFlowableIterator<T> it = new BlockingFlowableIterator<T>(bufferSize);
+        BlockingFlowableIterator<T> it = new BlockingFlowableIterator<>(bufferSize);
         source.subscribe(it);
         return it;
     }
@@ -65,7 +65,7 @@ static final class BlockingFlowableIterator<T>
         volatile Throwable error;
 
         BlockingFlowableIterator(int batchSize) {
-            this.queue = new SpscArrayQueue<T>(batchSize);
+            this.queue = new SpscArrayQueue<>(batchSize);
             this.batchSize = batchSize;
             this.limit = batchSize - (batchSize >> 2);
             this.lock = new ReentrantLock();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableLatest.java
Patch:
@@ -39,7 +39,7 @@ public BlockingFlowableLatest(Publisher<? extends T> source) {
 
     @Override
     public Iterator<T> iterator() {
-        LatestSubscriberIterator<T> lio = new LatestSubscriberIterator<T>();
+        LatestSubscriberIterator<T> lio = new LatestSubscriberIterator<>();
         Flowable.<T>fromPublisher(source).materialize().subscribe(lio);
         return lio;
     }
@@ -48,7 +48,7 @@ public Iterator<T> iterator() {
     static final class LatestSubscriberIterator<T> extends DisposableSubscriber<Notification<T>> implements Iterator<T> {
         final Semaphore notify = new Semaphore(0);
         // observer's notification
-        final AtomicReference<Notification<T>> value = new AtomicReference<Notification<T>>();
+        final AtomicReference<Notification<T>> value = new AtomicReference<>();
 
         // iterator's notification
         Notification<T> iteratorNotification;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -40,7 +40,7 @@ public BlockingFlowableMostRecent(Flowable<T> source, T initialValue) {
 
     @Override
     public Iterator<T> iterator() {
-        MostRecentSubscriber<T> mostRecentSubscriber = new MostRecentSubscriber<T>(initialValue);
+        MostRecentSubscriber<T> mostRecentSubscriber = new MostRecentSubscriber<>(initialValue);
 
         source.subscribe(mostRecentSubscriber);
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableNext.java
Patch:
@@ -41,8 +41,8 @@ public BlockingFlowableNext(Publisher<? extends T> source) {
 
     @Override
     public Iterator<T> iterator() {
-        NextSubscriber<T> nextSubscriber = new NextSubscriber<T>();
-        return new NextIterator<T>(source, nextSubscriber);
+        NextSubscriber<T> nextSubscriber = new NextSubscriber<>();
+        return new NextIterator<>(source, nextSubscriber);
     }
 
     // test needs to access the observer.waiting flag
@@ -133,7 +133,7 @@ public void remove() {
     }
 
     static final class NextSubscriber<T> extends DisposableSubscriber<Notification<T>> {
-        private final BlockingQueue<Notification<T>> buf = new ArrayBlockingQueue<Notification<T>>(1);
+        private final BlockingQueue<Notification<T>> buf = new ArrayBlockingQueue<>(1);
         final AtomicInteger waiting = new AtomicInteger();
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAll.java
Patch:
@@ -31,7 +31,7 @@ public FlowableAll(Flowable<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(Subscriber<? super Boolean> s) {
-        source.subscribe(new AllSubscriber<T>(s, predicate));
+        source.subscribe(new AllSubscriber<>(s, predicate));
     }
 
     static final class AllSubscriber<T> extends DeferredScalarSubscription<Boolean> implements FlowableSubscriber<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAllSingle.java
Patch:
@@ -35,12 +35,12 @@ public FlowableAllSingle(Flowable<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super Boolean> observer) {
-        source.subscribe(new AllSubscriber<T>(observer, predicate));
+        source.subscribe(new AllSubscriber<>(observer, predicate));
     }
 
     @Override
     public Flowable<Boolean> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableAll<T>(source, predicate));
+        return RxJavaPlugins.onAssembly(new FlowableAll<>(source, predicate));
     }
 
     static final class AllSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAmb.java
Patch:
@@ -69,7 +69,7 @@ public void subscribeActual(Subscriber<? super T> s) {
             return;
         }
 
-        AmbCoordinator<T> ac = new AmbCoordinator<T>(s, count);
+        AmbCoordinator<T> ac = new AmbCoordinator<>(s, count);
         ac.subscribe(sources);
     }
 
@@ -89,7 +89,7 @@ public void subscribe(Publisher<? extends T>[] sources) {
             AmbInnerSubscriber<T>[] as = subscribers;
             int len = as.length;
             for (int i = 0; i < len; i++) {
-                as[i] = new AmbInnerSubscriber<T>(this, i + 1, downstream);
+                as[i] = new AmbInnerSubscriber<>(this, i + 1, downstream);
             }
             winner.lazySet(0); // release the contents of 'as'
             downstream.onSubscribe(this);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAny.java
Patch:
@@ -29,7 +29,7 @@ public FlowableAny(Flowable<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(Subscriber<? super Boolean> s) {
-        source.subscribe(new AnySubscriber<T>(s, predicate));
+        source.subscribe(new AnySubscriber<>(s, predicate));
     }
 
     static final class AnySubscriber<T> extends DeferredScalarSubscription<Boolean> implements FlowableSubscriber<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAnySingle.java
Patch:
@@ -34,12 +34,12 @@ public FlowableAnySingle(Flowable<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super Boolean> observer) {
-        source.subscribe(new AnySubscriber<T>(observer, predicate));
+        source.subscribe(new AnySubscriber<>(observer, predicate));
     }
 
     @Override
     public Flowable<Boolean> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableAny<T>(source, predicate));
+        return RxJavaPlugins.onAssembly(new FlowableAny<>(source, predicate));
     }
 
     static final class AnySubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBlockingSubscribe.java
Patch:
@@ -42,9 +42,9 @@ private FlowableBlockingSubscribe() {
      * @param <T> the value type
      */
     public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T> subscriber) {
-        final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();
+        final BlockingQueue<Object> queue = new LinkedBlockingQueue<>();
 
-        BlockingSubscriber<T> bs = new BlockingSubscriber<T>(queue);
+        BlockingSubscriber<T> bs = new BlockingSubscriber<>(queue);
 
         o.subscribe(bs);
 
@@ -82,7 +82,7 @@ public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T>
      */
     public static <T> void subscribe(Publisher<? extends T> o) {
         BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();
-        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(Functions.emptyConsumer(),
+        LambdaSubscriber<T> ls = new LambdaSubscriber<>(Functions.emptyConsumer(),
         callback, callback, Functions.REQUEST_MAX);
 
         o.subscribe(ls);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.java
Patch:
@@ -41,7 +41,7 @@ public FlowableBufferExactBoundary(Flowable<T> source, Publisher<B> boundary, Su
 
     @Override
     protected void subscribeActual(Subscriber<? super U> s) {
-        source.subscribe(new BufferExactBoundarySubscriber<T, U, B>(new SerializedSubscriber<U>(s), bufferSupplier, boundary));
+        source.subscribe(new BufferExactBoundarySubscriber<>(new SerializedSubscriber<>(s), bufferSupplier, boundary));
     }
 
     static final class BufferExactBoundarySubscriber<T, U extends Collection<? super T>, B>
@@ -58,7 +58,7 @@ static final class BufferExactBoundarySubscriber<T, U extends Collection<? super
 
         BufferExactBoundarySubscriber(Subscriber<? super U> actual, Supplier<U> bufferSupplier,
                                              Publisher<B> boundary) {
-            super(actual, new MpscLinkedQueue<U>());
+            super(actual, new MpscLinkedQueue<>());
             this.bufferSupplier = bufferSupplier;
             this.boundary = boundary;
         }
@@ -84,7 +84,7 @@ public void onSubscribe(Subscription s) {
 
             buffer = b;
 
-            BufferBoundarySubscriber<T, U, B> bs = new BufferBoundarySubscriber<T, U, B>(this);
+            BufferBoundarySubscriber<T, U, B> bs = new BufferBoundarySubscriber<>(this);
             other = bs;
 
             downstream.onSubscribe(this);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCollect.java
Patch:
@@ -44,7 +44,7 @@ protected void subscribeActual(Subscriber<? super U> s) {
             return;
         }
 
-        source.subscribe(new CollectSubscriber<T, U>(s, u, collector));
+        source.subscribe(new CollectSubscriber<>(s, u, collector));
     }
 
     static final class CollectSubscriber<T, U> extends DeferredScalarSubscription<U> implements FlowableSubscriber<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCollectSingle.java
Patch:
@@ -49,12 +49,12 @@ protected void subscribeActual(SingleObserver<? super U> observer) {
             return;
         }
 
-        source.subscribe(new CollectSubscriber<T, U>(observer, u, collector));
+        source.subscribe(new CollectSubscriber<>(observer, u, collector));
     }
 
     @Override
     public Flowable<U> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableCollect<T, U>(source, initialSupplier, collector));
+        return RxJavaPlugins.onAssembly(new FlowableCollect<>(source, initialSupplier, collector));
     }
 
     static final class CollectSubscriber<T, U> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatArray.java
Patch:
@@ -34,7 +34,7 @@ public FlowableConcatArray(Publisher<? extends T>[] sources, boolean delayError)
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        ConcatArraySubscriber<T> parent = new ConcatArraySubscriber<T>(sources, delayError, s);
+        ConcatArraySubscriber<T> parent = new ConcatArraySubscriber<>(sources, delayError, s);
         s.onSubscribe(parent);
 
         parent.onComplete();
@@ -82,7 +82,7 @@ public void onError(Throwable t) {
             if (delayError) {
                 List<Throwable> list = errors;
                 if (list == null) {
-                    list = new ArrayList<Throwable>(sources.length - index + 1);
+                    list = new ArrayList<>(sources.length - index + 1);
                     errors = list;
                 }
                 list.add(t);
@@ -121,7 +121,7 @@ public void onComplete() {
                         if (delayError) {
                             List<Throwable> list = errors;
                             if (list == null) {
-                                list = new ArrayList<Throwable>(n - i + 1);
+                                list = new ArrayList<>(n - i + 1);
                                 errors = list;
                             }
                             list.add(ex);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapEager.java
Patch:
@@ -51,7 +51,7 @@ public FlowableConcatMapEager(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new ConcatMapEagerDelayErrorSubscriber<T, R>(
+        source.subscribe(new ConcatMapEagerDelayErrorSubscriber<>(
                 s, mapper, maxConcurrency, prefetch, errorMode));
     }
 
@@ -93,7 +93,7 @@ static final class ConcatMapEagerDelayErrorSubscriber<T, R>
             this.maxConcurrency = maxConcurrency;
             this.prefetch = prefetch;
             this.errorMode = errorMode;
-            this.subscribers = new SpscLinkedArrayQueue<InnerQueuedSubscriber<R>>(Math.min(prefetch, maxConcurrency));
+            this.subscribers = new SpscLinkedArrayQueue<>(Math.min(prefetch, maxConcurrency));
             this.errors = new AtomicThrowable();
             this.requested = new AtomicLong();
         }
@@ -123,7 +123,7 @@ public void onNext(T t) {
                 return;
             }
 
-            InnerQueuedSubscriber<R> inner = new InnerQueuedSubscriber<R>(this, prefetch);
+            InnerQueuedSubscriber<R> inner = new InnerQueuedSubscriber<>(this, prefetch);
 
             if (cancelled) {
                 return;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapEagerPublisher.java
Patch:
@@ -53,7 +53,7 @@ public FlowableConcatMapEagerPublisher(Publisher<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new ConcatMapEagerDelayErrorSubscriber<T, R>(
+        source.subscribe(new ConcatMapEagerDelayErrorSubscriber<>(
                 s, mapper, maxConcurrency, prefetch, errorMode));
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatWithCompletable.java
Patch:
@@ -40,7 +40,7 @@ public FlowableConcatWithCompletable(Flowable<T> source, CompletableSource other
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ConcatWithSubscriber<T>(s, other));
+        source.subscribe(new ConcatWithSubscriber<>(s, other));
     }
 
     static final class ConcatWithSubscriber<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatWithMaybe.java
Patch:
@@ -41,7 +41,7 @@ public FlowableConcatWithMaybe(Flowable<T> source, MaybeSource<? extends T> othe
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ConcatWithSubscriber<T>(s, other));
+        source.subscribe(new ConcatWithSubscriber<>(s, other));
     }
 
     static final class ConcatWithSubscriber<T>
@@ -59,7 +59,7 @@ static final class ConcatWithSubscriber<T>
         ConcatWithSubscriber(Subscriber<? super T> actual, MaybeSource<? extends T> other) {
             super(actual);
             this.other = other;
-            this.otherDisposable = new AtomicReference<Disposable>();
+            this.otherDisposable = new AtomicReference<>();
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatWithSingle.java
Patch:
@@ -41,7 +41,7 @@ public FlowableConcatWithSingle(Flowable<T> source, SingleSource<? extends T> ot
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ConcatWithSubscriber<T>(s, other));
+        source.subscribe(new ConcatWithSubscriber<>(s, other));
     }
 
     static final class ConcatWithSubscriber<T>
@@ -57,7 +57,7 @@ static final class ConcatWithSubscriber<T>
         ConcatWithSubscriber(Subscriber<? super T> actual, SingleSource<? extends T> other) {
             super(actual);
             this.other = other;
-            this.otherDisposable = new AtomicReference<Disposable>();
+            this.otherDisposable = new AtomicReference<>();
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCountSingle.java
Patch:
@@ -36,7 +36,7 @@ protected void subscribeActual(SingleObserver<? super Long> observer) {
 
     @Override
     public Flowable<Long> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableCount<T>(source));
+        return RxJavaPlugins.onAssembly(new FlowableCount<>(source));
     }
 
     static final class CountSubscriber implements FlowableSubscriber<Object>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -38,7 +38,7 @@ public FlowableDebounce(Flowable<T> source, Function<? super T, ? extends Publis
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new DebounceSubscriber<T, U>(new SerializedSubscriber<T>(s), debounceSelector));
+        source.subscribe(new DebounceSubscriber<>(new SerializedSubscriber<>(s), debounceSelector));
     }
 
     static final class DebounceSubscriber<T, U> extends AtomicLong
@@ -50,7 +50,7 @@ static final class DebounceSubscriber<T, U> extends AtomicLong
 
         Subscription upstream;
 
-        final AtomicReference<Disposable> debouncer = new AtomicReference<Disposable>();
+        final AtomicReference<Disposable> debouncer = new AtomicReference<>();
 
         volatile long index;
 
@@ -96,7 +96,7 @@ public void onNext(T t) {
                 return;
             }
 
-            DebounceInnerSubscriber<T, U> dis = new DebounceInnerSubscriber<T, U>(this, idx, t);
+            DebounceInnerSubscriber<T, U> dis = new DebounceInnerSubscriber<>(this, idx, t);
 
             if (debouncer.compareAndSet(d, dis)) {
                 p.subscribe(dis);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -42,8 +42,8 @@ public FlowableDebounceTimed(Flowable<T> source, long timeout, TimeUnit unit, Sc
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new DebounceTimedSubscriber<T>(
-                new SerializedSubscriber<T>(s),
+        source.subscribe(new DebounceTimedSubscriber<>(
+                new SerializedSubscriber<>(s),
                 timeout, unit, scheduler.createWorker()));
     }
 
@@ -93,7 +93,7 @@ public void onNext(T t) {
                 d.dispose();
             }
 
-            DebounceEmitter<T> de = new DebounceEmitter<T>(t, idx, this);
+            DebounceEmitter<T> de = new DebounceEmitter<>(t, idx, this);
             timer = de;
             d = worker.schedule(de, timeout, unit);
             de.setResource(d);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelay.java
Patch:
@@ -42,12 +42,12 @@ protected void subscribeActual(Subscriber<? super T> t) {
         if (delayError) {
             downstream = t;
         } else {
-            downstream = new SerializedSubscriber<T>(t);
+            downstream = new SerializedSubscriber<>(t);
         }
 
         Scheduler.Worker w = scheduler.createWorker();
 
-        source.subscribe(new DelaySubscriber<T>(downstream, delay, unit, w, delayError));
+        source.subscribe(new DelaySubscriber<>(downstream, delay, unit, w, delayError));
     }
 
     static final class DelaySubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelaySubscriptionOther.java
Patch:
@@ -37,7 +37,7 @@ public FlowableDelaySubscriptionOther(Publisher<? extends T> main, Publisher<U>
 
     @Override
     public void subscribeActual(final Subscriber<? super T> child) {
-        MainSubscriber<T> parent = new MainSubscriber<T>(child, main);
+        MainSubscriber<T> parent = new MainSubscriber<>(child, main);
         child.onSubscribe(parent);
         other.subscribe(parent.other);
     }
@@ -58,7 +58,7 @@ static final class MainSubscriber<T> extends AtomicLong implements FlowableSubsc
             this.downstream = downstream;
             this.main = main;
             this.other = new OtherSubscriber();
-            this.upstream = new AtomicReference<Subscription>();
+            this.upstream = new AtomicReference<>();
         }
 
         void next() {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDematerialize.java
Patch:
@@ -34,7 +34,7 @@ public FlowableDematerialize(Flowable<T> source, Function<? super T, ? extends N
 
     @Override
     protected void subscribeActual(Subscriber<? super R> subscriber) {
-        source.subscribe(new DematerializeSubscriber<T, R>(subscriber, selector));
+        source.subscribe(new DematerializeSubscriber<>(subscriber, selector));
     }
 
     static final class DematerializeSubscriber<T, R> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDetach.java
Patch:
@@ -27,7 +27,7 @@ public FlowableDetach(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new DetachSubscriber<T>(s));
+        source.subscribe(new DetachSubscriber<>(s));
     }
 
     static final class DetachSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -52,7 +52,7 @@ protected void subscribeActual(Subscriber<? super T> subscriber) {
             return;
         }
 
-        source.subscribe(new DistinctSubscriber<T, K>(subscriber, keySelector, collection));
+        source.subscribe(new DistinctSubscriber<>(subscriber, keySelector, collection));
     }
 
     static final class DistinctSubscriber<T, K> extends BasicFuseableSubscriber<T, T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDistinctUntilChanged.java
Patch:
@@ -37,9 +37,9 @@ public FlowableDistinctUntilChanged(Flowable<T> source, Function<? super T, K> k
     protected void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
             ConditionalSubscriber<? super T> cs = (ConditionalSubscriber<? super T>) s;
-            source.subscribe(new DistinctUntilChangedConditionalSubscriber<T, K>(cs, keySelector, comparer));
+            source.subscribe(new DistinctUntilChangedConditionalSubscriber<>(cs, keySelector, comparer));
         } else {
-            source.subscribe(new DistinctUntilChangedSubscriber<T, K>(s, keySelector, comparer));
+            source.subscribe(new DistinctUntilChangedSubscriber<>(s, keySelector, comparer));
         }
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoAfterNext.java
Patch:
@@ -39,9 +39,9 @@ public FlowableDoAfterNext(Flowable<T> source, Consumer<? super T> onAfterNext)
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
-            source.subscribe(new DoAfterConditionalSubscriber<T>((ConditionalSubscriber<? super T>)s, onAfterNext));
+            source.subscribe(new DoAfterConditionalSubscriber<>((ConditionalSubscriber<? super T>) s, onAfterNext));
         } else {
-            source.subscribe(new DoAfterSubscriber<T>(s, onAfterNext));
+            source.subscribe(new DoAfterSubscriber<>(s, onAfterNext));
         }
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoFinally.java
Patch:
@@ -41,9 +41,9 @@ public FlowableDoFinally(Flowable<T> source, Action onFinally) {
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
-            source.subscribe(new DoFinallyConditionalSubscriber<T>((ConditionalSubscriber<? super T>)s, onFinally));
+            source.subscribe(new DoFinallyConditionalSubscriber<>((ConditionalSubscriber<? super T>) s, onFinally));
         } else {
-            source.subscribe(new DoFinallySubscriber<T>(s, onFinally));
+            source.subscribe(new DoFinallySubscriber<>(s, onFinally));
         }
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -44,10 +44,10 @@ public FlowableDoOnEach(Flowable<T> source, Consumer<? super T> onNext,
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
-            source.subscribe(new DoOnEachConditionalSubscriber<T>(
-                    (ConditionalSubscriber<? super T>)s, onNext, onError, onComplete, onAfterTerminate));
+            source.subscribe(new DoOnEachConditionalSubscriber<>(
+                    (ConditionalSubscriber<? super T>) s, onNext, onError, onComplete, onAfterTerminate));
         } else {
-            source.subscribe(new DoOnEachSubscriber<T>(
+            source.subscribe(new DoOnEachSubscriber<>(
                     s, onNext, onError, onComplete, onAfterTerminate));
         }
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoOnLifecycle.java
Patch:
@@ -35,7 +35,7 @@ public FlowableDoOnLifecycle(Flowable<T> source, Consumer<? super Subscription>
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SubscriptionLambdaSubscriber<T>(s, onSubscribe, onRequest, onCancel));
+        source.subscribe(new SubscriptionLambdaSubscriber<>(s, onSubscribe, onRequest, onCancel));
     }
 
     static final class SubscriptionLambdaSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableElementAt.java
Patch:
@@ -35,7 +35,7 @@ public FlowableElementAt(Flowable<T> source, long index, T defaultValue, boolean
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ElementAtSubscriber<T>(s, index, defaultValue, errorOnFewer));
+        source.subscribe(new ElementAtSubscriber<>(s, index, defaultValue, errorOnFewer));
     }
 
     static final class ElementAtSubscriber<T> extends DeferredScalarSubscription<T> implements FlowableSubscriber<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableElementAtMaybe.java
Patch:
@@ -33,12 +33,12 @@ public FlowableElementAtMaybe(Flowable<T> source, long index) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new ElementAtSubscriber<T>(observer, index));
+        source.subscribe(new ElementAtSubscriber<>(observer, index));
     }
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(source, index, null, false));
+        return RxJavaPlugins.onAssembly(new FlowableElementAt<>(source, index, null, false));
     }
 
     static final class ElementAtSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableElementAtSingle.java
Patch:
@@ -38,12 +38,12 @@ public FlowableElementAtSingle(Flowable<T> source, long index, T defaultValue) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super T> observer) {
-        source.subscribe(new ElementAtSubscriber<T>(observer, index, defaultValue));
+        source.subscribe(new ElementAtSubscriber<>(observer, index, defaultValue));
     }
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(source, index, defaultValue, true));
+        return RxJavaPlugins.onAssembly(new FlowableElementAt<>(source, index, defaultValue, true));
     }
 
     static final class ElementAtSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -31,10 +31,10 @@ public FlowableFilter(Flowable<T> source, Predicate<? super T> predicate) {
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
-            source.subscribe(new FilterConditionalSubscriber<T>(
-                    (ConditionalSubscriber<? super T>)s, predicate));
+            source.subscribe(new FilterConditionalSubscriber<>(
+                    (ConditionalSubscriber<? super T>) s, predicate));
         } else {
-            source.subscribe(new FilterSubscriber<T>(s, predicate));
+            source.subscribe(new FilterSubscriber<>(s, predicate));
         }
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapCompletable.java
Patch:
@@ -50,7 +50,7 @@ public FlowableFlatMapCompletable(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super T> subscriber) {
-        source.subscribe(new FlatMapCompletableMainSubscriber<T>(subscriber, mapper, delayErrors, maxConcurrency));
+        source.subscribe(new FlatMapCompletableMainSubscriber<>(subscriber, mapper, delayErrors, maxConcurrency));
     }
 
     static final class FlatMapCompletableMainSubscriber<T> extends BasicIntQueueSubscription<T>
@@ -171,7 +171,7 @@ public void request(long n) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() {
             return null; // always empty
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
Patch:
@@ -53,12 +53,12 @@ public FlowableFlatMapCompletableCompletable(Flowable<T> source,
 
     @Override
     protected void subscribeActual(CompletableObserver observer) {
-        source.subscribe(new FlatMapCompletableMainSubscriber<T>(observer, mapper, delayErrors, maxConcurrency));
+        source.subscribe(new FlatMapCompletableMainSubscriber<>(observer, mapper, delayErrors, maxConcurrency));
     }
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableFlatMapCompletable<T>(source, mapper, delayErrors, maxConcurrency));
+        return RxJavaPlugins.onAssembly(new FlowableFlatMapCompletable<>(source, mapper, delayErrors, maxConcurrency));
     }
 
     static final class FlatMapCompletableMainSubscriber<T> extends AtomicInteger

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapMaybe.java
Patch:
@@ -50,7 +50,7 @@ public FlowableFlatMapMaybe(Flowable<T> source, Function<? super T, ? extends Ma
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new FlatMapMaybeSubscriber<T, R>(s, mapper, delayErrors, maxConcurrency));
+        source.subscribe(new FlatMapMaybeSubscriber<>(s, mapper, delayErrors, maxConcurrency));
     }
 
     static final class FlatMapMaybeSubscriber<T, R>
@@ -91,7 +91,7 @@ static final class FlatMapMaybeSubscriber<T, R>
             this.set = new CompositeDisposable();
             this.errors = new AtomicThrowable();
             this.active = new AtomicInteger(1);
-            this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();
+            this.queue = new AtomicReference<>();
         }
 
         @Override
@@ -210,7 +210,7 @@ SpscLinkedArrayQueue<R> getOrCreateQueue() {
                 if (current != null) {
                     return current;
                 }
-                current = new SpscLinkedArrayQueue<R>(Flowable.bufferSize());
+                current = new SpscLinkedArrayQueue<>(Flowable.bufferSize());
                 if (queue.compareAndSet(null, current)) {
                     return current;
                 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapSingle.java
Patch:
@@ -50,7 +50,7 @@ public FlowableFlatMapSingle(Flowable<T> source, Function<? super T, ? extends S
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new FlatMapSingleSubscriber<T, R>(s, mapper, delayErrors, maxConcurrency));
+        source.subscribe(new FlatMapSingleSubscriber<>(s, mapper, delayErrors, maxConcurrency));
     }
 
     static final class FlatMapSingleSubscriber<T, R>
@@ -91,7 +91,7 @@ static final class FlatMapSingleSubscriber<T, R>
             this.set = new CompositeDisposable();
             this.errors = new AtomicThrowable();
             this.active = new AtomicInteger(1);
-            this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();
+            this.queue = new AtomicReference<>();
         }
 
         @Override
@@ -210,7 +210,7 @@ SpscLinkedArrayQueue<R> getOrCreateQueue() {
                 if (current != null) {
                     return current;
                 }
-                current = new SpscLinkedArrayQueue<R>(Flowable.bufferSize());
+                current = new SpscLinkedArrayQueue<>(Flowable.bufferSize());
                 if (queue.compareAndSet(null, current)) {
                     return current;
                 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -76,7 +76,7 @@ public void subscribeActual(Subscriber<? super R> s) {
 
             return;
         }
-        source.subscribe(new FlattenIterableSubscriber<T, R>(s, mapper, prefetch));
+        source.subscribe(new FlattenIterableSubscriber<>(s, mapper, prefetch));
     }
 
     /**

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -33,10 +33,10 @@ public FlowableFromArray(T[] array) {
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
-            s.onSubscribe(new ArrayConditionalSubscription<T>(
+            s.onSubscribe(new ArrayConditionalSubscription<>(
                     (ConditionalSubscriber<? super T>)s, array));
         } else {
-            s.onSubscribe(new ArraySubscription<T>(s, array));
+            s.onSubscribe(new ArraySubscription<>(s, array));
         }
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromCallable.java
Patch:
@@ -32,7 +32,7 @@ public FlowableFromCallable(Callable<? extends T> callable) {
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s);
+        DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<>(s);
         s.onSubscribe(deferred);
 
         T t;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromFuture.java
Patch:
@@ -35,7 +35,7 @@ public FlowableFromFuture(Future<? extends T> future, long timeout, TimeUnit uni
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s);
+        DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<>(s);
         s.onSubscribe(deferred);
 
         T v;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromObservable.java
Patch:
@@ -26,7 +26,7 @@ public FlowableFromObservable(Observable<T> upstream) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        upstream.subscribe(new SubscriberObserver<T>(s));
+        upstream.subscribe(new SubscriberObserver<>(s));
     }
 
     static final class SubscriberObserver<T> implements Observer<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromSupplier.java
Patch:
@@ -38,7 +38,7 @@ public FlowableFromSupplier(Supplier<? extends T> supplier) {
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s);
+        DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<>(s);
         s.onSubscribe(deferred);
 
         T t;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGenerate.java
Patch:
@@ -48,7 +48,7 @@ public void subscribeActual(Subscriber<? super T> s) {
             return;
         }
 
-        s.onSubscribe(new GeneratorSubscription<T, S>(s, generator, disposeState, state));
+        s.onSubscribe(new GeneratorSubscription<>(s, generator, disposeState, state));
     }
 
     static final class GeneratorSubscription<T, S>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableHide.java
Patch:
@@ -32,7 +32,7 @@ public FlowableHide(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new HideSubscriber<T>(s));
+        source.subscribe(new HideSubscriber<>(s));
     }
 
     static final class HideSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableIgnoreElements.java
Patch:
@@ -28,7 +28,7 @@ public FlowableIgnoreElements(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(final Subscriber<? super T> t) {
-        source.subscribe(new IgnoreElementsSubscriber<T>(t));
+        source.subscribe(new IgnoreElementsSubscriber<>(t));
     }
 
     static final class IgnoreElementsSubscriber<T> implements FlowableSubscriber<T>, QueueSubscription<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableIgnoreElementsCompletable.java
Patch:
@@ -31,12 +31,12 @@ public FlowableIgnoreElementsCompletable(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(final CompletableObserver t) {
-        source.subscribe(new IgnoreElementsSubscriber<T>(t));
+        source.subscribe(new IgnoreElementsSubscriber<>(t));
     }
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableIgnoreElements<T>(source));
+        return RxJavaPlugins.onAssembly(new FlowableIgnoreElements<>(source));
     }
 
     static final class IgnoreElementsSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableInterval.java
Patch:
@@ -66,7 +66,7 @@ static final class IntervalSubscriber extends AtomicLong
 
         long count;
 
-        final AtomicReference<Disposable> resource = new AtomicReference<Disposable>();
+        final AtomicReference<Disposable> resource = new AtomicReference<>();
 
         IntervalSubscriber(Subscriber<? super Long> downstream) {
             this.downstream = downstream;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableIntervalRange.java
Patch:
@@ -71,7 +71,7 @@ static final class IntervalRangeSubscriber extends AtomicLong
 
         long count;
 
-        final AtomicReference<Disposable> resource = new AtomicReference<Disposable>();
+        final AtomicReference<Disposable> resource = new AtomicReference<>();
 
         IntervalRangeSubscriber(Subscriber<? super Long> actual, long start, long end) {
             this.downstream = actual;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJust.java
Patch:
@@ -31,7 +31,7 @@ public FlowableJust(final T value) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        s.onSubscribe(new ScalarSubscription<T>(s, value));
+        s.onSubscribe(new ScalarSubscription<>(s, value));
     }
 
     @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableLastMaybe.java
Patch:
@@ -36,7 +36,7 @@ public FlowableLastMaybe(Publisher<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new LastSubscriber<T>(observer));
+        source.subscribe(new LastSubscriber<>(observer));
     }
 
     static final class LastSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableLastSingle.java
Patch:
@@ -42,7 +42,7 @@ public FlowableLastSingle(Publisher<T> source, T defaultItem) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super T> observer) {
-        source.subscribe(new LastSubscriber<T>(observer, defaultItem));
+        source.subscribe(new LastSubscriber<>(observer, defaultItem));
     }
 
     static final class LastSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMapNotification.java
Patch:
@@ -41,7 +41,7 @@ public FlowableMapNotification(
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new MapNotificationSubscriber<T, R>(s, onNextMapper, onErrorMapper, onCompleteSupplier));
+        source.subscribe(new MapNotificationSubscriber<>(s, onNextMapper, onErrorMapper, onCompleteSupplier));
     }
 
     static final class MapNotificationSubscriber<T, R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMaterialize.java
Patch:
@@ -27,7 +27,7 @@ public FlowableMaterialize(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super Notification<T>> s) {
-        source.subscribe(new MaterializeSubscriber<T>(s));
+        source.subscribe(new MaterializeSubscriber<>(s));
     }
 
     static final class MaterializeSubscriber<T> extends SinglePostCompleteSubscriber<T, Notification<T>> {
@@ -46,12 +46,12 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable t) {
-            complete(Notification.<T>createOnError(t));
+            complete(Notification.createOnError(t));
         }
 
         @Override
         public void onComplete() {
-            complete(Notification.<T>createOnComplete());
+            complete(Notification.createOnComplete());
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMergeWithCompletable.java
Patch:
@@ -41,7 +41,7 @@ public FlowableMergeWithCompletable(Flowable<T> source, CompletableSource other)
 
     @Override
     protected void subscribeActual(Subscriber<? super T> subscriber) {
-        MergeWithSubscriber<T> parent = new MergeWithSubscriber<T>(subscriber);
+        MergeWithSubscriber<T> parent = new MergeWithSubscriber<>(subscriber);
         subscriber.onSubscribe(parent);
         source.subscribe(parent);
         other.subscribe(parent.otherObserver);
@@ -68,7 +68,7 @@ static final class MergeWithSubscriber<T> extends AtomicInteger
 
         MergeWithSubscriber(Subscriber<? super T> downstream) {
             this.downstream = downstream;
-            this.mainSubscription = new AtomicReference<Subscription>();
+            this.mainSubscription = new AtomicReference<>();
             this.otherObserver = new OtherObserver(this);
             this.errors = new AtomicThrowable();
             this.requested = new AtomicLong();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
Patch:
@@ -48,7 +48,7 @@ public FlowableOnBackpressureBufferStrategy(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new OnBackpressureBufferStrategySubscriber<T>(s, onOverflow, strategy, bufferSize));
+        source.subscribe(new OnBackpressureBufferStrategySubscriber<>(s, onOverflow, strategy, bufferSize));
     }
 
     static final class OnBackpressureBufferStrategySubscriber<T>
@@ -83,7 +83,7 @@ static final class OnBackpressureBufferStrategySubscriber<T>
             this.strategy = strategy;
             this.bufferSize = bufferSize;
             this.requested = new AtomicLong();
-            this.deque = new ArrayDeque<T>();
+            this.deque = new ArrayDeque<>();
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureDrop.java
Patch:
@@ -45,7 +45,7 @@ public void accept(T t) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        this.source.subscribe(new BackpressureDropSubscriber<T>(s, onDrop));
+        this.source.subscribe(new BackpressureDropSubscriber<>(s, onDrop));
     }
 
     static final class BackpressureDropSubscriber<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.java
Patch:
@@ -31,7 +31,7 @@ public FlowableOnBackpressureError(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        this.source.subscribe(new BackpressureErrorSubscriber<T>(s));
+        this.source.subscribe(new BackpressureErrorSubscriber<>(s));
     }
 
     static final class BackpressureErrorSubscriber<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatest.java
Patch:
@@ -29,7 +29,7 @@ public FlowableOnBackpressureLatest(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new BackpressureLatestSubscriber<T>(s));
+        source.subscribe(new BackpressureLatestSubscriber<>(s));
     }
 
     static final class BackpressureLatestSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T>, Subscription {
@@ -47,7 +47,7 @@ static final class BackpressureLatestSubscriber<T> extends AtomicInteger impleme
 
         final AtomicLong requested = new AtomicLong();
 
-        final AtomicReference<T> current = new AtomicReference<T>();
+        final AtomicReference<T> current = new AtomicReference<>();
 
         BackpressureLatestSubscriber(Subscriber<? super T> downstream) {
             this.downstream = downstream;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnErrorNext.java
Patch:
@@ -34,7 +34,7 @@ public FlowableOnErrorNext(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        OnErrorNextSubscriber<T> parent = new OnErrorNextSubscriber<T>(s, nextSupplier);
+        OnErrorNextSubscriber<T> parent = new OnErrorNextSubscriber<>(s, nextSupplier);
         s.onSubscribe(parent);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -31,7 +31,7 @@ public FlowableOnErrorReturn(Flowable<T> source, Function<? super Throwable, ? e
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new OnErrorReturnSubscriber<T>(s, valueSupplier));
+        source.subscribe(new OnErrorReturnSubscriber<>(s, valueSupplier));
     }
 
     static final class OnErrorReturnSubscriber<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduce.java
Patch:
@@ -40,7 +40,7 @@ public FlowableReduce(Flowable<T> source, BiFunction<T, T, T> reducer) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ReduceSubscriber<T>(s, reducer));
+        source.subscribe(new ReduceSubscriber<>(s, reducer));
     }
 
     static final class ReduceSubscriber<T> extends DeferredScalarSubscription<T> implements FlowableSubscriber<T> {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduceMaybe.java
Patch:
@@ -50,12 +50,12 @@ public Publisher<T> source() {
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableReduce<T>(source, reducer));
+        return RxJavaPlugins.onAssembly(new FlowableReduce<>(source, reducer));
     }
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new ReduceSubscriber<T>(observer, reducer));
+        source.subscribe(new ReduceSubscriber<>(observer, reducer));
     }
 
     static final class ReduceSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduceSeedSingle.java
Patch:
@@ -47,7 +47,7 @@ public FlowableReduceSeedSingle(Publisher<T> source, R seed, BiFunction<R, ? sup
 
     @Override
     protected void subscribeActual(SingleObserver<? super R> observer) {
-        source.subscribe(new ReduceSeedObserver<T, R>(observer, reducer, seed));
+        source.subscribe(new ReduceSeedObserver<>(observer, reducer, seed));
     }
 
     static final class ReduceSeedObserver<T, R> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduceWithSingle.java
Patch:
@@ -55,6 +55,6 @@ protected void subscribeActual(SingleObserver<? super R> observer) {
             EmptyDisposable.error(ex, observer);
             return;
         }
-        source.subscribe(new ReduceSeedObserver<T, R>(observer, reducer, seed));
+        source.subscribe(new ReduceSeedObserver<>(observer, reducer, seed));
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -84,7 +84,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
             }
         }
 
-        source.subscribe(new RefCountSubscriber<T>(s, this, conn));
+        source.subscribe(new RefCountSubscriber<>(s, this, conn));
 
         if (connect) {
             source.connect(conn);
@@ -168,7 +168,7 @@ public void run() {
         }
 
         @Override
-        public void accept(Disposable t) throws Exception {
+        public void accept(Disposable t) {
             DisposableHelper.replace(this, t);
             synchronized (parent) {
                 if (disconnectedEarly) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRepeat.java
Patch:
@@ -32,7 +32,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
-        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRepeatUntil.java
Patch:
@@ -34,7 +34,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
-        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, until, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, until, sa, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryBiPredicate.java
Patch:
@@ -36,7 +36,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
-        RetryBiSubscriber<T> rs = new RetryBiSubscriber<T>(s, predicate, sa, source);
+        RetryBiSubscriber<T> rs = new RetryBiSubscriber<>(s, predicate, sa, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryPredicate.java
Patch:
@@ -38,7 +38,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
-        RetrySubscriber<T> rs = new RetrySubscriber<T>(s, count, predicate, sa, source);
+        RetrySubscriber<T> rs = new RetrySubscriber<>(s, count, predicate, sa, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryWhen.java
Patch:
@@ -36,7 +36,7 @@ public FlowableRetryWhen(Flowable<T> source,
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        SerializedSubscriber<T> z = new SerializedSubscriber<T>(s);
+        SerializedSubscriber<T> z = new SerializedSubscriber<>(s);
 
         FlowableProcessor<Throwable> processor = UnicastProcessor.<Throwable>create(8).toSerialized();
 
@@ -50,9 +50,9 @@ public void subscribeActual(Subscriber<? super T> s) {
             return;
         }
 
-        WhenReceiver<T, Throwable> receiver = new WhenReceiver<T, Throwable>(source);
+        WhenReceiver<T, Throwable> receiver = new WhenReceiver<>(source);
 
-        RetryWhenSubscriber<T> subscriber = new RetryWhenSubscriber<T>(z, processor, receiver);
+        RetryWhenSubscriber<T> subscriber = new RetryWhenSubscriber<>(z, processor, receiver);
 
         receiver.subscriber = subscriber;
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSampleTimed.java
Patch:
@@ -42,11 +42,11 @@ public FlowableSampleTimed(Flowable<T> source, long period, TimeUnit unit, Sched
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        SerializedSubscriber<T> serial = new SerializedSubscriber<T>(s);
+        SerializedSubscriber<T> serial = new SerializedSubscriber<>(s);
         if (emitLast) {
-            source.subscribe(new SampleTimedEmitLast<T>(serial, period, unit, scheduler));
+            source.subscribe(new SampleTimedEmitLast<>(serial, period, unit, scheduler));
         } else {
-            source.subscribe(new SampleTimedNoLast<T>(serial, period, unit, scheduler));
+            source.subscribe(new SampleTimedNoLast<>(serial, period, unit, scheduler));
         }
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableScalarXMap.java
Patch:
@@ -87,7 +87,7 @@ public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,
                     EmptySubscription.complete(subscriber);
                     return true;
                 }
-                subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));
+                subscriber.onSubscribe(new ScalarSubscription<>(subscriber, u));
             } else {
                 r.subscribe(subscriber);
             }
@@ -108,7 +108,7 @@ public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,
      * @return the new Flowable instance
      */
     public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {
-        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));
+        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<>(value, mapper));
     }
 
     /**
@@ -155,7 +155,7 @@ public void subscribeActual(Subscriber<? super R> s) {
                     EmptySubscription.complete(s);
                     return;
                 }
-                s.onSubscribe(new ScalarSubscription<R>(s, u));
+                s.onSubscribe(new ScalarSubscription<>(s, u));
             } else {
                 other.subscribe(s);
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableScan.java
Patch:
@@ -32,7 +32,7 @@ public FlowableScan(Flowable<T> source, BiFunction<T, T, T> accumulator) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ScanSubscriber<T>(s, accumulator));
+        source.subscribe(new ScanSubscriber<>(s, accumulator));
     }
 
     static final class ScanSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableScanSeed.java
Patch:
@@ -48,7 +48,7 @@ protected void subscribeActual(Subscriber<? super R> s) {
             return;
         }
 
-        source.subscribe(new ScanSeedSubscriber<T, R>(s, accumulator, r, bufferSize()));
+        source.subscribe(new ScanSeedSubscriber<>(s, accumulator, r, bufferSize()));
     }
 
     static final class ScanSeedSubscriber<T, R>
@@ -85,7 +85,7 @@ static final class ScanSeedSubscriber<T, R>
             this.value = value;
             this.prefetch = prefetch;
             this.limit = prefetch - (prefetch >> 2);
-            this.queue = new SpscArrayQueue<R>(prefetch);
+            this.queue = new SpscArrayQueue<>(prefetch);
             this.queue.offer(value);
             this.requested = new AtomicLong();
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSerialized.java
Patch:
@@ -24,6 +24,6 @@ public FlowableSerialized(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SerializedSubscriber<T>(s));
+        source.subscribe(new SerializedSubscriber<>(s));
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSingle.java
Patch:
@@ -35,7 +35,7 @@ public FlowableSingle(Flowable<T> source, T defaultValue, boolean failOnEmpty) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SingleElementSubscriber<T>(s, defaultValue, failOnEmpty));
+        source.subscribe(new SingleElementSubscriber<>(s, defaultValue, failOnEmpty));
     }
 
     static final class SingleElementSubscriber<T> extends DeferredScalarSubscription<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSingleMaybe.java
Patch:
@@ -31,12 +31,12 @@ public FlowableSingleMaybe(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new SingleElementSubscriber<T>(observer));
+        source.subscribe(new SingleElementSubscriber<>(observer));
     }
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, null, false));
+        return RxJavaPlugins.onAssembly(new FlowableSingle<>(source, null, false));
     }
 
     static final class SingleElementSubscriber<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSingleSingle.java
Patch:
@@ -36,12 +36,12 @@ public FlowableSingleSingle(Flowable<T> source, T defaultValue) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super T> observer) {
-        source.subscribe(new SingleElementSubscriber<T>(observer, defaultValue));
+        source.subscribe(new SingleElementSubscriber<>(observer, defaultValue));
     }
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, defaultValue, true));
+        return RxJavaPlugins.onAssembly(new FlowableSingle<>(source, defaultValue, true));
     }
 
     static final class SingleElementSubscriber<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkip.java
Patch:
@@ -27,7 +27,7 @@ public FlowableSkip(Flowable<T> source, long n) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SkipSubscriber<T>(s, n));
+        source.subscribe(new SkipSubscriber<>(s, n));
     }
 
     static final class SkipSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipLast.java
Patch:
@@ -30,7 +30,7 @@ public FlowableSkipLast(Flowable<T> source, int skip) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SkipLastSubscriber<T>(s, skip));
+        source.subscribe(new SkipLastSubscriber<>(s, skip));
     }
 
     static final class SkipLastSubscriber<T> extends ArrayDeque<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipLastTimed.java
Patch:
@@ -41,7 +41,7 @@ public FlowableSkipLastTimed(Flowable<T> source, long time, TimeUnit unit, Sched
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SkipLastTimedSubscriber<T>(s, time, unit, scheduler, bufferSize, delayError));
+        source.subscribe(new SkipLastTimedSubscriber<>(s, time, unit, scheduler, bufferSize, delayError));
     }
 
     static final class SkipLastTimedSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T>, Subscription {
@@ -68,7 +68,7 @@ static final class SkipLastTimedSubscriber<T> extends AtomicInteger implements F
             this.time = time;
             this.unit = unit;
             this.scheduler = scheduler;
-            this.queue = new SpscLinkedArrayQueue<Object>(bufferSize);
+            this.queue = new SpscLinkedArrayQueue<>(bufferSize);
             this.delayError = delayError;
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipUntil.java
Patch:
@@ -31,7 +31,7 @@ public FlowableSkipUntil(Flowable<T> source, Publisher<U> other) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> child) {
-        SkipUntilMainSubscriber<T> parent = new SkipUntilMainSubscriber<T>(child);
+        SkipUntilMainSubscriber<T> parent = new SkipUntilMainSubscriber<>(child);
         child.onSubscribe(parent);
 
         other.subscribe(parent.other);
@@ -57,7 +57,7 @@ static final class SkipUntilMainSubscriber<T> extends AtomicInteger
 
         SkipUntilMainSubscriber(Subscriber<? super T> downstream) {
             this.downstream = downstream;
-            this.upstream = new AtomicReference<Subscription>();
+            this.upstream = new AtomicReference<>();
             this.requested = new AtomicLong();
             this.other = new OtherSubscriber();
             this.error = new AtomicThrowable();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipWhile.java
Patch:
@@ -29,7 +29,7 @@ public FlowableSkipWhile(Flowable<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new SkipWhileSubscriber<T>(s, predicate));
+        source.subscribe(new SkipWhileSubscriber<>(s, predicate));
     }
 
     static final class SkipWhileSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSubscribeOn.java
Patch:
@@ -42,7 +42,7 @@ public FlowableSubscribeOn(Flowable<T> source, Scheduler scheduler, boolean nonS
     @Override
     public void subscribeActual(final Subscriber<? super T> s) {
         Scheduler.Worker w = scheduler.createWorker();
-        final SubscribeOnSubscriber<T> sos = new SubscribeOnSubscriber<T>(s, w, source, nonScheduledRequests);
+        final SubscribeOnSubscriber<T> sos = new SubscribeOnSubscriber<>(s, w, source, nonScheduledRequests);
         s.onSubscribe(sos);
 
         w.schedule(sos);
@@ -69,7 +69,7 @@ static final class SubscribeOnSubscriber<T> extends AtomicReference<Thread>
             this.downstream = actual;
             this.worker = worker;
             this.source = source;
-            this.upstream = new AtomicReference<Subscription>();
+            this.upstream = new AtomicReference<>();
             this.requested = new AtomicLong();
             this.nonScheduledRequests = !requestOn;
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchIfEmpty.java
Patch:
@@ -27,7 +27,7 @@ public FlowableSwitchIfEmpty(Flowable<T> source, Publisher<? extends T> other) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<T>(s, other);
+        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<>(s, other);
         s.onSubscribe(parent.arbiter);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLast.java
Patch:
@@ -32,7 +32,7 @@ public FlowableTakeLast(Flowable<T> source, int count) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new TakeLastSubscriber<T>(s, count));
+        source.subscribe(new TakeLastSubscriber<>(s, count));
     }
 
     static final class TakeLastSubscriber<T> extends ArrayDeque<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastOne.java
Patch:
@@ -25,7 +25,7 @@ public FlowableTakeLastOne(Flowable<T> source) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new TakeLastOneSubscriber<T>(s));
+        source.subscribe(new TakeLastOneSubscriber<>(s));
     }
 
     static final class TakeLastOneSubscriber<T> extends DeferredScalarSubscription<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimed.java
Patch:
@@ -45,7 +45,7 @@ public FlowableTakeLastTimed(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new TakeLastTimedSubscriber<T>(s, count, time, unit, scheduler, bufferSize, delayError));
+        source.subscribe(new TakeLastTimedSubscriber<>(s, count, time, unit, scheduler, bufferSize, delayError));
     }
 
     static final class TakeLastTimedSubscriber<T> extends AtomicInteger implements FlowableSubscriber<T>, Subscription {
@@ -74,7 +74,7 @@ static final class TakeLastTimedSubscriber<T> extends AtomicInteger implements F
             this.time = time;
             this.unit = unit;
             this.scheduler = scheduler;
-            this.queue = new SpscLinkedArrayQueue<Object>(bufferSize);
+            this.queue = new SpscLinkedArrayQueue<>(bufferSize);
             this.delayError = delayError;
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakePublisher.java
Patch:
@@ -35,6 +35,6 @@ public FlowableTakePublisher(Publisher<T> source, long limit) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new TakeSubscriber<T>(s, limit));
+        source.subscribe(new TakeSubscriber<>(s, limit));
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeUntil.java
Patch:
@@ -30,7 +30,7 @@ public FlowableTakeUntil(Flowable<T> source, Publisher<? extends U> other) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> child) {
-        TakeUntilMainSubscriber<T> parent = new TakeUntilMainSubscriber<T>(child);
+        TakeUntilMainSubscriber<T> parent = new TakeUntilMainSubscriber<>(child);
         child.onSubscribe(parent);
 
         other.subscribe(parent.other);
@@ -55,7 +55,7 @@ static final class TakeUntilMainSubscriber<T> extends AtomicInteger implements F
         TakeUntilMainSubscriber(Subscriber<? super T> downstream) {
             this.downstream = downstream;
             this.requested = new AtomicLong();
-            this.upstream = new AtomicReference<Subscription>();
+            this.upstream = new AtomicReference<>();
             this.other = new OtherSubscriber();
             this.error = new AtomicThrowable();
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeUntilPredicate.java
Patch:
@@ -30,7 +30,7 @@ public FlowableTakeUntilPredicate(Flowable<T> source, Predicate<? super T> predi
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new InnerSubscriber<T>(s, predicate));
+        source.subscribe(new InnerSubscriber<>(s, predicate));
     }
 
     static final class InnerSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeWhile.java
Patch:
@@ -30,7 +30,7 @@ public FlowableTakeWhile(Flowable<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new TakeWhileSubscriber<T>(s, predicate));
+        source.subscribe(new TakeWhileSubscriber<>(s, predicate));
     }
 
     static final class TakeWhileSubscriber<T> implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.java
Patch:
@@ -42,8 +42,8 @@ public FlowableThrottleFirstTimed(Flowable<T> source, long timeout, TimeUnit uni
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new DebounceTimedSubscriber<T>(
-                new SerializedSubscriber<T>(s),
+        source.subscribe(new DebounceTimedSubscriber<>(
+                new SerializedSubscriber<>(s),
                 timeout, unit, scheduler.createWorker()));
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleLatest.java
Patch:
@@ -56,7 +56,7 @@ public FlowableThrottleLatest(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new ThrottleLatestSubscriber<T>(s, timeout, unit, scheduler.createWorker(), emitLast));
+        source.subscribe(new ThrottleLatestSubscriber<>(s, timeout, unit, scheduler.createWorker(), emitLast));
     }
 
     static final class ThrottleLatestSubscriber<T>
@@ -100,7 +100,7 @@ static final class ThrottleLatestSubscriber<T>
             this.unit = unit;
             this.worker = worker;
             this.emitLast = emitLast;
-            this.latest = new AtomicReference<T>();
+            this.latest = new AtomicReference<>();
             this.requested = new AtomicLong();
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeInterval.java
Patch:
@@ -33,7 +33,7 @@ public FlowableTimeInterval(Flowable<T> source, TimeUnit unit, Scheduler schedul
 
     @Override
     protected void subscribeActual(Subscriber<? super Timed<T>> s) {
-        source.subscribe(new TimeIntervalSubscriber<T>(s, unit, scheduler));
+        source.subscribe(new TimeIntervalSubscriber<>(s, unit, scheduler));
     }
 
     static final class TimeIntervalSubscriber<T> implements FlowableSubscriber<T>, Subscription {
@@ -66,7 +66,7 @@ public void onNext(T t) {
             long last = lastTime;
             lastTime = now;
             long delta = now - last;
-            downstream.onNext(new Timed<T>(t, delta, unit));
+            downstream.onNext(new Timed<>(t, delta, unit));
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java
Patch:
@@ -41,7 +41,7 @@ protected void subscribeActual(Subscriber<? super U> s) {
             EmptySubscription.error(e, s);
             return;
         }
-        source.subscribe(new ToListSubscriber<T, U>(s, coll));
+        source.subscribe(new ToListSubscriber<>(s, coll));
     }
 
     static final class ToListSubscriber<T, U extends Collection<? super T>>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToListSingle.java
Patch:
@@ -53,12 +53,12 @@ protected void subscribeActual(SingleObserver<? super U> observer) {
             EmptyDisposable.error(e, observer);
             return;
         }
-        source.subscribe(new ToListSubscriber<T, U>(observer, coll));
+        source.subscribe(new ToListSubscriber<>(observer, coll));
     }
 
     @Override
     public Flowable<U> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableToList<T, U>(source, collectionSupplier));
+        return RxJavaPlugins.onAssembly(new FlowableToList<>(source, collectionSupplier));
     }
 
     static final class ToListSubscriber<T, U extends Collection<? super T>>

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableUnsubscribeOn.java
Patch:
@@ -30,7 +30,7 @@ public FlowableUnsubscribeOn(Flowable<T> source, Scheduler scheduler) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new UnsubscribeSubscriber<T>(s, scheduler));
+        source.subscribe(new UnsubscribeSubscriber<>(s, scheduler));
     }
 
     static final class UnsubscribeSubscriber<T> extends AtomicBoolean implements FlowableSubscriber<T>, Subscription {

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableUsing.java
Patch:
@@ -68,7 +68,7 @@ public void subscribeActual(Subscriber<? super T> s) {
             return;
         }
 
-        UsingSubscriber<T, D> us = new UsingSubscriber<T, D>(s, resource, disposer, eager);
+        UsingSubscriber<T, D> us = new UsingSubscriber<>(s, resource, disposer, eager);
 
         source.subscribe(us);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableZip.java
Patch:
@@ -71,7 +71,7 @@ public void subscribeActual(Subscriber<? super R> s) {
             return;
         }
 
-        ZipCoordinator<T, R> coordinator = new ZipCoordinator<T, R>(s, zipper, count, bufferSize, delayError);
+        ZipCoordinator<T, R> coordinator = new ZipCoordinator<>(s, zipper, count, bufferSize, delayError);
 
         s.onSubscribe(coordinator);
 
@@ -108,7 +108,7 @@ static final class ZipCoordinator<T, R>
             @SuppressWarnings("unchecked")
             ZipSubscriber<T, R>[] a = new ZipSubscriber[n];
             for (int i = 0; i < n; i++) {
-                a[i] = new ZipSubscriber<T, R>(this, prefetch);
+                a[i] = new ZipSubscriber<>(this, prefetch);
             }
             this.current = new Object[n];
             this.subscribers = a;
@@ -354,7 +354,7 @@ public void onSubscribe(Subscription s) {
                     }
                 }
 
-                queue = new SpscArrayQueue<T>(prefetch);
+                queue = new SpscArrayQueue<>(prefetch);
 
                 s.request(prefetch);
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCache.java
Patch:
@@ -41,13 +41,13 @@ public final class MaybeCache<T> extends Maybe<T> implements MaybeObserver<T> {
 
     @SuppressWarnings("unchecked")
     public MaybeCache(MaybeSource<T> source) {
-        this.source = new AtomicReference<MaybeSource<T>>(source);
-        this.observers = new AtomicReference<CacheDisposable<T>[]>(EMPTY);
+        this.source = new AtomicReference<>(source);
+        this.observers = new AtomicReference<>(EMPTY);
     }
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        CacheDisposable<T> parent = new CacheDisposable<T>(observer, this);
+        CacheDisposable<T> parent = new CacheDisposable<>(observer, this);
         observer.onSubscribe(parent);
 
         if (add(parent)) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatArray.java
Patch:
@@ -38,7 +38,7 @@ public MaybeConcatArray(MaybeSource<? extends T>[] sources) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        ConcatMaybeObserver<T> parent = new ConcatMaybeObserver<T>(s, sources);
+        ConcatMaybeObserver<T> parent = new ConcatMaybeObserver<>(s, sources);
         s.onSubscribe(parent);
         parent.drain();
     }
@@ -68,7 +68,7 @@ static final class ConcatMaybeObserver<T>
             this.sources = sources;
             this.requested = new AtomicLong();
             this.disposables = new SequentialDisposable();
-            this.current = new AtomicReference<Object>(NotificationLite.COMPLETE); // as if a previous completed
+            this.current = new AtomicReference<>(NotificationLite.COMPLETE); // as if a previous completed
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatArrayDelayError.java
Patch:
@@ -39,7 +39,7 @@ public MaybeConcatArrayDelayError(MaybeSource<? extends T>[] sources) {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        ConcatMaybeObserver<T> parent = new ConcatMaybeObserver<T>(s, sources);
+        ConcatMaybeObserver<T> parent = new ConcatMaybeObserver<>(s, sources);
         s.onSubscribe(parent);
         parent.drain();
     }
@@ -71,7 +71,7 @@ static final class ConcatMaybeObserver<T>
             this.sources = sources;
             this.requested = new AtomicLong();
             this.disposables = new SequentialDisposable();
-            this.current = new AtomicReference<Object>(NotificationLite.COMPLETE); // as if a previous completed
+            this.current = new AtomicReference<>(NotificationLite.COMPLETE); // as if a previous completed
             this.errors = new AtomicThrowable();
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatIterable.java
Patch:
@@ -52,7 +52,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
             return;
         }
 
-        ConcatMaybeObserver<T> parent = new ConcatMaybeObserver<T>(s, it);
+        ConcatMaybeObserver<T> parent = new ConcatMaybeObserver<>(s, it);
         s.onSubscribe(parent);
         parent.drain();
     }
@@ -80,7 +80,7 @@ static final class ConcatMaybeObserver<T>
             this.sources = sources;
             this.requested = new AtomicLong();
             this.disposables = new SequentialDisposable();
-            this.current = new AtomicReference<Object>(NotificationLite.COMPLETE); // as if a previous completed
+            this.current = new AtomicReference<>(NotificationLite.COMPLETE); // as if a previous completed
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCreate.java
Patch:
@@ -39,7 +39,7 @@ public MaybeCreate(MaybeOnSubscribe<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        Emitter<T> parent = new Emitter<T>(observer);
+        Emitter<T> parent = new Emitter<>(observer);
         observer.onSubscribe(parent);
 
         try {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelay.java
Patch:
@@ -42,7 +42,7 @@ public MaybeDelay(MaybeSource<T> source, long delay, TimeUnit unit, Scheduler sc
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new DelayMaybeObserver<T>(observer, delay, unit, scheduler));
+        source.subscribe(new DelayMaybeObserver<>(observer, delay, unit, scheduler));
     }
 
     static final class DelayMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelayOtherPublisher.java
Patch:
@@ -40,7 +40,7 @@ public MaybeDelayOtherPublisher(MaybeSource<T> source, Publisher<U> other) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new DelayMaybeObserver<T, U>(observer, other));
+        source.subscribe(new DelayMaybeObserver<>(observer, other));
     }
 
     static final class DelayMaybeObserver<T, U>
@@ -52,7 +52,7 @@ static final class DelayMaybeObserver<T, U>
         Disposable upstream;
 
         DelayMaybeObserver(MaybeObserver<? super T> actual, Publisher<U> otherSource) {
-            this.other = new OtherSubscriber<T>(actual);
+            this.other = new OtherSubscriber<>(actual);
             this.otherSource = otherSource;
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelaySubscriptionOtherPublisher.java
Patch:
@@ -40,7 +40,7 @@ public MaybeDelaySubscriptionOtherPublisher(MaybeSource<T> source, Publisher<U>
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        other.subscribe(new OtherSubscriber<T>(observer, source));
+        other.subscribe(new OtherSubscriber<>(observer, source));
     }
 
     static final class OtherSubscriber<T> implements FlowableSubscriber<Object>, Disposable {
@@ -51,7 +51,7 @@ static final class OtherSubscriber<T> implements FlowableSubscriber<Object>, Dis
         Subscription upstream;
 
         OtherSubscriber(MaybeObserver<? super T> actual, MaybeSource<T> source) {
-            this.main = new DelayMaybeObserver<T>(actual);
+            this.main = new DelayMaybeObserver<>(actual);
             this.source = source;
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelayWithCompletable.java
Patch:
@@ -32,7 +32,7 @@ public MaybeDelayWithCompletable(MaybeSource<T> source, CompletableSource other)
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        other.subscribe(new OtherObserver<T>(observer, source));
+        other.subscribe(new OtherObserver<>(observer, source));
     }
 
     static final class OtherObserver<T>
@@ -64,7 +64,7 @@ public void onError(Throwable e) {
 
         @Override
         public void onComplete() {
-            source.subscribe(new DelayWithMainObserver<T>(this, downstream));
+            source.subscribe(new DelayWithMainObserver<>(this, downstream));
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDetach.java
Patch:
@@ -30,7 +30,7 @@ public MaybeDetach(MaybeSource<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new DetachMaybeObserver<T>(observer));
+        source.subscribe(new DetachMaybeObserver<>(observer));
     }
 
     static final class DetachMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoAfterSuccess.java
Patch:
@@ -37,7 +37,7 @@ public MaybeDoAfterSuccess(MaybeSource<T> source, Consumer<? super T> onAfterSuc
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new DoAfterObserver<T>(observer, onAfterSuccess));
+        source.subscribe(new DoAfterObserver<>(observer, onAfterSuccess));
     }
 
     static final class DoAfterObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoFinally.java
Patch:
@@ -39,7 +39,7 @@ public MaybeDoFinally(MaybeSource<T> source, Action onFinally) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new DoFinallyObserver<T>(observer, onFinally));
+        source.subscribe(new DoFinallyObserver<>(observer, onFinally));
     }
 
     static final class DoFinallyObserver<T> extends AtomicInteger implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoOnEvent.java
Patch:
@@ -36,7 +36,7 @@ public MaybeDoOnEvent(MaybeSource<T> source, BiConsumer<? super T, ? super Throw
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new DoOnEventMaybeObserver<T>(observer, onEvent));
+        source.subscribe(new DoOnEventMaybeObserver<>(observer, onEvent));
     }
 
     static final class DoOnEventMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeEqualSingle.java
Patch:
@@ -44,7 +44,7 @@ public MaybeEqualSingle(MaybeSource<? extends T> source1, MaybeSource<? extends
 
     @Override
     protected void subscribeActual(SingleObserver<? super Boolean> observer) {
-        EqualCoordinator<T> parent = new EqualCoordinator<T>(observer, isEqual);
+        EqualCoordinator<T> parent = new EqualCoordinator<>(observer, isEqual);
         observer.onSubscribe(parent);
         parent.subscribe(source1, source2);
     }
@@ -65,8 +65,8 @@ static final class EqualCoordinator<T>
             super(2);
             this.downstream = actual;
             this.isEqual = isEqual;
-            this.observer1 = new EqualObserver<T>(this);
-            this.observer2 = new EqualObserver<T>(this);
+            this.observer1 = new EqualObserver<>(this);
+            this.observer2 = new EqualObserver<>(this);
         }
 
         void subscribe(MaybeSource<? extends T> source1, MaybeSource<? extends T> source2) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFilter.java
Patch:
@@ -36,7 +36,7 @@ public MaybeFilter(MaybeSource<T> source, Predicate<? super T> predicate) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new FilterMaybeObserver<T>(observer, predicate));
+        source.subscribe(new FilterMaybeObserver<>(observer, predicate));
     }
 
     static final class FilterMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFilterSingle.java
Patch:
@@ -37,7 +37,7 @@ public MaybeFilterSingle(SingleSource<T> source, Predicate<? super T> predicate)
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new FilterMaybeObserver<T>(observer, predicate));
+        source.subscribe(new FilterMaybeObserver<>(observer, predicate));
     }
 
     static final class FilterMaybeObserver<T> implements SingleObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapBiSelector.java
Patch:
@@ -59,7 +59,7 @@ static final class FlatMapBiMainObserver<T, U, R>
         FlatMapBiMainObserver(MaybeObserver<? super R> actual,
                 Function<? super T, ? extends MaybeSource<? extends U>> mapper,
                 BiFunction<? super T, ? super U, ? extends R> resultSelector) {
-            this.inner = new InnerObserver<T, U, R>(actual, resultSelector);
+            this.inner = new InnerObserver<>(actual, resultSelector);
             this.mapper = mapper;
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapCompletable.java
Patch:
@@ -39,7 +39,7 @@ public MaybeFlatMapCompletable(MaybeSource<T> source, Function<? super T, ? exte
 
     @Override
     protected void subscribeActual(CompletableObserver observer) {
-        FlatMapCompletableObserver<T> parent = new FlatMapCompletableObserver<T>(observer, mapper);
+        FlatMapCompletableObserver<T> parent = new FlatMapCompletableObserver<>(observer, mapper);
         observer.onSubscribe(parent);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapIterableFlowable.java
Patch:
@@ -48,7 +48,7 @@ public MaybeFlatMapIterableFlowable(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new FlatMapIterableObserver<T, R>(s, mapper));
+        source.subscribe(new FlatMapIterableObserver<>(s, mapper));
     }
 
     static final class FlatMapIterableObserver<T, R>
@@ -279,7 +279,7 @@ public boolean isEmpty() {
 
         @Nullable
         @Override
-        public R poll() throws Exception {
+        public R poll() {
             Iterator<? extends R> iterator = it;
 
             if (iterator != null) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapIterableObservable.java
Patch:
@@ -44,7 +44,7 @@ public MaybeFlatMapIterableObservable(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(Observer<? super R> observer) {
-        source.subscribe(new FlatMapIterableObserver<T, R>(observer, mapper));
+        source.subscribe(new FlatMapIterableObserver<>(observer, mapper));
     }
 
     static final class FlatMapIterableObserver<T, R>
@@ -189,7 +189,7 @@ public boolean isEmpty() {
 
         @Nullable
         @Override
-        public R poll() throws Exception {
+        public R poll() {
             Iterator<? extends R> iterator = it;
 
             if (iterator != null) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapNotification.java
Patch:
@@ -48,7 +48,7 @@ public MaybeFlatMapNotification(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(MaybeObserver<? super R> observer) {
-        source.subscribe(new FlatMapMaybeObserver<T, R>(observer, onSuccessMapper, onErrorMapper, onCompleteSupplier));
+        source.subscribe(new FlatMapMaybeObserver<>(observer, onSuccessMapper, onErrorMapper, onCompleteSupplier));
     }
 
     static final class FlatMapMaybeObserver<T, R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapSingle.java
Patch:
@@ -41,7 +41,7 @@ public MaybeFlatMapSingle(MaybeSource<T> source, Function<? super T, ? extends S
 
     @Override
     protected void subscribeActual(SingleObserver<? super R> downstream) {
-        source.subscribe(new FlatMapMaybeObserver<T, R>(downstream, mapper));
+        source.subscribe(new FlatMapMaybeObserver<>(downstream, mapper));
     }
 
     static final class FlatMapMaybeObserver<T, R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapSingleElement.java
Patch:
@@ -42,7 +42,7 @@ public MaybeFlatMapSingleElement(MaybeSource<T> source, Function<? super T, ? ex
 
     @Override
     protected void subscribeActual(MaybeObserver<? super R> downstream) {
-        source.subscribe(new FlatMapMaybeObserver<T, R>(downstream, mapper));
+        source.subscribe(new FlatMapMaybeObserver<>(downstream, mapper));
     }
 
     static final class FlatMapMaybeObserver<T, R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatten.java
Patch:
@@ -39,7 +39,7 @@ public MaybeFlatten(MaybeSource<T> source, Function<? super T, ? extends MaybeSo
 
     @Override
     protected void subscribeActual(MaybeObserver<? super R> observer) {
-        source.subscribe(new FlatMapMaybeObserver<T, R>(observer, mapper));
+        source.subscribe(new FlatMapMaybeObserver<>(observer, mapper));
     }
 
     static final class FlatMapMaybeObserver<T, R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromRunnable.java
Patch:
@@ -58,7 +58,7 @@ protected void subscribeActual(MaybeObserver<? super T> observer) {
     }
 
     @Override
-    public T get() throws Throwable {
+    public T get() {
         runnable.run();
         return null;
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromSingle.java
Patch:
@@ -38,7 +38,7 @@ public SingleSource<T> source() {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new FromSingleObserver<T>(observer));
+        source.subscribe(new FromSingleObserver<>(observer));
     }
 
     static final class FromSingleObserver<T> implements SingleObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeHide.java
Patch:
@@ -30,7 +30,7 @@ public MaybeHide(MaybeSource<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new HideMaybeObserver<T>(observer));
+        source.subscribe(new HideMaybeObserver<>(observer));
     }
 
     static final class HideMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeIgnoreElement.java
Patch:
@@ -30,7 +30,7 @@ public MaybeIgnoreElement(MaybeSource<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new IgnoreMaybeObserver<T>(observer));
+        source.subscribe(new IgnoreMaybeObserver<>(observer));
     }
 
     static final class IgnoreMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeIgnoreElementCompletable.java
Patch:
@@ -34,12 +34,12 @@ public MaybeIgnoreElementCompletable(MaybeSource<T> source) {
 
     @Override
     protected void subscribeActual(CompletableObserver observer) {
-        source.subscribe(new IgnoreMaybeObserver<T>(observer));
+        source.subscribe(new IgnoreMaybeObserver<>(observer));
     }
 
     @Override
     public Maybe<T> fuseToMaybe() {
-        return RxJavaPlugins.onAssembly(new MaybeIgnoreElement<T>(source));
+        return RxJavaPlugins.onAssembly(new MaybeIgnoreElement<>(source));
     }
 
     static final class IgnoreMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeIsEmpty.java
Patch:
@@ -31,7 +31,7 @@ public MaybeIsEmpty(MaybeSource<T> source) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super Boolean> observer) {
-        source.subscribe(new IsEmptyMaybeObserver<T>(observer));
+        source.subscribe(new IsEmptyMaybeObserver<>(observer));
     }
 
     static final class IsEmptyMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeIsEmptySingle.java
Patch:
@@ -41,12 +41,12 @@ public MaybeSource<T> source() {
 
     @Override
     public Maybe<Boolean> fuseToMaybe() {
-        return RxJavaPlugins.onAssembly(new MaybeIsEmpty<T>(source));
+        return RxJavaPlugins.onAssembly(new MaybeIsEmpty<>(source));
     }
 
     @Override
     protected void subscribeActual(SingleObserver<? super Boolean> observer) {
-        source.subscribe(new IsEmptyMaybeObserver<T>(observer));
+        source.subscribe(new IsEmptyMaybeObserver<>(observer));
     }
 
     static final class IsEmptyMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeMaterialize.java
Patch:
@@ -34,6 +34,6 @@ public MaybeMaterialize(Maybe<T> source) {
 
     @Override
     protected void subscribeActual(SingleObserver<? super Notification<T>> observer) {
-        source.subscribe(new MaterializeSingleObserver<T>(observer));
+        source.subscribe(new MaterializeSingleObserver<>(observer));
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeObserveOn.java
Patch:
@@ -35,7 +35,7 @@ public MaybeObserveOn(MaybeSource<T> source, Scheduler scheduler) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new ObserveOnMaybeObserver<T>(observer, scheduler));
+        source.subscribe(new ObserveOnMaybeObserver<>(observer, scheduler));
     }
 
     static final class ObserveOnMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorComplete.java
Patch:
@@ -37,7 +37,7 @@ public MaybeOnErrorComplete(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new OnErrorCompleteMaybeObserver<T>(observer, predicate));
+        source.subscribe(new OnErrorCompleteMaybeObserver<>(observer, predicate));
     }
 
     static final class OnErrorCompleteMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorNext.java
Patch:
@@ -43,7 +43,7 @@ public MaybeOnErrorNext(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new OnErrorNextMaybeObserver<T>(observer, resumeFunction, allowFatal));
+        source.subscribe(new OnErrorNextMaybeObserver<>(observer, resumeFunction, allowFatal));
     }
 
     static final class OnErrorNextMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorReturn.java
Patch:
@@ -37,7 +37,7 @@ public MaybeOnErrorReturn(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new OnErrorReturnMaybeObserver<T>(observer, valueSupplier));
+        source.subscribe(new OnErrorReturnMaybeObserver<>(observer, valueSupplier));
     }
 
     static final class OnErrorReturnMaybeObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybePeek.java
Patch:
@@ -53,7 +53,7 @@ public MaybePeek(MaybeSource<T> source, Consumer<? super Disposable> onSubscribe
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new MaybePeekObserver<T>(observer, this));
+        source.subscribe(new MaybePeekObserver<>(observer, this));
     }
 
     static final class MaybePeekObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeSubscribeOn.java
Patch:
@@ -34,10 +34,10 @@ public MaybeSubscribeOn(MaybeSource<T> source, Scheduler scheduler) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        SubscribeOnMaybeObserver<T> parent = new SubscribeOnMaybeObserver<T>(observer);
+        SubscribeOnMaybeObserver<T> parent = new SubscribeOnMaybeObserver<>(observer);
         observer.onSubscribe(parent);
 
-        parent.task.replace(scheduler.scheduleDirect(new SubscribeTask<T>(parent, source)));
+        parent.task.replace(scheduler.scheduleDirect(new SubscribeTask<>(parent, source)));
     }
 
     static final class SubscribeTask<T> implements Runnable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeSwitchIfEmpty.java
Patch:
@@ -35,7 +35,7 @@ public MaybeSwitchIfEmpty(MaybeSource<T> source, MaybeSource<? extends T> other)
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new SwitchIfEmptyMaybeObserver<T>(observer, other));
+        source.subscribe(new SwitchIfEmptyMaybeObserver<>(observer, other));
     }
 
     static final class SwitchIfEmptyMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeSwitchIfEmptySingle.java
Patch:
@@ -42,7 +42,7 @@ public MaybeSource<T> source() {
 
     @Override
     protected void subscribeActual(SingleObserver<? super T> observer) {
-        source.subscribe(new SwitchIfEmptyMaybeObserver<T>(observer, other));
+        source.subscribe(new SwitchIfEmptyMaybeObserver<>(observer, other));
     }
 
     static final class SwitchIfEmptyMaybeObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTakeUntilMaybe.java
Patch:
@@ -38,7 +38,7 @@ public MaybeTakeUntilMaybe(MaybeSource<T> source, MaybeSource<U> other) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        TakeUntilMainMaybeObserver<T, U> parent = new TakeUntilMainMaybeObserver<T, U>(observer);
+        TakeUntilMainMaybeObserver<T, U> parent = new TakeUntilMainMaybeObserver<>(observer);
         observer.onSubscribe(parent);
 
         other.subscribe(parent.other);
@@ -57,7 +57,7 @@ static final class TakeUntilMainMaybeObserver<T, U>
 
         TakeUntilMainMaybeObserver(MaybeObserver<? super T> downstream) {
             this.downstream = downstream;
-            this.other = new TakeUntilOtherMaybeObserver<U>(this);
+            this.other = new TakeUntilOtherMaybeObserver<>(this);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTakeUntilPublisher.java
Patch:
@@ -41,7 +41,7 @@ public MaybeTakeUntilPublisher(MaybeSource<T> source, Publisher<U> other) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        TakeUntilMainMaybeObserver<T, U> parent = new TakeUntilMainMaybeObserver<T, U>(observer);
+        TakeUntilMainMaybeObserver<T, U> parent = new TakeUntilMainMaybeObserver<>(observer);
         observer.onSubscribe(parent);
 
         other.subscribe(parent.other);
@@ -60,7 +60,7 @@ static final class TakeUntilMainMaybeObserver<T, U>
 
         TakeUntilMainMaybeObserver(MaybeObserver<? super T> downstream) {
             this.downstream = downstream;
-            this.other = new TakeUntilOtherMaybeObserver<U>(this);
+            this.other = new TakeUntilOtherMaybeObserver<>(this);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTimeoutMaybe.java
Patch:
@@ -42,7 +42,7 @@ public MaybeTimeoutMaybe(MaybeSource<T> source, MaybeSource<U> other, MaybeSourc
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        TimeoutMainMaybeObserver<T, U> parent = new TimeoutMainMaybeObserver<T, U>(observer, fallback);
+        TimeoutMainMaybeObserver<T, U> parent = new TimeoutMainMaybeObserver<>(observer, fallback);
         observer.onSubscribe(parent);
 
         other.subscribe(parent.other);
@@ -66,9 +66,9 @@ static final class TimeoutMainMaybeObserver<T, U>
 
         TimeoutMainMaybeObserver(MaybeObserver<? super T> actual, MaybeSource<? extends T> fallback) {
             this.downstream = actual;
-            this.other = new TimeoutOtherMaybeObserver<T, U>(this);
+            this.other = new TimeoutOtherMaybeObserver<>(this);
             this.fallback = fallback;
-            this.otherObserver = fallback != null ? new TimeoutFallbackMaybeObserver<T>(actual) : null;
+            this.otherObserver = fallback != null ? new TimeoutFallbackMaybeObserver<>(actual) : null;
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTimeoutPublisher.java
Patch:
@@ -45,7 +45,7 @@ public MaybeTimeoutPublisher(MaybeSource<T> source, Publisher<U> other, MaybeSou
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        TimeoutMainMaybeObserver<T, U> parent = new TimeoutMainMaybeObserver<T, U>(observer, fallback);
+        TimeoutMainMaybeObserver<T, U> parent = new TimeoutMainMaybeObserver<>(observer, fallback);
         observer.onSubscribe(parent);
 
         other.subscribe(parent.other);
@@ -69,9 +69,9 @@ static final class TimeoutMainMaybeObserver<T, U>
 
         TimeoutMainMaybeObserver(MaybeObserver<? super T> actual, MaybeSource<? extends T> fallback) {
             this.downstream = actual;
-            this.other = new TimeoutOtherMaybeObserver<T, U>(this);
+            this.other = new TimeoutOtherMaybeObserver<>(this);
             this.fallback = fallback;
-            this.otherObserver = fallback != null ? new TimeoutFallbackMaybeObserver<T>(actual) : null;
+            this.otherObserver = fallback != null ? new TimeoutFallbackMaybeObserver<>(actual) : null;
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToFlowable.java
Patch:
@@ -42,7 +42,7 @@ public MaybeSource<T> source() {
 
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
-        source.subscribe(new MaybeToFlowableSubscriber<T>(s));
+        source.subscribe(new MaybeToFlowableSubscriber<>(s));
     }
 
     static final class MaybeToFlowableSubscriber<T> extends DeferredScalarSubscription<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToObservable.java
Patch:
@@ -52,7 +52,7 @@ protected void subscribeActual(Observer<? super T> observer) {
      * @since 2.2
      */
     public static <T> MaybeObserver<T> create(Observer<? super T> downstream) {
-        return new MaybeToObservableObserver<T>(downstream);
+        return new MaybeToObservableObserver<>(downstream);
     }
 
     static final class MaybeToObservableObserver<T> extends DeferredScalarDisposable<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToPublisher.java
Patch:
@@ -30,7 +30,7 @@ public static <T> Function<MaybeSource<T>, Publisher<T>> instance() {
     }
 
     @Override
-    public Publisher<Object> apply(MaybeSource<Object> t) throws Exception {
-        return new MaybeToFlowable<Object>(t);
+    public Publisher<Object> apply(MaybeSource<Object> t) {
+        return new MaybeToFlowable<>(t);
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToSingle.java
Patch:
@@ -43,7 +43,7 @@ public MaybeSource<T> source() {
 
     @Override
     protected void subscribeActual(SingleObserver<? super T> observer) {
-        source.subscribe(new ToSingleMaybeSubscriber<T>(observer, defaultValue));
+        source.subscribe(new ToSingleMaybeSubscriber<>(observer, defaultValue));
     }
 
     static final class ToSingleMaybeSubscriber<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeUnsubscribeOn.java
Patch:
@@ -35,7 +35,7 @@ public MaybeUnsubscribeOn(MaybeSource<T> source, Scheduler scheduler) {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        source.subscribe(new UnsubscribeOnMaybeObserver<T>(observer, scheduler));
+        source.subscribe(new UnsubscribeOnMaybeObserver<>(observer, scheduler));
     }
 
     static final class UnsubscribeOnMaybeObserver<T> extends AtomicReference<Disposable>

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeZipArray.java
Patch:
@@ -40,11 +40,11 @@ protected void subscribeActual(MaybeObserver<? super R> observer) {
         int n = sources.length;
 
         if (n == 1) {
-            sources[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new SingletonArrayFunc()));
+            sources[0].subscribe(new MaybeMap.MapMaybeObserver<>(observer, new SingletonArrayFunc()));
             return;
         }
 
-        ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper);
+        ZipCoordinator<T, R> parent = new ZipCoordinator<>(observer, n, zipper);
 
         observer.onSubscribe(parent);
 
@@ -82,7 +82,7 @@ static final class ZipCoordinator<T, R> extends AtomicInteger implements Disposa
             this.zipper = zipper;
             ZipMaybeObserver<T>[] o = new ZipMaybeObserver[n];
             for (int i = 0; i < n; i++) {
-                o[i] = new ZipMaybeObserver<T>(this, i);
+                o[i] = new ZipMaybeObserver<>(this, i);
             }
             this.observers = o;
             this.values = new Object[n];

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeZipIterable.java
Patch:
@@ -62,11 +62,11 @@ protected void subscribeActual(MaybeObserver<? super R> observer) {
         }
 
         if (n == 1) {
-            a[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new SingletonArrayFunc()));
+            a[0].subscribe(new MaybeMap.MapMaybeObserver<>(observer, new SingletonArrayFunc()));
             return;
         }
 
-        ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper);
+        ZipCoordinator<T, R> parent = new ZipCoordinator<>(observer, n, zipper);
 
         observer.onSubscribe(parent);
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/CompletableAndThenObservable.java
Patch:
@@ -40,7 +40,7 @@ public CompletableAndThenObservable(CompletableSource source,
 
     @Override
     protected void subscribeActual(Observer<? super R> observer) {
-        AndThenObservableObserver<R> parent = new AndThenObservableObserver<R>(observer, other);
+        AndThenObservableObserver<R> parent = new AndThenObservableObserver<>(observer, other);
         observer.onSubscribe(parent);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapCompletable.java
Patch:
@@ -57,7 +57,7 @@ public FlowableConcatMapCompletable(Flowable<T> source,
 
     @Override
     protected void subscribeActual(CompletableObserver observer) {
-        source.subscribe(new ConcatMapCompletableObserver<T>(observer, mapper, errorMode, prefetch));
+        source.subscribe(new ConcatMapCompletableObserver<>(observer, mapper, errorMode, prefetch));
     }
 
     static final class ConcatMapCompletableObserver<T>
@@ -99,7 +99,7 @@ static final class ConcatMapCompletableObserver<T>
             this.prefetch = prefetch;
             this.errors = new AtomicThrowable();
             this.inner = new ConcatMapInnerObserver(this);
-            this.queue = new SpscArrayQueue<T>(prefetch);
+            this.queue = new SpscArrayQueue<>(prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapMaybe.java
Patch:
@@ -58,7 +58,7 @@ public FlowableConcatMapMaybe(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new ConcatMapMaybeSubscriber<T, R>(s, mapper, prefetch, errorMode));
+        source.subscribe(new ConcatMapMaybeSubscriber<>(s, mapper, prefetch, errorMode));
     }
 
     static final class ConcatMapMaybeSubscriber<T, R>
@@ -113,8 +113,8 @@ static final class ConcatMapMaybeSubscriber<T, R>
             this.errorMode = errorMode;
             this.requested = new AtomicLong();
             this.errors = new AtomicThrowable();
-            this.inner = new ConcatMapMaybeObserver<R>(this);
-            this.queue = new SpscArrayQueue<T>(prefetch);
+            this.inner = new ConcatMapMaybeObserver<>(this);
+            this.queue = new SpscArrayQueue<>(prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapSingle.java
Patch:
@@ -58,7 +58,7 @@ public FlowableConcatMapSingle(Flowable<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new ConcatMapSingleSubscriber<T, R>(s, mapper, prefetch, errorMode));
+        source.subscribe(new ConcatMapSingleSubscriber<>(s, mapper, prefetch, errorMode));
     }
 
     static final class ConcatMapSingleSubscriber<T, R>
@@ -113,8 +113,8 @@ static final class ConcatMapSingleSubscriber<T, R>
             this.errorMode = errorMode;
             this.requested = new AtomicLong();
             this.errors = new AtomicThrowable();
-            this.inner = new ConcatMapSingleObserver<R>(this);
-            this.queue = new SpscArrayQueue<T>(prefetch);
+            this.inner = new ConcatMapSingleObserver<>(this);
+            this.queue = new SpscArrayQueue<>(prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapCompletable.java
Patch:
@@ -52,7 +52,7 @@ public FlowableSwitchMapCompletable(Flowable<T> source,
 
     @Override
     protected void subscribeActual(CompletableObserver observer) {
-        source.subscribe(new SwitchMapCompletableObserver<T>(observer, mapper, delayErrors));
+        source.subscribe(new SwitchMapCompletableObserver<>(observer, mapper, delayErrors));
     }
 
     static final class SwitchMapCompletableObserver<T> implements FlowableSubscriber<T>, Disposable {
@@ -79,7 +79,7 @@ static final class SwitchMapCompletableObserver<T> implements FlowableSubscriber
             this.mapper = mapper;
             this.delayErrors = delayErrors;
             this.errors = new AtomicThrowable();
-            this.inner = new AtomicReference<SwitchMapInnerObserver>();
+            this.inner = new AtomicReference<>();
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/MaterializeSingleObserver.java
Patch:
@@ -45,17 +45,17 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onComplete() {
-        downstream.onSuccess(Notification.<T>createOnComplete());
+        downstream.onSuccess(Notification.createOnComplete());
     }
 
     @Override
     public void onSuccess(T t) {
-        downstream.onSuccess(Notification.<T>createOnNext(t));
+        downstream.onSuccess(Notification.createOnNext(t));
     }
 
     @Override
     public void onError(Throwable e) {
-        downstream.onSuccess(Notification.<T>createOnError(e));
+        downstream.onSuccess(Notification.createOnError(e));
     }
 
     @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/MaybeFlatMapObservable.java
Patch:
@@ -44,7 +44,7 @@ public MaybeFlatMapObservable(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(Observer<? super R> observer) {
-        FlatMapObserver<T, R> parent = new FlatMapObserver<T, R>(observer, mapper);
+        FlatMapObserver<T, R> parent = new FlatMapObserver<>(observer, mapper);
         observer.onSubscribe(parent);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/MaybeFlatMapPublisher.java
Patch:
@@ -47,7 +47,7 @@ public MaybeFlatMapPublisher(MaybeSource<T> source,
 
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        source.subscribe(new FlatMapPublisherSubscriber<T, R>(s, mapper));
+        source.subscribe(new FlatMapPublisherSubscriber<>(s, mapper));
     }
 
     static final class FlatMapPublisherSubscriber<T, R>

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableConcatMapCompletable.java
Patch:
@@ -55,7 +55,7 @@ public ObservableConcatMapCompletable(Observable<T> source,
     @Override
     protected void subscribeActual(CompletableObserver observer) {
         if (!ScalarXMapZHelper.tryAsCompletable(source, mapper, observer)) {
-            source.subscribe(new ConcatMapCompletableObserver<T>(observer, mapper, errorMode, prefetch));
+            source.subscribe(new ConcatMapCompletableObserver<>(observer, mapper, errorMode, prefetch));
         }
     }
 
@@ -120,7 +120,7 @@ public void onSubscribe(Disposable d) {
                         return;
                     }
                 }
-                queue = new SpscLinkedArrayQueue<T>(prefetch);
+                queue = new SpscLinkedArrayQueue<>(prefetch);
                 downstream.onSubscribe(this);
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableConcatMapMaybe.java
Patch:
@@ -56,7 +56,7 @@ public ObservableConcatMapMaybe(Observable<T> source,
     @Override
     protected void subscribeActual(Observer<? super R> observer) {
         if (!ScalarXMapZHelper.tryAsMaybe(source, mapper, observer)) {
-            source.subscribe(new ConcatMapMaybeMainObserver<T, R>(observer, mapper, prefetch, errorMode));
+            source.subscribe(new ConcatMapMaybeMainObserver<>(observer, mapper, prefetch, errorMode));
         }
     }
 
@@ -102,8 +102,8 @@ static final class ConcatMapMaybeMainObserver<T, R>
             this.mapper = mapper;
             this.errorMode = errorMode;
             this.errors = new AtomicThrowable();
-            this.inner = new ConcatMapMaybeObserver<R>(this);
-            this.queue = new SpscLinkedArrayQueue<T>(prefetch);
+            this.inner = new ConcatMapMaybeObserver<>(this);
+            this.queue = new SpscLinkedArrayQueue<>(prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableConcatMapSingle.java
Patch:
@@ -56,7 +56,7 @@ public ObservableConcatMapSingle(Observable<T> source,
     @Override
     protected void subscribeActual(Observer<? super R> observer) {
         if (!ScalarXMapZHelper.tryAsSingle(source, mapper, observer)) {
-            source.subscribe(new ConcatMapSingleMainObserver<T, R>(observer, mapper, prefetch, errorMode));
+            source.subscribe(new ConcatMapSingleMainObserver<>(observer, mapper, prefetch, errorMode));
         }
     }
 
@@ -102,8 +102,8 @@ static final class ConcatMapSingleMainObserver<T, R>
             this.mapper = mapper;
             this.errorMode = errorMode;
             this.errors = new AtomicThrowable();
-            this.inner = new ConcatMapSingleObserver<R>(this);
-            this.queue = new SpscLinkedArrayQueue<T>(prefetch);
+            this.inner = new ConcatMapSingleObserver<>(this);
+            this.queue = new SpscLinkedArrayQueue<>(prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableSwitchMapCompletable.java
Patch:
@@ -50,7 +50,7 @@ public ObservableSwitchMapCompletable(Observable<T> source,
     @Override
     protected void subscribeActual(CompletableObserver observer) {
         if (!ScalarXMapZHelper.tryAsCompletable(source, mapper, observer)) {
-            source.subscribe(new SwitchMapCompletableObserver<T>(observer, mapper, delayErrors));
+            source.subscribe(new SwitchMapCompletableObserver<>(observer, mapper, delayErrors));
         }
     }
 
@@ -78,7 +78,7 @@ static final class SwitchMapCompletableObserver<T> implements Observer<T>, Dispo
             this.mapper = mapper;
             this.delayErrors = delayErrors;
             this.errors = new AtomicThrowable();
-            this.inner = new AtomicReference<SwitchMapInnerObserver>();
+            this.inner = new AtomicReference<>();
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/mixed/SingleFlatMapObservable.java
Patch:
@@ -44,7 +44,7 @@ public SingleFlatMapObservable(SingleSource<T> source,
 
     @Override
     protected void subscribeActual(Observer<? super R> observer) {
-        FlatMapObserver<T, R> parent = new FlatMapObserver<T, R>(observer, mapper);
+        FlatMapObserver<T, R> parent = new FlatMapObserver<>(observer, mapper);
         observer.onSubscribe(parent);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.java
Patch:
@@ -35,7 +35,7 @@ public BlockingObservableIterable(ObservableSource<? extends T> source, int buff
 
     @Override
     public Iterator<T> iterator() {
-        BlockingObservableIterator<T> it = new BlockingObservableIterator<T>(bufferSize);
+        BlockingObservableIterator<T> it = new BlockingObservableIterator<>(bufferSize);
         source.subscribe(it);
         return it;
     }
@@ -56,7 +56,7 @@ static final class BlockingObservableIterator<T>
         volatile Throwable error;
 
         BlockingObservableIterator(int batchSize) {
-            this.queue = new SpscLinkedArrayQueue<T>(batchSize);
+            this.queue = new SpscLinkedArrayQueue<>(batchSize);
             this.lock = new ReentrantLock();
             this.condition = lock.newCondition();
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableLatest.java
Patch:
@@ -38,7 +38,7 @@ public BlockingObservableLatest(ObservableSource<T> source) {
 
     @Override
     public Iterator<T> iterator() {
-        BlockingObservableLatestIterator<T> lio = new BlockingObservableLatestIterator<T>();
+        BlockingObservableLatestIterator<T> lio = new BlockingObservableLatestIterator<>();
 
         Observable<Notification<T>> materialized = Observable.wrap(source).materialize();
 
@@ -52,7 +52,7 @@ static final class BlockingObservableLatestIterator<T> extends DisposableObserve
 
         final Semaphore notify = new Semaphore(0);
         // observer's notification
-        final AtomicReference<Notification<T>> value = new AtomicReference<Notification<T>>();
+        final AtomicReference<Notification<T>> value = new AtomicReference<>();
 
         @Override
         public void onNext(Notification<T> args) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableMostRecent.java
Patch:
@@ -40,7 +40,7 @@ public BlockingObservableMostRecent(ObservableSource<T> source, T initialValue)
 
     @Override
     public Iterator<T> iterator() {
-        MostRecentObserver<T> mostRecentObserver = new MostRecentObserver<T>(initialValue);
+        MostRecentObserver<T> mostRecentObserver = new MostRecentObserver<>(initialValue);
 
         source.subscribe(mostRecentObserver);
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAll.java
Patch:
@@ -28,7 +28,7 @@ public ObservableAll(ObservableSource<T> source, Predicate<? super T> predicate)
 
     @Override
     protected void subscribeActual(Observer<? super Boolean> t) {
-        source.subscribe(new AllObserver<T>(t, predicate));
+        source.subscribe(new AllObserver<>(t, predicate));
     }
 
     static final class AllObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAllSingle.java
Patch:
@@ -31,12 +31,12 @@ public ObservableAllSingle(ObservableSource<T> source, Predicate<? super T> pred
 
     @Override
     protected void subscribeActual(SingleObserver<? super Boolean> t) {
-        source.subscribe(new AllObserver<T>(t, predicate));
+        source.subscribe(new AllObserver<>(t, predicate));
     }
 
     @Override
     public Observable<Boolean> fuseToObservable() {
-        return RxJavaPlugins.onAssembly(new ObservableAll<T>(source, predicate));
+        return RxJavaPlugins.onAssembly(new ObservableAll<>(source, predicate));
     }
 
     static final class AllObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAmb.java
Patch:
@@ -68,7 +68,7 @@ public void subscribeActual(Observer<? super T> observer) {
             return;
         }
 
-        AmbCoordinator<T> ac = new AmbCoordinator<T>(observer, count);
+        AmbCoordinator<T> ac = new AmbCoordinator<>(observer, count);
         ac.subscribe(sources);
     }
 
@@ -88,7 +88,7 @@ public void subscribe(ObservableSource<? extends T>[] sources) {
             AmbInnerObserver<T>[] as = observers;
             int len = as.length;
             for (int i = 0; i < len; i++) {
-                as[i] = new AmbInnerObserver<T>(this, i + 1, downstream);
+                as[i] = new AmbInnerObserver<>(this, i + 1, downstream);
             }
             winner.lazySet(0); // release the contents of 'as'
             downstream.onSubscribe(this);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAny.java
Patch:
@@ -28,7 +28,7 @@ public ObservableAny(ObservableSource<T> source, Predicate<? super T> predicate)
 
     @Override
     protected void subscribeActual(Observer<? super Boolean> t) {
-        source.subscribe(new AnyObserver<T>(t, predicate));
+        source.subscribe(new AnyObserver<>(t, predicate));
     }
 
     static final class AnyObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAnySingle.java
Patch:
@@ -32,12 +32,12 @@ public ObservableAnySingle(ObservableSource<T> source, Predicate<? super T> pred
 
     @Override
     protected void subscribeActual(SingleObserver<? super Boolean> t) {
-        source.subscribe(new AnyObserver<T>(t, predicate));
+        source.subscribe(new AnyObserver<>(t, predicate));
     }
 
     @Override
     public Observable<Boolean> fuseToObservable() {
-        return RxJavaPlugins.onAssembly(new ObservableAny<T>(source, predicate));
+        return RxJavaPlugins.onAssembly(new ObservableAny<>(source, predicate));
     }
 
     static final class AnyObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBlockingSubscribe.java
Patch:
@@ -41,9 +41,9 @@ private ObservableBlockingSubscribe() {
      * @param <T> the value type
      */
     public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {
-        final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();
+        final BlockingQueue<Object> queue = new LinkedBlockingQueue<>();
 
-        BlockingObserver<T> bs = new BlockingObserver<T>(queue);
+        BlockingObserver<T> bs = new BlockingObserver<>(queue);
         observer.onSubscribe(bs);
 
         o.subscribe(bs);
@@ -76,7 +76,7 @@ public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? sup
      */
     public static <T> void subscribe(ObservableSource<? extends T> o) {
         BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();
-        LambdaObserver<T> ls = new LambdaObserver<T>(Functions.emptyConsumer(),
+        LambdaObserver<T> ls = new LambdaObserver<>(Functions.emptyConsumer(),
         callback, callback, Functions.emptyConsumer());
 
         o.subscribe(ls);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBuffer.java
Patch:
@@ -39,12 +39,12 @@ public ObservableBuffer(ObservableSource<T> source, int count, int skip, Supplie
     @Override
     protected void subscribeActual(Observer<? super U> t) {
         if (skip == count) {
-            BufferExactObserver<T, U> bes = new BufferExactObserver<T, U>(t, count, bufferSupplier);
+            BufferExactObserver<T, U> bes = new BufferExactObserver<>(t, count, bufferSupplier);
             if (bes.createBuffer()) {
                 source.subscribe(bes);
             }
         } else {
-            source.subscribe(new BufferSkipObserver<T, U>(t, count, skip, bufferSupplier));
+            source.subscribe(new BufferSkipObserver<>(t, count, skip, bufferSupplier));
         }
     }
 
@@ -157,7 +157,7 @@ static final class BufferSkipObserver<T, U extends Collection<? super T>>
             this.count = count;
             this.skip = skip;
             this.bufferSupplier = bufferSupplier;
-            this.buffers = new ArrayDeque<U>();
+            this.buffers = new ArrayDeque<>();
         }
 
         @Override

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.java
Patch:
@@ -39,7 +39,7 @@ public ObservableBufferExactBoundary(ObservableSource<T> source, ObservableSourc
 
     @Override
     protected void subscribeActual(Observer<? super U> t) {
-        source.subscribe(new BufferExactBoundaryObserver<T, U, B>(new SerializedObserver<U>(t), bufferSupplier, boundary));
+        source.subscribe(new BufferExactBoundaryObserver<>(new SerializedObserver<>(t), bufferSupplier, boundary));
     }
 
     static final class BufferExactBoundaryObserver<T, U extends Collection<? super T>, B>
@@ -56,7 +56,7 @@ static final class BufferExactBoundaryObserver<T, U extends Collection<? super T
 
         BufferExactBoundaryObserver(Observer<? super U> actual, Supplier<U> bufferSupplier,
                                              ObservableSource<B> boundary) {
-            super(actual, new MpscLinkedQueue<U>());
+            super(actual, new MpscLinkedQueue<>());
             this.bufferSupplier = bufferSupplier;
             this.boundary = boundary;
         }
@@ -80,7 +80,7 @@ public void onSubscribe(Disposable d) {
 
                 buffer = b;
 
-                BufferBoundaryObserver<T, U, B> bs = new BufferBoundaryObserver<T, U, B>(this);
+                BufferBoundaryObserver<T, U, B> bs = new BufferBoundaryObserver<>(this);
                 other = bs;
 
                 downstream.onSubscribe(this);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCollect.java
Patch:
@@ -43,7 +43,7 @@ protected void subscribeActual(Observer<? super U> t) {
             return;
         }
 
-        source.subscribe(new CollectObserver<T, U>(t, u, collector));
+        source.subscribe(new CollectObserver<>(t, u, collector));
 
     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCollectSingle.java
Patch:
@@ -47,12 +47,12 @@ protected void subscribeActual(SingleObserver<? super U> t) {
             return;
         }
 
-        source.subscribe(new CollectObserver<T, U>(t, u, collector));
+        source.subscribe(new CollectObserver<>(t, u, collector));
     }
 
     @Override
     public Observable<U> fuseToObservable() {
-        return RxJavaPlugins.onAssembly(new ObservableCollect<T, U>(source, initialSupplier, collector));
+        return RxJavaPlugins.onAssembly(new ObservableCollect<>(source, initialSupplier, collector));
     }
 
     static final class CollectObserver<T, U> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCombineLatest.java
Patch:
@@ -66,7 +66,7 @@ public void subscribeActual(Observer<? super R> observer) {
             return;
         }
 
-        LatestCoordinator<T, R> lc = new LatestCoordinator<T, R>(observer, combiner, count, bufferSize, delayError);
+        LatestCoordinator<T, R> lc = new LatestCoordinator<>(observer, combiner, count, bufferSize, delayError);
         lc.subscribe(sources);
     }
 
@@ -99,10 +99,10 @@ static final class LatestCoordinator<T, R> extends AtomicInteger implements Disp
             this.latest = new Object[count];
             CombinerObserver<T, R>[] as = new CombinerObserver[count];
             for (int i = 0; i < count; i++) {
-                as[i] = new CombinerObserver<T, R>(this, i);
+                as[i] = new CombinerObserver<>(this, i);
             }
             this.observers = as;
-            this.queue = new SpscLinkedArrayQueue<Object[]>(bufferSize);
+            this.queue = new SpscLinkedArrayQueue<>(bufferSize);
         }
 
         public void subscribe(ObservableSource<? extends T>[] sources) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatWithCompletable.java
Patch:
@@ -37,7 +37,7 @@ public ObservableConcatWithCompletable(Observable<T> source, CompletableSource o
 
     @Override
     protected void subscribeActual(Observer<? super T> observer) {
-        source.subscribe(new ConcatWithObserver<T>(observer, other));
+        source.subscribe(new ConcatWithObserver<>(observer, other));
     }
 
     static final class ConcatWithObserver<T>

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatWithMaybe.java
Patch:
@@ -37,7 +37,7 @@ public ObservableConcatWithMaybe(Observable<T> source, MaybeSource<? extends T>
 
     @Override
     protected void subscribeActual(Observer<? super T> observer) {
-        source.subscribe(new ConcatWithObserver<T>(observer, other));
+        source.subscribe(new ConcatWithObserver<>(observer, other));
     }
 
     static final class ConcatWithObserver<T>

File: src/main/java/io/reactivex/rxjava3/core/Completable.java
Patch:
@@ -2335,7 +2335,7 @@ public final void subscribe(@NonNull CompletableObserver observer) {
      * applied by {@link #subscribe(CompletableObserver)} before this method gets called.
      * @param observer the CompletableObserver instance, never null
      */
-    protected abstract void subscribeActual(CompletableObserver observer);
+    protected abstract void subscribeActual(@NonNull CompletableObserver observer);
 
     /**
      * Subscribes a given CompletableObserver (subclass) to this Completable and returns the given

File: src/main/java/io/reactivex/rxjava3/disposables/SerialDisposable.java
Patch:
@@ -30,15 +30,15 @@ public final class SerialDisposable implements Disposable {
      * Constructs an empty SerialDisposable.
      */
     public SerialDisposable() {
-        this.resource = new AtomicReference<Disposable>();
+        this.resource = new AtomicReference<>();
     }
 
     /**
      * Constructs a SerialDisposable with the given initial Disposable instance.
      * @param initialDisposable the initial Disposable instance to use, null allowed
      */
     public SerialDisposable(@Nullable Disposable initialDisposable) {
-        this.resource = new AtomicReference<Disposable>(initialDisposable);
+        this.resource = new AtomicReference<>(initialDisposable);
     }
 
     /**

File: src/main/java/io/reactivex/rxjava3/exceptions/CompositeException.java
Patch:
@@ -62,8 +62,8 @@ public CompositeException(@NonNull Throwable... exceptions) {
      * @throws IllegalArgumentException if <code>errors</code> is empty.
      */
     public CompositeException(@NonNull Iterable<? extends Throwable> errors) {
-        Set<Throwable> deDupedExceptions = new LinkedHashSet<Throwable>();
-        List<Throwable> localExceptions = new ArrayList<Throwable>();
+        Set<Throwable> deDupedExceptions = new LinkedHashSet<>();
+        List<Throwable> localExceptions = new ArrayList<>();
         if (errors != null) {
             for (Throwable ex : errors) {
                 if (ex instanceof CompositeException) {
@@ -108,7 +108,7 @@ public synchronized Throwable getCause() { // NOPMD
         if (cause == null) {
             String separator = System.getProperty("line.separator");
             if (exceptions.size() > 1) {
-                Map<Throwable, Boolean> seenCauses = new IdentityHashMap<Throwable, Boolean>();
+                Map<Throwable, Boolean> seenCauses = new IdentityHashMap<>();
 
                 StringBuilder aggregateMessage = new StringBuilder();
                 aggregateMessage.append("Multiple exceptions (").append(exceptions.size()).append(")").append(separator);

File: src/main/java/io/reactivex/rxjava3/schedulers/TestScheduler.java
Patch:
@@ -28,7 +28,7 @@
  */
 public final class TestScheduler extends Scheduler {
     /** The ordered queue for the runnable tasks. */
-    final Queue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>(11);
+    final Queue<TimedRunnable> queue = new PriorityBlockingQueue<>(11);
     /** The per-scheduler global order counter. */
     long counter;
     // Storing time in nanoseconds internally.

File: src/main/java/io/reactivex/rxjava3/subjects/CompletableSubject.java
Patch:
@@ -107,7 +107,7 @@ public static CompletableSubject create() {
 
     CompletableSubject() {
         once = new AtomicBoolean();
-        observers = new AtomicReference<CompletableDisposable[]>(EMPTY);
+        observers = new AtomicReference<>(EMPTY);
     }
 
     @Override

File: src/main/java/io/reactivex/rxjava3/subjects/MaybeSubject.java
Patch:
@@ -131,13 +131,13 @@ public final class MaybeSubject<T> extends Maybe<T> implements MaybeObserver<T>
     @CheckReturnValue
     @NonNull
     public static <T> MaybeSubject<T> create() {
-        return new MaybeSubject<T>();
+        return new MaybeSubject<>();
     }
 
     @SuppressWarnings("unchecked")
     MaybeSubject() {
         once = new AtomicBoolean();
-        observers = new AtomicReference<MaybeDisposable<T>[]>(EMPTY);
+        observers = new AtomicReference<>(EMPTY);
     }
 
     @Override
@@ -185,7 +185,7 @@ public void onComplete() {
 
     @Override
     protected void subscribeActual(MaybeObserver<? super T> observer) {
-        MaybeDisposable<T> md = new MaybeDisposable<T>(observer, this);
+        MaybeDisposable<T> md = new MaybeDisposable<>(observer, this);
         observer.onSubscribe(md);
         if (add(md)) {
             if (md.isDisposed()) {

File: src/main/java/io/reactivex/rxjava3/subjects/SingleSubject.java
Patch:
@@ -115,13 +115,13 @@ public final class SingleSubject<T> extends Single<T> implements SingleObserver<
     @CheckReturnValue
     @NonNull
     public static <T> SingleSubject<T> create() {
-        return new SingleSubject<T>();
+        return new SingleSubject<>();
     }
 
     @SuppressWarnings("unchecked")
     SingleSubject() {
         once = new AtomicBoolean();
-        observers = new AtomicReference<SingleDisposable<T>[]>(EMPTY);
+        observers = new AtomicReference<>(EMPTY);
     }
 
     @Override
@@ -159,7 +159,7 @@ public void onError(@NonNull Throwable e) {
 
     @Override
     protected void subscribeActual(@NonNull SingleObserver<? super T> observer) {
-        SingleDisposable<T> md = new SingleDisposable<T>(observer, this);
+        SingleDisposable<T> md = new SingleDisposable<>(observer, this);
         observer.onSubscribe(md);
         if (add(md)) {
             if (md.isDisposed()) {

File: src/test/java/io/reactivex/rxjava3/core/TransformerTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 
+import io.reactivex.rxjava3.core.ConverterTest.*;
 import io.reactivex.rxjava3.exceptions.TestException;
 
 public class TransformerTest extends RxJavaTest {
@@ -127,9 +128,6 @@ public void flowableGenericsSignatureTest() {
         Flowable.just(a).compose(TransformerTest.<String>testFlowableTransformerCreator());
     }
 
-    interface A<T, R> { }
-    interface B<T> { }
-
     private static <T> ObservableTransformer<A<T, ?>, B<T>> testObservableTransformerCreator() {
         return new ObservableTransformer<A<T, ?>, B<T>>() {
             @Override

File: src/test/java/io/reactivex/rxjava3/flowable/FlowableConversionTest.java
Patch:
@@ -59,7 +59,7 @@ public <R> CylonDetectorObservable<R> lift(FlowableOperator<? extends R, ? super
             return x(new RobotConversionFunc<>(operator));
         }
 
-        public <R, O> O x(Function<Publisher<T>, O> operator) {
+        public <O> O x(Function<Publisher<T>, O> operator) {
             try {
                 return operator.apply(onSubscribe);
             } catch (Throwable ex) {

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -1046,7 +1046,7 @@ public void combineLatestNArguments() throws Exception {
                     if (j < i) {
                         assertEquals("source" + (j + 1) + " is null", ex.getCause().getMessage());
                     } else {
-                        assertEquals("f is null", ex.getCause().getMessage());
+                        assertEquals("combiner is null", ex.getCause().getMessage());
                     }
                 }
             }

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -73,7 +73,7 @@ public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {
                     .map(new Function<Throwable, Tuple>() {
                         @Override
                         public Tuple apply(Throwable n) {
-                            return new Tuple(new Long(1), n);
+                            return new Tuple(1L, n);
                         }})
                     .scan(new BiFunction<Tuple, Tuple, Tuple>() {
                         @Override

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableZipTest.java
Patch:
@@ -1297,7 +1297,7 @@ public void zipNArguments() throws Exception {
                     if (j < i) {
                         assertEquals("source" + (j + 1) + " is null", ex.getCause().getMessage());
                     } else {
-                        assertEquals("f is null", ex.getCause().getMessage());
+                        assertEquals("zipper is null", ex.getCause().getMessage());
                     }
                 }
             }

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatMapEagerTest.java
Patch:
@@ -893,7 +893,6 @@ public void arrayDelayErrorMaxConcurrency() {
         PublishSubject<Integer> ps2 = PublishSubject.create();
         PublishSubject<Integer> ps3 = PublishSubject.create();
 
-        @SuppressWarnings("unchecked")
         TestObserver<Integer> to = Observable.concatArrayEagerDelayError(2, 2, ps1, ps2, ps3)
         .test();
 
@@ -929,7 +928,6 @@ public void arrayDelayErrorMaxConcurrencyErrorDelayed() {
         PublishSubject<Integer> ps2 = PublishSubject.create();
         PublishSubject<Integer> ps3 = PublishSubject.create();
 
-        @SuppressWarnings("unchecked")
         TestObserver<Integer> to = Observable.concatArrayEagerDelayError(2, 2, ps1, ps2, ps3)
         .test();
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeDelayErrorTest.java
Patch:
@@ -506,7 +506,6 @@ public void mergeIterableDelayError() {
         .assertResult(1, 2);
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void mergeArrayDelayError() {
         Observable.mergeArrayDelayError(Observable.just(1), Observable.just(2))

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeTest.java
Patch:
@@ -1065,7 +1065,6 @@ public void onNext(Integer t) {
         }
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void mergeArray2() {
         Observable.mergeArray(Observable.just(1), Observable.just(2))

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java
Patch:
@@ -74,7 +74,7 @@ public Observable<Object> apply(Observable<? extends Throwable> attempts) {
                     .map(new Function<Throwable, Tuple>() {
                         @Override
                         public Tuple apply(Throwable n) {
-                            return new Tuple(new Long(1), n);
+                            return new Tuple(1L, n);
                         }})
                     .scan(new BiFunction<Tuple, Tuple, Tuple>() {
                         @Override

File: src/test/java/io/reactivex/rxjava3/maybe/MaybeTest.java
Patch:
@@ -2662,7 +2662,7 @@ public void mergeDelayError4() {
 
     @Test
     public void sequenceEqual() {
-        Maybe.sequenceEqual(Maybe.just(1), Maybe.just(new Integer(1))).test().assertResult(true);
+        Maybe.sequenceEqual(Maybe.just(1_000_000), Maybe.just(Integer.valueOf(1_000_000))).test().assertResult(true);
 
         Maybe.sequenceEqual(Maybe.just(1), Maybe.just(2)).test().assertResult(false);
 

File: src/test/java/io/reactivex/rxjava3/observable/ObservableNullTests.java
Patch:
@@ -202,7 +202,6 @@ public void concatArrayNull() {
         Observable.concatArray((Observable<Object>[])null);
     }
 
-    @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void concatArrayOneIsNull() {
         Observable.concatArray(just1, null).blockingLast();
@@ -521,7 +520,6 @@ public void mergeArrayNull() {
         Observable.mergeArray(128, 128, (Observable<Object>[])null);
     }
 
-    @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void mergeArrayOneIsNull() {
         Observable.mergeArray(128, 128, just1, null).blockingLast();
@@ -552,7 +550,6 @@ public void mergeDelayErrorArrayNull() {
         Observable.mergeArrayDelayError(128, 128, (Observable<Object>[])null);
     }
 
-    @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void mergeDelayErrorArrayOneIsNull() {
         Observable.mergeArrayDelayError(128, 128, just1, null).blockingLast();

File: src/test/java/io/reactivex/rxjava3/parallel/ParallelFlowableTest.java
Patch:
@@ -306,7 +306,6 @@ public Iterable<Integer> apply(List<Integer> v) throws Exception {
         TestHelper.assertValueSet(ts, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void from() {
         TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

File: src/test/java/io/reactivex/rxjava3/parallel/ParallelReduceFullTest.java
Patch:
@@ -73,7 +73,6 @@ public Integer apply(Integer a, Integer b) throws Exception {
         }
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void error2() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/rxjava3/parallel/ParallelSortedJoinTest.java
Patch:
@@ -82,7 +82,6 @@ public void error3() {
         }
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void error2() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/rxjava3/subjects/UnicastSubjectTest.java
Patch:
@@ -368,7 +368,7 @@ public void dispose() {
             public void run() {
                 calls[0]++;
             }
-        });
+        }, true);
 
         TestHelper.checkDisposed(us);
 

File: src/main/java/io/reactivex/rxjava3/annotations/BackpressureKind.java
Patch:
@@ -32,13 +32,13 @@ public enum BackpressureKind {
      */
     SPECIAL,
     /**
-     * The operator requests Long.MAX_VALUE from upstream but respects the backpressure
+     * The operator requests {@link Long#MAX_VALUE} from upstream but respects the backpressure
      * of the downstream.
      */
     UNBOUNDED_IN,
     /**
-     * The operator will emit a MissingBackpressureException if the downstream didn't request
-     * enough or in time.
+     * The operator will emit a {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException MissingBackpressureException}
+     * if the downstream didn't request enough or in time.
      */
     ERROR,
     /**

File: src/main/java/io/reactivex/rxjava3/core/CompletableEmitter.java
Patch:
@@ -82,12 +82,12 @@ public interface CompletableEmitter {
     boolean isDisposed();
 
     /**
-     * Attempts to emit the specified {@code Throwable} error if the downstream
+     * Attempts to emit the specified {@link Throwable} error if the downstream
      * hasn't cancelled the sequence or is otherwise terminated, returning false
      * if the emission is not allowed to happen due to lifecycle restrictions.
      * <p>
-     * Unlike {@link #onError(Throwable)}, the {@code RxJavaPlugins.onError} is not called
-     * if the error could not be delivered.
+     * Unlike {@link #onError(Throwable)}, the {@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable) RxjavaPlugins.onError}
+     * is not called if the error could not be delivered.
      * <p>History: 2.1.1 - experimental
      * @param t the throwable error to signal if possible
      * @return true if successful, false if the downstream is not able to accept further

File: src/main/java/io/reactivex/rxjava3/core/CompletableObserver.java
Patch:
@@ -49,9 +49,9 @@
  */
 public interface CompletableObserver {
     /**
-     * Called once by the Completable to set a Disposable on this instance which
+     * Called once by the {@link Completable} to set a {@link Disposable} on this instance which
      * then can be used to cancel the subscription at any time.
-     * @param d the Disposable instance to call dispose on for cancellation, not null
+     * @param d the {@code Disposable} instance to call dispose on for cancellation, not null
      */
     void onSubscribe(@NonNull Disposable d);
 
@@ -62,7 +62,7 @@ public interface CompletableObserver {
 
     /**
      * Called once if the deferred computation 'throws' an exception.
-     * @param e the exception, not null.
+     * @param e the exception, not {@code null}.
      */
     void onError(@NonNull Throwable e);
 }

File: src/main/java/io/reactivex/rxjava3/core/CompletableOnSubscribe.java
Patch:
@@ -23,8 +23,8 @@
 public interface CompletableOnSubscribe {
 
     /**
-     * Called for each CompletableObserver that subscribes.
-     * @param emitter the safe emitter instance, never null
+     * Called for each {@link CompletableObserver} that subscribes.
+     * @param emitter the safe emitter instance, never {@code null}
      * @throws Throwable on error
      */
     void subscribe(@NonNull CompletableEmitter emitter) throws Throwable;

File: src/main/java/io/reactivex/rxjava3/core/Emitter.java
Patch:
@@ -29,13 +29,13 @@ public interface Emitter<T> {
 
     /**
      * Signal a normal value.
-     * @param value the value to signal, not null
+     * @param value the value to signal, not {@code null}
      */
     void onNext(@NonNull T value);
 
     /**
-     * Signal a Throwable exception.
-     * @param error the Throwable to signal, not null
+     * Signal a {@link Throwable} exception.
+     * @param error the {@code Throwable} to signal, not {@code null}
      */
     void onError(@NonNull Throwable error);
 

File: src/main/java/io/reactivex/rxjava3/core/FlowableConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
- * Convenience interface and callback used by the {@link Flowable#to} operator to turn a Flowable into another
+ * Convenience interface and callback used by the {@link Flowable#to} operator to turn a {@link Flowable} into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type
@@ -26,9 +26,9 @@
 @FunctionalInterface
 public interface FlowableConverter<T, R> {
     /**
-     * Applies a function to the upstream Flowable and returns a converted value of type {@code R}.
+     * Applies a function to the upstream {@link Flowable} and returns a converted value of type {@code R}.
      *
-     * @param upstream the upstream Flowable instance
+     * @param upstream the upstream {@code Flowable} instance
      * @return the converted value
      */
     @NonNull

File: src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.java
Patch:
@@ -25,8 +25,8 @@
 public interface FlowableOnSubscribe<T> {
 
     /**
-     * Called for each Subscriber that subscribes.
-     * @param emitter the safe emitter instance, never null
+     * Called for each {@link org.reactivestreams.Subscriber Subscriber} that subscribes.
+     * @param emitter the safe emitter instance, never {@code null}
      * @throws Throwable on error
      */
     void subscribe(@NonNull FlowableEmitter<T> emitter) throws Throwable;

File: src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
- * Represents a Reactive-Streams inspired Subscriber that is RxJava 2 only
+ * Represents a Reactive-Streams inspired {@link Subscriber} that is RxJava 2 only
  * and weakens rules 1.3 and 3.9 of the specification for gaining performance.
  *
  * <p>History: 2.0.7 - experimental; 2.1 - beta

File: src/main/java/io/reactivex/rxjava3/core/MaybeConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
- * Convenience interface and callback used by the {@link Maybe#to} operator to turn a Maybe into another
+ * Convenience interface and callback used by the {@link Maybe#to} operator to turn a {@link Maybe} into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type
@@ -26,9 +26,9 @@
 @FunctionalInterface
 public interface MaybeConverter<T, R> {
     /**
-     * Applies a function to the upstream Maybe and returns a converted value of type {@code R}.
+     * Applies a function to the upstream {@link Maybe} and returns a converted value of type {@code R}.
      *
-     * @param upstream the upstream Maybe instance
+     * @param upstream the upstream {@code Maybe} instance
      * @return the converted value
      */
     @NonNull

File: src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.java
Patch:
@@ -25,8 +25,8 @@
 public interface MaybeOnSubscribe<T> {
 
     /**
-     * Called for each MaybeObserver that subscribes.
-     * @param emitter the safe emitter instance, never null
+     * Called for each {@link MaybeObserver} that subscribes.
+     * @param emitter the safe emitter instance, never {@code null}
      * @throws Throwable on error
      */
     void subscribe(@NonNull MaybeEmitter<T> emitter) throws Throwable;

File: src/main/java/io/reactivex/rxjava3/core/MaybeSource.java
Patch:
@@ -28,9 +28,9 @@
 public interface MaybeSource<T> {
 
     /**
-     * Subscribes the given MaybeObserver to this MaybeSource instance.
-     * @param observer the MaybeObserver, not null
-     * @throws NullPointerException if {@code observer} is null
+     * Subscribes the given {@link MaybeObserver} to this {@link MaybeSource} instance.
+     * @param observer the {@code MaybeObserver}, not {@code null}
+     * @throws NullPointerException if {@code observer} is {@code null}
      */
     void subscribe(@NonNull MaybeObserver<? super T> observer);
 }

File: src/main/java/io/reactivex/rxjava3/core/ObservableConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
- * Convenience interface and callback used by the {@link Observable#to} operator to turn an Observable into another
+ * Convenience interface and callback used by the {@link Observable#to} operator to turn an {@link Observable} into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type
@@ -26,9 +26,9 @@
 @FunctionalInterface
 public interface ObservableConverter<T, R> {
     /**
-     * Applies a function to the upstream Observable and returns a converted value of type {@code R}.
+     * Applies a function to the upstream {@link Observable} and returns a converted value of type {@code R}.
      *
-     * @param upstream the upstream Observable instance
+     * @param upstream the upstream {@code Observable} instance
      * @return the converted value
      */
     @NonNull

File: src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.java
Patch:
@@ -25,8 +25,8 @@
 public interface ObservableOnSubscribe<T> {
 
     /**
-     * Called for each Observer that subscribes.
-     * @param emitter the safe emitter instance, never null
+     * Called for each {@link Observer} that subscribes.
+     * @param emitter the safe emitter instance, never {@code null}
      * @throws Throwable on error
      */
     void subscribe(@NonNull ObservableEmitter<T> emitter) throws Throwable;

File: src/main/java/io/reactivex/rxjava3/core/ObservableSource.java
Patch:
@@ -25,9 +25,9 @@
 public interface ObservableSource<T> {
 
     /**
-     * Subscribes the given Observer to this ObservableSource instance.
-     * @param observer the Observer, not null
-     * @throws NullPointerException if {@code observer} is null
+     * Subscribes the given {@link Observer} to this {@link ObservableSource} instance.
+     * @param observer the {@code Observer}, not {@code null}
+     * @throws NullPointerException if {@code observer} is {@code null}
      */
     void subscribe(@NonNull Observer<? super T> observer);
 }

File: src/main/java/io/reactivex/rxjava3/core/Single.java
Patch:
@@ -2346,7 +2346,7 @@ public final <U> Single<T> delaySubscription(ObservableSource<U> other) {
      * <img width="640" height="214" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.p.png" alt="">
      * <p>If the delaying source signals an error, that error is re-emitted and no subscription
      * to the current Single happens.
-     * <p>The other source is consumed in an unbounded manner (requesting Long.MAX_VALUE from it).
+     * <p>The other source is consumed in an unbounded manner (requesting {@link Long#MAX_VALUE} from it).
      * <dl>
      * <dt><b>Backpressure:</b></dt>
      * <dd>The {@code other} publisher is consumed in an unbounded fashion but will be

File: src/main/java/io/reactivex/rxjava3/core/SingleConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
- * Convenience interface and callback used by the {@link Single#to} operator to turn a Single into another
+ * Convenience interface and callback used by the {@link Single#to} operator to turn a {@link Single} into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type
@@ -26,9 +26,9 @@
 @FunctionalInterface
 public interface SingleConverter<T, R> {
     /**
-     * Applies a function to the upstream Single and returns a converted value of type {@code R}.
+     * Applies a function to the upstream {@link Single} and returns a converted value of type {@code R}.
      *
-     * @param upstream the upstream Single instance
+     * @param upstream the upstream {@code Single} instance
      * @return the converted value
      */
     @NonNull

File: src/main/java/io/reactivex/rxjava3/core/SingleOnSubscribe.java
Patch:
@@ -25,8 +25,8 @@
 public interface SingleOnSubscribe<T> {
 
     /**
-     * Called for each SingleObserver that subscribes.
-     * @param emitter the safe emitter instance, never null
+     * Called for each {@link SingleObserver} that subscribes.
+     * @param emitter the safe emitter instance, never {@code null}
      * @throws Throwable on error
      */
     void subscribe(@NonNull SingleEmitter<T> emitter) throws Throwable;

File: src/main/java/io/reactivex/rxjava3/core/SingleSource.java
Patch:
@@ -28,9 +28,9 @@
 public interface SingleSource<T> {
 
     /**
-     * Subscribes the given SingleObserver to this SingleSource instance.
-     * @param observer the SingleObserver, not null
-     * @throws NullPointerException if {@code observer} is null
+     * Subscribes the given {@link SingleObserver} to this {@link SingleSource} instance.
+     * @param observer the {@code SingleObserver}, not {@code null}
+     * @throws NullPointerException if {@code observer} is {@code null}
      */
     void subscribe(@NonNull SingleObserver<? super T> observer);
 }

File: src/main/java/io/reactivex/rxjava3/exceptions/UndeliverableException.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.rxjava3.exceptions;
 
 /**
- * Wrapper for Throwable errors that are sent to `RxJavaPlugins.onError`.
+ * Wrapper for Throwable errors that are sent to {@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable) RxJavaPlugins.onError}.
  * <p>History: 2.0.6 - experimental; 2.1 - beta
  * @since 2.2
  */

File: src/main/java/io/reactivex/rxjava3/internal/util/QueueDrainHelper.java
Patch:
@@ -218,7 +218,7 @@ public static <T> SimpleQueue<T> createQueue(int capacityHint) {
     }
 
     /**
-     * Requests Long.MAX_VALUE if prefetch is negative or the exact
+     * Requests {@link Long#MAX_VALUE} if prefetch is negative or the exact
      * amount if prefetch is positive.
      * @param s the Subscription to request from
      * @param prefetch the prefetch value
@@ -383,7 +383,7 @@ static <T> boolean postCompleteDrain(long n,
      * in completed mode, requests no-longer reach the upstream but help in draining the queue.
      * <p>
      * The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
-     * request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
+     * request amount only goes up to {@link Long#MAX_VALUE} (bits 0-62) and negative values aren't
      * allowed.
      *
      * @param <T> the value type emitted

File: src/main/java/io/reactivex/rxjava3/observers/DisposableCompletableObserver.java
Patch:
@@ -53,7 +53,7 @@
  */
 public abstract class DisposableCompletableObserver implements CompletableObserver, Disposable {
 
-    final AtomicReference<Disposable> upstream = new AtomicReference<Disposable>();
+    final AtomicReference<Disposable> upstream = new AtomicReference<>();
 
     @Override
     public final void onSubscribe(@NonNull Disposable d) {
@@ -63,7 +63,7 @@ public final void onSubscribe(@NonNull Disposable d) {
     }
 
     /**
-     * Called once the single upstream Disposable is set via onSubscribe.
+     * Called once the single upstream {@link Disposable} is set via {@link #onSubscribe(Disposable)}.
      */
     protected void onStart() {
     }

File: src/main/java/io/reactivex/rxjava3/observers/DisposableMaybeObserver.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.rxjava3.internal.util.EndConsumerHelper;
 
 /**
- * An abstract {@link MaybeObserver} that allows asynchronous cancellation by implementing Disposable.
+ * An abstract {@link MaybeObserver} that allows asynchronous cancellation by implementing {@link Disposable}.
  *
  * <p>All pre-implemented final methods are thread-safe.
  *
@@ -62,7 +62,7 @@
  */
 public abstract class DisposableMaybeObserver<T> implements MaybeObserver<T>, Disposable {
 
-    final AtomicReference<Disposable> upstream = new AtomicReference<Disposable>();
+    final AtomicReference<Disposable> upstream = new AtomicReference<>();
 
     @Override
     public final void onSubscribe(@NonNull Disposable d) {
@@ -72,7 +72,7 @@ public final void onSubscribe(@NonNull Disposable d) {
     }
 
     /**
-     * Called once the single upstream Disposable is set via onSubscribe.
+     * Called once the single upstream {@link Disposable} is set via {@link #onSubscribe(Disposable)}.
      */
     protected void onStart() {
     }

File: src/main/java/io/reactivex/rxjava3/observers/DisposableObserver.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.rxjava3.internal.util.EndConsumerHelper;
 
 /**
- * An abstract {@link Observer} that allows asynchronous cancellation by implementing Disposable.
+ * An abstract {@link Observer} that allows asynchronous cancellation by implementing {@link Disposable}.
  *
  * <p>All pre-implemented final methods are thread-safe.
  *
@@ -66,7 +66,7 @@
  */
 public abstract class DisposableObserver<T> implements Observer<T>, Disposable {
 
-    final AtomicReference<Disposable> upstream = new AtomicReference<Disposable>();
+    final AtomicReference<Disposable> upstream = new AtomicReference<>();
 
     @Override
     public final void onSubscribe(@NonNull Disposable d) {

File: src/main/java/io/reactivex/rxjava3/observers/DisposableSingleObserver.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.rxjava3.internal.util.EndConsumerHelper;
 
 /**
- * An abstract {@link SingleObserver} that allows asynchronous cancellation by implementing Disposable.
+ * An abstract {@link SingleObserver} that allows asynchronous cancellation by implementing {@link Disposable}.
  *
  * <p>All pre-implemented final methods are thread-safe.
  *
@@ -55,7 +55,7 @@
  */
 public abstract class DisposableSingleObserver<T> implements SingleObserver<T>, Disposable {
 
-    final AtomicReference<Disposable> upstream = new AtomicReference<Disposable>();
+    final AtomicReference<Disposable> upstream = new AtomicReference<>();
 
     @Override
     public final void onSubscribe(@NonNull Disposable d) {
@@ -65,7 +65,7 @@ public final void onSubscribe(@NonNull Disposable d) {
     }
 
     /**
-     * Called once the single upstream Disposable is set via onSubscribe.
+     * Called once the single upstream {@link Disposable} is set via {@link #onSubscribe(Disposable)}.
      */
     protected void onStart() {
     }

File: src/main/java/io/reactivex/rxjava3/observers/LambdaConsumerIntrospection.java
Patch:
@@ -24,8 +24,8 @@
 public interface LambdaConsumerIntrospection {
 
     /**
-     * Returns true or false if a custom onError consumer has been provided.
-     * @return {@code true} if a custom onError consumer implementation was supplied. Returns {@code false} if the
+     * Returns {@code true} or {@code false} if a custom {@code onError} consumer has been provided.
+     * @return {@code true} if a custom {@code onError} consumer implementation was supplied. Returns {@code false} if the
      * implementation is missing an error consumer and thus using a throwing default implementation.
      */
     boolean hasCustomOnError();

File: src/main/java/io/reactivex/rxjava3/observers/SafeObserver.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
- * Wraps another Subscriber and ensures all onXXX methods conform the protocol
+ * Wraps another {@link Observer} and ensures all {@code onXXX} methods conform the protocol
  * (except the requirement for serialized access).
  *
  * @param <T> the value type
@@ -35,8 +35,8 @@ public final class SafeObserver<T> implements Observer<T>, Disposable {
     boolean done;
 
     /**
-     * Constructs a SafeObserver by wrapping the given actual Observer.
-     * @param downstream the actual Observer to wrap, not null (not validated)
+     * Constructs a {@code SafeObserver} by wrapping the given actual {@link Observer}.
+     * @param downstream the actual {@code Observer} to wrap, not {@code null} (not validated)
      */
     public SafeObserver(@NonNull Observer<? super T> downstream) {
         this.downstream = downstream;

File: src/main/java/io/reactivex/rxjava3/processors/AsyncProcessor.java
Patch:
@@ -68,7 +68,7 @@
  *  <dd>The {@code AsyncProcessor} honors the backpressure of the downstream {@code Subscriber}s and won't emit
  *  its single value to a particular {@code Subscriber} until that {@code Subscriber} has requested an item.
  *  When the {@code AsyncProcessor} is subscribed to a {@link io.reactivex.rxjava3.core.Flowable}, the processor consumes this
- *  {@code Flowable} in an unbounded manner (requesting `Long.MAX_VALUE`) as only the very last upstream item is
+ *  {@code Flowable} in an unbounded manner (requesting {@link Long#MAX_VALUE}) as only the very last upstream item is
  *  retained by it.
  *  </dd>
  *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/rxjava3/processors/BehaviorProcessor.java
Patch:
@@ -108,7 +108,7 @@
  *  that returns true if any of the {@code Subscriber}s is not ready to receive {@code onNext} events. If
  *  there are no {@code Subscriber}s to the processor, {@code offer()} always succeeds.
  *  If the {@code BehaviorProcessor} is (optionally) subscribed to another {@code Publisher}, this upstream
- *  {@code Publisher} is consumed in an unbounded fashion (requesting {@code Long.MAX_VALUE}).</dd>
+ *  {@code Publisher} is consumed in an unbounded fashion (requesting {@link Long#MAX_VALUE}).</dd>
  *  <dt><b>Scheduler:</b></dt>
  *  <dd>{@code BehaviorProcessor} does not operate by default on a particular {@link io.reactivex.rxjava3.core.Scheduler} and
  *  the {@code Subscriber}s get notified on the thread the respective {@code onXXX} methods were invoked.</dd>
@@ -229,7 +229,7 @@ public static <T> BehaviorProcessor<T> createDefault(T defaultValue) {
     /**
      * Constructs a BehaviorProcessor with the given initial value.
      * @param defaultValue the initial value, not null (verified)
-     * @throws NullPointerException if {@code defaultValue} is null
+     * @throws NullPointerException if {@code defaultValue} is {@code null}
      * @since 2.0
      */
     BehaviorProcessor(T defaultValue) {

File: src/main/java/io/reactivex/rxjava3/processors/PublishProcessor.java
Patch:
@@ -71,7 +71,7 @@
  * <dl>
  *  <dt><b>Backpressure:</b></dt>
  *  <dd>The processor does not coordinate backpressure for its subscribers and implements a weaker {@code onSubscribe} which
- *  calls requests Long.MAX_VALUE from the incoming Subscriptions. This makes it possible to subscribe the {@code PublishProcessor}
+ *  calls requests {@link Long#MAX_VALUE} from the incoming Subscriptions. This makes it possible to subscribe the {@code PublishProcessor}
  *  to multiple sources (note on serialization though) unlike the standard {@code Subscriber} contract. Child subscribers, however, are not overflown but receive an
  *  {@link IllegalStateException} in case their requested amount is zero.</dd>
  *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/rxjava3/processors/ReplayProcessor.java
Patch:
@@ -66,7 +66,7 @@
  * <p>
  * This {@code ReplayProcessor} respects the individual backpressure behavior of its {@code Subscriber}s but
  * does not coordinate their request amounts towards the upstream (because there might not be any) and
- * consumes the upstream in an unbounded manner (requesting {@code Long.MAX_VALUE}).
+ * consumes the upstream in an unbounded manner (requesting {@link Long#MAX_VALUE}).
  * Note that {@code Subscriber}s receive a continuous sequence of values after they subscribed even
  * if an individual item gets delayed due to backpressure.
  * Due to concurrency requirements, a size-bounded {@code ReplayProcessor} may hold strong references to more source
@@ -104,7 +104,7 @@
  *  <dt><b>Backpressure:</b></dt>
  *  <dd>This {@code ReplayProcessor} respects the individual backpressure behavior of its {@code Subscriber}s but
  *  does not coordinate their request amounts towards the upstream (because there might not be any) and
- *  consumes the upstream in an unbounded manner (requesting {@code Long.MAX_VALUE}).
+ *  consumes the upstream in an unbounded manner (requesting {@link Long#MAX_VALUE}).
  *  Note that {@code Subscriber}s receive a continuous sequence of values after they subscribed even
  *  if an individual item gets delayed due to backpressure.</dd>
  *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/rxjava3/processors/UnicastProcessor.java
Patch:
@@ -67,7 +67,7 @@
  * {@link NullPointerException} being thrown and the processor's state is not changed.
  * <p>
  * Since a {@code UnicastProcessor} is a {@link io.reactivex.rxjava3.core.Flowable} as well as a {@link FlowableProcessor}, it
- * honors the downstream backpressure but consumes an upstream source in an unbounded manner (requesting {@code Long.MAX_VALUE}).
+ * honors the downstream backpressure but consumes an upstream source in an unbounded manner (requesting {@link Long#MAX_VALUE}).
  * <p>
  * When this {@code UnicastProcessor} is terminated via {@link #onError(Throwable)} the current or late single {@code Subscriber}
  * may receive the {@code Throwable} before any available items could be emitted. To make sure an {@code onError} event is delivered
@@ -91,7 +91,7 @@
  * <dl>
  *  <dt><b>Backpressure:</b></dt>
  *  <dd>{@code UnicastProcessor} honors the downstream backpressure but consumes an upstream source
- *  (if any) in an unbounded manner (requesting {@code Long.MAX_VALUE}).</dd>
+ *  (if any) in an unbounded manner (requesting {@link Long#MAX_VALUE}).</dd>
  *  <dt><b>Scheduler:</b></dt>
  *  <dd>{@code UnicastProcessor} does not operate by default on a particular {@link io.reactivex.rxjava3.core.Scheduler} and
  *  the single {@code Subscriber} gets notified on the thread the respective {@code onXXX} methods were invoked.</dd>

File: src/main/java/io/reactivex/rxjava3/schedulers/Timed.java
Patch:
@@ -29,11 +29,11 @@ public final class Timed<T> {
     final TimeUnit unit;
 
     /**
-     * Constructs a Timed instance with the given value and time information.
+     * Constructs a {@code Timed} instance with the given value and time information.
      * @param value the value to hold
      * @param time the time to hold
      * @param unit the time unit, not null
-     * @throws NullPointerException if unit is null
+     * @throws NullPointerException if unit is {@code null}
      */
     public Timed(@NonNull T value, long time, @NonNull TimeUnit unit) {
         this.value = value;
@@ -69,7 +69,7 @@ public long time() {
 
     /**
      * Returns the contained time value in the time unit specified.
-     * @param unit the time unt
+     * @param unit the time unit
      * @return the converted time
      */
     public long time(@NonNull TimeUnit unit) {

File: src/main/java/io/reactivex/rxjava3/subjects/BehaviorSubject.java
Patch:
@@ -213,7 +213,7 @@ public static <T> BehaviorSubject<T> createDefault(T defaultValue) {
     /**
      * Constructs a BehaviorSubject with the given initial value.
      * @param defaultValue the initial value, not null (verified)
-     * @throws NullPointerException if {@code defaultValue} is null
+     * @throws NullPointerException if {@code defaultValue} is {@code null}
      * @since 2.0
      */
     BehaviorSubject(T defaultValue) {

File: src/main/java/io/reactivex/rxjava3/subscribers/DefaultSubscriber.java
Patch:
@@ -27,7 +27,7 @@
  *
  * <p>All pre-implemented final methods are thread-safe.
  *
- * <p>The default {@link #onStart()} requests Long.MAX_VALUE by default. Override
+ * <p>The default {@link #onStart()} requests {@link Long#MAX_VALUE} by default. Override
  * the method to request a custom <em>positive</em> amount.
  *
  * <p>Note that calling {@link #request(long)} from {@link #onStart()} may trigger
@@ -85,7 +85,7 @@ public final void onSubscribe(Subscription s) {
     }
 
     /**
-     * Requests from the upstream Subscription.
+     * Requests from the upstream {@link Subscription}.
      * @param n the request amount, positive
      */
     protected final void request(long n) {
@@ -96,7 +96,7 @@ protected final void request(long n) {
     }
 
     /**
-     * Cancels the upstream's Subscription.
+     * Cancels the upstream's {@link Subscription}.
      */
     protected final void cancel() {
         Subscription s = this.upstream;

File: src/test/java/io/reactivex/rxjava3/flowable/FlowableSubscriberTest.java
Patch:
@@ -83,7 +83,7 @@ public void cancel() {
     }
 
     @Test
-    public void requestFromChainedOperator() throws Exception {
+    public void requestFromChainedOperator() throws Throwable {
         TestSubscriber<String> s = new TestSubscriber<String>(10L);
         FlowableOperator<String, String> o = new FlowableOperator<String, String>() {
             @Override
@@ -135,7 +135,7 @@ public void cancel() {
     }
 
     @Test
-    public void requestFromDecoupledOperator() throws Exception {
+    public void requestFromDecoupledOperator() throws Throwable {
         TestSubscriber<String> s = new TestSubscriber<String>(0L);
         FlowableOperator<String, String> o = new FlowableOperator<String, String>() {
             @Override
@@ -188,7 +188,7 @@ public void cancel() {
     }
 
     @Test
-    public void requestFromDecoupledOperatorThatRequestsN() throws Exception {
+    public void requestFromDecoupledOperatorThatRequestsN() throws Throwable {
         TestSubscriber<String> s = new TestSubscriber<String>(10L);
         final AtomicLong innerR = new AtomicLong();
         FlowableOperator<String, String> o = new FlowableOperator<String, String>() {

File: src/test/java/io/reactivex/rxjava3/tck/BaseTck.java
Patch:
@@ -51,8 +51,8 @@ public long maxElementsFromPublisher() {
 
     /**
      * Creates an Iterable with the specified number of elements or an infinite one if
-     * elements > Integer.MAX_VALUE.
-     * @param elements the number of elements to return, Integer.MAX_VALUE means an infinite sequence
+     * elements > {@link Integer#MAX_VALUE}.
+     * @param elements the number of elements to return, {@link Integer#MAX_VALUE} means an infinite sequence
      * @return the Iterable
      */
     protected Iterable<Long> iterate(long elements) {

File: src/test/java/io/reactivex/rxjava3/testsupport/TestHelper.java
Patch:
@@ -69,7 +69,7 @@ public enum TestHelper {
     public static final int RACE_LONG_LOOPS = 10000;
 
     /**
-     * Mocks a subscriber and prepares it to request Long.MAX_VALUE.
+     * Mocks a subscriber and prepares it to request {@link Long#MAX_VALUE}.
      * @param <T> the value type
      * @return the mocked subscriber
      */

File: src/test/java/io/reactivex/rxjava3/testsupport/TestSubscriberEx.java
Patch:
@@ -51,7 +51,7 @@ public class TestSubscriberEx<T>
     private QueueSubscription<T> qs;
 
     /**
-     * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.
+     * Constructs a non-forwarding TestSubscriber with an initial request value of {@link Long#MAX_VALUE}.
      */
     public TestSubscriberEx() {
         this(EmptySubscriber.INSTANCE, Long.MAX_VALUE);

File: src/main/java/io/reactivex/rxjava3/annotations/NonNull.java
Patch:
@@ -19,10 +19,10 @@
 import java.lang.annotation.*;
 
 /**
- * Indicates that a field/parameter/variable/return type is never null.
+ * Indicates that a field/parameter/variable/type parameter/return type is never null.
  */
 @Documented
-@Target(value = {FIELD, METHOD, PARAMETER, LOCAL_VARIABLE})
+@Target(value = {FIELD, METHOD, PARAMETER, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE})
 @Retention(value = CLASS)
 public @interface NonNull { }
 

File: src/test/java/io/reactivex/rxjava3/flowable/Burst.java
Patch:
@@ -52,11 +52,11 @@ protected void subscribeActual(final Subscriber<? super T> subscriber) {
 
     }
 
-    @SuppressWarnings("unchecked")
     public static <T> Builder<T> item(T item) {
         return items(item);
     }
 
+    @SafeVarargs
     public static <T> Builder<T> items(T... items) {
         return new Builder<T>(Arrays.asList(items));
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/Burst.java
Patch:
@@ -47,11 +47,11 @@ protected void subscribeActual(final Observer<? super T> observer) {
         }
     }
 
-    @SuppressWarnings("unchecked")
     public static <T> Builder<T> item(T item) {
         return items(item);
     }
 
+    @SafeVarargs
     public static <T> Builder<T> items(T... items) {
         return new Builder<T>(Arrays.asList(items));
     }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowSubscribeIntercept.java
Patch:
@@ -25,13 +25,13 @@
  * @param <T> the element type of the flow.
  * @since 3.0.0
  */
-final class WindowSubscribeIntercept<T> extends Flowable<T> {
+final class FlowableWindowSubscribeIntercept<T> extends Flowable<T> {
 
     final FlowableProcessor<T> window;
 
     final AtomicBoolean once;
 
-    WindowSubscribeIntercept(FlowableProcessor<T> source) {
+    FlowableWindowSubscribeIntercept(FlowableProcessor<T> source) {
         this.window = source;
         this.once = new AtomicBoolean();
     }

File: src/main/java/io/reactivex/rxjava3/core/Flowable.java
Patch:
@@ -114,7 +114,7 @@
  *         Thread.sleep(1000);
  *
  *         // the consumer might have cancelled the flow
- *         if (emitter.isCancelled() {
+ *         if (emitter.isCancelled()) {
  *             return;
  *         }
  *

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAmb.java
Patch:
@@ -36,7 +36,7 @@ public void subscribeActual(Observer<? super T> observer) {
         ObservableSource<? extends T>[] sources = this.sources;
         int count = 0;
         if (sources == null) {
-            sources = new Observable[8];
+            sources = new ObservableSource[8];
             try {
                 for (ObservableSource<? extends T> p : sourcesIterable) {
                     if (p == null) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCombineLatest.java
Patch:
@@ -48,7 +48,7 @@ public void subscribeActual(Observer<? super R> observer) {
         ObservableSource<? extends T>[] sources = this.sources;
         int count = 0;
         if (sources == null) {
-            sources = new Observable[8];
+            sources = new ObservableSource[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
                     ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableZip.java
Patch:
@@ -50,7 +50,7 @@ public void subscribeActual(Observer<? super R> observer) {
         ObservableSource<? extends T>[] sources = this.sources;
         int count = 0;
         if (sources == null) {
-            sources = new Observable[8];
+            sources = new ObservableSource[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
                     ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];

File: src/test/java/io/reactivex/rxjava3/flowable/FlowableGroupByTests.java
Patch:
@@ -100,7 +100,8 @@ public Integer apply(Integer i) {
             public Flowable<Integer> apply(GroupedFlowable<Integer, Integer> v) {
                 return v;
             }
-        }).subscribe(ts);
+        }, 20) // need to prefetch as many groups as groupBy produces to avoid MBE
+        .subscribe(ts);
 
         // Behavior change: this now counts as group abandonment because concatMap
         // doesn't subscribe to the 2nd+ emitted groups immediately

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -864,7 +864,7 @@ public String apply(String t1) {
             public Flowable<String> apply(GroupedFlowable<String, String> t1) {
                 return t1.take(1);
             }
-        })
+        }, NUM_MSG) // Must request as many groups as groupBy produces to avoid MBE
         .subscribe(new TestSubscriber<String>(subscriber));
 
         InOrder inOrder = inOrder(subscriber);

File: src/test/java/io/reactivex/rxjava3/disposables/SequentialDisposableTest.java
Patch:
@@ -78,7 +78,7 @@ public void unsubscribingTwiceDoesUnsubscribeOnce() {
     public void settingSameDisposableTwiceDoesUnsubscribeIt() {
         Disposable underlying = mock(Disposable.class);
         serialDisposable.update(underlying);
-        verifyZeroInteractions(underlying);
+        verifyNoInteractions(underlying);
         serialDisposable.update(underlying);
         verify(underlying).dispose();
     }

File: src/test/java/io/reactivex/rxjava3/disposables/SerialDisposableTests.java
Patch:
@@ -78,7 +78,7 @@ public void unsubscribingTwiceDoesUnsubscribeOnce() {
     public void settingSameDisposableTwiceDoesUnsubscribeIt() {
         Disposable underlying = mock(Disposable.class);
         serialDisposable.set(underlying);
-        verifyZeroInteractions(underlying);
+        verifyNoInteractions(underlying);
         serialDisposable.set(underlying);
         verify(underlying).dispose();
     }

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDeferTest.java
Patch:
@@ -38,7 +38,7 @@ public void defer() throws Throwable {
 
         Flowable<String> deferred = Flowable.defer(factory);
 
-        verifyZeroInteractions(factory);
+        verifyNoInteractions(factory);
 
         Subscriber<String> firstSubscriber = TestHelper.mockSubscriber();
         deferred.subscribe(firstSubscriber);

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromCallableTest.java
Patch:
@@ -47,7 +47,7 @@ public void shouldNotInvokeFuncUntilSubscription() throws Exception {
 
         Flowable<Object> fromCallableFlowable = Flowable.fromCallable(func);
 
-        verifyZeroInteractions(func);
+        verifyNoInteractions(func);
 
         fromCallableFlowable.subscribe();
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromSupplierTest.java
Patch:
@@ -47,7 +47,7 @@ public void shouldNotInvokeFuncUntilSubscription() throws Throwable {
 
         Flowable<Object> fromSupplierFlowable = Flowable.fromSupplier(func);
 
-        verifyZeroInteractions(func);
+        verifyNoInteractions(func);
 
         fromSupplierFlowable.subscribe();
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDeferTest.java
Patch:
@@ -37,7 +37,7 @@ public void defer() throws Throwable {
 
         Observable<String> deferred = Observable.defer(factory);
 
-        verifyZeroInteractions(factory);
+        verifyNoInteractions(factory);
 
         Observer<String> firstObserver = TestHelper.mockObserver();
         deferred.subscribe(firstObserver);

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromCallableTest.java
Patch:
@@ -47,7 +47,7 @@ public void shouldNotInvokeFuncUntilSubscription() throws Exception {
 
         Observable<Object> fromCallableObservable = Observable.fromCallable(func);
 
-        verifyZeroInteractions(func);
+        verifyNoInteractions(func);
 
         fromCallableObservable.subscribe();
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromSupplierTest.java
Patch:
@@ -47,7 +47,7 @@ public void shouldNotInvokeFuncUntilSubscription() throws Throwable {
 
         Observable<Object> fromSupplierObservable = Observable.fromSupplier(func);
 
-        verifyZeroInteractions(func);
+        verifyNoInteractions(func);
 
         fromSupplierObservable.subscribe();
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleFromCallableTest.java
Patch:
@@ -100,7 +100,7 @@ public void shouldNotInvokeFuncUntilSubscription() throws Exception {
 
         Single<Object> fromCallableSingle = Single.fromCallable(func);
 
-        verifyZeroInteractions(func);
+        verifyNoInteractions(func);
 
         fromCallableSingle.subscribe();
 

File: src/test/java/io/reactivex/rxjava3/internal/operators/single/SingleFromSupplierTest.java
Patch:
@@ -101,7 +101,7 @@ public void shouldNotInvokeFuncUntilSubscription() throws Throwable {
 
         Single<Object> fromSupplierSingle = Single.fromSupplier(func);
 
-        verifyZeroInteractions(func);
+        verifyNoInteractions(func);
 
         fromSupplierSingle.subscribe();
 

File: src/main/java/io/reactivex/rxjava3/disposables/ActionDisposable.java
Patch:
@@ -16,6 +16,9 @@
 import io.reactivex.rxjava3.functions.Action;
 import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
+/**
+ * A Disposable container that manages an Action instance.
+ */
 final class ActionDisposable extends ReferenceDisposable<Action> {
 
     private static final long serialVersionUID = -8219729196779211169L;

File: src/main/java/io/reactivex/rxjava3/processors/MulticastProcessor.java
Patch:
@@ -570,6 +570,7 @@ void drain() {
                 }
             }
 
+            consumed = c;
             missed = wip.addAndGet(-missed);
             if (missed == 0) {
                 break;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -154,7 +154,7 @@ public final void cancel() {
             upstream.cancel();
             worker.dispose();
 
-            if (getAndIncrement() == 0) {
+            if (!outputFused && getAndIncrement() == 0) {
                 queue.clear();
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOn.java
Patch:
@@ -145,7 +145,7 @@ public void dispose() {
                 disposed = true;
                 upstream.dispose();
                 worker.dispose();
-                if (getAndIncrement() == 0) {
+                if (!outputFused && getAndIncrement() == 0) {
                     queue.clear();
                 }
             }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -268,7 +268,7 @@ public void cancel(K key) {
             if (groupCount.decrementAndGet() == 0) {
                 upstream.cancel();
 
-                if (getAndIncrement() == 0) {
+                if (!outputFused && getAndIncrement() == 0) {
                     queue.clear();
                 }
             }
@@ -601,7 +601,6 @@ void drainFused() {
             for (;;) {
                 if (a != null) {
                     if (cancelled.get()) {
-                        q.clear();
                         return;
                     }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureBuffer.java
Patch:
@@ -150,7 +150,7 @@ public void cancel() {
                 cancelled = true;
                 upstream.cancel();
 
-                if (getAndIncrement() == 0) {
+                if (!outputFused && getAndIncrement() == 0) {
                     queue.clear();
                 }
             }

File: src/main/java/io/reactivex/rxjava3/subjects/UnicastSubject.java
Patch:
@@ -418,7 +418,6 @@ void drainFused(Observer<? super T> a) {
 
             if (disposed) {
                 downstream.lazySet(null);
-                q.clear();
                 return;
             }
             boolean d = done;
@@ -556,7 +555,9 @@ public void dispose() {
                 downstream.lazySet(null);
                 if (wip.getAndIncrement() == 0) {
                     downstream.lazySet(null);
-                    queue.clear();
+                    if (!enableOperatorFusion) {
+                        queue.clear();
+                    }
                 }
             }
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowTimed.java
Patch:
@@ -498,7 +498,7 @@ void drainLoop() {
 
                     if (isHolder) {
                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;
-                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {
+                        if (!restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {
                             w.onComplete();
                             count = 0;
                             w = UnicastProcessor.<T>create(bufferSize);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowTimed.java
Patch:
@@ -444,7 +444,7 @@ void drainLoop() {
 
                     if (isHolder) {
                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;
-                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {
+                        if (!restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {
                             w.onComplete();
                             count = 0;
                             w = UnicastSubject.create(bufferSize);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimed.java
Patch:
@@ -139,6 +139,7 @@ void drain() {
             final Observer<? super T> a = downstream;
             final SpscLinkedArrayQueue<Object> q = queue;
             final boolean delayError = this.delayError;
+            final long timestampLimit = scheduler.now(unit) - time;
 
             for (;;) {
                 if (cancelled) {
@@ -171,7 +172,7 @@ void drain() {
                 @SuppressWarnings("unchecked")
                 T o = (T)q.poll();
 
-                if ((Long)ts < scheduler.now(unit) - time) {
+                if ((Long)ts < timestampLimit) {
                     continue;
                 }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableCreate.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Cancellable;
 import io.reactivex.rxjava3.internal.disposables.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class CompletableCreate extends Completable {
@@ -81,7 +82,7 @@ public void onError(Throwable t) {
         @Override
         public boolean tryOnError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+                t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -25,6 +25,7 @@
 import io.reactivex.rxjava3.internal.fuseable.QueueFuseable;
 import io.reactivex.rxjava3.internal.subscribers.BasicFuseableSubscriber;
 import io.reactivex.rxjava3.internal.subscriptions.EmptySubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class FlowableDistinct<T, K> extends AbstractFlowableWithUpstream<T, T> {
@@ -44,7 +45,7 @@ protected void subscribeActual(Subscriber<? super T> subscriber) {
         Collection<? super K> collection;
 
         try {
-            collection = ObjectHelper.requireNonNull(collectionSupplier.get(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+            collection = ExceptionHelper.nullCheck(collectionSupplier.get(), "The collectionSupplier returned a null Collection.");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptySubscription.error(ex, subscriber);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableError.java
Patch:
@@ -18,8 +18,8 @@
 import io.reactivex.rxjava3.core.Flowable;
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.subscriptions.EmptySubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class FlowableError<T> extends Flowable<T> {
     final Supplier<? extends Throwable> errorSupplier;
@@ -31,7 +31,7 @@ public FlowableError(Supplier<? extends Throwable> errorSupplier) {
     public void subscribeActual(Subscriber<? super T> s) {
         Throwable error;
         try {
-            error = ObjectHelper.requireNonNull(errorSupplier.get(), "Callable returned null throwable. Null values are generally not allowed in 2.x operators and sources.");
+            error = ExceptionHelper.nullCheck(errorSupplier.get(), "Callable returned a null Throwable.");
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
Patch:
@@ -133,7 +133,7 @@ public void onNext(T value) {
 
         @Override
         public void onError(Throwable e) {
-            if (errors.addThrowable(e)) {
+            if (errors.tryAddThrowableOrReport(e)) {
                 if (delayErrors) {
                     if (decrementAndGet() == 0) {
                         errors.tryTerminateConsumer(downstream);
@@ -150,8 +150,6 @@ public void onError(Throwable e) {
                         errors.tryTerminateConsumer(downstream);
                     }
                 }
-            } else {
-                RxJavaPlugins.onError(e);
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromFuture.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.rxjava3.core.Flowable;
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.internal.subscriptions.DeferredScalarSubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class FlowableFromFuture<T> extends Flowable<T> {
     final Future<? extends T> future;
@@ -48,7 +49,7 @@ public void subscribeActual(Subscriber<? super T> s) {
             return;
         }
         if (v == null) {
-            s.onError(new NullPointerException("The future returned null"));
+            s.onError(ExceptionHelper.createNullPointerException("The future returned a null value."));
         } else {
             deferred.complete(v);
         }

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGenerate.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.subscriptions.*;
-import io.reactivex.rxjava3.internal.util.BackpressureHelper;
+import io.reactivex.rxjava3.internal.util.*;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class FlowableGenerate<T, S> extends Flowable<T> {
@@ -167,7 +167,7 @@ public void onNext(T t) {
                     onError(new IllegalStateException("onNext already called in this generate turn"));
                 } else {
                     if (t == null) {
-                        onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
+                        onError(ExceptionHelper.createNullPointerException("onNext called with a null value."));
                     } else {
                         hasNext = true;
                         downstream.onNext(t);
@@ -182,7 +182,7 @@ public void onError(Throwable t) {
                 RxJavaPlugins.onError(t);
             } else {
                 if (t == null) {
-                    t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+                    t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
                 }
                 terminate = true;
                 downstream.onError(t);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -24,7 +24,6 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.flowables.GroupedFlowable;
 import io.reactivex.rxjava3.functions.*;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.rxjava3.internal.subscriptions.*;
 import io.reactivex.rxjava3.internal.util.*;
@@ -165,7 +164,7 @@ public void onNext(T t) {
 
             V v;
             try {
-                v = ObjectHelper.requireNonNull(valueSelector.apply(t), "The valueSelector returned null");
+                v = ExceptionHelper.nullCheck(valueSelector.apply(t), "The valueSelector returned a null value.");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 upstream.cancel();

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -24,7 +24,6 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.flowables.ConnectableFlowable;
 import io.reactivex.rxjava3.functions.*;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.fuseable.HasUpstreamPublisher;
 import io.reactivex.rxjava3.internal.subscribers.SubscriberResourceWrapper;
 import io.reactivex.rxjava3.internal.subscriptions.*;
@@ -1112,7 +1111,7 @@ static final class MulticastFlowable<R, U> extends Flowable<R> {
         protected void subscribeActual(Subscriber<? super R> child) {
             ConnectableFlowable<U> cf;
             try {
-                cf = ObjectHelper.requireNonNull(connectableFactory.get(), "The connectableFactory returned null");
+                cf = ExceptionHelper.nullCheck(connectableFactory.get(), "The connectableFactory returned a null ConnectableFlowable.");
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 EmptySubscription.error(e, child);
@@ -1121,7 +1120,7 @@ protected void subscribeActual(Subscriber<? super R> child) {
 
             Publisher<R> observable;
             try {
-                observable = ObjectHelper.requireNonNull(selector.apply(cf), "The selector returned a null Publisher");
+                observable = ExceptionHelper.nullCheck(selector.apply(cf), "The selector returned a null Publisher.");
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 EmptySubscription.error(e, child);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -134,7 +134,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable t) {
-            if (!done && errors.addThrowable(t)) {
+            if (!done && errors.tryAddThrowable(t)) {
                 if (!delayErrors) {
                     disposeInner();
                 }
@@ -265,7 +265,7 @@ void drain() {
                         } catch (Throwable ex) {
                             Exceptions.throwIfFatal(ex);
                             inner.cancel();
-                            errors.addThrowable(ex);
+                            errors.tryAddThrowableOrReport(ex);
                             d = true;
                             v = null;
                         }
@@ -392,7 +392,7 @@ public void onNext(R t) {
         @Override
         public void onError(Throwable t) {
             SwitchMapSubscriber<T, R> p = parent;
-            if (index == p.unique && p.errors.addThrowable(t)) {
+            if (index == p.unique && p.errors.tryAddThrowable(t)) {
                 if (!p.delayErrors) {
                     p.upstream.cancel();
                     p.done = true;

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToList.java
Patch:
@@ -20,8 +20,8 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.subscriptions.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class FlowableToList<T, U extends Collection<? super T>> extends AbstractFlowableWithUpstream<T, U> {
     final Supplier<U> collectionSupplier;
@@ -35,7 +35,7 @@ public FlowableToList(Flowable<T> source, Supplier<U> collectionSupplier) {
     protected void subscribeActual(Subscriber<? super U> s) {
         U coll;
         try {
-            coll = ObjectHelper.requireNonNull(collectionSupplier.get(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+            coll = ExceptionHelper.nullCheck(collectionSupplier.get(), "The collectionSupplier returned a null Collection.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptySubscription.error(e, s);

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToListSingle.java
Patch:
@@ -22,10 +22,9 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.fuseable.FuseToFlowable;
 import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
-import io.reactivex.rxjava3.internal.util.ArrayListSupplier;
+import io.reactivex.rxjava3.internal.util.*;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class FlowableToListSingle<T, U extends Collection<? super T>> extends Single<U> implements FuseToFlowable<U> {
@@ -48,7 +47,7 @@ public FlowableToListSingle(Flowable<T> source, Supplier<U> collectionSupplier)
     protected void subscribeActual(SingleObserver<? super U> observer) {
         U coll;
         try {
-            coll = ObjectHelper.requireNonNull(collectionSupplier.get(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+            coll = ExceptionHelper.nullCheck(collectionSupplier.get(), "The collectionSupplier returned a null Collection.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptyDisposable.error(e, observer);

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCreate.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Cancellable;
 import io.reactivex.rxjava3.internal.disposables.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -68,7 +69,7 @@ public void onSuccess(T value) {
                 if (d != DisposableHelper.DISPOSED) {
                     try {
                         if (value == null) {
-                            downstream.onError(new NullPointerException("onSuccess called with null. Null values are generally not allowed in 2.x operators and sources."));
+                            downstream.onError(ExceptionHelper.createNullPointerException("onSuccess called with a null value."));
                         } else {
                             downstream.onSuccess(value);
                         }
@@ -91,7 +92,7 @@ public void onError(Throwable t) {
         @Override
         public boolean tryOnError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+                t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeErrorCallable.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.rxjava3.disposables.Disposables;
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 /**
  * Signals a Throwable returned by a Supplier.
@@ -38,7 +38,7 @@ protected void subscribeActual(MaybeObserver<? super T> observer) {
         Throwable ex;
 
         try {
-            ex = ObjectHelper.requireNonNull(errorSupplier.get(), "Supplier returned null throwable. Null values are generally not allowed in 2.x operators and sources.");
+            ex = ExceptionHelper.nullCheck(errorSupplier.get(), "Supplier returned a null Throwable.");
         } catch (Throwable ex1) {
             Exceptions.throwIfFatal(ex1);
             ex = ex1;

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBuffer.java
Patch:
@@ -23,6 +23,7 @@
 import io.reactivex.rxjava3.functions.Supplier;
 import io.reactivex.rxjava3.internal.disposables.*;
 import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class ObservableBuffer<T, U extends Collection<? super T>> extends AbstractObservableWithUpstream<T, U> {
     final int count;
@@ -184,7 +185,7 @@ public void onNext(T t) {
                 U b;
 
                 try {
-                    b = ObjectHelper.requireNonNull(bufferSupplier.get(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+                    b = ExceptionHelper.nullCheck(bufferSupplier.get(), "The bufferSupplier returned a null Collection.");
                 } catch (Throwable e) {
                     buffers.clear();
                     upstream.dispose();

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
 import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.observers.BasicFuseableObserver;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class ObservableDistinct<T, K> extends AbstractObservableWithUpstream<T, T> {
@@ -41,7 +42,7 @@ protected void subscribeActual(Observer<? super T> observer) {
         Collection<? super K> collection;
 
         try {
-            collection = ObjectHelper.requireNonNull(collectionSupplier.get(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+            collection = ExceptionHelper.nullCheck(collectionSupplier.get(), "The collectionSupplier returned a null Collection.");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptyDisposable.error(ex, observer);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableError.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class ObservableError<T> extends Observable<T> {
     final Supplier<? extends Throwable> errorSupplier;
@@ -29,7 +29,7 @@ public ObservableError(Supplier<? extends Throwable> errorSupplier) {
     public void subscribeActual(Observer<? super T> observer) {
         Throwable error;
         try {
-            error = ObjectHelper.requireNonNull(errorSupplier.get(), "Supplier returned null throwable. Null values are generally not allowed in 2.x operators and sources.");
+            error = ExceptionHelper.nullCheck(errorSupplier.get(), "Supplier returned a null Throwable.");
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapCompletableCompletable.java
Patch:
@@ -113,7 +113,7 @@ public void onNext(T value) {
 
         @Override
         public void onError(Throwable e) {
-            if (errors.addThrowable(e)) {
+            if (errors.tryAddThrowableOrReport(e)) {
                 if (delayErrors) {
                     if (decrementAndGet() == 0) {
                         errors.tryTerminateConsumer(downstream);
@@ -126,8 +126,6 @@ public void onError(Throwable e) {
                         errors.tryTerminateConsumer(downstream);
                     }
                 }
-            } else {
-                RxJavaPlugins.onError(e);
             }
         }
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromCallable.java
Patch:
@@ -18,8 +18,8 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.observers.DeferredScalarDisposable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -43,7 +43,7 @@ public void subscribeActual(Observer<? super T> observer) {
         }
         T value;
         try {
-            value = ObjectHelper.requireNonNull(callable.call(), "Callable returned null");
+            value = ExceptionHelper.nullCheck(callable.call(), "Callable returned a null value.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             if (!d.isDisposed()) {
@@ -58,6 +58,6 @@ public void subscribeActual(Observer<? super T> observer) {
 
     @Override
     public T get() throws Throwable {
-        return ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");
+        return ExceptionHelper.nullCheck(callable.call(), "The Callable returned a null value.");
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromFuture.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.exceptions.Exceptions;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.observers.DeferredScalarDisposable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class ObservableFromFuture<T> extends Observable<T> {
     final Future<? extends T> future;
@@ -38,7 +38,7 @@ public void subscribeActual(Observer<? super T> observer) {
         if (!d.isDisposed()) {
             T v;
             try {
-                v = ObjectHelper.requireNonNull(unit != null ? future.get(timeout, unit) : future.get(), "Future returned null");
+                v = ExceptionHelper.nullCheck(unit != null ? future.get(timeout, unit) : future.get(), "Future returned a null value.");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 if (!d.isDisposed()) {

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromSupplier.java
Patch:
@@ -16,8 +16,8 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.observers.DeferredScalarDisposable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -42,7 +42,7 @@ public void subscribeActual(Observer<? super T> observer) {
         }
         T value;
         try {
-            value = ObjectHelper.requireNonNull(supplier.get(), "Supplier returned null");
+            value = ExceptionHelper.nullCheck(supplier.get(), "Supplier returned a null value.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             if (!d.isDisposed()) {
@@ -57,6 +57,6 @@ public void subscribeActual(Observer<? super T> observer) {
 
     @Override
     public T get() throws Throwable {
-        return ObjectHelper.requireNonNull(supplier.get(), "The supplier returned a null value");
+        return ExceptionHelper.nullCheck(supplier.get(), "The supplier returned a null value.");
     }
 }

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGenerate.java
Patch:
@@ -18,6 +18,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class ObservableGenerate<T, S> extends Observable<T> {
@@ -141,7 +142,7 @@ public void onNext(T t) {
                     onError(new IllegalStateException("onNext already called in this generate turn"));
                 } else {
                     if (t == null) {
-                        onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
+                        onError(ExceptionHelper.createNullPointerException("onNext called with a null value."));
                     } else {
                         hasNext = true;
                         downstream.onNext(t);
@@ -156,7 +157,7 @@ public void onError(Throwable t) {
                 RxJavaPlugins.onError(t);
             } else {
                 if (t == null) {
-                    t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+                    t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
                 }
                 terminate = true;
                 downstream.onError(t);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -132,7 +132,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable t) {
-            if (!done && errors.addThrowable(t)) {
+            if (!done && errors.tryAddThrowable(t)) {
                 if (!delayErrors) {
                     disposeInner();
                 }
@@ -272,7 +272,7 @@ void drain() {
                                 v = q.poll();
                             } catch (Throwable ex) {
                                 Exceptions.throwIfFatal(ex);
-                                errors.addThrowable(ex);
+                                errors.tryAddThrowableOrReport(ex);
                                 active.compareAndSet(inner, null);
                                 if (!delayErrors) {
                                     disposeInner();
@@ -313,7 +313,7 @@ void drain() {
         }
 
         void innerError(SwitchMapInnerObserver<T, R> inner, Throwable ex) {
-            if (inner.index == unique && errors.addThrowable(ex)) {
+            if (inner.index == unique && errors.tryAddThrowable(ex)) {
                 if (!delayErrors) {
                     upstream.dispose();
                     done = true;

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableToList.java
Patch:
@@ -20,7 +20,8 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
 import io.reactivex.rxjava3.internal.disposables.*;
-import io.reactivex.rxjava3.internal.functions.*;
+import io.reactivex.rxjava3.internal.functions.Functions;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class ObservableToList<T, U extends Collection<? super T>>
 extends AbstractObservableWithUpstream<T, U> {
@@ -42,7 +43,7 @@ public ObservableToList(ObservableSource<T> source, Supplier<U> collectionSuppli
     public void subscribeActual(Observer<? super U> t) {
         U coll;
         try {
-            coll = ObjectHelper.requireNonNull(collectionSupplier.get(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+            coll = ExceptionHelper.nullCheck(collectionSupplier.get(), "The collectionSupplier returned a null Collection.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptyDisposable.error(e, t);

File: src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableToListSingle.java
Patch:
@@ -20,8 +20,9 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
 import io.reactivex.rxjava3.internal.disposables.*;
-import io.reactivex.rxjava3.internal.functions.*;
+import io.reactivex.rxjava3.internal.functions.Functions;
 import io.reactivex.rxjava3.internal.fuseable.FuseToObservable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class ObservableToListSingle<T, U extends Collection<? super T>>
@@ -46,7 +47,7 @@ public ObservableToListSingle(ObservableSource<T> source, Supplier<U> collection
     public void subscribeActual(SingleObserver<? super U> t) {
         U coll;
         try {
-            coll = ObjectHelper.requireNonNull(collectionSupplier.get(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+            coll = ExceptionHelper.nullCheck(collectionSupplier.get(), "The collectionSupplier returned a null Collection.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptyDisposable.error(e, t);

File: src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleCreate.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Cancellable;
 import io.reactivex.rxjava3.internal.disposables.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 public final class SingleCreate<T> extends Single<T> {
@@ -62,7 +63,7 @@ public void onSuccess(T value) {
                 if (d != DisposableHelper.DISPOSED) {
                     try {
                         if (value == null) {
-                            downstream.onError(new NullPointerException("onSuccess called with null. Null values are generally not allowed in 2.x operators and sources."));
+                            downstream.onError(ExceptionHelper.createNullPointerException("onSuccess called with a null value."));
                         } else {
                             downstream.onSuccess(value);
                         }
@@ -85,7 +86,7 @@ public void onError(Throwable t) {
         @Override
         public boolean tryOnError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+                t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleError.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.rxjava3.exceptions.Exceptions;
 import io.reactivex.rxjava3.functions.Supplier;
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public final class SingleError<T> extends Single<T> {
 
@@ -32,7 +32,7 @@ protected void subscribeActual(SingleObserver<? super T> observer) {
         Throwable error;
 
         try {
-            error = ObjectHelper.requireNonNull(errorSupplier.get(), "Supplier returned null throwable. Null values are generally not allowed in 2.x operators and sources.");
+            error = ExceptionHelper.nullCheck(errorSupplier.get(), "Supplier returned a null Throwable.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             error = e;

File: src/main/java/io/reactivex/rxjava3/observers/SafeObserver.java
Patch:
@@ -17,6 +17,7 @@
 import io.reactivex.rxjava3.disposables.Disposable;
 import io.reactivex.rxjava3.exceptions.*;
 import io.reactivex.rxjava3.internal.disposables.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -84,7 +85,7 @@ public void onNext(@NonNull T t) {
         }
 
         if (t == null) {
-            Throwable ex = new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+            Throwable ex = ExceptionHelper.createNullPointerException("onNext called with a null value.");
             try {
                 upstream.dispose();
             } catch (Throwable e1) {
@@ -163,7 +164,7 @@ public void onError(@NonNull Throwable t) {
         }
 
         if (t == null) {
-            t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+            t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
         }
 
         try {

File: src/main/java/io/reactivex/rxjava3/observers/SerializedObserver.java
Patch:
@@ -90,7 +90,7 @@ public void onNext(@NonNull T t) {
         }
         if (t == null) {
             upstream.dispose();
-            onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
+            onError(ExceptionHelper.createNullPointerException("onNext called with a null value."));
             return;
         }
         synchronized (this) {

File: src/main/java/io/reactivex/rxjava3/plugins/RxJavaPlugins.java
Patch:
@@ -361,7 +361,7 @@ public static void onError(@NonNull Throwable error) {
         Consumer<? super Throwable> f = errorHandler;
 
         if (error == null) {
-            error = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+            error = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
         } else {
             if (!isBug(error)) {
                 error = new UndeliverableException(error);

File: src/main/java/io/reactivex/rxjava3/processors/AsyncProcessor.java
Patch:
@@ -17,8 +17,8 @@
 import org.reactivestreams.*;
 
 import io.reactivex.rxjava3.annotations.*;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.subscriptions.DeferredScalarSubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -161,7 +161,7 @@ public void onSubscribe(Subscription s) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
         if (subscribers.get() == TERMINATED) {
             return;
         }
@@ -171,7 +171,7 @@ public void onNext(T t) {
     @SuppressWarnings("unchecked")
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
         if (subscribers.get() == TERMINATED) {
             RxJavaPlugins.onError(t);
             return;

File: src/main/java/io/reactivex/rxjava3/processors/ReplayProcessor.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.rxjava3.core.Scheduler;
 import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
-import io.reactivex.rxjava3.internal.util.BackpressureHelper;
+import io.reactivex.rxjava3.internal.util.*;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -353,7 +353,7 @@ public void onSubscribe(Subscription s) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
 
         if (done) {
             return;
@@ -370,7 +370,7 @@ public void onNext(T t) {
     @SuppressWarnings("unchecked")
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
 
         if (done) {
             RxJavaPlugins.onError(t);

File: src/main/java/io/reactivex/rxjava3/processors/UnicastProcessor.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.rxjava3.internal.fuseable.QueueSubscription;
 import io.reactivex.rxjava3.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.rxjava3.internal.subscriptions.*;
-import io.reactivex.rxjava3.internal.util.BackpressureHelper;
+import io.reactivex.rxjava3.internal.util.*;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -446,7 +446,7 @@ public void onSubscribe(Subscription s) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
 
         if (done || cancelled) {
             return;
@@ -458,7 +458,7 @@ public void onNext(T t) {
 
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
 
         if (done || cancelled) {
             RxJavaPlugins.onError(t);

File: src/main/java/io/reactivex/rxjava3/subjects/AsyncSubject.java
Patch:
@@ -18,8 +18,8 @@
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.core.Observer;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 import io.reactivex.rxjava3.internal.observers.DeferredScalarDisposable;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -150,7 +150,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
         if (subscribers.get() == TERMINATED) {
             return;
         }
@@ -160,7 +160,7 @@ public void onNext(T t) {
     @SuppressWarnings("unchecked")
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
         if (subscribers.get() == TERMINATED) {
             RxJavaPlugins.onError(t);
             return;

File: src/main/java/io/reactivex/rxjava3/subjects/BehaviorSubject.java
Patch:
@@ -250,7 +250,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
 
         if (terminalEvent.get() != null) {
             return;
@@ -264,7 +264,7 @@ public void onNext(T t) {
 
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
         if (!terminalEvent.compareAndSet(null, t)) {
             RxJavaPlugins.onError(t);
             return;

File: src/main/java/io/reactivex/rxjava3/subjects/CompletableSubject.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -119,7 +119,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onError(Throwable e) {
-        ObjectHelper.requireNonNull(e, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(e, "onError called with a null Throwable.");
         if (once.compareAndSet(false, true)) {
             this.error = e;
             for (CompletableDisposable md : observers.getAndSet(TERMINATED)) {

File: src/main/java/io/reactivex/rxjava3/subjects/MaybeSubject.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -150,7 +150,7 @@ public void onSubscribe(Disposable d) {
     @SuppressWarnings("unchecked")
     @Override
     public void onSuccess(T value) {
-        ObjectHelper.requireNonNull(value, "onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(value, "onSuccess called with a null value.");
         if (once.compareAndSet(false, true)) {
             this.value = value;
             for (MaybeDisposable<T> md : observers.getAndSet(TERMINATED)) {
@@ -162,7 +162,7 @@ public void onSuccess(T value) {
     @SuppressWarnings("unchecked")
     @Override
     public void onError(Throwable e) {
-        ObjectHelper.requireNonNull(e, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(e, "onError called with a null Throwable.");
         if (once.compareAndSet(false, true)) {
             this.error = e;
             for (MaybeDisposable<T> md : observers.getAndSet(TERMINATED)) {

File: src/main/java/io/reactivex/rxjava3/subjects/PublishSubject.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.core.Observer;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -221,7 +221,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
         for (PublishDisposable<T> pd : subscribers.get()) {
             pd.onNext(t);
         }
@@ -230,7 +230,7 @@ public void onNext(T t) {
     @SuppressWarnings("unchecked")
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
         if (subscribers.get() == TERMINATED) {
             RxJavaPlugins.onError(t);
             return;

File: src/main/java/io/reactivex/rxjava3/subjects/ReplaySubject.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.rxjava3.core.Scheduler;
 import io.reactivex.rxjava3.disposables.Disposable;
 import io.reactivex.rxjava3.internal.functions.ObjectHelper;
-import io.reactivex.rxjava3.internal.util.NotificationLite;
+import io.reactivex.rxjava3.internal.util.*;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -340,7 +340,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
         if (done) {
             return;
         }
@@ -355,7 +355,7 @@ public void onNext(T t) {
 
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
         if (done) {
             RxJavaPlugins.onError(t);
             return;

File: src/main/java/io/reactivex/rxjava3/subjects/SingleSubject.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.Disposable;
-import io.reactivex.rxjava3.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -134,7 +134,7 @@ public void onSubscribe(@NonNull Disposable d) {
     @SuppressWarnings("unchecked")
     @Override
     public void onSuccess(@NonNull T value) {
-        ObjectHelper.requireNonNull(value, "onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(value, "onSuccess called with a null value.");
         if (once.compareAndSet(false, true)) {
             this.value = value;
             for (SingleDisposable<T> md : observers.getAndSet(TERMINATED)) {
@@ -146,7 +146,7 @@ public void onSuccess(@NonNull T value) {
     @SuppressWarnings("unchecked")
     @Override
     public void onError(@NonNull Throwable e) {
-        ObjectHelper.requireNonNull(e, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(e, "onError called with a null Throwable.");
         if (once.compareAndSet(false, true)) {
             this.error = e;
             for (SingleDisposable<T> md : observers.getAndSet(TERMINATED)) {

File: src/main/java/io/reactivex/rxjava3/subjects/UnicastSubject.java
Patch:
@@ -23,6 +23,7 @@
 import io.reactivex.rxjava3.internal.fuseable.SimpleQueue;
 import io.reactivex.rxjava3.internal.observers.BasicIntQueueDisposable;
 import io.reactivex.rxjava3.internal.queue.SpscLinkedArrayQueue;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -325,7 +326,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onNext(T t) {
-        ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onNext called with a null value.");
         if (done || disposed) {
             return;
         }
@@ -335,7 +336,7 @@ public void onNext(T t) {
 
     @Override
     public void onError(Throwable t) {
-        ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ExceptionHelper.nullCheck(t, "onError called with a null Throwable.");
         if (done || disposed) {
             RxJavaPlugins.onError(t);
             return;

File: src/main/java/io/reactivex/rxjava3/subscribers/SafeSubscriber.java
Patch:
@@ -17,6 +17,7 @@
 import io.reactivex.rxjava3.core.FlowableSubscriber;
 import io.reactivex.rxjava3.exceptions.*;
 import io.reactivex.rxjava3.internal.subscriptions.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 
 /**
@@ -74,7 +75,7 @@ public void onNext(T t) {
         }
 
         if (t == null) {
-            Throwable ex = new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+            Throwable ex = ExceptionHelper.createNullPointerException("onNext called with a null Throwable.");
             try {
                 upstream.cancel();
             } catch (Throwable e1) {
@@ -152,7 +153,7 @@ public void onError(Throwable t) {
         }
 
         if (t == null) {
-            t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
+            t = ExceptionHelper.createNullPointerException("onError called with a null Throwable.");
         }
 
         try {

File: src/main/java/io/reactivex/rxjava3/subscribers/SerializedSubscriber.java
Patch:
@@ -78,7 +78,7 @@ public void onNext(T t) {
         }
         if (t == null) {
             upstream.cancel();
-            onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
+            onError(ExceptionHelper.createNullPointerException("onNext called with a null value."));
             return;
         }
         synchronized (this) {

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDistinctTest.java
Patch:
@@ -29,6 +29,7 @@
 import io.reactivex.rxjava3.internal.functions.Functions;
 import io.reactivex.rxjava3.internal.fuseable.*;
 import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 import io.reactivex.rxjava3.processors.UnicastProcessor;
 import io.reactivex.rxjava3.testsupport.*;
@@ -193,7 +194,7 @@ public Collection<Object> get() throws Exception {
         })
         .to(TestHelper.<Integer>testConsumer())
         .assertFailure(NullPointerException.class)
-        .assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+        .assertErrorMessage(ExceptionHelper.nullWarning("The collectionSupplier returned a null Collection."));
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToListTest.java
Patch:
@@ -26,6 +26,7 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.exceptions.TestException;
 import io.reactivex.rxjava3.functions.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.observers.TestObserver;
 import io.reactivex.rxjava3.processors.PublishProcessor;
 import io.reactivex.rxjava3.subscribers.TestSubscriber;
@@ -244,7 +245,7 @@ public Collection<Integer> get() throws Exception {
         .toFlowable()
         .to(TestHelper.<Collection<Integer>>testConsumer())
         .assertFailure(NullPointerException.class)
-        .assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+        .assertErrorMessage(ExceptionHelper.nullWarning("The collectionSupplier returned a null Collection."));
     }
 
     @SuppressWarnings("unchecked")
@@ -273,7 +274,7 @@ public Collection<Integer> get() throws Exception {
         })
         .to(TestHelper.<Collection<Integer>>testConsumer())
         .assertFailure(NullPointerException.class)
-        .assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+        .assertErrorMessage(ExceptionHelper.nullWarning("The collectionSupplier returned a null Collection."));
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDistinctTest.java
Patch:
@@ -30,6 +30,7 @@
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.functions.Functions;
 import io.reactivex.rxjava3.internal.fuseable.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 import io.reactivex.rxjava3.subjects.UnicastSubject;
 import io.reactivex.rxjava3.testsupport.*;
@@ -194,7 +195,7 @@ public Collection<Object> get() throws Exception {
         })
         .to(TestHelper.<Integer>testConsumer())
         .assertFailure(NullPointerException.class)
-        .assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+        .assertErrorMessage(ExceptionHelper.nullWarning("The collectionSupplier returned a null Collection."));
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableToListTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.reactivex.rxjava3.core.Observer;
 import io.reactivex.rxjava3.exceptions.TestException;
 import io.reactivex.rxjava3.functions.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.testsupport.TestHelper;
 
 public class ObservableToListTest extends RxJavaTest {
@@ -216,7 +217,7 @@ public Collection<Integer> get() throws Exception {
         .toObservable()
         .to(TestHelper.<Collection<Integer>>testConsumer())
         .assertFailure(NullPointerException.class)
-        .assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+        .assertErrorMessage(ExceptionHelper.nullWarning("The collectionSupplier returned a null Collection."));
     }
 
     @SuppressWarnings("unchecked")
@@ -245,7 +246,7 @@ public Collection<Integer> get() throws Exception {
         })
         .to(TestHelper.<Collection<Integer>>testConsumer())
         .assertFailure(NullPointerException.class)
-        .assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
+        .assertErrorMessage(ExceptionHelper.nullWarning("The collectionSupplier returned a null Collection."));
     }
 
     @Test

File: src/test/java/io/reactivex/rxjava3/observers/SerializedObserverTest.java
Patch:
@@ -26,6 +26,7 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.*;
 import io.reactivex.rxjava3.exceptions.TestException;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 import io.reactivex.rxjava3.schedulers.Schedulers;
 import io.reactivex.rxjava3.testsupport.*;
@@ -1139,6 +1140,6 @@ public void nullOnNext() {
 
         so.onNext(null);
 
-        to.assertFailureAndMessage(NullPointerException.class, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        to.assertFailureAndMessage(NullPointerException.class, ExceptionHelper.nullWarning("onNext called with a null value."));
     }
 }

File: src/test/java/io/reactivex/rxjava3/plugins/RxJavaPluginsTest.java
Patch:
@@ -45,6 +45,7 @@
 import io.reactivex.rxjava3.internal.operators.single.SingleJust;
 import io.reactivex.rxjava3.internal.schedulers.ImmediateThinScheduler;
 import io.reactivex.rxjava3.internal.subscriptions.ScalarSubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.observables.ConnectableObservable;
 import io.reactivex.rxjava3.parallel.ParallelFlowable;
 import io.reactivex.rxjava3.schedulers.Schedulers;
@@ -1534,7 +1535,7 @@ public void accept(final Throwable throwable) throws Exception {
             RxJavaPlugins.onError(null);
 
             final Throwable throwable = t.get();
-            assertEquals("onError called with null. Null values are generally not allowed in 2.x operators and sources.", throwable.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onError called with a null Throwable."), throwable.getMessage());
             assertTrue(throwable instanceof NullPointerException);
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/rxjava3/processors/FlowableProcessorTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 
 import io.reactivex.rxjava3.core.RxJavaTest;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public abstract class FlowableProcessorTest<T>  extends RxJavaTest {
 
@@ -31,7 +32,7 @@ public void onNextNull() {
             p.onNext(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onNext called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onNext called with a null value."), ex.getMessage());
         }
 
         p.test().assertEmpty().cancel();
@@ -45,7 +46,7 @@ public void onErrorNull() {
             p.onError(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onError called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onError called with a null Throwable."), ex.getMessage());
         }
 
         p.test().assertEmpty().cancel();

File: src/test/java/io/reactivex/rxjava3/subjects/CompletableSubjectTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.observers.TestObserver;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 import io.reactivex.rxjava3.testsupport.TestHelper;
@@ -129,7 +130,7 @@ public void nullThrowable() {
             cs.onError(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onError called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onError called with a null Throwable."), ex.getMessage());
         }
 
         cs.test().assertEmpty().dispose();

File: src/test/java/io/reactivex/rxjava3/subjects/SingleSubjectTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.observers.TestObserver;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 import io.reactivex.rxjava3.testsupport.TestHelper;
@@ -135,7 +136,7 @@ public void nullValue() {
             ss.onSuccess(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onSuccess called with a null value."), ex.getMessage());
         }
 
         ss.test().assertEmpty().dispose();
@@ -149,7 +150,7 @@ public void nullThrowable() {
             ss.onError(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onError called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onError called with a null Throwable."), ex.getMessage());
         }
 
         ss.test().assertEmpty().dispose();

File: src/test/java/io/reactivex/rxjava3/subjects/SubjectTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 
 import io.reactivex.rxjava3.core.RxJavaTest;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 public abstract class SubjectTest<T> extends RxJavaTest {
 
@@ -31,7 +32,7 @@ public void onNextNull() {
             p.onNext(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onNext called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onNext called with a null value."), ex.getMessage());
         }
 
         p.test().assertEmpty().dispose();
@@ -45,7 +46,7 @@ public void onErrorNull() {
             p.onError(null);
             fail("No NullPointerException thrown");
         } catch (NullPointerException ex) {
-            assertEquals("onError called with null. Null values are generally not allowed in 2.x operators and sources.", ex.getMessage());
+            assertEquals(ExceptionHelper.nullWarning("onError called with a null Throwable."), ex.getMessage());
         }
 
         p.test().assertEmpty().dispose();

File: src/test/java/io/reactivex/rxjava3/subscribers/SerializedSubscriberTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.exceptions.TestException;
 import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 import io.reactivex.rxjava3.plugins.RxJavaPlugins;
 import io.reactivex.rxjava3.schedulers.Schedulers;
 import io.reactivex.rxjava3.testsupport.*;
@@ -1131,6 +1132,6 @@ public void nullOnNext() {
 
         so.onNext(null);
 
-        ts.assertFailureAndMessage(NullPointerException.class, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
+        ts.assertFailureAndMessage(NullPointerException.class, ExceptionHelper.nullWarning("onNext called with a null value."));
     }
 }

File: src/test/java/io/reactivex/rxjava3/tck/CombineLatestArrayDelayErrorTckTest.java
Patch:
@@ -27,14 +27,13 @@ public class CombineLatestArrayDelayErrorTckTest extends BaseTck<Long> {
     public Publisher<Long> createPublisher(long elements) {
         return
             Flowable.combineLatestDelayError(
+                new Publisher[] { Flowable.just(1L), Flowable.fromIterable(iterate(elements)) },
                 new Function<Object[], Long>() {
                     @Override
                     public Long apply(Object[] a) throws Exception {
                         return (Long)a[0];
                     }
-                },
-                Flowable.just(1L),
-                Flowable.fromIterable(iterate(elements))
+                }
             )
         ;
     }

File: src/test/java/io/reactivex/rxjava3/tck/CombineLatestArrayTckTest.java
Patch:
@@ -27,14 +27,13 @@ public class CombineLatestArrayTckTest extends BaseTck<Long> {
     public Publisher<Long> createPublisher(long elements) {
         return
             Flowable.combineLatest(
+                new Publisher[] { Flowable.just(1L), Flowable.fromIterable(iterate(elements)) },
                 new Function<Object[], Long>() {
                     @Override
                     public Long apply(Object[] a) throws Exception {
                         return (Long)a[0];
                     }
-                },
-                Flowable.just(1L),
-                Flowable.fromIterable(iterate(elements))
+                }
             )
         ;
     }

File: src/test/java/io/reactivex/rxjava3/disposables/SequentialDisposableTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import org.junit.*;
 import org.junit.runner.RunWith;
-import org.mockito.runners.MockitoJUnitRunner;
+import org.mockito.junit.MockitoJUnitRunner;
 
 import io.reactivex.rxjava3.core.RxJavaTest;
 import io.reactivex.rxjava3.internal.disposables.SequentialDisposable;

File: src/test/java/io/reactivex/rxjava3/disposables/SerialDisposableTests.java
Patch:
@@ -21,7 +21,7 @@
 
 import org.junit.*;
 import org.junit.runner.RunWith;
-import org.mockito.runners.MockitoJUnitRunner;
+import org.mockito.junit.MockitoJUnitRunner;
 
 import io.reactivex.rxjava3.core.RxJavaTest;
 import io.reactivex.rxjava3.internal.disposables.DisposableHelper;

File: src/jmh/java/io/reactivex/rxjava3/core/BinaryFlatMapPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,7 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.Observable;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/BlockingGetPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.TimeUnit;
 

File: src/jmh/java/io/reactivex/rxjava3/core/BlockingPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;

File: src/jmh/java/io/reactivex/rxjava3/core/CallableAsyncPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.*;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.internal.schedulers.SingleScheduler;
-import io.reactivex.schedulers.Schedulers;
+import io.reactivex.rxjava3.internal.schedulers.SingleScheduler;
+import io.reactivex.rxjava3.schedulers.Schedulers;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/EachTypeFlatMapPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/FlatMapJustPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenCrossMapPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import java.util.*;
+import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenJustPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/FlattenRangePerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import java.util.*;
+import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/FlowableFlatMapCompletableSyncPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.internal.functions.Functions;
+import io.reactivex.rxjava3.internal.functions.Functions;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/InputWithIncrementingInteger.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Iterator;
 
 import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.*;
 
-import io.reactivex.internal.subscriptions.EmptySubscription;
-import io.reactivex.subscribers.DefaultSubscriber;
+import io.reactivex.rxjava3.internal.subscriptions.EmptySubscription;
+import io.reactivex.rxjava3.subscribers.DefaultSubscriber;
 
 /**
  * Exposes an Observable and Observer that increments n Integers and consumes them in a Blackhole.

File: src/jmh/java/io/reactivex/rxjava3/core/JustAsyncPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.internal.schedulers.SingleScheduler;
-import io.reactivex.schedulers.Schedulers;
+import io.reactivex.rxjava3.internal.schedulers.SingleScheduler;
+import io.reactivex.rxjava3.schedulers.Schedulers;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/LatchedSingleObserver.java
Patch:
@@ -11,13 +11,13 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.CountDownLatch;
 
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 public final class LatchedSingleObserver<T> implements SingleObserver<T> {
     final CountDownLatch cdl;

File: src/jmh/java/io/reactivex/rxjava3/core/ObservableFlatMapPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/PerfBoundedSubscriber.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.CountDownLatch;
 

File: src/jmh/java/io/reactivex/rxjava3/core/PerfConsumer.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Subscription;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * A multi-type synchronous consumer.

File: src/jmh/java/io/reactivex/rxjava3/core/PerfInteropConsumer.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.*;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * A multi-type synchronous consumer that doesn't implement FlowableSubscriber and

File: src/jmh/java/io/reactivex/rxjava3/core/PerfObserver.java
Patch:
@@ -11,13 +11,13 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.CountDownLatch;
 
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 public final class PerfObserver implements Observer<Object> {
     final CountDownLatch cdl;

File: src/jmh/java/io/reactivex/rxjava3/core/PerfSubscriber.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.CountDownLatch;
 

File: src/jmh/java/io/reactivex/rxjava3/core/PublishProcessorPerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.processors.PublishProcessor;
-import io.reactivex.subjects.PublishSubject;
+import io.reactivex.rxjava3.processors.PublishProcessor;
+import io.reactivex.rxjava3.subjects.PublishSubject;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/ReducePerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.functions.BiFunction;
+import io.reactivex.rxjava3.functions.BiFunction;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/RxVsStreamPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -20,7 +20,7 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/StrictPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;

File: src/jmh/java/io/reactivex/rxjava3/core/ToFlowablePerf.java
Patch:
@@ -11,15 +11,15 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.functions.*;
+import io.reactivex.rxjava3.functions.*;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/core/XMapYPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -20,7 +20,7 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapCompletablePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapMaybeEmptyPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapMaybePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableConcatMapSinglePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapCompletablePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapMaybeEmptyPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapMaybePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableFlatMapSinglePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapCompletablePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapMaybeEmptyPerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapMaybePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/FlowableSwitchMapSinglePerf.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
@@ -20,8 +20,8 @@
 import org.openjdk.jmh.infra.Blackhole;
 import org.reactivestreams.Publisher;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapCompletablePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapMaybeEmptyPerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapMaybePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableConcatMapSinglePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapCompletablePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapMaybeEmptyPerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapMaybePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableFlatMapSinglePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapCompletablePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapMaybeEmptyPerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapMaybePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/jmh/java/io/reactivex/rxjava3/xmapz/ObservableSwitchMapSinglePerf.java
Patch:
@@ -11,16 +11,16 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.xmapz;
+package io.reactivex.rxjava3.xmapz;
 
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.*;
-import io.reactivex.functions.Function;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.functions.Function;
 
 @BenchmarkMode(Mode.Throughput)
 @Warmup(iterations = 5)

File: src/main/java/io/reactivex/rxjava3/annotations/BackpressureKind.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.annotations;
+package io.reactivex.rxjava3.annotations;
 
 /**
  * Enumeration for various kinds of backpressure support.

File: src/main/java/io/reactivex/rxjava3/annotations/BackpressureSupport.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.annotations;
+package io.reactivex.rxjava3.annotations;
 
 import java.lang.annotation.*;
 

File: src/main/java/io/reactivex/rxjava3/annotations/Beta.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.annotations;
+package io.reactivex.rxjava3.annotations;
 
 /**
  * Indicates the feature is in beta state: it will be most likely stay but

File: src/main/java/io/reactivex/rxjava3/annotations/Experimental.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.annotations;
+package io.reactivex.rxjava3.annotations;
 
 /**
  * Indicates the feature is in experimental state: its existence, signature or behavior

File: src/main/java/io/reactivex/rxjava3/annotations/SchedulerSupport.java
Patch:
@@ -11,11 +11,11 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.annotations;
+package io.reactivex.rxjava3.annotations;
 
 import java.lang.annotation.*;
 
-import io.reactivex.schedulers.Schedulers;
+import io.reactivex.rxjava3.schedulers.Schedulers;
 
 /**
  * Indicates what kind of scheduler the class or method uses.

File: src/main/java/io/reactivex/rxjava3/annotations/package-info.java
Patch:
@@ -17,4 +17,4 @@
 /**
  * Annotations for indicating experimental and beta operators, classes, methods, types or fields.
  */
-package io.reactivex.annotations;
+package io.reactivex.rxjava3.annotations;

File: src/main/java/io/reactivex/rxjava3/core/BackpressureOverflowStrategy.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 /**
  * Options to deal with buffer overflow when using onBackpressureBuffer.

File: src/main/java/io/reactivex/rxjava3/core/BackpressureStrategy.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
 /**
  * Represents the options for applying backpressure to a source sequence.

File: src/main/java/io/reactivex/rxjava3/core/CompletableConverter.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Convenience interface and callback used by the {@link Completable#to} operator to turn a Completable into another

File: src/main/java/io/reactivex/rxjava3/core/CompletableObserver.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.NonNull;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.annotations.NonNull;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * Provides a mechanism for receiving push-based notification of a valueless completion or an error.

File: src/main/java/io/reactivex/rxjava3/core/CompletableOnSubscribe.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives

File: src/main/java/io/reactivex/rxjava3/core/CompletableOperator.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to map/wrap a downstream observer to an upstream observer.

File: src/main/java/io/reactivex/rxjava3/core/CompletableSource.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Represents a basic {@link Completable} source base interface,

File: src/main/java/io/reactivex/rxjava3/core/CompletableTransformer.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Convenience interface and callback used by the compose operator to turn a Completable into another

File: src/main/java/io/reactivex/rxjava3/core/Emitter.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Base interface for emitting signals in a push-fashion in various generator-like source

File: src/main/java/io/reactivex/rxjava3/core/FlowableConverter.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Convenience interface and callback used by the {@link Flowable#to} operator to turn a Flowable into another

File: src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives

File: src/main/java/io/reactivex/rxjava3/core/FlowableOperator.java
Patch:
@@ -11,11 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
 import org.reactivestreams.Subscriber;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * Interface to map/wrap a downstream subscriber to an upstream subscriber.
  *

File: src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.java
Patch:
@@ -11,11 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
 import org.reactivestreams.*;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * Represents a Reactive-Streams inspired Subscriber that is RxJava 2 only
  * and weakens rules 1.3 and 3.9 of the specification for gaining performance.

File: src/main/java/io/reactivex/rxjava3/core/FlowableTransformer.java
Patch:
@@ -11,11 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
 import org.reactivestreams.Publisher;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * Interface to compose Flowables.
  *

File: src/main/java/io/reactivex/rxjava3/core/MaybeConverter.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Convenience interface and callback used by the {@link Maybe#to} operator to turn a Maybe into another

File: src/main/java/io/reactivex/rxjava3/core/MaybeObserver.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.annotations.NonNull;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * Provides a mechanism for receiving push-based notification of a single value, an error or completion without any value.

File: src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives

File: src/main/java/io/reactivex/rxjava3/core/MaybeOperator.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to map/wrap a downstream observer to an upstream observer.

File: src/main/java/io/reactivex/rxjava3/core/MaybeSource.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Represents a basic {@link Maybe} source base interface,

File: src/main/java/io/reactivex/rxjava3/core/MaybeTransformer.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to compose Maybes.

File: src/main/java/io/reactivex/rxjava3/core/ObservableConverter.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Convenience interface and callback used by the {@link Observable#to} operator to turn an Observable into another

File: src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives

File: src/main/java/io/reactivex/rxjava3/core/ObservableOperator.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to map/wrap a downstream observer to an upstream observer.

File: src/main/java/io/reactivex/rxjava3/core/ObservableSource.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Represents a basic, non-backpressured {@link Observable} source base interface,

File: src/main/java/io/reactivex/rxjava3/core/ObservableTransformer.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to compose Observables.

File: src/main/java/io/reactivex/rxjava3/core/SingleConverter.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Convenience interface and callback used by the {@link Single#to} operator to turn a Single into another

File: src/main/java/io/reactivex/rxjava3/core/SingleObserver.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.annotations.NonNull;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * Provides a mechanism for receiving push-based notification of a single value or an error.

File: src/main/java/io/reactivex/rxjava3/core/SingleOnSubscribe.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives

File: src/main/java/io/reactivex/rxjava3/core/SingleOperator.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to map/wrap a downstream observer to an upstream observer.

File: src/main/java/io/reactivex/rxjava3/core/SingleSource.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Represents a basic {@link Single} source base interface,

File: src/main/java/io/reactivex/rxjava3/core/SingleTransformer.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex;
+package io.reactivex.rxjava3.core;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Interface to compose Singles.

File: src/main/java/io/reactivex/rxjava3/disposables/Disposable.java
Patch:
@@ -10,7 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;
 
 /**
  * Represents a disposable resource.

File: src/main/java/io/reactivex/rxjava3/disposables/FutureDisposable.java
Patch:
@@ -10,7 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;
 
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;

File: src/main/java/io/reactivex/rxjava3/disposables/ReferenceDisposable.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.annotations.NonNull;
-import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.rxjava3.annotations.NonNull;
+import io.reactivex.rxjava3.internal.functions.ObjectHelper;
 
 /**
  * Base class for Disposable containers that manage some other type that

File: src/main/java/io/reactivex/rxjava3/disposables/RunnableDisposable.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A disposable container that manages a Runnable instance.

File: src/main/java/io/reactivex/rxjava3/disposables/SerialDisposable.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.annotations.Nullable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.rxjava3.annotations.Nullable;
+import io.reactivex.rxjava3.internal.disposables.DisposableHelper;
 
 /**
  * A Disposable container that allows atomically updating/replacing the contained

File: src/main/java/io/reactivex/rxjava3/disposables/SubscriptionDisposable.java
Patch:
@@ -10,11 +10,12 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;
 
-import io.reactivex.annotations.NonNull;
 import org.reactivestreams.Subscription;
 
+import io.reactivex.rxjava3.annotations.NonNull;
+
 /**
  * A Disposable container that handles a {@link Subscription}.
  */

File: src/main/java/io/reactivex/rxjava3/disposables/package-info.java
Patch:
@@ -19,4 +19,4 @@
  * (Disposable container types) and utility classes to construct
  * Disposables from callbacks and other types.
  */
-package io.reactivex.disposables;
+package io.reactivex.rxjava3.disposables;

File: src/main/java/io/reactivex/rxjava3/exceptions/CompositeException.java
Patch:
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;
 
 import java.io.*;
 import java.util.*;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Represents an exception that is a composite of one or more other exceptions. A {@code CompositeException}

File: src/main/java/io/reactivex/rxjava3/exceptions/Exceptions.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;
 
-import io.reactivex.annotations.*;
-import io.reactivex.internal.util.ExceptionHelper;
+import io.reactivex.rxjava3.annotations.NonNull;
+import io.reactivex.rxjava3.internal.util.ExceptionHelper;
 
 /**
  * Utility class to help propagate checked exceptions and rethrow exceptions

File: src/main/java/io/reactivex/rxjava3/exceptions/MissingBackpressureException.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;
 
 /**
  * Indicates that an operator attempted to emit a value but the downstream wasn't ready for it.

File: src/main/java/io/reactivex/rxjava3/exceptions/OnErrorNotImplementedException.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * Represents an exception used to signal to the {@code RxJavaPlugins.onError()} that a

File: src/main/java/io/reactivex/rxjava3/exceptions/ProtocolViolationException.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;
 
 /**
  * Explicitly named exception to indicate a Reactive-Streams

File: src/main/java/io/reactivex/rxjava3/exceptions/UndeliverableException.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;
 
 /**
  * Wrapper for Throwable errors that are sent to `RxJavaPlugins.onError`.

File: src/main/java/io/reactivex/rxjava3/exceptions/package-info.java
Patch:
@@ -18,4 +18,4 @@
  * Exception handling utilities, safe subscriber exception classes,
  * lifecycle exception classes.
  */
-package io.reactivex.exceptions;
+package io.reactivex.rxjava3.exceptions;

File: src/main/java/io/reactivex/rxjava3/flowables/package-info.java
Patch:
@@ -16,7 +16,7 @@
 
 /**
  * Classes supporting the Flowable base reactive class:
- * {@link io.reactivex.flowables.ConnectableFlowable} and
- * {@link io.reactivex.flowables.GroupedFlowable}.
+ * {@link io.reactivex.rxjava3.flowables.ConnectableFlowable} and
+ * {@link io.reactivex.rxjava3.flowables.GroupedFlowable}.
  */
-package io.reactivex.flowables;
+package io.reactivex.rxjava3.flowables;

File: src/main/java/io/reactivex/rxjava3/functions/Action.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface similar to Runnable but allows throwing a checked exception.

File: src/main/java/io/reactivex/rxjava3/functions/BiConsumer.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface (callback) that accepts two values (of possibly different types).

File: src/main/java/io/reactivex/rxjava3/functions/BiFunction.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/BiPredicate.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that returns true or false for the given input values.

File: src/main/java/io/reactivex/rxjava3/functions/BooleanSupplier.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface (callback) that returns a boolean value.

File: src/main/java/io/reactivex/rxjava3/functions/Cancellable.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface that has a single cancel method

File: src/main/java/io/reactivex/rxjava3/functions/Consumer.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface (callback) that accepts a single value.

File: src/main/java/io/reactivex/rxjava3/functions/Function.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface that takes a value and returns another value, possibly with a

File: src/main/java/io/reactivex/rxjava3/functions/Function3.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/Function4.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/Function5.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/Function6.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/Function7.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/Function8.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/Function9.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that computes a value based on multiple input values.

File: src/main/java/io/reactivex/rxjava3/functions/IntFunction.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that takes a primitive value and return value of type T.

File: src/main/java/io/reactivex/rxjava3/functions/LongConsumer.java
Patch:
@@ -10,7 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface (callback) that consumes a primitive long value.

File: src/main/java/io/reactivex/rxjava3/functions/Predicate.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
-import io.reactivex.annotations.NonNull;
+import io.reactivex.rxjava3.annotations.NonNull;
 
 /**
  * A functional interface (callback) that returns true or false for the given input value.

File: src/main/java/io/reactivex/rxjava3/functions/Supplier.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;
 
 /**
  * A functional interface (callback) that provides a single value or

File: src/main/java/io/reactivex/rxjava3/functions/package-info.java
Patch:
@@ -18,4 +18,4 @@
  * Functional interfaces of functions and actions of arity 0 to 9 and related
  * utility classes.
  */
-package io.reactivex.functions;
+package io.reactivex.rxjava3.functions;

File: src/main/java/io/reactivex/rxjava3/internal/disposables/ArrayCompositeDisposable.java
Patch:
@@ -11,11 +11,11 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.disposables;
+package io.reactivex.rxjava3.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReferenceArray;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * A composite disposable with a fixed number of slots.

File: src/main/java/io/reactivex/rxjava3/internal/disposables/DisposableContainer.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.disposables;
+package io.reactivex.rxjava3.internal.disposables;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * Common interface to add and remove disposables from a container.

File: src/main/java/io/reactivex/rxjava3/internal/disposables/SequentialDisposable.java
Patch:
@@ -11,11 +11,11 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.disposables;
+package io.reactivex.rxjava3.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * A Disposable container that allows updating/replacing a Disposable

File: src/main/java/io/reactivex/rxjava3/internal/functions/ObjectHelper.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.internal.functions;
+package io.reactivex.rxjava3.internal.functions;
 
-import io.reactivex.functions.BiPredicate;
+import io.reactivex.rxjava3.functions.BiPredicate;
 
 /**
  * Utility methods containing the backport of Java 7's Objects utility class.

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/ConditionalSubscriber.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.FlowableSubscriber;
+import io.reactivex.rxjava3.core.FlowableSubscriber;
 
 /**
  * A Subscriber with an additional {@link #tryOnNext(Object)} method that

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToFlowable.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.Flowable;
+import io.reactivex.rxjava3.core.Flowable;
 
 /**
  * Interface indicating a operator implementation can be macro-fused back to Flowable in case

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToMaybe.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.Maybe;
+import io.reactivex.rxjava3.core.Maybe;
 
 /**
  * Interface indicating an operator implementation can be macro-fused back to Maybe in case

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToObservable.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.Observable;
+import io.reactivex.rxjava3.core.Observable;
 
 /**
  * Interface indicating a operator implementation can be macro-fused back to Observable in case

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamCompletableSource.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.CompletableSource;
+import io.reactivex.rxjava3.core.CompletableSource;
 
 /**
  * Interface indicating the implementor has an upstream CompletableSource-like source available

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamMaybeSource.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.MaybeSource;
+import io.reactivex.rxjava3.core.MaybeSource;
 
 /**
  * Interface indicating the implementor has an upstream MaybeSource-like source available

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamObservableSource.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.ObservableSource;
+import io.reactivex.rxjava3.core.ObservableSource;
 
 /**
  * Interface indicating the implementor has an upstream ObservableSource-like source available

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamPublisher.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
 import org.reactivestreams.Publisher;
 

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamSingleSource.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.SingleSource;
+import io.reactivex.rxjava3.core.SingleSource;
 
 /**
  * Interface indicating the implementor has an upstream SingleSource-like source available

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueDisposable.java
Patch:
@@ -10,11 +10,11 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
 import java.util.Queue;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * An interface extending Queue and Disposable and allows negotiating

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueFuseable.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
 /**
  * Represents a SimpleQueue plus the means and constants for requesting a fusion mode.

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/QueueSubscription.java
Patch:
@@ -10,7 +10,7 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
 import java.util.Queue;
 

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/ScalarSupplier.java
Patch:
@@ -10,9 +10,9 @@
  * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
  * the License for the specific language governing permissions and limitations under the License.
  */
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.functions.Supplier;
+import io.reactivex.rxjava3.functions.Supplier;
 
 /**
  * A marker interface indicating that a scalar, constant value

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/SimplePlainQueue.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.annotations.Nullable;
+import io.reactivex.rxjava3.annotations.Nullable;
 
 /**
  * Override of the SimpleQueue interface with no throws Exception on poll().

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/SimpleQueue.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;
 
-import io.reactivex.annotations.*;
+import io.reactivex.rxjava3.annotations.*;
 
 /**
  * A minimalist queue interface without the method bloat of java.util.Collection and java.util.Queue.

File: src/main/java/io/reactivex/rxjava3/internal/fuseable/package-info.java
Patch:
@@ -14,4 +14,4 @@
 /**
  * Base interfaces and types for supporting operator-fusion.
  */
-package io.reactivex.internal.fuseable;
+package io.reactivex.rxjava3.internal.fuseable;

File: src/main/java/io/reactivex/rxjava3/internal/observers/BasicIntQueueDisposable.java
Patch:
@@ -11,11 +11,11 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.observers;
+package io.reactivex.rxjava3.internal.observers;
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.rxjava3.internal.fuseable.QueueDisposable;
 
 /**
  * An abstract QueueDisposable implementation, extending an AtomicInteger,

File: src/main/java/io/reactivex/rxjava3/internal/observers/BasicQueueDisposable.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.observers;
+package io.reactivex.rxjava3.internal.observers;
 
-import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.rxjava3.internal.fuseable.QueueDisposable;
 
 /**
  * An abstract QueueDisposable implementation that defaults all

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingFirstObserver.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.observers;
+package io.reactivex.rxjava3.internal.observers;
 
 /**
  * Blocks until the upstream signals its first value or completes.

File: src/main/java/io/reactivex/rxjava3/internal/observers/BlockingLastObserver.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.observers;
+package io.reactivex.rxjava3.internal.observers;
 
 /**
  * Blocks until the upstream signals its last value or completes.

File: src/main/java/io/reactivex/rxjava3/internal/observers/InnerQueuedObserverSupport.java
Patch:
@@ -11,7 +11,7 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.observers;
+package io.reactivex.rxjava3.internal.observers;
 
 /**
  * Interface to allow the InnerQueuedSubscriber to call back a parent

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableCache.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
 import java.util.concurrent.atomic.*;
 
-import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 /**
  * Consume the upstream source exactly once and cache its terminal event.

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableEmpty.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
 
 public final class CompletableEmpty extends Completable {
     public static final Completable INSTANCE = new CompletableEmpty();

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableError.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
 
 public final class CompletableError extends Completable {
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 public final class CompletableFromObservable<T> extends Completable {
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.Disposable;
 
 public final class CompletableFromSingle<T> extends Completable {
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromUnsafeSource.java
Patch:
@@ -11,9 +11,9 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
+import io.reactivex.rxjava3.core.*;
 
 public final class CompletableFromUnsafeSource extends Completable {
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMaterialize.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
-import io.reactivex.internal.operators.mixed.MaterializeSingleObserver;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.internal.operators.mixed.MaterializeSingleObserver;
 
 /**
  * Turn the signal types of a Completable source into a single Notification of

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableNever.java
Patch:
@@ -11,10 +11,10 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
-import io.reactivex.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
 
 public final class CompletableNever extends Completable {
     public static final Completable INSTANCE = new CompletableNever();

File: src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToFlowable.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.completable;
+package io.reactivex.rxjava3.internal.operators.completable;
 
 import org.reactivestreams.Subscriber;
 
-import io.reactivex.*;
-import io.reactivex.internal.observers.SubscriberCompletableObserver;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.internal.observers.SubscriberCompletableObserver;
 
 public final class CompletableToFlowable<T> extends Flowable<T> {
 

File: src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCount.java
Patch:
@@ -11,12 +11,12 @@
  * the License for the specific language governing permissions and limitations under the License.
  */
 
-package io.reactivex.internal.operators.flowable;
+package io.reactivex.rxjava3.internal.operators.flowable;
 
 import org.reactivestreams.*;
 
-import io.reactivex.*;
-import io.reactivex.internal.subscriptions.*;
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.internal.subscriptions.*;
 
 public final class FlowableCount<T> extends AbstractFlowableWithUpstream<T, Long> {
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java
Patch:
@@ -63,7 +63,7 @@ public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.upstream, s)) {
                 this.upstream = s;
                 downstream.onSubscribe(this);
-                s.request(Long.MAX_VALUE);
+                s.request(index + 1);
             }
         }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java
Patch:
@@ -70,7 +70,7 @@ public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.upstream, s)) {
                 this.upstream = s;
                 downstream.onSubscribe(this);
-                s.request(Long.MAX_VALUE);
+                s.request(index + 1);
             }
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -316,6 +316,7 @@ void innerError(SwitchMapInnerObserver<T, R> inner, Throwable ex) {
             if (inner.index == unique && errors.addThrowable(ex)) {
                 if (!delayErrors) {
                     upstream.dispose();
+                    done = true;
                 }
                 inner.done = true;
                 drain();

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeMergeArray.java
Patch:
@@ -201,7 +201,7 @@ void drainNormal() {
                     Throwable ex = error.get();
                     if (ex != null) {
                         q.clear();
-                        a.onError(error.terminate());
+                        error.tryTerminateConsumer(downstream);
                         return;
                     }
 
@@ -227,7 +227,7 @@ void drainNormal() {
                     Throwable ex = error.get();
                     if (ex != null) {
                         q.clear();
-                        a.onError(error.terminate());
+                        error.tryTerminateConsumer(downstream);
                         return;
                     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -210,7 +210,7 @@ void drain() {
                     } else {
                         Throwable ex = errors.get();
                         if (ex != null) {
-                            a.onError(errors.terminate());
+                            errors.tryTerminateConsumer(a);
                             return;
                         }
                         if (empty) {
@@ -236,7 +236,7 @@ void drain() {
                             } else {
                                 Throwable ex = errors.get();
                                 if (ex != null) {
-                                    a.onError(errors.terminate());
+                                    errors.tryTerminateConsumer(a);
                                     return;
                                 }
                                 if (empty) {
@@ -260,7 +260,7 @@ void drain() {
                             if (!delayErrors) {
                                 Throwable ex = errors.get();
                                 if (ex != null) {
-                                    a.onError(errors.terminate());
+                                    errors.tryTerminateConsumer(a);
                                     return;
                                 }
                             }

File: src/main/java/io/reactivex/observers/SerializedObserver.java
Patch:
@@ -74,6 +74,7 @@ public void onSubscribe(@NonNull Disposable d) {
 
     @Override
     public void dispose() {
+        done = true;
         upstream.dispose();
     }
 

File: src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
Patch:
@@ -16,7 +16,6 @@
 import static org.junit.Assert.*;
 
 import java.util.*;
-import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
 import org.junit.*;

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecentTest.java
Patch:
@@ -24,7 +24,6 @@
 import io.reactivex.exceptions.TestException;
 import io.reactivex.processors.*;
 import io.reactivex.schedulers.TestScheduler;
-import io.reactivex.testsupport.TestHelper;
 
 public class BlockingFlowableMostRecentTest extends RxJavaTest {
     @Test

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableToFutureTest.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.*;
 import java.util.concurrent.*;
 
-import io.reactivex.testsupport.TestHelper;
 import org.junit.*;
 import org.reactivestreams.*;
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
-import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.TestSubscriber;
 import io.reactivex.testsupport.*;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
Patch:
@@ -17,7 +17,6 @@
 import static org.mockito.Mockito.*;
 
 import java.io.IOException;
-import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
-import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.TestSubscriber;
 import io.reactivex.testsupport.*;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDefaultIfEmptyTest.java
Patch:
@@ -20,8 +20,6 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
-import io.reactivex.exceptions.TestException;
-import io.reactivex.subscribers.DefaultSubscriber;
 import io.reactivex.testsupport.*;
 
 public class FlowableDefaultIfEmptyTest extends RxJavaTest {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
Patch:
@@ -16,13 +16,11 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 
 import io.reactivex.RxJavaTest;
 import org.junit.*;
-import org.mockito.InOrder;
 import org.reactivestreams.*;
 
 import io.reactivex.Flowable;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
Patch:
@@ -17,7 +17,6 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.subscribers.*;
 import io.reactivex.testsupport.*;
 
-public class FlowableSubscribeOnTest extends RxJavaTest{
+public class FlowableSubscribeOnTest extends RxJavaTest {
 
     @Test
     public void issue813() throws InterruptedException {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
Patch:
@@ -17,7 +17,6 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.*;
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
Patch:
@@ -27,7 +27,6 @@
 import io.reactivex.functions.*;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.processors.PublishProcessor;
-import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 import io.reactivex.testsupport.*;
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
Patch:
@@ -24,9 +24,6 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
-import io.reactivex.observers.TestObserver;
-import io.reactivex.processors.PublishProcessor;
-import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 import io.reactivex.testsupport.*;
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDefaultIfEmptyTest.java
Patch:
@@ -18,8 +18,6 @@
 import org.junit.*;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.TestException;
-import io.reactivex.observers.DefaultObserver;
 import io.reactivex.testsupport.TestHelper;
 
 public class ObservableDefaultIfEmptyTest extends RxJavaTest {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeDelayErrorTest.java
Patch:
@@ -21,7 +21,6 @@
 
 import io.reactivex.RxJavaTest;
 import org.junit.*;
-import org.mockito.InOrder;
 
 import io.reactivex.Observable;
 import io.reactivex.ObservableSource;

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutTests.java
Patch:
@@ -17,7 +17,6 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.*;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMergeWithCompletable.java
Patch:
@@ -86,7 +86,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable ex) {
-            SubscriptionHelper.cancel(mainSubscription);
+            DisposableHelper.dispose(otherObserver);
             HalfSerializer.onError(downstream, ex, this, error);
         }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMergeWithMaybe.java
Patch:
@@ -143,7 +143,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable ex) {
             if (error.addThrowable(ex)) {
-                SubscriptionHelper.cancel(mainSubscription);
+                DisposableHelper.dispose(otherObserver);
                 drain();
             } else {
                 RxJavaPlugins.onError(ex);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMergeWithSingle.java
Patch:
@@ -143,7 +143,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable ex) {
             if (error.addThrowable(ex)) {
-                SubscriptionHelper.cancel(mainSubscription);
+                DisposableHelper.dispose(otherObserver);
                 drain();
             } else {
                 RxJavaPlugins.onError(ex);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMergeWithCompletable.java
Patch:
@@ -80,7 +80,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable ex) {
-            DisposableHelper.dispose(mainDisposable);
+            DisposableHelper.dispose(otherObserver);
             HalfSerializer.onError(downstream, ex, this, error);
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMergeWithMaybe.java
Patch:
@@ -106,7 +106,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable ex) {
             if (error.addThrowable(ex)) {
-                DisposableHelper.dispose(mainDisposable);
+                DisposableHelper.dispose(otherObserver);
                 drain();
             } else {
                 RxJavaPlugins.onError(ex);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMergeWithSingle.java
Patch:
@@ -106,7 +106,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable ex) {
             if (error.addThrowable(ex)) {
-                DisposableHelper.dispose(mainDisposable);
+                DisposableHelper.dispose(otherObserver);
                 drain();
             } else {
                 RxJavaPlugins.onError(ex);

File: src/test/java/io/reactivex/completable/CompletableRetryTest.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.completable;
 
 import io.reactivex.Completable;
+import io.reactivex.RxJavaTest;
 import io.reactivex.functions.Action;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.functions.Functions;
@@ -22,7 +23,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class CompletableRetryTest {
+public class CompletableRetryTest extends RxJavaTest {
     @Test
     public void retryTimesPredicateWithMatchingPredicate() {
         final AtomicInteger atomicInteger = new AtomicInteger(3);

File: src/test/java/io/reactivex/completable/CompletableTimerTest.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.completable;
 
+import io.reactivex.RxJavaTest;
 import org.junit.Test;
 
 import java.util.concurrent.TimeUnit;
@@ -24,7 +25,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class CompletableTimerTest {
+public class CompletableTimerTest extends RxJavaTest {
     @Test
     public void timer() {
         final TestScheduler testScheduler = new TestScheduler();

File: src/test/java/io/reactivex/disposables/DisposablesTest.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.RxJavaTest;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
 
@@ -28,7 +29,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.testsupport.TestHelper;
 
-public class DisposablesTest {
+public class DisposablesTest extends RxJavaTest {
 
     @Test
     public void unsubscribeOnlyOnce() {

File: src/test/java/io/reactivex/disposables/FutureDisposableTest.java
Patch:
@@ -16,11 +16,13 @@
 import java.util.concurrent.FutureTask;
 
 import static org.junit.Assert.*;
+
+import io.reactivex.RxJavaTest;
 import org.junit.Test;
 
 import io.reactivex.internal.functions.Functions;
 
-public class FutureDisposableTest {
+public class FutureDisposableTest extends RxJavaTest {
 
     @Test
     public void normal() {

File: src/test/java/io/reactivex/disposables/SequentialDisposableTest.java
Patch:
@@ -19,14 +19,15 @@
 import java.util.*;
 import java.util.concurrent.CountDownLatch;
 
+import io.reactivex.RxJavaTest;
 import org.junit.*;
 import org.junit.runner.RunWith;
 import org.mockito.runners.MockitoJUnitRunner;
 
 import io.reactivex.internal.disposables.SequentialDisposable;
 
 @RunWith(MockitoJUnitRunner.class)
-public class SequentialDisposableTest {
+public class SequentialDisposableTest extends RxJavaTest {
     private SequentialDisposable serialDisposable;
 
     @Before
@@ -117,7 +118,7 @@ public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() {
         verify(underlying).dispose();
     }
 
-    @Test(timeout = 1000)
+    @Test
     public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently()
             throws InterruptedException {
         final Disposable firstSet = mock(Disposable.class);

File: src/test/java/io/reactivex/disposables/SerialDisposableTests.java
Patch:
@@ -19,14 +19,15 @@
 import java.util.*;
 import java.util.concurrent.CountDownLatch;
 
+import io.reactivex.RxJavaTest;
 import org.junit.*;
 import org.junit.runner.RunWith;
 import org.mockito.runners.MockitoJUnitRunner;
 
 import io.reactivex.internal.disposables.DisposableHelper;
 
 @RunWith(MockitoJUnitRunner.class)
-public class SerialDisposableTests {
+public class SerialDisposableTests extends RxJavaTest {
     private SerialDisposable serialDisposable;
 
     @Before
@@ -117,7 +118,7 @@ public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() {
         verify(underlying).dispose();
     }
 
-    @Test(timeout = 1000)
+    @Test
     public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently()
             throws InterruptedException {
         final Disposable firstSet = mock(Disposable.class);

File: src/test/java/io/reactivex/exceptions/OnErrorNotImplementedExceptionTest.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.testsupport.TestHelper;
 
-public class OnErrorNotImplementedExceptionTest {
+public class OnErrorNotImplementedExceptionTest extends RxJavaTest {
 
     List<Throwable> errors;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
Patch:
@@ -61,7 +61,7 @@ public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? sup
                 }
             }
             if (bs.isDisposed()
-                    || o == BlockingObserver.TERMINATED
+                    || v == BlockingObserver.TERMINATED
                     || NotificationLite.acceptFull(v, observer)) {
                 break;
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -173,6 +173,8 @@ public void cancel() {
                 upstream.cancel();
 
                 disposeInner();
+
+                error.tryTerminateAndReport();
             }
         }
 

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapCompletable.java
Patch:
@@ -162,6 +162,7 @@ void disposeInner() {
         public void dispose() {
             upstream.cancel();
             disposeInner();
+            errors.tryTerminateAndReport();
         }
 
         @Override
@@ -178,7 +179,8 @@ void innerError(SwitchMapInnerObserver sender, Throwable error) {
                             downstream.onError(ex);
                         }
                     } else {
-                        dispose();
+                        upstream.cancel();
+                        disposeInner();
                         Throwable ex = errors.terminate();
                         if (ex != ExceptionHelper.TERMINATED) {
                             downstream.onError(ex);

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapMaybe.java
Patch:
@@ -177,6 +177,7 @@ public void cancel() {
             cancelled = true;
             upstream.cancel();
             disposeInner();
+            errors.tryTerminateAndReport();
         }
 
         void innerError(SwitchMapMaybeObserver<R> sender, Throwable ex) {

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapSingle.java
Patch:
@@ -177,6 +177,7 @@ public void cancel() {
             cancelled = true;
             upstream.cancel();
             disposeInner();
+            errors.tryTerminateAndReport();
         }
 
         void innerError(SwitchMapSingleObserver<R> sender, Throwable ex) {

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapCompletable.java
Patch:
@@ -160,6 +160,7 @@ void disposeInner() {
         public void dispose() {
             upstream.dispose();
             disposeInner();
+            errors.tryTerminateAndReport();
         }
 
         @Override
@@ -176,7 +177,8 @@ void innerError(SwitchMapInnerObserver sender, Throwable error) {
                             downstream.onError(ex);
                         }
                     } else {
-                        dispose();
+                        upstream.dispose();
+                        disposeInner();
                         Throwable ex = errors.terminate();
                         if (ex != ExceptionHelper.TERMINATED) {
                             downstream.onError(ex);

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapMaybe.java
Patch:
@@ -164,6 +164,7 @@ public void dispose() {
             cancelled = true;
             upstream.dispose();
             disposeInner();
+            errors.tryTerminateAndReport();
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapSingle.java
Patch:
@@ -164,6 +164,7 @@ public void dispose() {
             cancelled = true;
             upstream.dispose();
             disposeInner();
+            errors.tryTerminateAndReport();
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -157,6 +157,8 @@ public void dispose() {
                 cancelled = true;
                 upstream.dispose();
                 disposeInner();
+
+                errors.tryTerminateAndReport();
             }
         }
 

File: src/test/java/io/reactivex/validators/CheckLocalVariablesInTests.java
Patch:
@@ -19,6 +19,8 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 /**
  * Checks for commonly copy-pasted but not-renamed local variables in unit tests.
  * <ul>
@@ -41,7 +43,7 @@ static void findPattern(String pattern) throws Exception {
     }
 
     static void findPattern(String pattern, boolean checkMain) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             System.out.println("Unable to find sources of RxJava");
             return;

File: src/test/java/io/reactivex/validators/FixLicenseHeaders.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 /**
  * Adds license header to java files.
  */
@@ -45,7 +47,7 @@ public void checkAndUpdateLicenses() throws Exception {
             // no point in changing the files in CI
             return;
         }
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             return;
         }

File: src/test/java/io/reactivex/validators/InternalWrongNaming.java
Patch:
@@ -18,13 +18,15 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 /**
  * Adds license header to java files.
  */
 public class InternalWrongNaming {
 
     static void checkInternalOperatorNaming(String baseClassName, String consumerClassName, String... ignore) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource(baseClassName);
+        File f = TestHelper.findSource(baseClassName);
         if (f == null) {
             return;
         }

File: src/test/java/io/reactivex/validators/JavadocFindUnescapedAngleBrackets.java
Patch:
@@ -17,11 +17,13 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 public class JavadocFindUnescapedAngleBrackets {
 
     @Test
     public void find() throws Exception {
-        File base = MaybeNo2Dot0Since.findSource("Flowable");
+        File base = TestHelper.findSource("Flowable");
 
         if (base == null) {
             return;

File: src/test/java/io/reactivex/validators/JavadocForAnnotations.java
Patch:
@@ -20,6 +20,7 @@
 import org.junit.*;
 
 import io.reactivex.*;
+import io.reactivex.testsupport.TestHelper;
 
 /**
  * Checks the source code of the base reactive types and locates missing
@@ -28,7 +29,7 @@
 public class JavadocForAnnotations {
 
     static void checkSource(String baseClassName, boolean scheduler) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource(baseClassName);
+        File f = TestHelper.findSource(baseClassName);
         if (f == null) {
             return;
         }
@@ -173,7 +174,7 @@ static final void scanForBadMethod(StringBuilder sourceCode, String annotation,
     }
 
     static void checkSchedulerBadMethod(String baseClassName) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource(baseClassName);
+        File f = TestHelper.findSource(baseClassName);
         if (f == null) {
             return;
         }

File: src/test/java/io/reactivex/validators/NewLinesBeforeAnnotation.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 /**
  * These tests verify the code style that a typical closing curly brace
  * and the next annotation &#64; indicator
@@ -64,7 +66,7 @@ public void tooManyEmptyNewLines5() throws Exception  {
     }
 
     static void findPattern(int newLines) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             System.out.println("Unable to find sources of RxJava");
             return;

File: src/test/java/io/reactivex/validators/OperatorsAreFinal.java
Patch:
@@ -18,10 +18,12 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 public class OperatorsAreFinal {
 
     File directoryOf(String baseClassName) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             return null;
         }

File: src/test/java/io/reactivex/validators/TestPrefixInMethodName.java
Patch:
@@ -15,6 +15,8 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 import java.io.*;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -33,7 +35,7 @@ public class TestPrefixInMethodName {
 
     @Test
     public void checkAndUpdateTestMethodNames() throws Exception {
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             System.out.println("Unable to find sources of RxJava");
             return;

File: src/test/java/io/reactivex/validators/TextualAorAn.java
Patch:
@@ -18,14 +18,16 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 /**
  * Adds license header to java files.
  */
 public class TextualAorAn {
 
     @Test
     public void checkFiles() throws Exception {
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             return;
         }

File: src/test/java/io/reactivex/validators/TooManyEmptyNewLines.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.junit.Test;
 
+import io.reactivex.testsupport.TestHelper;
+
 /**
  * Test verifying there are no 2..5 empty newlines in the code.
  */
@@ -44,7 +46,7 @@ public void tooManyEmptyNewLines5() throws Exception  {
     }
 
     static void findPattern(int newLines) throws Exception {
-        File f = MaybeNo2Dot0Since.findSource("Flowable");
+        File f = TestHelper.findSource("Flowable");
         if (f == null) {
             System.out.println("Unable to find sources of TestHelper.findSourceDir()");
             return;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -119,7 +119,9 @@ public void onComplete() {
             if (!DisposableHelper.isDisposed(d)) {
                 @SuppressWarnings("unchecked")
                 DebounceInnerSubscriber<T, U> dis = (DebounceInnerSubscriber<T, U>)d;
-                dis.emit();
+                if (dis != null) {
+                    dis.emit();
+                }
                 DisposableHelper.dispose(debouncer);
                 downstream.onComplete();
             }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java
Patch:
@@ -112,7 +112,9 @@ public void onComplete() {
             if (d != DisposableHelper.DISPOSED) {
                 @SuppressWarnings("unchecked")
                 DebounceInnerObserver<T, U> dis = (DebounceInnerObserver<T, U>)d;
-                dis.emit();
+                if (dis != null) {
+                    dis.emit();
+                }
                 DisposableHelper.dispose(debouncer);
                 downstream.onComplete();
             }

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -3732,7 +3732,7 @@ public final Maybe<T> onErrorComplete(final Predicate<? super Throwable> predica
      * encountered.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
-     *  <dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.</dd>
+     *  <dd>{@code onErrorResumeWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
      * @param next
@@ -3744,7 +3744,7 @@ public final Maybe<T> onErrorComplete(final Predicate<? super Throwable> predica
     @CheckReturnValue
     @NonNull
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Maybe<T> onErrorResumeNext(final MaybeSource<? extends T> next) {
+    public final Maybe<T> onErrorResumeWith(final MaybeSource<? extends T> next) {
         ObjectHelper.requireNonNull(next, "next is null");
         return onErrorResumeNext(Functions.justFunction(next));
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
Patch:
@@ -928,7 +928,7 @@ public void accept(Throwable throwable) throws Exception {
                         latch.countDown();
                     }
                 })
-                .onErrorResumeNext(Flowable.<String>empty())
+                .onErrorResumeWith(Flowable.<String>empty())
                 .subscribe();
 
         latch.await();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java
Patch:
@@ -326,7 +326,7 @@ public void errorResubscribe() {
         .publish(new Function<Flowable<Object>, Publisher<Object>>() {
             @Override
             public Publisher<Object> apply(Flowable<Object> f) throws Exception {
-                return f.onErrorResumeNext(f);
+                return f.onErrorResumeWith(f);
             }
         })
         .test()

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeOnErrorXTest.java
Patch:
@@ -193,23 +193,23 @@ public MaybeSource<Object> apply(Maybe<Object> v) throws Exception {
 
     @Test
     public void onErrorNextDispose() {
-        TestHelper.checkDisposed(PublishProcessor.create().singleElement().onErrorResumeNext(Maybe.just(1)));
+        TestHelper.checkDisposed(PublishProcessor.create().singleElement().onErrorResumeWith(Maybe.just(1)));
     }
 
     @Test
     public void onErrorNextDoubleOnSubscribe() {
         TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Object>, MaybeSource<Object>>() {
             @Override
             public MaybeSource<Object> apply(Maybe<Object> v) throws Exception {
-                return v.onErrorResumeNext(Maybe.just(1));
+                return v.onErrorResumeWith(Maybe.just(1));
             }
         });
     }
 
     @Test
     public void onErrorNextIsAlsoError() {
         Maybe.error(new TestException("Main"))
-        .onErrorResumeNext(Maybe.error(new TestException("Secondary")))
+        .onErrorResumeWith(Maybe.error(new TestException("Secondary")))
         .to(TestHelper.testConsumer())
         .assertFailureAndMessage(TestException.class, "Secondary");
     }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java
Patch:
@@ -876,7 +876,7 @@ public void accept(Throwable throwable) throws Exception {
                         latch.countDown();
                     }
                 })
-                .onErrorResumeNext(Observable.<String>empty())
+                .onErrorResumeWith(Observable.<String>empty())
                 .subscribe();
 
         latch.await();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorResumeNextTest.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.testsupport.*;
 
-public class ObservableOnErrorResumeNextViaFunctionTest {
+public class ObservableOnErrorResumeNextTest {
 
     @Test
     public void resumeNextWithSynchronousExecution() {

File: src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java
Patch:
@@ -149,7 +149,7 @@ public void accept(Throwable throwable) throws Exception {
                         latch.countDown();
                     }
                 })
-                .onErrorResumeNext(Single.just(""))
+                .onErrorResumeWith(Single.just(""))
                 .subscribe();
 
         latch.await();

File: src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
Patch:
@@ -106,9 +106,9 @@ public void hide() {
     }
 
     @Test
-    public void onErrorResumeNext() {
+    public void onErrorResumeWith() {
         Single.<Integer>error(new TestException())
-        .onErrorResumeNext(Single.just(1))
+        .onErrorResumeWith(Single.just(1))
         .test()
         .assertResult(1);
     }

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -1700,7 +1700,7 @@ public void ofTypeNull() {
 
     @Test(expected = NullPointerException.class)
     public void onErrorResumeNextFunctionNull() {
-        just1.onErrorResumeNext((Function<Throwable, Observable<Integer>>)null);
+        just1.onErrorResumeNext(null);
     }
 
     @Test(expected = NullPointerException.class)
@@ -1715,7 +1715,7 @@ public Observable<Object> apply(Throwable e) {
 
     @Test(expected = NullPointerException.class)
     public void onErrorResumeNextObservableNull() {
-        just1.onErrorResumeNext((Observable<Integer>)null);
+        just1.onErrorResumeWith(null);
     }
 
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/tck/OnErrorResumeWithTckTest.java
Patch:
@@ -19,12 +19,12 @@
 import io.reactivex.Flowable;
 
 @Test
-public class OnErrorResumeNextTckTest extends BaseTck<Integer> {
+public class OnErrorResumeWithTckTest extends BaseTck<Integer> {
 
     @Override
     public Publisher<Integer> createPublisher(long elements) {
         return
-                Flowable.range(0, (int)elements).onErrorResumeNext(Flowable.<Integer>never())
+                Flowable.range(0, (int)elements).onErrorResumeWith(Flowable.<Integer>never())
         ;
     }
 }

File: src/main/java/io/reactivex/schedulers/Schedulers.java
Patch:
@@ -400,7 +400,7 @@ public static Scheduler from(@NonNull Executor executor) {
      * @param interruptibleWorker if {@code true} the tasks submitted to the {@link io.reactivex.Scheduler.Worker Scheduler.Worker} will
      * be interrupted when the task is disposed.
      * @return the new Scheduler wrapping the Executor
-     * @since 2.2.6 - experimental
+     * @since 3.0.0
      */
     @NonNull
     public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker) {

File: src/test/java/io/reactivex/completable/CompletableTest.java
Patch:
@@ -3786,7 +3786,7 @@ public void after() {
     }
 
     @Test
-    public void testHookCreate() throws Throwable {
+    public void hookCreate() throws Throwable {
         CompletableSource subscriber = mock(CompletableSource.class);
         Completable create = Completable.unsafeCreate(subscriber);
 
@@ -4200,7 +4200,7 @@ public void onSubscribe(Subscription s) {
     }
 
     @Test
-    public void testHookSubscribeStart() throws Throwable {
+    public void hookSubscribeStart() throws Throwable {
         TestSubscriber<String> ts = new TestSubscriber<String>();
 
         Completable completable = Completable.unsafeCreate(new CompletableSource() {
@@ -4215,7 +4215,7 @@ public void testHookSubscribeStart() throws Throwable {
 
     @Ignore("No unsafeSubscribe")
     @Test
-    public void testHookUnsafeSubscribeStart() {
+    public void hookUnsafeSubscribeStart() {
         /*
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Completable completable = Completable.create(new CompletableOnSubscribe() {

File: src/test/java/io/reactivex/disposables/DisposablesTest.java
Patch:
@@ -32,7 +32,7 @@
 public class DisposablesTest {
 
     @Test
-    public void testUnsubscribeOnlyOnce() {
+    public void unsubscribeOnlyOnce() {
         Runnable dispose = mock(Runnable.class);
         Disposable subscription = Disposables.fromRunnable(dispose);
         subscription.dispose();
@@ -41,15 +41,15 @@ public void testUnsubscribeOnlyOnce() {
     }
 
     @Test
-    public void testEmpty() {
+    public void empty() {
         Disposable empty = Disposables.empty();
         assertFalse(empty.isDisposed());
         empty.dispose();
         assertTrue(empty.isDisposed());
     }
 
     @Test
-    public void testUnsubscribed() {
+    public void unsubscribed() {
         Disposable disposed = Disposables.disposed();
         assertTrue(disposed.isDisposed());
     }

File: src/test/java/io/reactivex/flowable/FlowableCombineLatestTests.java
Patch:
@@ -30,7 +30,7 @@ public class FlowableCombineLatestTests {
      * This won't compile if super/extends isn't done correctly on generics.
      */
     @Test
-    public void testCovarianceOfCombineLatest() {
+    public void covarianceOfCombineLatest() {
         Flowable<HorrorMovie> horrors = Flowable.just(new HorrorMovie());
         Flowable<CoolRating> ratings = Flowable.just(new CoolRating());
 
@@ -66,7 +66,7 @@ public void accept(ExtendedResult t1) {
 
     @Ignore("No longer allowed")
     @Test
-    public void testNullEmitting() throws Exception {
+    public void nullEmitting() throws Exception {
         // FIXME this is no longer allowed
         Flowable<Boolean> nullObservable = BehaviorProcessor.createDefault((Boolean) null);
         Flowable<Boolean> nonNullObservable = BehaviorProcessor.createDefault(true);

File: src/test/java/io/reactivex/flowable/FlowableConversionTest.java
Patch:
@@ -146,7 +146,7 @@ public Flowable<T> apply(final Publisher<T> onSubscribe) {
     }
 
     @Test
-    public void testConversionBetweenObservableClasses() {
+    public void conversionBetweenObservableClasses() {
         final TestObserver<String> to = new TestObserver<String>(new DefaultObserver<String>() {
 
             @Override
@@ -203,7 +203,7 @@ public String apply(String a, String n) {
     }
 
     @Test
-    public void testConvertToConcurrentQueue() {
+    public void convertToConcurrentQueue() {
         final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>(null);
         final AtomicBoolean isFinished = new AtomicBoolean(false);
         ConcurrentLinkedQueue<? extends Integer> queue = Flowable.range(0, 5)

File: src/test/java/io/reactivex/flowable/FlowableDoAfterNextTest.java
Patch:
@@ -26,7 +26,7 @@
 public class FlowableDoAfterNextTest {
 
     @Test
-    public void testIfFunctionThrowsThatNoMoreEventsAreProcessed() {
+    public void ifFunctionThrowsThatNoMoreEventsAreProcessed() {
         final AtomicInteger count = new AtomicInteger();
         final RuntimeException e = new RuntimeException();
         Burst.items(1, 2).create()

File: src/test/java/io/reactivex/flowable/FlowableDoOnTest.java
Patch:
@@ -26,7 +26,7 @@
 public class FlowableDoOnTest {
 
     @Test
-    public void testDoOnEach() {
+    public void doOnEach() {
         final AtomicReference<String> r = new AtomicReference<String>();
         String output = Flowable.just("one").doOnNext(new Consumer<String>() {
             @Override
@@ -40,7 +40,7 @@ public void accept(String v) {
     }
 
     @Test
-    public void testDoOnError() {
+    public void doOnError() {
         final AtomicReference<Throwable> r = new AtomicReference<Throwable>();
         Throwable t = null;
         try {
@@ -61,7 +61,7 @@ public void accept(Throwable v) {
     }
 
     @Test
-    public void testDoOnCompleted() {
+    public void doOnCompleted() {
         final AtomicBoolean r = new AtomicBoolean();
         String output = Flowable.just("one").doOnComplete(new Action() {
             @Override

File: src/test/java/io/reactivex/flowable/FlowableErrorHandlingTests.java
Patch:
@@ -33,7 +33,7 @@ public class FlowableErrorHandlingTests {
      * @throws InterruptedException if the test is interrupted
      */
     @Test
-    public void testOnNextError() throws InterruptedException {
+    public void onNextError() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();
         Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);
@@ -70,7 +70,7 @@ public void onNext(Long args) {
      * @throws InterruptedException if the test is interrupted
      */
     @Test
-    public void testOnNextErrorAcrossThread() throws InterruptedException {
+    public void onNextErrorAcrossThread() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();
         Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);

File: src/test/java/io/reactivex/flowable/FlowableGroupByTests.java
Patch:
@@ -25,7 +25,7 @@
 public class FlowableGroupByTests {
 
     @Test
-    public void testTakeUnsubscribesOnGroupBy() {
+    public void takeUnsubscribesOnGroupBy() {
         Flowable.merge(
             FlowableEventStream.getEventStream("HTTP-ClusterA", 50),
             FlowableEventStream.getEventStream("HTTP-ClusterB", 20)
@@ -50,7 +50,7 @@ public void accept(GroupedFlowable<Object, Event> v) {
     }
 
     @Test
-    public void testTakeUnsubscribesOnFlatMapOfGroupBy() {
+    public void takeUnsubscribesOnFlatMapOfGroupBy() {
         Flowable.merge(
             FlowableEventStream.getEventStream("HTTP-ClusterA", 50),
             FlowableEventStream.getEventStream("HTTP-ClusterB", 20)

File: src/test/java/io/reactivex/flowable/FlowableThrottleLastTests.java
Patch:
@@ -28,7 +28,7 @@
 public class FlowableThrottleLastTests {
 
     @Test
-    public void testThrottle() {
+    public void throttle() {
         Subscriber<Integer> subscriber = TestHelper.mockSubscriber();
 
         TestScheduler s = new TestScheduler();

File: src/test/java/io/reactivex/flowable/FlowableThrottleWithTimeoutTests.java
Patch:
@@ -29,7 +29,7 @@
 public class FlowableThrottleWithTimeoutTests {
 
     @Test
-    public void testThrottle() {
+    public void throttle() {
         Subscriber<Integer> subscriber = TestHelper.mockSubscriber();
 
         TestScheduler s = new TestScheduler();

File: src/test/java/io/reactivex/flowable/FlowableWindowTests.java
Patch:
@@ -25,7 +25,7 @@
 public class FlowableWindowTests {
 
     @Test
-    public void testWindow() {
+    public void window() {
         final ArrayList<List<Integer>> lists = new ArrayList<List<Integer>>();
 
         Flowable.concat(

File: src/test/java/io/reactivex/flowable/FlowableZipTests.java
Patch:
@@ -29,7 +29,7 @@
 public class FlowableZipTests {
 
     @Test
-    public void testZipObservableOfObservables() {
+    public void zipObservableOfObservables() {
         FlowableEventStream.getEventStream("HTTP-ClusterB", 20)
                 .groupBy(new Function<Event, String>() {
                     @Override
@@ -70,7 +70,7 @@ public void accept(HashMap<String, String> v) {
      * This won't compile if super/extends isn't done correctly on generics.
      */
     @Test
-    public void testCovarianceOfZip() {
+    public void covarianceOfZip() {
         Flowable<HorrorMovie> horrors = Flowable.just(new HorrorMovie());
         Flowable<CoolRating> ratings = Flowable.just(new CoolRating());
 

File: src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java
Patch:
@@ -40,7 +40,7 @@ public void delayCustomScheduler() {
     }
 
     @Test
-    public void testOnErrorCalledOnScheduler() throws Exception {
+    public void onErrorCalledOnScheduler() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Thread> thread = new AtomicReference<Thread>();
 

File: src/test/java/io/reactivex/internal/operators/flowable/BufferUntilSubscriberTest.java
Patch:
@@ -28,7 +28,7 @@
 public class BufferUntilSubscriberTest {
 
     @Test
-    public void testIssue1677() throws InterruptedException {
+    public void issue1677() throws InterruptedException {
         final AtomicLong counter = new AtomicLong();
         final Integer[] numbers = new Integer[5000];
         for (int i = 0; i < numbers.length; i++) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAsObservableTest.java
Patch:
@@ -28,7 +28,7 @@
 
 public class FlowableAsObservableTest {
     @Test
-    public void testHiding() {
+    public void hiding() {
         PublishProcessor<Integer> src = PublishProcessor.create();
 
         Flowable<Integer> dst = src.hide();
@@ -48,7 +48,7 @@ public void testHiding() {
     }
 
     @Test
-    public void testHidingError() {
+    public void hidingError() {
         PublishProcessor<Integer> src = PublishProcessor.create();
 
         Flowable<Integer> dst = src.hide();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCastTest.java
Patch:
@@ -26,7 +26,7 @@
 public class FlowableCastTest {
 
     @Test
-    public void testCast() {
+    public void cast() {
         Flowable<?> source = Flowable.just(1, 2);
         Flowable<Integer> flowable = source.cast(Integer.class);
 
@@ -41,7 +41,7 @@ public void testCast() {
     }
 
     @Test
-    public void testCastWithWrongType() {
+    public void castWithWrongType() {
         Flowable<?> source = Flowable.just(1, 2);
         Flowable<Boolean> flowable = source.cast(Boolean.class);
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
Patch:
@@ -52,7 +52,7 @@ public void before() {
     }
 
     @Test
-    public void testDebounceWithCompleted() {
+    public void debounceWithCompleted() {
         Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> subscriber) {
@@ -78,7 +78,7 @@ public void subscribe(Subscriber<? super String> subscriber) {
     }
 
     @Test
-    public void testDebounceNeverEmits() {
+    public void debounceNeverEmits() {
         Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> subscriber) {
@@ -108,7 +108,7 @@ public void subscribe(Subscriber<? super String> subscriber) {
     }
 
     @Test
-    public void testDebounceWithError() {
+    public void debounceWithError() {
         Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> subscriber) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDeferTest.java
Patch:
@@ -28,7 +28,7 @@
 public class FlowableDeferTest {
 
     @Test
-    public void testDefer() throws Throwable {
+    public void defer() throws Throwable {
 
         Supplier<Flowable<String>> factory = mock(Supplier.class);
 
@@ -63,7 +63,7 @@ public void testDefer() throws Throwable {
     }
 
     @Test
-    public void testDeferFunctionThrows() throws Throwable {
+    public void deferFunctionThrows() throws Throwable {
         Supplier<Flowable<String>> factory = mock(Supplier.class);
 
         when(factory.get()).thenThrow(new TestException());

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
Patch:
@@ -52,12 +52,12 @@ private void checkActionCalled(Flowable<String> input) {
     }
 
     @Test
-    public void testDoAfterTerminateCalledOnComplete() {
+    public void doAfterTerminateCalledOnComplete() {
         checkActionCalled(Flowable.fromArray("1", "2", "3"));
     }
 
     @Test
-    public void testDoAfterTerminateCalledOnError() {
+    public void doAfterTerminateCalledOnError() {
         checkActionCalled(Flowable.<String> error(new RuntimeException("expected")));
     }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java
Patch:
@@ -27,7 +27,7 @@
 public class FlowableDoOnRequestTest {
 
     @Test
-    public void testUnsubscribeHappensAgainstParent() {
+    public void unsubscribeHappensAgainstParent() {
         final AtomicBoolean unsubscribed = new AtomicBoolean(false);
         Flowable.just(1).concatWith(Flowable.<Integer>never())
         //
@@ -50,7 +50,7 @@ public void accept(long n) {
     }
 
     @Test
-    public void testDoRequest() {
+    public void doRequest() {
         final List<Long> requests = new ArrayList<Long>();
         Flowable.range(1, 5)
         //

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnSubscribeTest.java
Patch:
@@ -27,7 +27,7 @@
 public class FlowableDoOnSubscribeTest {
 
     @Test
-    public void testDoOnSubscribe() throws Exception {
+    public void doOnSubscribe() throws Exception {
         final AtomicInteger count = new AtomicInteger();
         Flowable<Integer> f = Flowable.just(1).doOnSubscribe(new Consumer<Subscription>() {
             @Override
@@ -43,7 +43,7 @@ public void accept(Subscription s) {
     }
 
     @Test
-    public void testDoOnSubscribe2() throws Exception {
+    public void doOnSubscribe2() throws Exception {
         final AtomicInteger count = new AtomicInteger();
         Flowable<Integer> f = Flowable.just(1).doOnSubscribe(new Consumer<Subscription>() {
             @Override
@@ -62,7 +62,7 @@ public void accept(Subscription s) {
     }
 
     @Test
-    public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
+    public void doOnUnSubscribeWorksWithRefCount() throws Exception {
         final AtomicInteger onSubscribed = new AtomicInteger();
         final AtomicInteger countBefore = new AtomicInteger();
         final AtomicInteger countAfter = new AtomicInteger();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java
Patch:
@@ -30,7 +30,7 @@
 public class FlowableDoOnUnsubscribeTest {
 
     @Test
-    public void testDoOnUnsubscribe() throws Exception {
+    public void doOnUnsubscribe() throws Exception {
         int subCount = 3;
         final CountDownLatch upperLatch = new CountDownLatch(subCount);
         final CountDownLatch lowerLatch = new CountDownLatch(subCount);
@@ -90,7 +90,7 @@ public void run() {
     }
 
     @Test
-    public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
+    public void doOnUnSubscribeWorksWithRefCount() throws Exception {
         int subCount = 3;
         final CountDownLatch upperLatch = new CountDownLatch(1);
         final CountDownLatch lowerLatch = new CountDownLatch(1);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableHideTest.java
Patch:
@@ -28,7 +28,7 @@
 
 public class FlowableHideTest {
     @Test
-    public void testHiding() {
+    public void hiding() {
         PublishProcessor<Integer> src = PublishProcessor.create();
 
         Flowable<Integer> dst = src.hide();
@@ -48,7 +48,7 @@ public void testHiding() {
     }
 
     @Test
-    public void testHidingError() {
+    public void hidingError() {
         PublishProcessor<Integer> src = PublishProcessor.create();
 
         Flowable<Integer> dst = src.hide();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMapNotificationTest.java
Patch:
@@ -28,7 +28,7 @@
 
 public class FlowableMapNotificationTest {
     @Test
-    public void testJust() {
+    public void just() {
         TestSubscriber<Object> ts = new TestSubscriber<Object>();
         Flowable.just(1)
         .flatMap(

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java
Patch:
@@ -48,7 +48,7 @@ public void before() {
     }
 
     @Test
-    public void testSample() {
+    public void sample() {
         Flowable<Long> source = Flowable.unsafeCreate(new Publisher<Long>() {
             @Override
             public void subscribe(final Subscriber<? super Long> subscriber1) {
@@ -268,7 +268,7 @@ public void sampleWithSamplerThrows() {
     }
 
     @Test
-    public void testSampleUnsubscribe() {
+    public void sampleUnsubscribe() {
         final Subscription s = mock(Subscription.class);
         Flowable<Integer> f = Flowable.unsafeCreate(
                 new Publisher<Integer>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimedTest.java
Patch:
@@ -32,7 +32,7 @@
 public class FlowableTakeLastTimedTest {
 
     @Test(expected = IndexOutOfBoundsException.class)
-    public void testTakeLastTimedWithNegativeCount() {
+    public void takeLastTimedWithNegativeCount() {
         Flowable.just("one").takeLast(-1, 1, TimeUnit.SECONDS);
     }
 
@@ -204,7 +204,7 @@ public void takeLastTimedWithZeroCapacity() {
     }
 
     @Test
-    public void testContinuousDelivery() {
+    public void continuousDelivery() {
         TestScheduler scheduler = new TestScheduler();
 
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
Patch:
@@ -30,7 +30,7 @@
 public class FlowableTakeTimedTest {
 
     @Test
-    public void testTakeTimed() {
+    public void takeTimed() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -61,7 +61,7 @@ public void testTakeTimed() {
     }
 
     @Test
-    public void testTakeTimedErrorBeforeTime() {
+    public void takeTimedErrorBeforeTime() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -93,7 +93,7 @@ public void testTakeTimedErrorBeforeTime() {
     }
 
     @Test
-    public void testTakeTimedErrorAfterTime() {
+    public void takeTimedErrorAfterTime() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishProcessor<Integer> source = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicateTest.java
Patch:
@@ -158,7 +158,7 @@ public boolean test(Integer v) {
     }
 
     @Test
-    public void testErrorIncludesLastValueAsCause() {
+    public void errorIncludesLastValueAsCause() {
         TestSubscriberEx<String> ts = new TestSubscriberEx<String>();
         final TestException e = new TestException("Forced failure");
         Predicate<String> predicate = new Predicate<String>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
Patch:
@@ -45,7 +45,7 @@ public void before() {
     }
 
     @Test
-    public void testThrottlingWithCompleted() {
+    public void throttlingWithCompleted() {
         Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> subscriber) {
@@ -73,7 +73,7 @@ public void subscribe(Subscriber<? super String> subscriber) {
     }
 
     @Test
-    public void testThrottlingWithError() {
+    public void throttlingWithError() {
         Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> subscriber) {
@@ -124,7 +124,7 @@ public void run() {
     }
 
     @Test
-    public void testThrottle() {
+    public void throttle() {
         Subscriber<Integer> subscriber = TestHelper.mockSubscriber();
         TestScheduler s = new TestScheduler();
         PublishProcessor<Integer> o = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
Patch:
@@ -48,7 +48,7 @@ public void setUp() {
     }
 
     @Test
-    public void testTimeInterval() {
+    public void timeInterval() {
         InOrder inOrder = inOrder(subscriber);
         flowable.subscribe(subscriber);
 

File: src/test/java/io/reactivex/internal/operators/flowable/NotificationLiteTest.java
Patch:
@@ -26,7 +26,7 @@
 public class NotificationLiteTest {
 
     @Test
-    public void testComplete() {
+    public void complete() {
         Object n = NotificationLite.next("Hello");
         Object c = NotificationLite.complete();
 
@@ -37,7 +37,7 @@ public void testComplete() {
     }
 
     @Test
-    public void testValueKind() {
+    public void valueKind() {
         assertSame(1, NotificationLite.next(1));
     }
 

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToIteratorTest.java
Patch:
@@ -29,7 +29,7 @@
 public class BlockingObservableToIteratorTest {
 
     @Test
-    public void testToIterator() {
+    public void toIterator() {
         Observable<String> obs = Observable.just("one", "two", "three");
 
         Iterator<String> it = obs.blockingIterable().iterator();
@@ -48,7 +48,7 @@ public void testToIterator() {
     }
 
     @Test(expected = TestException.class)
-    public void testToIteratorWithException() {
+    public void toIteratorWithException() {
         Observable<String> obs = Observable.unsafeCreate(new ObservableSource<String>() {
 
             @Override
@@ -70,7 +70,7 @@ public void subscribe(Observer<? super String> observer) {
 
     @Ignore("subscribe() should not throw")
     @Test(expected = TestException.class)
-    public void testExceptionThrownFromOnSubscribe() {
+    public void exceptionThrownFromOnSubscribe() {
         Iterable<String> strings = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> observer) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableBufferUntilSubscriberTest.java
Patch:
@@ -27,7 +27,7 @@
 public class ObservableBufferUntilSubscriberTest {
 
     @Test
-    public void testIssue1677() throws InterruptedException {
+    public void issue1677() throws InterruptedException {
         final AtomicLong counter = new AtomicLong();
         final Integer[] numbers = new Integer[5000];
         for (int i = 0; i < numbers.length; i++) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCastTest.java
Patch:
@@ -23,7 +23,7 @@
 public class ObservableCastTest {
 
     @Test
-    public void testCast() {
+    public void cast() {
         Observable<?> source = Observable.just(1, 2);
         Observable<Integer> observable = source.cast(Integer.class);
 
@@ -39,7 +39,7 @@ public void testCast() {
     }
 
     @Test
-    public void testCastWithWrongType() {
+    public void castWithWrongType() {
         Observable<?> source = Observable.just(1, 2);
         Observable<Boolean> observable = source.cast(Boolean.class);
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
Patch:
@@ -51,7 +51,7 @@ public void before() {
     }
 
     @Test
-    public void testDebounceWithCompleted() {
+    public void debounceWithCompleted() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> observer) {
@@ -77,7 +77,7 @@ public void subscribe(Observer<? super String> observer) {
     }
 
     @Test
-    public void testDebounceNeverEmits() {
+    public void debounceNeverEmits() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> observer) {
@@ -107,7 +107,7 @@ public void subscribe(Observer<? super String> observer) {
     }
 
     @Test
-    public void testDebounceWithError() {
+    public void debounceWithError() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> observer) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDefaultIfEmptyTest.java
Patch:
@@ -25,7 +25,7 @@
 public class ObservableDefaultIfEmptyTest {
 
     @Test
-    public void testDefaultIfEmpty() {
+    public void defaultIfEmpty() {
         Observable<Integer> source = Observable.just(1, 2, 3);
         Observable<Integer> observable = source.defaultIfEmpty(10);
 
@@ -42,7 +42,7 @@ public void testDefaultIfEmpty() {
     }
 
     @Test
-    public void testDefaultIfEmptyWithEmpty() {
+    public void defaultIfEmptyWithEmpty() {
         Observable<Integer> source = Observable.empty();
         Observable<Integer> observable = source.defaultIfEmpty(10);
 
@@ -57,7 +57,7 @@ public void testDefaultIfEmptyWithEmpty() {
 
     @Test
     @Ignore("Subscribers should not throw")
-    public void testEmptyButClientThrows() {
+    public void emptyButClientThrows() {
         final Observer<Integer> o = TestHelper.mockObserver();
 
         Observable.<Integer>empty().defaultIfEmpty(1).subscribe(new DefaultObserver<Integer>() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDeferTest.java
Patch:
@@ -27,7 +27,7 @@
 public class ObservableDeferTest {
 
     @Test
-    public void testDefer() throws Throwable {
+    public void defer() throws Throwable {
 
         Supplier<Observable<String>> factory = mock(Supplier.class);
 
@@ -62,7 +62,7 @@ public void testDefer() throws Throwable {
     }
 
     @Test
-    public void testDeferFunctionThrows() throws Throwable {
+    public void deferFunctionThrows() throws Throwable {
         Supplier<Observable<String>> factory = mock(Supplier.class);
 
         when(factory.get()).thenThrow(new TestException());

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDoOnSubscribeTest.java
Patch:
@@ -30,7 +30,7 @@
 public class ObservableDoOnSubscribeTest {
 
     @Test
-    public void testDoOnSubscribe() throws Exception {
+    public void doOnSubscribe() throws Exception {
         final AtomicInteger count = new AtomicInteger();
         Observable<Integer> o = Observable.just(1).doOnSubscribe(new Consumer<Disposable>() {
             @Override
@@ -46,7 +46,7 @@ public void accept(Disposable d) {
     }
 
     @Test
-    public void testDoOnSubscribe2() throws Exception {
+    public void doOnSubscribe2() throws Exception {
         final AtomicInteger count = new AtomicInteger();
         Observable<Integer> o = Observable.just(1).doOnSubscribe(new Consumer<Disposable>() {
             @Override
@@ -65,7 +65,7 @@ public void accept(Disposable d) {
     }
 
     @Test
-    public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
+    public void doOnUnSubscribeWorksWithRefCount() throws Exception {
         final AtomicInteger onSubscribed = new AtomicInteger();
         final AtomicInteger countBefore = new AtomicInteger();
         final AtomicInteger countAfter = new AtomicInteger();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDoOnUnsubscribeTest.java
Patch:
@@ -30,7 +30,7 @@
 public class ObservableDoOnUnsubscribeTest {
 
     @Test
-    public void testDoOnUnsubscribe() throws Exception {
+    public void doOnUnsubscribe() throws Exception {
         int subCount = 3;
         final CountDownLatch upperLatch = new CountDownLatch(subCount);
         final CountDownLatch lowerLatch = new CountDownLatch(subCount);
@@ -92,7 +92,7 @@ public void run() {
     }
 
     @Test
-    public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
+    public void doOnUnSubscribeWorksWithRefCount() throws Exception {
         int subCount = 3;
         final CountDownLatch upperLatch = new CountDownLatch(1);
         final CountDownLatch lowerLatch = new CountDownLatch(1);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFilterTest.java
Patch:
@@ -30,7 +30,7 @@
 public class ObservableFilterTest {
 
     @Test
-    public void testFilter() {
+    public void filter() {
         Observable<String> w = Observable.just("one", "two", "three");
         Observable<String> observable = w.filter(new Predicate<String>() {
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFinallyTest.java
Patch:
@@ -44,12 +44,12 @@ private void checkActionCalled(Observable<String> input) {
     }
 
     @Test
-    public void testFinallyCalledOnComplete() {
+    public void finallyCalledOnComplete() {
         checkActionCalled(Observable.fromArray("1", "2", "3"));
     }
 
     @Test
-    public void testFinallyCalledOnError() {
+    public void finallyCalledOnError() {
         checkActionCalled(Observable.<String> error(new RuntimeException("expected")));
     }
 }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableHideTest.java
Patch:
@@ -26,7 +26,7 @@
 
 public class ObservableHideTest {
     @Test
-    public void testHiding() {
+    public void hiding() {
         PublishSubject<Integer> src = PublishSubject.create();
 
         Observable<Integer> dst = src.hide();
@@ -46,7 +46,7 @@ public void testHiding() {
     }
 
     @Test
-    public void testHidingError() {
+    public void hidingError() {
         PublishSubject<Integer> src = PublishSubject.create();
 
         Observable<Integer> dst = src.hide();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMapNotificationTest.java
Patch:
@@ -26,7 +26,7 @@
 
 public class ObservableMapNotificationTest {
     @Test
-    public void testJust() {
+    public void just() {
         TestObserver<Object> to = new TestObserver<Object>();
         Observable.just(1)
         .flatMap(

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSampleTest.java
Patch:
@@ -46,7 +46,7 @@ public void before() {
     }
 
     @Test
-    public void testSample() {
+    public void sample() {
         Observable<Long> source = Observable.unsafeCreate(new ObservableSource<Long>() {
             @Override
             public void subscribe(final Observer<? super Long> observer1) {
@@ -266,7 +266,7 @@ public void sampleWithSamplerThrows() {
     }
 
     @Test
-    public void testSampleUnsubscribe() {
+    public void sampleUnsubscribe() {
         final Disposable upstream = mock(Disposable.class);
         Observable<Integer> o = Observable.unsafeCreate(
                 new ObservableSource<Integer>() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimedTest.java
Patch:
@@ -31,7 +31,7 @@
 public class ObservableTakeLastTimedTest {
 
     @Test(expected = IndexOutOfBoundsException.class)
-    public void testTakeLastTimedWithNegativeCount() {
+    public void takeLastTimedWithNegativeCount() {
         Observable.just("one").takeLast(-1, 1, TimeUnit.SECONDS);
     }
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTimedTest.java
Patch:
@@ -29,7 +29,7 @@
 public class ObservableTakeTimedTest {
 
     @Test
-    public void testTakeTimed() {
+    public void takeTimed() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishSubject<Integer> source = PublishSubject.create();
@@ -60,7 +60,7 @@ public void testTakeTimed() {
     }
 
     @Test
-    public void testTakeTimedErrorBeforeTime() {
+    public void takeTimedErrorBeforeTime() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishSubject<Integer> source = PublishSubject.create();
@@ -92,7 +92,7 @@ public void testTakeTimedErrorBeforeTime() {
     }
 
     @Test
-    public void testTakeTimedErrorAfterTime() {
+    public void takeTimedErrorAfterTime() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishSubject<Integer> source = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilPredicateTest.java
Patch:
@@ -140,7 +140,7 @@ public boolean test(Integer v) {
     }
 
     @Test
-    public void testErrorIncludesLastValueAsCause() {
+    public void errorIncludesLastValueAsCause() {
         TestObserverEx<String> to = new TestObserverEx<String>();
         final TestException e = new TestException("Forced failure");
         Predicate<String> predicate = (new Predicate<String>() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
Patch:
@@ -43,7 +43,7 @@ public void before() {
     }
 
     @Test
-    public void testThrottlingWithCompleted() {
+    public void throttlingWithCompleted() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> innerObserver) {
@@ -71,7 +71,7 @@ public void subscribe(Observer<? super String> innerObserver) {
     }
 
     @Test
-    public void testThrottlingWithError() {
+    public void throttlingWithError() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> innerObserver) {
@@ -122,7 +122,7 @@ public void run() {
     }
 
     @Test
-    public void testThrottle() {
+    public void throttle() {
         Observer<Integer> observer = TestHelper.mockObserver();
         TestScheduler s = new TestScheduler();
         PublishSubject<Integer> o = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeIntervalTest.java
Patch:
@@ -47,7 +47,7 @@ public void setUp() {
     }
 
     @Test
-    public void testTimeInterval() {
+    public void timeInterval() {
         InOrder inOrder = inOrder(observer);
         observable.subscribe(observer);
 

File: src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java
Patch:
@@ -136,7 +136,7 @@ public void delaySubscriptionTimeCustomScheduler() throws Exception {
     }
 
     @Test
-    public void testOnErrorCalledOnScheduler() throws Exception {
+    public void onErrorCalledOnScheduler() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Thread> thread = new AtomicReference<Thread>();
 

File: src/main/java/io/reactivex/CompletableConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.annotations.*;
 
 /**
- * Convenience interface and callback used by the {@link Completable#as} operator to turn a Completable into another
+ * Convenience interface and callback used by the {@link Completable#to} operator to turn a Completable into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <R> the output type

File: src/main/java/io/reactivex/FlowableConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.annotations.*;
 
 /**
- * Convenience interface and callback used by the {@link Flowable#as} operator to turn a Flowable into another
+ * Convenience interface and callback used by the {@link Flowable#to} operator to turn a Flowable into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type

File: src/main/java/io/reactivex/MaybeConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.annotations.*;
 
 /**
- * Convenience interface and callback used by the {@link Maybe#as} operator to turn a Maybe into another
+ * Convenience interface and callback used by the {@link Maybe#to} operator to turn a Maybe into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type

File: src/main/java/io/reactivex/ObservableConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.annotations.*;
 
 /**
- * Convenience interface and callback used by the {@link Observable#as} operator to turn an Observable into another
+ * Convenience interface and callback used by the {@link Observable#to} operator to turn an Observable into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type

File: src/main/java/io/reactivex/SingleConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.annotations.*;
 
 /**
- * Convenience interface and callback used by the {@link Single#as} operator to turn a Single into another
+ * Convenience interface and callback used by the {@link Single#to} operator to turn a Single into another
  * value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type

File: src/main/java/io/reactivex/parallel/ParallelFlowableConverter.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.annotations.*;
 
 /**
- * Convenience interface and callback used by the {@link ParallelFlowable#as} operator to turn a ParallelFlowable into
+ * Convenience interface and callback used by the {@link ParallelFlowable#to} operator to turn a ParallelFlowable into
  * another value fluently.
  * <p>History: 2.1.7 - experimental
  * @param <T> the upstream type

File: src/test/java/io/reactivex/flowable/FlowableConversionTest.java
Patch:
@@ -131,9 +131,9 @@ public void subscribe(Subscriber<? super R> subscriber) {
         }
     }
 
-    public static class ConvertToCylonDetector<T> implements Function<Publisher<T>, CylonDetectorObservable<T>> {
+    public static class ConvertToCylonDetector<T> implements FlowableConverter<T, CylonDetectorObservable<T>> {
         @Override
-        public CylonDetectorObservable<T> apply(final Publisher<T> onSubscribe) {
+        public CylonDetectorObservable<T> apply(final Flowable<T> onSubscribe) {
             return CylonDetectorObservable.create(onSubscribe);
         }
     }
@@ -225,7 +225,7 @@ public Integer apply(Integer k) {
                                 });
                     }
                 })
-                    .to(new Function<Flowable<Integer>, ConcurrentLinkedQueue<Integer>>() {
+                    .to(new FlowableConverter<Integer, ConcurrentLinkedQueue<Integer>>() {
                         @Override
                         public ConcurrentLinkedQueue<Integer> apply(Flowable<Integer> onSubscribe) {
                             final ConcurrentLinkedQueue<Integer> q = new ConcurrentLinkedQueue<Integer>();

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -1118,7 +1118,7 @@ public void testForEachWithNull() {
     public void testExtend() {
         final TestSubscriber<Object> subscriber = new TestSubscriber<Object>();
         final Object value = new Object();
-        Object returned = Flowable.just(value).to(new Function<Flowable<Object>, Object>() {
+        Object returned = Flowable.just(value).to(new FlowableConverter<Object, Object>() {
             @Override
             public Object apply(Flowable<Object> onSubscribe) {
                     onSubscribe.subscribe(subscriber);
@@ -1135,7 +1135,7 @@ public Object apply(Flowable<Object> onSubscribe) {
     public void testAsExtend() {
         final TestSubscriber<Object> subscriber = new TestSubscriber<Object>();
         final Object value = new Object();
-        Object returned = Flowable.just(value).as(new FlowableConverter<Object, Object>() {
+        Object returned = Flowable.just(value).to(new FlowableConverter<Object, Object>() {
             @Override
             public Object apply(Flowable<Object> onSubscribe) {
                     onSubscribe.subscribe(subscriber);
@@ -1150,7 +1150,7 @@ public Object apply(Flowable<Object> onSubscribe) {
 
     @Test
     public void as() {
-        Flowable.just(1).as(new FlowableConverter<Integer, Observable<Integer>>() {
+        Flowable.just(1).to(new FlowableConverter<Integer, Observable<Integer>>() {
             @Override
             public Observable<Integer> apply(Flowable<Integer> v) {
                 return v.toObservable();

File: src/test/java/io/reactivex/observable/ObservableTest.java
Patch:
@@ -1155,7 +1155,7 @@ public void testForEachWithNull() {
     public void testExtend() {
         final TestObserver<Object> to = new TestObserver<Object>();
         final Object value = new Object();
-        Object returned = Observable.just(value).to(new Function<Observable<Object>, Object>() {
+        Object returned = Observable.just(value).to(new ObservableConverter<Object, Object>() {
             @Override
             public Object apply(Observable<Object> onSubscribe) {
                     onSubscribe.subscribe(to);
@@ -1172,7 +1172,7 @@ public Object apply(Observable<Object> onSubscribe) {
     public void testAsExtend() {
         final TestObserver<Object> to = new TestObserver<Object>();
         final Object value = new Object();
-        Object returned = Observable.just(value).as(new ObservableConverter<Object, Object>() {
+        Object returned = Observable.just(value).to(new ObservableConverter<Object, Object>() {
             @Override
             public Object apply(Observable<Object> onSubscribe) {
                 onSubscribe.subscribe(to);
@@ -1187,7 +1187,7 @@ public Object apply(Observable<Object> onSubscribe) {
 
     @Test
     public void as() {
-        Observable.just(1).as(new ObservableConverter<Integer, Flowable<Integer>>() {
+        Observable.just(1).to(new ObservableConverter<Integer, Flowable<Integer>>() {
             @Override
             public Flowable<Integer> apply(Observable<Integer> v) {
                 return v.toFlowable(BackpressureStrategy.MISSING);

File: src/main/java/io/reactivex/functions/Action.java
Patch:
@@ -19,7 +19,7 @@
 public interface Action {
     /**
      * Runs the action and optionally throws a checked exception.
-     * @throws Exception if the implementation wishes to throw a checked exception
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    void run() throws Exception;
+    void run() throws Throwable;
 }

File: src/main/java/io/reactivex/functions/BiConsumer.java
Patch:
@@ -24,7 +24,7 @@ public interface BiConsumer<T1, T2> {
      * Performs an operation on the given values.
      * @param t1 the first value
      * @param t2 the second value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    void accept(T1 t1, T2 t2) throws Exception;
+    void accept(T1 t1, T2 t2) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/BiFunction.java
Patch:
@@ -28,8 +28,8 @@ public interface BiFunction<T1, T2, R> {
      * @param t1 the first value
      * @param t2 the second value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/BiPredicate.java
Patch:
@@ -27,7 +27,7 @@ public interface BiPredicate<T1, T2> {
      * @param t1 the first value
      * @param t2 the second value
      * @return the boolean result
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    boolean test(@NonNull T1 t1, @NonNull T2 t2) throws Exception;
+    boolean test(@NonNull T1 t1, @NonNull T2 t2) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/BooleanSupplier.java
Patch:
@@ -20,7 +20,7 @@ public interface BooleanSupplier {
     /**
      * Returns a boolean value.
      * @return a boolean value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    boolean getAsBoolean() throws Exception; // NOPMD
+    boolean getAsBoolean() throws Throwable; // NOPMD
 }

File: src/main/java/io/reactivex/functions/Cancellable.java
Patch:
@@ -21,7 +21,7 @@ public interface Cancellable {
 
     /**
      * Cancel the action or free a resource.
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    void cancel() throws Exception;
+    void cancel() throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Consumer.java
Patch:
@@ -21,7 +21,7 @@ public interface Consumer<T> {
     /**
      * Consume the given value.
      * @param t the value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    void accept(T t) throws Exception;
+    void accept(T t) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function.java
Patch:
@@ -27,7 +27,7 @@ public interface Function<T, R> {
      * Apply some calculation to the input value and return some other value.
      * @param t the input value
      * @return the output value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    R apply(@NonNull T t) throws Exception;
+    R apply(@NonNull T t) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function3.java
Patch:
@@ -29,8 +29,8 @@ public interface Function3<T1, T2, T3, R> {
      * @param t2 the second value
      * @param t3 the third value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function4.java
Patch:
@@ -31,8 +31,8 @@ public interface Function4<T1, T2, T3, T4, R> {
      * @param t3 the third value
      * @param t4 the fourth value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function5.java
Patch:
@@ -33,8 +33,8 @@ public interface Function5<T1, T2, T3, T4, T5, R> {
      * @param t4 the fourth value
      * @param t5 the fifth value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function6.java
Patch:
@@ -35,8 +35,8 @@ public interface Function6<T1, T2, T3, T4, T5, T6, R> {
      * @param t5 the fifth value
      * @param t6 the sixth value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function7.java
Patch:
@@ -37,8 +37,8 @@ public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {
      * @param t6 the sixth value
      * @param t7 the seventh value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function8.java
Patch:
@@ -39,8 +39,8 @@ public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
      * @param t7 the seventh value
      * @param t8 the eighth value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7, @NonNull T8 t8) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7, @NonNull T8 t8) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Function9.java
Patch:
@@ -41,8 +41,8 @@ public interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
      * @param t8 the eighth value
      * @param t9 the ninth value
      * @return the result value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7, @NonNull T8 t8, @NonNull T9 t9) throws Exception;
+    R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7, @NonNull T8 t8, @NonNull T9 t9) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/IntFunction.java
Patch:
@@ -23,8 +23,8 @@ public interface IntFunction<T> {
      * Calculates a value based on a primitive integer input.
      * @param i the input value
      * @return the result Object
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
     @NonNull
-    T apply(int i) throws Exception;
+    T apply(int i) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/LongConsumer.java
Patch:
@@ -19,7 +19,7 @@ public interface LongConsumer {
     /**
      * Consume a primitive long input.
      * @param t the primitive long value
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    void accept(long t) throws Exception;
+    void accept(long t) throws Throwable;
 }

File: src/main/java/io/reactivex/functions/Predicate.java
Patch:
@@ -24,7 +24,7 @@ public interface Predicate<T> {
      * Test the given input value and return a boolean.
      * @param t the value
      * @return the boolean result
-     * @throws Exception on error
+     * @throws Throwable if the implementation wishes to throw any type of exception
      */
-    boolean test(@NonNull T t) throws Exception;
+    boolean test(@NonNull T t) throws Throwable;
 }

File: src/main/java/io/reactivex/internal/disposables/CancellableDisposable.java
Patch:
@@ -46,7 +46,7 @@ public void dispose() {
             if (c != null) {
                 try {
                     c.cancel();
-                } catch (Exception ex) {
+                } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
                     RxJavaPlugins.onError(ex);
                 }

File: src/main/java/io/reactivex/internal/fuseable/SimpleQueue.java
Patch:
@@ -48,11 +48,11 @@ public interface SimpleQueue<T> {
      * item, the second poll() is guaranteed to return a non-null item
      * as well.
      * @return the item or null to indicate an empty queue
-     * @throws Exception if some pre-processing of the dequeued
+     * @throws Throwable if some pre-processing of the dequeued
      * item (usually through fused functions) throws.
      */
     @Nullable
-    T poll() throws Exception;
+    T poll() throws Throwable;
 
     /**
      * Returns true if the queue is empty.

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -466,7 +466,7 @@ public int requestFusion(int requestedMode) {
         @Nullable
         @SuppressWarnings("unchecked")
         @Override
-        public R poll() throws Exception {
+        public R poll() throws Throwable {
             Object e = queue.poll();
             if (e == null) {
                 return null;
@@ -550,7 +550,7 @@ public void requestOne() {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return combiner.apply(new Object[] { t });
         }
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
Patch:
@@ -109,7 +109,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             for (;;) {
                 T v = qs.poll();
                 if (v == null) {
@@ -199,7 +199,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             for (;;) {
                 T v = qs.poll();
                 if (v == null) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoAfterNext.java
Patch:
@@ -77,7 +77,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = qs.poll();
             if (v != null) {
                 onAfterNext.accept(v);
@@ -126,7 +126,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = qs.poll();
             if (v != null) {
                 onAfterNext.accept(v);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoFinally.java
Patch:
@@ -132,7 +132,7 @@ public boolean isEmpty() {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = qs.poll();
             if (v == null && syncFused) {
                 runFinally();
@@ -242,7 +242,7 @@ public boolean isEmpty() {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = qs.poll();
             if (v == null && syncFused) {
                 runFinally();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -149,7 +149,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v;
 
             try {
@@ -304,7 +304,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v;
 
             try {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableEmpty.java
Patch:
@@ -16,13 +16,13 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 
 /**
  * A source Flowable that signals an onSubscribe() + onComplete() only.
  */
-public final class FlowableEmpty extends Flowable<Object> implements ScalarCallable<Object> {
+public final class FlowableEmpty extends Flowable<Object> implements ScalarSupplier<Object> {
 
     public static final Flowable<Object> INSTANCE = new FlowableEmpty();
 
@@ -35,7 +35,7 @@ public void subscribeActual(Subscriber<? super Object> s) {
     }
 
     @Override
-    public Object call() {
+    public Object get() {
         return null; // null scalar is interpreted as being empty
     }
 }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -83,7 +83,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             QueueSubscription<T> qs = this.qs;
             Predicate<? super T> f = filter;
 
@@ -146,7 +146,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             QueueSubscription<T> qs = this.qs;
             Predicate<? super T> f = filter;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -67,7 +67,7 @@ protected void subscribeActual(Subscriber<? super GroupedFlowable<K, V>> s) {
                 Consumer<Object> evictionAction = (Consumer) new EvictionAction<K, V>(evictedGroups);
                 groups = (Map) mapFactory.apply(evictionAction);
             }
-        } catch (Exception e) {
+        } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             s.onSubscribe(EmptyComponent.INSTANCE);
             s.onError(e);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableJust.java
Patch:
@@ -16,14 +16,14 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 import io.reactivex.internal.subscriptions.ScalarSubscription;
 
 /**
  * Represents a constant scalar value.
  * @param <T> the value type
  */
-public final class FlowableJust<T> extends Flowable<T> implements ScalarCallable<T> {
+public final class FlowableJust<T> extends Flowable<T> implements ScalarSupplier<T> {
     private final T value;
     public FlowableJust(final T value) {
         this.value = value;
@@ -35,7 +35,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
     }
 
     @Override
-    public T call() {
+    public T get() {
         return value;
     }
 }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
Patch:
@@ -75,7 +75,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public U poll() throws Exception {
+        public U poll() throws Throwable {
             T t = qs.poll();
             return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;
         }
@@ -135,7 +135,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public U poll() throws Exception {
+        public U poll() throws Throwable {
             T t = qs.poll();
             return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -468,7 +468,7 @@ void runBackfused() {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = queue.poll();
             if (v != null && sourceMode != SYNC) {
                 long p = produced + 1;
@@ -712,7 +712,7 @@ void runBackfused() {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = queue.poll();
             if (v != null && sourceMode != SYNC) {
                 long p = consumed + 1;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java
Patch:
@@ -296,7 +296,7 @@ void dispose() {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return ObjectHelper.requireNonNull(combiner.apply(new Object[] { t }), "The combiner returned a null value");
         }
     }

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeEmpty.java
Patch:
@@ -15,12 +15,12 @@
 
 import io.reactivex.*;
 import io.reactivex.internal.disposables.EmptyDisposable;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 
 /**
  * Signals an onComplete.
  */
-public final class MaybeEmpty extends Maybe<Object> implements ScalarCallable<Object> {
+public final class MaybeEmpty extends Maybe<Object> implements ScalarSupplier<Object> {
 
     public static final MaybeEmpty INSTANCE = new MaybeEmpty();
 
@@ -30,7 +30,7 @@ protected void subscribeActual(MaybeObserver<? super Object> observer) {
     }
 
     @Override
-    public Object call() {
+    public Object get() {
         return null; // nulls of ScalarCallable are considered empty sources
     }
 }

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatten.java
Patch:
@@ -86,7 +86,7 @@ public void onSuccess(T value) {
 
             try {
                 source = ObjectHelper.requireNonNull(mapper.apply(value), "The mapper returned a null MaybeSource");
-            } catch (Exception ex) {
+            } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 downstream.onError(ex);
                 return;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFromCallable.java
Patch:
@@ -18,14 +18,15 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Supplier;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * Executes a callable and signals its value as success or signals an exception.
  *
  * @param <T> the value type
  */
-public final class MaybeFromCallable<T> extends Maybe<T> implements Callable<T> {
+public final class MaybeFromCallable<T> extends Maybe<T> implements Supplier<T> {
 
     final Callable<? extends T> callable;
 
@@ -65,7 +66,7 @@ protected void subscribeActual(MaybeObserver<? super T> observer) {
     }
 
     @Override
-    public T call() throws Exception {
+    public T get() throws Exception {
         return callable.call();
     }
 }

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeJust.java
Patch:
@@ -15,14 +15,14 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposables;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 
 /**
  * Signals a constant value.
  *
  * @param <T> the value type
  */
-public final class MaybeJust<T> extends Maybe<T> implements ScalarCallable<T> {
+public final class MaybeJust<T> extends Maybe<T> implements ScalarSupplier<T> {
 
     final T value;
 
@@ -37,7 +37,7 @@ protected void subscribeActual(MaybeObserver<? super T> observer) {
     }
 
     @Override
-    public T call() {
+    public T get() {
         return value;
     }
 }

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java
Patch:
@@ -189,7 +189,7 @@ public void onComplete() {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return ObjectHelper.requireNonNull(zipper.apply(new Object[] { t }), "The zipper returned a null value");
         }
     }

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java
Patch:
@@ -81,7 +81,7 @@ protected void subscribeActual(MaybeObserver<? super R> observer) {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return ObjectHelper.requireNonNull(zipper.apply(new Object[] { t }), "The zipper returned a null value");
         }
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinctUntilChanged.java
Patch:
@@ -92,7 +92,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             for (;;) {
                 T v = qd.poll();
                 if (v == null) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoAfterNext.java
Patch:
@@ -67,7 +67,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = qd.poll();
             if (v != null) {
                 onAfterNext.accept(v);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoFinally.java
Patch:
@@ -128,7 +128,7 @@ public boolean isEmpty() {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             T v = qd.poll();
             if (v == null && syncFused) {
                 runFinally();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableEmpty.java
Patch:
@@ -15,9 +15,9 @@
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.internal.disposables.EmptyDisposable;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 
-public final class ObservableEmpty extends Observable<Object> implements ScalarCallable<Object> {
+public final class ObservableEmpty extends Observable<Object> implements ScalarSupplier<Object> {
     public static final Observable<Object> INSTANCE = new ObservableEmpty();
 
     private ObservableEmpty() {
@@ -29,7 +29,7 @@ protected void subscribeActual(Observer<? super Object> o) {
     }
 
     @Override
-    public Object call() {
+    public Object get() {
         return null; // null scalar is interpreted as being empty
     }
 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java
Patch:
@@ -63,7 +63,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             for (;;) {
                 T v = qd.poll();
                 if (v == null || filter.test(v)) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableJust.java
Patch:
@@ -14,14 +14,14 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 import io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarDisposable;
 
 /**
  * Represents a constant scalar value.
  * @param <T> the value type
  */
-public final class ObservableJust<T> extends Observable<T> implements ScalarCallable<T> {
+public final class ObservableJust<T> extends Observable<T> implements ScalarSupplier<T> {
 
     private final T value;
     public ObservableJust(final T value) {
@@ -36,7 +36,7 @@ protected void subscribeActual(Observer<? super T> observer) {
     }
 
     @Override
-    public T call() {
+    public T get() {
         return value;
     }
 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
Patch:
@@ -69,7 +69,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public U poll() throws Exception {
+        public U poll() throws Throwable {
             T t = qd.poll();
             return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;
         }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableObserveOn.java
Patch:
@@ -304,7 +304,7 @@ public int requestFusion(int mode) {
 
         @Nullable
         @Override
-        public T poll() throws Exception {
+        public T poll() throws Throwable {
             return queue.poll();
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromMany.java
Patch:
@@ -285,7 +285,7 @@ public void dispose() {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return ObjectHelper.requireNonNull(combiner.apply(new Object[] { t }), "The combiner returned a null value");
         }
     }

File: src/main/java/io/reactivex/internal/operators/single/SingleZipArray.java
Patch:
@@ -178,7 +178,7 @@ public void onError(Throwable e) {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return ObjectHelper.requireNonNull(zipper.apply(new Object[] { t }), "The zipper returned a null value");
         }
     }

File: src/main/java/io/reactivex/internal/operators/single/SingleZipIterable.java
Patch:
@@ -81,7 +81,7 @@ protected void subscribeActual(SingleObserver<? super R> observer) {
 
     final class SingletonArrayFunc implements Function<T, R> {
         @Override
-        public R apply(T t) throws Exception {
+        public R apply(T t) throws Throwable {
             return ObjectHelper.requireNonNull(zipper.apply(new Object[] { t }), "The zipper returned a null value");
         }
     }

File: src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
Patch:
@@ -158,10 +158,10 @@ public <U> boolean accept(Observer<? super U> observer) {
      * @param <S> the extra state type
      * @param state the extra state passed into the consumer
      * @param consumer the consumer of values that returns true if the forEach should terminate
-     * @throws Exception if the predicate throws
+     * @throws Throwable if the predicate throws
      */
     @SuppressWarnings("unchecked")
-    public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Exception {
+    public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Throwable {
         Object[] a = head;
         final int c = capacity;
         for (;;) {

File: src/main/java/io/reactivex/observers/BaseTestConsumer.java
Patch:
@@ -326,7 +326,7 @@ public final U assertError(Predicate<Throwable> errorPredicate) {
                     found = true;
                     break;
                 }
-            } catch (Exception ex) {
+            } catch (Throwable ex) {
                 throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
@@ -421,7 +421,7 @@ public final U assertNever(Predicate<? super T> valuePredicate) {
                 if (valuePredicate.test(v)) {
                     throw fail("Value at position " + i + " matches predicate " + valuePredicate.toString() + ", which was not expected.");
                 }
-            } catch (Exception ex) {
+            } catch (Throwable ex) {
                 throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
@@ -481,7 +481,7 @@ public final U assertValueAt(int index, Predicate<T> valuePredicate) {
             if (valuePredicate.test(values.get(index))) {
                 found = true;
             }
-        } catch (Exception ex) {
+        } catch (Throwable ex) {
             throw ExceptionHelper.wrapOrThrow(ex);
         }
 

File: src/main/java/io/reactivex/parallel/ParallelFlowable.java
Patch:
@@ -14,7 +14,6 @@
 package io.reactivex.parallel;
 
 import java.util.*;
-import java.util.concurrent.Callable;
 
 import io.reactivex.*;
 import io.reactivex.annotations.*;
@@ -330,7 +329,7 @@ public final Flowable<T> reduce(@NonNull BiFunction<T, T, T> reducer) {
      */
     @CheckReturnValue
     @NonNull
-    public final <R> ParallelFlowable<R> reduce(@NonNull Callable<R> initialSupplier, @NonNull BiFunction<R, ? super T, R> reducer) {
+    public final <R> ParallelFlowable<R> reduce(@NonNull Supplier<R> initialSupplier, @NonNull BiFunction<R, ? super T, R> reducer) {
         ObjectHelper.requireNonNull(initialSupplier, "initialSupplier");
         ObjectHelper.requireNonNull(reducer, "reducer");
         return RxJavaPlugins.onAssembly(new ParallelReduce<T, R>(this, initialSupplier, reducer));
@@ -738,7 +737,7 @@ public final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) {
      */
     @CheckReturnValue
     @NonNull
-    public final <C> ParallelFlowable<C> collect(@NonNull Callable<? extends C> collectionSupplier, @NonNull BiConsumer<? super C, ? super T> collector) {
+    public final <C> ParallelFlowable<C> collect(@NonNull Supplier<? extends C> collectionSupplier, @NonNull BiConsumer<? super C, ? super T> collector) {
         ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");
         ObjectHelper.requireNonNull(collector, "collector is null");
         return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));

File: src/test/java/io/reactivex/TestHelper.java
Patch:
@@ -2998,7 +2998,7 @@ public boolean offer(T v1, T v2) {
             }
 
             @Override
-            public T poll() throws Exception {
+            public T poll() throws Throwable {
                 return qs.poll();
             }
 
@@ -3103,7 +3103,7 @@ public boolean offer(T v1, T v2) {
             }
 
             @Override
-            public T poll() throws Exception {
+            public T poll() throws Throwable {
                 return qd.poll();
             }
 

File: src/test/java/io/reactivex/flowable/FlowableMergeTests.java
Patch:
@@ -16,13 +16,13 @@
 import static org.junit.Assert.*;
 
 import java.util.List;
-import java.util.concurrent.Callable;
 
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 
 import io.reactivex.Flowable;
 import io.reactivex.flowable.FlowableCovarianceTest.*;
+import io.reactivex.functions.Supplier;
 
 public class FlowableMergeTests {
 
@@ -76,9 +76,9 @@ public void testMergeCovariance3() {
     @Test
     public void testMergeCovariance4() {
 
-        Flowable<Movie> f1 = Flowable.defer(new Callable<Publisher<Movie>>() {
+        Flowable<Movie> f1 = Flowable.defer(new Supplier<Publisher<Movie>>() {
             @Override
-            public Publisher<Movie> call() {
+            public Publisher<Movie> get() {
                 return Flowable.just(
                         new HorrorMovie(),
                         new Movie()

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
Patch:
@@ -133,7 +133,7 @@ public void accept(String v) {
     }
 
     @Test
-    public void testUnsubscribeSource() throws Exception {
+    public void testUnsubscribeSource() throws Throwable {
         Action unsubscribe = mock(Action.class);
         Flowable<Integer> f = Flowable.just(1).doOnCancel(unsubscribe).cache();
         f.subscribe();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
Patch:
@@ -84,7 +84,7 @@ public void nullFinallyActionShouldBeCheckedASAP() {
     }
 
     @Test
-    public void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() throws Exception {
+    public void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() throws Throwable {
         List<Throwable> errors = TestHelper.trackPluginErrors();
         try {
             Action finallyAction = Mockito.mock(Action.class);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java
Patch:
@@ -1057,7 +1057,7 @@ public void badRequest() {
     }
 
     @Test
-    public void fusedCurrentIteratorEmpty() throws Exception {
+    public void fusedCurrentIteratorEmpty() throws Throwable {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0);
         FlattenIterableSubscriber<Integer, Integer> f = new FlattenIterableSubscriber<Integer, Integer>(ts,
                 Functions.justFunction(Arrays.<Integer>asList(1, 2)), 128);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromArrayTest.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.*;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.functions.Functions;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableFromArrayTest {
@@ -101,7 +101,7 @@ public void empty() {
     @Test
     public void just() {
         Flowable<Integer> source = Flowable.fromArray(new Integer[] { 1 });
-        Assert.assertTrue(source.getClass().toString(), source instanceof ScalarCallable);
+        Assert.assertTrue(source.getClass().toString(), source instanceof ScalarSupplier);
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
Patch:
@@ -580,7 +580,7 @@ public void onSubscribe(Subscription s) {
 
                 try {
                     assertEquals(1, qs.poll().intValue());
-                } catch (Exception ex) {
+                } catch (Throwable ex) {
                     throw new AssertionError(ex);
                 }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupJoinTest.java
Patch:
@@ -68,7 +68,7 @@ public Flowable<R> apply(T t1) {
         public Flowable<Integer> apply(final Integer leftValue, Flowable<Integer> rightValues) {
             return rightValues.map(new Function<Integer, Integer>() {
                 @Override
-                public Integer apply(Integer rightValue) throws Exception {
+                public Integer apply(Integer rightValue) throws Throwable {
                     return add.apply(leftValue, rightValue);
                 }
             });

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
Patch:
@@ -273,7 +273,7 @@ public void onSubscribe(Subscription s) {
 
                 try {
                     assertNull(qs.poll());
-                } catch (Exception ex) {
+                } catch (Throwable ex) {
                     throw new AssertionError(ex);
                 }
 
@@ -285,7 +285,7 @@ public void onSubscribe(Subscription s) {
 
                 try {
                     assertNull(qs.poll());
-                } catch (Exception ex) {
+                } catch (Throwable ex) {
                     throw new AssertionError(ex);
                 }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReduceWithSingleTest.java
Patch:
@@ -24,7 +24,7 @@ public class FlowableReduceWithSingleTest {
     @Test
     public void normal() {
         Flowable.range(1, 5)
-        .reduceWith(Functions.justCallable(1), new BiFunction<Integer, Integer, Integer>() {
+        .reduceWith(Functions.justSupplier(1), new BiFunction<Integer, Integer, Integer>() {
             @Override
             public Integer apply(Integer a, Integer b) throws Exception {
                 return a + b;
@@ -37,7 +37,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
     @Test
     public void disposed() {
         TestHelper.checkDisposed(Flowable.range(1, 5)
-        .reduceWith(Functions.justCallable(1), new BiFunction<Integer, Integer, Integer>() {
+        .reduceWith(Functions.justSupplier(1), new BiFunction<Integer, Integer, Integer>() {
             @Override
             public Integer apply(Integer a, Integer b) throws Exception {
                 return a + b;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
Patch:
@@ -548,10 +548,10 @@ public void accept(Subscription s) {
                             .flatMap(new Function<Long, Publisher<String>>() {
                                 @Override
                                 public Publisher<String> apply(Long t1) {
-                                        return Flowable.defer(new Callable<Publisher<String>>() {
+                                        return Flowable.defer(new Supplier<Publisher<String>>() {
                                             @Override
-                                            public Publisher<String> call() {
-                                                    return Flowable.<String>error(new TestException("Some exception"));
+                                            public Publisher<String> get() {
+                                                return Flowable.<String>error(new TestException("Some exception"));
                                             }
                                         });
                                 }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java
Patch:
@@ -111,9 +111,9 @@ public Flowable<Integer> apply(Integer t1) {
             }
         };
 
-        Callable<Flowable<Integer>> firstTimeoutFunc = new Callable<Flowable<Integer>>() {
+        Supplier<Flowable<Integer>> firstTimeoutFunc = new Supplier<Flowable<Integer>>() {
             @Override
-            public Flowable<Integer> call() {
+            public Flowable<Integer> get() {
                 throw new TestException();
             }
         };

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithStartEndFlowableTest.java
Patch:
@@ -112,10 +112,10 @@ public void subscribe(Subscriber<? super String> subscriber) {
             }
         });
 
-        Callable<Flowable<Object>> closer = new Callable<Flowable<Object>>() {
+        Supplier<Flowable<Object>> closer = new Supplier<Flowable<Object>>() {
             int calls;
             @Override
-            public Flowable<Object> call() {
+            public Flowable<Object> get() {
                 return Flowable.unsafeCreate(new Publisher<Object>() {
                     @Override
                     public void subscribe(Subscriber<? super Object> subscriber) {

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeHideTest.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.internal.fuseable.ScalarSupplier;
 import io.reactivex.processors.PublishProcessor;
 
 public class MaybeHideTest {
@@ -51,9 +51,9 @@ public void error() {
 
     @Test
     public void hidden() {
-        assertTrue(Maybe.just(1) instanceof ScalarCallable);
+        assertTrue(Maybe.just(1) instanceof ScalarSupplier);
 
-        assertFalse(Maybe.just(1).hide() instanceof ScalarCallable);
+        assertFalse(Maybe.just(1).hide() instanceof ScalarSupplier);
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCacheTest.java
Patch:
@@ -107,7 +107,7 @@ public void accept(String v) {
     }
 
     @Test
-    public void testUnsubscribeSource() throws Exception {
+    public void testUnsubscribeSource() throws Throwable {
         Action unsubscribe = mock(Action.class);
         Observable<Integer> o = Observable.just(1).doOnDispose(unsubscribe).cache();
         o.subscribe();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
Patch:
@@ -57,7 +57,7 @@ public void fromArrayEmpty() {
 
     @Test
     public void fromArraySingle() {
-        assertTrue(Observable.fromArray(1) instanceof ScalarCallable);
+        assertTrue(Observable.fromArray(1) instanceof ScalarSupplier);
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/observable/ObservableGroupJoinTest.java
Patch:
@@ -70,7 +70,7 @@ public Observable<R> apply(T t1) {
         public Observable<Integer> apply(final Integer leftValue, Observable<Integer> rightValues) {
             return rightValues.map(new Function<Integer, Integer>() {
                 @Override
-                public Integer apply(Integer rightValue) throws Exception {
+                public Integer apply(Integer rightValue) throws Throwable {
                     return add.apply(leftValue, rightValue);
                 }
             });

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReduceTest.java
Patch:
@@ -18,7 +18,6 @@
 import static org.mockito.Mockito.*;
 
 import java.util.List;
-import java.util.concurrent.Callable;
 
 import org.junit.*;
 
@@ -243,9 +242,9 @@ public void testBackpressureWithInitialValue() throws InterruptedException {
     @Test
     public void reduceWithSingle() {
         Observable.range(1, 5)
-        .reduceWith(new Callable<Integer>() {
+        .reduceWith(new Supplier<Integer>() {
             @Override
-            public Integer call() throws Exception {
+            public Integer get() throws Exception {
                 return 0;
             }
         }, new BiFunction<Integer, Integer, Integer>() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -527,9 +527,9 @@ public void accept(Disposable d) {
                         .flatMap(new Function<Long, Observable<String>>() {
                             @Override
                             public Observable<String> apply(Long t1) {
-                                    return Observable.defer(new Callable<Observable<String>>() {
+                                    return Observable.defer(new Supplier<Observable<String>>() {
                                         @Override
-                                        public Observable<String> call() {
+                                        public Observable<String> get() {
                                                 return Observable.<String>error(new Exception("Some exception"));
                                         }
                                     });

File: src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleLatestTest.java
Patch:
@@ -181,7 +181,7 @@ public void normalEmitLast() {
     }
 
     @Test
-    public void take() throws Exception {
+    public void take() throws Throwable {
         Action onCancel = mock(Action.class);
 
         Observable.range(1, 5)

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutWithSelectorTest.java
Patch:
@@ -111,9 +111,9 @@ public Observable<Integer> apply(Integer t1) {
             }
         };
 
-        Callable<Observable<Integer>> firstTimeoutFunc = new Callable<Observable<Integer>>() {
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
             @Override
-            public Observable<Integer> call() {
+            public Observable<Integer> get() {
                 throw new TestException();
             }
         };

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java
Patch:
@@ -113,10 +113,10 @@ public void subscribe(Observer<? super String> innerObserver) {
             }
         });
 
-        Callable<Observable<Object>> closer = new Callable<Observable<Object>>() {
+        Supplier<Observable<Object>> closer = new Supplier<Observable<Object>>() {
             int calls;
             @Override
-            public Observable<Object> call() {
+            public Observable<Object> get() {
                 return Observable.unsafeCreate(new ObservableSource<Object>() {
                     @Override
                     public void subscribe(Observer<? super Object> innerObserver) {

File: src/test/java/io/reactivex/observable/ObservableMergeTests.java
Patch:
@@ -16,11 +16,11 @@
 import static org.junit.Assert.*;
 
 import java.util.List;
-import java.util.concurrent.Callable;
 
 import org.junit.Test;
 
 import io.reactivex.Observable;
+import io.reactivex.functions.Supplier;
 import io.reactivex.observable.ObservableCovarianceTest.*;
 
 public class ObservableMergeTests {
@@ -75,9 +75,9 @@ public void testMergeCovariance3() {
     @Test
     public void testMergeCovariance4() {
 
-        Observable<Movie> o1 = Observable.defer(new Callable<Observable<Movie>>() {
+        Observable<Movie> o1 = Observable.defer(new Supplier<Observable<Movie>>() {
             @Override
-            public Observable<Movie> call() {
+            public Observable<Movie> get() {
                 return Observable.just(
                         new HorrorMovie(),
                         new Movie()

File: src/test/java/io/reactivex/parallel/ParallelFromPublisherTest.java
Patch:
@@ -101,7 +101,7 @@ public int requestFusion(int mode) {
             }
 
             @Override
-            public T poll() throws Exception {
+            public T poll() throws Throwable {
                 return qs.poll();
             }
         }

File: src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
Patch:
@@ -36,7 +36,7 @@ public class TestSchedulerTest {
     @SuppressWarnings("unchecked")
     // mocking is unchecked, unfortunately
     @Test
-    public final void testPeriodicScheduling() throws Exception {
+    public final void testPeriodicScheduling() throws Throwable {
         final Function<Long, Void> calledOp = mock(Function.class);
 
         final TestScheduler scheduler = new TestScheduler();
@@ -86,7 +86,7 @@ public void run() {
     @SuppressWarnings("unchecked")
     // mocking is unchecked, unfortunately
     @Test
-    public final void testPeriodicSchedulingUnsubscription() throws Exception {
+    public final void testPeriodicSchedulingUnsubscription() throws Throwable {
         final Function<Long, Void> calledOp = mock(Function.class);
 
         final TestScheduler scheduler = new TestScheduler();

File: src/test/java/io/reactivex/tck/GenerateTckTest.java
Patch:
@@ -26,7 +26,7 @@ public class GenerateTckTest extends BaseTck<Long> {
     @Override
     public Publisher<Long> createPublisher(final long elements) {
         return
-            Flowable.generate(Functions.justCallable(0L),
+            Flowable.generate(Functions.justSupplier(0L),
             new BiFunction<Long, Emitter<Long>, Long>() {
                 @Override
                 public Long apply(Long s, Emitter<Long> e) throws Exception {

File: src/test/java/io/reactivex/tck/ReduceWithTckTest.java
Patch:
@@ -26,7 +26,7 @@ public class ReduceWithTckTest extends BaseTck<Integer> {
     @Override
     public Publisher<Integer> createPublisher(final long elements) {
         return
-                Flowable.range(1, 1000).reduceWith(Functions.justCallable(0),
+                Flowable.range(1, 1000).reduceWith(Functions.justSupplier(0),
                 new BiFunction<Integer, Integer, Integer>() {
                     @Override
                     public Integer apply(Integer a, Integer b) throws Exception {

File: src/test/java/io/reactivex/tck/UsingTckTest.java
Patch:
@@ -25,7 +25,7 @@ public class UsingTckTest extends BaseTck<Long> {
     @Override
     public Publisher<Long> createPublisher(long elements) {
         return
-            Flowable.using(Functions.justCallable(1),
+            Flowable.using(Functions.justSupplier(1),
                     Functions.justFunction(Flowable.fromIterable(iterate(elements))),
                     Functions.emptyConsumer()
             )

File: src/main/java/io/reactivex/exceptions/CompositeException.java
Patch:
@@ -280,7 +280,7 @@ public int size() {
      */
     /*private */Throwable getRootCause(Throwable e) {
         Throwable root = e.getCause();
-        if (root == null || cause == root) {
+        if (root == null || e == root) {
             return e;
         }
         while (true) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
Patch:
@@ -453,6 +453,8 @@ public void dispose() {
                 cancelled = true;
                 // remove this from the parent
                 parent.remove(this);
+                // make sure the last known node is not retained
+                index = null;
             }
         }
         /**
@@ -686,6 +688,7 @@ public final void replay(InnerDisposable<T> output) {
 
                 for (;;) {
                     if (output.isDisposed()) {
+                        output.index = null;
                         return;
                     }
 

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1171,7 +1171,8 @@ public final <T> Maybe<T> andThen(MaybeSource<T> next) {
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Completable andThen(CompletableSource next) {
-        return concatWith(next);
+        ObjectHelper.requireNonNull(next, "next is null");
+        return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, next));
     }
 
     /**
@@ -1357,7 +1358,7 @@ public final Completable compose(CompletableTransformer transformer) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Completable concatWith(CompletableSource other) {
         ObjectHelper.requireNonNull(other, "other is null");
-        return concatArray(this, other);
+        return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, other));
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatWhen.java
Patch:
@@ -108,8 +108,8 @@ public void onError(Throwable e) {
 
         @Override
         public void onComplete() {
-            active = false;
             DisposableHelper.replace(upstream, null);
+            active = false;
             signaller.onNext(0);
         }
 

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -8846,7 +8846,7 @@ public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,
      * {@code CharSequence}s or {@code List}s where the objects will actually have the same
      * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
      * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
-     * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`.
+     * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
@@ -8889,7 +8889,7 @@ public final Flowable<T> distinctUntilChanged() {
      * {@code CharSequence}s or {@code List}s where the objects will actually have the same
      * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
      * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
-     * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`.
+     * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
@@ -8928,7 +8928,7 @@ public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySele
      * {@code CharSequence}s or {@code List}s where the objects will actually have the same
      * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
      * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
-     * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`.
+     * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -7879,7 +7879,7 @@ public final <K> Observable<T> distinct(Function<? super T, K> keySelector, Call
      * {@code CharSequence}s or {@code List}s where the objects will actually have the same
      * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
      * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
-     * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`.
+     * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -7918,7 +7918,7 @@ public final Observable<T> distinctUntilChanged() {
      * {@code CharSequence}s or {@code List}s where the objects will actually have the same
      * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
      * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
-     * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`.
+     * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -7953,7 +7953,7 @@ public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySe
      * {@code CharSequence}s or {@code List}s where the objects will actually have the same
      * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
      * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
-     * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`.
+     * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -9507,7 +9507,7 @@ public final Maybe<T> lastElement() {
      *
      * @param defaultItem
      *            the default item to emit if the source ObservableSource is empty
-     * @return an Observable that emits only the last item emitted by the source ObservableSource, or a default item
+     * @return a Single that emits only the last item emitted by the source ObservableSource, or a default item
      *         if the source ObservableSource is empty
      * @see <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>
      */

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -16983,7 +16983,7 @@ public final <K, V> Single<Map<K, Collection<V>>> toMultimap(
      * @since 2.0
      */
     @CheckReturnValue
-    @BackpressureSupport(BackpressureKind.NONE)
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> toObservable() {
         return RxJavaPlugins.onAssembly(new ObservableFromPublisher<T>(this));

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -18043,7 +18043,7 @@ public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T
      * <br>To work around this termination property,
      * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
      * or cancellation.
-     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
@@ -18090,7 +18090,7 @@ public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction
      * <br>To work around this termination property,
      * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
      * or cancellation.
-     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
@@ -18140,7 +18140,7 @@ public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,
      * <br>To work around this termination property,
      * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
      * or cancellation.
-     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java
Patch:
@@ -59,6 +59,7 @@ static final class ConcatArraySubscriber<T> extends SubscriptionArbiter implemen
         long produced;
 
         ConcatArraySubscriber(Publisher<? extends T>[] sources, boolean delayError, Subscriber<? super T> downstream) {
+            super(false);
             this.downstream = downstream;
             this.sources = sources;
             this.delayError = delayError;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -571,6 +571,7 @@ static final class ConcatMapInner<R>
         long produced;
 
         ConcatMapInner(ConcatMapSupport<R> parent) {
+            super(false);
             this.parent = parent;
         }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorNext.java
Patch:
@@ -58,6 +58,7 @@ static final class OnErrorNextSubscriber<T>
         long produced;
 
         OnErrorNextSubscriber(Subscriber<? super T> actual, Function<? super Throwable, ? extends Publisher<? extends T>> nextSupplier, boolean allowFatal) {
+            super(false);
             this.downstream = actual;
             this.nextSupplier = nextSupplier;
             this.allowFatal = allowFatal;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java
Patch:
@@ -29,7 +29,7 @@ public FlowableRepeat(Flowable<T> source, long count) {
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        SubscriptionArbiter sa = new SubscriptionArbiter();
+        SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
         RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java
Patch:
@@ -31,7 +31,7 @@ public FlowableRepeatUntil(Flowable<T> source, BooleanSupplier until) {
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        SubscriptionArbiter sa = new SubscriptionArbiter();
+        SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
         RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, until, sa, source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatWhen.java
Patch:
@@ -143,6 +143,7 @@ abstract static class WhenSourceSubscriber<T, U> extends SubscriptionArbiter imp
 
         WhenSourceSubscriber(Subscriber<? super T> actual, FlowableProcessor<U> processor,
                 Subscription receiver) {
+            super(false);
             this.downstream = actual;
             this.processor = processor;
             this.receiver = receiver;
@@ -160,6 +161,7 @@ public final void onNext(T t) {
         }
 
         protected final void again(U signal) {
+            setSubscription(EmptySubscription.INSTANCE);
             long p = produced;
             if (p != 0L) {
                 produced = 0L;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java
Patch:
@@ -33,7 +33,7 @@ public FlowableRetryBiPredicate(
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        SubscriptionArbiter sa = new SubscriptionArbiter();
+        SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
         RetryBiSubscriber<T> rs = new RetryBiSubscriber<T>(s, predicate, sa, source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java
Patch:
@@ -35,7 +35,7 @@ public FlowableRetryPredicate(Flowable<T> source,
 
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
-        SubscriptionArbiter sa = new SubscriptionArbiter();
+        SubscriptionArbiter sa = new SubscriptionArbiter(false);
         s.onSubscribe(sa);
 
         RetrySubscriber<T> rs = new RetrySubscriber<T>(s, count, predicate, sa, source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmpty.java
Patch:
@@ -43,7 +43,7 @@ static final class SwitchIfEmptySubscriber<T> implements FlowableSubscriber<T> {
             this.downstream = actual;
             this.other = other;
             this.empty = true;
-            this.arbiter = new SubscriptionArbiter();
+            this.arbiter = new SubscriptionArbiter(false);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
Patch:
@@ -208,6 +208,7 @@ static final class TimeoutFallbackSubscriber<T> extends SubscriptionArbiter
         TimeoutFallbackSubscriber(Subscriber<? super T> actual,
                 Function<? super T, ? extends Publisher<?>> itemTimeoutIndicator,
                         Publisher<? extends T> fallback) {
+            super(true);
             this.downstream = actual;
             this.itemTimeoutIndicator = itemTimeoutIndicator;
             this.task = new SequentialDisposable();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
Patch:
@@ -196,6 +196,7 @@ static final class TimeoutFallbackSubscriber<T> extends SubscriptionArbiter
 
         TimeoutFallbackSubscriber(Subscriber<? super T> actual, long timeout, TimeUnit unit,
                 Scheduler.Worker worker, Publisher<? extends T> fallback) {
+            super(true);
             this.downstream = actual;
             this.timeout = timeout;
             this.unit = unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
Patch:
@@ -244,7 +244,7 @@ static final class InnerObserver<U> extends AtomicReference<Disposable> implemen
 
             @Override
             public void onSubscribe(Disposable d) {
-                DisposableHelper.set(this, d);
+                DisposableHelper.replace(this, d);
             }
 
             @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatWhen.java
Patch:
@@ -92,7 +92,7 @@ static final class RepeatWhenObserver<T> extends AtomicInteger implements Observ
 
         @Override
         public void onSubscribe(Disposable d) {
-            DisposableHelper.replace(this.upstream, d);
+            DisposableHelper.setOnce(this.upstream, d);
         }
 
         @Override
@@ -109,6 +109,7 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             active = false;
+            DisposableHelper.replace(upstream, null);
             signaller.onNext(0);
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryBiPredicate.java
Patch:
@@ -58,7 +58,7 @@ static final class RetryBiObserver<T> extends AtomicInteger implements Observer<
 
         @Override
         public void onSubscribe(Disposable d) {
-            upstream.update(d);
+            upstream.replace(d);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryPredicate.java
Patch:
@@ -61,7 +61,7 @@ static final class RepeatObserver<T> extends AtomicInteger implements Observer<T
 
         @Override
         public void onSubscribe(Disposable d) {
-            upstream.update(d);
+            upstream.replace(d);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryWhen.java
Patch:
@@ -102,6 +102,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable e) {
+            DisposableHelper.replace(upstream, null);
             active = false;
             signaller.onNext(e);
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryWithPredicateTest.java
Patch:
@@ -230,7 +230,7 @@ public void testUnsubscribeAfterError() {
         Subscriber<Long> subscriber = TestHelper.mockSubscriber();
 
         // Flowable that always fails after 100ms
-        FlowableRetryTest.SlowFlowable so = new FlowableRetryTest.SlowFlowable(100, 0);
+        FlowableRetryTest.SlowFlowable so = new FlowableRetryTest.SlowFlowable(100, 0, "testUnsubscribeAfterError");
         Flowable<Long> f = Flowable
                 .unsafeCreate(so)
                 .retry(retry5);
@@ -256,7 +256,7 @@ public void testTimeoutWithRetry() {
         Subscriber<Long> subscriber = TestHelper.mockSubscriber();
 
         // Flowable that sends every 100ms (timeout fails instead)
-        FlowableRetryTest.SlowFlowable so = new FlowableRetryTest.SlowFlowable(100, 10);
+        FlowableRetryTest.SlowFlowable so = new FlowableRetryTest.SlowFlowable(100, 10, "testTimeoutWithRetry");
         Flowable<Long> f = Flowable
                 .unsafeCreate(so)
                 .timeout(80, TimeUnit.MILLISECONDS)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmptyTest.java
Patch:
@@ -127,7 +127,7 @@ public void onNext(Long aLong) {
     }
 
     @Test
-    public void testSwitchShouldTriggerUnsubscribe() {
+    public void testSwitchShouldNotTriggerUnsubscribe() {
         final BooleanSubscription bs = new BooleanSubscription();
 
         Flowable.unsafeCreate(new Publisher<Long>() {
@@ -137,7 +137,7 @@ public void subscribe(final Subscriber<? super Long> subscriber) {
                 subscriber.onComplete();
             }
         }).switchIfEmpty(Flowable.<Long>never()).subscribe();
-        assertTrue(bs.isCancelled());
+        assertFalse(bs.isCancelled());
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRetryWithPredicateTest.java
Patch:
@@ -229,7 +229,7 @@ public void testUnsubscribeAfterError() {
         Observer<Long> observer = TestHelper.mockObserver();
 
         // Observable that always fails after 100ms
-        ObservableRetryTest.SlowObservable so = new ObservableRetryTest.SlowObservable(100, 0);
+        ObservableRetryTest.SlowObservable so = new ObservableRetryTest.SlowObservable(100, 0, "testUnsubscribeAfterError");
         Observable<Long> o = Observable
                 .unsafeCreate(so)
                 .retry(retry5);
@@ -255,7 +255,7 @@ public void testTimeoutWithRetry() {
         Observer<Long> observer = TestHelper.mockObserver();
 
         // Observable that sends every 100ms (timeout fails instead)
-        ObservableRetryTest.SlowObservable so = new ObservableRetryTest.SlowObservable(100, 10);
+        ObservableRetryTest.SlowObservable so = new ObservableRetryTest.SlowObservable(100, 10, "testTimeoutWithRetry");
         Observable<Long> o = Observable
                 .unsafeCreate(so)
                 .timeout(80, TimeUnit.MILLISECONDS)

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1393,6 +1393,7 @@ public final Completable delay(final long delay, final TimeUnit unit, final Sche
     /**
      * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time.
      * <p>
+     * <img width="640" height="475" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.</dd>
@@ -1415,6 +1416,7 @@ public final Completable delaySubscription(long delay, TimeUnit unit) {
      * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time,
      * both waiting and subscribing on a given Scheduler.
      * <p>
+     * <img width="640" height="420" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>You specify which {@link Scheduler} this operator will use.</dd>

File: src/main/java/io/reactivex/internal/fuseable/ConditionalSubscriber.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.FlowableSubscriber;
 
 /**
- * A Subscriber with an additional onNextIf(T) method that
+ * A Subscriber with an additional {@link #tryOnNext(Object)} method that
  * tells the caller the specified value has been accepted or
  * not.
  *
@@ -30,6 +30,7 @@ public interface ConditionalSubscriber<T> extends FlowableSubscriber<T> {
      * Conditionally takes the value.
      * @param t the value to deliver
      * @return true if the value has been accepted, false if the value has been rejected
+     * and the next value can be sent immediately
      */
     boolean tryOnNext(T t);
 }

File: src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java
Patch:
@@ -48,6 +48,6 @@ public OnErrorNotImplementedException(String message, @NonNull Throwable e) {
      *          the {@code Throwable} to signal; if null, a NullPointerException is constructed
      */
     public OnErrorNotImplementedException(@NonNull Throwable e) {
-        this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + (e != null ? e.getMessage() : ""), e);
+        this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + e, e);
     }
 }
\ No newline at end of file

File: src/main/java/io/reactivex/exceptions/UndeliverableException.java
Patch:
@@ -28,6 +28,6 @@ public final class UndeliverableException extends IllegalStateException {
      * @param cause the cause, not null
      */
     public UndeliverableException(Throwable cause) {
-        super("The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | " + cause.getMessage(), cause);
+        super("The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | " + cause, cause);
     }
 }

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -12130,8 +12130,6 @@ public final Flowable<T> rebatchRequests(int n) {
      * Publisher into the same function, and so on until all items have been emitted by the finite source Publisher,
      * and emits the final result from the final call to your function as its sole item.
      * <p>
-     * If the source is empty, a {@code NoSuchElementException} is signaled.
-     * <p>
      * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduce.png" alt="">
      * <p>
      * This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate,"

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -2168,6 +2168,8 @@ public final void subscribe(CompletableObserver observer) {
 
             observer = RxJavaPlugins.onSubscribe(this, observer);
 
+            ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");
+
             subscribeActual(observer);
         } catch (NullPointerException ex) { // NOPMD
             throw ex;

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -14473,7 +14473,7 @@ public final void subscribe(FlowableSubscriber<? super T> s) {
         try {
             Subscriber<? super T> z = RxJavaPlugins.onSubscribe(this, s);
 
-            ObjectHelper.requireNonNull(z, "Plugin returned null Subscriber");
+            ObjectHelper.requireNonNull(z, "The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");
 
             subscribeActual(z);
         } catch (NullPointerException e) { // NOPMD

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -4150,7 +4150,7 @@ public final void subscribe(MaybeObserver<? super T> observer) {
 
         observer = RxJavaPlugins.onSubscribe(this, observer);
 
-        ObjectHelper.requireNonNull(observer, "observer returned by the RxJavaPlugins hook is null");
+        ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");
 
         try {
             subscribeActual(observer);

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -12079,7 +12079,7 @@ public final void subscribe(Observer<? super T> observer) {
         try {
             observer = RxJavaPlugins.onSubscribe(this, observer);
 
-            ObjectHelper.requireNonNull(observer, "Plugin returned null Observer");
+            ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");
 
             subscribeActual(observer);
         } catch (NullPointerException e) { // NOPMD

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -3427,7 +3427,7 @@ public final void subscribe(SingleObserver<? super T> observer) {
 
         observer = RxJavaPlugins.onSubscribe(this, observer);
 
-        ObjectHelper.requireNonNull(observer, "subscriber returned by the RxJavaPlugins hook is null");
+        ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");
 
         try {
             subscribeActual(observer);

File: src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
Patch:
@@ -815,7 +815,7 @@ public Subscriber apply(Flowable a, Subscriber b) throws Exception {
                 Flowable.just(1).test();
                 fail("Should have thrown");
             } catch (NullPointerException ex) {
-                assertEquals("Plugin returned null Subscriber", ex.getMessage());
+                assertEquals("The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins", ex.getMessage());
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
Patch:
@@ -205,7 +205,7 @@ public Observer apply(Observable a, Observer b) throws Exception {
                 Observable.just(1).test();
                 fail("Should have thrown");
             } catch (NullPointerException ex) {
-                assertEquals("Plugin returned null Observer", ex.getMessage());
+                assertEquals("The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins", ex.getMessage());
             }
         } finally {
             RxJavaPlugins.reset();

File: src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java
Patch:
@@ -48,6 +48,6 @@ public OnErrorNotImplementedException(String message, @NonNull Throwable e) {
      *          the {@code Throwable} to signal; if null, a NullPointerException is constructed
      */
     public OnErrorNotImplementedException(@NonNull Throwable e) {
-        super(e != null ? e.getMessage() : null, e != null ? e : new NullPointerException());
+        this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + (e != null ? e.getMessage() : ""), e);
     }
 }
\ No newline at end of file

File: src/main/java/io/reactivex/exceptions/UndeliverableException.java
Patch:
@@ -28,6 +28,6 @@ public final class UndeliverableException extends IllegalStateException {
      * @param cause the cause, not null
      */
     public UndeliverableException(Throwable cause) {
-        super(cause);
+        super("The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | " + cause.getMessage(), cause);
     }
 }

File: src/test/java/io/reactivex/exceptions/ExceptionsTest.java
Patch:
@@ -53,7 +53,8 @@ public void accept(Integer t1) {
 
         });
 
-        TestHelper.assertError(errors, 0, RuntimeException.class, "hello");
+        TestHelper.assertError(errors, 0, RuntimeException.class);
+        assertTrue(errors.get(0).toString(), errors.get(0).getMessage().contains("hello"));
         RxJavaPlugins.reset();
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromCallable.java
Patch:
@@ -18,6 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CompletableFromCallable extends Completable {
 
@@ -37,6 +38,8 @@ protected void subscribeActual(CompletableObserver observer) {
             Exceptions.throwIfFatal(e);
             if (!d.isDisposed()) {
                 observer.onError(e);
+            } else {
+                RxJavaPlugins.onError(e);
             }
             return;
         }

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -2909,7 +2909,7 @@ public final <R> Maybe<R> flatMap(Function<? super T, ? extends MaybeSource<? ex
      * Maps the onSuccess, onError or onComplete signals of this Maybe into MaybeSource and emits that
      * MaybeSource's signals.
      * <p>
-     * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png" alt="">
+     * <img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.mmm.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/jmh/java/io/reactivex/LatchedSingleObserver.java
Patch:
@@ -26,15 +26,18 @@ public LatchedSingleObserver(Blackhole bh) {
         this.bh = bh;
         this.cdl = new CountDownLatch(1);
     }
+
     @Override
     public void onSubscribe(Disposable d) {
 
     }
+
     @Override
     public void onSuccess(T value) {
         bh.consume(value);
         cdl.countDown();
     }
+
     @Override
     public void onError(Throwable e) {
         e.printStackTrace();

File: src/jmh/java/io/reactivex/PublishProcessorPerf.java
Patch:
@@ -71,7 +71,6 @@ public void bounded1() {
         bounded.onNext(1);
     }
 
-
     @Benchmark
     public void bounded1k() {
         for (int i = 0; i < 1000; i++) {
@@ -86,13 +85,11 @@ public void bounded1m() {
         }
     }
 
-
     @Benchmark
     public void subject1() {
         subject.onNext(1);
     }
 
-
     @Benchmark
     public void subject1k() {
         for (int i = 0; i < 1000; i++) {

File: src/jmh/java/io/reactivex/ToFlowablePerf.java
Patch:
@@ -78,6 +78,7 @@ public Observable<Integer> apply(Integer v) throws Exception {
     public Object flowable() {
         return flowable.blockingGet();
     }
+
     @Benchmark
     public Object flowableInner() {
         return flowableInner.blockingLast();

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -83,7 +83,6 @@ public static void error(Throwable e, MaybeObserver<?> observer) {
         observer.onError(e);
     }
 
-
     @Override
     public boolean offer(Object value) {
         throw new UnsupportedOperationException("Should not be called!");

File: src/main/java/io/reactivex/internal/observers/DisposableLambdaObserver.java
Patch:
@@ -74,7 +74,6 @@ public void onComplete() {
         }
     }
 
-
     @Override
     public void dispose() {
         try {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java
Patch:
@@ -53,7 +53,6 @@ public void onSubscribe(Subscription s) {
             }
         }
 
-
         @Override
         public void onNext(T t) {
             // ignored

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -61,7 +61,6 @@ final class CompletableObserverImplementation implements CompletableObserver, Di
             this.downstream = downstream;
         }
 
-
         @Override
         public void onSubscribe(final Disposable d) {
             try {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java
Patch:
@@ -34,8 +34,6 @@ public CompletableResumeNext(CompletableSource source,
         this.errorMapper = errorMapper;
     }
 
-
-
     @Override
     protected void subscribeActual(final CompletableObserver observer) {
         ResumeNextObserver parent = new ResumeNextObserver(observer, errorMapper);
@@ -60,7 +58,6 @@ static final class ResumeNextObserver
             this.errorMapper = errorMapper;
         }
 
-
         @Override
         public void onSubscribe(Disposable d) {
             DisposableHelper.replace(this, d);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
Patch:
@@ -40,7 +40,6 @@ public CompletableUsing(Callable<R> resourceSupplier,
         this.eager = eager;
     }
 
-
     @Override
     protected void subscribeActual(CompletableObserver observer) {
         R resource;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java
Patch:
@@ -47,6 +47,7 @@ static final class AllSubscriber<T> extends DeferredScalarSubscription<Boolean>
             super(actual);
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.upstream, s)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAllSingle.java
Patch:
@@ -57,6 +57,7 @@ static final class AllSubscriber<T> implements FlowableSubscriber<T>, Disposable
             this.downstream = actual;
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.upstream, s)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java
Patch:
@@ -46,6 +46,7 @@ static final class AnySubscriber<T> extends DeferredScalarSubscription<Boolean>
             super(actual);
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.upstream, s)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAnySingle.java
Patch:
@@ -56,6 +56,7 @@ static final class AnySubscriber<T> implements FlowableSubscriber<T>, Disposable
             this.downstream = actual;
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.upstream, s)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -518,7 +518,6 @@ public boolean accept(Subscriber<? super U> a, U v) {
             return true;
         }
 
-
         @Override
         public void request(long n) {
             requested(n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -417,7 +417,6 @@ public void innerNext(R value) {
             downstream.onNext(value);
         }
 
-
         @Override
         public void innerError(Throwable e) {
             if (errors.addThrowable(e)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -125,6 +125,7 @@ public void onComplete() {
             if (d != null) {
                 d.dispose();
             }
+
             @SuppressWarnings("unchecked")
             DebounceEmitter<T> de = (DebounceEmitter<T>)d;
             if (de != null) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDefer.java
Patch:
@@ -27,6 +27,7 @@ public final class FlowableDefer<T> extends Flowable<T> {
     public FlowableDefer(Callable<? extends Publisher<? extends T>> supplier) {
         this.supplier = supplier;
     }
+
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
         Publisher<? extends T> pub;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
Patch:
@@ -79,6 +79,7 @@ public void onError(Throwable t) {
 
             downstream.onError(t);
         }
+
         @Override
         public void onComplete() {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java
Patch:
@@ -27,6 +27,7 @@ public final class FlowableError<T> extends Flowable<T> {
     public FlowableError(Callable<? extends Throwable> errorSupplier) {
         this.errorSupplier = errorSupplier;
     }
+
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
         Throwable error;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -28,6 +28,7 @@ public final class FlowableFromArray<T> extends Flowable<T> {
     public FlowableFromArray(T[] array) {
         this.array = array;
     }
+
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
         if (s instanceof ConditionalSubscriber) {
@@ -92,7 +93,6 @@ public final void request(long n) {
             }
         }
 
-
         @Override
         public final void cancel() {
             cancelled = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java
Patch:
@@ -27,6 +27,7 @@ public final class FlowableFromCallable<T> extends Flowable<T> implements Callab
     public FlowableFromCallable(Callable<? extends T> callable) {
         this.callable = callable;
     }
+
     @Override
     public void subscribeActual(Subscriber<? super T> s) {
         DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
Patch:
@@ -104,7 +104,6 @@ public final T poll() {
             return ObjectHelper.requireNonNull(it.next(), "Iterator.next() returned a null value");
         }
 
-
         @Override
         public final boolean isEmpty() {
             return it == null || !it.hasNext();
@@ -128,7 +127,6 @@ public final void request(long n) {
             }
         }
 
-
         @Override
         public final void cancel() {
             cancelled = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java
Patch:
@@ -30,7 +30,6 @@ public FlowableOnBackpressureError(Flowable<T> source) {
         super(source);
     }
 
-
     @Override
     protected void subscribeActual(Subscriber<? super T> s) {
         this.source.subscribe(new BackpressureErrorSubscriber<T>(s));

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
Patch:
@@ -230,6 +230,7 @@ public void onNext(T t) {
             // loop to act on the current state serially
             dispatch();
         }
+
         @Override
         public void onError(Throwable e) {
             // The observer front is accessed serially as required by spec so
@@ -243,6 +244,7 @@ public void onError(Throwable e) {
                 RxJavaPlugins.onError(e);
             }
         }
+
         @Override
         public void onComplete() {
             // The observer front is accessed serially as required by spec so

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRange.java
Patch:
@@ -31,6 +31,7 @@ public FlowableRange(int start, int count) {
         this.start = start;
         this.end = start + count;
     }
+
     @Override
     public void subscribeActual(Subscriber<? super Integer> s) {
         if (s instanceof ConditionalSubscriber) {
@@ -94,7 +95,6 @@ public final void request(long n) {
             }
         }
 
-
         @Override
         public final void cancel() {
             cancelled = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java
Patch:
@@ -64,6 +64,7 @@ public void onNext(T t) {
             produced++;
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             downstream.onError(t);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java
Patch:
@@ -66,6 +66,7 @@ public void onNext(T t) {
             produced++;
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             downstream.onError(t);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -409,6 +409,7 @@ public void onError(Throwable e) {
                 RxJavaPlugins.onError(e);
             }
         }
+
         @SuppressWarnings("unchecked")
         @Override
         public void onComplete() {
@@ -624,6 +625,7 @@ static final class UnboundedReplayBuffer<T> extends ArrayList<Object> implements
         UnboundedReplayBuffer(int capacityHint) {
             super(capacityHint);
         }
+
         @Override
         public void next(T value) {
             add(NotificationLite.next(value));
@@ -1037,6 +1039,7 @@ void truncate() {
                 setFirst(prev);
             }
         }
+
         @Override
         void truncateFinal() {
             long timeLimit = scheduler.now(unit) - maxAge;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java
Patch:
@@ -70,6 +70,7 @@ public void onNext(T t) {
             produced++;
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             boolean b;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java
Patch:
@@ -73,6 +73,7 @@ public void onNext(T t) {
             produced++;
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             long r = remaining;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeInterval.java
Patch:
@@ -31,7 +31,6 @@ public FlowableTimeInterval(Flowable<T> source, TimeUnit unit, Scheduler schedul
         this.unit = unit;
     }
 
-
     @Override
     protected void subscribeActual(Subscriber<? super Timed<T>> s) {
         source.subscribe(new TimeIntervalSubscriber<T>(s, unit, scheduler));

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java
Patch:
@@ -131,9 +131,9 @@ static final class WithLatestFromSubscriber<T, R>
 
         void subscribe(Publisher<?>[] others, int n) {
             WithLatestInnerSubscriber[] subscribers = this.subscribers;
-            AtomicReference<Subscription> s = this.upstream;
+            AtomicReference<Subscription> upstream = this.upstream;
             for (int i = 0; i < n; i++) {
-                if (SubscriptionHelper.isCancelled(s.get())) {
+                if (SubscriptionHelper.isCancelled(upstream.get())) {
                     return;
                 }
                 others[i].subscribe(subscribers[i]);

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeSwitchIfEmptySingle.java
Patch:
@@ -106,14 +106,17 @@ static final class OtherSingleObserver<T> implements SingleObserver<T> {
                 this.downstream = actual;
                 this.parent = parent;
             }
+
             @Override
             public void onSubscribe(Disposable d) {
                 DisposableHelper.setOnce(parent, d);
             }
+
             @Override
             public void onSuccess(T value) {
                 downstream.onSuccess(value);
             }
+
             @Override
             public void onError(Throwable e) {
                 downstream.onError(e);

File: src/main/java/io/reactivex/internal/operators/mixed/CompletableAndThenObservable.java
Patch:
@@ -81,7 +81,6 @@ public void onComplete() {
             }
         }
 
-
         @Override
         public void dispose() {
             DisposableHelper.dispose(this);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java
Patch:
@@ -43,6 +43,7 @@ static final class AllObserver<T> implements Observer<T>, Disposable {
             this.downstream = actual;
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             if (DisposableHelper.validate(this.upstream, d)) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAllSingle.java
Patch:
@@ -51,6 +51,7 @@ static final class AllObserver<T> implements Observer<T>, Disposable {
             this.downstream = actual;
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             if (DisposableHelper.validate(this.upstream, d)) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAny.java
Patch:
@@ -44,6 +44,7 @@ static final class AnyObserver<T> implements Observer<T>, Disposable {
             this.downstream = actual;
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             if (DisposableHelper.validate(this.upstream, d)) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAnySingle.java
Patch:
@@ -53,6 +53,7 @@ static final class AnyObserver<T> implements Observer<T>, Disposable {
             this.downstream = actual;
             this.predicate = predicate;
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             if (DisposableHelper.validate(this.upstream, d)) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java
Patch:
@@ -168,7 +168,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
Patch:
@@ -517,7 +517,6 @@ public void accept(Observer<? super U> a, U v) {
             a.onNext(v);
         }
 
-
         @Override
         public void dispose() {
             if (!cancelled) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
Patch:
@@ -69,7 +69,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -80,7 +79,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCollectSingle.java
Patch:
@@ -77,7 +77,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -88,7 +87,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
Patch:
@@ -43,7 +43,6 @@ public ObservableCombineLatest(ObservableSource<? extends T>[] sources,
         this.delayError = delayError;
     }
 
-
     @Override
     @SuppressWarnings("unchecked")
     public void subscribeActual(Observer<? super R> observer) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCount.java
Patch:
@@ -46,7 +46,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCountSingle.java
Patch:
@@ -54,7 +54,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
Patch:
@@ -117,6 +117,7 @@ public void onComplete() {
             if (d != null) {
                 d.dispose();
             }
+
             @SuppressWarnings("unchecked")
             DebounceEmitter<T> de = (DebounceEmitter<T>)d;
             if (de != null) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDefer.java
Patch:
@@ -25,6 +25,7 @@ public final class ObservableDefer<T> extends Observable<T> {
     public ObservableDefer(Callable<? extends ObservableSource<? extends T>> supplier) {
         this.supplier = supplier;
     }
+
     @Override
     public void subscribeActual(Observer<? super T> observer) {
         ObservableSource<? extends T> pub;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDematerialize.java
Patch:
@@ -49,7 +49,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -60,7 +59,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(Notification<T> t) {
             if (done) {
@@ -91,6 +89,7 @@ public void onError(Throwable t) {
 
             downstream.onError(t);
         }
+
         @Override
         public void onComplete() {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoOnEach.java
Patch:
@@ -74,7 +74,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -85,7 +84,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAt.java
Patch:
@@ -31,6 +31,7 @@ public ObservableElementAt(ObservableSource<T> source, long index, T defaultValu
         this.defaultValue = defaultValue;
         this.errorOnFewer = errorOnFewer;
     }
+
     @Override
     public void subscribeActual(Observer<? super T> t) {
         source.subscribe(new ElementAtObserver<T>(t, index, defaultValue, errorOnFewer));
@@ -63,7 +64,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -74,7 +74,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java
Patch:
@@ -26,6 +26,7 @@ public ObservableElementAtMaybe(ObservableSource<T> source, long index) {
         this.source = source;
         this.index = index;
     }
+
     @Override
     public void subscribeActual(MaybeObserver<? super T> t) {
         source.subscribe(new ElementAtObserver<T>(t, index));
@@ -59,7 +60,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -70,7 +70,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java
Patch:
@@ -67,7 +67,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -78,7 +77,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableError.java
Patch:
@@ -25,6 +25,7 @@ public final class ObservableError<T> extends Observable<T> {
     public ObservableError(Callable<? extends Throwable> errorSupplier) {
         this.errorSupplier = errorSupplier;
     }
+
     @Override
     public void subscribeActual(Observer<? super T> observer) {
         Throwable error;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromArray.java
Patch:
@@ -23,6 +23,7 @@ public final class ObservableFromArray<T> extends Observable<T> {
     public ObservableFromArray(T[] array) {
         this.array = array;
     }
+
     @Override
     public void subscribeActual(Observer<? super T> observer) {
         FromArrayDisposable<T> d = new FromArrayDisposable<T>(observer, array);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromCallable.java
Patch:
@@ -30,6 +30,7 @@ public final class ObservableFromCallable<T> extends Observable<T> implements Ca
     public ObservableFromCallable(Callable<? extends T> callable) {
         this.callable = callable;
     }
+
     @Override
     public void subscribeActual(Observer<? super T> observer) {
         DeferredScalarDisposable<T> d = new DeferredScalarDisposable<T>(observer);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java
Patch:
@@ -136,7 +136,6 @@ public boolean isDisposed() {
             return cancelled;
         }
 
-
         @Override
         public void onNext(T t) {
             if (!terminate) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMapNotification.java
Patch:
@@ -71,7 +71,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -82,7 +81,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             ObservableSource<? extends R> p;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMaterialize.java
Patch:
@@ -46,7 +46,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturn.java
Patch:
@@ -50,7 +50,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
Patch:
@@ -172,6 +172,7 @@ public void onNext(T t) {
                 inner.child.onNext(t);
             }
         }
+
         @SuppressWarnings("unchecked")
         @Override
         public void onError(Throwable e) {
@@ -185,6 +186,7 @@ public void onError(Throwable e) {
                 RxJavaPlugins.onError(e);
             }
         }
+
         @SuppressWarnings("unchecked")
         @Override
         public void onComplete() {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeat.java
Patch:
@@ -59,6 +59,7 @@ public void onSubscribe(Disposable d) {
         public void onNext(T t) {
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             downstream.onError(t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatUntil.java
Patch:
@@ -61,6 +61,7 @@ public void onSubscribe(Disposable d) {
         public void onNext(T t) {
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             downstream.onError(t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryBiPredicate.java
Patch:
@@ -65,6 +65,7 @@ public void onSubscribe(Disposable d) {
         public void onNext(T t) {
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             boolean b;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryPredicate.java
Patch:
@@ -68,6 +68,7 @@ public void onSubscribe(Disposable d) {
         public void onNext(T t) {
             downstream.onNext(t);
         }
+
         @Override
         public void onError(Throwable t) {
             long r = remaining;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
Patch:
@@ -36,7 +36,6 @@ public ObservableSampleTimed(ObservableSource<T> source, long period, TimeUnit u
         this.emitLast = emitLast;
     }
 
-
     @Override
     public void subscribeActual(Observer<? super T> t) {
         SerializedObserver<T> serial = new SerializedObserver<T>(t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java
Patch:
@@ -56,7 +56,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -67,7 +66,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java
Patch:
@@ -74,7 +74,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingleMaybe.java
Patch:
@@ -25,6 +25,7 @@ public final class ObservableSingleMaybe<T> extends Maybe<T> {
     public ObservableSingleMaybe(ObservableSource<T> source) {
         this.source = source;
     }
+
     @Override
     public void subscribeActual(MaybeObserver<? super T> t) {
         source.subscribe(new SingleElementObserver<T>(t));
@@ -51,7 +52,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -62,7 +62,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java
Patch:
@@ -59,7 +59,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -70,7 +69,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLast.java
Patch:
@@ -54,7 +54,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipWhile.java
Patch:
@@ -49,7 +49,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -60,7 +59,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (notSkipping) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java
Patch:
@@ -28,6 +28,7 @@ public ObservableTakeUntil(ObservableSource<T> source, ObservableSource<? extend
         super(source);
         this.other = other;
     }
+
     @Override
     public void subscribeActual(Observer<? super T> child) {
         TakeUntilMainObserver<T, U> parent = new TakeUntilMainObserver<T, U>(child);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeWhile.java
Patch:
@@ -53,7 +53,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -64,7 +63,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeInterval.java
Patch:
@@ -69,7 +69,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             long now = scheduler.now(unit);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableToList.java
Patch:
@@ -71,7 +71,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -82,7 +81,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             collection.add(t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableToListSingle.java
Patch:
@@ -83,7 +83,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -94,7 +93,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             collection.add(t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java
Patch:
@@ -61,6 +61,7 @@ static final class WithLatestFromObserver<T, U, R> extends AtomicReference<U> im
             this.downstream = actual;
             this.combiner = combiner;
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             DisposableHelper.setOnce(this.upstream, d);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
Patch:
@@ -265,6 +265,7 @@ static final class ZipObserver<T, R> implements Observer<T> {
             this.parent = parent;
             this.queue = new SpscLinkedArrayQueue<T>(bufferSize);
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             DisposableHelper.setOnce(this.upstream, d);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableZipIterable.java
Patch:
@@ -90,7 +90,6 @@ public void onSubscribe(Disposable d) {
             }
         }
 
-
         @Override
         public void dispose() {
             upstream.dispose();
@@ -101,7 +100,6 @@ public boolean isDisposed() {
             return upstream.isDisposed();
         }
 
-
         @Override
         public void onNext(T t) {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/single/SingleEquals.java
Patch:
@@ -57,6 +57,7 @@ static class InnerObserver<T> implements SingleObserver<T> {
             this.downstream = observer;
             this.count = count;
         }
+
         @Override
         public void onSubscribe(Disposable d) {
             set.add(d);

File: src/main/java/io/reactivex/internal/operators/single/SingleInternalHelper.java
Patch:
@@ -110,6 +110,7 @@ public Observable apply(SingleSource v) {
             return new SingleToObservable(v);
         }
     }
+
     @SuppressWarnings({ "rawtypes", "unchecked" })
     public static <T> Function<SingleSource<? extends T>, Observable<? extends T>> toObservable() {
         return (Function)ToObservable.INSTANCE;

File: src/main/java/io/reactivex/internal/operators/single/SingleOnErrorReturn.java
Patch:
@@ -32,8 +32,6 @@ public SingleOnErrorReturn(SingleSource<? extends T> source,
         this.value = value;
     }
 
-
-
     @Override
     protected void subscribeActual(final SingleObserver<? super T> observer) {
 

File: src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
Patch:
@@ -113,6 +113,7 @@ private void resize(final AtomicReferenceArray<Object> oldBuffer, final long cur
     private void soNext(AtomicReferenceArray<Object> curr, AtomicReferenceArray<Object> next) {
         soElement(curr, calcDirectOffset(curr.length() - 1), next);
     }
+
     @SuppressWarnings("unchecked")
     private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {
         int nextOffset = calcDirectOffset(nextIndex);
@@ -179,6 +180,7 @@ private T newBufferPeek(AtomicReferenceArray<Object> nextBuffer, final long inde
         final int offsetInNew = calcWrappedOffset(index, mask);
         return (T) lvElement(nextBuffer, offsetInNew);// LoadLoad
     }
+
     @Override
     public void clear() {
         while (poll() != null || !isEmpty()) { } // NOPMD

File: src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java
Patch:
@@ -227,6 +227,7 @@ public Disposable schedule(@NonNull Runnable action) {
 
             return poolWorker.scheduleActual(action, 0, TimeUnit.MILLISECONDS, serial);
         }
+
         @NonNull
         @Override
         public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {

File: src/main/java/io/reactivex/internal/schedulers/IoScheduler.java
Patch:
@@ -167,6 +167,7 @@ public void start() {
             update.shutdown();
         }
     }
+
     @Override
     public void shutdown() {
         for (;;) {

File: src/main/java/io/reactivex/internal/util/LinkedArrayList.java
Patch:
@@ -87,6 +87,7 @@ public Object[] head() {
     public int size() {
         return size;
     }
+
     @Override
     public String toString() {
         final int cap = capacityHint;

File: src/main/java/io/reactivex/observers/SafeObserver.java
Patch:
@@ -63,7 +63,6 @@ public void onSubscribe(@NonNull Disposable d) {
         }
     }
 
-
     @Override
     public void dispose() {
         upstream.dispose();

File: src/main/java/io/reactivex/observers/SerializedObserver.java
Patch:
@@ -72,7 +72,6 @@ public void onSubscribe(@NonNull Disposable d) {
         }
     }
 
-
     @Override
     public void dispose() {
         upstream.dispose();
@@ -83,7 +82,6 @@ public boolean isDisposed() {
         return upstream.isDisposed();
     }
 
-
     @Override
     public void onNext(@NonNull T t) {
         if (done) {

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -141,7 +141,6 @@ public static <T> PublishProcessor<T> create() {
         subscribers = new AtomicReference<PublishSubscription<T>[]>(EMPTY);
     }
 
-
     @Override
     protected void subscribeActual(Subscriber<? super T> t) {
         PublishSubscription<T> ps = new PublishSubscription<T>(t, this);

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -605,6 +605,7 @@ static final class ReplaySubscription<T> extends AtomicInteger implements Subscr
             this.state = state;
             this.requested = new AtomicLong();
         }
+
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validate(n)) {
@@ -1117,7 +1118,6 @@ void trimFinal() {
             }
         }
 
-
         @Override
         public void trimHead() {
             if (head.value != null) {

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -129,7 +129,6 @@ public static <T> PublishSubject<T> create() {
         subscribers = new AtomicReference<PublishDisposable<T>[]>(EMPTY);
     }
 
-
     @Override
     protected void subscribeActual(Observer<? super T> t) {
         PublishDisposable<T> ps = new PublishDisposable<T>(t, this);

File: src/main/java/io/reactivex/subjects/SerializedSubject.java
Patch:
@@ -49,7 +49,6 @@ protected void subscribeActual(Observer<? super T> observer) {
         actual.subscribe(observer);
     }
 
-
     @Override
     public void onSubscribe(Disposable d) {
         boolean cancel;

File: src/test/java/io/reactivex/completable/CompletableTest.java
Patch:
@@ -2029,6 +2029,7 @@ public void onSubscribe(Disposable d) {
             };
         }
     }
+
     @Test(timeout = 5000, expected = TestException.class)
     public void liftOnCompleteError() {
         Completable c = normal.completable.lift(new CompletableOperatorSwap());
@@ -4660,7 +4661,6 @@ public void accept(final Throwable throwable) throws Exception {
         }
     }
 
-
     @Test(timeout = 5000)
     public void subscribeTwoCallbacksDispose() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
Patch:
@@ -277,6 +277,7 @@ public void run() {
         // we should have only disposed once
         assertEquals(1, counter.get());
     }
+
     @Test
     public void testTryRemoveIfNotIn() {
         CompositeDisposable cd = new CompositeDisposable();

File: src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java
Patch:
@@ -182,6 +182,7 @@ public void testNullCollection() {
         composite.getCause();
         composite.printStackTrace();
     }
+
     @Test
     public void testNullElement() {
         CompositeException composite = new CompositeException(Collections.singletonList((Throwable) null));

File: src/test/java/io/reactivex/exceptions/OnErrorNotImplementedExceptionTest.java
Patch:
@@ -108,7 +108,6 @@ public void singleSubscribe1() {
         .subscribe(Functions.emptyConsumer());
     }
 
-
     @Test
     public void maybeSubscribe0() {
         Maybe.error(new TestException())

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -2724,7 +2724,6 @@ public Object apply(Integer a, Integer b) {
         });
     }
 
-
     @Test(expected = NullPointerException.class)
     public void zipWithCombinerNull() {
         just1.zipWith(just1, null);

File: src/test/java/io/reactivex/flowable/FlowableReduceTests.java
Patch:
@@ -77,7 +77,6 @@ public Movie apply(Movie t1, Movie t2) {
         assertNotNull(reduceResult2);
     }
 
-
     @Test
     public void reduceInts() {
         Flowable<Integer> f = Flowable.just(1, 2, 3);

File: src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
Patch:
@@ -771,7 +771,6 @@ public void safeSubscriberAlreadySafe() {
         ts.assertResult(1);
     }
 
-
     @Test
     public void methodTestNoCancel() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -148,7 +148,6 @@ public Throwable call() {
         verify(w, times(1)).onError(any(RuntimeException.class));
     }
 
-
     @Test
     public void testCountAFewItems() {
         Flowable<String> flowable = Flowable.just("a", "b", "c", "d");
@@ -862,7 +861,6 @@ public void testContainsWithEmptyObservableFlowable() {
         verify(subscriber, times(1)).onComplete();
     }
 
-
     @Test
     public void testContains() {
         Single<Boolean> single = Flowable.just("a", "b", "c").contains("b"); // FIXME nulls not allowed, changed to "c"

File: src/test/java/io/reactivex/internal/SubscribeWithTest.java
Patch:
@@ -30,7 +30,6 @@ public void withFlowable() {
         .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
     }
 
-
     @Test
     public void withObservable() {
         Observable.range(1, 10)

File: src/test/java/io/reactivex/internal/observers/DeferredScalarObserverTest.java
Patch:
@@ -181,7 +181,6 @@ static final class TakeLast extends DeferredScalarObserver<Integer, Integer> {
             super(downstream);
         }
 
-
         @Override
         public void onNext(Integer value) {
             this.value = value;

File: src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java
Patch:
@@ -247,6 +247,7 @@ public void accept(Disposable d) throws Exception {
             RxJavaPlugins.reset();
         }
     }
+
     @Test
     public void badSourceEmitAfterDone() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/completable/CompletableAmbTest.java
Patch:
@@ -187,7 +187,6 @@ public void ambRace() {
         }
     }
 
-
     @Test
     public void untilCompletableMainComplete() {
         CompletableSubject main = CompletableSubject.create();

File: src/test/java/io/reactivex/internal/operators/completable/CompletableResumeNextTest.java
Patch:
@@ -40,7 +40,6 @@ public CompletableSource apply(Completable c) throws Exception {
         });
     }
 
-
     @Test
     public void disposeInResume() {
         TestHelper.checkDisposedCompletable(new Function<Completable, CompletableSource>() {

File: src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java
Patch:
@@ -30,7 +30,6 @@ public void subscribeAlreadyCancelled() {
         assertFalse(pp.hasSubscribers());
     }
 
-
     @Test
     public void methodTestNoCancel() {
         PublishSubject<Integer> ps = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/completable/CompletableUsingTest.java
Patch:
@@ -347,7 +347,6 @@ public void accept(Object d) throws Exception {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void emptyDisposerCrashes() {
         Completable.using(new Callable<Object>() {

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecentTest.java
Patch:
@@ -103,7 +103,6 @@ public void constructorshouldbeprivate() {
         TestHelper.checkUtilityClass(BlockingFlowableMostRecent.class);
     }
 
-
     @Test
     public void empty() {
         Iterator<Integer> it = Flowable.<Integer>empty()

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
Patch:
@@ -124,6 +124,7 @@ public boolean test(Integer i) {
 
         assertFalse(allOdd.blockingGet());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstream() {
         Flowable<Integer> source = Flowable.just(1)
@@ -297,6 +298,7 @@ public boolean test(Integer i) {
 
         assertFalse(allOdd.blockingFirst());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstreamFlowable() {
         Flowable<Integer> source = Flowable.just(1)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
Patch:
@@ -236,7 +236,6 @@ public void testBackpressure() {
         assertEquals(Flowable.bufferSize() * 2, ts.values().size());
     }
 
-
     @SuppressWarnings("unchecked")
     @Test
     public void testSubscriptionOnlyHappensOnce() throws InterruptedException {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
Patch:
@@ -223,6 +223,7 @@ public boolean test(Integer i) {
 
         assertTrue(anyEven.blockingGet());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstream() {
         Flowable<Integer> source = Flowable.just(1).isEmpty()
@@ -489,6 +490,7 @@ public boolean test(Integer i) {
 
         assertTrue(anyEven.blockingFirst());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstreamFlowable() {
         Flowable<Integer> source = Flowable.just(1).isEmpty()

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAsObservableTest.java
Patch:
@@ -45,6 +45,7 @@ public void testHiding() {
         verify(subscriber).onComplete();
         verify(subscriber, never()).onError(any(Throwable.class));
     }
+
     @Test
     public void testHidingError() {
         PublishProcessor<Integer> src = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
Patch:
@@ -54,6 +54,7 @@ public void testColdReplayNoBackpressure() {
             assertEquals((Integer)i, onNextEvents.get(i));
         }
     }
+
     @Test
     public void testColdReplayBackpressure() {
         FlowableCache<Integer> source = new FlowableCache<Integer>(Flowable.range(0, 1000), 16);
@@ -178,6 +179,7 @@ public void testAsync() {
             assertEquals(10000, ts2.values().size());
         }
     }
+
     @Test
     public void testAsyncComeAndGo() {
         Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -1206,6 +1206,7 @@ public Object apply(Object[] a) throws Exception {
         .test()
         .assertFailure(TestException.class, "[1, 2]");
     }
+
     @SuppressWarnings("unchecked")
     @Test
     public void combineLatestEmpty() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatDelayErrorTest.java
Patch:
@@ -216,7 +216,6 @@ static <T> Flowable<T> withError(Flowable<T> source) {
         return source.concatWith(Flowable.<T>error(new TestException()));
     }
 
-
     @Test
     public void concatDelayErrorFlowable() {
         TestSubscriber<Integer> ts = TestSubscriber.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
Patch:
@@ -655,7 +655,6 @@ public Flowable<Integer> apply(Integer t) {
         ts.assertValue(null);
     }
 
-
     @Test
     public void testMaxConcurrent5() {
         final List<Long> requests = new ArrayList<Long>();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -169,6 +169,7 @@ public void subscribe(final Subscriber<? super Flowable<String>> subscriber) {
                     public void request(long n) {
 
                     }
+
                     @Override
                     public void cancel() {
                         d.dispose();
@@ -636,6 +637,7 @@ public Flowable<Integer> apply(Integer v) {
         inOrder.verify(o).onSuccess(list);
         verify(o, never()).onError(any(Throwable.class));
     }
+
     @Test
     public void concatVeryLongObservableOfObservablesTakeHalf() {
         final int n = 10000;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatWithMaybeTest.java
Patch:
@@ -41,7 +41,6 @@ public void run() throws Exception {
         ts.assertResult(1, 2, 3, 4, 5, 100);
     }
 
-
     @Test
     public void normalNonEmpty() {
         final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCountTest.java
Patch:
@@ -39,7 +39,6 @@ public void simple() {
 
     }
 
-
     @Test
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).count());

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java
Patch:
@@ -1001,7 +1001,6 @@ public void cancel() throws Exception {
         }
     }
 
-
     @Test
     public void tryOnError() {
         for (BackpressureStrategy strategy : BackpressureStrategy.values()) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
Patch:
@@ -239,6 +239,7 @@ public Flowable<Integer> apply(Integer t1) {
         verify(subscriber, never()).onComplete();
         verify(subscriber).onError(any(TestException.class));
     }
+
     @Test
     public void debounceTimedLastIsNotLost() {
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -256,6 +257,7 @@ public void debounceTimedLastIsNotLost() {
         verify(subscriber).onComplete();
         verify(subscriber, never()).onError(any(Throwable.class));
     }
+
     @Test
     public void debounceSelectorLastIsNotLost() {
         PublishProcessor<Integer> source = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java
Patch:
@@ -87,7 +87,6 @@ public void range() {
         ts.assertComplete();
     }
 
-
     @Test
     public void backpressured() throws Exception {
         o = new Object();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoFinallyTest.java
Patch:
@@ -157,7 +157,6 @@ public void asyncFusedBoundary() {
         assertEquals(1, calls);
     }
 
-
     @Test
     public void normalJustConditional() {
         Flowable.just(1)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java
Patch:
@@ -186,7 +186,6 @@ public void elementAtOrErrorIndex1OnEmptySource() {
             .assertFailure(NoSuchElementException.class);
     }
 
-
     @Test
     public void doubleOnSubscribe() {
         TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Object>>() {
@@ -229,7 +228,6 @@ public void errorFlowable() {
             .assertFailure(TestException.class);
     }
 
-
     @Test
     public void error() {
         Flowable.error(new TestException())

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableTest.java
Patch:
@@ -183,7 +183,6 @@ public CompletableSource apply(Integer v) throws Exception {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void fusedFlowable() {
         TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueFuseable.ANY);
@@ -338,7 +337,6 @@ public CompletableSource apply(Integer v) throws Exception {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void fused() {
         TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueFuseable.ANY);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
Patch:
@@ -355,6 +355,7 @@ public Flowable<Integer> apply(Integer t1) {
         Assert.assertEquals(expected.size(), ts.valueCount());
         Assert.assertTrue(expected.containsAll(ts.values()));
     }
+
     @Test
     public void testFlatMapSelectorMaxConcurrent() {
         final int m = 4;
@@ -478,6 +479,7 @@ public Flowable<Integer> apply(Integer t) {
             }
         }
     }
+
     @Test(timeout = 30000)
     public void flatMapRangeMixedAsyncLoop() {
         for (int i = 0; i < 2000; i++) {
@@ -537,6 +539,7 @@ public Flowable<Integer> apply(Integer t) {
             ts.assertValueCount(1000);
         }
     }
+
     @Test
     public void flatMapTwoNestedSync() {
         for (final int n : new int[] { 1, 1000, 1000000 }) {
@@ -856,7 +859,6 @@ public void run() {
         }
     }
 
-
     @Test
     public void fusedInnerThrows() {
         Flowable.just(1).hide()

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromArrayTest.java
Patch:
@@ -33,6 +33,7 @@ Flowable<Integer> create(int n) {
         }
         return Flowable.fromArray(array);
     }
+
     @Test
     public void simple() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
Patch:
@@ -40,7 +40,6 @@ public void before() {
         ts = new TestSubscriber<Integer>(0L);
     }
 
-
     @Test
     public void normalBuffered() {
         Flowable.create(source, BackpressureStrategy.BUFFER).subscribe(ts);
@@ -125,7 +124,6 @@ public void normalMissingRequested() {
         ts.assertComplete();
     }
 
-
     @Test
     public void normalError() {
         Flowable.create(source, BackpressureStrategy.ERROR).subscribe(ts);
@@ -489,7 +487,6 @@ public void unsubscribeNoCancel() {
         ts.assertNotComplete();
     }
 
-
     @Test
     public void unsubscribeInline() {
         TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
Patch:
@@ -1638,7 +1638,6 @@ public void accept(GroupedFlowable<Integer, Integer> g) {
         .assertComplete();
     }
 
-
     @Test
     public void keySelectorAndDelayError() {
         Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
Patch:
@@ -144,7 +144,6 @@ public void onNext(Integer t) {
         assertEquals(0, count.get());
     }
 
-
     @Test
     public void testWithEmpty() {
         assertNull(Flowable.empty().ignoreElements().blockingGet());

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
Patch:
@@ -436,6 +436,7 @@ public void onNext(String args) {
         }
 
     }
+
     @Test
     @Ignore("Subscribers should not throw")
     public void testMergeSourceWhichDoesntPropagateExceptionBack() {
@@ -559,6 +560,7 @@ public void run() {
             t.start();
         }
     }
+
     @Test
     public void testDelayErrorMaxConcurrent() {
         final List<Long> requests = new ArrayList<Long>();
@@ -737,7 +739,6 @@ public void array() {
         }
     }
 
-
     @SuppressWarnings("unchecked")
     @Test
     public void mergeArrayDelayError() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
Patch:
@@ -1360,10 +1360,12 @@ void runMerge(Function<Integer, Flowable<Integer>> func, TestSubscriber<Integer>
     public void testFastMergeFullScalar() {
         runMerge(toScalar, new TestSubscriber<Integer>());
     }
+
     @Test
     public void testFastMergeHiddenScalar() {
         runMerge(toHiddenScalar, new TestSubscriber<Integer>());
     }
+
     @Test
     public void testSlowMergeFullScalar() {
         for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
@@ -1382,6 +1384,7 @@ public void onNext(Integer t) {
             runMerge(toScalar, ts);
         }
     }
+
     @Test
     public void testSlowMergeHiddenScalar() {
         for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
@@ -1462,7 +1465,6 @@ public void mergeConcurrentJustRange() {
         ts.assertComplete();
     }
 
-
     @SuppressWarnings("unchecked")
     @Test
     @Ignore("No 2-9 argument merge()")
@@ -1622,7 +1624,6 @@ public void array() {
         }
     }
 
-
     @SuppressWarnings("unchecked")
     @Test
     public void mergeArray() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
Patch:
@@ -794,7 +794,6 @@ public void onNext(Integer t) {
         assertEquals(Arrays.asList(128L), requests);
     }
 
-
     @Test
     public void testErrorDelayed() {
         TestScheduler s = new TestScheduler();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatestTest.java
Patch:
@@ -37,6 +37,7 @@ public void testSimple() {
         ts.assertTerminated();
         ts.assertValues(1, 2, 3, 4, 5);
     }
+
     @Test
     public void testSimpleError() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
@@ -48,6 +49,7 @@ public void testSimpleError() {
         ts.assertError(TestException.class);
         ts.assertValues(1, 2, 3, 4, 5);
     }
+
     @Test
     public void testSimpleBackpressure() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>(2L);
@@ -100,6 +102,7 @@ public void testSynchronousDrop() {
         ts.assertNoErrors();
         ts.assertTerminated();
     }
+
     @Test
     public void testAsynchronousDrop() throws InterruptedException {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1L) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java
Patch:
@@ -242,7 +242,6 @@ public Integer apply(Throwable e) {
         ts.assertComplete();
     }
 
-
     @Test
     public void returnItem() {
         Flowable.error(new TestException())

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnExceptionResumeNextViaFlowableTest.java
Patch:
@@ -186,7 +186,6 @@ public String apply(String s) {
         verify(subscriber, times(1)).onComplete();
     }
 
-
     @Test
     public void testBackpressure() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticastTest.java
Patch:
@@ -152,7 +152,6 @@ public void errorAllCancelled() {
         mp.errorAll(null);
     }
 
-
     @Test
     public void completeAllCancelled() {
         MulticastProcessor<Integer> mp = new MulticastProcessor<Integer>(128, true);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java
Patch:
@@ -371,6 +371,7 @@ public void testZeroRequested() {
         ts.assertNoErrors();
         ts.assertTerminated();
     }
+
     @Test
     public void testConnectIsIdempotent() {
         final AtomicInteger calls = new AtomicInteger();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeLongTest.java
Patch:
@@ -164,18 +164,21 @@ void testWithBackpressureAllAtOnce(long start) {
         ts.assertValueSequence(list);
         ts.assertTerminated();
     }
+
     @Test
     public void testWithBackpressure1() {
         for (long i = 0; i < 100; i++) {
             testWithBackpressureOneByOne(i);
         }
     }
+
     @Test
     public void testWithBackpressureAllAtOnce() {
         for (long i = 0; i < 100; i++) {
             testWithBackpressureAllAtOnce(i);
         }
     }
+
     @Test
     public void testWithBackpressureRequestWayMore() {
         Flowable<Long> source = Flowable.rangeLong(50, 100);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReduceTest.java
Patch:
@@ -141,7 +141,6 @@ public void testBackpressureWithInitialValueFlowable() throws InterruptedExcepti
         assertEquals(21, r.intValue());
     }
 
-
     @Test
     public void testAggregateAsIntSum() {
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -876,6 +876,7 @@ public void testColdReplayNoBackpressure() {
             assertEquals((Integer)i, onNextEvents.get(i));
         }
     }
+
     @Test
     public void testColdReplayBackpressure() {
         Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();
@@ -995,6 +996,7 @@ public void testAsync() {
             assertEquals(10000, ts2.values().size());
         }
     }
+
     @Test
     public void testAsyncComeAndGo() {
         Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -433,6 +433,7 @@ public void request(long n) {
                         }
                     }
                 }
+
                 @Override
                 public void cancel() {
                     // TODO Auto-generated method stub
@@ -829,6 +830,7 @@ static <T> StringBuilder sequenceFrequency(Iterable<T> it) {
 
         return sb;
     }
+
     @Test//(timeout = 3000)
     public void testIssue1900() throws InterruptedException {
         Subscriber<String> subscriber = TestHelper.mockSubscriber();
@@ -869,6 +871,7 @@ public Flowable<String> apply(GroupedFlowable<String, String> t1) {
         inOrder.verify(subscriber, times(1)).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+
     @Test//(timeout = 3000)
     public void testIssue1900SourceNotSupportingBackpressure() {
         Subscriber<String> subscriber = TestHelper.mockSubscriber();
@@ -997,7 +1000,6 @@ public boolean getAsBoolean() throws Exception {
         .assertResult(1, 1, 1, 1, 1);
     }
 
-
     @Test
     public void shouldDisposeInnerObservable() {
       final PublishProcessor<Object> processor = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
Patch:
@@ -483,7 +483,6 @@ protected void subscribeActual(Subscriber<? super Object> s) {
         }
     }
 
-
     @Test
     public void longSequenceEquals() {
         Flowable<Integer> source = Flowable.range(1, Flowable.bufferSize() * 4).subscribeOn(Schedulers.computation());

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
Patch:
@@ -192,7 +192,6 @@ public void onNext(Integer t) {
         assertEquals(Arrays.asList(Long.MAX_VALUE), requests);
     }
 
-
     @Test
     public void testSingleWithPredicateFlowable() {
         Flowable<Integer> flowable = Flowable.just(1, 2)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmptyTest.java
Patch:
@@ -156,6 +156,7 @@ public void testSwitchRequestAlternativeObservableWithBackpressure() {
         ts.request(1);
         ts.assertValueCount(3);
     }
+
     @Test
     public void testBackpressureNoRequest() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
Patch:
@@ -583,7 +583,6 @@ public Flowable<Long> apply(Long t) {
         assertTrue(ts.valueCount() > 0);
     }
 
-
     @Test(timeout = 10000)
     public void testSecondaryRequestsDontOverflow() throws InterruptedException {
         TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTest.java
Patch:
@@ -241,7 +241,6 @@ public void onNext(Integer integer) {
         });
     }
 
-
     @Test
     public void testIgnoreRequest4() {
         // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
Patch:
@@ -451,7 +451,6 @@ public void accept(Integer v) {
         ts.assertComplete();
     }
 
-
     @Test
     public void takeNegative() {
         try {
@@ -485,7 +484,6 @@ public Flowable<Object> apply(Flowable<Object> f) throws Exception {
         });
     }
 
-
     @Test
     public void badRequest() {
         TestHelper.assertBadRequestReported(Flowable.never().take(1));

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java
Patch:
@@ -209,6 +209,7 @@ public void testUntilFires() {
         assertFalse("Until still has observers", until.hasSubscribers());
         assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
     }
+
     @Test
     public void testMainCompletes() {
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -232,6 +233,7 @@ public void testMainCompletes() {
         assertFalse("Until still has observers", until.hasSubscribers());
         assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
     }
+
     @Test
     public void testDownstreamUnsubscribes() {
         PublishProcessor<Integer> source = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
Patch:
@@ -153,7 +153,6 @@ public void testThrottle() {
         inOrder.verifyNoMoreInteractions();
     }
 
-
     @Test
     public void throttleFirstDefaultScheduler() {
         Flowable.just(1).throttleFirst(100, TimeUnit.MILLISECONDS)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleLatestTest.java
Patch:
@@ -130,7 +130,6 @@ public void normal() {
         ts.assertResult(1, 3, 5, 6);
     }
 
-
     @Test
     public void normalEmitLast() {
         TestScheduler sch = new TestScheduler();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
Patch:
@@ -477,7 +477,6 @@ protected void subscribeActual(Subscriber<? super Integer> subscriber) {
         }
     }
 
-
     @Test
     public void timedTake() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java
Patch:
@@ -86,6 +86,7 @@ public void testTimerPeriodically() {
         ts.assertNotComplete();
         ts.assertNoErrors();
     }
+
     @Test
     public void testInterval() {
         Flowable<Long> w = Flowable.interval(1, TimeUnit.SECONDS, scheduler);
@@ -226,6 +227,7 @@ public void testWithMultipleStaggeredSubscribersAndPublish() {
         ts2.assertNoErrors();
         ts2.assertNotComplete();
     }
+
     @Test
     public void testOnceObserverThrows() {
         Flowable<Long> source = Flowable.timer(100, TimeUnit.MILLISECONDS, scheduler);
@@ -254,6 +256,7 @@ public void onComplete() {
         verify(subscriber, never()).onNext(anyLong());
         verify(subscriber, never()).onComplete();
     }
+
     @Test
     public void testPeriodicObserverThrows() {
         Flowable<Long> source = Flowable.interval(100, 100, TimeUnit.MILLISECONDS, scheduler);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToMapTest.java
Patch:
@@ -224,7 +224,6 @@ public String apply(String v) {
         verify(objectSubscriber, times(1)).onError(any(Throwable.class));
     }
 
-
     @Test
     public void testToMap() {
         Flowable<String> source = Flowable.just("a", "bb", "ccc", "dddd");

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToMultimapTest.java
Patch:
@@ -296,7 +296,6 @@ public Map<Integer, Collection<String>> call() {
         verify(objectSubscriber, never()).onComplete();
     }
 
-
     @Test
     public void testToMultimap() {
         Flowable<String> source = Flowable.just("a", "b", "cc", "dd");

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
Patch:
@@ -69,6 +69,7 @@ public void testWithFollowingFirstFlowable() {
         Flowable<Integer> f = Flowable.just(1, 3, 2, 5, 4);
         assertEquals(Arrays.asList(1, 2, 3, 4, 5), f.toSortedList().toFlowable().blockingFirst());
     }
+
     @Test
     public void testBackpressureHonoredFlowable() {
         Flowable<List<Integer>> w = Flowable.just(1, 3, 2, 5, 4).toSortedList().toFlowable();
@@ -202,6 +203,7 @@ public void testWithFollowingFirst() {
         Flowable<Integer> f = Flowable.just(1, 3, 2, 5, 4);
         assertEquals(Arrays.asList(1, 2, 3, 4, 5), f.toSortedList().blockingGet());
     }
+
     @Test
     @Ignore("Single doesn't do backpressure")
     public void testBackpressureHonored() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
Patch:
@@ -331,8 +331,6 @@ public Flowable<String> apply(Resource resource) {
 
     }
 
-
-
     @Test
     public void testUsingDisposesEagerlyBeforeError() {
         final List<String> events = new ArrayList<String>();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithFlowableTest.java
Patch:
@@ -326,6 +326,7 @@ public Flowable<Integer> call() {
         ts.assertNoErrors();
         ts.assertValueCount(1);
     }
+
     @Test
     public void testMainUnsubscribedOnBoundaryCompletion() {
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -386,6 +387,7 @@ public Flowable<Integer> call() {
         ts.assertNoErrors();
         ts.assertValueCount(1);
     }
+
     @Test
     public void testInnerBackpressure() {
         Flowable<Integer> source = Flowable.range(1, 10);
@@ -771,7 +773,6 @@ public Flowable<Integer> apply(
         ts.assertResult(1);
     }
 
-
     @Test
     public void mainAndBoundaryBothError() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
Patch:
@@ -158,6 +158,7 @@ public void onNext(T args) {
             }
         };
     }
+
     @Test
     public void testExactWindowSize() {
         Flowable<Flowable<Integer>> source = Flowable.range(1, 10)
@@ -222,7 +223,6 @@ public void accept(Integer pv) {
         Assert.assertTrue(ts.valueCount() != 0);
     }
 
-
     @Test
     public void timespanTimeskipCustomSchedulerBufferSize() {
         Flowable.range(1, 10)
@@ -811,6 +811,7 @@ public void periodicWindowCompletionRestartTimerBoundedSomeData() {
         .assertNoErrors()
         .assertNotComplete();
     }
+
     @Test
     public void countRestartsOnTimeTick() {
         TestScheduler scheduler = new TestScheduler();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java
Patch:
@@ -134,7 +134,6 @@ public void testEmptyOther() {
         assertFalse(other.hasSubscribers());
     }
 
-
     @Test
     public void testUnsubscription() {
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -189,6 +188,7 @@ public void testSourceThrows() {
         assertFalse(source.hasSubscribers());
         assertFalse(other.hasSubscribers());
     }
+
     @Test
     public void testOtherThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
Patch:
@@ -1224,6 +1224,7 @@ public Integer apply(Integer i1, Integer i2) {
         }
         assertEquals(expected, zip2.toList().blockingGet());
     }
+
     @Test
     public void testUnboundedDownstreamOverrequesting() {
         Flowable<Integer> source = Flowable.range(1, 2).zipWith(Flowable.range(1, 2), new BiFunction<Integer, Integer, Integer>() {
@@ -1247,6 +1248,7 @@ public void onNext(Integer t) {
         ts.assertTerminated();
         ts.assertValues(11, 22);
     }
+
     @Test(timeout = 10000)
     public void testZipRace() {
         long startTime = System.currentTimeMillis();
@@ -1570,6 +1572,7 @@ public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integ
         .test()
         .assertResult("12345678");
     }
+
     @Test
     public void zip9() {
         Flowable.zip(Flowable.just(1),
@@ -1589,7 +1592,6 @@ public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integ
         .assertResult("123456789");
     }
 
-
     @Test
     public void zipArrayMany() {
         @SuppressWarnings("unchecked")

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeCacheTest.java
Patch:
@@ -52,7 +52,6 @@ public void offlineError() {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void offlineComplete() {
         Maybe<Integer> source = Maybe.<Integer>empty().cache();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeContainsTest.java
Patch:
@@ -59,7 +59,6 @@ public void dispose() {
         assertFalse(pp.hasSubscribers());
     }
 
-
     @Test
     public void isDisposed() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeDelayOtherTest.java
Patch:
@@ -65,7 +65,6 @@ public void justWithOnComplete() {
         to.assertResult(1);
     }
 
-
     @Test
     public void justWithOnError() {
         PublishProcessor<Object> pp = PublishProcessor.create();
@@ -102,7 +101,6 @@ public void emptyWithOnNext() {
         to.assertResult();
     }
 
-
     @Test
     public void emptyWithOnComplete() {
         PublishProcessor<Object> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeIsEmptyTest.java
Patch:
@@ -54,7 +54,6 @@ public void fusedBackToMaybe() {
         .toMaybe() instanceof MaybeIsEmpty);
     }
 
-
     @Test
     public void normalToMaybe() {
         Maybe.just(1)

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeSwitchIfEmptySingleTest.java
Patch:
@@ -61,7 +61,6 @@ public void dispose() {
         assertFalse(pp.hasSubscribers());
     }
 
-
     @Test
     public void isDisposed() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeSwitchIfEmptyTest.java
Patch:
@@ -76,7 +76,6 @@ public void dispose() {
         assertFalse(pp.hasSubscribers());
     }
 
-
     @Test
     public void isDisposed() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeUsingTest.java
Patch:
@@ -346,7 +346,6 @@ public void accept(Object d) throws Exception {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void emptyDisposerCrashes() {
         Maybe.using(new Callable<Object>() {

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeZipArrayTest.java
Patch:
@@ -150,6 +150,7 @@ public void run() {
             }
         }
     }
+
     @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void zipArrayOneIsNull() {

File: src/test/java/io/reactivex/internal/operators/mixed/CompletableAndThenObservableTest.java
Patch:
@@ -63,7 +63,6 @@ public void cancelOther() {
         assertFalse(ps.hasObservers());
     }
 
-
     @Test
     public void errorMain() {
         CompletableSubject cs = CompletableSubject.create();

File: src/test/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapMaybeTest.java
Patch:
@@ -399,7 +399,6 @@ public MaybeSource<Integer> apply(Integer v)
         }
     }
 
-
     @Test
     public void innerErrorAfterTermination() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapSingleTest.java
Patch:
@@ -347,7 +347,6 @@ public SingleSource<Integer> apply(Integer v)
         }
     }
 
-
     @Test
     public void innerErrorAfterTermination() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapMaybeTest.java
Patch:
@@ -375,7 +375,6 @@ public MaybeSource<Integer> apply(Integer v)
         }
     }
 
-
     @Test
     public void innerErrorAfterTermination() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapSingleTest.java
Patch:
@@ -344,7 +344,6 @@ public SingleSource<Integer> apply(Integer v)
         }
     }
 
-
     @Test
     public void innerErrorAfterTermination() {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableAllTest.java
Patch:
@@ -124,6 +124,7 @@ public boolean test(Integer i) {
 
         assertFalse(allOdd.blockingFirst());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstreamObservable() {
         Observable<Integer> source = Observable.just(1)
@@ -143,7 +144,6 @@ public Observable<Integer> apply(Boolean t1) {
         assertEquals((Object)2, source.blockingFirst());
     }
 
-
     @Test
     public void testPredicateThrowsExceptionAndValueInCauseMessageObservable() {
         TestObserver<Boolean> to = new TestObserver<Boolean>();
@@ -166,7 +166,6 @@ public boolean test(String v) {
 //        assertTrue(ex.getCause().getMessage().contains("Boo!"));
     }
 
-
     @Test
     public void testAll() {
         Observable<String> obs = Observable.just("one", "two", "six");
@@ -256,6 +255,7 @@ public boolean test(Integer i) {
 
         assertFalse(allOdd.blockingGet());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstream() {
         Observable<Integer> source = Observable.just(1)
@@ -275,7 +275,6 @@ public Observable<Integer> apply(Boolean t1) {
         assertEquals((Object)2, source.blockingFirst());
     }
 
-
     @Test
     public void testPredicateThrowsExceptionAndValueInCauseMessage() {
         TestObserver<Boolean> to = new TestObserver<Boolean>();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableAnyTest.java
Patch:
@@ -231,6 +231,7 @@ public boolean test(Integer i) {
 
         assertTrue(anyEven.blockingFirst());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstreamObservable() {
         Observable<Integer> source = Observable.just(1).isEmpty().toObservable()
@@ -452,6 +453,7 @@ public boolean test(Integer i) {
 
         assertTrue(anyEven.blockingGet());
     }
+
     @Test(timeout = 5000)
     public void testIssue1935NoUnsubscribeDownstream() {
         Observable<Integer> source = Observable.just(1).isEmpty()

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCacheTest.java
Patch:
@@ -154,6 +154,7 @@ public void testAsync() {
             assertEquals(10000, to2.values().size());
         }
     }
+
     @Test
     public void testAsyncComeAndGo() {
         Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapCompletableTest.java
Patch:
@@ -155,7 +155,6 @@ public void mapperThrows() {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void fusedPollThrows() {
         Observable.just(1)

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java
Patch:
@@ -623,7 +623,6 @@ public Observable<Integer> apply(Integer t) {
         to.assertValue(null);
     }
 
-
     @Test
     @Ignore("Observable doesn't do backpressure")
     public void testMaxConcurrent5() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java
Patch:
@@ -623,6 +623,7 @@ public Observable<Integer> apply(Integer v) {
         inOrder.verify(o).onSuccess(list);
         verify(o, never()).onError(any(Throwable.class));
     }
+
     @Test
     public void concatVeryLongObservableOfObservablesTakeHalf() {
         final int n = 10000;

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatWithMaybeTest.java
Patch:
@@ -42,7 +42,6 @@ public void run() throws Exception {
         to.assertResult(1, 2, 3, 4, 5, 100);
     }
 
-
     @Test
     public void normalNonEmpty() {
         final TestObserver<Integer> to = new TestObserver<Integer>();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
Patch:
@@ -239,6 +239,7 @@ public Observable<Integer> apply(Integer t1) {
         verify(o, never()).onComplete();
         verify(o).onError(any(TestException.class));
     }
+
     @Test
     public void debounceTimedLastIsNotLost() {
         PublishSubject<Integer> source = PublishSubject.create();
@@ -256,6 +257,7 @@ public void debounceTimedLastIsNotLost() {
         verify(o).onComplete();
         verify(o, never()).onError(any(Throwable.class));
     }
+
     @Test
     public void debounceSelectorLastIsNotLost() {
         PublishSubject<Integer> source = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDelaySubscriptionOtherTest.java
Patch:
@@ -203,7 +203,6 @@ public Object apply(Observable<Integer> o) throws Exception {
         }, false, 1, 1, 1);
     }
 
-
     @Test
     public void afterDelayNoInterrupt() {
         ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDetachTest.java
Patch:
@@ -85,7 +85,6 @@ public void range() {
         to.assertComplete();
     }
 
-
     @Test
     @Ignore("Observable doesn't do backpressure")
     public void backpressured() throws Exception {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDoFinallyTest.java
Patch:
@@ -159,7 +159,6 @@ public void asyncFusedBoundary() {
         assertEquals(1, calls);
     }
 
-
     @Test
     public void normalJustConditional() {
         Observable.just(1)
@@ -445,7 +444,6 @@ public void onComplete() {
         assertEquals(1, calls);
     }
 
-
     @Test
     public void eventOrdering() {
         final List<String> list = new ArrayList<String>();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableTest.java
Patch:
@@ -166,7 +166,6 @@ public CompletableSource apply(Integer v) throws Exception {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void fusedObservable() {
         TestObserver<Integer> to = ObserverFusion.newTest(QueueFuseable.ANY);
@@ -332,7 +331,6 @@ public CompletableSource apply(Integer v) throws Exception {
         .assertFailure(TestException.class);
     }
 
-
     @Test
     public void fused() {
         TestObserver<Integer> to = ObserverFusion.newTest(QueueFuseable.ANY);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java
Patch:
@@ -350,6 +350,7 @@ public Observable<Integer> apply(Integer t1) {
         Assert.assertEquals(expected.size(), to.valueCount());
         Assert.assertTrue(expected.containsAll(to.values()));
     }
+
     @Test
     public void testFlatMapSelectorMaxConcurrent() {
         final int m = 4;
@@ -471,6 +472,7 @@ public Observable<Integer> apply(Integer t) {
             }
         }
     }
+
     @Test(timeout = 30000)
     public void flatMapRangeMixedAsyncLoop() {
         for (int i = 0; i < 2000; i++) {
@@ -530,6 +532,7 @@ public Observable<Integer> apply(Integer t) {
             to.assertValueCount(1000);
         }
     }
+
     @Test
     public void flatMapTwoNestedSync() {
         for (final int n : new int[] { 1, 1000, 1000000 }) {
@@ -895,7 +898,6 @@ public Object apply(Integer v, Object w) throws Exception {
         .assertFailureAndMessage(NullPointerException.class, "The mapper returned a null ObservableSource");
     }
 
-
     @Test
     public void failingFusedInnerCancelsSource() {
         final AtomicInteger counter = new AtomicInteger();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeDelayErrorTest.java
Patch:
@@ -429,6 +429,7 @@ public void onNext(String args) {
         }
 
     }
+
     @Test
     @Ignore("Subscribers should not throw")
     public void testMergeSourceWhichDoesntPropagateExceptionBack() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
Patch:
@@ -1082,10 +1082,12 @@ void runMerge(Function<Integer, Observable<Integer>> func, TestObserver<Integer>
     public void testFastMergeFullScalar() {
         runMerge(toScalar, new TestObserver<Integer>());
     }
+
     @Test
     public void testFastMergeHiddenScalar() {
         runMerge(toHiddenScalar, new TestObserver<Integer>());
     }
+
     @Test
     public void testSlowMergeFullScalar() {
         for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
@@ -1103,6 +1105,7 @@ public void onNext(Integer t) {
             runMerge(toScalar, to);
         }
     }
+
     @Test
     public void testSlowMergeHiddenScalar() {
         for (final int req : new int[] { 16, 32, 64, 128, 256 }) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnExceptionResumeNextViaObservableTest.java
Patch:
@@ -183,7 +183,6 @@ public String apply(String s) {
         verify(observer, times(1)).onComplete();
     }
 
-
     @Test
     public void testBackpressure() {
         TestObserver<Integer> to = new TestObserver<Integer>();

File: src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java
Patch:
@@ -372,6 +372,7 @@ public void subscribe(Observer<? super Integer> t) {
 
         assertEquals(2, calls.get());
     }
+
     @Test
     public void testObserveOn() {
         ConnectableObservable<Integer> co = Observable.range(0, 1000).publish();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReduceTest.java
Patch:
@@ -145,7 +145,6 @@ public void testBackpressureWithInitialValueObservable() throws InterruptedExcep
         assertEquals(21, r.intValue());
     }
 
-
     @Test
     public void testAggregateAsIntSum() {
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
Patch:
@@ -986,6 +986,7 @@ public void testAsync() {
             assertEquals(10000, to2.values().size());
         }
     }
+
     @Test
     public void testAsyncComeAndGo() {
         Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
Patch:
@@ -779,6 +779,7 @@ static <T> StringBuilder sequenceFrequency(Iterable<T> it) {
 
         return sb;
     }
+
     @Test//(timeout = 3000)
     public void testIssue1900() throws InterruptedException {
         Observer<String> observer = TestHelper.mockObserver();
@@ -819,6 +820,7 @@ public Observable<String> apply(GroupedObservable<String, String> t1) {
         inOrder.verify(observer, times(1)).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+
     @Test//(timeout = 3000)
     public void testIssue1900SourceNotSupportingBackpressure() {
         Observer<String> observer = TestHelper.mockObserver();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java
Patch:
@@ -484,7 +484,6 @@ public void onNext(String t) {
         Assert.assertEquals(250, to.valueCount());
     }
 
-
     @Test
     public void delayErrors() {
         PublishSubject<ObservableSource<Integer>> source = PublishSubject.create();
@@ -608,7 +607,6 @@ public ObservableSource<Integer> apply(Object v) throws Exception {
 
     }
 
-
     @Test
     public void switchMapInnerCancelled() {
         PublishSubject<Integer> ps = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilTest.java
Patch:
@@ -210,6 +210,7 @@ public void testUntilFires() {
         // 2.0.2 - not anymore
 //        assertTrue("Not cancelled!", ts.isCancelled());
     }
+
     @Test
     public void testMainCompletes() {
         PublishSubject<Integer> source = PublishSubject.create();
@@ -234,6 +235,7 @@ public void testMainCompletes() {
         // 2.0.2 - not anymore
 //        assertTrue("Not cancelled!", ts.isCancelled());
     }
+
     @Test
     public void testDownstreamUnsubscribes() {
         PublishSubject<Integer> source = PublishSubject.create();
@@ -273,7 +275,6 @@ public Observable<Integer> apply(Observable<Integer> o) throws Exception {
         });
     }
 
-
     @Test
     public void untilPublisherMainSuccess() {
         PublishSubject<Integer> main = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleLatestTest.java
Patch:
@@ -129,7 +129,6 @@ public void normal() {
         to.assertResult(1, 3, 5, 6);
     }
 
-
     @Test
     public void normalEmitLast() {
         TestScheduler sch = new TestScheduler();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimerTest.java
Patch:
@@ -87,6 +87,7 @@ public void testTimerPeriodically() {
         to.assertNotComplete();
         to.assertNoErrors();
     }
+
     @Test
     public void testInterval() {
         Observable<Long> w = Observable.interval(1, TimeUnit.SECONDS, scheduler);
@@ -227,6 +228,7 @@ public void testWithMultipleStaggeredSubscribersAndPublish() {
         to2.assertNoErrors();
         to2.assertNotComplete();
     }
+
     @Test
     public void testOnceObserverThrows() {
         Observable<Long> source = Observable.timer(100, TimeUnit.MILLISECONDS, scheduler);
@@ -255,6 +257,7 @@ public void onComplete() {
         verify(observer, never()).onNext(anyLong());
         verify(observer, never()).onComplete();
     }
+
     @Test
     public void testPeriodicObserverThrows() {
         Observable<Long> source = Observable.interval(100, 100, TimeUnit.MILLISECONDS, scheduler);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableToMapTest.java
Patch:
@@ -225,7 +225,6 @@ public String apply(String v) {
         verify(objectObserver, times(1)).onError(any(Throwable.class));
     }
 
-
     @Test
     public void testToMap() {
         Observable<String> source = Observable.just("a", "bb", "ccc", "dddd");

File: src/test/java/io/reactivex/internal/operators/observable/ObservableToMultimapTest.java
Patch:
@@ -296,8 +296,6 @@ public Map<Integer, Collection<String>> call() {
         verify(objectObserver, never()).onComplete();
     }
 
-
-
     @Test
     public void testToMultimap() {
         Observable<String> source = Observable.just("a", "b", "cc", "dd");

File: src/test/java/io/reactivex/internal/operators/observable/ObservableToSortedListTest.java
Patch:
@@ -115,7 +115,6 @@ public int compare(Integer a, Integer b) {
         .assertResult(Arrays.asList(5, 4, 3, 2, 1));
     }
 
-
     @Test
     public void testSortedList() {
         Observable<Integer> w = Observable.just(1, 3, 2, 5, 4);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
Patch:
@@ -330,8 +330,6 @@ public Observable<String> apply(Resource resource) {
 
     }
 
-
-
     @Test
     public void testUsingDisposesEagerlyBeforeError() {
         final List<String> events = new ArrayList<String>();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithObservableTest.java
Patch:
@@ -329,6 +329,7 @@ public Observable<Integer> call() {
         to.assertNoErrors();
         to.assertValueCount(1);
     }
+
     @Test
     public void testMainUnsubscribedOnBoundaryCompletion() {
         PublishSubject<Integer> source = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
Patch:
@@ -158,6 +158,7 @@ public void onNext(T args) {
             }
         };
     }
+
     @Test
     public void testExactWindowSize() {
         Observable<Observable<Integer>> source = Observable.range(1, 10)

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java
Patch:
@@ -134,7 +134,6 @@ public void testEmptyOther() {
         assertFalse(other.hasObservers());
     }
 
-
     @Test
     public void testUnsubscription() {
         PublishSubject<Integer> source = PublishSubject.create();
@@ -189,6 +188,7 @@ public void testSourceThrows() {
         assertFalse(source.hasObservers());
         assertFalse(other.hasObservers());
     }
+
     @Test
     public void testOtherThrows() {
         PublishSubject<Integer> source = PublishSubject.create();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java
Patch:
@@ -1261,6 +1261,7 @@ public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integ
         .test()
         .assertResult("12345678");
     }
+
     @Test
     public void zip9() {
         Observable.zip(Observable.just(1),

File: src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java
Patch:
@@ -163,7 +163,6 @@ public void subscribe(SingleEmitter<Integer> s) throws Exception {
         assertEquals(1, calls[0]);
     }
 
-
     @SuppressWarnings("unchecked")
     @Test
     public void noSubsequentSubscriptionIterable() {

File: src/test/java/io/reactivex/internal/operators/single/SingleFlatMapTest.java
Patch:
@@ -105,7 +105,6 @@ public Completable apply(Integer t) throws Exception {
         assertFalse(b[0]);
     }
 
-
     @Test
     public void flatMapObservable() {
         Single.just(1).flatMapObservable(new Function<Integer, Observable<Integer>>() {

File: src/test/java/io/reactivex/internal/operators/single/SingleFromCallableTest.java
Patch:
@@ -111,7 +111,6 @@ public void shouldNotInvokeFuncUntilSubscription() throws Exception {
         verify(func).call();
     }
 
-
     @Test
     public void noErrorLoss() throws Exception {
         List<Throwable> errors = TestHelper.trackPluginErrors();

File: src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java
Patch:
@@ -125,7 +125,6 @@ public void mergeDelayError3() {
         .assertFailure(TestException.class, 1, 2);
     }
 
-
     @Test
     public void mergeDelayError4() {
         Single.mergeDelayError(

File: src/test/java/io/reactivex/internal/operators/single/SingleTakeUntilTest.java
Patch:
@@ -59,7 +59,6 @@ public void mainSuccessSingle() {
         to.assertResult(1);
     }
 
-
     @Test
     public void mainSuccessCompletable() {
         PublishProcessor<Integer> pp = PublishProcessor.create();

File: src/test/java/io/reactivex/internal/operators/single/SingleZipArrayTest.java
Patch:
@@ -150,6 +150,7 @@ public void run() {
             }
         }
     }
+
     @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void zipArrayOneIsNull() {

File: src/test/java/io/reactivex/internal/schedulers/AbstractDirectTaskTest.java
Patch:
@@ -115,6 +115,7 @@ public boolean cancel(boolean mayInterruptIfRunning) {
 
         assertTrue(interrupted[0]);
     }
+
     @Test
     public void setFutureCancelSameThread() {
         AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE) {

File: src/test/java/io/reactivex/internal/schedulers/ImmediateThinSchedulerTest.java
Patch:
@@ -47,6 +47,7 @@ public void scheduleDirectTimed() {
     public void scheduleDirectPeriodic() {
         ImmediateThinScheduler.INSTANCE.schedulePeriodicallyDirect(Functions.EMPTY_RUNNABLE, 1, 1, TimeUnit.SECONDS);
     }
+
     @Test
     public void schedule() {
         final int[] count = { 0 };

File: src/test/java/io/reactivex/internal/schedulers/ScheduledRunnableTest.java
Patch:
@@ -372,7 +372,6 @@ public void asyncDisposeIdempotent() {
         assertEquals(ScheduledRunnable.ASYNC_DISPOSED, run.get(ScheduledRunnable.FUTURE_INDEX));
     }
 
-
     @Test
     public void noParentIsDisposed() {
         ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, null);

File: src/test/java/io/reactivex/internal/subscribers/BlockingSubscriberTest.java
Patch:
@@ -93,6 +93,7 @@ public void cancelOnRequest() {
             public void request(long n) {
                 bf.cancelled = true;
             }
+
             @Override
             public void cancel() {
                 b.set(true);
@@ -118,6 +119,7 @@ public void cancelUpfront() {
             public void request(long n) {
                 b.set(true);
             }
+
             @Override
             public void cancel() {
             }

File: src/test/java/io/reactivex/internal/subscribers/DeferredScalarSubscriberTest.java
Patch:
@@ -303,6 +303,7 @@ public void callsAfterUnsubscribe() {
         ts.assertNoErrors();
         ts.assertNotComplete();
     }
+
     @Test
     public void emissionRequestRace() {
         Worker w = Schedulers.computation().createWorker();

File: src/test/java/io/reactivex/internal/subscribers/LambdaSubscriberTest.java
Patch:
@@ -242,6 +242,7 @@ public void accept(Subscription s) throws Exception {
 
         assertEquals(Arrays.asList(1, 100), received);
     }
+
     @Test
     public void badSourceEmitAfterDone() {
         Flowable<Integer> source = Flowable.fromPublisher(new Publisher<Integer>() {

File: src/test/java/io/reactivex/internal/util/QueueDrainHelperTest.java
Patch:
@@ -814,6 +814,7 @@ public void accept(Observer<? super Integer> a, Integer v) {
 
         to.assertFailure(TestException.class);
     }
+
     @Test
     public void observerCheckTerminatedNonDelayErrorErrorResource() {
         TestObserver<Integer> to = new TestObserver<Integer>();

File: src/test/java/io/reactivex/maybe/MaybeCreateTest.java
Patch:
@@ -92,7 +92,6 @@ public void subscribe(MaybeEmitter<Integer> e) throws Exception {
         assertTrue(d.isDisposed());
     }
 
-
     @Test
     public void basicWithCompletion() {
         final Disposable d = Disposables.empty();

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -2768,7 +2768,6 @@ public Object apply(Integer a, Integer b) {
         });
     }
 
-
     @Test(expected = NullPointerException.class)
     public void zipWithCombinerNull() {
         just1.zipWith(just1, null);

File: src/test/java/io/reactivex/observable/ObservableReduceTests.java
Patch:
@@ -77,7 +77,6 @@ public Movie apply(Movie t1, Movie t2) {
         assertNotNull(reduceResult2);
     }
 
-
     @Test
     public void reduceInts() {
         Observable<Integer> o = Observable.just(1, 2, 3);

File: src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
Patch:
@@ -180,7 +180,6 @@ public void safeSubscriberAlreadySafe() {
         to.assertResult(1);
     }
 
-
     @Test
     public void methodTestNoCancel() {
         PublishSubject<Integer> ps = PublishSubject.create();

File: src/test/java/io/reactivex/observable/ObservableTest.java
Patch:
@@ -145,7 +145,6 @@ public Throwable call() {
         verify(w, times(1)).onError(any(RuntimeException.class));
     }
 
-
     @Test
     public void testCountAFewItems() {
         Observable<String> o = Observable.just("a", "b", "c", "d");

File: src/test/java/io/reactivex/observers/SerializedObserverTest.java
Patch:
@@ -974,6 +974,7 @@ public void onNext(Integer v) {
         to.assertValue(1);
         to.assertError(TestException.class);
     }
+
     @Test
     public void testCompleteReentry() {
         final AtomicReference<Observer<Integer>> serial = new AtomicReference<Observer<Integer>>();

File: src/test/java/io/reactivex/observers/TestObserverTest.java
Patch:
@@ -272,6 +272,7 @@ public void testTerminalErrorOnce() {
         }
         fail("Failed to report multiple onError terminal events!");
     }
+
     @Test
     public void testTerminalCompletedOnce() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();

File: src/test/java/io/reactivex/parallel/ParallelDoOnNextTryTest.java
Patch:
@@ -49,6 +49,7 @@ public void doOnNextNoError() {
             calls = 0;
         }
     }
+
     @Test
     public void doOnNextErrorNoError() {
         for (ParallelFailureHandling e : ParallelFailureHandling.values()) {

File: src/test/java/io/reactivex/parallel/ParallelFilterTryTest.java
Patch:
@@ -94,6 +94,7 @@ public void filterConditionalNoError() {
             .assertResult(1);
         }
     }
+
     @Test
     public void filterErrorConditionalNoError() {
         for (ParallelFailureHandling e : ParallelFailureHandling.values()) {

File: src/test/java/io/reactivex/parallel/ParallelFlowableTest.java
Patch:
@@ -454,7 +454,6 @@ public void accept(List<Integer> v) throws Exception {
         }
     }
 
-
     @Test
     public void collectAsync2() {
         ExecutorService exec = Executors.newFixedThreadPool(3);
@@ -551,7 +550,6 @@ public void accept(List<Integer> v) throws Exception {
         }
     }
 
-
     @Test
     public void collectAsync3Fused() {
         ExecutorService exec = Executors.newFixedThreadPool(3);

File: src/test/java/io/reactivex/parallel/ParallelMapTryTest.java
Patch:
@@ -44,6 +44,7 @@ public void mapNoError() {
             .assertResult(1);
         }
     }
+
     @Test
     public void mapErrorNoError() {
         for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
@@ -68,6 +69,7 @@ public void mapConditionalNoError() {
             .assertResult(1);
         }
     }
+
     @Test
     public void mapErrorConditionalNoError() {
         for (ParallelFailureHandling e : ParallelFailureHandling.values()) {

File: src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
Patch:
@@ -1954,7 +1954,6 @@ public Subscriber apply(Flowable f, Subscriber s) throws Exception {
         }
     }
 
-
     @SuppressWarnings("rawtypes")
     @Test
     public void maybeCreate() {

File: src/test/java/io/reactivex/processors/AsyncProcessorTest.java
Patch:
@@ -368,6 +368,7 @@ public void testCurrentStateMethodsEmpty() {
         assertNull(as.getValue());
         assertNull(as.getThrowable());
     }
+
     @Test
     public void testCurrentStateMethodsError() {
         AsyncProcessor<Object> as = AsyncProcessor.create();

File: src/test/java/io/reactivex/processors/MulticastProcessorTest.java
Patch:
@@ -185,7 +185,6 @@ public void longRunning() {
         mp.test().assertValueCount(1000).assertNoErrors().assertComplete();
     }
 
-
     @Test
     public void oneByOne() {
         MulticastProcessor<Integer> mp = MulticastProcessor.create(16);
@@ -419,7 +418,6 @@ public void onNextNull() {
         mp.onNext(null);
     }
 
-
     @Test(expected = NullPointerException.class)
     public void onOfferNull() {
         MulticastProcessor<Integer> mp = MulticastProcessor.create(4, false);
@@ -623,7 +621,6 @@ public void cancelUpfront() {
         assertFalse(mp.hasSubscribers());
     }
 
-
     @Test
     public void cancelUpfrontOtherConsumersPresent() {
         MulticastProcessor<Integer> mp = MulticastProcessor.create();

File: src/test/java/io/reactivex/processors/PublishProcessorTest.java
Patch:
@@ -384,6 +384,7 @@ public void onComplete() {
 //        // even though the onError above throws we should still receive it on the other subscriber
 //        assertEquals(1, ts.getOnErrorEvents().size());
 //    }
+
     @Test
     public void testCurrentStateMethodsNormal() {
         PublishProcessor<Object> as = PublishProcessor.create();
@@ -419,6 +420,7 @@ public void testCurrentStateMethodsEmpty() {
         assertTrue(as.hasComplete());
         assertNull(as.getThrowable());
     }
+
     @Test
     public void testCurrentStateMethodsError() {
         PublishProcessor<Object> as = PublishProcessor.create();

File: src/test/java/io/reactivex/processors/ReplayProcessorConcurrencyTest.java
Patch:
@@ -318,6 +318,7 @@ public void run() {
             }
         }
     }
+
     @Test
     public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
         Scheduler s = Schedulers.io();
@@ -391,6 +392,7 @@ public void run() {
             worker.dispose();
         }
     }
+
     @Test(timeout = 10000)
     public void testConcurrentSizeAndHasAnyValue() throws InterruptedException {
         final ReplayProcessor<Object> rs = ReplayProcessor.create();

File: src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
Patch:
@@ -111,7 +111,6 @@ public void accept(String t) {
         });
     }
 
-
     @Test
     public final void testMergeWithExecutorScheduler() {
 

File: src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java
Patch:
@@ -204,6 +204,7 @@ public void run() {
             w.dispose();
         }
     }
+
     @Test
     public void testCancelledWorkerDoesntRunTasks() {
         final AtomicInteger calls = new AtomicInteger();

File: src/test/java/io/reactivex/schedulers/SchedulerTest.java
Patch:
@@ -204,7 +204,6 @@ public void run() {
 
     }
 
-
     @Test
     public void periodicDirectTaskRaceIO() throws Exception {
         final Scheduler scheduler = Schedulers.io();

File: src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
Patch:
@@ -232,9 +232,9 @@ public void timedRunnableToString() {
         TimedRunnable r = new TimedRunnable((TestWorker) new TestScheduler().createWorker(), 5, new Runnable() {
             @Override
             public void run() {
-                // TODO Auto-generated method stub
-
+                // deliberately no-op
             }
+
             @Override
             public String toString() {
                 return "Runnable";

File: src/test/java/io/reactivex/single/SingleNullTests.java
Patch:
@@ -809,6 +809,7 @@ public void subscribeOnErrorNull() {
             public void accept(Integer v) { }
         }, null);
     }
+
     @Test(expected = NullPointerException.class)
     public void subscribeSubscriberNull() {
         just1.toFlowable().subscribe((Subscriber<Integer>)null);

File: src/test/java/io/reactivex/subjects/AsyncSubjectTest.java
Patch:
@@ -367,6 +367,7 @@ public void testCurrentStateMethodsEmpty() {
         assertNull(as.getValue());
         assertNull(as.getThrowable());
     }
+
     @Test
     public void testCurrentStateMethodsError() {
         AsyncSubject<Object> as = AsyncSubject.create();
@@ -386,7 +387,6 @@ public void testCurrentStateMethodsError() {
         assertTrue(as.getThrowable() instanceof TestException);
     }
 
-
     @Test
     public void fusionLive() {
         AsyncSubject<Integer> ap = new AsyncSubject<Integer>();

File: src/test/java/io/reactivex/subjects/PublishSubjectTest.java
Patch:
@@ -384,6 +384,7 @@ public void onComplete() {
 //        // even though the onError above throws we should still receive it on the other subscriber
 //        assertEquals(1, to.getOnErrorEvents().size());
 //    }
+
     @Test
     public void testCurrentStateMethodsNormal() {
         PublishSubject<Object> as = PublishSubject.create();
@@ -419,6 +420,7 @@ public void testCurrentStateMethodsEmpty() {
         assertTrue(as.hasComplete());
         assertNull(as.getThrowable());
     }
+
     @Test
     public void testCurrentStateMethodsError() {
         PublishSubject<Object> as = PublishSubject.create();

File: src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java
Patch:
@@ -322,6 +322,7 @@ public void run() {
             }
         }
     }
+
     @Test
     public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
         Scheduler s = Schedulers.io();
@@ -395,6 +396,7 @@ public void run() {
             worker.dispose();
         }
     }
+
     @Test(timeout = 10000)
     public void testConcurrentSizeAndHasAnyValue() throws InterruptedException {
         final ReplaySubject<Object> rs = ReplaySubject.create();

File: src/test/java/io/reactivex/subscribers/SafeSubscriberWithPluginTest.java
Patch:
@@ -171,6 +171,7 @@ public void onError(Throwable e) {
 
         safe.onError(new TestException());
     }
+
     @Test(expected = RuntimeException.class)
     @Ignore("Subscribers can't throw")
     public void testPluginExceptionWhileOnErrorThrowsAndUnsubscribeThrows() {
@@ -195,6 +196,7 @@ public void onError(Throwable e) {
 
         safe.onError(new TestException());
     }
+
     @Test(expected = RuntimeException.class)
     @Ignore("Subscribers can't throw")
     public void testPluginExceptionWhenUnsubscribing2() {

File: src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java
Patch:
@@ -976,6 +976,7 @@ public void onNext(Integer v) {
         ts.assertValue(1);
         ts.assertError(TestException.class);
     }
+
     @Test
     public void testCompleteReentry() {
         final AtomicReference<Subscriber<Integer>> serial = new AtomicReference<Subscriber<Integer>>();

File: src/test/java/io/reactivex/subscribers/TestSubscriberTest.java
Patch:
@@ -746,7 +746,6 @@ public void onError(Throwable e) {
         ts.awaitTerminalEvent();
     }
 
-
     @Test
     public void createDelegate() {
         TestSubscriber<Integer> ts1 = TestSubscriber.create();
@@ -1611,7 +1610,6 @@ public void onComplete() {
         }
     }
 
-
     @Test
     public void syncQueueThrows() {
         TestSubscriber<Object> ts = new TestSubscriber<Object>();
@@ -1826,7 +1824,6 @@ public void timeoutIndicated2() throws InterruptedException {
         }
     }
 
-
     @Test
     public void timeoutIndicated3() throws InterruptedException {
         TestSubscriber<Object> ts = Flowable.never()

File: src/test/java/io/reactivex/tck/BaseTck.java
Patch:
@@ -44,7 +44,6 @@ public Publisher<T> createFailedPublisher() {
         return Flowable.error(new TestException());
     }
 
-
     @Override
     public long maxElementsFromPublisher() {
         return 1024;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -113,7 +113,7 @@ public final void onSubscribe(Subscription s) {
 
                 if (s instanceof QueueSubscription) {
                     @SuppressWarnings("unchecked") QueueSubscription<T> f = (QueueSubscription<T>)s;
-                    int m = f.requestFusion(QueueSubscription.ANY);
+                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);
                     if (m == QueueSubscription.SYNC) {
                         sourceMode = m;
                         queue = f;

File: src/test/java/io/reactivex/validators/JavadocForAnnotations.java
Patch:
@@ -129,8 +129,10 @@ static final void scanForBadMethod(StringBuilder sourceCode, String annotation,
                     if ((ll < 0 || ll > idx) && (lm < 0 || lm > idx)) {
 
                         int n = sourceCode.indexOf("{@code ", k);
+                        int endDD = sourceCode.indexOf("</dd>", k);
+                        // make sure the {@code is within the dt/dd section
 
-                        if (n < idx) {
+                        if (n < idx && n < endDD) {
                             int m = sourceCode.indexOf("}", n);
 
                             if (m < idx) {

File: src/jmh/java/io/reactivex/InputWithIncrementingInteger.java
Patch:
@@ -94,7 +94,7 @@ public void subscribe(Subscriber<? super Integer> s) {
     }
 
     public Iterable<Integer> iterable;
-    public Flowable<Integer> observable;
+    public Flowable<Integer> flowable;
     public Flowable<Integer> firehose;
     public Blackhole bh;
 
@@ -104,7 +104,7 @@ public void subscribe(Subscriber<? super Integer> s) {
     public void setup(final Blackhole bh) {
         this.bh = bh;
         final int size = getSize();
-        observable = Flowable.range(0, size);
+        flowable = Flowable.range(0, size);
 
         firehose = Flowable.unsafeCreate(new IncrementingPublisher(size));
         iterable = new IncrementingIterable(size);

File: src/jmh/java/io/reactivex/OperatorFlatMapPerf.java
Patch:
@@ -42,7 +42,7 @@ public int getSize() {
 
     @Benchmark
     public void flatMapIntPassthruSync(Input input) throws InterruptedException {
-        input.observable.flatMap(new Function<Integer, Publisher<Integer>>() {
+        input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
             public Publisher<Integer> apply(Integer v) {
                 return Flowable.just(v);
@@ -53,7 +53,7 @@ public Publisher<Integer> apply(Integer v) {
     @Benchmark
     public void flatMapIntPassthruAsync(Input input) throws InterruptedException {
         PerfSubscriber latchedObserver = input.newLatchedObserver();
-        input.observable.flatMap(new Function<Integer, Publisher<Integer>>() {
+        input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
             public Publisher<Integer> apply(Integer i) {
                     return Flowable.just(i).subscribeOn(Schedulers.computation());
@@ -71,7 +71,7 @@ public void flatMapTwoNestedSync(final Input input) throws InterruptedException
         Flowable.range(1, 2).flatMap(new Function<Integer, Publisher<Integer>>() {
             @Override
             public Publisher<Integer> apply(Integer i) {
-                    return input.observable;
+                    return input.flowable;
             }
         }).subscribe(input.newSubscriber());
     }

File: src/jmh/java/io/reactivex/OperatorMergePerf.java
Patch:
@@ -68,7 +68,7 @@ public Flowable<Integer> apply(Integer i) {
 
     @Benchmark
     public void mergeNSyncStreamsOfN(final InputThousand input) throws InterruptedException {
-        Flowable<Flowable<Integer>> os = input.observable.map(new Function<Integer, Flowable<Integer>>() {
+        Flowable<Flowable<Integer>> os = input.flowable.map(new Function<Integer, Flowable<Integer>>() {
             @Override
             public Flowable<Integer> apply(Integer i) {
                     return Flowable.range(0, input.size);
@@ -85,7 +85,7 @@ public Flowable<Integer> apply(Integer i) {
 
     @Benchmark
     public void mergeNAsyncStreamsOfN(final InputThousand input) throws InterruptedException {
-        Flowable<Flowable<Integer>> os = input.observable.map(new Function<Integer, Flowable<Integer>>() {
+        Flowable<Flowable<Integer>> os = input.flowable.map(new Function<Integer, Flowable<Integer>>() {
             @Override
             public Flowable<Integer> apply(Integer i) {
                     return Flowable.range(0, input.size).subscribeOn(Schedulers.computation());

File: src/main/java/io/reactivex/FlowableOperator.java
Patch:
@@ -25,10 +25,10 @@
 public interface FlowableOperator<Downstream, Upstream> {
     /**
      * Applies a function to the child Subscriber and returns a new parent Subscriber.
-     * @param observer the child Subscriber instance
+     * @param subscriber the child Subscriber instance
      * @return the parent Subscriber instance
      * @throws Exception on failure
      */
     @NonNull
-    Subscriber<? super Upstream> apply(@NonNull Subscriber<? super Downstream> observer) throws Exception;
+    Subscriber<? super Upstream> apply(@NonNull Subscriber<? super Downstream> subscriber) throws Exception;
 }

File: src/main/java/io/reactivex/internal/observers/SubscriberCompletableObserver.java
Patch:
@@ -24,8 +24,8 @@ public final class SubscriberCompletableObserver<T> implements CompletableObserv
 
     Disposable d;
 
-    public SubscriberCompletableObserver(Subscriber<? super T> observer) {
-        this.subscriber = observer;
+    public SubscriberCompletableObserver(Subscriber<? super T> subscriber) {
+        this.subscriber = subscriber;
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
Patch:
@@ -36,8 +36,8 @@ public CompletableConcat(Publisher<? extends CompletableSource> sources, int pre
     }
 
     @Override
-    public void subscribeActual(CompletableObserver s) {
-        sources.subscribe(new CompletableConcatSubscriber(s, prefetch));
+    public void subscribeActual(CompletableObserver observer) {
+        sources.subscribe(new CompletableConcatSubscriber(observer, prefetch));
     }
 
     static final class CompletableConcatSubscriber

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java
Patch:
@@ -27,9 +27,9 @@ public CompletableConcatArray(CompletableSource[] sources) {
     }
 
     @Override
-    public void subscribeActual(CompletableObserver s) {
-        ConcatInnerObserver inner = new ConcatInnerObserver(s, sources);
-        s.onSubscribe(inner.sd);
+    public void subscribeActual(CompletableObserver observer) {
+        ConcatInnerObserver inner = new ConcatInnerObserver(observer, sources);
+        observer.onSubscribe(inner.sd);
         inner.next();
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java
Patch:
@@ -31,9 +31,9 @@ public CompletableCreate(CompletableOnSubscribe source) {
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        Emitter parent = new Emitter(s);
-        s.onSubscribe(parent);
+    protected void subscribeActual(CompletableObserver observer) {
+        Emitter parent = new Emitter(observer);
+        observer.onSubscribe(parent);
 
         try {
             source.subscribe(parent);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDefer.java
Patch:
@@ -29,18 +29,18 @@ public CompletableDefer(Callable<? extends CompletableSource> completableSupplie
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
+    protected void subscribeActual(CompletableObserver observer) {
         CompletableSource c;
 
         try {
             c = ObjectHelper.requireNonNull(completableSupplier.call(), "The completableSupplier returned a null CompletableSource");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            EmptyDisposable.error(e, s);
+            EmptyDisposable.error(e, observer);
             return;
         }
 
-        c.subscribe(s);
+        c.subscribe(observer);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java
Patch:
@@ -41,8 +41,8 @@ public CompletableDelay(CompletableSource source, long delay, TimeUnit unit, Sch
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
-        source.subscribe(new Delay(s, delay, unit, scheduler, delayError));
+    protected void subscribeActual(final CompletableObserver observer) {
+        source.subscribe(new Delay(observer, delay, unit, scheduler, delayError));
     }
 
     static final class Delay extends AtomicReference<Disposable>

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDoFinally.java
Patch:
@@ -39,8 +39,8 @@ public CompletableDoFinally(CompletableSource source, Action onFinally) {
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        source.subscribe(new DoFinallyObserver(s, onFinally));
+    protected void subscribeActual(CompletableObserver observer) {
+        source.subscribe(new DoFinallyObserver(observer, onFinally));
     }
 
     static final class DoFinallyObserver extends AtomicInteger implements CompletableObserver, Disposable {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDoOnEvent.java
Patch:
@@ -31,8 +31,8 @@ public CompletableDoOnEvent(final CompletableSource source, final Consumer<? sup
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
-        source.subscribe(new DoOnEvent(s));
+    protected void subscribeActual(final CompletableObserver observer) {
+        source.subscribe(new DoOnEvent(observer));
     }
 
     final class DoOnEvent implements CompletableObserver {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableEmpty.java
Patch:
@@ -23,7 +23,7 @@ private CompletableEmpty() {
     }
 
     @Override
-    public void subscribeActual(CompletableObserver s) {
-        EmptyDisposable.complete(s);
+    public void subscribeActual(CompletableObserver observer) {
+        EmptyDisposable.complete(observer);
     }
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableError.java
Patch:
@@ -25,7 +25,7 @@ public CompletableError(Throwable error) {
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        EmptyDisposable.error(error, s);
+    protected void subscribeActual(CompletableObserver observer) {
+        EmptyDisposable.error(error, observer);
     }
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java
Patch:
@@ -29,7 +29,7 @@ public CompletableErrorSupplier(Callable<? extends Throwable> errorSupplier) {
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
+    protected void subscribeActual(CompletableObserver observer) {
         Throwable error;
 
         try {
@@ -39,7 +39,7 @@ protected void subscribeActual(CompletableObserver s) {
             error = e;
         }
 
-        EmptyDisposable.error(error, s);
+        EmptyDisposable.error(error, observer);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -25,8 +25,8 @@ public CompletableFromObservable(ObservableSource<T> observable) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
-        observable.subscribe(new CompletableFromObservableObserver<T>(s));
+    protected void subscribeActual(final CompletableObserver observer) {
+        observable.subscribe(new CompletableFromObservableObserver<T>(observer));
     }
 
     static final class CompletableFromObservableObserver<T> implements Observer<T> {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -25,8 +25,8 @@ public CompletableFromSingle(SingleSource<T> single) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
-        single.subscribe(new CompletableFromSingleObserver<T>(s));
+    protected void subscribeActual(final CompletableObserver observer) {
+        single.subscribe(new CompletableFromSingleObserver<T>(observer));
     }
 
     static final class CompletableFromSingleObserver<T> implements SingleObserver<T> {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableLift.java
Patch:
@@ -29,11 +29,11 @@ public CompletableLift(CompletableSource source, CompletableOperator onLift) {
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
+    protected void subscribeActual(CompletableObserver observer) {
         try {
             // TODO plugin wrapping
 
-            CompletableObserver sw = onLift.apply(s);
+            CompletableObserver sw = onLift.apply(observer);
 
             source.subscribe(sw);
         } catch (NullPointerException ex) { // NOPMD

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
Patch:
@@ -36,8 +36,8 @@ public CompletableMerge(Publisher<? extends CompletableSource> source, int maxCo
     }
 
     @Override
-    public void subscribeActual(CompletableObserver s) {
-        CompletableMergeSubscriber parent = new CompletableMergeSubscriber(s, maxConcurrency, delayErrors);
+    public void subscribeActual(CompletableObserver observer) {
+        CompletableMergeSubscriber parent = new CompletableMergeSubscriber(observer, maxConcurrency, delayErrors);
         source.subscribe(parent);
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
Patch:
@@ -27,12 +27,12 @@ public CompletableMergeArray(CompletableSource[] sources) {
     }
 
     @Override
-    public void subscribeActual(final CompletableObserver s) {
+    public void subscribeActual(final CompletableObserver observer) {
         final CompositeDisposable set = new CompositeDisposable();
         final AtomicBoolean once = new AtomicBoolean();
 
-        InnerCompletableObserver shared = new InnerCompletableObserver(s, once, set, sources.length + 1);
-        s.onSubscribe(set);
+        InnerCompletableObserver shared = new InnerCompletableObserver(observer, once, set, sources.length + 1);
+        observer.onSubscribe(set);
 
         for (CompletableSource c : sources) {
             if (set.isDisposed()) {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableNever.java
Patch:
@@ -23,8 +23,8 @@ private CompletableNever() {
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        s.onSubscribe(EmptyDisposable.NEVER);
+    protected void subscribeActual(CompletableObserver observer) {
+        observer.onSubscribe(EmptyDisposable.NEVER);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableObserveOn.java
Patch:
@@ -30,8 +30,8 @@ public CompletableObserveOn(CompletableSource source, Scheduler scheduler) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
-        source.subscribe(new ObserveOnCompletableObserver(s, scheduler));
+    protected void subscribeActual(final CompletableObserver observer) {
+        source.subscribe(new ObserveOnCompletableObserver(observer, scheduler));
     }
 
     static final class ObserveOnCompletableObserver

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -46,9 +46,9 @@ public CompletablePeek(CompletableSource source, Consumer<? super Disposable> on
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
+    protected void subscribeActual(final CompletableObserver observer) {
 
-        source.subscribe(new CompletableObserverImplementation(s));
+        source.subscribe(new CompletableObserverImplementation(observer));
     }
 
     final class CompletableObserverImplementation implements CompletableObserver, Disposable {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java
Patch:
@@ -30,10 +30,10 @@ public CompletableSubscribeOn(CompletableSource source, Scheduler scheduler) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
+    protected void subscribeActual(final CompletableObserver observer) {
 
-        final SubscribeOnObserver parent = new SubscribeOnObserver(s, source);
-        s.onSubscribe(parent);
+        final SubscribeOnObserver parent = new SubscribeOnObserver(observer, source);
+        observer.onSubscribe(parent);
 
         Disposable f = scheduler.scheduleDirect(parent);
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTakeUntilCompletable.java
Patch:
@@ -38,9 +38,9 @@ public CompletableTakeUntilCompletable(Completable source,
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        TakeUntilMainObserver parent = new TakeUntilMainObserver(s);
-        s.onSubscribe(parent);
+    protected void subscribeActual(CompletableObserver observer) {
+        TakeUntilMainObserver parent = new TakeUntilMainObserver(observer);
+        observer.onSubscribe(parent);
 
         other.subscribe(parent.other);
         source.subscribe(parent);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTimer.java
Patch:
@@ -36,9 +36,9 @@ public CompletableTimer(long delay, TimeUnit unit, Scheduler scheduler) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableObserver s) {
-        TimerDisposable parent = new TimerDisposable(s);
-        s.onSubscribe(parent);
+    protected void subscribeActual(final CompletableObserver observer) {
+        TimerDisposable parent = new TimerDisposable(observer);
+        observer.onSubscribe(parent);
         parent.setFuture(scheduler.scheduleDirect(parent, delay, unit));
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableToSingle.java
Patch:
@@ -34,8 +34,8 @@ public CompletableToSingle(CompletableSource source,
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
-        source.subscribe(new ToSingle(s));
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
+        source.subscribe(new ToSingle(observer));
     }
 
     final class ToSingle implements CompletableObserver {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAllSingle.java
Patch:
@@ -34,8 +34,8 @@ public FlowableAllSingle(Flowable<T> source, Predicate<? super T> predicate) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super Boolean> s) {
-        source.subscribe(new AllSubscriber<T>(s, predicate));
+    protected void subscribeActual(SingleObserver<? super Boolean> observer) {
+        source.subscribe(new AllSubscriber<T>(observer, predicate));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAnySingle.java
Patch:
@@ -33,8 +33,8 @@ public FlowableAnySingle(Flowable<T> source, Predicate<? super T> predicate) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super Boolean> s) {
-        source.subscribe(new AnySubscriber<T>(s, predicate));
+    protected void subscribeActual(SingleObserver<? super Boolean> observer) {
+        source.subscribe(new AnySubscriber<T>(observer, predicate));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollectSingle.java
Patch:
@@ -40,16 +40,16 @@ public FlowableCollectSingle(Flowable<T> source, Callable<? extends U> initialSu
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super U> s) {
+    protected void subscribeActual(SingleObserver<? super U> observer) {
         U u;
         try {
             u = ObjectHelper.requireNonNull(initialSupplier.call(), "The initialSupplier returned a null value");
         } catch (Throwable e) {
-            EmptyDisposable.error(e, s);
+            EmptyDisposable.error(e, observer);
             return;
         }
 
-        source.subscribe(new CollectSubscriber<T, U>(s, u, collector));
+        source.subscribe(new CollectSubscriber<T, U>(observer, u, collector));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCountSingle.java
Patch:
@@ -30,8 +30,8 @@ public FlowableCountSingle(Flowable<T> source) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super Long> s) {
-        source.subscribe(new CountSubscriber(s));
+    protected void subscribeActual(SingleObserver<? super Long> observer) {
+        source.subscribe(new CountSubscriber(observer));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -41,18 +41,18 @@ public FlowableDistinct(Flowable<T> source, Function<? super T, K> keySelector,
     }
 
     @Override
-    protected void subscribeActual(Subscriber<? super T> observer) {
+    protected void subscribeActual(Subscriber<? super T> subscriber) {
         Collection<? super K> collection;
 
         try {
             collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            EmptySubscription.error(ex, observer);
+            EmptySubscription.error(ex, subscriber);
             return;
         }
 
-        source.subscribe(new DistinctSubscriber<T, K>(observer, keySelector, collection));
+        source.subscribe(new DistinctSubscriber<T, K>(subscriber, keySelector, collection));
     }
 
     static final class DistinctSubscriber<T, K> extends BasicFuseableSubscriber<T, T> {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java
Patch:
@@ -32,8 +32,8 @@ public FlowableElementAtMaybe(Flowable<T> source, long index) {
     }
 
     @Override
-    protected void subscribeActual(MaybeObserver<? super T> s) {
-        source.subscribe(new ElementAtSubscriber<T>(s, index));
+    protected void subscribeActual(MaybeObserver<? super T> observer) {
+        source.subscribe(new ElementAtSubscriber<T>(observer, index));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java
Patch:
@@ -37,8 +37,8 @@ public FlowableElementAtSingle(Flowable<T> source, long index, T defaultValue) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        source.subscribe(new ElementAtSubscriber<T>(s, index, defaultValue));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        source.subscribe(new ElementAtSubscriber<T>(observer, index, defaultValue));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMergeWithCompletable.java
Patch:
@@ -40,9 +40,9 @@ public FlowableMergeWithCompletable(Flowable<T> source, CompletableSource other)
     }
 
     @Override
-    protected void subscribeActual(Subscriber<? super T> observer) {
-        MergeWithSubscriber<T> parent = new MergeWithSubscriber<T>(observer);
-        observer.onSubscribe(parent);
+    protected void subscribeActual(Subscriber<? super T> subscriber) {
+        MergeWithSubscriber<T> parent = new MergeWithSubscriber<T>(subscriber);
+        subscriber.onSubscribe(parent);
         source.subscribe(parent);
         other.subscribe(parent.otherObserver);
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMergeWithMaybe.java
Patch:
@@ -43,9 +43,9 @@ public FlowableMergeWithMaybe(Flowable<T> source, MaybeSource<? extends T> other
     }
 
     @Override
-    protected void subscribeActual(Subscriber<? super T> observer) {
-        MergeWithObserver<T> parent = new MergeWithObserver<T>(observer);
-        observer.onSubscribe(parent);
+    protected void subscribeActual(Subscriber<? super T> subscriber) {
+        MergeWithObserver<T> parent = new MergeWithObserver<T>(subscriber);
+        subscriber.onSubscribe(parent);
         source.subscribe(parent);
         other.subscribe(parent.otherObserver);
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMergeWithSingle.java
Patch:
@@ -43,9 +43,9 @@ public FlowableMergeWithSingle(Flowable<T> source, SingleSource<? extends T> oth
     }
 
     @Override
-    protected void subscribeActual(Subscriber<? super T> observer) {
-        MergeWithObserver<T> parent = new MergeWithObserver<T>(observer);
-        observer.onSubscribe(parent);
+    protected void subscribeActual(Subscriber<? super T> subscriber) {
+        MergeWithObserver<T> parent = new MergeWithObserver<T>(subscriber);
+        subscriber.onSubscribe(parent);
         source.subscribe(parent);
         other.subscribe(parent.otherObserver);
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualSingle.java
Patch:
@@ -42,9 +42,9 @@ public FlowableSequenceEqualSingle(Publisher<? extends T> first, Publisher<? ext
     }
 
     @Override
-    public void subscribeActual(SingleObserver<? super Boolean> s) {
-        EqualCoordinator<T> parent = new EqualCoordinator<T>(s, prefetch, comparer);
-        s.onSubscribe(parent);
+    public void subscribeActual(SingleObserver<? super Boolean> observer) {
+        EqualCoordinator<T> parent = new EqualCoordinator<T>(observer, prefetch, comparer);
+        observer.onSubscribe(parent);
         parent.subscribe(first, second);
     }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java
Patch:
@@ -30,8 +30,8 @@ public FlowableSingleMaybe(Flowable<T> source) {
     }
 
     @Override
-    protected void subscribeActual(MaybeObserver<? super T> s) {
-        source.subscribe(new SingleElementSubscriber<T>(s));
+    protected void subscribeActual(MaybeObserver<? super T> observer) {
+        source.subscribe(new SingleElementSubscriber<T>(observer));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java
Patch:
@@ -35,8 +35,8 @@ public FlowableSingleSingle(Flowable<T> source, T defaultValue) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        source.subscribe(new SingleElementSubscriber<T>(s, defaultValue));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        source.subscribe(new SingleElementSubscriber<T>(observer, defaultValue));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableToListSingle.java
Patch:
@@ -45,16 +45,16 @@ public FlowableToListSingle(Flowable<T> source, Callable<U> collectionSupplier)
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super U> s) {
+    protected void subscribeActual(SingleObserver<? super U> observer) {
         U coll;
         try {
             coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            EmptyDisposable.error(e, s);
+            EmptyDisposable.error(e, observer);
             return;
         }
-        source.subscribe(new ToListSubscriber<T, U>(s, coll));
+        source.subscribe(new ToListSubscriber<T, U>(observer, coll));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeCreate.java
Patch:
@@ -37,9 +37,9 @@ public MaybeCreate(MaybeOnSubscribe<T> source) {
     }
 
     @Override
-    protected void subscribeActual(MaybeObserver<? super T> s) {
-        Emitter<T> parent = new Emitter<T>(s);
-        s.onSubscribe(parent);
+    protected void subscribeActual(MaybeObserver<? super T> observer) {
+        Emitter<T> parent = new Emitter<T>(observer);
+        observer.onSubscribe(parent);
 
         try {
             source.subscribe(parent);

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayWithCompletable.java
Patch:
@@ -34,8 +34,8 @@ public MaybeDelayWithCompletable(MaybeSource<T> source, CompletableSource other)
     }
 
     @Override
-    protected void subscribeActual(MaybeObserver<? super T> subscriber) {
-        other.subscribe(new OtherObserver<T>(subscriber, source));
+    protected void subscribeActual(MaybeObserver<? super T> observer) {
+        other.subscribe(new OtherObserver<T>(observer, source));
     }
 
     static final class OtherObserver<T>

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeDoAfterSuccess.java
Patch:
@@ -36,8 +36,8 @@ public MaybeDoAfterSuccess(MaybeSource<T> source, Consumer<? super T> onAfterSuc
     }
 
     @Override
-    protected void subscribeActual(MaybeObserver<? super T> s) {
-        source.subscribe(new DoAfterObserver<T>(s, onAfterSuccess));
+    protected void subscribeActual(MaybeObserver<? super T> observer) {
+        source.subscribe(new DoAfterObserver<T>(observer, onAfterSuccess));
     }
 
     static final class DoAfterObserver<T> implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeDoFinally.java
Patch:
@@ -38,8 +38,8 @@ public MaybeDoFinally(MaybeSource<T> source, Action onFinally) {
     }
 
     @Override
-    protected void subscribeActual(MaybeObserver<? super T> s) {
-        source.subscribe(new DoFinallyObserver<T>(s, onFinally));
+    protected void subscribeActual(MaybeObserver<? super T> observer) {
+        source.subscribe(new DoFinallyObserver<T>(observer, onFinally));
     }
 
     static final class DoFinallyObserver<T> extends AtomicInteger implements MaybeObserver<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapCompletable.java
Patch:
@@ -38,9 +38,9 @@ public MaybeFlatMapCompletable(MaybeSource<T> source, Function<? super T, ? exte
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        FlatMapCompletableObserver<T> parent = new FlatMapCompletableObserver<T>(s, mapper);
-        s.onSubscribe(parent);
+    protected void subscribeActual(CompletableObserver observer) {
+        FlatMapCompletableObserver<T> parent = new FlatMapCompletableObserver<T>(observer, mapper);
+        observer.onSubscribe(parent);
         source.subscribe(parent);
     }
 

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapIterableObservable.java
Patch:
@@ -43,8 +43,8 @@ public MaybeFlatMapIterableObservable(MaybeSource<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        source.subscribe(new FlatMapIterableObserver<T, R>(s, mapper));
+    protected void subscribeActual(Observer<? super R> observer) {
+        source.subscribe(new FlatMapIterableObserver<T, R>(observer, mapper));
     }
 
     static final class FlatMapIterableObserver<T, R>

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeToObservable.java
Patch:
@@ -39,8 +39,8 @@ public MaybeSource<T> source() {
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        source.subscribe(create(s));
+    protected void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(create(observer));
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/mixed/CompletableAndThenObservable.java
Patch:
@@ -39,9 +39,9 @@ public CompletableAndThenObservable(CompletableSource source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        AndThenObservableObserver<R> parent = new AndThenObservableObserver<R>(s, other);
-        s.onSubscribe(parent);
+    protected void subscribeActual(Observer<? super R> observer) {
+        AndThenObservableObserver<R> parent = new AndThenObservableObserver<R>(observer, other);
+        observer.onSubscribe(parent);
         source.subscribe(parent);
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapCompletable.java
Patch:
@@ -57,8 +57,8 @@ public FlowableConcatMapCompletable(Flowable<T> source,
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        source.subscribe(new ConcatMapCompletableObserver<T>(s, mapper, errorMode, prefetch));
+    protected void subscribeActual(CompletableObserver observer) {
+        source.subscribe(new ConcatMapCompletableObserver<T>(observer, mapper, errorMode, prefetch));
     }
 
     static final class ConcatMapCompletableObserver<T>

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapCompletable.java
Patch:
@@ -51,8 +51,8 @@ public FlowableSwitchMapCompletable(Flowable<T> source,
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        source.subscribe(new SwitchMapCompletableObserver<T>(s, mapper, delayErrors));
+    protected void subscribeActual(CompletableObserver observer) {
+        source.subscribe(new SwitchMapCompletableObserver<T>(observer, mapper, delayErrors));
     }
 
     static final class SwitchMapCompletableObserver<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/mixed/MaybeFlatMapObservable.java
Patch:
@@ -43,9 +43,9 @@ public MaybeFlatMapObservable(MaybeSource<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        FlatMapObserver<T, R> parent = new FlatMapObserver<T, R>(s, mapper);
-        s.onSubscribe(parent);
+    protected void subscribeActual(Observer<? super R> observer) {
+        FlatMapObserver<T, R> parent = new FlatMapObserver<T, R>(observer, mapper);
+        observer.onSubscribe(parent);
         source.subscribe(parent);
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapCompletable.java
Patch:
@@ -54,9 +54,9 @@ public ObservableConcatMapCompletable(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        if (!ScalarXMapZHelper.tryAsCompletable(source, mapper, s)) {
-            source.subscribe(new ConcatMapCompletableObserver<T>(s, mapper, errorMode, prefetch));
+    protected void subscribeActual(CompletableObserver observer) {
+        if (!ScalarXMapZHelper.tryAsCompletable(source, mapper, observer)) {
+            source.subscribe(new ConcatMapCompletableObserver<T>(observer, mapper, errorMode, prefetch));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java
Patch:
@@ -55,9 +55,9 @@ public ObservableConcatMapMaybe(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        if (!ScalarXMapZHelper.tryAsMaybe(source, mapper, s)) {
-            source.subscribe(new ConcatMapMaybeMainObserver<T, R>(s, mapper, prefetch, errorMode));
+    protected void subscribeActual(Observer<? super R> observer) {
+        if (!ScalarXMapZHelper.tryAsMaybe(source, mapper, observer)) {
+            source.subscribe(new ConcatMapMaybeMainObserver<T, R>(observer, mapper, prefetch, errorMode));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java
Patch:
@@ -55,9 +55,9 @@ public ObservableConcatMapSingle(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        if (!ScalarXMapZHelper.tryAsSingle(source, mapper, s)) {
-            source.subscribe(new ConcatMapSingleMainObserver<T, R>(s, mapper, prefetch, errorMode));
+    protected void subscribeActual(Observer<? super R> observer) {
+        if (!ScalarXMapZHelper.tryAsSingle(source, mapper, observer)) {
+            source.subscribe(new ConcatMapSingleMainObserver<T, R>(observer, mapper, prefetch, errorMode));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapCompletable.java
Patch:
@@ -48,9 +48,9 @@ public ObservableSwitchMapCompletable(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        if (!ScalarXMapZHelper.tryAsCompletable(source, mapper, s)) {
-            source.subscribe(new SwitchMapCompletableObserver<T>(s, mapper, delayErrors));
+    protected void subscribeActual(CompletableObserver observer) {
+        if (!ScalarXMapZHelper.tryAsCompletable(source, mapper, observer)) {
+            source.subscribe(new SwitchMapCompletableObserver<T>(observer, mapper, delayErrors));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapMaybe.java
Patch:
@@ -50,9 +50,9 @@ public ObservableSwitchMapMaybe(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        if (!ScalarXMapZHelper.tryAsMaybe(source, mapper, s)) {
-            source.subscribe(new SwitchMapMaybeMainObserver<T, R>(s, mapper, delayErrors));
+    protected void subscribeActual(Observer<? super R> observer) {
+        if (!ScalarXMapZHelper.tryAsMaybe(source, mapper, observer)) {
+            source.subscribe(new SwitchMapMaybeMainObserver<T, R>(observer, mapper, delayErrors));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableSwitchMapSingle.java
Patch:
@@ -50,9 +50,9 @@ public ObservableSwitchMapSingle(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        if (!ScalarXMapZHelper.tryAsSingle(source, mapper, s)) {
-            source.subscribe(new SwitchMapSingleMainObserver<T, R>(s, mapper, delayErrors));
+    protected void subscribeActual(Observer<? super R> observer) {
+        if (!ScalarXMapZHelper.tryAsSingle(source, mapper, observer)) {
+            source.subscribe(new SwitchMapSingleMainObserver<T, R>(observer, mapper, delayErrors));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/mixed/SingleFlatMapObservable.java
Patch:
@@ -43,9 +43,9 @@ public SingleFlatMapObservable(SingleSource<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        FlatMapObserver<T, R> parent = new FlatMapObserver<T, R>(s, mapper);
-        s.onSubscribe(parent);
+    protected void subscribeActual(Observer<? super R> observer) {
+        FlatMapObserver<T, R> parent = new FlatMapObserver<T, R>(observer, mapper);
+        observer.onSubscribe(parent);
         source.subscribe(parent);
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDefer.java
Patch:
@@ -26,16 +26,16 @@ public ObservableDefer(Callable<? extends ObservableSource<? extends T>> supplie
         this.supplier = supplier;
     }
     @Override
-    public void subscribeActual(Observer<? super T> s) {
+    public void subscribeActual(Observer<? super T> observer) {
         ObservableSource<? extends T> pub;
         try {
             pub = ObjectHelper.requireNonNull(supplier.call(), "null ObservableSource supplied");
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
-            EmptyDisposable.error(t, s);
+            EmptyDisposable.error(t, observer);
             return;
         }
 
-        pub.subscribe(s);
+        pub.subscribe(observer);
     }
 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDetach.java
Patch:
@@ -31,8 +31,8 @@ public ObservableDetach(ObservableSource<T> source) {
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new DetachObserver<T>(s));
+    protected void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new DetachObserver<T>(observer));
     }
 
     static final class DetachObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinctUntilChanged.java
Patch:
@@ -31,8 +31,8 @@ public ObservableDistinctUntilChanged(ObservableSource<T> source, Function<? sup
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new DistinctUntilChangedObserver<T, K>(s, keySelector, comparer));
+    protected void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new DistinctUntilChangedObserver<T, K>(observer, keySelector, comparer));
     }
 
     static final class DistinctUntilChangedObserver<T, K> extends BasicFuseableObserver<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoAfterNext.java
Patch:
@@ -34,8 +34,8 @@ public ObservableDoAfterNext(ObservableSource<T> source, Consumer<? super T> onA
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new DoAfterObserver<T>(s, onAfterNext));
+    protected void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new DoAfterObserver<T>(observer, onAfterNext));
     }
 
     static final class DoAfterObserver<T> extends BasicFuseableObserver<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoFinally.java
Patch:
@@ -39,8 +39,8 @@ public ObservableDoFinally(ObservableSource<T> source, Action onFinally) {
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new DoFinallyObserver<T>(s, onFinally));
+    protected void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new DoFinallyObserver<T>(observer, onFinally));
     }
 
     static final class DoFinallyObserver<T> extends BasicIntQueueDisposable<T> implements Observer<T> {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableError.java
Patch:
@@ -26,14 +26,14 @@ public ObservableError(Callable<? extends Throwable> errorSupplier) {
         this.errorSupplier = errorSupplier;
     }
     @Override
-    public void subscribeActual(Observer<? super T> s) {
+    public void subscribeActual(Observer<? super T> observer) {
         Throwable error;
         try {
             error = ObjectHelper.requireNonNull(errorSupplier.call(), "Callable returned null throwable. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;
         }
-        EmptyDisposable.error(error, s);
+        EmptyDisposable.error(error, observer);
     }
 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java
Patch:
@@ -26,8 +26,8 @@ public ObservableFilter(ObservableSource<T> source, Predicate<? super T> predica
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new FilterObserver<T>(s, predicate));
+    public void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new FilterObserver<T>(observer, predicate));
     }
 
     static final class FilterObserver<T> extends BasicFuseableObserver<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java
Patch:
@@ -44,8 +44,8 @@ public ObservableFlatMapMaybe(ObservableSource<T> source, Function<? super T, ?
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        source.subscribe(new FlatMapMaybeObserver<T, R>(s, mapper, delayErrors));
+    protected void subscribeActual(Observer<? super R> observer) {
+        source.subscribe(new FlatMapMaybeObserver<T, R>(observer, mapper, delayErrors));
     }
 
     static final class FlatMapMaybeObserver<T, R>

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java
Patch:
@@ -44,8 +44,8 @@ public ObservableFlatMapSingle(ObservableSource<T> source, Function<? super T, ?
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        source.subscribe(new FlatMapSingleObserver<T, R>(s, mapper, delayErrors));
+    protected void subscribeActual(Observer<? super R> observer) {
+        source.subscribe(new FlatMapSingleObserver<T, R>(observer, mapper, delayErrors));
     }
 
     static final class FlatMapSingleObserver<T, R>

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromArray.java
Patch:
@@ -24,10 +24,10 @@ public ObservableFromArray(T[] array) {
         this.array = array;
     }
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        FromArrayDisposable<T> d = new FromArrayDisposable<T>(s, array);
+    public void subscribeActual(Observer<? super T> observer) {
+        FromArrayDisposable<T> d = new FromArrayDisposable<T>(observer, array);
 
-        s.onSubscribe(d);
+        observer.onSubscribe(d);
 
         if (d.fusionMode) {
             return;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupJoin.java
Patch:
@@ -56,12 +56,12 @@ public ObservableGroupJoin(
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
+    protected void subscribeActual(Observer<? super R> observer) {
 
         GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R> parent =
-                new GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>(s, leftEnd, rightEnd, resultSelector);
+                new GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>(observer, leftEnd, rightEnd, resultSelector);
 
-        s.onSubscribe(parent);
+        observer.onSubscribe(parent);
 
         LeftRightObserver left = new LeftRightObserver(parent, true);
         parent.disposables.add(left);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java
Patch:
@@ -36,9 +36,9 @@ public ObservableInterval(long initialDelay, long period, TimeUnit unit, Schedul
     }
 
     @Override
-    public void subscribeActual(Observer<? super Long> s) {
-        IntervalObserver is = new IntervalObserver(s);
-        s.onSubscribe(is);
+    public void subscribeActual(Observer<? super Long> observer) {
+        IntervalObserver is = new IntervalObserver(observer);
+        observer.onSubscribe(is);
 
         Scheduler sch = scheduler;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableIntervalRange.java
Patch:
@@ -40,9 +40,9 @@ public ObservableIntervalRange(long start, long end, long initialDelay, long per
     }
 
     @Override
-    public void subscribeActual(Observer<? super Long> s) {
-        IntervalRangeObserver is = new IntervalRangeObserver(s, start, end);
-        s.onSubscribe(is);
+    public void subscribeActual(Observer<? super Long> observer) {
+        IntervalRangeObserver is = new IntervalRangeObserver(observer, start, end);
+        observer.onSubscribe(is);
 
         Scheduler sch = scheduler;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableJoin.java
Patch:
@@ -54,13 +54,13 @@ public ObservableJoin(
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
+    protected void subscribeActual(Observer<? super R> observer) {
 
         JoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R> parent =
                 new JoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>(
-                        s, leftEnd, rightEnd, resultSelector);
+                        observer, leftEnd, rightEnd, resultSelector);
 
-        s.onSubscribe(parent);
+        observer.onSubscribe(parent);
 
         LeftRightObserver left = new LeftRightObserver(parent, true);
         parent.disposables.add(left);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableJust.java
Patch:
@@ -29,9 +29,9 @@ public ObservableJust(final T value) {
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        ScalarDisposable<T> sd = new ScalarDisposable<T>(s, value);
-        s.onSubscribe(sd);
+    protected void subscribeActual(Observer<? super T> observer) {
+        ScalarDisposable<T> sd = new ScalarDisposable<T>(observer, value);
+        observer.onSubscribe(sd);
         sd.run();
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
Patch:
@@ -59,7 +59,7 @@ public ObservableRefCount(ConnectableObservable<T> source, int n, long timeout,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
+    protected void subscribeActual(Observer<? super T> observer) {
 
         RefConnection conn;
 
@@ -82,7 +82,7 @@ protected void subscribeActual(Observer<? super T> s) {
             }
         }
 
-        source.subscribe(new RefCountObserver<T>(s, this, conn));
+        source.subscribe(new RefCountObserver<T>(observer, this, conn));
 
         if (connect) {
             source.connect(conn);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeat.java
Patch:
@@ -27,11 +27,11 @@ public ObservableRepeat(Observable<T> source, long count) {
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
+    public void subscribeActual(Observer<? super T> observer) {
         SequentialDisposable sd = new SequentialDisposable();
-        s.onSubscribe(sd);
+        observer.onSubscribe(sd);
 
-        RepeatObserver<T> rs = new RepeatObserver<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sd, source);
+        RepeatObserver<T> rs = new RepeatObserver<T>(observer, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sd, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatUntil.java
Patch:
@@ -29,11 +29,11 @@ public ObservableRepeatUntil(Observable<T> source, BooleanSupplier until) {
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
+    public void subscribeActual(Observer<? super T> observer) {
         SequentialDisposable sd = new SequentialDisposable();
-        s.onSubscribe(sd);
+        observer.onSubscribe(sd);
 
-        RepeatUntilObserver<T> rs = new RepeatUntilObserver<T>(s, until, sd, source);
+        RepeatUntilObserver<T> rs = new RepeatUntilObserver<T>(observer, until, sd, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryBiPredicate.java
Patch:
@@ -31,11 +31,11 @@ public ObservableRetryBiPredicate(
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
+    public void subscribeActual(Observer<? super T> observer) {
         SequentialDisposable sa = new SequentialDisposable();
-        s.onSubscribe(sa);
+        observer.onSubscribe(sa);
 
-        RetryBiObserver<T> rs = new RetryBiObserver<T>(s, predicate, sa, source);
+        RetryBiObserver<T> rs = new RetryBiObserver<T>(observer, predicate, sa, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryPredicate.java
Patch:
@@ -33,11 +33,11 @@ public ObservableRetryPredicate(Observable<T> source,
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
+    public void subscribeActual(Observer<? super T> observer) {
         SequentialDisposable sa = new SequentialDisposable();
-        s.onSubscribe(sa);
+        observer.onSubscribe(sa);
 
-        RepeatObserver<T> rs = new RepeatObserver<T>(s, count, predicate, sa, source);
+        RepeatObserver<T> rs = new RepeatObserver<T>(observer, count, predicate, sa, source);
         rs.subscribeNext();
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkip.java
Patch:
@@ -25,8 +25,8 @@ public ObservableSkip(ObservableSource<T> source, long n) {
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new SkipObserver<T>(s, n));
+    public void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new SkipObserver<T>(observer, n));
     }
 
     static final class SkipObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLast.java
Patch:
@@ -28,8 +28,8 @@ public ObservableSkipLast(ObservableSource<T> source, int skip) {
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new SkipLastObserver<T>(s, skip));
+    public void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new SkipLastObserver<T>(observer, skip));
     }
 
     static final class SkipLastObserver<T> extends ArrayDeque<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipWhile.java
Patch:
@@ -27,8 +27,8 @@ public ObservableSkipWhile(ObservableSource<T> source, Predicate<? super T> pred
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new SkipWhileObserver<T>(s, predicate));
+    public void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new SkipWhileObserver<T>(observer, predicate));
     }
 
     static final class SkipWhileObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java
Patch:
@@ -28,10 +28,10 @@ public ObservableSubscribeOn(ObservableSource<T> source, Scheduler scheduler) {
     }
 
     @Override
-    public void subscribeActual(final Observer<? super T> s) {
-        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);
+    public void subscribeActual(final Observer<? super T> observer) {
+        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(observer);
 
-        s.onSubscribe(parent);
+        observer.onSubscribe(parent);
 
         parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLastOne.java
Patch:
@@ -23,8 +23,8 @@ public ObservableTakeLastOne(ObservableSource<T> source) {
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new TakeLastOneObserver<T>(s));
+    public void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new TakeLastOneObserver<T>(observer));
     }
 
     static final class TakeLastOneObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntilPredicate.java
Patch:
@@ -28,8 +28,8 @@ public ObservableTakeUntilPredicate(ObservableSource<T> source, Predicate<? supe
     }
 
     @Override
-    public void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new TakeUntilPredicateObserver<T>(s, predicate));
+    public void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new TakeUntilPredicateObserver<T>(observer, predicate));
     }
 
     static final class TakeUntilPredicateObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleLatest.java
Patch:
@@ -52,8 +52,8 @@ public ObservableThrottleLatest(Observable<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super T> s) {
-        source.subscribe(new ThrottleLatestObserver<T>(s, timeout, unit, scheduler.createWorker(), emitLast));
+    protected void subscribeActual(Observer<? super T> observer) {
+        source.subscribe(new ThrottleLatestObserver<T>(observer, timeout, unit, scheduler.createWorker(), emitLast));
     }
 
     static final class ThrottleLatestObserver<T>

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimer.java
Patch:
@@ -31,9 +31,9 @@ public ObservableTimer(long delay, TimeUnit unit, Scheduler scheduler) {
     }
 
     @Override
-    public void subscribeActual(Observer<? super Long> s) {
-        TimerObserver ios = new TimerObserver(s);
-        s.onSubscribe(ios);
+    public void subscribeActual(Observer<? super Long> observer) {
+        TimerObserver ios = new TimerObserver(observer);
+        observer.onSubscribe(ios);
 
         Disposable d = scheduler.scheduleDirect(ios, delay, unit);
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
Patch:
@@ -46,7 +46,7 @@ public ObservableZip(ObservableSource<? extends T>[] sources,
 
     @Override
     @SuppressWarnings("unchecked")
-    public void subscribeActual(Observer<? super R> s) {
+    public void subscribeActual(Observer<? super R> observer) {
         ObservableSource<? extends T>[] sources = this.sources;
         int count = 0;
         if (sources == null) {
@@ -64,11 +64,11 @@ public void subscribeActual(Observer<? super R> s) {
         }
 
         if (count == 0) {
-            EmptyDisposable.complete(s);
+            EmptyDisposable.complete(observer);
             return;
         }
 
-        ZipCoordinator<T, R> zc = new ZipCoordinator<T, R>(s, zipper, count, delayError);
+        ZipCoordinator<T, R> zc = new ZipCoordinator<T, R>(observer, zipper, count, delayError);
         zc.subscribe(sources, bufferSize);
     }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleCreate.java
Patch:
@@ -31,9 +31,9 @@ public SingleCreate(SingleOnSubscribe<T> source) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        Emitter<T> parent = new Emitter<T>(s);
-        s.onSubscribe(parent);
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        Emitter<T> parent = new Emitter<T>(observer);
+        observer.onSubscribe(parent);
 
         try {
             source.subscribe(parent);

File: src/main/java/io/reactivex/internal/operators/single/SingleDefer.java
Patch:
@@ -29,18 +29,18 @@ public SingleDefer(Callable<? extends SingleSource<? extends T>> singleSupplier)
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
+    protected void subscribeActual(SingleObserver<? super T> observer) {
         SingleSource<? extends T> next;
 
         try {
             next = ObjectHelper.requireNonNull(singleSupplier.call(), "The singleSupplier returned a null SingleSource");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            EmptyDisposable.error(e, s);
+            EmptyDisposable.error(e, observer);
             return;
         }
 
-        next.subscribe(s);
+        next.subscribe(observer);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithCompletable.java
Patch:
@@ -32,8 +32,8 @@ public SingleDelayWithCompletable(SingleSource<T> source, CompletableSource othe
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> subscriber) {
-        other.subscribe(new OtherObserver<T>(subscriber, source));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        other.subscribe(new OtherObserver<T>(observer, source));
     }
 
     static final class OtherObserver<T>

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithObservable.java
Patch:
@@ -33,8 +33,8 @@ public SingleDelayWithObservable(SingleSource<T> source, ObservableSource<U> oth
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> subscriber) {
-        other.subscribe(new OtherSubscriber<T, U>(subscriber, source));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        other.subscribe(new OtherSubscriber<T, U>(observer, source));
     }
 
     static final class OtherSubscriber<T, U>

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java
Patch:
@@ -36,8 +36,8 @@ public SingleDelayWithPublisher(SingleSource<T> source, Publisher<U> other) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> subscriber) {
-        other.subscribe(new OtherSubscriber<T, U>(subscriber, source));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        other.subscribe(new OtherSubscriber<T, U>(observer, source));
     }
 
     static final class OtherSubscriber<T, U>

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithSingle.java
Patch:
@@ -32,8 +32,8 @@ public SingleDelayWithSingle(SingleSource<T> source, SingleSource<U> other) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> subscriber) {
-        other.subscribe(new OtherObserver<T, U>(subscriber, source));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        other.subscribe(new OtherObserver<T, U>(observer, source));
     }
 
     static final class OtherObserver<T, U>

File: src/main/java/io/reactivex/internal/operators/single/SingleDoAfterSuccess.java
Patch:
@@ -38,8 +38,8 @@ public SingleDoAfterSuccess(SingleSource<T> source, Consumer<? super T> onAfterS
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        source.subscribe(new DoAfterObserver<T>(s, onAfterSuccess));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        source.subscribe(new DoAfterObserver<T>(observer, onAfterSuccess));
     }
 
     static final class DoAfterObserver<T> implements SingleObserver<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/single/SingleDoAfterTerminate.java
Patch:
@@ -40,8 +40,8 @@ public SingleDoAfterTerminate(SingleSource<T> source, Action onAfterTerminate) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        source.subscribe(new DoAfterTerminateObserver<T>(s, onAfterTerminate));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        source.subscribe(new DoAfterTerminateObserver<T>(observer, onAfterTerminate));
     }
 
     static final class DoAfterTerminateObserver<T> implements SingleObserver<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/single/SingleDoFinally.java
Patch:
@@ -40,8 +40,8 @@ public SingleDoFinally(SingleSource<T> source, Action onFinally) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        source.subscribe(new DoFinallyObserver<T>(s, onFinally));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        source.subscribe(new DoFinallyObserver<T>(observer, onFinally));
     }
 
     static final class DoFinallyObserver<T> extends AtomicInteger implements SingleObserver<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/single/SingleDoOnDispose.java
Patch:
@@ -33,9 +33,9 @@ public SingleDoOnDispose(SingleSource<T> source, Action onDispose) {
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
 
-        source.subscribe(new DoOnDisposeObserver<T>(s, onDispose));
+        source.subscribe(new DoOnDisposeObserver<T>(observer, onDispose));
     }
 
     static final class DoOnDisposeObserver<T>

File: src/main/java/io/reactivex/internal/operators/single/SingleDoOnSubscribe.java
Patch:
@@ -37,8 +37,8 @@ public SingleDoOnSubscribe(SingleSource<T> source, Consumer<? super Disposable>
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
-        source.subscribe(new DoOnSubscribeSingleObserver<T>(s, onSubscribe));
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
+        source.subscribe(new DoOnSubscribeSingleObserver<T>(observer, onSubscribe));
     }
 
     static final class DoOnSubscribeSingleObserver<T> implements SingleObserver<T> {

File: src/main/java/io/reactivex/internal/operators/single/SingleError.java
Patch:
@@ -29,7 +29,7 @@ public SingleError(Callable<? extends Throwable> errorSupplier) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
+    protected void subscribeActual(SingleObserver<? super T> observer) {
         Throwable error;
 
         try {
@@ -39,7 +39,7 @@ protected void subscribeActual(SingleObserver<? super T> s) {
             error = e;
         }
 
-        EmptyDisposable.error(error, s);
+        EmptyDisposable.error(error, observer);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapCompletable.java
Patch:
@@ -38,9 +38,9 @@ public SingleFlatMapCompletable(SingleSource<T> source, Function<? super T, ? ex
     }
 
     @Override
-    protected void subscribeActual(CompletableObserver s) {
-        FlatMapCompletableObserver<T> parent = new FlatMapCompletableObserver<T>(s, mapper);
-        s.onSubscribe(parent);
+    protected void subscribeActual(CompletableObserver observer) {
+        FlatMapCompletableObserver<T> parent = new FlatMapCompletableObserver<T>(observer, mapper);
+        observer.onSubscribe(parent);
         source.subscribe(parent);
     }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapIterableObservable.java
Patch:
@@ -43,8 +43,8 @@ public SingleFlatMapIterableObservable(SingleSource<T> source,
     }
 
     @Override
-    protected void subscribeActual(Observer<? super R> s) {
-        source.subscribe(new FlatMapIterableObserver<T, R>(s, mapper));
+    protected void subscribeActual(Observer<? super R> observer) {
+        source.subscribe(new FlatMapIterableObserver<T, R>(observer, mapper));
     }
 
     static final class FlatMapIterableObserver<T, R>

File: src/main/java/io/reactivex/internal/operators/single/SingleFromPublisher.java
Patch:
@@ -31,8 +31,8 @@ public SingleFromPublisher(Publisher<? extends T> publisher) {
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
-        publisher.subscribe(new ToSingleObserver<T>(s));
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
+        publisher.subscribe(new ToSingleObserver<T>(observer));
     }
 
     static final class ToSingleObserver<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/single/SingleHide.java
Patch:
@@ -26,8 +26,8 @@ public SingleHide(SingleSource<? extends T> source) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> subscriber) {
-        source.subscribe(new HideSingleObserver<T>(subscriber));
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        source.subscribe(new HideSingleObserver<T>(observer));
     }
 
     static final class HideSingleObserver<T> implements SingleObserver<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/single/SingleJust.java
Patch:
@@ -25,9 +25,9 @@ public SingleJust(T value) {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-        s.onSubscribe(Disposables.disposed());
-        s.onSuccess(value);
+    protected void subscribeActual(SingleObserver<? super T> observer) {
+        observer.onSubscribe(Disposables.disposed());
+        observer.onSuccess(value);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/single/SingleLift.java
Patch:
@@ -30,14 +30,14 @@ public SingleLift(SingleSource<T> source, SingleOperator<? extends R, ? super T>
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super R> s) {
+    protected void subscribeActual(SingleObserver<? super R> observer) {
         SingleObserver<? super T> sr;
 
         try {
-            sr = ObjectHelper.requireNonNull(onLift.apply(s), "The onLift returned a null SingleObserver");
+            sr = ObjectHelper.requireNonNull(onLift.apply(observer), "The onLift returned a null SingleObserver");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            EmptyDisposable.error(ex, s);
+            EmptyDisposable.error(ex, observer);
             return;
         }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleNever.java
Patch:
@@ -23,8 +23,8 @@ private SingleNever() {
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super Object> s) {
-        s.onSubscribe(EmptyDisposable.NEVER);
+    protected void subscribeActual(SingleObserver<? super Object> observer) {
+        observer.onSubscribe(EmptyDisposable.NEVER);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/single/SingleObserveOn.java
Patch:
@@ -31,8 +31,8 @@ public SingleObserveOn(SingleSource<T> source, Scheduler scheduler) {
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
-        source.subscribe(new ObserveOnSingleObserver<T>(s, scheduler));
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
+        source.subscribe(new ObserveOnSingleObserver<T>(observer, scheduler));
     }
 
     static final class ObserveOnSingleObserver<T> extends AtomicReference<Disposable>

File: src/main/java/io/reactivex/internal/operators/single/SingleOnErrorReturn.java
Patch:
@@ -35,9 +35,9 @@ public SingleOnErrorReturn(SingleSource<? extends T> source,
 
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
 
-        source.subscribe(new OnErrorReturn(s));
+        source.subscribe(new OnErrorReturn(observer));
     }
 
     final class OnErrorReturn implements SingleObserver<T> {

File: src/main/java/io/reactivex/internal/operators/single/SingleResumeNext.java
Patch:
@@ -35,8 +35,8 @@ public SingleResumeNext(SingleSource<? extends T> source,
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
-        source.subscribe(new ResumeMainSingleObserver<T>(s, nextFunction));
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
+        source.subscribe(new ResumeMainSingleObserver<T>(observer, nextFunction));
     }
 
     static final class ResumeMainSingleObserver<T> extends AtomicReference<Disposable>

File: src/main/java/io/reactivex/internal/operators/single/SingleSubscribeOn.java
Patch:
@@ -30,9 +30,9 @@ public SingleSubscribeOn(SingleSource<? extends T> source, Scheduler scheduler)
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
-        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s, source);
-        s.onSubscribe(parent);
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
+        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(observer, source);
+        observer.onSubscribe(parent);
 
         Disposable f = scheduler.scheduleDirect(parent);
 

File: src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java
Patch:
@@ -43,10 +43,10 @@ public SingleTimeout(SingleSource<T> source, long timeout, TimeUnit unit, Schedu
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super T> s) {
+    protected void subscribeActual(final SingleObserver<? super T> observer) {
 
-        TimeoutMainObserver<T> parent = new TimeoutMainObserver<T>(s, other);
-        s.onSubscribe(parent);
+        TimeoutMainObserver<T> parent = new TimeoutMainObserver<T>(observer, other);
+        observer.onSubscribe(parent);
 
         DisposableHelper.replace(parent.task, scheduler.scheduleDirect(parent, timeout, unit));
 

File: src/main/java/io/reactivex/internal/operators/single/SingleTimer.java
Patch:
@@ -36,9 +36,9 @@ public SingleTimer(long delay, TimeUnit unit, Scheduler scheduler) {
     }
 
     @Override
-    protected void subscribeActual(final SingleObserver<? super Long> s) {
-        TimerDisposable parent = new TimerDisposable(s);
-        s.onSubscribe(parent);
+    protected void subscribeActual(final SingleObserver<? super Long> observer) {
+        TimerDisposable parent = new TimerDisposable(observer);
+        observer.onSubscribe(parent);
         parent.setFuture(scheduler.scheduleDirect(parent, delay, unit));
     }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleToObservable.java
Patch:
@@ -31,8 +31,8 @@ public SingleToObservable(SingleSource<? extends T> source) {
     }
 
     @Override
-    public void subscribeActual(final Observer<? super T> s) {
-        source.subscribe(create(s));
+    public void subscribeActual(final Observer<? super T> observer) {
+        source.subscribe(create(observer));
     }
 
     /**

File: src/test/java/io/reactivex/flowable/FlowableCollectTest.java
Patch:
@@ -31,7 +31,7 @@ public final class FlowableCollectTest {
 
     @Test
     public void testCollectToListFlowable() {
-        Flowable<List<Integer>> o = Flowable.just(1, 2, 3)
+        Flowable<List<Integer>> f = Flowable.just(1, 2, 3)
         .collect(new Callable<List<Integer>>() {
             @Override
             public List<Integer> call() {
@@ -44,15 +44,15 @@ public void accept(List<Integer> list, Integer v) {
             }
         }).toFlowable();
 
-        List<Integer> list =  o.blockingLast();
+        List<Integer> list =  f.blockingLast();
 
         assertEquals(3, list.size());
         assertEquals(1, list.get(0).intValue());
         assertEquals(2, list.get(1).intValue());
         assertEquals(3, list.get(2).intValue());
 
         // test multiple subscribe
-        List<Integer> list2 =  o.blockingLast();
+        List<Integer> list2 =  f.blockingLast();
 
         assertEquals(3, list2.size());
         assertEquals(1, list2.get(0).intValue());

File: src/test/java/io/reactivex/internal/operators/flowable/AbstractFlowableWithUpstreamTest.java
Patch:
@@ -26,8 +26,8 @@ public class AbstractFlowableWithUpstreamTest {
     @SuppressWarnings("unchecked")
     @Test
     public void source() {
-        Flowable<Integer> o = Flowable.just(1);
+        Flowable<Integer> f = Flowable.just(1);
 
-        assertSame(o, ((HasUpstreamPublisher<Integer>)o.map(Functions.<Integer>identity())).source());
+        assertSame(f, ((HasUpstreamPublisher<Integer>)f.map(Functions.<Integer>identity())).source());
     }
 }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBlockingTest.java
Patch:
@@ -489,9 +489,9 @@ public void run() {
 
         new Flowable<Integer>() {
             @Override
-            protected void subscribeActual(Subscriber<? super Integer> observer) {
-                observer.onSubscribe(new BooleanSubscription());
-                s[0] = observer;
+            protected void subscribeActual(Subscriber<? super Integer> subscriber) {
+                subscriber.onSubscribe(new BooleanSubscription());
+                s[0] = subscriber;
             }
         }.blockingSubscribe(ts);
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java
Patch:
@@ -169,8 +169,8 @@ public void dispose() {
     public void doubleOnSubscribe() {
         TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
             @Override
-            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
-                return o.onTerminateDetach();
+            public Flowable<Object> apply(Flowable<Object> f) throws Exception {
+                return f.onTerminateDetach();
             }
         });
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycleTest.java
Patch:
@@ -48,8 +48,8 @@ public void doubleOnSubscribe() {
 
         TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Object>>() {
             @Override
-            public Publisher<Object> apply(Flowable<Object> o) throws Exception {
-                return o
+            public Publisher<Object> apply(Flowable<Object> f) throws Exception {
+                return f
                 .doOnLifecycle(new Consumer<Subscription>() {
                     @Override
                     public void accept(Subscription s) throws Exception {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java
Patch:
@@ -583,8 +583,8 @@ public Iterable<Integer> apply(Object v) throws Exception {
     public void badSource() {
         TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() {
             @Override
-            public Object apply(Flowable<Integer> o) throws Exception {
-                return o.flatMapIterable(new Function<Object, Iterable<Integer>>() {
+            public Object apply(Flowable<Integer> f) throws Exception {
+                return f.flatMapIterable(new Function<Object, Iterable<Integer>>() {
                     @Override
                     public Iterable<Integer> apply(Object v) throws Exception {
                         return Arrays.asList(10, 20);

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -577,6 +577,7 @@ public static <T> Completable fromSingle(final SingleSource<T> single) {
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.</dd>
+     *  <dt><b>Error handling:</b></dt>
      *  <dd>If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
      *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are cancelled.
      *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the
@@ -653,6 +654,7 @@ public static Completable merge(Iterable<? extends CompletableSource> sources) {
      *  and expects the other {@code Publisher} to honor it as well.</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.</dd>
+     *  <dt><b>Error handling:</b></dt>
      *  <dd>If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
      *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are cancelled.
      *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the
@@ -689,6 +691,7 @@ public static Completable merge(Publisher<? extends CompletableSource> sources)
      *  and expects the other {@code Publisher} to honor it as well.</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code merge} does not operate by default on a particular {@link Scheduler}.</dd>
+     *  <dt><b>Error handling:</b></dt>
      *  <dd>If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
      *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are cancelled.
      *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the

File: src/test/java/io/reactivex/TestHelper.java
Patch:
@@ -482,7 +482,7 @@ public static <E extends Enum<E>> void checkEnum(Class<E> enumClass) {
     }
 
     /**
-     * Returns an Consumer that asserts the TestSubscriber has exaclty one value + completed
+     * Returns an Consumer that asserts the TestSubscriber has exactly one value + completed
      * normally and that single value is not the value specified.
      * @param <T> the value type
      * @param value the value not expected
@@ -505,7 +505,7 @@ public void accept(TestSubscriber<T> ts) throws Exception {
     }
 
     /**
-     * Returns an Consumer that asserts the TestObserver has exaclty one value + completed
+     * Returns an Consumer that asserts the TestObserver has exactly one value + completed
      * normally and that single value is not the value specified.
      * @param <T> the value type
      * @param value the value not expected

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -511,7 +511,7 @@ public static <T> Completable fromObservable(final ObservableSource<T> observabl
      * Returns a Completable instance that subscribes to the given publisher, ignores all values and
      * emits only the terminal event.
      * <p>
-     * <img width="640" height="442" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png" alt="">
+     * <img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png" alt="">
      * <p>
      * The {@link Publisher} must follow the
      * <a href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams">Reactive-Streams specification</a>.
@@ -2427,8 +2427,6 @@ public final <T> Flowable<T> toFlowable() {
 
     /**
      * Converts this Completable into a {@link Maybe}.
-     * <p>
-     * <img width="640" height="293" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png" alt="">
      * <dl>
      * <dt><b>Scheduler:</b></dt>
      * <dd>{@code toMaybe} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -2451,6 +2449,8 @@ public final <T> Maybe<T> toMaybe() {
     /**
      * Returns an Observable which when subscribed to subscribes to this Completable and
      * relays the terminal events to the subscriber.
+     * <p>
+     * <img width="640" height="293" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toObservable} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -51,7 +51,7 @@
  * <p>
  * <img width="640" height="301" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.legend.png" alt="">
  * <p>
- * For more information see the <a href="http://reactivex.io/documentation/observable.html">ReactiveX
+ * For more information see the <a href="http://reactivex.io/documentation/single.html">ReactiveX
  * documentation</a>.
  *
  * @param <T>
@@ -3591,7 +3591,6 @@ public final <R> R to(Function<? super Single<T>, R> convert) {
      *
      * @return a {@link Completable} that calls {@code onComplete} on it's subscriber when the source {@link Single}
      *         calls {@code onSuccess}.
-     * @see <a href="http://reactivex.io/documentation/completable.html">ReactiveX documentation: Completable</a>
      * @since 2.0
      * @deprecated see {@link #ignoreElement()} instead, will be removed in 3.0
      */
@@ -3614,7 +3613,6 @@ public final Completable toCompletable() {
      *
      * @return a {@link Completable} that calls {@code onComplete} on it's observer when the source {@link Single}
      *         calls {@code onSuccess}.
-     * @see <a href="http://reactivex.io/documentation/completable.html">ReactiveX documentation: Completable</a>
      * @since 2.1.13
      */
     @CheckReturnValue

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -5481,7 +5481,7 @@ public final T blockingFirst(T defaultItem) {
      * <em>Note:</em> the method will only return if the upstream terminates or the current
      * thread is interrupted.
      * <p>
-     * <p>This method executes the {@code Consumer} on the current thread while
+     * This method executes the {@code Consumer} on the current thread while
      * {@link #subscribe(Consumer)} executes the consumer on the original caller thread of the
      * sequence.
      * <dl>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -5027,7 +5027,7 @@ public final T blockingFirst(T defaultItem) {
      * <em>Note:</em> the method will only return if the upstream terminates or the current
      * thread is interrupted.
      * <p>
-     * <p>This method executes the {@code Consumer} on the current thread while
+     * This method executes the {@code Consumer} on the current thread while
      * {@link #subscribe(Consumer)} executes the consumer on the original caller thread of the
      * sequence.
      * <dl>

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java
Patch:
@@ -218,6 +218,7 @@ void drain() {
                     if (cancelled) {
                         queue.clear();
                         item = null;
+                        break;
                     }
 
                     int s = state;

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java
Patch:
@@ -213,6 +213,7 @@ void drain() {
                     if (cancelled) {
                         queue.clear();
                         item = null;
+                        break;
                     }
 
                     int s = state;

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java
Patch:
@@ -199,6 +199,7 @@ void drain() {
                     if (cancelled) {
                         queue.clear();
                         item = null;
+                        break;
                     }
 
                     int s = state;

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java
Patch:
@@ -194,6 +194,7 @@ void drain() {
                     if (cancelled) {
                         queue.clear();
                         item = null;
+                        break;
                     }
 
                     int s = state;

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -272,9 +272,9 @@ public static <T> Flowable<T> concat(Publisher<? extends MaybeSource<? extends T
 
     /**
      * Concatenate the single values, in a non-overlapping fashion, of the MaybeSource sources in the array.
-     * <dl>
      * <p>
      * <img width="640" height="526" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArray.png" alt="">
+     * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Flowable} honors the backpressure of the downstream consumer.</dd>
      *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -13173,7 +13173,6 @@ public final Observable<T> throttleLatest(long timeout, TimeUnit unit, Scheduler
      * will be emitted by the resulting ObservableSource.
      * <p>
      * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.png" alt="">
-     * <p>
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
Patch:
@@ -63,7 +63,7 @@ public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T>
                 if (bs.isCancelled()) {
                     break;
                 }
-                if (o == BlockingSubscriber.TERMINATED
+                if (v == BlockingSubscriber.TERMINATED
                         || NotificationLite.acceptFull(v, subscriber)) {
                     break;
                 }

File: src/main/java/io/reactivex/processors/MulticastProcessor.java
Patch:
@@ -43,7 +43,7 @@
  *      the given prefetch amount and no reference counting behavior.</li>
  * <li>{@link #create(boolean)}: create an empty {@code MulticastProcessor} with
  *      {@link io.reactivex.Flowable#bufferSize() Flowable.bufferSize()} prefetch amount
- *      and no reference counting behavior.</li>
+ *      and an optional reference counting behavior.</li>
  * <li>{@link #create(int, boolean)}: create an empty {@code MulticastProcessor} with
  *      the given prefetch amount and an optional reference counting behavior.</li>
  * </ul>
@@ -174,7 +174,7 @@ public static <T> MulticastProcessor<T> create() {
 
     /**
      * Constructs a fresh instance with the default Flowable.bufferSize() prefetch
-     * amount and no refCount-behavior.
+     * amount and the optional refCount-behavior.
      * @param <T> the input and output value type
      * @param refCount if true and if all Subscribers have canceled, the upstream
      * is cancelled

File: src/main/java/io/reactivex/internal/observers/LambdaObserver.java
Patch:
@@ -79,6 +79,8 @@ public void onError(Throwable t) {
                 Exceptions.throwIfFatal(e);
                 RxJavaPlugins.onError(new CompositeException(t, e));
             }
+        } else {
+            RxJavaPlugins.onError(t);
         }
     }
 

File: src/main/java/io/reactivex/processors/MulticastProcessor.java
Patch:
@@ -102,14 +102,14 @@
  * <p>
  * Example:
  * <pre><code>
-    MulticastProcessor&lt;Integer> mp = Flowable.range(1, 10)
+    MulticastProcessor&lt;Integer&gt; mp = Flowable.range(1, 10)
     .subscribeWith(MulticastProcessor.create());
 
     mp.test().assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
 
     // --------------------
 
-    MulticastProcessor&lt;Integer> mp2 = MulticastProcessor.create(4);
+    MulticastProcessor&lt;Integer&gt; mp2 = MulticastProcessor.create(4);
     mp2.start();
 
     assertTrue(mp2.offer(1));

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -28,6 +28,7 @@
 import io.reactivex.internal.operators.completable.*;
 import io.reactivex.internal.operators.flowable.*;
 import io.reactivex.internal.operators.maybe.*;
+import io.reactivex.internal.operators.mixed.*;
 import io.reactivex.internal.operators.observable.*;
 import io.reactivex.internal.operators.single.*;
 import io.reactivex.internal.util.*;
@@ -2535,7 +2536,8 @@ public final <U> Observable<U> flattenAsObservable(final Function<? super T, ? e
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <R> Observable<R> flatMapObservable(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {
-        return toObservable().flatMap(mapper);
+        ObjectHelper.requireNonNull(mapper, "mapper is null");
+        return RxJavaPlugins.onAssembly(new SingleFlatMapObservable<T, R>(this, mapper));
     }
 
     /**

File: src/test/java/io/reactivex/completable/CompletableTest.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.completable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -26,7 +27,7 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.*;
@@ -4428,6 +4429,7 @@ public void andThenError() {
         Completable.unsafeCreate(new CompletableSource() {
                 @Override
                 public void subscribe(CompletableObserver cs) {
+                    cs.onSubscribe(Disposables.empty());
                     cs.onError(e);
                 }
             })

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisher.java
Patch:
@@ -137,6 +137,7 @@ public void onSubscribe(Subscription s) {
 
             @Override
             public void onNext(Object value) {
+                SubscriptionHelper.cancel(this);
                 parent.otherComplete();
             }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java
Patch:
@@ -69,6 +69,7 @@ static final class TakeUntilMainObserver<T>
         @Override
         public void dispose() {
             DisposableHelper.dispose(this);
+            other.dispose();
         }
 
         @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java
Patch:
@@ -934,6 +934,7 @@ public void subscribe(FlowableEmitter<Object> e) throws Exception {
         }
     }
 
+    @SuppressWarnings("rawtypes")
     @Test
     public void emittersHasToString() {
         Map<BackpressureStrategy, Class<? extends FlowableEmitter>> emitterMap =

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -359,7 +359,7 @@ public void onSubscribe(Subscription s) {
                     @SuppressWarnings("unchecked")
                     QueueSubscription<R> qs = (QueueSubscription<R>) s;
 
-                    int m = qs.requestFusion(QueueSubscription.ANY);
+                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);
                     if (m == QueueSubscription.SYNC) {
                         fusionMode = m;
                         queue = qs;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -348,7 +348,7 @@ public void onSubscribe(Disposable s) {
                     @SuppressWarnings("unchecked")
                     QueueDisposable<R> qd = (QueueDisposable<R>) s;
 
-                    int m = qd.requestFusion(QueueDisposable.ANY);
+                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);
                     if (m == QueueDisposable.SYNC) {
                         queue = qd;
                         done = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.reactivex.*;
 import io.reactivex.internal.subscriptions.*;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class FlowableTake<T> extends AbstractFlowableWithUpstream<T, T> {
     final long limit;
@@ -75,6 +76,8 @@ public void onError(Throwable t) {
                 done = true;
                 subscription.cancel();
                 actual.onError(t);
+            } else {
+                RxJavaPlugins.onError(t);
             }
         }
         @Override

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -49,7 +49,7 @@
 public abstract class Maybe<T> implements MaybeSource<T> {
 
     /**
-     * Runs multiple Maybe sources and signals the events of the first one that signals (cancelling
+     * Runs multiple MaybeSources and signals the events of the first one that signals (cancelling
      * the rest).
      * <dl>
      * <dt><b>Scheduler:</b></dt>
@@ -68,7 +68,7 @@ public static <T> Maybe<T> amb(final Iterable<? extends MaybeSource<? extends T>
     }
 
     /**
-     * Runs multiple Maybe sources and signals the events of the first one that signals (cancelling
+     * Runs multiple MaybeSources and signals the events of the first one that signals (cancelling
      * the rest).
      * <dl>
      * <dt><b>Scheduler:</b></dt>
@@ -412,7 +412,7 @@ public static <T> Flowable<T> concatEager(Iterable<? extends MaybeSource<? exten
     }
 
     /**
-     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.
+     * Concatenates a Publisher sequence of MaybeSources eagerly into a single stream of values.
      * <p>
      * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
      * emitted source Publishers as they are observed. The operator buffers the values emitted by these

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java
Patch:
@@ -18,12 +18,12 @@
 import io.reactivex.*;
 import io.reactivex.annotations.Experimental;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.*;
+import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.SimplePlainQueue;
-import io.reactivex.internal.queue.SpscArrayQueue;
+import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -107,7 +107,7 @@ static final class ConcatMapSingleMainObserver<T, R>
             this.errorMode = errorMode;
             this.errors = new AtomicThrowable();
             this.inner = new ConcatMapSingleObserver<R>(this);
-            this.queue = new SpscArrayQueue<T>(prefetch);
+            this.queue = new SpscLinkedArrayQueue<T>(prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1397,7 +1397,7 @@ public final Completable doFinally(Action onFinally) {
      * 
      * public final class CustomCompletableObserver implements CompletableObserver, Disposable {
      *
-     *     // The donstream's CompletableObserver that will receive the onXXX events
+     *     // The downstream's CompletableObserver that will receive the onXXX events
      *     final CompletableObserver downstream;
      *
      *     // The connection to the upstream source that will call this class' onXXX methods

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -2978,7 +2978,7 @@ public final <R> Observable<R> flatMapObservable(Function<? super T, ? extends O
      *
      * @param <R> the result value type
      * @param mapper
-     *            a function that, when applied to the item emitted by the source Maybe, returns an
+     *            a function that, when applied to the item emitted by the source Maybe, returns a
      *            Flowable
      * @return the Flowable returned from {@code func} when applied to the item emitted by the source Maybe
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
@@ -3139,7 +3139,7 @@ public final Single<Boolean> isEmpty() {
      * 
      * public final class CustomMaybeObserver&lt;T&gt; implements MaybeObserver&lt;T&gt;, Disposable {
      *
-     *     // The donstream's MaybeObserver that will receive the onXXX events
+     *     // The downstream's MaybeObserver that will receive the onXXX events
      *     final MaybeObserver&lt;? super String&gt; downstream;
      *
      *     // The connection to the upstream source that will call this class' onXXX methods

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -9386,7 +9386,7 @@ public final Single<T> lastOrError() {
      * 
      * public final class CustomObserver&lt;T&gt; implements Observer&lt;T&gt;, Disposable {
      *
-     *     // The donstream's Observer that will receive the onXXX events
+     *     // The downstream's Observer that will receive the onXXX events
      *     final Observer&lt;? super String&gt; downstream;
      *
      *     // The connection to the upstream source that will call this class' onXXX methods
@@ -12250,7 +12250,7 @@ public final Completable switchMapCompletable(@NonNull Function<? super T, ? ext
      *  <dd>Errors of this {@code Observable} and all the {@code CompletableSource}s, who had the chance
      *  to run to their completion, are delayed until
      *  all of them terminate in some fashion. At this point, if there was only one failure, the respective
-     *  {@code Throwable} is emitted to the dowstream. It there were more than one failures, the
+     *  {@code Throwable} is emitted to the downstream. It there were more than one failures, the
      *  operator combines all {@code Throwable}s into a {@link io.reactivex.exceptions.CompositeException CompositeException}
      *  and signals that to the downstream.
      *  If any inactivated (switched out) {@code CompletableSource}

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2365,7 +2365,7 @@ public final <R> Maybe<R> flatMapMaybe(final Function<? super T, ? extends Maybe
      *
      * @param <R> the result value type
      * @param mapper
-     *            a function that, when applied to the item emitted by the source Single, returns an
+     *            a function that, when applied to the item emitted by the source Single, returns a
      *            Flowable
      * @return the Flowable returned from {@code func} when applied to the item emitted by the source Single
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
@@ -2517,7 +2517,7 @@ public final T blockingGet() {
      * 
      * public final class CustomSingleObserver&lt;T&gt; implements SingleObserver&lt;T&gt;, Disposable {
      *
-     *     // The donstream's SingleObserver that will receive the onXXX events
+     *     // The downstream's SingleObserver that will receive the onXXX events
      *     final SingleObserver&lt;? super String&gt; downstream;
      *
      *     // The connection to the upstream source that will call this class' onXXX methods

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapCompletable.java
Patch:
@@ -31,7 +31,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
- * Maps the upstream intems into {@link CompletableSource}s and subscribes to them one after the
+ * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
  * other completes or terminates (in error-delaying mode).
  * @param <T> the upstream value type
  * @since 2.1.11 - experimental

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapCompletable.java
Patch:
@@ -28,7 +28,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
- * Maps the upstream intems into {@link CompletableSource}s and subscribes to them one after the
+ * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
  * other completes or terminates (in error-delaying mode).
  * @param <T> the upstream value type
  * @since 2.1.11 - experimental

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -49,7 +49,7 @@
  * <p>
  * <img width="640" height="415" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.t.png" alt="">
  * </li>
- * <li>{@link #createWithTimeAndSize(long, TimeUnit, Scheduler, int)}: retaims no more than the given number of items
+ * <li>{@link #createWithTimeAndSize(long, TimeUnit, Scheduler, int)}: retains no more than the given number of items
  * which are also no older than the specified time and replays them to new {@code Subscriber}s (which could mean all items age out).
  * <p>
  * <img width="640" height="404" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.nt.png" alt="">

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -3084,7 +3084,7 @@ public final Maybe<T> hide() {
     /**
      * Ignores the item emitted by the source Maybe and only calls {@code onComplete} or {@code onError}.
      * <p>
-     * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.png" alt="">
+     * <img width="640" height="389" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code ignoreElement} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
Patch:
@@ -91,7 +91,7 @@ public void forEachWhile(NonThrowingPredicate<? super T> consumer) {
                     break;
                 }
                 if (consumer.test((T)o)) {
-                    break;
+                    return;
                 }
             }
             a = (Object[])a[c];

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -2182,7 +2182,8 @@ public final <T> Flowable<T> toFlowable() {
      * </dl>
      *
      * @param <T> the value type
-     * @return a {@link Maybe} that emits a single item T or an error.
+     * @return a {@link Maybe} that only calls {@code onComplete} or {@code onError}, based on which one is
+     *         called by the source Completable.
      */
     @CheckReturnValue
     @SuppressWarnings("unchecked")

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java
Patch:
@@ -170,7 +170,7 @@ public void cancel() {
             cancelled = true;
             upstream.cancel();
             inner.dispose();
-            if (getAndIncrement() != 0) {
+            if (getAndIncrement() == 0) {
                 queue.clear();
                 item = null;
             }

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java
Patch:
@@ -170,7 +170,7 @@ public void cancel() {
             cancelled = true;
             upstream.cancel();
             inner.dispose();
-            if (getAndIncrement() != 0) {
+            if (getAndIncrement() == 0) {
                 queue.clear();
                 item = null;
             }

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java
Patch:
@@ -148,7 +148,7 @@ public void dispose() {
             cancelled = true;
             upstream.dispose();
             inner.dispose();
-            if (getAndIncrement() != 0) {
+            if (getAndIncrement() == 0) {
                 queue.clear();
                 item = null;
             }

File: src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java
Patch:
@@ -148,7 +148,7 @@ public void dispose() {
             cancelled = true;
             upstream.dispose();
             inner.dispose();
-            if (getAndIncrement() != 0) {
+            if (getAndIncrement() == 0) {
                 queue.clear();
                 item = null;
             }

File: src/main/java/io/reactivex/exceptions/CompositeException.java
Patch:
@@ -278,7 +278,7 @@ public int size() {
      * @param e the {@link Throwable} {@code e}.
      * @return The root cause of {@code e}. If {@code e.getCause()} returns {@code null} or {@code e}, just return {@code e} itself.
      */
-    private Throwable getRootCause(Throwable e) {
+    /*private */Throwable getRootCause(Throwable e) {
         Throwable root = e.getCause();
         if (root == null || cause == root) {
             return e;

File: src/main/java/io/reactivex/internal/functions/ObjectHelper.java
Patch:
@@ -71,7 +71,7 @@ public static int compare(int v1, int v2) {
     }
 
     /**
-     * Compares two integer values similar to Long.compare.
+     * Compares two long values similar to Long.compare.
      * @param v1 the first value
      * @param v2 the second value
      * @return the comparison result

File: src/main/java/io/reactivex/internal/util/MergerBiFunction.java
Patch:
@@ -58,8 +58,7 @@ public List<T> apply(List<T> a, List<T> b) throws Exception {
             while (at.hasNext()) {
                 both.add(at.next());
             }
-        } else
-        if (s2 != null) {
+        } else {
             both.add(s2);
             while (bt.hasNext()) {
                 both.add(bt.next());

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -1215,7 +1215,8 @@ public void subscribe(Subscriber<? super T> child) {
                         buf = bufferFactory.call();
                     } catch (Throwable ex) {
                         Exceptions.throwIfFatal(ex);
-                        throw ExceptionHelper.wrapOrThrow(ex);
+                        EmptySubscription.error(ex, child);
+                        return;
                     }
                     // create a new subscriber to source
                     ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java
Patch:
@@ -36,7 +36,7 @@ protected void subscribeActual(MaybeObserver<? super T> s) {
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, null));
+        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, null, false));
     }
 
     static final class SingleElementSubscriber<T>

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java
Patch:
@@ -41,7 +41,7 @@ protected void subscribeActual(SingleObserver<? super T> s) {
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, defaultValue));
+        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(source, defaultValue, true));
     }
 
     static final class SingleElementSubscriber<T>

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java
Patch:
@@ -125,9 +125,7 @@ public T next() {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(batchSize);
-            }
+            SubscriptionHelper.setOnce(this, s, batchSize);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
Patch:
@@ -180,9 +180,7 @@ public void removeChild(ReplaySubscription<T> p) {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(connection, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(connection, s, Long.MAX_VALUE);
         }
 
         /**

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -516,9 +516,7 @@ static final class CombineLatestInnerSubscriber<T>
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(prefetch);
-            }
+            SubscriptionHelper.setOnce(this, s, prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipUntil.java
Patch:
@@ -114,9 +114,7 @@ final class OtherSubscriber extends AtomicReference<Subscription>
 
             @Override
             public void onSubscribe(Subscription s) {
-                if (SubscriptionHelper.setOnce(this, s)) {
-                    s.request(Long.MAX_VALUE);
-                }
+                SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
             }
 
             @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntil.java
Patch:
@@ -99,9 +99,7 @@ final class OtherSubscriber extends AtomicReference<Subscription> implements Flo
 
             @Override
             public void onSubscribe(Subscription s) {
-                if (SubscriptionHelper.setOnce(this, s)) {
-                    s.request(Long.MAX_VALUE);
-                }
+                SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
             }
 
             @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
Patch:
@@ -343,9 +343,7 @@ static final class TimeoutConsumer extends AtomicReference<Subscription>
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
Patch:
@@ -95,9 +95,7 @@ static final class WindowBoundaryMainSubscriber<T, B>
 
         @Override
         public void onSubscribe(Subscription d) {
-            if (SubscriptionHelper.setOnce(upstream, d)) {
-                d.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(upstream, d, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java
Patch:
@@ -268,9 +268,7 @@ static final class WithLatestInnerSubscriber
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayOtherPublisher.java
Patch:
@@ -120,9 +120,7 @@ static final class OtherSubscriber<T> extends
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisher.java
Patch:
@@ -132,9 +132,7 @@ static final class TakeUntilOtherMaybeObserver<U>
 
             @Override
             public void onSubscribe(Subscription s) {
-                if (SubscriptionHelper.setOnce(this, s)) {
-                    s.request(Long.MAX_VALUE);
-                }
+                SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
             }
 
             @Override

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeTimeoutPublisher.java
Patch:
@@ -155,9 +155,7 @@ static final class TimeoutOtherMaybeObserver<T, U>
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/parallel/ParallelJoin.java
Patch:
@@ -516,9 +516,7 @@ static final class JoinInnerSubscriber<T>
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(prefetch);
-            }
+            SubscriptionHelper.setOnce(this, s, prefetch);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/parallel/ParallelReduceFull.java
Patch:
@@ -180,9 +180,7 @@ static final class ParallelReduceFullInnerSubscriber<T>
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/parallel/ParallelSortedJoin.java
Patch:
@@ -280,9 +280,7 @@ static final class SortedJoinInnerSubscriber<T>
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithSingle.java
Patch:
@@ -54,7 +54,7 @@ static final class OtherObserver<T, U>
 
         @Override
         public void onSubscribe(Disposable d) {
-            if (DisposableHelper.set(this, d)) {
+            if (DisposableHelper.setOnce(this, d)) {
 
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java
Patch:
@@ -139,9 +139,7 @@ static final class TakeUntilOtherSubscriber
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.setOnce(this, s)) {
-                s.request(Long.MAX_VALUE);
-            }
+            SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/subscribers/ForEachWhileSubscriber.java
Patch:
@@ -48,9 +48,7 @@ public ForEachWhileSubscriber(Predicate<? super T> onNext,
 
     @Override
     public void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.setOnce(this, s)) {
-            s.request(Long.MAX_VALUE);
-        }
+        SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);
     }
 
     @Override

File: src/main/java/io/reactivex/internal/subscribers/FutureSubscriber.java
Patch:
@@ -110,9 +110,7 @@ public T get(long timeout, TimeUnit unit) throws InterruptedException, Execution
 
     @Override
     public void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.setOnce(this.s, s)) {
-            s.request(Long.MAX_VALUE);
-        }
+        SubscriptionHelper.setOnce(this.s, s, Long.MAX_VALUE);
     }
 
     @Override

File: src/test/java/io/reactivex/flowable/FlowableCovarianceTest.java
Patch:
@@ -48,7 +48,7 @@ public void testCovarianceOfFrom() {
 
     @Test
     public void testSortedList() {
-        Comparator<Media> SORT_FUNCTION = new Comparator<Media>() {
+        Comparator<Media> sortFunction = new Comparator<Media>() {
             @Override
             public int compare(Media t1, Media t2) {
                 return 1;
@@ -57,11 +57,11 @@ public int compare(Media t1, Media t2) {
 
         // this one would work without the covariance generics
         Flowable<Media> o = Flowable.just(new Movie(), new TVSeason(), new Album());
-        o.toSortedList(SORT_FUNCTION);
+        o.toSortedList(sortFunction);
 
         // this one would NOT work without the covariance generics
         Flowable<Movie> o2 = Flowable.just(new Movie(), new ActionMovie(), new HorrorMovie());
-        o2.toSortedList(SORT_FUNCTION);
+        o2.toSortedList(sortFunction);
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -751,11 +751,11 @@ public void testBackpressureLoop() {
     public void testBackpressure() {
         BiFunction<String, Integer, String> combineLatestFunction = getConcatStringIntegerCombineLatestFunction();
 
-        int NUM = Flowable.bufferSize() * 4;
+        int num = Flowable.bufferSize() * 4;
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.combineLatest(
                 Flowable.just("one", "two"),
-                Flowable.range(2, NUM),
+                Flowable.range(2, num),
                 combineLatestFunction
         )
         .observeOn(Schedulers.computation())
@@ -767,7 +767,7 @@ public void testBackpressure() {
         assertEquals("two2", events.get(0));
         assertEquals("two3", events.get(1));
         assertEquals("two4", events.get(2));
-        assertEquals(NUM, events.size());
+        assertEquals(num, events.size());
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
Patch:
@@ -2021,7 +2021,7 @@ public V remove(Object key) {
         @Override
         public void putAll(Map<? extends K, ? extends V> m) {
            for (Entry<? extends K, ? extends V> entry: m.entrySet()) {
-               put(entry.getKey(), entry.getValue()); 
+               put(entry.getKey(), entry.getValue());
            }
         }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
Patch:
@@ -221,7 +221,7 @@ public void testMergeFlowableOfFlowables() {
         final Flowable<String> o1 = Flowable.unsafeCreate(new TestSynchronousFlowable());
         final Flowable<String> o2 = Flowable.unsafeCreate(new TestSynchronousFlowable());
 
-        Flowable<Flowable<String>> FlowableOfFlowables = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {
+        Flowable<Flowable<String>> flowableOfFlowables = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {
 
             @Override
             public void subscribe(Subscriber<? super Flowable<String>> observer) {
@@ -233,7 +233,7 @@ public void subscribe(Subscriber<? super Flowable<String>> observer) {
             }
 
         });
-        Flowable<String> m = Flowable.mergeDelayError(FlowableOfFlowables);
+        Flowable<String> m = Flowable.mergeDelayError(flowableOfFlowables);
         m.subscribe(stringObserver);
 
         verify(stringObserver, never()).onError(any(Throwable.class));

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
Patch:
@@ -78,7 +78,7 @@ public void testMergeFlowableOfFlowables() {
         final Flowable<String> o1 = Flowable.unsafeCreate(new TestSynchronousFlowable());
         final Flowable<String> o2 = Flowable.unsafeCreate(new TestSynchronousFlowable());
 
-        Flowable<Flowable<String>> FlowableOfFlowables = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {
+        Flowable<Flowable<String>> flowableOfFlowables = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {
 
             @Override
             public void subscribe(Subscriber<? super Flowable<String>> observer) {
@@ -90,7 +90,7 @@ public void subscribe(Subscriber<? super Flowable<String>> observer) {
             }
 
         });
-        Flowable<String> m = Flowable.merge(FlowableOfFlowables);
+        Flowable<String> m = Flowable.merge(flowableOfFlowables);
         m.subscribe(stringObserver);
 
         verify(stringObserver, never()).onError(any(Throwable.class));

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java
Patch:
@@ -37,7 +37,7 @@ public class FlowableRepeatTest {
 
     @Test(timeout = 2000)
     public void testRepetition() {
-        int NUM = 10;
+        int num = 10;
         final AtomicInteger count = new AtomicInteger();
         int value = Flowable.unsafeCreate(new Publisher<Integer>() {
 
@@ -47,9 +47,9 @@ public void subscribe(final Subscriber<? super Integer> o) {
                 o.onComplete();
             }
         }).repeat().subscribeOn(Schedulers.computation())
-        .take(NUM).blockingLast();
+        .take(num).blockingLast();
 
-        assertEquals(NUM, value);
+        assertEquals(num, value);
     }
 
     @Test(timeout = 2000)

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java
Patch:
@@ -37,7 +37,7 @@ public class ObservableRepeatTest {
 
     @Test(timeout = 2000)
     public void testRepetition() {
-        int NUM = 10;
+        int num = 10;
         final AtomicInteger count = new AtomicInteger();
         int value = Observable.unsafeCreate(new ObservableSource<Integer>() {
 
@@ -47,9 +47,9 @@ public void subscribe(final Observer<? super Integer> o) {
                 o.onComplete();
             }
         }).repeat().subscribeOn(Schedulers.computation())
-        .take(NUM).blockingLast();
+        .take(num).blockingLast();
 
-        assertEquals(NUM, value);
+        assertEquals(num, value);
     }
 
     @Test(timeout = 2000)

File: src/test/java/io/reactivex/observable/ObservableCovarianceTest.java
Patch:
@@ -47,7 +47,7 @@ public void testCovarianceOfFrom() {
 
     @Test
     public void testSortedList() {
-        Comparator<Media> SORT_FUNCTION = new Comparator<Media>() {
+        Comparator<Media> sortFunction = new Comparator<Media>() {
             @Override
             public int compare(Media t1, Media t2) {
                 return 1;
@@ -56,11 +56,11 @@ public int compare(Media t1, Media t2) {
 
         // this one would work without the covariance generics
         Observable<Media> o = Observable.just(new Movie(), new TVSeason(), new Album());
-        o.toSortedList(SORT_FUNCTION);
+        o.toSortedList(sortFunction);
 
         // this one would NOT work without the covariance generics
         Observable<Movie> o2 = Observable.just(new Movie(), new ActionMovie(), new HorrorMovie());
-        o2.toSortedList(SORT_FUNCTION);
+        o2.toSortedList(sortFunction);
     }
 
     @Test

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -180,8 +180,8 @@ public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancel
     }
 
     void doTerminate() {
-        Runnable r = onTerminate.get();
-        if (r != null && onTerminate.compareAndSet(r, null)) {
+        Runnable r = onTerminate.getAndSet(null);
+        if (r != null) {
             r.run();
         }
     }

File: src/test/java/io/reactivex/observers/ObserverFusion.java
Patch:
@@ -32,7 +32,7 @@ public enum ObserverFusion {
      * Use this as follows:
      * <pre>
      * source
-     * .to(ObserverFusion.test(0, QueueDisposable.ANY, false))
+     * .to(ObserverFusion.test(QueueDisposable.ANY, false))
      * .assertResult(0);
      * </pre>
      * @param <T> the value type

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -185,10 +185,10 @@ boolean addInner(InnerSubscriber<T, U> inner) {
         void removeInner(InnerSubscriber<T, U> inner) {
             for (;;) {
                 InnerSubscriber<?, ?>[] a = subscribers.get();
-                if (a == CANCELLED || a == EMPTY) {
+                int n = a.length;
+                if (n == 0) {
                     return;
                 }
-                int n = a.length;
                 int j = -1;
                 for (int i = 0; i < n; i++) {
                     if (a[i] == inner) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
Patch:
@@ -326,7 +326,6 @@ public void onComplete() {
             }
             done = true;
             parent.onComplete();
-//            parent.next();
         }
     }
 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableReduceSeedSingle.java
Patch:
@@ -89,8 +89,8 @@ public void onNext(T value) {
         @Override
         public void onError(Throwable e) {
             R v = value;
-            value = null;
             if (v != null) {
+                value = null;
                 actual.onError(e);
             } else {
                 RxJavaPlugins.onError(e);
@@ -100,8 +100,8 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             R v = value;
-            value = null;
             if (v != null) {
+                value = null;
                 actual.onSuccess(v);
             }
         }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
Patch:
@@ -296,7 +296,6 @@ public void onComplete() {
             }
             done = true;
             parent.onComplete();
-//            parent.next();
         }
     }
 }

File: src/main/java/io/reactivex/internal/schedulers/SchedulerWhen.java
Patch:
@@ -28,8 +28,8 @@
 import io.reactivex.annotations.NonNull;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.disposables.Disposables;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.processors.FlowableProcessor;
 import io.reactivex.processors.UnicastProcessor;
 
@@ -116,7 +116,7 @@ public SchedulerWhen(Function<Flowable<Flowable<Completable>>, Completable> comb
         try {
             disposable = combine.apply(workerProcessor).subscribe();
         } catch (Throwable e) {
-            Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
 
@@ -155,7 +155,7 @@ public Worker createWorker() {
     static final Disposable DISPOSED = Disposables.disposed();
 
     @SuppressWarnings("serial")
-    abstract static class ScheduledAction extends AtomicReference<Disposable>implements Disposable {
+    abstract static class ScheduledAction extends AtomicReference<Disposable> implements Disposable {
         ScheduledAction() {
             super(SUBSCRIBED);
         }

File: src/main/java/io/reactivex/internal/subscribers/QueueDrainSubscriber.java
Patch:
@@ -69,7 +69,7 @@ protected final void fastPathEmitMax(U value, boolean delayError, Disposable dis
         final Subscriber<? super V> s = actual;
         final SimplePlainQueue<U> q = queue;
 
-        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {
+        if (fastEnter()) {
             long r = requested.get();
             if (r != 0L) {
                 if (accept(s, value)) {
@@ -98,7 +98,7 @@ protected final void fastPathOrderedEmitMax(U value, boolean delayError, Disposa
         final Subscriber<? super V> s = actual;
         final SimplePlainQueue<U> q = queue;
 
-        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {
+        if (fastEnter()) {
             long r = requested.get();
             if (r != 0L) {
                 if (q.isEmpty()) {

File: src/main/java/io/reactivex/processors/BehaviorProcessor.java
Patch:
@@ -459,10 +459,10 @@ boolean add(BehaviorSubscription<T> rs) {
     void remove(BehaviorSubscription<T> rs) {
         for (;;) {
             BehaviorSubscription<T>[] a = subscribers.get();
-            if (a == TERMINATED || a == EMPTY) {
+            int len = a.length;
+            if (len == 0) {
                 return;
             }
-            int len = a.length;
             int j = -1;
             for (int i = 0; i < len; i++) {
                 if (a[i] == rs) {

File: src/main/java/io/reactivex/subjects/BehaviorSubject.java
Patch:
@@ -410,10 +410,10 @@ boolean add(BehaviorDisposable<T> rs) {
     void remove(BehaviorDisposable<T> rs) {
         for (;;) {
             BehaviorDisposable<T>[] a = subscribers.get();
-            if (a == TERMINATED || a == EMPTY) {
+            int len = a.length;
+            if (len == 0) {
                 return;
             }
-            int len = a.length;
             int j = -1;
             for (int i = 0; i < len; i++) {
                 if (a[i] == rs) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableInternalHelperTest.java
Patch:
@@ -29,8 +29,6 @@ public void enums() {
         assertNotNull(ObservableInternalHelper.MapToInt.values()[0]);
         assertNotNull(ObservableInternalHelper.MapToInt.valueOf("INSTANCE"));
 
-        assertNotNull(ObservableInternalHelper.ErrorMapperFilter.values()[0]);
-        assertNotNull(ObservableInternalHelper.ErrorMapperFilter.valueOf("INSTANCE"));
     }
 
     @Test

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java
Patch:
@@ -255,10 +255,10 @@ void drain() {
                             consumed = c;
                         }
 
-                        SingleSource<? extends R> ms;
+                        SingleSource<? extends R> ss;
 
                         try {
-                            ms = ObjectHelper.requireNonNull(mapper.apply(v), "The mapper returned a null SingleSource");
+                            ss = ObjectHelper.requireNonNull(mapper.apply(v), "The mapper returned a null SingleSource");
                         } catch (Throwable ex) {
                             Exceptions.throwIfFatal(ex);
                             upstream.cancel();
@@ -270,7 +270,7 @@ void drain() {
                         }
 
                         state = STATE_ACTIVE;
-                        ms.subscribe(inner);
+                        ss.subscribe(inner);
                         break;
                     } else if (s == STATE_RESULT_VALUE) {
                         long e = emitted;

File: src/main/java/io/reactivex/internal/operators/mixed/FlowableSwitchMapSingle.java
Patch:
@@ -115,10 +115,10 @@ public void onNext(T t) {
                 current.dispose();
             }
 
-            SingleSource<? extends R> ms;
+            SingleSource<? extends R> ss;
 
             try {
-                ms = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null SingleSource");
+                ss = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null SingleSource");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 upstream.cancel();
@@ -135,7 +135,7 @@ public void onNext(T t) {
                     break;
                 }
                 if (inner.compareAndSet(current, observer)) {
-                    ms.subscribe(observer);
+                    ss.subscribe(observer);
                     break;
                 }
             }

File: src/main/java/io/reactivex/CompletableObserver.java
Patch:
@@ -28,7 +28,6 @@
  * Calling the {@code CompletableObserver}'s method must happen in a serialized fashion, that is, they must not
  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must
  * adhere to the following protocol:
- * <p>
  * <pre><code>    onSubscribe (onError | onComplete)?</code></pre>
  * <p>
  * Subscribing a {@code CompletableObserver} to multiple {@code CompletableSource}s is not recommended. If such reuse

File: src/main/java/io/reactivex/MaybeObserver.java
Patch:
@@ -28,7 +28,6 @@
  * Calling the {@code MaybeObserver}'s method must happen in a serialized fashion, that is, they must not
  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must
  * adhere to the following protocol:
- * <p>
  * <pre><code>    onSubscribe (onSuccess | onError | onComplete)?</code></pre>
  * <p>
  * Note that unlike with the {@code Observable} protocol, {@link #onComplete()} is not called after the success item has been

File: src/main/java/io/reactivex/Observer.java
Patch:
@@ -30,7 +30,6 @@
  * Calling the {@code Observer}'s method must happen in a serialized fashion, that is, they must not
  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must
  * adhere to the following protocol:
- * <p>
  * <pre><code>    onSubscribe onNext* (onError | onComplete)?</code></pre>
  * <p>
  * Subscribing an {@code Observer} to multiple {@code ObservableSource}s is not recommended. If such reuse

File: src/main/java/io/reactivex/SingleObserver.java
Patch:
@@ -28,7 +28,6 @@
  * Calling the {@code SingleObserver}'s method must happen in a serialized fashion, that is, they must not
  * be invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern must
  * adhere to the following protocol:
- * <p>
  * <pre><code>    onSubscribe (onSuccess | onError)?</code></pre>
  * <p>
  * Subscribing a {@code SingleObserver} to multiple {@code SingleSource}s is not recommended. If such reuse

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -5078,7 +5078,7 @@ public final Iterable<T> blockingIterable() {
     /**
      * Converts this {@code Observable} into an {@link Iterable}.
      * <p>
-     * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.toIterable.png" alt="">
+     * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -5151,6 +5151,8 @@ public final T blockingLast(T defaultItem) {
      * Returns an {@link Iterable} that returns the latest item emitted by this {@code Observable},
      * waiting if necessary for one to become available.
      * <p>
+     * <img width="640" height="350" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLatest.o.png" alt="">
+     * <p>
      * If this {@code Observable} produces items faster than {@code Iterator.next} takes them,
      * {@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.
      * <p>

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -12373,11 +12373,11 @@ public final Flowable<T> serialize() {
     }
 
     /**
-     * Returns a new {@link Publisher} that multicasts (shares) the original {@link Publisher}. As long as
+     * Returns a new {@link Publisher} that multicasts (and shares a single subscription to) the original {@link Publisher}. As long as
      * there is at least one {@link Subscriber} this {@link Publisher} will be subscribed and emitting data.
      * When all subscribers have cancelled it will cancel the source {@link Publisher}.
      * <p>
-     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount()}.
+     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount() refCount()}.
      * <p>
      * <img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.png" alt="">
      * <dl>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -10493,11 +10493,11 @@ public final Observable<T> serialize() {
     }
 
     /**
-     * Returns a new {@link ObservableSource} that multicasts (shares) the original {@link ObservableSource}. As long as
+     * Returns a new {@link ObservableSource} that multicasts (and shares a single subscription to) the original {@link ObservableSource}. As long as
      * there is at least one {@link Observer} this {@link ObservableSource} will be subscribed and emitting data.
      * When all subscribers have disposed it will dispose the source {@link ObservableSource}.
      * <p>
-     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}.
+     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount() refCount()}.
      * <p>
      * <img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png" alt="">
      * <dl>

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -10524,7 +10524,7 @@ public final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
-     * @return a Flowable which out references to the upstream producer and downstream Subscriber if
+     * @return a Flowable which nulls out references to the upstream producer and downstream Subscriber if
      * the sequence is terminated or downstream cancels
      * @since 2.0
      */

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -9012,7 +9012,7 @@ public final Observable<T> onExceptionResumeNext(final ObservableSource<? extend
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
-     * @return an Observable which out references to the upstream producer and downstream Observer if
+     * @return an Observable which nulls out references to the upstream producer and downstream Observer if
      * the sequence is terminated or downstream calls dispose()
      * @since 2.0
      */

File: src/test/java/io/reactivex/processors/AsyncProcessorTest.java
Patch:
@@ -35,7 +35,7 @@
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.*;
 
-public class AsyncProcessorTest extends DelayedFlowableProcessorTest<Object> {
+public class AsyncProcessorTest extends FlowableProcessorTest<Object> {
 
     private final Throwable testException = new Throwable();
 

File: src/test/java/io/reactivex/processors/BehaviorProcessorTest.java
Patch:
@@ -39,7 +39,7 @@
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
-public class BehaviorProcessorTest extends DelayedFlowableProcessorTest<Object> {
+public class BehaviorProcessorTest extends FlowableProcessorTest<Object> {
 
     private final Throwable testException = new Throwable();
 

File: src/test/java/io/reactivex/processors/UnicastProcessorTest.java
Patch:
@@ -30,7 +30,7 @@
 
 import static org.junit.Assert.*;
 
-public class UnicastProcessorTest extends DelayedFlowableProcessorTest<Object> {
+public class UnicastProcessorTest extends FlowableProcessorTest<Object> {
 
     @Override
     protected FlowableProcessor<Object> create() {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -166,7 +166,7 @@ public void onComplete() {
             queue.offer(b);
             done = true;
             if (enter()) {
-                QueueDrainHelper.drainMaxLoop(queue, actual, false, this, this);
+                QueueDrainHelper.drainMaxLoop(queue, actual, false, null, this);
             }
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
Patch:
@@ -161,7 +161,7 @@ public void onComplete() {
                 queue.offer(b);
                 done = true;
                 if (enter()) {
-                    QueueDrainHelper.drainLoop(queue, actual, false, this, this);
+                    QueueDrainHelper.drainLoop(queue, actual, false, null, this);
                 }
             }
             DisposableHelper.dispose(timer);

File: src/test/java/io/reactivex/ParamValidationCheckerTest.java
Patch:
@@ -258,6 +258,7 @@ public void checkParallelFlowable() {
 
         // zero retry is allowed
         addOverride(new ParamOverride(Completable.class, 0, ParamMode.NON_NEGATIVE, "retry", Long.TYPE));
+        addOverride(new ParamOverride(Completable.class, 0, ParamMode.NON_NEGATIVE, "retry", Long.TYPE, Predicate.class));
 
         // negative time is considered as zero time
         addOverride(new ParamOverride(Completable.class, 0, ParamMode.ANY, "blockingGet", Long.TYPE, TimeUnit.class));
@@ -323,6 +324,7 @@ public void checkParallelFlowable() {
 
         // zero retry is allowed
         addOverride(new ParamOverride(Single.class, 0, ParamMode.NON_NEGATIVE, "retry", Long.TYPE));
+        addOverride(new ParamOverride(Single.class, 0, ParamMode.NON_NEGATIVE, "retry", Long.TYPE, Predicate.class));
 
         // negative time is considered as zero time
         addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, "delaySubscription", Long.TYPE, TimeUnit.class));

File: src/main/java/io/reactivex/observables/package-info.java
Patch:
@@ -16,7 +16,7 @@
 
 /**
  * Classes supporting the Observable base reactive class:
- * {@link io.reactivex.observable.ConnectableObservable} and
- * {@link io.reactivex.observable.GroupedObservable}.
+ * {@link io.reactivex.observables.ConnectableObservable} and
+ * {@link io.reactivex.observables.GroupedObservable}.
  */
 package io.reactivex.observables;

File: src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
Patch:
@@ -49,7 +49,7 @@ public Worker createWorker() {
     @NonNull
     @Override
     public Disposable scheduleDirect(@NonNull Runnable run) {
-        run.run();
+        RxJavaPlugins.onSchedule(run).run();
         return EmptyDisposable.INSTANCE;
     }
 
@@ -58,7 +58,7 @@ public Disposable scheduleDirect(@NonNull Runnable run) {
     public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) {
         try {
             unit.sleep(delay);
-            run.run();
+            RxJavaPlugins.onSchedule(run).run();
         } catch (InterruptedException ex) {
             Thread.currentThread().interrupt();
             RxJavaPlugins.onError(ex);

File: src/main/java/io/reactivex/internal/schedulers/SchedulerMultiWorkerSupport.java
Patch:
@@ -23,7 +23,7 @@
  * {@link io.reactivex.Scheduler.Worker} instances will be running
  * with different backing threads.
  *
- * @since 2.1.7 - experimental
+ * @since 2.1.8 - experimental
  */
 @Experimental
 public interface SchedulerMultiWorkerSupport {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java
Patch:
@@ -52,7 +52,7 @@ static final class ConcatInnerObserver extends AtomicInteger implements Completa
 
         @Override
         public void onSubscribe(Disposable d) {
-            sd.update(d);
+            sd.replace(d);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java
Patch:
@@ -64,7 +64,7 @@ static final class ConcatInnerObserver extends AtomicInteger implements Completa
 
         @Override
         public void onSubscribe(Disposable d) {
-            sd.update(d);
+            sd.replace(d);
         }
 
         @Override

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -313,9 +313,7 @@ public void onNext(T t) {
             }
             if (r != 0L) {
                 actual.onNext(t);
-                if (r != Long.MAX_VALUE) {
-                    decrementAndGet();
-                }
+                BackpressureHelper.producedCancel(this, 1);
             } else {
                 cancel();
                 actual.onError(new MissingBackpressureException("Could not emit value due to lack of requests"));

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java
Patch:
@@ -282,6 +282,7 @@ public void testSingleWithEmpty() {
 
         InOrder inOrder = inOrder(observer);
         inOrder.verify(observer).onComplete();
+        inOrder.verify(observer, never()).onError(any(Throwable.class));
         inOrder.verifyNoMoreInteractions();
     }
 

File: src/main/java/io/reactivex/observers/package-info.java
Patch:
@@ -17,7 +17,7 @@
 /**
  * Default wrappers and implementations for Observer-based consumer classes and interfaces,
  * including disposable and resource-tracking variants and
- * the {@link io.reactivex.subscribers.TestObserver} that allows unit testing
+ * the {@link io.reactivex.observers.TestObserver} that allows unit testing
  * {@link io.reactivex.Observable}-, {@link io.reactivex.Single}-, {@link io.reactivex.Maybe}-
  * and {@link io.reactivex.Completable}-based flows.
  */

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1686,11 +1686,11 @@ public final void subscribe(CompletableObserver s) {
      * Completable source = Completable.complete().delay(1, TimeUnit.SECONDS);
      * CompositeDisposable composite = new CompositeDisposable();
      *
-     * class ResourceCompletableObserver implements CompletableObserver, Disposable {
+     * DisposableCompletableObserver ds = new DisposableCompletableObserver() {
      *     // ...
-     * }
+     * };
      *
-     * composite.add(source.subscribeWith(new ResourceCompletableObserver()));
+     * composite.add(source.subscribeWith(ds));
      * </code></pre>
      * <dl>
      *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -3772,11 +3772,11 @@ public final Maybe<T> subscribeOn(Scheduler scheduler) {
      * Maybe&lt;Integer&gt; source = Maybe.just(1);
      * CompositeDisposable composite = new CompositeDisposable();
      *
-     * MaybeObserver&lt;Integer&gt; ms = new MaybeObserver&lt;&gt;() {
+     * DisposableMaybeObserver&lt;Integer&gt; ds = new DisposableMaybeObserver&lt;&gt;() {
      *     // ...
      * };
      *
-     * composite.add(source.subscribeWith(ms));
+     * composite.add(source.subscribeWith(ds));
      * </code></pre>
      * <dl>
      *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -10939,11 +10939,11 @@ public final void subscribe(Observer<? super T> observer) {
      * Observable&lt;Integer&gt; source = Observable.range(1, 10);
      * CompositeDisposable composite = new CompositeDisposable();
      *
-     * ResourceObserver&lt;Integer&gt; rs = new ResourceObserver&lt;&gt;() {
+     * DisposableObserver&lt;Integer&gt; ds = new DisposableObserver&lt;&gt;() {
      *     // ...
      * };
      *
-     * composite.add(source.subscribeWith(rs));
+     * composite.add(source.subscribeWith(ds));
      * </code></pre>
      * <dl>
      *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2801,11 +2801,11 @@ public final void subscribe(SingleObserver<? super T> subscriber) {
      * Single&lt;Integer&gt; source = Single.just(1);
      * CompositeDisposable composite = new CompositeDisposable();
      *
-     * class ResourceSingleObserver implements SingleObserver&lt;Integer&gt;, Disposable {
+     * DisposableSingleObserver&lt;Integer&gt; ds = new DisposableSingleObserver&lt;&gt;() {
      *     // ...
-     * }
+     * };
      *
-     * composite.add(source.subscribeWith(new ResourceSingleObserver()));
+     * composite.add(source.subscribeWith(ds));
      * </code></pre>
      * <dl>
      *  <dt><b>Scheduler:</b></dt>

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -207,7 +207,6 @@ public static Completable concat(Publisher<? extends CompletableSource> sources,
      *
      * });
      * </code></pre>
-     * <p>
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code create} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/observers/DefaultObserver.java
Patch:
@@ -40,7 +40,7 @@
  *
  * <p>Example<pre><code>
  * Observable.range(1, 5)
- *     .subscribe(new DefaultObserver&lt;Integer>() {
+ *     .subscribe(new DefaultObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             System.out.println("Start!");
  *         }

File: src/main/java/io/reactivex/observers/DisposableCompletableObserver.java
Patch:
@@ -36,7 +36,7 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Completable.complete().delay(1, TimeUnit.SECONDS)
- *     .subscribeWith(new DisposableMaybeObserver&lt;Integer>() {
+ *     .subscribeWith(new DisposableMaybeObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             System.out.println("Start!");
  *         }

File: src/main/java/io/reactivex/observers/DisposableMaybeObserver.java
Patch:
@@ -40,7 +40,7 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Maybe.just(1).delay(1, TimeUnit.SECONDS)
- *     .subscribeWith(new DisposableMaybeObserver&lt;Integer>() {
+ *     .subscribeWith(new DisposableMaybeObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             System.out.println("Start!");
  *         }

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -41,7 +41,7 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Observable.range(1, 5)
- *     .subscribeWith(new DisposableObserver&lt;Integer>() {
+ *     .subscribeWith(new DisposableObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             System.out.println("Start!");
  *         }

File: src/main/java/io/reactivex/observers/DisposableSingleObserver.java
Patch:
@@ -36,7 +36,7 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Single.just(1).delay(1, TimeUnit.SECONDS)
- *     .subscribeWith(new DisposableSingleObserver&lt;Integer>() {
+ *     .subscribeWith(new DisposableSingleObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             System.out.println("Start!");
  *         }

File: src/main/java/io/reactivex/observers/ResourceCompletableObserver.java
Patch:
@@ -56,7 +56,7 @@
  *     .subscribeWith(new ResourceCompletableObserver() {
  *         &#64;Override public void onStart() {
  *             add(Schedulers.single()
- *                 .scheduleDirect(() -> System.out.println("Time!"),
+ *                 .scheduleDirect(() -&gt; System.out.println("Time!"),
  *                     2, TimeUnit.SECONDS));
  *         }
  *         &#64;Override public void onError(Throwable t) {

File: src/main/java/io/reactivex/observers/ResourceMaybeObserver.java
Patch:
@@ -57,10 +57,10 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Maybe.just(1).delay(1, TimeUnit.SECONDS)
- *     .subscribeWith(new ResourceMaybeObserver&lt;Integer>() {
+ *     .subscribeWith(new ResourceMaybeObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             add(Schedulers.single()
- *                 .scheduleDirect(() -> System.out.println("Time!"),
+ *                 .scheduleDirect(() -&gt; System.out.println("Time!"),
  *                     2, TimeUnit.SECONDS));
  *         }
  *         &#64;Override public void onSuccess(Integer t) {

File: src/main/java/io/reactivex/observers/ResourceObserver.java
Patch:
@@ -52,10 +52,10 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Observable.range(1, 5)
- *     .subscribeWith(new ResourceObserver&lt;Integer>() {
+ *     .subscribeWith(new ResourceObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             add(Schedulers.single()
- *                 .scheduleDirect(() -> System.out.println("Time!"),
+ *                 .scheduleDirect(() -&gt; System.out.println("Time!"),
  *                     2, TimeUnit.SECONDS));
  *             request(1);
  *         }

File: src/main/java/io/reactivex/observers/ResourceSingleObserver.java
Patch:
@@ -54,10 +54,10 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Single.just(1).delay(1, TimeUnit.SECONDS)
- *     .subscribeWith(new ResourceSingleObserver&lt;Integer>() {
+ *     .subscribeWith(new ResourceSingleObserver&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             add(Schedulers.single()
- *                 .scheduleDirect(() -> System.out.println("Time!"),
+ *                 .scheduleDirect(() -&gt; System.out.println("Time!"),
  *                     2, TimeUnit.SECONDS));
  *         }
  *         &#64;Override public void onSuccess(Integer t) {

File: src/main/java/io/reactivex/package-info.java
Patch:
@@ -40,7 +40,7 @@
  * <li>Subscriber == IAsyncEnumerator</li>
  * </ul>
  * The Single and Completable reactive base types have no equivalent in Rx.NET as of 3.x.
- * </p>
+ *
  * <p>Services which intend on exposing data asynchronously and wish
  * to allow reactive processing and composition can implement the
  * {@link io.reactivex.Flowable}, {@link io.reactivex.Observable}, {@link io.reactivex.Single}

File: src/main/java/io/reactivex/processors/BehaviorProcessor.java
Patch:
@@ -34,7 +34,6 @@
  * <img width="640" height="460" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.BehaviorProcessor.png" alt="">
  * <p>
  * Example usage:
- * <p>
  * <pre> {@code
 
   // observer will receive all events.

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -40,7 +40,6 @@
  * {@code new} but must be created via the {@link #create()} method.
  *
  * Example usage:
- * <p>
  * <pre> {@code
 
   PublishProcessor<Object> processor = PublishProcessor.create();

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -44,7 +44,6 @@
  *
  * <p>
  * Example usage:
- * <p>
  * <pre> {@code
 
   ReplayProcessor<Object> processor = new ReplayProcessor<T>();

File: src/main/java/io/reactivex/subjects/BehaviorSubject.java
Patch:
@@ -32,7 +32,6 @@
  * <img width="640" height="415" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.BehaviorSubject.png" alt="">
  * <p>
  * Example usage:
- * <p>
  * <pre> {@code
 
   // observer will receive all 4 events (including "default").

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -27,7 +27,6 @@
  * <img width="640" height="405" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.PublishSubject.png" alt="">
  * <p>
  * Example usage:
- * <p>
  * <pre> {@code
 
   PublishSubject<Object> subject = PublishSubject.create();

File: src/main/java/io/reactivex/subjects/ReplaySubject.java
Patch:
@@ -32,7 +32,6 @@
  * <img width="640" height="405" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.ReplaySubject.png" alt="">
  * <p>
  * Example usage:
- * <p>
  * <pre> {@code
 
   ReplaySubject<Object> subject = new ReplaySubject<>();

File: src/main/java/io/reactivex/subjects/Subject.java
Patch:
@@ -37,7 +37,7 @@ public abstract class Subject<T> extends Observable<T> implements Observer<T> {
      * <p>The method is thread-safe.
      * @return true if the subject has reached a terminal state through an error event
      * @see #getThrowable()
-     * &see {@link #hasComplete()}
+     * @see #hasComplete()
      */
     public abstract boolean hasThrowable();
 

File: src/main/java/io/reactivex/subscribers/DefaultSubscriber.java
Patch:
@@ -51,7 +51,7 @@
  *
  * <p>Example<pre><code>
  * Flowable.range(1, 5)
- *     .subscribe(new DefaultSubscriber&lt;Integer>() {
+ *     .subscribe(new DefaultSubscriber&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             System.out.println("Start!");
  *             request(1);

File: src/main/java/io/reactivex/subscribers/DisposableSubscriber.java
Patch:
@@ -50,7 +50,7 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Flowable.range(1, 5)
- *     .subscribeWith(new DisposableSubscriber&lt;Integer>() {
+ *     .subscribeWith(new DisposableSubscriber&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             request(1);
  *         }

File: src/main/java/io/reactivex/subscribers/ResourceSubscriber.java
Patch:
@@ -63,10 +63,10 @@
  * <p>Example<pre><code>
  * Disposable d =
  *     Flowable.range(1, 5)
- *     .subscribeWith(new ResourceSubscriber&lt;Integer>() {
+ *     .subscribeWith(new ResourceSubscriber&lt;Integer&gt;() {
  *         &#64;Override public void onStart() {
  *             add(Schedulers.single()
- *                 .scheduleDirect(() -> System.out.println("Time!"),
+ *                 .scheduleDirect(() -&gt; System.out.println("Time!"),
  *                     2, TimeUnit.SECONDS));
  *             request(1);
  *         }

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -3316,14 +3316,15 @@ public final Maybe<T> onExceptionResumeNext(final MaybeSource<? extends T> next)
         ObjectHelper.requireNonNull(next, "next is null");
         return RxJavaPlugins.onAssembly(new MaybeOnErrorNext<T>(this, Functions.justFunction(next), false));
     }
+
     /**
      * Nulls out references to the upstream producer and downstream MaybeObserver if
      * the sequence is terminated or downstream calls dispose().
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
-     * @return a Maybe which out references to the upstream producer and downstream MaybeObserver if
+     * @return a Maybe which nulls out references to the upstream producer and downstream MaybeObserver if
      * the sequence is terminated or downstream calls dispose()
      */
     @CheckReturnValue

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeDetach.java
Patch:
@@ -69,6 +69,7 @@ public void onSuccess(T value) {
             d = DisposableHelper.DISPOSED;
             MaybeObserver<? super T> a = actual;
             if (a != null) {
+                actual = null;
                 a.onSuccess(value);
             }
         }
@@ -78,6 +79,7 @@ public void onError(Throwable e) {
             d = DisposableHelper.DISPOSED;
             MaybeObserver<? super T> a = actual;
             if (a != null) {
+                actual = null;
                 a.onError(e);
             }
         }
@@ -87,6 +89,7 @@ public void onComplete() {
             d = DisposableHelper.DISPOSED;
             MaybeObserver<? super T> a = actual;
             if (a != null) {
+                actual = null;
                 a.onComplete();
             }
         }

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
Patch:
@@ -137,7 +137,7 @@ public static boolean set(AtomicReference<Subscription> field, Subscription s) {
      * @return true if the operation succeeded, false if the target field was not null.
      */
     public static boolean setOnce(AtomicReference<Subscription> field, Subscription s) {
-        ObjectHelper.requireNonNull(s, "d is null");
+        ObjectHelper.requireNonNull(s, "s is null");
         if (!field.compareAndSet(null, s)) {
             s.cancel();
             if (field.get() != CANCELLED) {

File: src/test/java/io/reactivex/ParamValidationCheckerTest.java
Patch:
@@ -312,7 +312,9 @@ public void checkParallelFlowable() {
 
         // negative time is considered as zero time
         addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class));
+        addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class, Boolean.TYPE));
         addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class, Scheduler.class));
+        addOverride(new ParamOverride(Single.class, 0, ParamMode.ANY, "delay", Long.TYPE, TimeUnit.class, Scheduler.class, Boolean.TYPE));
 
 
         // zero repeat is allowed

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -7261,7 +7261,7 @@ public final Flowable<T> delay(long delay, TimeUnit unit) {
 
     /**
      * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a
-     * specified delay. Error notifications from the source Publisher are not delayed.
+     * specified delay. If {@code delayError} is true, error notifications will also be delayed.
      * <p>
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png" alt="">
      * <dl>
@@ -7318,7 +7318,7 @@ public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {
 
     /**
      * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a
-     * specified delay. Error notifications from the source Publisher are not delayed.
+     * specified delay. If {@code delayError} is true, error notifications will also be delayed.
      * <p>
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png" alt="">
      * <dl>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -6546,7 +6546,7 @@ public final Observable<T> delay(long delay, TimeUnit unit) {
 
     /**
      * Returns an Observable that emits the items emitted by the source ObservableSource shifted forward in time by a
-     * specified delay. Error notifications from the source ObservableSource are not delayed.
+     * specified delay. If {@code delayError} is true, error notifications will also be delayed.
      * <p>
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png" alt="">
      * <dl>
@@ -6597,7 +6597,7 @@ public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler)
 
     /**
      * Returns an Observable that emits the items emitted by the source ObservableSource shifted forward in time by a
-     * specified delay. Error notifications from the source ObservableSource are not delayed.
+     * specified delay. If {@code delayError} is true, error notifications will also be delayed.
      * <p>
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png" alt="">
      * <dl>

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java
Patch:
@@ -24,6 +24,7 @@
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.observers.*;
+import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -129,7 +130,7 @@ public void onSubscribe(Disposable d) {
                     }
                 }
 
-                queue = QueueDrainHelper.createQueue(prefetch);
+                queue = new SpscLinkedArrayQueue<T>(prefetch);
 
                 actual.onSubscribe(this);
             }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java
Patch:
@@ -135,16 +135,14 @@ public void noErrorLoss() throws Exception {
                 @Override
                 public void run() throws Exception {
                     cdl1.countDown();
-                    cdl2.await();
+                    cdl2.await(5, TimeUnit.SECONDS);
                 }
             }).subscribeOn(Schedulers.single()).test();
 
             assertTrue(cdl1.await(5, TimeUnit.SECONDS));
 
             to.cancel();
 
-            cdl2.countDown();
-
             int timeout = 10;
 
             while (timeout-- > 0 && errors.isEmpty()) {

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java
Patch:
@@ -138,7 +138,7 @@ public void noErrorLoss() throws Exception {
                 @Override
                 public Integer call() throws Exception {
                     cdl1.countDown();
-                    cdl2.await();
+                    cdl2.await(5, TimeUnit.SECONDS);
                     return 1;
                 }
             }).subscribeOn(Schedulers.single()).test();
@@ -147,8 +147,6 @@ public Integer call() throws Exception {
 
             to.cancel();
 
-            cdl2.countDown();
-
             int timeout = 10;
 
             while (timeout-- > 0 && errors.isEmpty()) {

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java
Patch:
@@ -134,7 +134,7 @@ public void noErrorLoss() throws Exception {
                 public void run() {
                     cdl1.countDown();
                     try {
-                        cdl2.await();
+                        cdl2.await(5, TimeUnit.SECONDS);
                     } catch (InterruptedException ex) {
                         throw new RuntimeException(ex);
                     }
@@ -145,8 +145,6 @@ public void run() {
 
             to.cancel();
 
-            cdl2.countDown();
-
             int timeout = 10;
 
             while (timeout-- > 0 && errors.isEmpty()) {

File: src/main/java/io/reactivex/schedulers/Schedulers.java
Patch:
@@ -140,10 +140,10 @@ public static Scheduler computation() {
      * <p>
      * This can be used for asynchronously performing blocking IO.
      * <p>
-     * The implementation is backed by a pool of single-threaded {link ScheduledExecutorService} instances
+     * The implementation is backed by a pool of single-threaded {@link ScheduledExecutorService} instances
      * that will try to reuse previoulsy started instances used by the worker
      * returned by {@link io.reactivex.Scheduler#createWorker()} but otherwise will start a new backing
-     * {link ScheduledExecutorService} instance. Note that this scheduler may create an unbounded number
+     * {@link ScheduledExecutorService} instance. Note that this scheduler may create an unbounded number
      * of worker threads that can result in system slowdowns or {@code OutOfMemoryError}. Therefore, for casual uses
      * or when implementing an operator, the Worker instances must be disposed via {@link io.reactivex.Scheduler.Worker#dispose()}.
      * <p>

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
Patch:
@@ -14,14 +14,12 @@
 package io.reactivex.internal.operators.flowable;
 
 import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicReference;
 
 import org.reactivestreams.*;
 
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.subscribers.FullArbiterSubscriber;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.plugins.RxJavaPlugins;

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -10787,7 +10787,7 @@ public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {
      * @param reducer
      *            an accumulator function to be invoked on each item emitted by the source Publisher, the
      *            result of which will be used in the next accumulator call
-     * @return a Flowable that emits a single item that is the result of accumulating the output from the
+     * @return a Single that emits a single item that is the result of accumulating the output from the
      *         items emitted by the source Publisher
      * @see <a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>
      * @see <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>
@@ -10803,7 +10803,7 @@ public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {
     }
 
     /**
-     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source
+     * Returns a Single that applies a specified accumulator function to the first item emitted by a source
      * Publisher and a seed value derived from calling a specified seedSupplier, then feeds the result
      * of that function along with the second item emitted by a Publisher into the same function, and so on until
      * all items have been emitted by the source Publisher, emitting the final result from the final call to your
@@ -10828,7 +10828,7 @@ public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {
      * @param reducer
      *            an accumulator function to be invoked on each item emitted by the source Publisher, the
      *            result of which will be used in the next accumulator call
-     * @return a Flowable that emits a single item that is the result of accumulating the output from the
+     * @return a Single that emits a single item that is the result of accumulating the output from the
      *         items emitted by the source Publisher
      * @see <a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>
      * @see <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -9027,7 +9027,7 @@ public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {
      * @param reducer
      *            an accumulator function to be invoked on each item emitted by the source ObservableSource, the
      *            result of which will be used in the next accumulator call
-     * @return an Observable that emits a single item that is the result of accumulating the output from the
+     * @return a Single that emits a single item that is the result of accumulating the output from the
      *         items emitted by the source ObservableSource
      * @see <a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>
      * @see <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -10745,7 +10745,7 @@ public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {
     }
 
     /**
-     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source
+     * Returns a Single that applies a specified accumulator function to the first item emitted by a source
      * Publisher and a specified seed value, then feeds the result of that function along with the second item
      * emitted by a Publisher into the same function, and so on until all items have been emitted by the
      * source Publisher, emitting the final result from the final call to your function as its sole item.

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -8988,7 +8988,7 @@ public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {
     }
 
     /**
-     * Returns an Observable that applies a specified accumulator function to the first item emitted by a source
+     * Returns a Single that applies a specified accumulator function to the first item emitted by a source
      * ObservableSource and a specified seed value, then feeds the result of that function along with the second item
      * emitted by an ObservableSource into the same function, and so on until all items have been emitted by the
      * source ObservableSource, emitting the final result from the final call to your function as its sole item.

File: src/main/java/io/reactivex/observers/DefaultObserver.java
Patch:
@@ -38,7 +38,7 @@
  * If for some reason this can't be avoided, use {@link io.reactivex.Observable#safeSubscribe(io.reactivex.Observer)}
  * instead of the standard {@code subscribe()} method.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Observable.range(1, 5)
  *     .subscribe(new DefaultObserver&lt;Integer>() {
  *         &#64;Override public void onStart() {
@@ -57,7 +57,7 @@
  *             System.out.println("Done!");
  *         }
  *     });
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/observers/DisposableCompletableObserver.java
Patch:
@@ -33,7 +33,7 @@
  * <p>Implementation of {@link #onStart()}, {@link #onError(Throwable)} and
  * {@link #onComplete()} are not allowed to throw any unchecked exceptions.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Completable.complete().delay(1, TimeUnit.SECONDS)
  *     .subscribeWith(new DisposableMaybeObserver&lt;Integer>() {
@@ -49,7 +49,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  */
 public abstract class DisposableCompletableObserver implements CompletableObserver, Disposable {
     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();

File: src/main/java/io/reactivex/observers/DisposableMaybeObserver.java
Patch:
@@ -37,7 +37,7 @@
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)}, {@link #onError(Throwable)} and
  * {@link #onComplete()} are not allowed to throw any unchecked exceptions.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Maybe.just(1).delay(1, TimeUnit.SECONDS)
  *     .subscribeWith(new DisposableMaybeObserver&lt;Integer>() {
@@ -56,8 +56,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
- *
+ * </code></pre>
  *
  * @param <T> the received value type
  */

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -38,7 +38,7 @@
  * If for some reason this can't be avoided, use {@link io.reactivex.Observable#safeSubscribe(io.reactivex.Observer)}
  * instead of the standard {@code subscribe()} method.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Observable.range(1, 5)
  *     .subscribeWith(new DisposableObserver&lt;Integer>() {
@@ -60,7 +60,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the received value type
  */

File: src/main/java/io/reactivex/observers/DisposableSingleObserver.java
Patch:
@@ -33,7 +33,7 @@
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)} and {@link #onError(Throwable)}
  * are not allowed to throw any unchecked exceptions.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Single.just(1).delay(1, TimeUnit.SECONDS)
  *     .subscribeWith(new DisposableSingleObserver&lt;Integer>() {
@@ -49,7 +49,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the received value type
  */

File: src/main/java/io/reactivex/observers/ResourceCompletableObserver.java
Patch:
@@ -50,7 +50,7 @@
  * <p>Implementation of {@link #onStart()}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Completable.complete().delay(1, TimeUnit.SECONDS)
  *     .subscribeWith(new ResourceCompletableObserver() {
@@ -70,7 +70,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  */
 public abstract class ResourceCompletableObserver implements CompletableObserver, Disposable {
     /** The active subscription. */

File: src/main/java/io/reactivex/observers/ResourceMaybeObserver.java
Patch:
@@ -54,7 +54,7 @@
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Maybe.just(1).delay(1, TimeUnit.SECONDS)
  *     .subscribeWith(new ResourceMaybeObserver&lt;Integer>() {
@@ -78,7 +78,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/observers/ResourceObserver.java
Patch:
@@ -49,7 +49,7 @@
  * If for some reason this can't be avoided, use {@link io.reactivex.Observable#safeSubscribe(io.reactivex.Observer)}
  * instead of the standard {@code subscribe()} method.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Observable.range(1, 5)
  *     .subscribeWith(new ResourceObserver&lt;Integer>() {
@@ -76,7 +76,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/observers/ResourceSingleObserver.java
Patch:
@@ -51,7 +51,7 @@
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)} and {@link #onError(Throwable)}
  * are not allowed to throw any unchecked exceptions.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Single.just(1).delay(1, TimeUnit.SECONDS)
  *     .subscribeWith(new ResourceSingleObserver&lt;Integer>() {
@@ -71,7 +71,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/schedulers/Schedulers.java
Patch:
@@ -313,7 +313,7 @@ public static Scheduler single() {
      * <p>
      * Starting, stopping and restarting this scheduler is not supported (no-op) and the provided
      * executor's lifecycle must be managed externally:
-     * <code><pre>
+     * <pre><code>
      * ExecutorService exec = Executors.newSingleThreadedExecutor();
      * try {
      *     Scheduler scheduler = Schedulers.from(exec);
@@ -325,7 +325,7 @@ public static Scheduler single() {
      * } finally {
      *     exec.shutdown();
      * }
-     * </pre></code>
+     * </code></pre>
      * <p>
      * This type of scheduler is less sensitive to leaking {@link io.reactivex.Scheduler.Worker} instances, although
      * not disposing a worker that has timed/delayed tasks not cancelled by other means may leak resources and/or

File: src/main/java/io/reactivex/subscribers/DefaultSubscriber.java
Patch:
@@ -49,7 +49,7 @@
  * instead of the standard {@code subscribe()} method.
  * @param <T> the value type
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Flowable.range(1, 5)
  *     .subscribe(new DefaultSubscriber&lt;Integer>() {
  *         &#64;Override public void onStart() {
@@ -70,7 +70,7 @@
  *             System.out.println("Done!");
  *         }
  *     });
- * </pre></code>
+ * </code></pre>
  */
 public abstract class DefaultSubscriber<T> implements FlowableSubscriber<T> {
     private Subscription s;

File: src/main/java/io/reactivex/subscribers/DisposableSubscriber.java
Patch:
@@ -47,7 +47,7 @@
  * If for some reason this can't be avoided, use {@link io.reactivex.Flowable#safeSubscribe(org.reactivestreams.Subscriber)}
  * instead of the standard {@code subscribe()} method.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Flowable.range(1, 5)
  *     .subscribeWith(new DisposableSubscriber&lt;Integer>() {
@@ -70,7 +70,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  * @param <T> the received value type.
  */
 public abstract class DisposableSubscriber<T> implements FlowableSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/subscribers/ResourceSubscriber.java
Patch:
@@ -60,7 +60,7 @@
  * If for some reason this can't be avoided, use {@link io.reactivex.Flowable#safeSubscribe(org.reactivestreams.Subscriber)}
  * instead of the standard {@code subscribe()} method.
  *
- * <p>Example<code><pre>
+ * <p>Example<pre><code>
  * Disposable d =
  *     Flowable.range(1, 5)
  *     .subscribeWith(new ResourceSubscriber&lt;Integer>() {
@@ -88,7 +88,7 @@
  *     });
  * // ...
  * d.dispose();
- * </pre></code>
+ * </code></pre>
  *
  * @param <T> the value type
  */

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFilterTest.java
Patch:
@@ -59,7 +59,7 @@ public boolean test(String t1) {
     }
 
     /**
-     * Make sure we are adjusting subscriber.request() for filtered items
+     * Make sure we are adjusting subscriber.request() for filtered items.
      * @throws InterruptedException if the test is interrupted
      * @throws InterruptedException if the test is interrupted
      */
@@ -107,7 +107,7 @@ public void onNext(String t) {
     }
 
     /**
-     * Make sure we are adjusting subscriber.request() for filtered items
+     * Make sure we are adjusting subscriber.request() for filtered items.
      * @throws InterruptedException if the test is interrupted
      */
     @Test(timeout = 500000)

File: src/test/java/io/reactivex/observable/ObservableErrorHandlingTests.java
Patch:
@@ -27,7 +27,7 @@
 public class ObservableErrorHandlingTests {
 
     /**
-     * Test that an error from a user provided Observer.onNext is handled and emitted to the onError
+     * Test that an error from a user provided Observer.onNext is handled and emitted to the onError.
      * @throws InterruptedException if the test is interrupted
      */
     @Test
@@ -63,7 +63,7 @@ public void onNext(Long args) {
 
     /**
      * Test that an error from a user provided Observer.onNext is handled and emitted to the onError
-     * even when done across thread boundaries with observeOn
+     * even when done across thread boundaries with observeOn.
      * @throws InterruptedException if the test is interrupted
      */
     @Test

File: src/test/java/io/reactivex/tck/BaseTck.java
Patch:
@@ -52,7 +52,7 @@ public long maxElementsFromPublisher() {
 
     /**
      * Creates an Iterable with the specified number of elements or an infinite one if
-     * elements > Integer.MAX_VALUE
+     * elements > Integer.MAX_VALUE.
      * @param elements the number of elements to return, Integer.MAX_VALUE means an infinite sequence
      * @return the Iterable
      */

File: src/main/java/io/reactivex/functions/Consumer.java
Patch:
@@ -13,8 +13,6 @@
 
 package io.reactivex.functions;
 
-import io.reactivex.annotations.NonNull;
-
 /**
  * A functional interface (callback) that accepts a single value.
  * @param <T> the value type
@@ -25,5 +23,5 @@ public interface Consumer<T> {
      * @param t the value
      * @throws Exception on error
      */
-    void accept(@NonNull T t) throws Exception;
+    void accept(T t) throws Exception;
 }

File: src/main/java/io/reactivex/processors/AsyncProcessor.java
Patch:
@@ -21,7 +21,8 @@
 import org.reactivestreams.*;
 
 /**
- * A Subject that emits the very last value followed by a completion event or the received error to Subscribers.
+ * Processor that emits the very last value followed by a completion event or the received error
+ * to {@link Subscriber}s.
  *
  * <p>The implementation of onXXX methods are technically thread-safe but non-serialized calls
  * to them may lead to undefined state in the currently subscribed Subscribers.

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeMaxConcurrentTest.java
Patch:
@@ -201,7 +201,7 @@ public void testSimpleAsyncLoop() {
             }
         }
     }
-    @Test(timeout = 10000)
+    @Test(timeout = 30000)
     public void testSimpleAsync() {
         for (int i = 1; i < 50; i++) {
             TestObserver<Integer> ts = new TestObserver<Integer>();
@@ -221,13 +221,13 @@ public void testSimpleAsync() {
             assertEquals(expected, actual);
         }
     }
-    @Test(timeout = 10000)
+    @Test(timeout = 30000)
     public void testSimpleOneLessAsyncLoop() {
         for (int i = 0; i < 200; i++) {
             testSimpleOneLessAsync();
         }
     }
-    @Test(timeout = 10000)
+    @Test(timeout = 30000)
     public void testSimpleOneLessAsync() {
         long t = System.currentTimeMillis();
         for (int i = 2; i < 50; i++) {

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -1641,7 +1641,7 @@ public final Single<T> delay(long time, TimeUnit unit) {
      *
      * @param time the time amount to delay the emission of the success signal
      * @param unit the time unit
-     * @param scheduler the target scheduler to use fro the non-blocking wait and emission
+     * @param scheduler the target scheduler to use for the non-blocking wait and emission
      * @return the new Single instance
      * @since 2.0
      */

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -1633,14 +1633,13 @@ public final Single<T> delay(long time, TimeUnit unit) {
     }
 
     /**
-     * Delays the emission of the success or error signal from the current Single by
-     * the specified amount.
+     * Delays the emission of the success signal from the current Single by the specified amount.
      * <dl>
      * <dt><b>Scheduler:</b></dt>
      * <dd>you specify the {@link Scheduler} where the non-blocking wait and emission happens</dd>
      * </dl>
      *
-     * @param time the time amount to delay the signals
+     * @param time the time amount to delay the emission of the success signal
      * @param unit the time unit
      * @param scheduler the target scheduler to use fro the non-blocking wait and emission
      * @return the new Single instance

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -1807,7 +1807,7 @@ public final Single<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) {
 
     /**
      * Registers an {@link Action} to be called after this Single invokes either onSuccess or onError.
-     * * <p>Note that the {@code doAfterSuccess} action is shared between subscriptions and as such
+     * * <p>Note that the {@code doAfterTerminate} action is shared between subscriptions and as such
      * should be thread-safe.</p>
      * <p>
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterTerminate.png" alt="">

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapIterableObservable.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.internal.observers.BasicIntQueueDisposable;
 
 /**
- * Maps a success value into an Iterable and streams it back as a Flowable.
+ * Maps a success value into an Iterable and streams it back as an Observable.
  *
  * @param <T> the source value type
  * @param <R> the element type of the Iterable

File: src/main/java/io/reactivex/observers/BaseTestConsumer.java
Patch:
@@ -549,7 +549,7 @@ public final U assertValueSequence(Iterable<? extends T> sequence) {
             throw fail("More values received than expected (" + i + ")");
         }
         if (expectedNext) {
-            throw fail("Fever values received than expected (" + i + ")");
+            throw fail("Fewer values received than expected (" + i + ")");
         }
         return (U)this;
     }

File: src/main/java/io/reactivex/functions/Function3.java
Patch:
@@ -19,7 +19,7 @@
  * A functional interface (callback) that computes a value based on multiple input values.
  * @param <T1> the first value type
  * @param <T2> the second value type
- * @param <T3> the second value type
+ * @param <T3> the third value type
  * @param <R> the result type
  */
 public interface Function3<T1, T2, T3, R> {

File: src/main/java/io/reactivex/functions/Function4.java
Patch:
@@ -19,8 +19,8 @@
  * A functional interface (callback) that computes a value based on multiple input values.
  * @param <T1> the first value type
  * @param <T2> the second value type
- * @param <T3> the second value type
- * @param <T4> the second value type
+ * @param <T3> the third value type
+ * @param <T4> the fourth value type
  * @param <R> the result type
  */
 public interface Function4<T1, T2, T3, T4, R> {

File: src/main/java/io/reactivex/functions/Function5.java
Patch:
@@ -19,9 +19,9 @@
  * A functional interface (callback) that computes a value based on multiple input values.
  * @param <T1> the first value type
  * @param <T2> the second value type
- * @param <T3> the second value type
- * @param <T4> the second value type
- * @param <T5> the second value type
+ * @param <T3> the third value type
+ * @param <T4> the fourth value type
+ * @param <T5> the fifth value type
  * @param <R> the result type
  */
 public interface Function5<T1, T2, T3, T4, T5, R> {

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -3116,7 +3116,8 @@ public final Observable<T> toObservable() {
 
     /**
      * Converts this Maybe into a Single instance composing cancellation
-     * through and turning an empty Maybe into a signal of NoSuchElementException.
+     * through and turning an empty Maybe into a Single that emits the given
+     * value through onSuccess.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toSingle} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -14873,15 +14873,15 @@ public final <K, V> Single<Map<K, Collection<V>>> toMultimap(
     }
 
     /**
-     * Converts the current Flowable into a non-backpressured Publisher.
+     * Converts the current Flowable into a non-backpressured {@link Observable}.
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
-     *  <dd>Publishers don't support backpressure thus the current Flowable is consumed in an unbounded
+     *  <dd>Observables don't support backpressure thus the current Flowable is consumed in an unbounded
      *  manner (by requesting Long.MAX_VALUE).</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toObservable} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
-     * @return the new Publisher instance
+     * @return the new Observable instance
      * @since 2.0
      */
     @CheckReturnValue

File: src/main/java/io/reactivex/observers/DefaultObserver.java
Patch:
@@ -17,6 +17,7 @@
 import io.reactivex.annotations.NonNull;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * Abstract base implementation of an {@link io.reactivex.Observer Observer} with support for cancelling a
@@ -30,7 +31,7 @@
  *
  * <p>Like all other consumers, {@code DefaultObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onNext(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -67,7 +68,7 @@ public abstract class DefaultObserver<T> implements Observer<T> {
     private Disposable s;
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.validate(this.s, s)) {
+        if (EndConsumerHelper.validate(this.s, s, getClass())) {
             this.s = s;
             onStart();
         }

File: src/main/java/io/reactivex/observers/DisposableCompletableObserver.java
Patch:
@@ -19,6 +19,7 @@
 import io.reactivex.annotations.NonNull;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link CompletableObserver} that allows asynchronous cancellation by implementing Disposable.
@@ -27,7 +28,7 @@
  *
  * <p>Like all other consumers, {@code DisposableCompletableObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onError(Throwable)} and
  * {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -55,7 +56,7 @@ public abstract class DisposableCompletableObserver implements CompletableObserv
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/DisposableMaybeObserver.java
Patch:
@@ -19,6 +19,7 @@
 import io.reactivex.annotations.NonNull;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link MaybeObserver} that allows asynchronous cancellation by implementing Disposable.
@@ -31,7 +32,7 @@
  *
  * <p>Like all other consumers, {@code DisposableMaybeObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)}, {@link #onError(Throwable)} and
  * {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -66,7 +67,7 @@ public abstract class DisposableMaybeObserver<T> implements MaybeObserver<T>, Di
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -19,6 +19,7 @@
 import io.reactivex.annotations.NonNull;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link Observer} that allows asynchronous cancellation by implementing Disposable.
@@ -30,7 +31,7 @@
  *
  * <p>Like all other consumers, {@code DisposableObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onNext(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -69,7 +70,7 @@ public abstract class DisposableObserver<T> implements Observer<T>, Disposable {
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/DisposableSingleObserver.java
Patch:
@@ -19,6 +19,7 @@
 import io.reactivex.annotations.NonNull;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link SingleObserver} that allows asynchronous cancellation by implementing Disposable.
@@ -27,7 +28,7 @@
  *
  * <p>Like all other consumers, {@code DisposableSingleObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)} and {@link #onError(Throwable)}
  * are not allowed to throw any unchecked exceptions.
@@ -58,7 +59,7 @@ public abstract class DisposableSingleObserver<T> implements SingleObserver<T>,
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/ResourceCompletableObserver.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link CompletableObserver} that allows asynchronous cancellation of its subscription and associated resources.
@@ -44,7 +45,7 @@
  *
  * <p>Like all other consumers, {@code ResourceCompletableObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -92,7 +93,7 @@ public final void add(@NonNull Disposable resource) {
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/ResourceMaybeObserver.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link MaybeObserver} that allows asynchronous cancellation of its subscription and associated resources.
@@ -48,7 +49,7 @@
  *
  * <p>Like all other consumers, {@code ResourceMaybeObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -102,7 +103,7 @@ public final void add(@NonNull Disposable resource) {
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/ResourceObserver.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link Observer} that allows asynchronous cancellation of its subscription and associated resources.
@@ -41,7 +42,7 @@
  *
  * <p>Like all other consumers, {@code ResourceObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onNext(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -100,7 +101,7 @@ public final void add(@NonNull Disposable resource) {
 
     @Override
     public final void onSubscribe(Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/observers/ResourceSingleObserver.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract {@link SingleObserver} that allows asynchronous cancellation of its subscription
@@ -45,7 +46,7 @@
  *
  * <p>Like all other consumers, {@code ResourceSingleObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Disposable already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onSuccess(Object)} and {@link #onError(Throwable)}
  * are not allowed to throw any unchecked exceptions.
@@ -95,7 +96,7 @@ public final void add(@NonNull Disposable resource) {
 
     @Override
     public final void onSubscribe(@NonNull Disposable s) {
-        if (DisposableHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/main/java/io/reactivex/subscribers/DefaultSubscriber.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.reactivex.FlowableSubscriber;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * Abstract base implementation of a {@link org.reactivestreams.Subscriber Subscriber} with
@@ -40,7 +41,7 @@
  *
  * <p>Like all other consumers, {@code DefaultSubscriber} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Subscription already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onNext(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -78,7 +79,7 @@ public abstract class DefaultSubscriber<T> implements FlowableSubscriber<T> {
     private Subscription s;
     @Override
     public final void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validate(this.s, s)) {
+        if (EndConsumerHelper.validate(this.s, s, getClass())) {
             this.s = s;
             onStart();
         }

File: src/main/java/io/reactivex/subscribers/DisposableSubscriber.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.FlowableSubscriber;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.EndConsumerHelper;
 
 /**
  * An abstract Subscriber that allows asynchronous, external cancellation by implementing Disposable.
@@ -39,7 +40,7 @@
  *
  * <p>Like all other consumers, {@code DisposableSubscriber} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
- * {@link IllegalStateException} with message {@code "Subscription already set!"}.
+ * {@link IllegalStateException} with message {@code "It is not allowed to subscribe with a(n) <class name> multiple times."}.
  *
  * <p>Implementation of {@link #onStart()}, {@link #onNext(Object)}, {@link #onError(Throwable)}
  * and {@link #onComplete()} are not allowed to throw any unchecked exceptions.
@@ -77,7 +78,7 @@ public abstract class DisposableSubscriber<T> implements FlowableSubscriber<T>,
 
     @Override
     public final void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.setOnce(this.s, s)) {
+        if (EndConsumerHelper.setOnce(this.s, s, getClass())) {
             onStart();
         }
     }

File: src/test/java/io/reactivex/observers/DisposableCompletableObserverTest.java
Patch:
@@ -21,6 +21,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.observers.DisposableCompletableObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -88,7 +89,7 @@ public void startOnce() {
 
             assertEquals(1, tc.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/DisposableMaybeObserverTest.java
Patch:
@@ -21,6 +21,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.observers.DisposableMaybeObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -96,7 +97,7 @@ public void startOnce() {
 
             assertEquals(1, tc.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/DisposableObserverTest.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.Observable;
 import io.reactivex.TestHelper;
 import io.reactivex.disposables.*;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public class DisposableObserverTest {
@@ -94,7 +95,7 @@ public void startOnce() {
 
             assertEquals(1, tc.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/DisposableSingleObserverTest.java
Patch:
@@ -21,6 +21,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.observers.DisposableSingleObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -88,7 +89,7 @@ public void startOnce() {
 
             assertEquals(1, tc.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/ResourceCompletableObserverTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 import static org.junit.Assert.assertEquals;
@@ -180,7 +181,7 @@ public void startOnce() {
 
             assertEquals(1, rco.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(rco.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/ResourceMaybeObserverTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 import static org.junit.Assert.assertEquals;
@@ -231,7 +232,7 @@ public void startOnce() {
 
             assertEquals(1, rmo.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(rmo.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/ResourceObserverTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 import static org.junit.Assert.assertEquals;
@@ -190,7 +191,7 @@ public void startOnce() {
 
             assertEquals(1, tc.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/ResourceSingleObserverTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 import static org.junit.Assert.assertEquals;
@@ -183,7 +184,7 @@ public void startOnce() {
 
             assertEquals(1, rso.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Disposable already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(rso.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/subscribers/DisposableSubscriberTest.java
Patch:
@@ -21,6 +21,7 @@
 
 import io.reactivex.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.EndConsumerHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public class DisposableSubscriberTest {
@@ -93,7 +94,7 @@ public void startOnce() {
 
             assertEquals(1, tc.start);
 
-            TestHelper.assertError(error, 0, IllegalStateException.class, "Subscription already set!");
+            TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName()));
         } finally {
             RxJavaPlugins.reset();
         }

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2096,7 +2096,7 @@ public final <U> Observable<U> flattenAsObservable(final Function<? super T, ? e
 
     /**
      * Returns an Observable that is based on applying a specified function to the item emitted by the source Single,
-     * where that function returns a SingleSource.
+     * where that function returns an ObservableSource.
      * <p>
      * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapObservable.png" alt="">
      * <dl>

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2097,7 +2097,7 @@ public final <U> Observable<U> flattenAsObservable(final Function<? super T, ? e
      * Returns an Observable that is based on applying a specified function to the item emitted by the source Single,
      * where that function returns a SingleSource.
      * <p>
-     * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.png" alt="">
+     * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapObservable.png" alt="">
      * <dl>
      * <dt><b>Scheduler:</b></dt>
      * <dd>{@code flatMapObservable} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/flowables/GroupedFlowable.java
Patch:
@@ -31,7 +31,7 @@
  * @see <a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX documentation: GroupBy</a>
  */
 public abstract class GroupedFlowable<K, T> extends Flowable<T> {
-    
+
     final K key;
 
     /**

File: src/main/java/io/reactivex/observables/GroupedObservable.java
Patch:
@@ -31,7 +31,7 @@
  * @see <a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX documentation: GroupBy</a>
  */
 public abstract class GroupedObservable<K, T> extends Observable<T> {
-    
+
     final K key;
 
     /**

File: src/main/java/io/reactivex/observers/DisposableMaybeObserver.java
Patch:
@@ -61,7 +61,7 @@
  * @param <T> the received value type
  */
 public abstract class DisposableMaybeObserver<T> implements MaybeObserver<T>, Disposable {
-    
+
     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();
 
     @Override

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -64,7 +64,7 @@
  * @param <T> the received value type
  */
 public abstract class DisposableObserver<T> implements Observer<T>, Disposable {
-   
+
     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();
 
     @Override

File: src/main/java/io/reactivex/observers/DisposableSingleObserver.java
Patch:
@@ -53,7 +53,7 @@
  * @param <T> the received value type
  */
 public abstract class DisposableSingleObserver<T> implements SingleObserver<T>, Disposable {
-    
+
     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();
 
     @Override

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -27,7 +27,7 @@
  * <p>Use the public {@link #dispose()} method to dispose the sequence from within an
  * {@code onNext} implementation.
  *
- * <p>Like all other consumers, {@code DefaultObserver} can be subscribed only once.
+ * <p>Like all other consumers, {@code DisposableObserver} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
  * {@link IllegalStateException} with message {@code "Disposable already set!"}.
  *

File: src/main/java/io/reactivex/subscribers/DisposableSubscriber.java
Patch:
@@ -37,7 +37,7 @@
  * Calling {@link #request(long)} inside {@link #onNext(Object)} can happen at any time
  * because by design, {@code onNext} calls from upstream are non-reentrant and non-overlapping.
  *
- * <p>Like all other consumers, {@code DefaultSubscriber} can be subscribed only once.
+ * <p>Like all other consumers, {@code DisposableSubscriber} can be subscribed only once.
  * Any subsequent attempt to subscribe it to a new source will yield an
  * {@link IllegalStateException} with message {@code "Subscription already set!"}.
  *

File: src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java
Patch:
@@ -52,8 +52,7 @@ public void onComplete() {
             onComplete.run();
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            onError(ex);
-            return;
+            RxJavaPlugins.onError(ex);
         }
         lazySet(DisposableHelper.DISPOSED);
     }

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -24,7 +24,7 @@
  *
  * <p>All pre-implemented final methods are thread-safe.
  *
- * <p>Use the protected {@link #dispose()} to dispose the sequence from within an
+ * <p>Use the public {@link #dispose()} method to dispose the sequence from within an
  * {@code onNext} implementation.
  *
  * <p>Like all other consumers, {@code DefaultObserver} can be subscribed only once.

File: src/main/java/io/reactivex/observers/ResourceCompletableObserver.java
Patch:
@@ -29,7 +29,7 @@
  * <p>Override the protected {@link #onStart()} to perform initialization when this
  * {@code ResourceCompletableObserver} is subscribed to a source.
  *
- * <p>Use the protected {@link #dispose()} to dispose the sequence externally and release
+ * <p>Use the public {@link #dispose()} method to dispose the sequence externally and release
  * all resources.
  *
  * <p>To release the associated resources, one has to call {@link #dispose()}

File: src/main/java/io/reactivex/observers/ResourceMaybeObserver.java
Patch:
@@ -33,7 +33,7 @@
  * <p>Override the protected {@link #onStart()} to perform initialization when this
  * {@code ResourceMaybeObserver} is subscribed to a source.
  *
- * <p>Use the protected {@link #dispose()} to dispose the sequence externally and release
+ * <p>Use the public {@link #dispose()} method to dispose the sequence externally and release
  * all resources.
  *
  * <p>To release the associated resources, one has to call {@link #dispose()}

File: src/main/java/io/reactivex/observers/ResourceSingleObserver.java
Patch:
@@ -30,7 +30,7 @@
  * <p>Override the protected {@link #onStart()} to perform initialization when this
  * {@code ResourceSingleObserver} is subscribed to a source.
  *
- * <p>Use the protected {@link #dispose()} to dispose the sequence externally and release
+ * <p>Use the public {@link #dispose()} method to dispose the sequence externally and release
  * all resources.
  *
  * <p>To release the associated resources, one has to call {@link #dispose()}

File: src/test/java/io/reactivex/schedulers/TimedTest.java
Patch:
@@ -84,7 +84,7 @@ public void toStringOf() {
 
         assertEquals("Timed[time=5, unit=SECONDS, value=1]", t1.toString());
     }
-    
+
     @Test(expected = NullPointerException.class)
     public void timeUnitNullFail() throws Exception {
         new Timed<Integer>(1, 5, null);

File: src/main/java/io/reactivex/internal/functions/Functions.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.schedulers.Timed;
 
 /**
- * Utility methods to convert the Function3..Function9 instances to Function of Object array.
+ * Utility methods to convert the BiFunction, Function3..Function9 instances to Function of Object array.
  */
 public final class Functions {
 

File: src/main/java/io/reactivex/internal/schedulers/AbstractDirectTask.java
Patch:
@@ -40,7 +40,7 @@ abstract class AbstractDirectTask
 
     protected static final FutureTask<Void> DISPOSED = new FutureTask<Void>(Functions.EMPTY_RUNNABLE, null);
 
-    public AbstractDirectTask(Runnable runnable) {
+    AbstractDirectTask(Runnable runnable) {
         this.runnable = runnable;
     }
 

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -54,7 +54,7 @@ public final class UnicastSubject<T> extends Subject<T> {
     /** The optional callback when the Subject gets cancelled or terminates. */
     final AtomicReference<Runnable> onTerminate;
 
-    /** deliver onNext events before error event */
+    /** deliver onNext events before error event. */
     final boolean delayError;
 
     /** Indicates the single observer has cancelled. */

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -2696,7 +2696,7 @@ public final <U, R> Maybe<R> flatMap(Function<? super T, ? extends MaybeSource<?
      * Returns a Flowable that merges each item emitted by the source Maybe with the values in an
      * Iterable corresponding to that item that is generated by a selector.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png" alt="">
+     * <img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator honors backpressure from downstream.</dd>
@@ -2723,7 +2723,7 @@ public final <U> Flowable<U> flattenAsFlowable(final Function<? super T, ? exten
     /**
      * Returns an Observable that maps a success value into an Iterable and emits its items.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png" alt="">
+     * <img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsObservable.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code flattenAsObservable} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2045,7 +2045,7 @@ public final <R> Flowable<R> flatMapPublisher(Function<? super T, ? extends Publ
      * Returns a Flowable that merges each item emitted by the source Single with the values in an
      * Iterable corresponding to that item that is generated by a selector.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png" alt="">
+     * <img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png" alt="">
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The operator honors backpressure from downstream.</dd>
@@ -2072,7 +2072,7 @@ public final <U> Flowable<U> flattenAsFlowable(final Function<? super T, ? exten
     /**
      * Returns an Observable that maps a success value into an Iterable and emits its items.
      * <p>
-     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png" alt="">
+     * <img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsObservable.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code flattenAsObservable} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -37,6 +37,8 @@
  * will receive an IllegalStateException if this Processor hasn't terminated yet,
  * or the Subscribers receive the terminal event (error or completion) if this
  * Processor has terminated.
+ * <p>
+ * <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastProcessor.png" alt="">
  *
  * @param <T> the value type received and emitted by this Processor subclass
  * @since 2.0

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -37,6 +37,8 @@
  * will receive an IllegalStateException if this Subject hasn't terminated yet,
  * or the Subscribers receive the terminal event (error or completion) if this
  * Subject has terminated.
+ * <p>
+ * <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastSubject.png" alt="">
  *
  * @param <T> the value type received and emitted by this Subject subclass
  * @since 2.0

File: src/main/java/io/reactivex/parallel/ParallelFlowable.java
Patch:
@@ -32,7 +32,7 @@
  * Abstract base class for Parallel publishers that take an array of Subscribers.
  * <p>
  * Use {@code from()} to start processing a regular Publisher in 'rails'.
- * Use {@code runOn()} to introduce where each 'rail' shoud run on thread-vise.
+ * Use {@code runOn()} to introduce where each 'rail' should run on thread-vise.
  * Use {@code sequential()} to merge the sources back into a single Flowable.
  *
  * @param <T> the value type

File: src/main/java/io/reactivex/observables/ConnectableObservable.java
Patch:
@@ -68,7 +68,7 @@ public final Disposable connect() {
      * Returns an {@code Observable} that stays connected to this {@code ConnectableObservable} as long as there
      * is at least one subscription to this {@code ConnectableObservable}.
      *
-     * @return a {@link Flowable}
+     * @return an {@link Observable}
      * @see <a href="http://reactivex.io/documentation/operators/refcount.html">ReactiveX documentation: RefCount</a>
      */
     public Observable<T> refCount() {

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -6789,7 +6789,7 @@ public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publis
      * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be
      *               eagerly concatenated
      * @param maxConcurrency the maximum number of concurrent subscribed Publishers
-     * @param prefetch hints about the number of expected source sequence values
+     * @param prefetch hints about the number of expected values from each inner Publisher, must be positive
      * @return the new Publisher instance with the specified concatenation behavior
      * @since 2.0
      */

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -6082,7 +6082,7 @@ public final <R> Observable<R> concatMapEager(Function<? super T, ? extends Obse
      * @param mapper the function that maps a sequence of values into a sequence of ObservableSources that will be
      *               eagerly concatenated
      * @param maxConcurrency the maximum number of concurrent subscribed ObservableSources
-     * @param prefetch hints about the number of expected source sequence values
+     * @param prefetch hints about the number of expected values from each inner ObservableSource, must be positive
      * @return the new ObservableSource instance with the specified concatenation behavior
      * @since 2.0
      */

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
Patch:
@@ -542,12 +542,12 @@ public Flowable<Integer> apply(Integer t) {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testInvalidCapacityHint() {
+    public void testInvalidMaxConcurrent() {
         Flowable.just(1).concatMapEager(toJust, 0, Flowable.bufferSize());
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testInvalidMaxConcurrent() {
+    public void testInvalidCapacityHint() {
         Flowable.just(1).concatMapEager(toJust, Flowable.bufferSize(), 0);
     }
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java
Patch:
@@ -509,12 +509,12 @@ public Observable<Integer> apply(Integer t) {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testInvalidCapacityHint() {
+    public void testInvalidMaxConcurrent() {
         Observable.just(1).concatMapEager(toJust, 0, Observable.bufferSize());
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testInvalidMaxConcurrent() {
+    public void testInvalidCapacityHint() {
         Observable.just(1).concatMapEager(toJust, Observable.bufferSize(), 0);
     }
 

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -929,6 +929,7 @@ public final void blockingAwait() {
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
     public final boolean blockingAwait(long timeout, TimeUnit unit) {
+        ObjectHelper.requireNonNull(unit, "unit is null");
         BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();
         subscribe(observer);
         return observer.blockingAwait(timeout, unit);

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -118,6 +118,9 @@ public TestSubscriber(Subscriber<? super T> actual) {
      */
     public TestSubscriber(Subscriber<? super T> actual, long initialRequest) {
         super();
+        if (initialRequest < 0) {
+            throw new IllegalArgumentException("Negative initial request not allowed");
+        }
         this.actual = actual;
         this.subscription = new AtomicReference<Subscription>();
         this.missedRequested = new AtomicLong(initialRequest);

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -2427,8 +2427,8 @@ public void toSortedListNull() {
         just1.toSortedList(null);
     }
 
-    @Test
-    public void toMapKeyNullAllowed() {
+    @Test(expected = NullPointerException.class)
+    public void toMapKeyNull() {
         just1.toMap(null);
     }
 

File: src/main/java/io/reactivex/internal/functions/Functions.java
Patch:
@@ -33,7 +33,6 @@ private Functions() {
         throw new IllegalStateException("No instances!");
     }
 
-    @SuppressWarnings("unchecked")
     public static <T1, T2, R> Function<Object[], R> toFunction(final BiFunction<? super T1, ? super T2, ? extends R> f) {
         ObjectHelper.requireNonNull(f, "f is null");
         return new Array2Func<T1, T2, R>(f);
@@ -521,12 +520,13 @@ static final class Array2Func<T1, T2, R> implements Function<Object[], R> {
             this.f = f;
         }
 
+        @SuppressWarnings("unchecked")
         @Override
         public R apply(Object[] a) throws Exception {
             if (a.length != 2) {
                 throw new IllegalArgumentException("Array of size 2 expected but got " + a.length);
             }
-            return ((BiFunction<Object, Object, R>) f).apply(a[0], a[1]);
+            return f.apply((T1)a[0], (T2)a[1]);
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java
Patch:
@@ -48,7 +48,7 @@ protected void subscribeActual(final CompletableObserver s) {
     final class Delay implements CompletableObserver {
 
         private final CompositeDisposable set;
-        private final CompletableObserver s;
+        final CompletableObserver s;
 
         Delay(CompositeDisposable set, CompletableObserver s) {
             this.set = set;

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -57,7 +57,7 @@ final class CompletableObserverImplementation implements CompletableObserver, Di
 
         Disposable d;
 
-        private CompletableObserverImplementation(CompletableObserver actual) {
+        CompletableObserverImplementation(CompletableObserver actual) {
             this.actual = actual;
         }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java
Patch:
@@ -43,8 +43,8 @@ protected void subscribeActual(final CompletableObserver s) {
 
     final class ResumeNext implements CompletableObserver {
 
-        private final CompletableObserver s;
-        private final SequentialDisposable sd;
+        final CompletableObserver s;
+        final SequentialDisposable sd;
 
         ResumeNext(CompletableObserver s, SequentialDisposable sd) {
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java
Patch:
@@ -90,8 +90,8 @@ public void onComplete() {
 
     final class DisposeTask implements Runnable {
         private final AtomicBoolean once;
-        private final CompositeDisposable set;
-        private final CompletableObserver s;
+        final CompositeDisposable set;
+        final CompletableObserver s;
 
         DisposeTask(AtomicBoolean once, CompositeDisposable set, CompletableObserver s) {
             this.once = once;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java
Patch:
@@ -44,8 +44,8 @@ public void subscribeActual(final Subscriber<? super T> child) {
     }
 
     final class DelaySubscriber implements FlowableSubscriber<U> {
-        private final SubscriptionArbiter serial;
-        private final Subscriber<? super T> child;
+        final SubscriptionArbiter serial;
+        final Subscriber<? super T> child;
         boolean done;
 
         DelaySubscriber(SubscriptionArbiter serial, Subscriber<? super T> child) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -1256,7 +1256,7 @@ public void subscribe(Subscriber<? super T> child) {
         }
     }
 
-    static final class DefaultUnboundedFactory implements Callable {
+    static final class DefaultUnboundedFactory implements Callable<Object> {
         @Override
         public Object call() {
             return new UnboundedReplayBuffer<Object>(16);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java
Patch:
@@ -40,7 +40,7 @@ protected void subscribeActual(Subscriber<? super R> s) {
 
         serial.onSubscribe(wlf);
 
-        other.subscribe(new FlowableWithLatestSubscriber<U>(wlf));
+        other.subscribe(new FlowableWithLatestSubscriber(wlf));
 
         source.subscribe(wlf);
     }
@@ -117,7 +117,7 @@ public void otherError(Throwable e) {
         }
     }
 
-    final class FlowableWithLatestSubscriber<U> implements FlowableSubscriber<U> {
+    final class FlowableWithLatestSubscriber implements FlowableSubscriber<U> {
         private final WithLatestFromSubscriber<T, U, R> wlf;
 
         FlowableWithLatestSubscriber(WithLatestFromSubscriber<T, U, R> wlf) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDelaySubscriptionOther.java
Patch:
@@ -44,8 +44,8 @@ public void subscribeActual(final Observer<? super T> child) {
     }
 
     final class DelayObserver implements Observer<U> {
-        private final SequentialDisposable serial;
-        private final Observer<? super T> child;
+        final SequentialDisposable serial;
+        final Observer<? super T> child;
         boolean done;
 
         DelayObserver(SequentialDisposable serial, Observer<? super T> child) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
Patch:
@@ -892,9 +892,9 @@ Node getHead() {
         }
     }
 
-    static final class UnBoundedFactory implements BufferSupplier {
+    static final class UnBoundedFactory implements BufferSupplier<Object> {
         @Override
-        public ReplayBuffer call() {
+        public ReplayBuffer<Object> call() {
             return new UnboundedReplayBuffer<Object>(16);
         }
     }
@@ -1027,7 +1027,7 @@ protected void subscribeActual(Observer<? super R> child) {
 
             observable.subscribe(srw);
 
-            co.connect(new DisposeConsumer(srw));
+            co.connect(new DisposeConsumer<R>(srw));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleDelay.java
Patch:
@@ -44,7 +44,7 @@ protected void subscribeActual(final SingleObserver<? super T> s) {
 
     final class Delay implements SingleObserver<T> {
         private final SequentialDisposable sd;
-        private final SingleObserver<? super T> s;
+        final SingleObserver<? super T> s;
 
         Delay(SequentialDisposable sd, SingleObserver<? super T> s) {
             this.sd = sd;

File: src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java
Patch:
@@ -58,8 +58,8 @@ protected void subscribeActual(final SingleObserver<? super T> s) {
 
     final class TimeoutDispose implements Runnable {
         private final AtomicBoolean once;
-        private final CompositeDisposable set;
-        private final SingleObserver<? super T> s;
+        final CompositeDisposable set;
+        final SingleObserver<? super T> s;
 
         TimeoutDispose(AtomicBoolean once, CompositeDisposable set, SingleObserver<? super T> s) {
             this.once = once;

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -10894,7 +10894,7 @@ public final <R> Observable<R> switchMap(Function<? super T, ? extends Observabl
     public final <R> Observable<R> switchMapSingle(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {
         return ObservableInternalHelper.switchMapSingle(this, mapper);
     }
-    
+
     /**
      * Returns a new ObservableSource by applying a function that you supply to each item emitted by the source
      * ObservableSource that returns a SingleSource, and then emitting the item emitted by the most recently emitted
@@ -10925,7 +10925,7 @@ public final <R> Observable<R> switchMapSingle(@NonNull Function<? super T, ? ex
     public final <R> Observable<R> switchMapSingleDelayError(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {
         return ObservableInternalHelper.switchMapSingleDelayError(this, mapper);
     }
-    
+
     /**
      * Returns a new ObservableSource by applying a function that you supply to each item emitted by the source
      * ObservableSource that returns an ObservableSource, and then emitting the items emitted by the most recently emitted

File: src/main/java/io/reactivex/internal/observers/LambdaObserver.java
Patch:
@@ -47,6 +47,7 @@ public void onSubscribe(Disposable s) {
                 onSubscribe.accept(this);
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
+                s.dispose();
                 onError(ex);
             }
         }
@@ -59,6 +60,7 @@ public void onNext(T t) {
                 onNext.accept(t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
+                get().dispose();
                 onError(e);
             }
         }

File: src/main/java/io/reactivex/internal/observers/ConsumerSingleObserver.java
Patch:
@@ -40,6 +40,7 @@ public ConsumerSingleObserver(Consumer<? super T> onSuccess, Consumer<? super Th
 
     @Override
     public void onError(Throwable e) {
+        lazySet(DisposableHelper.DISPOSED);
         try {
             onError.accept(e);
         } catch (Throwable ex) {
@@ -55,6 +56,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void onSuccess(T value) {
+        lazySet(DisposableHelper.DISPOSED);
         try {
             onSuccess.accept(value);
         } catch (Throwable ex) {

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java
Patch:
@@ -27,11 +27,11 @@
 import io.reactivex.internal.util.*;
 
 public final class BlockingFlowableIterable<T> implements Iterable<T> {
-    final Flowable<? extends T> source;
+    final Flowable<T> source;
 
     final int bufferSize;
 
-    public BlockingFlowableIterable(Flowable<? extends T> source, int bufferSize) {
+    public BlockingFlowableIterable(Flowable<T> source, int bufferSize) {
         this.source = source;
         this.bufferSize = bufferSize;
     }

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -29,11 +29,11 @@
  */
 public final class BlockingFlowableMostRecent<T> implements Iterable<T> {
 
-    final Flowable<? extends T> source;
+    final Flowable<T> source;
 
     final T initialValue;
 
-    public BlockingFlowableMostRecent(Flowable<? extends T> source, T initialValue) {
+    public BlockingFlowableMostRecent(Flowable<T> source, T initialValue) {
         this.source = source;
         this.initialValue = initialValue;
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
Patch:
@@ -93,7 +93,7 @@ protected void subscribeActual(Subscriber<? super T> t) {
      */
     static final class CacheState<T> extends LinkedArrayList implements FlowableSubscriber<T> {
         /** The source observable to connect to. */
-        final Flowable<? extends T> source;
+        final Flowable<T> source;
         /** Holds onto the subscriber connected to source. */
         final AtomicReference<Subscription> connection = new AtomicReference<Subscription>();
         /** Guarded by connection (not this). */
@@ -114,7 +114,7 @@ static final class CacheState<T> extends LinkedArrayList implements FlowableSubs
         boolean sourceDone;
 
         @SuppressWarnings("unchecked")
-        CacheState(Flowable<? extends T> source, int capacityHint) {
+        CacheState(Flowable<T> source, int capacityHint) {
             super(capacityHint);
             this.source = source;
             this.subscribers = new AtomicReference<ReplaySubscription<T>[]>(EMPTY);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -32,7 +32,7 @@
  *            the value type
  */
 public final class FlowableRefCount<T> extends AbstractFlowableWithUpstream<T, T> {
-    final ConnectableFlowable<? extends T> source;
+    final ConnectableFlowable<T> source;
     volatile CompositeDisposable baseDisposable = new CompositeDisposable();
     final AtomicInteger subscriptionCount = new AtomicInteger();
 

File: src/test/java/io/reactivex/TestHelper.java
Patch:
@@ -644,7 +644,7 @@ public static void doubleOnSubscribe(MaybeObserver<?> subscriber) {
      * isCancelled properly before and after calling dispose.
      * @param source the source to test
      */
-    public static void checkDisposed(Flowable<?> source) {
+    public static <T> void checkDisposed(Flowable<T> source) {
         final TestSubscriber<Object> ts = new TestSubscriber<Object>(0L);
         source.subscribe(new FlowableSubscriber<Object>() {
             @Override

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1441,7 +1441,7 @@ public final Completable repeatUntil(BooleanSupplier stop) {
      */
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<Object>> handler) {
+    public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {
         return fromPublisher(toFlowable().repeatWhen(handler));
     }
 
@@ -1526,7 +1526,7 @@ public final Completable retry(Predicate<? super Throwable> predicate) {
      */
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {
+    public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {
         return fromPublisher(toFlowable().retryWhen(handler));
     }
 

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2467,7 +2467,7 @@ public final Flowable<T> repeat(long times) {
     @BackpressureSupport(BackpressureKind.FULL)
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<Object>> handler) {
+    public final Flowable<T> repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {
         return toFlowable().repeatWhen(handler);
     }
 
@@ -2577,7 +2577,7 @@ public final Single<T> retry(Predicate<? super Throwable> predicate) {
      */
     @CheckReturnValue
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {
+    public final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {
         return toSingle(toFlowable().retryWhen(handler));
     }
 

File: src/test/java/io/reactivex/parallel/ParallelPeekTest.java
Patch:
@@ -185,7 +185,9 @@ public void run() throws Exception {
             assertFalse(errors.isEmpty());
 
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
+                Throwable exc = ex.getCause();
+                assertTrue(ex.toString(), exc instanceof TestException
+                        || exc instanceof IOException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
Patch:
@@ -496,6 +496,8 @@ void drainLoop() {
                     if (isHolder) {
                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;
                         if (producerIndex == consumerIndexHolder.index) {
+                            w.onComplete();
+
                             w = UnicastProcessor.<T>create(bufferSize);
                             window = w;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
Patch:
@@ -439,6 +439,8 @@ void drainLoop() {
                     if (isHolder) {
                         ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;
                         if (producerIndex == consumerIndexHolder.index) {
+                            w.onComplete();
+
                             w = UnicastSubject.create(bufferSize);
                             window = w;
 

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java
Patch:
@@ -114,9 +114,10 @@ void drain() {
 
             AtomicReference<Object> c = current;
             Subscriber<? super T> a = actual;
+            Disposable cancelled = disposables;
 
             for (;;) {
-                if (disposables.isDisposed()) {
+                if (cancelled.isDisposed()) {
                     c.lazySet(null);
                     return;
                 }
@@ -141,7 +142,7 @@ void drain() {
                         c.lazySet(null);
                     }
 
-                    if (goNextSource) {
+                    if (goNextSource && !cancelled.isDisposed()) {
                         int i = index;
                         if (i == sources.length) {
                             a.onComplete();

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayDelayError.java
Patch:
@@ -124,9 +124,10 @@ void drain() {
 
             AtomicReference<Object> c = current;
             Subscriber<? super T> a = actual;
+            Disposable cancelled = disposables;
 
             for (;;) {
-                if (disposables.isDisposed()) {
+                if (cancelled.isDisposed()) {
                     c.lazySet(null);
                     return;
                 }
@@ -151,7 +152,7 @@ void drain() {
                         c.lazySet(null);
                     }
 
-                    if (goNextSource) {
+                    if (goNextSource && !cancelled.isDisposed()) {
                         int i = index;
                         if (i == sources.length) {
                             Throwable ex = errors.get();

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatIterable.java
Patch:
@@ -126,9 +126,10 @@ void drain() {
 
             AtomicReference<Object> c = current;
             Subscriber<? super T> a = actual;
+            Disposable cancelled = disposables;
 
             for (;;) {
-                if (disposables.isDisposed()) {
+                if (cancelled.isDisposed()) {
                     c.lazySet(null);
                     return;
                 }
@@ -153,7 +154,7 @@ void drain() {
                         c.lazySet(null);
                     }
 
-                    if (goNextSource) {
+                    if (goNextSource && !cancelled.isDisposed()) {
                         boolean b;
 
                         try {

File: src/test/java/io/reactivex/XFlatMapTest.java
Patch:
@@ -37,7 +37,7 @@ public class XFlatMapTest {
     void sleep() throws Exception {
         cb.await();
         try {
-            Thread.sleep(1000);
+            Thread.sleep(5000);
         } catch (InterruptedException ex) {
             // ignored here
         }

File: src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.ProtocolViolationException;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -152,7 +153,7 @@ public static boolean validate(Disposable current, Disposable next) {
      * Reports that the disposable is already set to the RxJavaPlugins error handler.
      */
     public static void reportDisposableSet() {
-        RxJavaPlugins.onError(new IllegalStateException("Disposable already set!"));
+        RxJavaPlugins.onError(new ProtocolViolationException("Disposable already set!"));
     }
 
     /**

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscription;
 
+import io.reactivex.exceptions.ProtocolViolationException;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -67,7 +68,7 @@ public static boolean validate(Subscription current, Subscription next) {
      * which is an indication of a onSubscribe management bug.
      */
     public static void reportSubscriptionSet() {
-        RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
+        RxJavaPlugins.onError(new ProtocolViolationException("Subscription already set!"));
     }
 
     /**
@@ -89,7 +90,7 @@ public static boolean validate(long n) {
      * @param n the overproduction amount
      */
     public static void reportMoreProduced(long n) {
-        RxJavaPlugins.onError(new IllegalStateException("More produced than requested: " + n));
+        RxJavaPlugins.onError(new ProtocolViolationException("More produced than requested: " + n));
     }
     /**
      * Check if the given subscription is the common cancelled subscription.

File: src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
Patch:
@@ -722,7 +722,7 @@ public void run() throws Exception {
 
             s.onComplete();
 
-            TestHelper.assertError(list, 0, TestException.class, "Inner");
+            TestHelper.assertUndeliverable(list, 0, TestException.class, "Inner");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/disposables/CancellableDisposableTest.java
Patch:
@@ -72,7 +72,7 @@ public void cancel() throws Exception {
             cd.dispose();
             cd.dispose();
 
-            TestHelper.assertError(list, 0, TestException.class);
+            TestHelper.assertUndeliverable(list, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/disposables/ObserverFullArbiterTest.java
Patch:
@@ -73,7 +73,7 @@ public void errorAfterCancel() {
         try {
             fa.onError(new TestException(), bs);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -90,7 +90,7 @@ public void cancelAfterError() {
             fa.dispose();
 
             fa.drain();
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java
Patch:
@@ -185,7 +185,7 @@ public void accept(Disposable s) throws Exception {
 
             assertTrue(o.isDisposed());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/completable/CompletableAmbTest.java
Patch:
@@ -100,7 +100,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java
Patch:
@@ -104,7 +104,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/completable/CompletableDisposeOnTest.java
Patch:
@@ -88,7 +88,7 @@ public void errorAfterCancel() {
 
             to.assertEmpty();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/completable/CompletableDoFinallyTest.java
Patch:
@@ -84,7 +84,7 @@ public void run() throws Exception {
             .assertResult()
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/completable/CompletableMergeIterableTest.java
Patch:
@@ -57,7 +57,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/completable/CompletablePeekTest.java
Patch:
@@ -38,7 +38,7 @@ public void run() throws Exception {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/completable/CompletableTimeoutTest.java
Patch:
@@ -138,7 +138,7 @@ public void run() {
                 to.assertTerminated();
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
 
             } finally {

File: src/test/java/io/reactivex/internal/operators/completable/CompletableUsingTest.java
Patch:
@@ -242,7 +242,7 @@ public void accept(Object d) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "Main");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Disposer");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Disposer");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -299,7 +299,7 @@ public void accept(Object d) throws Exception {
 
             to.cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatestTest.java
Patch:
@@ -226,7 +226,7 @@ public void onError() {
         try {
             ((Subscriber<Object>)it).onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableNextTest.java
Patch:
@@ -348,7 +348,7 @@ public void nextObserverError() {
         try {
             no.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
Patch:
@@ -410,7 +410,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -441,7 +441,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
Patch:
@@ -655,7 +655,7 @@ public void run() {
 
             to.assertFailure(TestException.class);
             if (!errors.isEmpty()) {
-                TestHelper.assertError(errors, 0, TestException.class);
+                TestHelper.assertUndeliverable(errors, 0, TestException.class);
             }
         }
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
Patch:
@@ -604,7 +604,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -629,7 +629,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBlockingTest.java
Patch:
@@ -249,7 +249,7 @@ public void subscribe(Subscriber<? super Integer> s) {
 
             assertEquals(1, source.blockingFirst().intValue());
 
-            TestHelper.assertError(list, 0, TestException.class);
+            TestHelper.assertUndeliverable(list, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -1310,7 +1310,7 @@ public void run() {
                 }
 
                 for (Throwable e : errors) {
-                    assertTrue(e.toString(), e instanceof TestException);
+                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
Patch:
@@ -900,7 +900,7 @@ public void run() {
                 } else {
                     to.assertError(TestException.class);
                     if (!errors.isEmpty()) {
-                        TestHelper.assertError(errors, 0, TestException.class);
+                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                     }
                 }
             } finally {
@@ -1084,7 +1084,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
 
             sub[0].onError(new TestException("Second"));
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -1112,7 +1112,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
             .test(0L)
             .assertFailure(MissingBackpressureException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -1413,7 +1413,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         try {
             ts0[0].onError(new TestException("Second"));
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -1439,7 +1439,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
         try {
             ts0[0].onError(new TestException("Second"));
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
Patch:
@@ -350,7 +350,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDematerializeTest.java
Patch:
@@ -170,8 +170,8 @@ protected void subscribeActual(Subscriber<? super Object> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class, "First");
-            TestHelper.assertError(errors, 1, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "First");
+            TestHelper.assertUndeliverable(errors, 1, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDistinctTest.java
Patch:
@@ -246,7 +246,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChangedTest.java
Patch:
@@ -337,7 +337,7 @@ public boolean test(Integer a, Integer b) throws Exception {
             .test()
             .assertFailure(TestException.class, 1);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoFinallyTest.java
Patch:
@@ -318,7 +318,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -340,7 +340,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycleTest.java
Patch:
@@ -104,7 +104,7 @@ public void accept(long v) throws Exception {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -127,7 +127,7 @@ public void run() throws Exception {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java
Patch:
@@ -263,7 +263,7 @@ protected void subscribeActual(Subscriber<? super Integer> subscriber) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -326,7 +326,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -351,7 +351,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybeTest.java
Patch:
@@ -391,7 +391,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -413,7 +413,7 @@ protected void subscribeActual(MaybeObserver<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingleTest.java
Patch:
@@ -341,7 +341,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -363,7 +363,7 @@ protected void subscribeActual(SingleObserver<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
Patch:
@@ -109,7 +109,7 @@ public void accept(Object d) throws Exception {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -264,7 +264,7 @@ public void accept(Emitter<Object> e) throws Exception {
             .test(1)
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupJoinTest.java
Patch:
@@ -568,7 +568,7 @@ public void run() {
                 }
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();
@@ -641,7 +641,7 @@ public void run() {
                 }
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableJoinTest.java
Patch:
@@ -404,7 +404,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -441,7 +441,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             to
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java
Patch:
@@ -541,7 +541,7 @@ public Object apply(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -601,7 +601,7 @@ public boolean test(Integer v) throws Exception {
            .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -668,7 +668,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
Patch:
@@ -1179,7 +1179,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
 
             to.assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java
Patch:
@@ -664,7 +664,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -678,7 +678,7 @@ public void noErrorLoss() {
 
             co.connect();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReduceTest.java
Patch:
@@ -261,7 +261,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "Reducer");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Source");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Source");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -1443,7 +1443,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
Patch:
@@ -477,7 +477,7 @@ protected void subscribeActual(Subscriber<? super Object> s) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -578,7 +578,7 @@ protected void subscribeActual(Subscriber<? super Object> s) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
Patch:
@@ -721,7 +721,7 @@ public void singleElementOperatorDoNotSwallowExceptionWhenDone() {
                 }
             }).singleElement().test().assertComplete();
 
-            assertSame(exception, error.get());
+            assertSame(exception, error.get().getCause());
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
Patch:
@@ -976,7 +976,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -1016,7 +1016,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicateTest.java
Patch:
@@ -202,7 +202,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
Patch:
@@ -187,7 +187,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
Patch:
@@ -451,7 +451,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -477,7 +477,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java
Patch:
@@ -447,7 +447,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
 
             to.assertFailureAndMessage(TestException.class, "First", 1);
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -476,7 +476,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
 
             to.assertFailureAndMessage(TestException.class, "First", 1);
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOnTest.java
Patch:
@@ -263,7 +263,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
Patch:
@@ -622,7 +622,7 @@ public void accept(Object e) throws Exception {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java
Patch:
@@ -649,7 +649,7 @@ public Object apply(Integer a, Integer b, Integer c) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -676,7 +676,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableZipIterableTest.java
Patch:
@@ -424,7 +424,7 @@ public Object apply(Integer a, Integer b) throws Exception {
             .test()
             .assertResult(2);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
Patch:
@@ -1654,7 +1654,7 @@ public Object apply(Object a, Object b) throws Exception {
 
             sub[0].onError(new TestException("Second"));
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeAmbTest.java
Patch:
@@ -101,7 +101,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeCallbackObserverTest.java
Patch:
@@ -63,7 +63,7 @@ public void accept(Object v) throws Exception {
 
             mo.onSuccess(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -116,7 +116,7 @@ public void run() throws Exception {
 
             mo.onComplete();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayTest.java
Patch:
@@ -151,7 +151,7 @@ protected void subscribeActual(MaybeObserver<? super Integer> observer) {
             o[0].onError(new TestException());
 
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeDelaySubscriptionTest.java
Patch:
@@ -135,7 +135,7 @@ protected void subscribeActual(Subscriber<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeDoAfterSuccessTest.java
Patch:
@@ -128,7 +128,7 @@ public void accept(Integer e) throws Exception {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeDoFinallyTest.java
Patch:
@@ -134,7 +134,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -156,7 +156,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java
Patch:
@@ -151,7 +151,7 @@ public void run() throws Exception {
                 Thread.sleep(100);
             }
 
-            TestHelper.assertError(errors, 0, InterruptedException.class);
+            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java
Patch:
@@ -155,7 +155,7 @@ public Integer call() throws Exception {
                 Thread.sleep(100);
             }
 
-            TestHelper.assertError(errors, 0, InterruptedException.class);
+            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java
Patch:
@@ -153,9 +153,9 @@ public void run() {
                 Thread.sleep(100);
             }
 
-            TestHelper.assertError(errors, 0, RuntimeException.class);
+            TestHelper.assertUndeliverable(errors, 0, RuntimeException.class);
 
-            assertTrue(errors.get(0).toString(), errors.get(0).getCause() instanceof InterruptedException);
+            assertTrue(errors.get(0).toString(), errors.get(0).getCause().getCause() instanceof InterruptedException);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeMergeArrayTest.java
Patch:
@@ -164,7 +164,7 @@ public void run() {
                 ts.assertFailure(Throwable.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybePeekTest.java
Patch:
@@ -68,7 +68,7 @@ public void accept(Throwable e) throws Exception {
             })
             .test();
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
 
             assertTrue("" + err, err[0] instanceof TestException);
             assertEquals("First", err[0].getMessage());
@@ -139,7 +139,7 @@ public void run() throws Exception {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java
Patch:
@@ -148,7 +148,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
 
             } finally {

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilTest.java
Patch:
@@ -176,7 +176,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
 
             } finally {

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeUsingTest.java
Patch:
@@ -242,7 +242,7 @@ public void accept(Object d) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "Main");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Disposer");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Disposer");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -299,7 +299,7 @@ public void accept(Object d) throws Exception {
 
             to.cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeZipArrayTest.java
Patch:
@@ -143,7 +143,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/maybe/MaybeZipIterableTest.java
Patch:
@@ -145,7 +145,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableLatestTest.java
Patch:
@@ -221,7 +221,7 @@ public void onError() {
         try {
             ((Observer<Object>)it).onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableNextTest.java
Patch:
@@ -348,7 +348,7 @@ public void nextObserverError() {
         try {
             no.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableAllTest.java
Patch:
@@ -330,7 +330,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -360,7 +360,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java
Patch:
@@ -359,7 +359,7 @@ public void run() {
 
             to.assertFailure(TestException.class);
             if (!errors.isEmpty()) {
-                TestHelper.assertError(errors, 0, TestException.class);
+                TestHelper.assertUndeliverable(errors, 0, TestException.class);
             }
         }
     }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableAnyTest.java
Patch:
@@ -533,7 +533,7 @@ public boolean test(Integer v) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -558,7 +558,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
Patch:
@@ -1010,7 +1010,7 @@ public void run() {
                 }
 
                 for (Throwable e : errors) {
-                    assertTrue(e.toString(), e instanceof TestException);
+                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java
Patch:
@@ -851,7 +851,7 @@ public void run() {
                 } else {
                     to.assertError(TestException.class);
                     if (!errors.isEmpty()) {
-                        TestHelper.assertError(errors, 0, TestException.class);
+                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                     }
                 }
             } finally {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java
Patch:
@@ -164,7 +164,7 @@ public ObservableSource<Integer> apply(Integer v) throws Exception {
             .test()
             .assertResult(1, 2);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -195,7 +195,7 @@ public ObservableSource<Integer> apply(Integer v) throws Exception {
             .test()
             .assertResult(1, 2);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -362,7 +362,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
 
             o[0].onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
Patch:
@@ -337,7 +337,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDematerializeTest.java
Patch:
@@ -169,8 +169,8 @@ protected void subscribeActual(Observer<? super Object> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class, "First");
-            TestHelper.assertError(errors, 1, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "First");
+            TestHelper.assertUndeliverable(errors, 1, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDistinctTest.java
Patch:
@@ -247,7 +247,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDistinctUntilChangedTest.java
Patch:
@@ -243,7 +243,7 @@ public boolean test(Integer a, Integer b) throws Exception {
             .test()
             .assertFailure(TestException.class, 1);
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDoFinallyTest.java
Patch:
@@ -320,7 +320,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -342,7 +342,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableElementAtTest.java
Patch:
@@ -245,7 +245,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -270,7 +270,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -295,7 +295,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybeTest.java
Patch:
@@ -332,7 +332,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -354,7 +354,7 @@ protected void subscribeActual(MaybeObserver<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingleTest.java
Patch:
@@ -282,7 +282,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -304,7 +304,7 @@ protected void subscribeActual(SingleObserver<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableForEachTest.java
Patch:
@@ -154,7 +154,7 @@ public void run() throws Exception {
                         }
                     });
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFromCompletableTest.java
Patch:
@@ -76,7 +76,7 @@ public Integer call() throws Exception {
 
             to.assertEmpty();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableGenerateTest.java
Patch:
@@ -107,7 +107,7 @@ public void accept(Object d) throws Exception {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -175,7 +175,7 @@ public void accept(Emitter<Object> e) throws Exception {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableGroupJoinTest.java
Patch:
@@ -569,7 +569,7 @@ public void run() {
                 }
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();
@@ -642,7 +642,7 @@ public void run() {
                 }
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableJoinTest.java
Patch:
@@ -403,7 +403,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -440,7 +440,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             to
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
Patch:
@@ -510,7 +510,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
 
             to.assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java
Patch:
@@ -598,7 +598,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -612,7 +612,7 @@ public void noErrorLoss() {
 
             co.connect();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
Patch:
@@ -1310,7 +1310,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java
Patch:
@@ -479,7 +479,7 @@ public void singleElementOperatorDoNotSwallowExceptionWhenDone() {
                 }
             }).singleElement().test().assertComplete();
 
-            assertSame(exception, error.get());
+            assertSame(exception, error.get().getCause());
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java
Patch:
@@ -800,7 +800,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -840,7 +840,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertFailure(TestException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilPredicateTest.java
Patch:
@@ -186,7 +186,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
Patch:
@@ -184,7 +184,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutTests.java
Patch:
@@ -450,7 +450,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -476,7 +476,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutWithSelectorTest.java
Patch:
@@ -448,7 +448,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
 
             to.assertFailureAndMessage(TestException.class, "First", 1);
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -477,7 +477,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
 
             to.assertFailureAndMessage(TestException.class, "First", 1);
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUnsubscribeOnTest.java
Patch:
@@ -252,7 +252,7 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
Patch:
@@ -552,7 +552,7 @@ public void accept(Object e) throws Exception {
             .test()
             .assertResult();
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java
Patch:
@@ -615,7 +615,7 @@ public Object apply(Integer a, Integer b, Integer c) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "First");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Second");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Second");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableZipIterableTest.java
Patch:
@@ -425,7 +425,7 @@ public Object apply(Integer a, Integer b) throws Exception {
             .test()
             .assertResult(2);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java
Patch:
@@ -202,7 +202,7 @@ public void run() {
                 TestHelper.race(r1, r2, Schedulers.single());
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();
@@ -243,7 +243,7 @@ public void run() {
                 TestHelper.race(r1, r2, Schedulers.single());
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java
Patch:
@@ -161,7 +161,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -197,7 +197,7 @@ protected void subscribeActual(Observer<? super Integer> s) {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleDoAfterSuccessTest.java
Patch:
@@ -107,7 +107,7 @@ public void accept(Integer e) throws Exception {
             .test()
             .assertResult(1);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleDoFinallyTest.java
Patch:
@@ -84,7 +84,7 @@ public void run() throws Exception {
             .assertResult(1)
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleDoOnTest.java
Patch:
@@ -147,7 +147,7 @@ public void accept(Disposable s) throws Exception {
             .test()
             .assertFailureAndMessage(TestException.class, "Inner");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Outer");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Outer");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -292,7 +292,7 @@ public void run() throws Exception {
             .test()
             .cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleEqualsTest.java
Patch:
@@ -31,7 +31,7 @@ public void bothError() {
             .test()
             .assertFailureAndMessage(TestException.class, "One");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Two");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Two");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleFromPublisherTest.java
Patch:
@@ -101,7 +101,7 @@ protected void subscribeActual(Subscriber<? super Integer> s) {
             .assertResult(1);
 
             TestHelper.assertError(errors, 0, IllegalStateException.class, "Subscription already set!");
-            TestHelper.assertError(errors, 1, TestException.class);
+            TestHelper.assertUndeliverable(errors, 1, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleTakeUntilTest.java
Patch:
@@ -253,7 +253,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/single/SingleUsingTest.java
Patch:
@@ -121,7 +121,7 @@ public void noneagerMapperThrowsDisposerThrows() {
             .test()
             .assertFailureAndMessage(TestException.class, "Mapper");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Disposer");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Disposer");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -175,7 +175,7 @@ public void disposerThrowsNonEager() {
             Single.using(Functions.justCallable(Disposables.empty()), mapper, disposerThrows, false)
             .test()
             .assertResult(1);
-            TestHelper.assertError(errors, 0, TestException.class, "Disposer");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Disposer");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -212,7 +212,7 @@ public SingleSource<Integer> apply(Disposable v) throws Exception {
             }, disposerThrows, false)
             .test()
             .assertFailure(TestException.class);
-            TestHelper.assertError(errors, 0, TestException.class, "Disposer");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Disposer");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/operators/single/SingleZipArrayTest.java
Patch:
@@ -143,7 +143,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/operators/single/SingleZipIterableTest.java
Patch:
@@ -145,7 +145,7 @@ public void run() {
                 to.assertFailure(TestException.class);
 
                 if (!errors.isEmpty()) {
-                    TestHelper.assertError(errors, 0, TestException.class);
+                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/internal/schedulers/ScheduledRunnableTest.java
Patch:
@@ -212,7 +212,7 @@ public void run() {
 
             assertEquals(0, set.size());
 
-            TestHelper.assertError(errors, 0, TestException.class, "First");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "First");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/subscribers/EmptyComponentTest.java
Patch:
@@ -67,7 +67,7 @@ public void normal() {
 
             c.cancel();
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/subscribers/FutureSubscriberTest.java
Patch:
@@ -87,7 +87,7 @@ public void onError() throws Exception {
                 assertEquals("One", ex.getCause().getMessage());
             }
 
-            TestHelper.assertError(errors, 0, TestException.class, "Two");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Two");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/subscribers/LambdaSubscriberTest.java
Patch:
@@ -187,7 +187,7 @@ public void accept(Subscription s) throws Exception {
 
             assertTrue(o.isDisposed());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/internal/subscriptions/FullArbiterTest.java
Patch:
@@ -89,7 +89,7 @@ public void errorAfterCancel() {
         try {
             fa.onError(new TestException(), bs);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -106,7 +106,7 @@ public void cancelAfterError() {
             fa.cancel();
 
             fa.drain();
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/maybe/MaybeTest.java
Patch:
@@ -872,7 +872,7 @@ public void run() throws Exception {
             .assertNoErrors()
             .assertNotComplete();
 
-            TestHelper.assertError(list, 0, TestException.class);
+            TestHelper.assertUndeliverable(list, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -2679,7 +2679,7 @@ public void sequenceEqual() {
         try {
             Maybe.sequenceEqual(Maybe.error(new TestException("One")), Maybe.error(new TestException("Two"))).test().assertFailureAndMessage(TestException.class, "One");
 
-            TestHelper.assertError(errors, 0, TestException.class, "Two");
+            TestHelper.assertUndeliverable(errors, 0, TestException.class, "Two");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/SafeObserverTest.java
Patch:
@@ -736,7 +736,7 @@ public void onSubscribeCrashes() {
             SafeObserver<Object> so = cd.toSafe();
             so.onSubscribe(cd);
 
-            TestHelper.assertError(list, 0, TestException.class, "onSubscribe()");
+            TestHelper.assertUndeliverable(list, 0, TestException.class, "onSubscribe()");
         } finally {
             RxJavaPlugins.reset();
         }
@@ -872,7 +872,7 @@ public void onCompleteteCrash() {
 
             so.onComplete();
 
-            TestHelper.assertError(list, 0, TestException.class, "onComplete()");
+            TestHelper.assertUndeliverable(list, 0, TestException.class, "onComplete()");
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/observers/SerializedObserverTest.java
Patch:
@@ -1219,7 +1219,7 @@ public void run() {
                 }
 
                 for (Throwable e : errors) {
-                    assertTrue(e.toString(), e instanceof TestException);
+                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                 }
             } finally {
                 RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelCollectTest.java
Patch:
@@ -161,7 +161,7 @@ public void accept(List<Object> a, Object b) throws Exception {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelFilterTest.java
Patch:
@@ -66,7 +66,7 @@ public void doubleError() {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();
@@ -86,7 +86,7 @@ public void doubleError2() {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelMapTest.java
Patch:
@@ -93,7 +93,7 @@ public void doubleError() {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();
@@ -113,7 +113,7 @@ public void doubleError2() {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelReduceFullTest.java
Patch:
@@ -88,7 +88,7 @@ public Integer apply(Integer a, Integer b) throws Exception {
             .test()
             .assertFailure(IOException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -124,7 +124,7 @@ public Object apply(Object a, Object b) throws Exception {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelReduceTest.java
Patch:
@@ -166,7 +166,7 @@ public List<Object> apply(List<Object> a, Object b) throws Exception {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelRunOnTest.java
Patch:
@@ -52,7 +52,7 @@ public void doubleError() {
 
             assertFalse(errors.isEmpty());
             for (Throwable ex : errors) {
-                assertTrue(ex.toString(), ex instanceof TestException);
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
             }
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/parallel/ParallelSortedJoinTest.java
Patch:
@@ -92,7 +92,7 @@ public void error2() {
             .test()
             .assertFailure(IOException.class);
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/processors/BehaviorProcessorTest.java
Patch:
@@ -614,7 +614,7 @@ public void onErrorAfterComplete() {
         try {
             p.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/processors/SerializedProcessorTest.java
Patch:
@@ -419,7 +419,7 @@ public void normal() {
         try {
             s.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -636,7 +636,7 @@ public void run() {
 
                 ts.assertFailure(TestException.class);
 
-                TestHelper.assertError(errors, 0, TestException.class);
+                TestHelper.assertUndeliverable(errors, 0, TestException.class);
             } finally {
                 RxJavaPlugins.reset();
             }

File: src/test/java/io/reactivex/processors/UnicastProcessorTest.java
Patch:
@@ -184,7 +184,7 @@ public void afterDone() {
         try {
             p.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/schedulers/SchedulerTest.java
Patch:
@@ -234,7 +234,7 @@ public void run() {
             Thread.sleep(250);
 
             assertEquals(1, list.size());
-            TestHelper.assertError(list, 0, TestException.class, null);
+            TestHelper.assertUndeliverable(list, 0, TestException.class, null);
 
         } finally {
             RxJavaPlugins.reset();

File: src/test/java/io/reactivex/single/SingleSubscribeTest.java
Patch:
@@ -140,7 +140,7 @@ public void accept(Integer t) throws Exception {
                 }
             });
 
-            TestHelper.assertError(list, 0, TestException.class);
+            TestHelper.assertUndeliverable(list, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -181,7 +181,7 @@ public void accept(Integer t, Throwable e) throws Exception {
                 }
             });
 
-            TestHelper.assertError(list, 0, TestException.class);
+            TestHelper.assertUndeliverable(list, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/subjects/BehaviorSubjectTest.java
Patch:
@@ -663,7 +663,7 @@ public void onErrorAfterComplete() {
         try {
             p.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/subjects/CompletableSubjectTest.java
Patch:
@@ -40,7 +40,7 @@ public void once() {
         try {
             cs.onError(new IOException());
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/subjects/MaybeSubjectTest.java
Patch:
@@ -83,7 +83,7 @@ public void once() {
         try {
             ms.onError(new IOException());
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/subjects/SerializedSubjectTest.java
Patch:
@@ -420,7 +420,7 @@ public void normal() {
         try {
             s.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -637,7 +637,7 @@ public void run() {
 
                 ts.assertFailure(TestException.class);
 
-                TestHelper.assertError(errors, 0, TestException.class);
+                TestHelper.assertUndeliverable(errors, 0, TestException.class);
             } finally {
                 RxJavaPlugins.reset();
             }

File: src/test/java/io/reactivex/subjects/SingleSubjectTest.java
Patch:
@@ -80,7 +80,7 @@ public void once() {
         try {
             ss.onError(new IOException());
 
-            TestHelper.assertError(errors, 0, IOException.class);
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/subjects/UnicastSubjectTest.java
Patch:
@@ -235,7 +235,7 @@ public void afterDone() {
         try {
             p.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }
@@ -341,7 +341,7 @@ public void dispose() {
         try {
             us.onError(new TestException());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertUndeliverable(errors, 0, TestException.class);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
Patch:
@@ -1170,7 +1170,7 @@ public void uncaughtException(Thread t, Throwable e) {
     }
 
     /**
-     * Ensure set*() accepts a consumers/functions with wider bounds
+     * Ensure set*() accepts a consumers/functions with wider bounds.
      * @throws Exception on error
      */
     @Test

File: src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
Patch:
@@ -117,7 +117,7 @@ public void run() {
     }
 
     /**
-     * Regression test to ensure there is no NPE when the worker has been disposed
+     * Regression test to ensure there is no NPE when the worker has been disposed.
      * @throws Exception on error
      */
     @Test

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1708,8 +1708,6 @@ public final Disposable subscribe(final Action onComplete, final Consumer<? supe
      * If the Completable emits an error, it is wrapped into an
      * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
      * and routed to the RxJavaPlugins.onError handler.
-     * <p>
-     * If this Completable emits an error, it is sent to RxJavaPlugins.onError and gets swallowed.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
Patch:
@@ -118,6 +118,7 @@ public void run() {
 
     /**
      * Regression test to ensure there is no NPE when the worker has been disposed
+     * @throws Exception on error
      */
     @Test
     public void npeRegression() throws Exception {

File: src/test/java/io/reactivex/exceptions/ExceptionsTest.java
Patch:
@@ -141,7 +141,7 @@ public void onNext(Integer n) {
             }
         });
         a.onNext(1);
-        assertTrue(depth.get() > MAX_STACK_DEPTH);
+        assertTrue(depth.get() >= MAX_STACK_DEPTH);
     }
 
     @Test(expected = StackOverflowError.class)

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.disposables;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.fuseable.QueueDisposable;
 
 /**
@@ -93,6 +94,7 @@ public boolean offer(Object v1, Object v2) {
         throw new UnsupportedOperationException("Should not be called!");
     }
 
+    @Nullable
     @Override
     public Object poll() throws Exception {
         return null; // always empty

File: src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java
Patch:
@@ -13,13 +13,16 @@
 
 package io.reactivex.internal.fuseable;
 
+import io.reactivex.annotations.Nullable;
+
 /**
  * Override of the SimpleQueue interface with no throws Exception on poll.
  *
  * @param <T> the value type to enqueue and dequeue, not null
  */
 public interface SimplePlainQueue<T> extends SimpleQueue<T> {
 
+    @Nullable
     @Override
     T poll();
 }

File: src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.observers;
 
 import io.reactivex.Observer;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -110,6 +111,7 @@ public final void complete() {
         actual.onComplete();
     }
 
+    @Nullable
     @Override
     public final T poll() throws Exception {
         if (get() == FUSED_READY) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Iterator;
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.Flowable;
@@ -466,6 +467,7 @@ public int requestFusion(int requestedMode) {
             return m;
         }
 
+        @Nullable
         @SuppressWarnings("unchecked")
         @Override
         public R poll() throws Exception {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Collection;
 import java.util.concurrent.Callable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.Exceptions;
@@ -117,6 +118,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.functions.*;
@@ -106,6 +107,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             for (;;) {
@@ -195,6 +197,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoAfterNext.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.annotations.Experimental;
@@ -74,6 +75,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();
@@ -122,6 +124,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoFinally.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.annotations.Experimental;
@@ -130,6 +131,7 @@ public boolean isEmpty() {
             return qs.isEmpty();
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();
@@ -239,6 +241,7 @@ public boolean isEmpty() {
             return qs.isEmpty();
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.*;
@@ -144,6 +145,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();
@@ -276,6 +278,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.functions.Predicate;
@@ -79,6 +80,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             QueueSubscription<T> qs = this.qs;
@@ -143,6 +145,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             QueueSubscription<T> qs = this.qs;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.*;
@@ -174,6 +175,7 @@ public void request(long n) {
             // ignored, no values emitted
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             return null; // always empty

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.*;
@@ -413,6 +414,7 @@ public boolean isEmpty() {
             return (it != null && !it.hasNext()) || queue.isEmpty();
         }
 
+        @Nullable
         @Override
         public R poll() throws Exception {
             Iterator<? extends R> it = current;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
@@ -55,6 +56,7 @@ public final int requestFusion(int mode) {
             return mode & SYNC;
         }
 
+        @Nullable
         @Override
         public final T poll() {
             int i = index;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.Iterator;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
@@ -87,6 +88,7 @@ public final int requestFusion(int mode) {
             return mode & SYNC;
         }
 
+        @Nullable
         @Override
         public final T poll() {
             if (it == null) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.Exceptions;
@@ -353,6 +354,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public GroupedFlowable<K, V> poll() {
             return queue.poll();
@@ -627,6 +629,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public T poll() {
             T v = queue.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElements.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.internal.fuseable.QueueSubscription;
@@ -72,6 +73,7 @@ public boolean offer(T v1, T v2) {
             throw new UnsupportedOperationException("Should not be called!");
         }
 
+        @Nullable
         @Override
         public T poll() {
             return null; // empty, always

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
Patch:
@@ -14,6 +14,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.functions.Function;
@@ -72,6 +73,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public U poll() throws Exception {
             T t = qs.poll();
@@ -131,6 +133,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public U poll() throws Exception {
             T t = qs.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicLong;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.Scheduler;
@@ -457,6 +458,7 @@ void runBackfused() {
             }
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = queue.poll();
@@ -695,6 +697,7 @@ void runBackfused() {
             }
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = queue.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicLong;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.*;
@@ -251,6 +252,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             return queue.poll();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRange.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
@@ -59,6 +60,7 @@ public final int requestFusion(int mode) {
             return mode & SYNC;
         }
 
+        @Nullable
         @Override
         public final Integer poll() {
             int i = index;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRangeLong.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import io.reactivex.Flowable;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.fuseable.ConditionalSubscriber;
 import io.reactivex.internal.subscriptions.BasicQueueSubscription;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
@@ -62,6 +63,7 @@ public final int requestFusion(int mode) {
             return mode & SYNC;
         }
 
+        @Nullable
         @Override
         public final Long poll() {
             long i = index;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapIterableFlowable.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicLong;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
@@ -277,6 +278,7 @@ public boolean isEmpty() {
             return it == null;
         }
 
+        @Nullable
         @Override
         public R poll() throws Exception {
             Iterator<? extends R> iter = it;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapIterableObservable.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Iterator;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
@@ -187,6 +188,7 @@ public boolean isEmpty() {
             return it == null;
         }
 
+        @Nullable
         @Override
         public R poll() throws Exception {
             Iterator<? extends R> iter = it;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.Callable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -113,6 +114,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinctUntilChanged.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.observers.BasicFuseableObserver;
 
@@ -90,6 +91,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoAfterNext.java
Patch:
@@ -15,6 +15,7 @@
 
 import io.reactivex.*;
 import io.reactivex.annotations.Experimental;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.observers.BasicFuseableObserver;
 
@@ -65,6 +66,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qs.poll();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoFinally.java
Patch:
@@ -15,6 +15,7 @@
 
 import io.reactivex.*;
 import io.reactivex.annotations.Experimental;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
@@ -127,6 +128,7 @@ public boolean isEmpty() {
             return qd.isEmpty();
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             T v = qd.poll();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.observers.BasicFuseableObserver;
 
@@ -60,6 +61,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletable.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
@@ -148,6 +149,7 @@ public boolean isDisposed() {
             return d.isDisposed();
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             return null; // always empty

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromArray.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.observers.BasicQueueDisposable;
 
@@ -61,6 +62,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public T poll() {
             int i = index;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromIterable.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Iterator;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.functions.ObjectHelper;
@@ -122,6 +123,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public T poll() {
             if (done) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
Patch:
@@ -15,6 +15,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.observers.BasicFuseableObserver;
@@ -68,6 +69,7 @@ public int requestFusion(int mode) {
             return transitiveBoundaryFusion(mode);
         }
 
+        @Nullable
         @Override
         public U poll() throws Exception {
             T t = qs.poll();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableObserveOn.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.DisposableHelper;
@@ -294,6 +295,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             return queue.poll();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
Patch:
@@ -13,6 +13,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.observers.BasicIntQueueDisposable;
 
 /**
@@ -68,6 +69,7 @@ void run() {
             }
         }
 
+        @Nullable
         @Override
         public Integer poll() throws Exception {
             long i = index;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRangeLong.java
Patch:
@@ -13,6 +13,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.observers.BasicIntQueueDisposable;
 
 public final class ObservableRangeLong extends Observable<Long> {
@@ -65,6 +66,7 @@ void run() {
             }
         }
 
+        @Nullable
         @Override
         public Long poll() throws Exception {
             long i = index;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -202,6 +203,7 @@ public boolean offer(T v1, T v2) {
             throw new UnsupportedOperationException("Should not be called!");
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             if (get() == FUSED) {

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapIterableFlowable.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicLong;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
@@ -271,6 +272,7 @@ public boolean isEmpty() {
             return it == null;
         }
 
+        @Nullable
         @Override
         public R poll() throws Exception {
             Iterator<? extends R> iter = it;

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapIterableObservable.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Iterator;
 
 import io.reactivex.*;
+import io.reactivex.annotations.Nullable;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
@@ -181,6 +182,7 @@ public boolean isEmpty() {
             return it == null;
         }
 
+        @Nullable
         @Override
         public R poll() throws Exception {
             Iterator<? extends R> iter = it;

File: src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.fuseable.SimplePlainQueue;
 
 /**
@@ -81,6 +82,7 @@ public boolean offer(final T e) {
      *
      * @see java.util.Queue#poll()
      */
+    @Nullable
     @Override
     public T poll() {
         LinkedQueueNode<T> currConsumerNode = lpConsumerNode(); // don't load twice, it's alright

File: src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.fuseable.SimplePlainQueue;
 import io.reactivex.internal.util.Pow2;
 
@@ -82,6 +83,7 @@ public boolean offer(E v1, E v2) {
         return offer(v1) && offer(v2);
     }
 
+    @Nullable
     @Override
     public E poll() {
         final long index = consumerIndex.get();

File: src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import io.reactivex.internal.fuseable.SimplePlainQueue;
 import io.reactivex.internal.util.Pow2;
 
@@ -121,6 +122,7 @@ private AtomicReferenceArray<Object> lvNext(AtomicReferenceArray<Object> curr) {
      * <p>
      * This implementation is correct for single consumer thread use only.
      */
+    @Nullable
     @SuppressWarnings("unchecked")
     @Override
     public T poll() {

File: src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.subscriptions;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 /**
@@ -156,6 +157,7 @@ public final int requestFusion(int mode) {
         return NONE;
     }
 
+    @Nullable
     @Override
     public final T poll() {
         if (get() == FUSED_READY) {

File: src/main/java/io/reactivex/internal/subscriptions/EmptySubscription.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.subscriptions;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.internal.fuseable.QueueSubscription;
@@ -66,6 +67,7 @@ public static void complete(Subscriber<?> s) {
         s.onSubscribe(INSTANCE);
         s.onComplete();
     }
+    @Nullable
     @Override
     public Object poll() {
         return null; // always empty

File: src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.internal.fuseable.QueueSubscription;
@@ -82,6 +83,7 @@ public boolean offer(T v1, T v2) {
         throw new UnsupportedOperationException("Should not be called!");
     }
 
+    @Nullable
     @Override
     public T poll() {
         if (get() == NO_REQUEST) {

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -16,6 +16,7 @@
 import io.reactivex.annotations.CheckReturnValue;
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import org.reactivestreams.*;
 
 import io.reactivex.internal.functions.ObjectHelper;
@@ -340,6 +341,7 @@ final class UnicastQueueSubscription extends BasicIntQueueSubscription<T> {
 
         private static final long serialVersionUID = -4896760517184205454L;
 
+        @Nullable
         @Override
         public T poll() {
             return queue.poll();

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.subjects;
 
+import io.reactivex.annotations.Nullable;
 import io.reactivex.plugins.RxJavaPlugins;
 import java.util.concurrent.atomic.*;
 
@@ -348,6 +349,7 @@ public int requestFusion(int mode) {
             return NONE;
         }
 
+        @Nullable
         @Override
         public T poll() throws Exception {
             return queue.poll();

File: src/test/java/io/reactivex/internal/observers/BasicFuseableObserverTest.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.observers;
 
+import io.reactivex.annotations.Nullable;
 import org.junit.Test;
 
 import io.reactivex.disposables.Disposables;
@@ -24,6 +25,7 @@ public class BasicFuseableObserverTest {
     public void offer() {
         TestObserver<Integer> to = new TestObserver<Integer>();
         BasicFuseableObserver<Integer, Integer> o = new BasicFuseableObserver<Integer, Integer>(to) {
+            @Nullable
             @Override
             public Integer poll() throws Exception {
                 return null;
@@ -51,6 +53,7 @@ protected boolean beforeDownstream() {
     @Test(expected = UnsupportedOperationException.class)
     public void offer2() {
         BasicFuseableObserver<Integer, Integer> o = new BasicFuseableObserver<Integer, Integer>(new TestObserver<Integer>()) {
+            @Nullable
             @Override
             public Integer poll() throws Exception {
                 return null;

File: src/test/java/io/reactivex/internal/observers/BasicQueueDisposableTest.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.observers;
 
+import io.reactivex.annotations.Nullable;
 import org.junit.Test;
 
 public class BasicQueueDisposableTest {
@@ -29,6 +30,7 @@ public void dispose() {
 
         }
 
+        @Nullable
         @Override
         public Integer poll() throws Exception {
             return null;

File: src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
+import io.reactivex.annotations.Nullable;
 import org.junit.Test;
 import org.mockito.InOrder;
 
@@ -692,6 +693,7 @@ public boolean offer(Integer v1, Integer v2) {
                         return false;
                     }
 
+                    @Nullable
                     @Override
                     public Integer poll() throws Exception {
                         throw new TestException();

File: src/test/java/io/reactivex/internal/subscribers/BasicFuseableConditionalSubscriberTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import static org.junit.Assert.*;
 
+import io.reactivex.annotations.Nullable;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
 
@@ -66,6 +67,7 @@ public int requestFusion(int mode) {
                 return 0;
             }
 
+            @Nullable
             @Override
             public Integer poll() throws Exception {
                 return null;

File: src/test/java/io/reactivex/internal/subscribers/BasicFuseableSubscriberTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import static org.junit.Assert.*;
 
+import io.reactivex.annotations.Nullable;
 import org.junit.Test;
 
 import io.reactivex.TestHelper;
@@ -36,6 +37,7 @@ public int requestFusion(int mode) {
                 return 0;
             }
 
+            @Nullable
             @Override
             public Integer poll() throws Exception {
                 return null;

File: src/test/java/io/reactivex/internal/subscriptions/QueueSubscriptionTest.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.subscriptions;
 
+import io.reactivex.annotations.Nullable;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -28,6 +29,7 @@ public int requestFusion(int mode) {
             return 0;
         }
 
+        @Nullable
         @Override
         public Integer poll() throws Exception {
             return null;
@@ -64,6 +66,7 @@ public int requestFusion(int mode) {
             return 0;
         }
 
+        @Nullable
         @Override
         public Integer poll() throws Exception {
             return null;

File: src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java
Patch:
@@ -17,9 +17,9 @@
 
 import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.*;
+import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CallbackCompletableObserver
@@ -43,7 +43,7 @@ public CallbackCompletableObserver(Consumer<? super Throwable> onError, Action o
 
     @Override
     public void accept(Throwable e) {
-        RxJavaPlugins.onError(e);
+        RxJavaPlugins.onError(new OnErrorNotImplementedException(e));
     }
 
     @Override

File: src/main/java/io/reactivex/internal/observers/EmptyCompletableObserver.java
Patch:
@@ -17,7 +17,8 @@
 
 import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.*;
+import io.reactivex.exceptions.OnErrorNotImplementedException;
+import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class EmptyCompletableObserver
@@ -46,7 +47,7 @@ public void onComplete() {
     @Override
     public void onError(Throwable e) {
         lazySet(DisposableHelper.DISPOSED);
-        RxJavaPlugins.onError(e);
+        RxJavaPlugins.onError(new OnErrorNotImplementedException(e));
     }
 
     @Override

File: src/test/java/io/reactivex/internal/operators/observable/ObservableForEachTest.java
Patch:
@@ -111,7 +111,9 @@ public boolean test(Integer v) throws Exception {
                 }
             });
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);
+            Throwable c = errors.get(0).getCause();
+            assertTrue("" + c, c instanceof TestException);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/maybe/MaybeTest.java
Patch:
@@ -2214,7 +2214,9 @@ public void subscribeZeroError() {
             assertTrue(Maybe.error(new TestException())
             .subscribe().isDisposed());
 
-            TestHelper.assertError(errors, 0, TestException.class);
+            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);
+            Throwable c = errors.get(0).getCause();
+            assertTrue("" + c, c instanceof TestException);
         } finally {
             RxJavaPlugins.reset();
         }

File: src/test/java/io/reactivex/TransformerTest.java
Patch:
@@ -126,8 +126,8 @@ public void flowableGenericsSignatureTest() {
         Flowable.just(a).compose(TransformerTest.<String>testFlowableTransformerCreator());
     }
 
-    interface A<T, R> {}
-    interface B<T> {}
+    interface A<T, R> { }
+    interface B<T> { }
 
     private static <T> ObservableTransformer<A<T, ?>, B<T>> testObservableTransformerCreator() {
         return new ObservableTransformer<A<T, ?>, B<T>>() {

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -10015,7 +10015,7 @@ public final Observable<T> share() {
     }
 
     /**
-     * Returns an Observable that emits the single item emitted by this Observable if this Observable
+     * Returns a Maybe that emits the single item emitted by this Observable if this Observable
      * emits only a single item, otherwise if this Observable emits more than one item or no items, an
      * {@code IllegalArgumentException} or {@code NoSuchElementException} is signalled respectively.
      * <p>
@@ -10025,7 +10025,7 @@ public final Observable<T> share() {
      *  <dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @return an Observable that emits the single item emitted by the source ObservableSource
+     * @return a {@link Maybe} that emits the single item emitted by the source ObservableSource
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
      */
     @CheckReturnValue

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -600,7 +600,7 @@ public void onSubscribe(Subscription s) {
                 if (s instanceof QueueSubscription) {
                     @SuppressWarnings("unchecked")
                     QueueSubscription<U> qs = (QueueSubscription<U>) s;
-                    int m = qs.requestFusion(QueueSubscription.ANY);
+                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);
                     if (m == QueueSubscription.SYNC) {
                         fusionMode = m;
                         queue = qs;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
Patch:
@@ -357,7 +357,7 @@ public void onSubscribe(Subscription s) {
                 if (s instanceof QueueSubscription) {
                     QueueSubscription<T> f = (QueueSubscription<T>) s;
 
-                    int m = f.requestFusion(QueueSubscription.ANY);
+                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);
 
                     if (m == QueueSubscription.SYNC) {
                         sourceMode = m;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
Patch:
@@ -532,7 +532,7 @@ public void onSubscribe(Disposable s) {
                     @SuppressWarnings("unchecked")
                     QueueDisposable<U> qd = (QueueDisposable<U>) s;
 
-                    int m = qd.requestFusion(QueueDisposable.ANY);
+                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);
                     if (m == QueueDisposable.SYNC) {
                         fusionMode = m;
                         queue = qd;

File: src/main/java/io/reactivex/BackpressureOverflowStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/BackpressureStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/CompletableEmitter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/CompletableObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/CompletableOnSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/CompletableOperator.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/CompletableSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/CompletableTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Emitter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/FlowableEmitter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/FlowableOnSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/FlowableOperator.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/FlowableTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/MaybeEmitter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/MaybeObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/MaybeOnSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/MaybeOperator.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/MaybeSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/MaybeTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Notification.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/ObservableEmitter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/ObservableOnSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/ObservableOperator.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/ObservableSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/ObservableTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Observer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Scheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/SingleEmitter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/SingleObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/SingleOnSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/SingleOperator.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/SingleSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/SingleTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/BackpressureKind.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/BackpressureSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/Beta.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/CheckReturnValue.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/Experimental.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/SchedulerSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/disposables/ActionDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/CompositeDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/Disposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/Disposables.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/FutureDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/ReferenceDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/RunnableDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/SerialDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/SubscriptionDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/exceptions/CompositeException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/exceptions/Exceptions.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/flowables/ConnectableFlowable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/flowables/GroupedFlowable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/flowables/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/functions/Action.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/BiConsumer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/BiFunction.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/BiPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/BooleanSupplier.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Cancellable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Consumer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function3.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function4.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function5.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function6.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function7.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function8.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Function9.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/IntFunction.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/LongConsumer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/Predicate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/functions/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/internal/disposables/ArrayCompositeDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/CancellableDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/DisposableContainer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/SequentialDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/functions/Functions.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/functions/ObjectHelper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/ConditionalSubscriber.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/FuseToFlowable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/FuseToMaybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/FuseToObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/HasUpstreamCompletableSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/HasUpstreamMaybeSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/HasUpstreamObservableSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/HasUpstreamPublisher.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/HasUpstreamSingleSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/QueueDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/QueueFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/QueueSubscription.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/ScalarCallable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/SimpleQueue.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/fuseable/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BasicFuseableObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BasicIntQueueDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BasicQueueDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BiConsumerSingleObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BlockingBaseObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BlockingFirstObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BlockingLastObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/BlockingObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/ConsumerSingleObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/DeferredScalarObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/DisposableLambdaObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/EmptyCompletableObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/ForEachWhileObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/FullArbiterObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/FutureObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/FutureSingleObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/InnerQueuedObserverSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/LambdaObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/ResumeSingleObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/observers/SubscriberCompletableObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableCache.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDefer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDisposeOn.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDoFinally.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDoOnEvent.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableError.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromAction.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromCallable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromRunnable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromUnsafeSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableHide.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableLift.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorArray.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableNever.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableObserveOn.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableOnErrorComplete.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTimer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableToFlowable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableToObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableToSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/AbstractFlowableWithUpstream.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAllSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAnySingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAutoConnect.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollectSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCountSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDefer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDetach.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoAfterNext.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoFinally.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromFuture.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromPublisher.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGenerate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableHide.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElements.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsCompletable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableJoin.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableJust.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableLastMaybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableLastSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableLift.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMaterialize.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableNever.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDrop.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  * <p>
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorNext.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRange.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRangeLong.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReduce.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceMaybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceWithSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatWhen.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryWhen.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSampleTimed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSerialized.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkip.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipWhile.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableStrict.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastOne.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeWhile.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2016 Netflix, Inc.
+ * Copyright (c) 2016-present, RxJava Contributors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableWithLatestFrom<T, U, R> extends AbstractObservableWithUpstream<T, R> {
@@ -37,7 +38,7 @@ public void subscribeActual(Observer<? super R> t) {
         final SerializedObserver<R> serial = new SerializedObserver<R>(t);
         final WithLatestFromObserver<T, U, R> wlf = new WithLatestFromObserver<T, U, R>(serial, combiner);
 
-        t.onSubscribe(wlf);
+        serial.onSubscribe(wlf);
 
         other.subscribe(new Observer<U>() {
             @Override
@@ -91,7 +92,7 @@ public void onNext(T t) {
             if (u != null) {
                 R r;
                 try {
-                    r = combiner.apply(t, u);
+                    r = ObjectHelper.requireNonNull(combiner.apply(t, u), "The combiner returned a null value");
                 } catch (Throwable e) {
                     Exceptions.throwIfFatal(e);
                     dispose();

File: src/test/java/io/reactivex/tck/DelayTckTest.java
Patch:
@@ -26,9 +26,7 @@ public class DelayTckTest extends BaseTck<Integer> {
     @Override
     public Publisher<Integer> createPublisher(long elements) {
         return FlowableTck.wrap(
-            FlowableAwaitOnSubscribeTck.wrap(
-                Flowable.range(0, (int)elements).delay(1, TimeUnit.MILLISECONDS)
-            )
+            Flowable.range(0, (int)elements).delay(1, TimeUnit.MILLISECONDS)
         );
     }
 }

File: src/test/java/io/reactivex/tck/ObserveOnTckTest.java
Patch:
@@ -29,9 +29,7 @@ public ObserveOnTckTest() {
     @Override
     public Publisher<Integer> createPublisher(long elements) {
         return FlowableTck.wrap(
-            FlowableAwaitOnSubscribeTck.wrap(
                 Flowable.range(0, (int)elements).observeOn(Schedulers.single())
-            )
         );
     }
 }

File: src/main/java/io/reactivex/internal/observers/LambdaObserver.java
Patch:
@@ -67,7 +67,7 @@ public void onNext(T t) {
     @Override
     public void onError(Throwable t) {
         if (!isDisposed()) {
-            dispose();
+            lazySet(DisposableHelper.DISPOSED);
             try {
                 onError.accept(t);
             } catch (Throwable e) {
@@ -80,7 +80,7 @@ public void onError(Throwable t) {
     @Override
     public void onComplete() {
         if (!isDisposed()) {
-            dispose();
+            lazySet(DisposableHelper.DISPOSED);
             try {
                 onComplete.run();
             } catch (Throwable e) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
Patch:
@@ -91,6 +91,8 @@ public void testUnsubscribesFromUpstreamFlowable() {
             public void run() {
                 unsub.set(true);
             }})
+            .ignoreElements()
+            .toFlowable()
             .subscribe().dispose();
 
         assertTrue(unsub.get());
@@ -207,6 +209,7 @@ public void testUnsubscribesFromUpstream() {
             public void run() {
                 unsub.set(true);
             }})
+            .ignoreElements()
             .subscribe().dispose();
 
         assertTrue(unsub.get());

File: src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java
Patch:
@@ -83,6 +83,7 @@ protected final void fastPathEmit(U value, boolean delayError, Disposable dispos
      * Makes sure the fast-path emits in order.
      * @param value the value to emit or queue up
      * @param delayError if true, errors are delayed until the source has terminated
+     * @param disposable the resource to dispose if the drain terminates
      */
     protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {
         final Observer<? super V> s = actual;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapCompletable.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Maps the success value of the source MaybeSource into a Completable.
- * @param <T>
+ * @param <T> the value type of the source MaybeSource
  */
 public final class MaybeFlatMapCompletable<T> extends Completable {
 

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapCompletable.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Maps the success value of the source SingleSource into a Completable.
- * @param <T>
+ * @param <T> the value type of the source SingleSource
  */
 public final class SingleFlatMapCompletable<T> extends Completable {
 

File: src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java
Patch:
@@ -35,7 +35,7 @@
  * 2012 - Junchang- BQueue- Efficient and Practical Queuing.pdf <br>
  * </i> This implementation is wait free.
  *
- * @param <E>
+ * @param <E> the element type of the queue
  */
 public final class SpscArrayQueue<E> extends AtomicReferenceArray<E> implements SimplePlainQueue<E> {
     private static final long serialVersionUID = -1296597691183856449L;

File: src/main/java/io/reactivex/observers/BaseTestConsumer.java
Patch:
@@ -117,6 +117,7 @@ public final int errorCount() {
      * will capture those potential errors and report it along with the original failure.
      *
      * @param message the message to use
+     * @return AssertionError the prepared AssertionError instance
      */
     protected final AssertionError fail(String message) {
         StringBuilder b = new StringBuilder(64 + message.length());

File: src/main/java/io/reactivex/subscribers/DefaultSubscriber.java
Patch:
@@ -37,6 +37,7 @@ public final void onSubscribe(Subscription s) {
 
     /**
      * Requests from the upstream Subscription.
+     * @param n the request amount, positive
      */
     protected final void request(long n) {
         Subscription s = this.s;

File: src/test/java/io/reactivex/flowable/FlowableEventStream.java
Patch:
@@ -66,8 +66,9 @@ public static class Event {
         public final Map<String, Object> values;
 
         /**
-         * @param type
-         * @param instanceId
+         * Construct an event with the provided parameters.
+         * @param type the event type
+         * @param instanceId the instance identifier
          * @param values
          *            This does NOT deep-copy, so do not mutate this Map after passing it in.
          */

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -699,7 +699,7 @@ public void testErrorThrownWithoutErrorHandlerSynchronous() {
      * to rethrow the exception on the thread that the message comes out from the Observable.
      * The OnCompleted behavior in this case is to do nothing."
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Test
     @Ignore("Subscribers can't throw")

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableNextTest.java
Patch:
@@ -224,7 +224,7 @@ public void testNextWithCallingHasNextMultipleTimes() {
      * <p/>
      * This results in output such as => a: 1 b: 2 c: 89
      *
-     * @throws Throwable
+     * @throws Throwable some method call is declared throws
      */
     @Test
     public void testNoBufferingOrBlockingOfSequence() throws Throwable {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
Patch:
@@ -171,7 +171,7 @@ public void accept(V v) {
     /**
      * Assert that only a single subscription to a stream occurs and that all events are received.
      *
-     * @throws Throwable
+     * @throws Throwable some method call is declared throws
      */
     @Test
     public void testGroupedEventStream() throws Throwable {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
Patch:
@@ -836,7 +836,7 @@ public void onNext(Integer t) {
      * Thus, we must allow all Flowables to be sent. The ScalarSynchronousFlowable use case is an exception to this since
      * we can grab the value synchronously.
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Test(timeout = 5000)
     public void testBackpressureBothUpstreamAndDownstreamWithRegularFlowables() throws InterruptedException {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -557,7 +557,7 @@ public void testIssue2191_UnsubscribeSource() throws Exception {
     /**
      * Specifically test interaction with a Scheduler with subscribeOn.
      *
-     * @throws Exception
+     * @throws Exception functional interfaces declare throws Exception
      */
     @SuppressWarnings("unchecked")
     @Test
@@ -619,7 +619,7 @@ public void testIssue2191_SchedulerUnsubscribe() throws Exception {
     /**
      * Specifically test interaction with a Scheduler with subscribeOn.
      *
-     * @throws Exception
+     * @throws Exception functional interfaces declare throws Exception
      */
     @SuppressWarnings("unchecked")
     @Test

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableNextTest.java
Patch:
@@ -230,7 +230,7 @@ public void testNextWithCallingHasNextMultipleTimes() {
      * <p/>
      * This results in output such as => a: 1 b: 2 c: 89
      *
-     * @throws Throwable
+     * @throws Throwable some method call is declared throws
      */
     @Test
     public void testNoBufferingOrBlockingOfSequence() throws Throwable {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
Patch:
@@ -171,7 +171,7 @@ public void accept(V v) {
     /**
      * Assert that only a single subscription to a stream occurs and that all events are received.
      *
-     * @throws Throwable
+     * @throws Throwable some method may throw
      */
     @Test
     public void testGroupedEventStream() throws Throwable {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
Patch:
@@ -772,7 +772,7 @@ public void onNext(Integer t) {
      * Thus, we must allow all Observables to be sent. The ScalarSynchronousObservable use case is an exception to this since
      * we can grab the value synchronously.
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Test(timeout = 5000)
     public void testBackpressureBothUpstreamAndDownstreamWithRegularObservables() throws InterruptedException {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
Patch:
@@ -557,7 +557,7 @@ public void testIssue2191_UnsubscribeSource() throws Exception {
     /**
      * Specifically test interaction with a Scheduler with subscribeOn.
      *
-     * @throws Exception
+     * @throws Exception functional interfaces are declared with throws Exception
      */
     @SuppressWarnings("unchecked")
     @Test
@@ -610,7 +610,7 @@ public void testIssue2191_SchedulerUnsubscribe() throws Exception {
     /**
      * Specifically test interaction with a Scheduler with subscribeOn.
      *
-     * @throws Exception
+     * @throws Exception functional interfaces are declared with throws Exception
      */
     @SuppressWarnings("unchecked")
     @Test

File: src/test/java/io/reactivex/observable/ObservableEventStream.java
Patch:
@@ -67,8 +67,9 @@ public static class Event {
         public final Map<String, Object> values;
 
         /**
-         * @param type
-         * @param instanceId
+         * Construct an event with the provided parameters.
+         * @param type the event type
+         * @param instanceId the instance identifier
          * @param values
          *            This does NOT deep-copy, so do not mutate this Map after passing it in.
          */

File: src/test/java/io/reactivex/observable/ObservableTest.java
Patch:
@@ -719,7 +719,7 @@ public void testErrorThrownWithoutErrorHandlerSynchronous() {
      * to rethrow the exception on the thread that the message comes out from the Observable.
      * The OnCompleted behavior in this case is to do nothing."
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Test
     @Ignore("Subscribers can't throw")

File: src/test/java/io/reactivex/observers/SerializedObserverTest.java
Patch:
@@ -250,7 +250,7 @@ public void runConcurrencyTest() {
     /**
      * Test that a notification does not get delayed in the queue waiting for the next event to push it through.
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Ignore("this is non-deterministic ... haven't figured out what's wrong with the test yet (benjchristensen: July 2014)")
     @Test
@@ -340,7 +340,7 @@ public void onNext(String t) {
      * The real issue in this example is the async buffer-bloat, so we need backpressure.
      *
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Ignore("Demonstrates thread starvation problem. Read JavaDoc")
     @Test
@@ -585,7 +585,7 @@ public void onNext(String args) {
         /**
          * Assert the order of events is correct and return the number of onNext executions.
          *
-         * @param expectedEndingEvent
+         * @param expectedEndingEvent the expected last event
          * @return int count of onNext calls
          * @throws IllegalStateException
          *             If order of events was invalid.

File: src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java
Patch:
@@ -40,6 +40,7 @@ public abstract class AbstractSchedulerTests {
 
     /**
      * The scheduler to test.
+     * @return the Scheduler instance
      */
     protected abstract Scheduler getScheduler();
 
@@ -136,7 +137,7 @@ public String apply(String s) {
     /**
      * The order of execution is nondeterministic.
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @SuppressWarnings("rawtypes")
     @Test

File: src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java
Patch:
@@ -251,7 +251,7 @@ public void runConcurrencyTest() {
     /**
      * Test that a notification does not get delayed in the queue waiting for the next event to push it through.
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Ignore("this is non-deterministic ... haven't figured out what's wrong with the test yet (benjchristensen: July 2014)")
     @Test
@@ -341,7 +341,7 @@ public void onNext(String t) {
      * The real issue in this example is the async buffer-bloat, so we need backpressure.
      *
      *
-     * @throws InterruptedException
+     * @throws InterruptedException if the await is interrupted
      */
     @Ignore("Demonstrates thread starvation problem. Read JavaDoc")
     @Test
@@ -586,7 +586,7 @@ public void onNext(String args) {
         /**
          * Assert the order of events is correct and return the number of onNext executions.
          *
-         * @param expectedEndingEvent
+         * @param expectedEndingEvent the last event
          * @return int count of onNext calls
          * @throws IllegalStateException
          *             If order of events was invalid.

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeToObservable.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.observers.DeferredScalarDisposable;
 
 /**
- * Wraps a MaybeSource and exposes it as a Flowable, relaying signals in a backpressure-aware manner
+ * Wraps a MaybeSource and exposes it as an Observable, relaying signals in a backpressure-aware manner
  * and composes cancellation through.
  *
  * @param <T> the value type

File: src/main/java/io/reactivex/internal/operators/single/SingleToObservable.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 
 /**
- * Wraps a Single and exposes it as a Flowable.
+ * Wraps a Single and exposes it as an Observable.
  *
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
Patch:
@@ -174,6 +174,7 @@ public void onComplete() {
         public void dispose() {
             worker.dispose();
             DisposableHelper.dispose(timer);
+            s.cancel();
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java
Patch:
@@ -174,6 +174,7 @@ public void onComplete() {
         public void dispose() {
             worker.dispose();
             DisposableHelper.dispose(this);
+            s.dispose();
         }
 
         @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java
Patch:
@@ -473,7 +473,7 @@ public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {
                             public boolean test(Integer w) throws Exception {
                                 return w % 2 == 0;
                             }
-                        }), 
+                        }),
                         v.filter(new Predicate<Integer>() {
                             @Override
                             public boolean test(Integer w) throws Exception {
@@ -500,7 +500,7 @@ public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {
                             public boolean test(Integer w) throws Exception {
                                 return w % 2 == 0;
                             }
-                        }), 
+                        }),
                         v.filter(new Predicate<Integer>() {
                             @Override
                             public boolean test(Integer w) throws Exception {
@@ -528,7 +528,7 @@ public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {
                             public boolean test(Integer w) throws Exception {
                                 return w % 2 == 0;
                             }
-                        }), 
+                        }),
                         v.filter(new Predicate<Integer>() {
                             @Override
                             public boolean test(Integer w) throws Exception {

File: src/main/java/io/reactivex/observers/TestObserver.java
Patch:
@@ -149,7 +149,7 @@ public void onNext(T t) {
         values.add(t);
 
         if (t == null) {
-            errors.add(new NullPointerException("onNext received a null Subscription"));
+            errors.add(new NullPointerException("onNext received a null value"));
         }
 
         actual.onNext(t);

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -207,7 +207,7 @@ public void onNext(T t) {
         values.add(t);
 
         if (t == null) {
-            errors.add(new NullPointerException("onNext received a null Subscription"));
+            errors.add(new NullPointerException("onNext received a null value"));
         }
 
         actual.onNext(t);
@@ -226,7 +226,7 @@ public void onError(Throwable t) {
             errors.add(t);
 
             if (t == null) {
-                errors.add(new IllegalStateException("onError received a null Subscription"));
+                errors.add(new IllegalStateException("onError received a null Throwable"));
             }
 
             actual.onError(t);

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -8884,7 +8884,7 @@ public final Observable<T> repeatUntil(BooleanSupplier stop) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) {
         ObjectHelper.requireNonNull(handler, "handler is null");
-        return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.repeatWhenHandler(handler), false));
+        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));
     }
 
     /**
@@ -9560,7 +9560,7 @@ public final Observable<T> retryUntil(final BooleanSupplier stop) {
     public final Observable<T> retryWhen(
             final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {
         ObjectHelper.requireNonNull(handler, "handler is null");
-        return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.retryWhenHandler(handler), true));
+        return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java
Patch:
@@ -40,7 +40,7 @@ static final class ScanSubscriber<T> implements Subscriber<T>, Subscription {
         Subscription s;
 
         T value;
-        
+
         boolean done;
 
         ScanSubscriber(Subscriber<? super T> actual, BiFunction<T, T, T> accumulator) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java
Patch:
@@ -52,7 +52,7 @@ static final class ScanSeedSubscriber<T, R> extends SinglePostCompleteSubscriber
         private static final long serialVersionUID = -1776795561228106469L;
 
         final BiFunction<R, ? super T, R> accumulator;
-        
+
         boolean done;
 
         ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T, R> accumulator, R value) {
@@ -66,7 +66,7 @@ public void onNext(T t) {
             if (done) {
                 return;
             }
-            
+
             R v = value;
 
             R u;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java
Patch:
@@ -40,7 +40,7 @@ static final class ScanObserver<T> implements Observer<T>, Disposable {
         Disposable s;
 
         T value;
-        
+
         boolean done;
 
         ScanObserver(Observer<? super T> actual, BiFunction<T, T, T> accumulator) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java
Patch:
@@ -304,7 +304,7 @@ public Object apply(Object a, Object b) throws Exception {
             }
         }, false, 1, 1, 0, 0);
     }
-    
+
     @Test
     public void testScanFunctionThrowsAndUpstreamErrorsDoesNotResultInTwoTerminalEvents() {
         final RuntimeException err = new RuntimeException();
@@ -338,7 +338,7 @@ public Integer apply(Integer t1, Integer t2) throws Exception {
             RxJavaPlugins.reset();
         }
     }
-    
+
     @Test
     public void testScanFunctionThrowsAndUpstreamCompletesDoesNotResultInTwoTerminalEvents() {
         final RuntimeException err = new RuntimeException();
@@ -360,7 +360,7 @@ public Integer apply(Integer t1, Integer t2) throws Exception {
         .assertError(err)
         .assertValue(1);
     }
-    
+
     @Test
     public void testScanFunctionThrowsAndUpstreamEmitsOnNextResultsInScanFunctionBeingCalledOnlyOnce() {
         final RuntimeException err = new RuntimeException();

File: src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
Patch:
@@ -100,7 +100,7 @@ public static boolean replace(AtomicReference<Disposable> field, Disposable d) {
     /**
      * Atomically disposes the Disposable in the field if not already disposed.
      * @param field the target field
-     * @return true if the curren thread managed to dispose the Disposable
+     * @return true if the current thread managed to dispose the Disposable
      */
     public static boolean dispose(AtomicReference<Disposable> field) {
         Disposable current = field.get();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java
Patch:
@@ -38,7 +38,7 @@ protected void subscribeActual(MaybeObserver<? super T> s) {
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(source, index, null));
+        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(source, index, null, false));
     }
 
     static final class ElementAtSubscriber<T> implements Subscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java
Patch:
@@ -42,7 +42,7 @@ protected void subscribeActual(SingleObserver<? super T> s) {
 
     @Override
     public Flowable<T> fuseToFlowable() {
-        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(source, index, defaultValue));
+        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(source, index, defaultValue, true));
     }
 
     static final class ElementAtSubscriber<T> implements Subscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java
Patch:
@@ -33,7 +33,7 @@ public void subscribeActual(MaybeObserver<? super T> t) {
 
     @Override
     public Observable<T> fuseToObservable() {
-        return RxJavaPlugins.onAssembly(new ObservableElementAt<T>(source, index, null));
+        return RxJavaPlugins.onAssembly(new ObservableElementAt<T>(source, index, null, false));
     }
 
     static final class ElementAtObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java
Patch:
@@ -39,7 +39,7 @@ public void subscribeActual(SingleObserver<? super T> t) {
 
     @Override
     public Observable<T> fuseToObservable() {
-        return RxJavaPlugins.onAssembly(new ObservableElementAt<T>(source, index, defaultValue));
+        return RxJavaPlugins.onAssembly(new ObservableElementAt<T>(source, index, defaultValue, true));
     }
 
     static final class ElementAtObserver<T> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReduceSeedSingle.java
Patch:
@@ -59,7 +59,7 @@ static final class ReduceSeedObserver<T, R> implements Subscriber<T>, Disposable
 
         Subscription s;
 
-        public ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {
+        ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {
             this.actual = actual;
             this.value = value;
             this.reducer = reducer;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableReduceMaybe.java
Patch:
@@ -55,7 +55,7 @@ static final class ReduceObserver<T> implements Observer<T>, Disposable {
 
         Disposable d;
 
-        public ReduceObserver(MaybeObserver<? super T> observer, BiFunction<T, T, T> reducer) {
+        ReduceObserver(MaybeObserver<? super T> observer, BiFunction<T, T, T> reducer) {
             this.actual = observer;
             this.reducer = reducer;
         }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableReduceSeedSingle.java
Patch:
@@ -57,7 +57,7 @@ static final class ReduceSeedObserver<T, R> implements Observer<T>, Disposable {
 
         Disposable d;
 
-        public ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {
+        ReduceSeedObserver(SingleObserver<? super R> actual, BiFunction<R, ? super T, R> reducer, R value) {
             this.actual = actual;
             this.value = value;
             this.reducer = reducer;

File: src/test/java/io/reactivex/InternalWrongNaming.java
Patch:
@@ -173,6 +173,8 @@ public void flowableNoObserver() throws Exception {
                 "FlowableLastMaybe",
                 "FlowableIgnoreElementsCompletable",
                 "FlowableReduceMaybe",
+                "FlowableReduceWithSingle",
+                "FlowableReduceSeedSingle",
                 "FlowableFlatMapCompletable",
                 "FlowableFlatMapCompletableCompletable",
                 "FlowableFlatMapSingle",

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeWhileTest.java
Patch:
@@ -228,7 +228,8 @@ public boolean test(Integer t1) {
         ts.assertNoErrors();
         ts.assertValue(1);
 
-        Assert.assertTrue("Not cancelled!", ts.isCancelled());
+        // 2.0.2 - not anymore
+//        Assert.assertTrue("Not cancelled!", ts.isCancelled());
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithObservableTest.java
Patch:
@@ -296,7 +296,9 @@ public Observable<String> call() {
         TestObserver<Observable<Integer>> ts = new TestObserver<Observable<Integer>>();
         source.window(boundary).subscribe(ts);
 
-        assertTrue("Not cancelled!", ts.isCancelled());
+        // 2.0.2 - not anymore
+        // assertTrue("Not cancelled!", ts.isCancelled());
+        ts.assertComplete();
     }
 
     @Test

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java
Patch:
@@ -226,7 +226,8 @@ public Observable<Integer> apply(Integer t) {
         ts.assertNoErrors();
         ts.assertValueCount(1);
 
-        assertTrue("Not cancelled!", ts.isCancelled());
+        // 2.0.2 - not anymore
+//        assertTrue("Not cancelled!", ts.isCancelled());
         assertFalse(open.hasObservers());
         assertFalse(close.hasObservers());
     }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromTest.java
Patch:
@@ -255,7 +255,8 @@ public void testNoDownstreamUnsubscribe() {
 
         source.onComplete();
 
-        assertTrue("Not cancelled!", ts.isCancelled());
+        // 2.0.2 - not anymore
+//        assertTrue("Not cancelled!", ts.isCancelled());
     }
 
 

File: src/main/java/io/reactivex/Scheduler.java
Patch:
@@ -215,7 +215,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
      * actions. Generally each {@link Flowable} uses its own {@link Worker}.
      * This means that this will essentially limit the number of concurrent
      * subscribes. The danger comes from using operators like
-     * {@link Flowable#zip(Flowable, Flowable, rx.functions.Func2)} where
+     * {@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.functions.BiFunction)} where
      * subscribing to the first {@link Flowable} could deadlock the
      * subscription to the second.
      * 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -8566,7 +8566,7 @@ public final Observable<T> repeatUntil(BooleanSupplier stop) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) {
         ObjectHelper.requireNonNull(handler, "handler is null");
-        return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.repeatWhenHandler(handler)));
+        return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.repeatWhenHandler(handler), false));
     }
 
     /**
@@ -9219,7 +9219,7 @@ public final Observable<T> retryUntil(final BooleanSupplier stop) {
     public final Observable<T> retryWhen(
             final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {
         ObjectHelper.requireNonNull(handler, "handler is null");
-        return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.retryWhenHandler(handler)));
+        return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.retryWhenHandler(handler), true));
     }
 
     /**

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -2919,7 +2919,7 @@ public final Observable<T> toObservable() {
 
     /**
      * Converts this Maybe into a Single instance composing cancellation
-     * through and turing an empty Maybe into a signal of NoSuchElementException.
+     * through and turning an empty Maybe into a signal of NoSuchElementException.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toSingle} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -2935,7 +2935,7 @@ public final Single<T> toSingle(T defaultValue) {
 
     /**
      * Converts this Maybe into a Single instance composing cancellation
-     * through and turing an empty Maybe into a signal of NoSuchElementException.
+     * through and turning an empty Maybe into a signal of NoSuchElementException.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toSingle} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -3445,7 +3445,7 @@ public final Disposable subscribe(Consumer<? super T> onSuccess) {
      * @return a {@link Disposable} reference with which the caller can stop receiving items before
      *         the Maybe has finished sending them
      * @see <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if {@code onSuccess} is null, or
      *             if {@code onError} is null
      */
@@ -3472,7 +3472,7 @@ public final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? supe
      *             Maybe
      * @return a {@link Disposable} reference with which the caller can stop receiving items before
      *         the Maybe has finished sending them
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if {@code onSuccess} is null, or
      *             if {@code onError} is null, or
      *             if {@code onComplete} is null

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2444,7 +2444,7 @@ public final Disposable subscribe() {
      *            (whichever is not null)
      * @return a {@link Disposable} reference can request the {@link Single} stop work.
      * @see <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if {@code onCallback} is null
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -2490,7 +2490,7 @@ public final Disposable subscribe(Consumer<? super T> onSuccess) {
      *            Single
      * @return a {@link Disposable} reference can request the {@link Single} stop work.
      * @see <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if {@code onSuccess} is null, or
      *             if {@code onError} is null
      */

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -11329,6 +11329,8 @@ public final <R> Flowable<R> scan(final R initialValue, BiFunction<R, ? super T,
      *     Publisher.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))
      * );
      * </code></pre>
+     * <p>
+     * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event.
      * <dl>
      *  <dt><b>Backpressure:</b><dt>
      *  <dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.

File: src/main/java/io/reactivex/internal/observers/ForEachWhileObserver.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -82,7 +82,7 @@ public void onError(Throwable t) {
             onError.accept(t);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
+            RxJavaPlugins.onError(new CompositeException(t, ex));
         }
     }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -142,9 +142,7 @@ void emit(long idx, T value) {
                 long r = get();
                 if (r != 0L) {
                     actual.onNext(value);
-                    if (r != Long.MAX_VALUE) {
-                        decrementAndGet();
-                    }
+                    BackpressureHelper.produced(this, 1);
                 } else {
                     cancel();
                     actual.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));

File: src/main/java/io/reactivex/internal/schedulers/IoScheduler.java
Patch:
@@ -74,8 +74,7 @@ static final class CachedWorkerPool implements Runnable {
             Future<?> task = null;
             if (unit != null) {
                 evictor = Executors.newScheduledThreadPool(1, EVICTOR_THREAD_FACTORY);
-                task = evictor.scheduleWithFixedDelay(this, this.keepAliveTime, this.keepAliveTime, TimeUnit.NANOSECONDS
-                );
+                task = evictor.scheduleWithFixedDelay(this, this.keepAliveTime, this.keepAliveTime, TimeUnit.NANOSECONDS);
             }
             evictorService = evictor;
             evictorTask = task;

File: src/test/java/io/reactivex/observable/ObservableScanTests.java
Patch:
@@ -23,7 +23,7 @@
 public class ObservableScanTests {
 
     @Test
-    public void testUnsubscribeScan() {
+    public void testUnsubscribeScan() throws Exception {
 
         ObservableEventStream.getEventStream("HTTP-ClusterB", 20)
         .scan(new HashMap<String, String>(), new BiFunction<HashMap<String, String>, Event, HashMap<String, String>>() {
@@ -40,5 +40,7 @@ public void accept(HashMap<String, String> pv) {
                 System.out.println(pv);
             }
         });
+
+        Thread.sleep(200); // make sure the event streams receive their interrupt
     }
 }
\ No newline at end of file

File: src/test/java/io/reactivex/observable/ObservableZipTests.java
Patch:
@@ -28,7 +28,7 @@
 public class ObservableZipTests {
 
     @Test
-    public void testZipObservableOfObservables() {
+    public void testZipObservableOfObservables() throws Exception {
         ObservableEventStream.getEventStream("HTTP-ClusterB", 20)
                 .groupBy(new Function<Event, String>() {
                     @Override
@@ -63,6 +63,8 @@ public void accept(Object pv) {
                 });
 
         System.out.println("**** finished");
+
+        Thread.sleep(200); // make sure the event streams receive their interrupt
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromFuture.java
Patch:
@@ -46,8 +46,6 @@ public void subscribeActual(Subscriber<? super T> s) {
                 s.onError(ex);
             }
             return;
-        } finally {
-            future.cancel(true); // TODO ?? not sure about this
         }
         if (v == null) {
             s.onError(new NullPointerException("The future returned null"));

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
Patch:
@@ -390,9 +390,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable t) {
-            if (sourceMode != QueueSubscription.ASYNC) {
-                parent.error(this, t);
-            }
+            parent.error(this, t);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/util/BackpressureHelper.java
Patch:
@@ -100,7 +100,7 @@ public static long addCancel(AtomicLong requested, long n) {
     }
 
     /**
-     * Atomically subtract the given number (positive, not validated) from the target field.
+     * Atomically subtract the given number (positive, not validated) from the target field unless it contains Long.MAX_VALUE.
      * @param requested the target field holding the current requested amount
      * @param n the produced element count, positive (not validated)
      * @return the new amount
@@ -124,7 +124,7 @@ public static long produced(AtomicLong requested, long n) {
 
     /**
      * Atomically subtract the given number (positive, not validated) from the target field if
-     * it doesn't contain Long.MIN_VALUE (indicating some cancelled state).
+     * it doesn't contain Long.MIN_VALUE (indicating some cancelled state) or Long.MAX_VALUE (unbounded mode).
      * @param requested the target field holding the current requested amount
      * @param n the produced element count, positive (not validated)
      * @return the new amount

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToFutureTest.java
Patch:
@@ -45,7 +45,7 @@ public void testSuccess() throws Exception {
         verify(o, times(1)).onNext(value);
         verify(o, times(1)).onComplete();
         verify(o, never()).onError(any(Throwable.class));
-        verify(future, times(1)).cancel(true);
+        verify(future, never()).cancel(anyBoolean());
     }
 
     @Test
@@ -87,7 +87,7 @@ public void testFailure() throws Exception {
         verify(o, never()).onNext(null);
         verify(o, never()).onComplete();
         verify(o, times(1)).onError(e);
-        verify(future, times(1)).cancel(true);
+        verify(future, never()).cancel(anyBoolean());
     }
 
     @Test

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -18,11 +18,10 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.functions.ObjectHelper;
-import io.reactivex.internal.fuseable.*;
+import io.reactivex.internal.fuseable.QueueFuseable;
 import io.reactivex.internal.subscribers.BasicFuseableSubscriber;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.plugins.RxJavaPlugins;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -17,12 +17,10 @@
 import java.util.concurrent.Callable;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.functions.ObjectHelper;
-import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.observers.BasicFuseableObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java
Patch:
@@ -14,7 +14,6 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.observers.BasicFuseableObserver;
 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -6333,7 +6333,7 @@ public final <K> Observable<T> distinct(Function<? super T, K> keySelector, Call
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> distinctUntilChanged() {
-        return new ObservableDistinctUntilChanged<T>(this, Functions.equalsPredicate());
+        return distinctUntilChanged(Functions.identity());
     }
 
     /**
@@ -6357,7 +6357,7 @@ public final Observable<T> distinctUntilChanged() {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySelector) {
         ObjectHelper.requireNonNull(keySelector, "keySelector is null");
-        return new ObservableDistinctUntilChanged<T>(this, Functions.equalsPredicate(keySelector));
+        return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));
     }
 
     /**
@@ -6380,7 +6380,7 @@ public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySe
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {
         ObjectHelper.requireNonNull(comparer, "comparer is null");
-        return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T>(this, comparer));
+        return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));
     }
 
     /**

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -1167,14 +1167,14 @@ public void distinctUntilChangedBiPredicateNull() {
         just1.distinctUntilChanged((BiPredicate<Integer, Integer>)null);
     }
 
-    @Test(expected = NullPointerException.class)
+    @Test
     public void distinctUntilChangedFunctionReturnsNull() {
         Flowable.range(1, 2).distinctUntilChanged(new Function<Integer, Object>() {
             @Override
             public Object apply(Integer v) {
                 return null;
             }
-        }).blockingSubscribe();
+        }).test().assertResult(1);
     }
 
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -1257,14 +1257,14 @@ public void distinctUntilChangedBiPredicateNull() {
         just1.distinctUntilChanged((BiPredicate<Object, Object>)null);
     }
 
-    @Test(expected = NullPointerException.class)
+    @Test
     public void distinctUntilChangedFunctionReturnsNull() {
         Observable.range(1, 2).distinctUntilChanged(new Function<Integer, Object>() {
             @Override
             public Object apply(Integer v) {
                 return null;
             }
-        }).blockingSubscribe();
+        }).test().assertResult(1);
     }
 
     @Test(expected = NullPointerException.class)

File: src/main/java/io/reactivex/disposables/Disposables.java
Patch:
@@ -66,9 +66,9 @@ public static Disposable fromFuture(Future<?> future) {
     }
 
     /**
-     * Construct a Disposable by wrapping a Runnable that is
-     * executed exactly once when the Disposable is disposed.
-     * @param future the Runnable to wrap
+     * Construct a Disposable by wrapping a Future that is
+     * cancelled exactly once when the Disposable is disposed.
+     * @param future the Future to wrap
      * @param allowInterrupt if true, the future cancel happens via Future.cancel(true)
      * @return the new Disposable instance
      */

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java
Patch:
@@ -170,10 +170,10 @@ public void request(long n) {
         void innerSuccess(InnerObserver inner, R value) {
             set.delete(inner);
             if (get() == 0 && compareAndSet(0, 1)) {
+                boolean d = active.decrementAndGet() == 0;
                 if (requested.get() != 0) {
                     actual.onNext(value);
 
-                    boolean d = active.decrementAndGet() == 0;
                     SpscLinkedArrayQueue<R> q = queue.get();
 
                     if (d && (q == null || q.isEmpty())) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java
Patch:
@@ -170,10 +170,10 @@ public void request(long n) {
         void innerSuccess(InnerObserver inner, R value) {
             set.delete(inner);
             if (get() == 0 && compareAndSet(0, 1)) {
+                boolean d = active.decrementAndGet() == 0;
                 if (requested.get() != 0) {
                     actual.onNext(value);
 
-                    boolean d = active.decrementAndGet() == 0;
                     SpscLinkedArrayQueue<R> q = queue.get();
 
                     if (d && (q == null || q.isEmpty())) {

File: src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
Patch:
@@ -20,13 +20,13 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.fuseable.SimplePlainQueue;
 
 /**
  * A multi-producer single consumer unbounded queue.
  * @param <T> the contained value type
  */
-public final class MpscLinkedQueue<T> implements SimpleQueue<T> {
+public final class MpscLinkedQueue<T> implements SimplePlainQueue<T> {
     private final AtomicReference<LinkedQueueNode<T>> producerNode;
     private final AtomicReference<LinkedQueueNode<T>> consumerNode;
 

File: src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.concurrent.atomic.*;
 
-import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.fuseable.SimplePlainQueue;
 import io.reactivex.internal.util.Pow2;
 
 /**
@@ -37,7 +37,7 @@
  *
  * @param <E>
  */
-public final class SpscArrayQueue<E> extends AtomicReferenceArray<E> implements SimpleQueue<E> {
+public final class SpscArrayQueue<E> extends AtomicReferenceArray<E> implements SimplePlainQueue<E> {
     private static final long serialVersionUID = -1296597691183856449L;
     private static final Integer MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctools.spsc.max.lookahead.step", 4096);
     final int mask;

File: src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
Patch:
@@ -20,15 +20,15 @@
 
 import java.util.concurrent.atomic.*;
 
-import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.fuseable.SimplePlainQueue;
 import io.reactivex.internal.util.Pow2;
 
 /**
  * A single-producer single-consumer array-backed queue which can allocate new arrays in case the consumer is slower
  * than the producer.
  * @param <T> the contained value type
  */
-public final class SpscLinkedArrayQueue<T> implements SimpleQueue<T> {
+public final class SpscLinkedArrayQueue<T> implements SimplePlainQueue<T> {
     static final int MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctools.spsc.max.lookahead.step", 4096);
     final AtomicLong producerIndex = new AtomicLong();
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeLongTest.java
Patch:
@@ -378,7 +378,6 @@ public void conditionalSlowPathRebatch() {
     @Test
     public void slowPathRebatch() {
         Flowable.rangeLong(1L, 5L)
-        .filter(Functions.alwaysTrue())
         .rebatchRequests(1)
         .test()
         .assertResult(1L, 2L, 3L, 4L, 5L);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycle.java
Patch:
@@ -46,7 +46,7 @@ static final class SubscriptionLambdaSubscriber<T> implements Subscriber<T>, Sub
 
         Subscription s;
 
-        public SubscriptionLambdaSubscriber(Subscriber<? super T> actual,
+        SubscriptionLambdaSubscriber(Subscriber<? super T> actual,
                 Consumer<? super Subscription> onSubscribe,
                 LongConsumer onRequest,
                 Action onCancel) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
Patch:
@@ -264,7 +264,7 @@ void drain() {
                     }
                 }
 
-                if (e != 0L && r != Long.MAX_VALUE) {
+                if (e != 0L) {
                     BackpressureHelper.produced(requested, e);
                 }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReduce.java
Patch:
@@ -13,8 +13,6 @@
 
 package io.reactivex.internal.operators.flowable;
 
-import java.util.NoSuchElementException;
-
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.Exceptions;
@@ -108,7 +106,7 @@ public void onComplete() {
             if (v != null) {
                 complete(v);
             } else {
-                actual.onError(new NoSuchElementException());
+                actual.onComplete();
             }
         }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
Patch:
@@ -132,7 +132,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
-                RxJavaPlugins.onError(error);
+                RxJavaPlugins.onError(t);
                 return;
             }
             error = t;

File: src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterable.java
Patch:
@@ -39,7 +39,7 @@ public Iterator<T> iterator() {
         source.subscribe(it);
         return it;
     }
-    
+
     static final class BlockingObservableIterator<T>
     extends AtomicReference<Disposable>
     implements io.reactivex.Observer<T>, Iterator<T>, Disposable {
@@ -56,7 +56,7 @@ static final class BlockingObservableIterator<T>
         volatile boolean done;
         Throwable error;
 
-        public BlockingObservableIterator(int batchSize) {
+        BlockingObservableIterator(int batchSize) {
             this.queue = new SpscLinkedArrayQueue<T>(batchSize);
             this.lock = new ReentrantLock();
             this.condition = lock.newCondition();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
Patch:
@@ -96,7 +96,8 @@ public void onSubscribe(Disposable s) {
                 if (boundary.compareAndSet(null, os)) {
                     windows.getAndIncrement();
                     open.subscribe(os);
-                }            }
+                }
+            }
         }
 
         @Override

File: src/test/java/io/reactivex/TestHelper.java
Patch:
@@ -611,17 +611,17 @@ public void onSubscribe(Subscription s) {
 
                 s.cancel();
             }
-            
+
             @Override
             public void onNext(Object t) {
                 ts.onNext(t);
             }
-            
+
             @Override
             public void onError(Throwable t) {
                 ts.onError(t);
             }
-            
+
             @Override
             public void onComplete() {
                 ts.onComplete();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorResumeNextViaFlowableTest.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
-public class FlowableOnErrorResumeNextViaObservableTest {
+public class FlowableOnErrorResumeNextViaFlowableTest {
 
     @Test
     public void testResumeNext() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnExceptionResumeNextViaFlowableTest.java
Patch:
@@ -28,7 +28,7 @@
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
-public class FlowableOnExceptionResumeNextViaObservableTest {
+public class FlowableOnExceptionResumeNextViaFlowableTest {
 
     @Test
     public void testResumeNextWithException() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableScalarXMapTest.java
Patch:
@@ -238,11 +238,11 @@ public void run() {
     @Test
     public void cancelled() {
         ScalarSubscription<Integer> scalar = new ScalarSubscription<Integer>(new TestSubscriber<Integer>(), 1);
-        
+
         assertFalse(scalar.isCancelled());
-        
+
         scalar.cancel();
-        
+
         assertTrue(scalar.isCancelled());
     }
 }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRedoTest.java
Patch:
@@ -25,7 +25,7 @@ public class ObservableRedoTest {
     @Test
     public void redoCancel() {
         final TestObserver<Integer> to = new TestObserver<Integer>();
-        
+
         Observable.just(1)
         .repeatWhen(new Function<Observable<Object>, ObservableSource<Object>>() {
             @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlattenIterable.java
Patch:
@@ -121,6 +121,7 @@ public void onError(Throwable e) {
                 RxJavaPlugins.onError(e);
                 return;
             }
+            d = DisposableHelper.DISPOSED;
             actual.onError(e);
         }
 
@@ -129,6 +130,7 @@ public void onComplete() {
             if (d == DisposableHelper.DISPOSED) {
                 return;
             }
+            d = DisposableHelper.DISPOSED;
             actual.onComplete();
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
Patch:
@@ -20,6 +20,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.SequentialDisposable;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.observers.ToNotificationObserver;
 import io.reactivex.subjects.*;
 
@@ -44,7 +45,7 @@ public void subscribeActual(Observer<? super T> s) {
         ObservableSource<?> action;
 
         try {
-            action = manager.apply(subject);
+            action = ObjectHelper.requireNonNull(manager.apply(subject), "The function returned a null ObservableSource");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             s.onError(ex);

File: src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
Patch:
@@ -106,7 +106,9 @@ else if (currConsumerNode != lvProducerNode()) {
 
     @Override
     public boolean offer(T v1, T v2) {
-        return offer(v1) && offer(v2);
+        offer(v1);
+        offer(v2);
+        return true;
     }
 
     @Override

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToIteratorTest.java
Patch:
@@ -24,6 +24,7 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.operators.observable.BlockingObservableIterable.BlockingObservableIterator;
 
 public class BlockingObservableToIteratorTest {
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.functions.ObjectHelper;
 import java.util.Collection;
 import java.util.concurrent.Callable;
 
@@ -33,7 +34,7 @@ public FlowableToList(Publisher<T> source, Callable<U> collectionSupplier) {
     protected void subscribeActual(Subscriber<? super U> s) {
         U coll;
         try {
-            coll = collectionSupplier.call();
+            coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptySubscription.error(e, s);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableToListSingle.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.functions.ObjectHelper;
 import java.util.Collection;
 import java.util.concurrent.Callable;
 
@@ -47,7 +48,7 @@ public FlowableToListSingle(Publisher<T> source, Callable<U> collectionSupplier)
     protected void subscribeActual(SingleObserver<? super U> s) {
         U coll;
         try {
-            coll = collectionSupplier.call();
+            coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptyDisposable.error(e, s);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableToList.java
Patch:
@@ -42,7 +42,7 @@ public ObservableToList(ObservableSource<T> source, Callable<U> collectionSuppli
     public void subscribeActual(Observer<? super U> t) {
         U coll;
         try {
-            coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null Collection");
+            coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptyDisposable.error(e, t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableToListSingle.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.internal.functions.ObjectHelper;
 import java.util.*;
 import java.util.concurrent.Callable;
 
@@ -48,7 +49,7 @@ public ObservableToListSingle(ObservableSource<T> source, Callable<U> collection
     public void subscribeActual(SingleObserver<? super U> t) {
         U coll;
         try {
-            coll = collectionSupplier.call();
+            coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             EmptyDisposable.error(e, t);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java
Patch:
@@ -38,6 +38,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
 
     static final class BackpressureErrorSubscriber<T>
             extends AtomicLong implements Subscriber<T>, Subscription {
+        private static final long serialVersionUID = -3176480756392482682L;
 
         final Subscriber<? super T> actual;
         Subscription s;

File: src/test/java/io/reactivex/TransformerTest.java
Patch:
@@ -15,8 +15,6 @@
 
 import static org.junit.Assert.*;
 
-import java.io.IOException;
-
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
Patch:
@@ -13,8 +13,6 @@
 
 package io.reactivex.internal.operators.flowable;
 
-import static org.junit.Assert.*;
-
 import org.junit.*;
 import org.reactivestreams.*;
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java
Patch:
@@ -52,7 +52,7 @@ public void toFlowableLatest() {
 
     @Test
     public void toFlowableError1() {
-        TestSubscriber<Integer> ts = Observable.range(1, 5)
+        Observable.range(1, 5)
         .toFlowable(BackpressureStrategy.ERROR)
         .test(1)
         .assertFailure(MissingBackpressureException.class, 1);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -125,7 +125,9 @@ public void onComplete() {
             if (!DisposableHelper.isDisposed(d)) {
                 @SuppressWarnings("unchecked")
                 DebounceEmitter<T> de = (DebounceEmitter<T>)d;
-                de.emit();
+                if (de != null) {
+                    de.emit();
+                }
                 DisposableHelper.dispose(timer);
                 worker.dispose();
                 actual.onComplete();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
Patch:
@@ -52,6 +52,9 @@ public void onSubscribe(Subscription s) {
         @Override
         public void onNext(Notification<T> t) {
             if (done) {
+                if (t.isOnError()) {
+                    RxJavaPlugins.onError(t.getError());
+                }
                 return;
             }
             if (t.isOnError()) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
Patch:
@@ -97,7 +97,7 @@ public void subscribe(Subscriber<? super T> child) {
                  * Note: although technically correct, concurrent disconnects can cause
                  * unexpected behavior such as child subscribers never receiving anything
                  * (unless connected again). An alternative approach, similar to
-                 * PublishSubject would be to immediately terminate such child
+                 * PublishProcessor would be to immediately terminate such child
                  * subscribers as well:
                  *
                  * Object term = r.terminalEvent;
@@ -172,7 +172,7 @@ public void connect(Consumer<? super Disposable> connection) {
          * Disposable as subscribe() may never return on its own.
          *
          * Note however, that asynchronously disconnecting a running source might leave
-         * child subscribers without any terminal event; PublishSubject does not have this
+         * child subscribers without any terminal event; PublishProcessor does not have this
          * issue because the cancellation was always triggered by the child subscribers
          * themselves.
          */

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
Patch:
@@ -18,6 +18,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class FlowableTakeUntilPredicate<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
@@ -75,6 +76,8 @@ public void onError(Throwable t) {
             if (!done) {
                 done = true;
                 actual.onError(t);
+            } else {
+                RxJavaPlugins.onError(t);
             }
         }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
Patch:
@@ -1522,7 +1522,6 @@ public Collection<Object> call() throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.range(1, 5).buffer(1, TimeUnit.DAYS, Schedulers.single()));
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
Patch:
@@ -299,7 +299,6 @@ public void take() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.range(1, 5).cache());
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -1230,7 +1230,6 @@ public Object apply(Object a, Object b) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(Flowable.combineLatest(Flowable.never(), Flowable.never(), new BiFunction<Object, Object, Object>() {
             @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
Patch:
@@ -831,7 +831,6 @@ public Flowable<Integer> apply(Integer v) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).hide().concatMapEager(new Function<Integer, Flowable<Integer>>() {
             @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java
Patch:
@@ -161,7 +161,6 @@ public void subscribe(Subscriber<? super Object> t) {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.never().onTerminateDetach());
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
Patch:
@@ -113,7 +113,6 @@ public void accept(Object d) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.generate(new Callable<Object>() {
                 @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
Patch:
@@ -595,7 +595,6 @@ private enum CancelledSubscriber implements Subscriber<Integer> {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(Flowable.just(1).publish().refCount());
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -354,7 +354,7 @@ public void testRetrySubscribesAgainAfterError() throws Exception {
         Consumer<Integer> throwException = mock(Consumer.class);
         doThrow(new RuntimeException()).when(throwException).accept(Mockito.anyInt());
 
-        // create a retrying observable based on a PublishSubject
+        // create a retrying observable based on a PublishProcessor
         PublishProcessor<Integer> subject = PublishProcessor.create();
         subject
         // record item

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
Patch:
@@ -359,7 +359,6 @@ public void run() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposedFlowable() {
         TestHelper.checkDisposed(Flowable.sequenceEqual(Flowable.just(1), Flowable.just(2)).toFlowable());
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTest.java
Patch:
@@ -109,7 +109,6 @@ public void testSkipLastWithNegativeCount() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).skipLast(1));
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
Patch:
@@ -163,7 +163,6 @@ public void throttleFirstDefaultScheduler() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).throttleFirst(1, TimeUnit.DAYS));
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
Patch:
@@ -124,7 +124,6 @@ public Long apply(Timed<Integer> v) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).timeInterval());
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
Patch:
@@ -387,7 +387,6 @@ public void timedAndOther() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(PublishProcessor.create().timeout(1, TimeUnit.DAYS));
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java
Patch:
@@ -284,7 +284,6 @@ public void onComplete() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(Flowable.timer(1, TimeUnit.DAYS));
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
Patch:
@@ -121,7 +121,7 @@ public void testBackpressureHonoredFlowable() {
         ts.assertComplete();
     }
     @Test(timeout = 2000)
-    @Ignore("PublishSubject no longer emits without requests so this test fails due to the race of onComplete and request")
+    @Ignore("PublishProcessor no longer emits without requests so this test fails due to the race of onComplete and request")
     public void testAsyncRequestedFlowable() {
         Scheduler.Worker w = Schedulers.newThread().createWorker();
         try {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
Patch:
@@ -92,7 +92,7 @@ public void testBackpressureHonoredFlowable() {
     }
 
     @Test(timeout = 2000)
-    @Ignore("PublishSubject no longer emits without requests so this test fails due to the race of onComplete and request")
+    @Ignore("PublishProcessor no longer emits without requests so this test fails due to the race of onComplete and request")
     public void testAsyncRequestedFlowable() {
         Scheduler.Worker w = Schedulers.newThread().createWorker();
         try {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLast.java
Patch:
@@ -70,9 +70,6 @@ public void onError(Throwable t) {
 
         @Override
         public void onComplete() {
-            if (cancelled) {
-                return;
-            }
             Observer<? super T> a = actual;
             for (;;) {
                 if (cancelled) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -40,7 +40,7 @@ public class ObservableRefCountTest {
     public void testRefCountAsync() {
         final AtomicInteger subscribeCount = new AtomicInteger();
         final AtomicInteger nextCount = new AtomicInteger();
-        Observable<Long> r = Observable.interval(0, 5, TimeUnit.MILLISECONDS)
+        Observable<Long> r = Observable.interval(0, 25, TimeUnit.MILLISECONDS)
                 .doOnSubscribe(new Consumer<Disposable>() {
                     @Override
                     public void accept(Disposable s) {
@@ -67,7 +67,7 @@ public void accept(Long l) {
 
         // give time to emit
         try {
-            Thread.sleep(52);
+            Thread.sleep(260);
         } catch (InterruptedException e) {
         }
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableScalarXMapTest.java
Patch:
@@ -187,7 +187,7 @@ public void scalarDisposableStateCheck() {
 
         assertFalse(sd.isDisposed());
 
-        assertFalse(sd.isEmpty());
+        assertTrue(sd.isEmpty());
 
         sd.run();
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -44,7 +44,7 @@ protected void subscribeActual(Subscriber<? super T> observer) {
         Collection<? super K> collection;
 
         try {
-            collection = collectionSupplier.call();
+            collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptySubscription.error(ex, observer);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -43,7 +43,7 @@ protected void subscribeActual(Observer<? super T> observer) {
         Collection<? super K> collection;
 
         try {
-            collection = collectionSupplier.call();
+            collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptyDisposable.error(ex, observer);

File: src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java
Patch:
@@ -54,7 +54,8 @@ public void dispose() {
 
     @Override
     public boolean isDisposed() {
-        return cancelled;
+        Disposable d = resource;
+        return d != null ? d.isDisposed() : cancelled;
     }
 
     void disposeResource() {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeInterval.java
Patch:
@@ -53,6 +53,7 @@ static final class TimeIntervalObserver<T> implements Observer<T>, Disposable {
         @Override
         public void onSubscribe(Disposable s) {
             if (DisposableHelper.validate(this.s, s)) {
+                this.s = s;
                 lastTime = scheduler.now(unit);
                 actual.onSubscribe(this);
             }

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -1259,7 +1259,7 @@ public void distinctUntilChangedBiPredicateNull() {
 
     @Test(expected = NullPointerException.class)
     public void distinctUntilChangedFunctionReturnsNull() {
-        just1.distinctUntilChanged(new Function<Integer, Object>() {
+        Observable.range(1, 2).distinctUntilChanged(new Function<Integer, Object>() {
             @Override
             public Object apply(Integer v) {
                 return null;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -794,7 +794,7 @@ public Long apply(Long t1, Integer t2) {
             }
         }).subscribe(ts);
 
-        if (!latch.await(SIZE + 1000, TimeUnit.MILLISECONDS)) {
+        if (!latch.await(SIZE + 2000, TimeUnit.MILLISECONDS)) {
             fail("timed out");
         }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java
Patch:
@@ -87,7 +87,7 @@ public void onError(Throwable t) {
 
         @Override
         public void onComplete() {
-            if (index <= count && !done) {
+            if (!done) {
                 done = true;
                 T v = defaultValue;
                 if (v == null) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAt.java
Patch:
@@ -96,7 +96,7 @@ public void onError(Throwable t) {
 
         @Override
         public void onComplete() {
-            if (index <= count && !done) {
+            if (!done) {
                 done = true;
                 T v = defaultValue;
                 if (v != null) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupJoin.java
Patch:
@@ -469,7 +469,7 @@ public void onNext(Object t) {
 
         @Override
         public void onError(Throwable t) {
-            parent.innerError(t);
+            parent.innerCloseError(t);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
Patch:
@@ -334,6 +334,7 @@ public void onSubscribe(Disposable s) {
                 ConsumerIndexHolder consumerIndexHolder = new ConsumerIndexHolder(producerIndex, this);
                 if (restartTimerOnMaxSize) {
                     Scheduler.Worker sw = scheduler.createWorker();
+                    worker = sw;
                     sw.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);
                     d = sw;
                 } else {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
Patch:
@@ -131,7 +131,7 @@ public void subscribe(Subscriber<? super String> observer) {
             }
         });
 
-        Flowable<List<String>> buffered = source.buffer(100, TimeUnit.MILLISECONDS, 2, scheduler);
+        Flowable<List<String>> buffered = source.buffer(100, TimeUnit.MILLISECONDS, scheduler, 2);
         buffered.subscribe(observer);
 
         InOrder inOrder = Mockito.inOrder(observer);
@@ -663,7 +663,7 @@ public void bufferWithTimeThrows() {
     public void bufferWithTimeAndSize() {
         Flowable<Long> source = Flowable.interval(30, 30, TimeUnit.MILLISECONDS, scheduler);
 
-        Flowable<List<Long>> result = source.buffer(100, TimeUnit.MILLISECONDS, 2, scheduler).take(3);
+        Flowable<List<Long>> result = source.buffer(100, TimeUnit.MILLISECONDS, scheduler, 2).take(3);
 
         Subscriber<Object> o = TestHelper.mockSubscriber();
         InOrder inOrder = inOrder(o);

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -4549,7 +4549,7 @@ public final T blockingLast(T defaultItem) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Iterable<T> blockingLatest() {
-        return BlockingObservableLatest.latest(this);
+        return new BlockingObservableLatest<T>(this);
     }
 
     /**
@@ -4571,7 +4571,7 @@ public final Iterable<T> blockingLatest() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Iterable<T> blockingMostRecent(T initialValue) {
-        return BlockingObservableMostRecent.mostRecent(this, initialValue);
+        return new BlockingObservableMostRecent<T>(this, initialValue);
     }
 
     /**
@@ -4590,7 +4590,7 @@ public final Iterable<T> blockingMostRecent(T initialValue) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Iterable<T> blockingNext() {
-        return BlockingObservableNext.next(this);
+        return new BlockingObservableNext<T>(this);
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDetach.java
Patch:
@@ -55,8 +55,7 @@ public void dispose() {
 
         @Override
         public boolean isDisposed() {
-            Disposable s = this.s;
-            return s == null || s.isDisposed();
+            return s.isDisposed();
         }
 
         @Override

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
Patch:
@@ -132,7 +132,7 @@ public void accept(Integer t1) {
                         if (count.incrementAndGet() == 500000) {
                             // give it a small break halfway through
                             try {
-                                Thread.sleep(5);
+                                Thread.sleep(10);
                             } catch (InterruptedException ex) {
                                 // ignored
                             }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java
Patch:
@@ -13,7 +13,6 @@
 
 package io.reactivex.internal.operators.completable;
 
-import io.reactivex.internal.functions.ObjectHelper;
 import java.util.Iterator;
 import java.util.concurrent.atomic.*;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorNext.java
Patch:
@@ -94,7 +94,7 @@ public void onError(Throwable t) {
                 p = nextSupplier.apply(t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -85,7 +85,7 @@ public void onError(Throwable t) {
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 state.lazySet(HAS_REQUEST_HAS_VALUE);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java
Patch:
@@ -74,7 +74,7 @@ public void onError(Throwable t) {
                 b = predicate.test(++retries, t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
             if (!b) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java
Patch:
@@ -84,7 +84,7 @@ public void onError(Throwable t) {
                     b = predicate.test(t);
                 } catch (Throwable e) {
                     Exceptions.throwIfFatal(e);
-                    actual.onError(new CompositeException(e, t));
+                    actual.onError(new CompositeException(t, e));
                     return;
                 }
                 if (!b) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableUsing.java
Patch:
@@ -61,7 +61,7 @@ public void subscribeActual(Subscriber<? super T> s) {
                 disposer.accept(resource);
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
-                EmptySubscription.error(new CompositeException(ex, e), s);
+                EmptySubscription.error(new CompositeException(e, ex), s);
                 return;
             }
             EmptySubscription.error(e, s);
@@ -119,7 +119,7 @@ public void onError(Throwable t) {
 
                 s.cancel();
                 if (innerError != null) {
-                    actual.onError(new CompositeException(innerError, t));
+                    actual.onError(new CompositeException(t, innerError));
                 } else {
                     actual.onError(t);
                 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -194,7 +194,7 @@ public void onError(Throwable t) {
                 predicate.test(null); // special case: poison pill
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
             actual.onError(t);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableOnErrorNext.java
Patch:
@@ -91,7 +91,7 @@ public void onError(Throwable t) {
                 p = nextSupplier.apply(t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturn.java
Patch:
@@ -73,7 +73,7 @@ public void onError(Throwable t) {
                 v = valueSupplier.apply(t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryBiPredicate.java
Patch:
@@ -72,7 +72,7 @@ public void onError(Throwable t) {
                 b = predicate.test(++retries, t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                actual.onError(new CompositeException(e, t));
+                actual.onError(new CompositeException(t, e));
                 return;
             }
             if (!b) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryPredicate.java
Patch:
@@ -82,7 +82,7 @@ public void onError(Throwable t) {
                     b = predicate.test(t);
                 } catch (Throwable e) {
                     Exceptions.throwIfFatal(e);
-                    actual.onError(new CompositeException(e, t));
+                    actual.onError(new CompositeException(t, e));
                     return;
                 }
                 if (!b) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableUsing.java
Patch:
@@ -60,7 +60,7 @@ public void subscribeActual(Observer<? super T> s) {
                 disposer.accept(resource);
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
-                EmptyDisposable.error(new CompositeException(ex, e), s);
+                EmptyDisposable.error(new CompositeException(e, ex), s);
                 return;
             }
             EmptyDisposable.error(e, s);
@@ -111,7 +111,7 @@ public void onError(Throwable t) {
                         disposer.accept(resource);
                     } catch (Throwable e) {
                         Exceptions.throwIfFatal(e);
-                        t = new CompositeException(e, t);
+                        t = new CompositeException(t, e);
                     }
                 }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDoOnEvent.java
Patch:
@@ -52,7 +52,7 @@ public void onError(Throwable e) {
                     onEvent.accept(e);
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    e = new CompositeException(ex, e);
+                    e = new CompositeException(e, ex);
                 }
 
                 s.onError(e);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java
Patch:
@@ -37,6 +37,7 @@ public CompletableResumeNext(CompletableSource source,
     protected void subscribeActual(final CompletableObserver s) {
 
         final SequentialDisposable sd = new SequentialDisposable();
+        s.onSubscribe(sd);
         source.subscribe(new CompletableObserver() {
 
             @Override

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithObservable.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.operators.single.SingleDelayWithCompletable.DelayWithMainObserver;
+import io.reactivex.internal.observers.ResumeSingleObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class SingleDelayWithObservable<T, U> extends Single<T> {
@@ -85,7 +85,7 @@ public void onComplete() {
                 return;
             }
             done = true;
-            source.subscribe(new DelayWithMainObserver<T>(this, actual));
+            source.subscribe(new ResumeSingleObserver<T>(this, actual));
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.operators.single.SingleDelayWithCompletable.DelayWithMainObserver;
+import io.reactivex.internal.observers.ResumeSingleObserver;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -93,7 +93,7 @@ public void onComplete() {
                 return;
             }
             done = true;
-            source.subscribe(new DelayWithMainObserver<T>(this, actual));
+            source.subscribe(new ResumeSingleObserver<T>(this, actual));
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithSingle.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.operators.single.SingleDelayWithCompletable.DelayWithMainObserver;
+import io.reactivex.internal.observers.ResumeSingleObserver;
 
 public final class SingleDelayWithSingle<T, U> extends Single<T> {
 
@@ -62,7 +62,7 @@ public void onSubscribe(Disposable d) {
 
         @Override
         public void onSuccess(U value) {
-            source.subscribe(new DelayWithMainObserver<T>(this, actual));
+            source.subscribe(new ResumeSingleObserver<T>(this, actual));
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/single/SingleDoOnError.java
Patch:
@@ -49,7 +49,7 @@ public void onError(Throwable e) {
                     onError.accept(e);
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    e = new CompositeException(ex, e);
+                    e = new CompositeException(e, ex);
                 }
                 s.onError(e);
             }

File: src/main/java/io/reactivex/internal/operators/single/SingleDoOnEvent.java
Patch:
@@ -59,7 +59,7 @@ public void onError(Throwable e) {
                     onEvent.accept(null, e);
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    e = new CompositeException(ex, e);
+                    e = new CompositeException(e, ex);
                 }
                 s.onError(e);
             }

File: src/main/java/io/reactivex/internal/operators/single/SingleEquals.java
Patch:
@@ -67,6 +67,7 @@ public void onError(Throwable e) {
                         return;
                     }
                     if (count.compareAndSet(state, 2)) {
+                        set.dispose();
                         s.onError(e);
                         return;
                     }

File: src/main/java/io/reactivex/internal/operators/single/SingleOnErrorReturn.java
Patch:
@@ -48,7 +48,7 @@ public void onError(Throwable e) {
                         v = valueSupplier.apply(e);
                     } catch (Throwable ex) {
                         Exceptions.throwIfFatal(ex);
-                        s.onError(new CompositeException(ex, e));
+                        s.onError(new CompositeException(e, ex));
                         return;
                     }
                 } else {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java
Patch:
@@ -228,7 +228,8 @@ void innerError(InnerObserver inner, Throwable e) {
             set.delete(inner);
             if (errors.addThrowable(e)) {
                 if (!delayErrors) {
-                    cancel();
+                    s.cancel();
+                    set.dispose();
                 }
                 active.decrementAndGet();
                 drain();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java
Patch:
@@ -228,7 +228,8 @@ void innerError(InnerObserver inner, Throwable e) {
             set.delete(inner);
             if (errors.addThrowable(e)) {
                 if (!delayErrors) {
-                    cancel();
+                    s.cancel();
+                    set.dispose();
                 }
                 active.decrementAndGet();
                 drain();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java
Patch:
@@ -195,7 +195,8 @@ void innerError(InnerObserver inner, Throwable e) {
             set.delete(inner);
             if (errors.addThrowable(e)) {
                 if (!delayErrors) {
-                    dispose();
+                    d.dispose();
+                    set.dispose();
                 }
                 active.decrementAndGet();
                 drain();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java
Patch:
@@ -195,7 +195,8 @@ void innerError(InnerObserver inner, Throwable e) {
             set.delete(inner);
             if (errors.addThrowable(e)) {
                 if (!delayErrors) {
-                    dispose();
+                    d.dispose();
+                    set.dispose();
                 }
                 active.decrementAndGet();
                 drain();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java
Patch:
@@ -97,7 +97,7 @@ public void onError(Throwable t) {
         @Override
         public void onComplete() {
             s = SubscriptionHelper.CANCELLED;
-            if (index <= count && !done) {
+            if (!done) {
                 done = true;
                 actual.onComplete();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java
Patch:
@@ -103,7 +103,7 @@ public void onError(Throwable t) {
         @Override
         public void onComplete() {
             s = SubscriptionHelper.CANCELLED;
-            if (index <= count && !done) {
+            if (!done) {
                 done = true;
 
                 T v = defaultValue;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java
Patch:
@@ -98,7 +98,7 @@ public void onError(Throwable t) {
 
         @Override
         public void onComplete() {
-            if (index <= count && !done) {
+            if (!done) {
                 done = true;
                 actual.onComplete();
             }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java
Patch:
@@ -99,7 +99,7 @@ public void onError(Throwable t) {
 
         @Override
         public void onComplete() {
-            if (index <= count && !done) {
+            if (!done) {
                 done = true;
 
                 T v = defaultValue;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapMaybe.java
Patch:
@@ -167,7 +167,9 @@ void innerSuccess(InnerObserver inner, R value) {
                 }
             } else {
                 SpscLinkedArrayQueue<R> q = getOrCreateQueue();
-                q.offer(value);
+                synchronized (q) {
+                    q.offer(value);
+                }
                 active.decrementAndGet();
                 if (getAndIncrement() != 0) {
                     return;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapSingle.java
Patch:
@@ -167,7 +167,9 @@ void innerSuccess(InnerObserver inner, R value) {
                 }
             } else {
                 SpscLinkedArrayQueue<R> q = getOrCreateQueue();
-                q.offer(value);
+                synchronized (q) {
+                    q.offer(value);
+                }
                 active.decrementAndGet();
                 if (getAndIncrement() != 0) {
                     return;

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -1922,8 +1922,7 @@ public final <U> Observable<U> flattenAsObservable(final Function<? super T, ? e
     }
 
     /**
-     * Returns a Single that is based on applying a specified function to the item emitted by the source Single,
->>>>>>> refs/remotes/akarnokd/SoloFlatMapIterable
+     * Returns an Observable that is based on applying a specified function to the item emitted by the source Single,
      * where that function returns a SingleSource.
      * <p>
      * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.png" alt="">

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapIterableFlowable.java
Patch:
@@ -277,7 +277,7 @@ public R poll() throws Exception {
 
             if (iter != null) {
                 R v = ObjectHelper.requireNonNull(iter.next(), "The iterator returned a null value");
-                if (iter.hasNext()) {
+                if (!iter.hasNext()) {
                     it = null;
                 }
                 return v;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapIterableObservable.java
Patch:
@@ -219,7 +219,7 @@ public R poll() throws Exception {
 
             if (iter != null) {
                 R v = ObjectHelper.requireNonNull(iter.next(), "The iterator returned a null value");
-                if (iter.hasNext()) {
+                if (!iter.hasNext()) {
                     it = null;
                 }
                 return v;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoOnEach.java
Patch:
@@ -114,7 +114,7 @@ public void onError(Throwable t) {
                 onError.accept(t);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                t = new CompositeException(e, t);
+                t = new CompositeException(t, e);
             }
             actual.onError(t);
 
@@ -131,7 +131,6 @@ public void onComplete() {
             if (done) {
                 return;
             }
-            done = true;
             try {
                 onComplete.run();
             } catch (Throwable e) {
@@ -140,6 +139,7 @@ public void onComplete() {
                 return;
             }
 
+            done = true;
             actual.onComplete();
 
             try {

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapIterableFlowable.java
Patch:
@@ -272,7 +272,7 @@ public R poll() throws Exception {
 
             if (iter != null) {
                 R v = ObjectHelper.requireNonNull(iter.next(), "The iterator returned a null value");
-                if (iter.hasNext()) {
+                if (!iter.hasNext()) {
                     it = null;
                 }
                 return v;

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -61,7 +61,7 @@ public static Completable ambArray(final CompletableSource... sources) {
             return wrap(sources[0]);
         }
 
-        return RxJavaPlugins.onAssembly(new CompletableAmbArray(sources));
+        return RxJavaPlugins.onAssembly(new CompletableAmb(sources, null));
     }
 
     /**
@@ -79,7 +79,7 @@ public static Completable ambArray(final CompletableSource... sources) {
     public static Completable amb(final Iterable<? extends CompletableSource> sources) {
         ObjectHelper.requireNonNull(sources, "sources is null");
 
-        return RxJavaPlugins.onAssembly(new CompletableAmbIterable(sources));
+        return RxJavaPlugins.onAssembly(new CompletableAmb(null, sources));
     }
 
     /**

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -57,7 +57,7 @@ public abstract class Maybe<T> implements MaybeSource<T> {
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Maybe<T> amb(final Iterable<? extends MaybeSource<? extends T>> sources) {
         ObjectHelper.requireNonNull(sources, "sources is null");
-        return RxJavaPlugins.onAssembly(new MaybeAmbIterable<T>(sources));
+        return RxJavaPlugins.onAssembly(new MaybeAmb<T>(null, sources));
     }
 
     /**
@@ -80,7 +80,7 @@ public static <T> Maybe<T> ambArray(final MaybeSource<? extends T>... sources) {
         if (sources.length == 1) {
             return wrap((MaybeSource<T>)sources[0]);
         }
-        return RxJavaPlugins.onAssembly(new MaybeAmbArray<T>(sources));
+        return RxJavaPlugins.onAssembly(new MaybeAmb<T>(sources, null));
     }
 
     /**

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -73,7 +73,7 @@ public abstract class Single<T> implements SingleSource<T> {
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Single<T> amb(final Iterable<? extends SingleSource<? extends T>> sources) {
         ObjectHelper.requireNonNull(sources, "sources is null");
-        return RxJavaPlugins.onAssembly(new SingleAmbIterable<T>(sources));
+        return RxJavaPlugins.onAssembly(new SingleAmb<T>(null, sources));
     }
 
     /**
@@ -97,7 +97,7 @@ public static <T> Single<T> ambArray(final SingleSource<? extends T>... sources)
         if (sources.length == 1) {
             return wrap((SingleSource<T>)sources[0]);
         }
-        return RxJavaPlugins.onAssembly(new SingleAmbArray<T>(sources));
+        return RxJavaPlugins.onAssembly(new SingleAmb<T>(sources, null));
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java
Patch:
@@ -39,7 +39,10 @@ protected void subscribeActual(SingleObserver<? super R> actual) {
     static final class SingleFlatMapCallback<T, R>
     extends AtomicReference<Disposable>
     implements SingleObserver<T>, Disposable {
+        private static final long serialVersionUID = 3258103020495908596L;
+
         final SingleObserver<? super R> actual;
+
         final Function<? super T, ? extends SingleSource<? extends R>> mapper;
 
         SingleFlatMapCallback(SingleObserver<? super R> actual,

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
Patch:
@@ -299,9 +299,8 @@ boolean checkTerminated(boolean d, boolean empty, Observer<?> a, SpscLinkedArray
         void onError(Throwable e) {
             for (;;) {
                 Throwable curr = error.get();
-                if (curr instanceof CompositeException) {
-                    CompositeException ce = new CompositeException((CompositeException)curr);
-                    ce.suppress(e);
+                if (curr != null) {
+                    CompositeException ce = new CompositeException(curr, e);
                     e = ce;
                 }
                 Throwable next = e;

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -2563,6 +2563,7 @@ public final <R> Flowable<R> flatMapPublisher(Function<? super T, ? extends Publ
      * <dd>{@code flatMapSingle} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
+     * @param <R> the result value type
      * @param mapper
      *            a function that, when applied to the item emitted by the source Maybe, returns a
      *            Single

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapSingle.java
Patch:
@@ -28,7 +28,8 @@
 
 /**
  * Maps the success value of the source MaybeSource into a Single.
- * @param <T>
+ * @param <T> the input value type
+ * @param <R> the result value type
  */
 public final class MaybeFlatMapSingle<T, R> extends Single<R> {
 

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -175,7 +175,7 @@ public void onNext(T t) {
             return;
         }
         if (t == null) {
-            onError(new NullPointerException("onNext got a null value. Null values are generally not allowed in 2.x operators and sources."));
+            onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
             return;
         }
         for (PublishDisposable<T> s : subscribers.get()) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
Patch:
@@ -787,6 +787,8 @@ public void testErrorRunsBeforeOnNext() {
         ts.assertError(TestException.class);
         ts.assertNotComplete();
     }
+
+    @Test
     public void testDelaySupplierSimple() {
         final PublishProcessor<Integer> ps = PublishProcessor.create();
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java
Patch:
@@ -789,6 +789,7 @@ public void testErrorRunsBeforeOnNext() {
         ts.assertNotComplete();
     }
 
+    @Test
     public void testDelaySupplierSimple() {
         final PublishSubject<Integer> ps = PublishSubject.create();
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableLastSingle.java
Patch:
@@ -99,10 +99,10 @@ public void onComplete() {
                 actual.onSuccess(v);
             } else {
                 v = defaultItem;
-                if (v == null) {
-                    actual.onError(new NoSuchElementException());
-                } else {
+                if (v != null) {
                     actual.onSuccess(v);
+                } else {
+                    actual.onError(new NoSuchElementException());
                 }
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.*;
 
@@ -309,6 +310,7 @@ void tryEmit(U value, InnerSubscriber<T, U> inner) {
         public void onError(Throwable t) {
             // safeguard against misbehaving sources
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             getErrorQueue().offer(t);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDrop.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.reactivestreams.*;
@@ -97,6 +98,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import org.reactivestreams.*;
 
 import io.reactivex.internal.subscriptions.*;
@@ -73,6 +74,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleMaybe.java
Patch:
@@ -81,6 +81,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingleSingle.java
Patch:
@@ -87,6 +87,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeWhile.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.Exceptions;
@@ -80,6 +81,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAt.java
Patch:
@@ -16,6 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableElementAt<T> extends AbstractObservableWithUpstream<T, T> {
     final long index;
@@ -86,6 +87,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java
Patch:
@@ -89,6 +89,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java
Patch:
@@ -16,6 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableElementAtSingle<T> extends Single<T> {
     final ObservableSource<T> source;
@@ -86,6 +87,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import java.util.*;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.*;
@@ -277,8 +278,8 @@ void tryEmit(U value, InnerObserver<T, U> inner) {
 
         @Override
         public void onError(Throwable t) {
-            // safeguard against misbehaving sources
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             getErrorQueue().offer(t);
@@ -288,7 +289,6 @@ public void onError(Throwable t) {
 
         @Override
         public void onComplete() {
-            // safeguard against misbehaving sources
             if (done) {
                 return;
             }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingle.java
Patch:
@@ -16,6 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableSingle<T> extends AbstractObservableWithUpstream<T, T> {
 
@@ -82,6 +83,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingleMaybe.java
Patch:
@@ -16,6 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableSingleMaybe<T> extends Maybe<T> {
 
@@ -79,6 +80,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingleSingle.java
Patch:
@@ -16,6 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableSingleSingle<T> extends Single<T> {
 
@@ -85,6 +86,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeWhile.java
Patch:
@@ -18,6 +18,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableTakeWhile<T> extends AbstractObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
@@ -92,6 +93,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
+                RxJavaPlugins.onError(t);
                 return;
             }
             done = true;

File: src/main/java/io/reactivex/observers/SafeObserver.java
Patch:
@@ -136,6 +136,7 @@ void onNextNoSubscription() {
     @Override
     public void onError(Throwable t) {
         if (done) {
+            RxJavaPlugins.onError(t);
             return;
         }
         done = true;

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -13,6 +13,7 @@
 
 package io.reactivex.subjects;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.Observer;
@@ -193,6 +194,7 @@ public void onNext(T t) {
     @Override
     public void onError(Throwable t) {
         if (done || disposed) {
+            RxJavaPlugins.onError(t);
             return;
         }
         if (t == null) {

File: src/main/java/io/reactivex/subscribers/SafeSubscriber.java
Patch:
@@ -124,6 +124,7 @@ void onNextNoSubscription() {
     @Override
     public void onError(Throwable t) {
         if (done) {
+            RxJavaPlugins.onError(t);
             return;
         }
         done = true;

File: src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java
Patch:
@@ -74,7 +74,7 @@ public void onComplete() {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
+                t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeCreate.java
Patch:
@@ -69,7 +69,7 @@ public void onSuccess(T value) {
                 if (d != DisposableHelper.DISPOSED) {
                     try {
                         if (value == null) {
-                            actual.onError(new NullPointerException("Emitter got a null value. Null values are generally not allowed in 2.x operators and sources."));
+                            actual.onError(new NullPointerException("onSuccess called with null. Null values are generally not allowed in 2.x operators and sources."));
                         } else {
                             actual.onSuccess(value);
                         }
@@ -85,7 +85,7 @@ public void onSuccess(T value) {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
+                t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/internal/operators/single/SingleCreate.java
Patch:
@@ -63,7 +63,7 @@ public void onSuccess(T value) {
                 if (d != DisposableHelper.DISPOSED) {
                     try {
                         if (value == null) {
-                            actual.onError(new NullPointerException("Emitter got a null value. Null values are generally not allowed in 2.x operators and sources."));
+                            actual.onError(new NullPointerException("onSuccess called with null. Null values are generally not allowed in 2.x operators and sources."));
                         } else {
                             actual.onSuccess(value);
                         }
@@ -79,7 +79,7 @@ public void onSuccess(T value) {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
+                t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java
Patch:
@@ -22,7 +22,7 @@
 public final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {
     final Scheduler scheduler;
 
-    public ObservableSubscribeOn(Observable<T> source, Scheduler scheduler) {
+    public ObservableSubscribeOn(ObservableSource<T> source, Scheduler scheduler) {
         super(source);
         this.scheduler = scheduler;
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java
Patch:
@@ -74,7 +74,7 @@ public void onComplete() {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException();
+                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java
Patch:
@@ -107,7 +107,7 @@ public void onNext(T t) {
                 return;
             }
             if (t == null) {
-                onError(new NullPointerException("t is null"));
+                onError(new NullPointerException("Emitter got a null value. Null values are generally not allowed in 2.x operators and sources."));
                 return;
             }
             if (get() == 0 && compareAndSet(0, 1)) {
@@ -134,7 +134,7 @@ public void onError(Throwable t) {
                 return;
             }
             if (t == null) {
-                t = new NullPointerException("t is null");
+                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (error.addThrowable(t)) {
                 done = true;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeCreate.java
Patch:
@@ -69,7 +69,7 @@ public void onSuccess(T value) {
                 if (d != DisposableHelper.DISPOSED) {
                     try {
                         if (value == null) {
-                            actual.onError(new NullPointerException());
+                            actual.onError(new NullPointerException("Emitter got a null value. Null values are generally not allowed in 2.x operators and sources."));
                         } else {
                             actual.onSuccess(value);
                         }
@@ -85,7 +85,7 @@ public void onSuccess(T value) {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException();
+                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCreate.java
Patch:
@@ -60,7 +60,7 @@ static final class CreateEmitter<T>
         @Override
         public void onNext(T t) {
             if (t == null) {
-                onError(new NullPointerException());
+                onError(new NullPointerException("Emitter got a null value. Null values are generally not allowed in 2.x operators and sources."));
             }
             if (!isDisposed()) {
                 observer.onNext(t);
@@ -70,7 +70,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException();
+                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (!isDisposed()) {
                 try {

File: src/main/java/io/reactivex/internal/operators/single/SingleCreate.java
Patch:
@@ -63,7 +63,7 @@ public void onSuccess(T value) {
                 if (d != DisposableHelper.DISPOSED) {
                     try {
                         if (value == null) {
-                            actual.onError(new NullPointerException());
+                            actual.onError(new NullPointerException("Emitter got a null value. Null values are generally not allowed in 2.x operators and sources."));
                         } else {
                             actual.onSuccess(value);
                         }
@@ -79,7 +79,7 @@ public void onSuccess(T value) {
         @Override
         public void onError(Throwable t) {
             if (t == null) {
-                t = new NullPointerException();
+                t = new NullPointerException("Emitter got a null throwable. Null values are generally not allowed in 2.x operators and sources.");
             }
             if (get() != DisposableHelper.DISPOSED) {
                 Disposable d = getAndSet(DisposableHelper.DISPOSED);

File: src/main/java/io/reactivex/Maybe.java
Patch:
@@ -461,7 +461,7 @@ public static <T> Maybe<T> create(MaybeOnSubscribe<T> onSubscribe) {
 
     /**
      * Calls a Callable for each individual MaybeObserver to return the actual MaybeSource source to
-     * be subscribe to.
+     * be subscribed to.
      * <dl>
      * <dt><b>Scheduler:</b></dt>
      * <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -348,7 +348,7 @@ public static <T> Single<T> create(SingleOnSubscribe<T> source) {
 
     /**
      * Calls a Callable for each individual SingleObserver to return the actual Single source to
-     * be subscribe to.
+     * be subscribed to.
      * <dl>
      * <dt><b>Scheduler:</b></dt>
      * <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -647,7 +647,7 @@ private static NullPointerException toNpe(Throwable ex) {
      * Returns a Completable instance which manages a resource along
      * with a custom Completable instance while the subscription is active.
      * <p>
-     * This overload performs an eager unsubscription before the terminal event is emitted.
+     * This overload disposes eagerly before the terminal event is emitted.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code using} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -670,7 +670,7 @@ public static <R> Completable using(Callable<R> resourceSupplier,
      * with a custom Completable instance while the subscription is active and performs eager or lazy
      * resource disposition.
      * <p>
-     * If this overload performs a lazy unsubscription after the terminal event is emitted.
+     * If this overload performs a lazy cancellation after the terminal event is emitted.
      * Exceptions thrown at this time will be delivered to RxJavaPlugins only.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -1797,7 +1797,7 @@ public final <T> Single<T> toSingleDefault(final T completionValue) {
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final Completable unsubscribeOn(final Scheduler scheduler) {
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
-        return RxJavaPlugins.onAssembly(new CompletableUnsubscribeOn(this, scheduler));
+        return RxJavaPlugins.onAssembly(new CompletableDisposeOn(this, scheduler));
     }
     // -------------------------------------------------------------------------
     // Fluent test support, super handy and reduces test preparation boilerplate

File: src/main/java/io/reactivex/CompletableEmitter.java
Patch:
@@ -39,14 +39,14 @@ public interface CompletableEmitter {
 
     /**
      * Sets a Disposable on this emitter; any previous Disposable
-     * or Cancellation will be unsubscribed/cancelled.
+     * or Cancellation will be disposed/cancelled.
      * @param d the disposable, null is allowed
      */
     void setDisposable(Disposable d);
 
     /**
      * Sets a Cancellable on this emitter; any previous Disposable
-     * or Cancellation will be unsubscribed/cancelled.
+     * or Cancellation will be disposed/cancelled.
      * @param c the cancellable resource, null is allowed
      */
     void setCancellable(Cancellable c);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableDisposeOn.java
Patch:
@@ -16,13 +16,13 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 
-public final class CompletableUnsubscribeOn extends Completable {
+public final class CompletableDisposeOn extends Completable {
 
     final CompletableSource source;
 
     final Scheduler scheduler;
 
-    public CompletableUnsubscribeOn(CompletableSource source, Scheduler scheduler) {
+    public CompletableDisposeOn(CompletableSource source, Scheduler scheduler) {
         this.source = source;
         this.scheduler = scheduler;
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
Patch:
@@ -128,11 +128,11 @@ public void onComplete() {
 
         void terminate() {
             if (decrementAndGet() == 0) {
-                Throwable ex = error.terminate();
-                if (ex == null && ex != ExceptionHelper.TERMINATED) {
+                Throwable ex = error.get();
+                if (ex == null) {
                     actual.onComplete();
                 } else {
-                    actual.onError(ex);
+                    actual.onError(error.terminate());
                 }
             }
             else if (!delayErrors) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
Patch:
@@ -35,7 +35,7 @@ public enum FlowableBlockingSubscribe {
      * Subscribes to the source and calls the Subscriber methods on the current thread.
      * <p>
      * @param o the source publisher
-     * The unsubscription and backpressure is composed through.
+     * The cancellation and backpressure is composed through.
      * @param subscriber the subscriber to forward events and calls to in the current thread
      * @param <T> the value type
      */

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -195,7 +195,7 @@ public void cancel() {
         public void run() {
             /*
              * If running on a synchronous scheduler, the timer might never
-             * be set so the periodic timer can't be stopped this loopback way.
+             * be set so the periodic timer can't be stopped this loop-back way.
              * The last resort is to crash the task so it hopefully won't
              * be rescheduled.
              */

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeCount.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.internal.fuseable.HasUpstreamMaybeSource;
 
 /**
- * Singals 1L if the source signalled an item or 0L if the source is empty.
+ * Signals 1L if the source signalled an item or 0L if the source is empty.
  *
  * @param <T> the source value type
  */

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeDelayOtherPublisher.java
Patch:
@@ -47,7 +47,7 @@ static final class DelayMaybeObserver<T, U>
     implements MaybeObserver<T>, Disposable {
         final OtherSubscriber<T> other;
 
-        Publisher<U> otherSource;
+        final Publisher<U> otherSource;
 
         Disposable d;
 

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFromFuture.java
Patch:
@@ -19,8 +19,8 @@
 import io.reactivex.disposables.*;
 
 /**
- * Waits until the source Future completes or the wait times out; treates null
- * result as indication for empty.
+ * Waits until the source Future completes or the wait times out; treats a {@code null}
+ * result as indication to signal {@code onComplete} instead of {@code onSuccess}.
  *
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
Patch:
@@ -36,7 +36,7 @@ public enum ObservableBlockingSubscribe {
      * Subscribes to the source and calls the Subscriber methods on the current thread.
      * <p>
      * @param o the source publisher
-     * The unsubscription and backpressure is composed through.
+     * The call to dispose() is composed through.
      * @param subscriber the subscriber to forward events and calls to in the current thread
      * @param <T> the value type
      */

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
Patch:
@@ -190,7 +190,7 @@ public boolean isDisposed() {
         public void run() {
             /*
              * If running on a synchronous scheduler, the timer might never
-             * be set so the periodic timer can't be stopped this loopback way.
+             * be set so the periodic timer can't be stopped this loop-back way.
              * The last resort is to crash the task so it hopefully won't
              * be rescheduled.
              */

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
Patch:
@@ -212,7 +212,7 @@ void drain() {
                         ObservableSource<? extends U> o;
 
                         try {
-                            o = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null ObservableConsumable");
+                            o = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null ObservableSource");
                         } catch (Throwable ex) {
                             Exceptions.throwIfFatal(ex);
                             dispose();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
Patch:
@@ -329,7 +329,7 @@ void drainLoop() {
 
                 if (svq != null) {
                     for (;;) {
-                        U o = null;
+                        U o;
                         for (;;) {
                             if (checkTerminate()) {
                                 return;

File: src/main/java/io/reactivex/internal/operators/single/SingleFromObservable.java
Patch:
@@ -21,8 +21,9 @@
 import io.reactivex.disposables.Disposable;
 
 public final class SingleFromObservable<T> extends Single<T> {
-    private final Observable<T> upstream;
-    private final T defaultValue;
+    final Observable<T> upstream;
+
+    final T defaultValue;
 
     public SingleFromObservable(Observable<T> upstream, T defaultValue) {
         this.upstream = upstream;

File: src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
Patch:
@@ -21,7 +21,7 @@
  * Note that the class leaks all methods of {@link java.util.concurrent.atomic.AtomicLong}.
  * Use {@link #complete(Object)} to signal the single value.
  * <p>
- * The this atomic integer stores a bitfield:<br>
+ * The this atomic integer stores a bit field:<br>
  * bit 0: indicates that there is a value available<br>
  * bit 1: indicates that there was a request made<br>
  * bit 2: indicates there was a cancellation, exclusively set<br>

File: src/main/java/io/reactivex/observers/DefaultObserver.java
Patch:
@@ -39,7 +39,7 @@ public final void onSubscribe(Disposable s) {
      */
     protected final void cancel() {
         Disposable s = this.s;
-        this.s = DisposableHelper.DISPOSED;;
+        this.s = DisposableHelper.DISPOSED;
         s.dispose();
     }
     /**

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -99,7 +99,7 @@ public void subscribeActual(Subscriber<? super T> t) {
                 remove(ps);
             }
         } else {
-            Throwable ex = error;;
+            Throwable ex = error;
             if (ex != null) {
                 t.onError(ex);
             } else {

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -235,9 +235,7 @@ void drain() {
             if (missed == 0) {
                 break;
             }
-            if (a == null) {
-                a = actual.get();
-            }
+            a = actual.get();
         }
     }
 

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -88,7 +88,7 @@ public void subscribeActual(Observer<? super T> t) {
                 remove(ps);
             }
         } else {
-            Throwable ex = error;;
+            Throwable ex = error;
             if (ex != null) {
                 t.onError(ex);
             } else {
@@ -166,7 +166,6 @@ void remove(PublishDisposable<T> ps) {
     public void onSubscribe(Disposable s) {
         if (subscribers.get() == TERMINATED) {
             s.dispose();
-            return;
         }
     }
 

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -312,9 +312,7 @@ void drain() {
                 break;
             }
 
-            if (a == null) {
-                a = actual.get();
-            }
+            a = actual.get();
         }
     }
 

File: src/main/java/io/reactivex/subscribers/SafeSubscriber.java
Patch:
@@ -222,7 +222,6 @@ public void request(long n) {
                 return;
             }
             RxJavaPlugins.onError(e);
-            return;
         }
     }
 
@@ -233,7 +232,6 @@ public void cancel() {
         } catch (Throwable e1) {
             Exceptions.throwIfFatal(e1);
             RxJavaPlugins.onError(e1);
-            return;
         }
     }
 }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCacheTest.java
Patch:
@@ -68,7 +68,7 @@ public void subscribe(final Observer<? super String> observer) {
                     @Override
                     public void run() {
                         counter.incrementAndGet();
-                        System.out.println("published NbpObservable being executed");
+                        System.out.println("published Observable being executed");
                         observer.onNext("one");
                         observer.onComplete();
                     }

File: src/test/java/io/reactivex/observable/ObservableCombineLatestTests.java
Patch:
@@ -67,10 +67,10 @@ public void accept(ExtendedResult t1) {
     @Test
     public void testNullEmitting() throws Exception {
         // FIXME this is no longer allowed
-        Observable<Boolean> nullNbpObservable = BehaviorSubject.createDefault((Boolean) null);
-        Observable<Boolean> nonNullNbpObservable = BehaviorSubject.createDefault(true);
+        Observable<Boolean> nullObservable = BehaviorSubject.createDefault((Boolean) null);
+        Observable<Boolean> nonNullObservable = BehaviorSubject.createDefault(true);
         Observable<Boolean> combined =
-                combineLatest(nullNbpObservable, nonNullNbpObservable, new BiFunction<Boolean, Boolean, Boolean>() {
+                combineLatest(nullObservable, nonNullObservable, new BiFunction<Boolean, Boolean, Boolean>() {
                     @Override
                     public Boolean apply(Boolean bool1, Boolean bool2) {
                         return bool1 == null ? null : bool2;

File: src/test/java/io/reactivex/observable/ObservableCovarianceTest.java
Patch:
@@ -42,7 +42,7 @@ public class ObservableCovarianceTest {
     public void testCovarianceOfFrom() {
         Observable.<Movie> just(new HorrorMovie());
         Observable.<Movie> fromIterable(new ArrayList<HorrorMovie>());
-        // NbpObservable.<HorrorMovie>from(new Movie()); // may not compile
+        // Observable.<HorrorMovie>from(new Movie()); // may not compile
     }
 
     @Test

File: src/test/java/io/reactivex/observable/ObservableTest.java
Patch:
@@ -996,8 +996,8 @@ public void testEmptyIsEmpty() {
 // FIXME this test doesn't make sense
 //    @Test // cf. https://github.com/ReactiveX/RxJava/issues/2599
 //    public void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain() {
-//        NbpTestSubscriber<Object> subscriber = new NbpTestSubscriber<T>();
-//        Subscription subscription = Observable.just("event").subscribe((Observer<Object>) subscriber);
+//        TestObserver<Object> observer = new TestObserver<T>();
+//        Subscription subscription = Observable.just("event").subscribe((Observer<Object>) observer);
 //        subscription.unsubscribe();
 //
 //        subscriber.assertUnsubscribed();

File: src/test/java/io/reactivex/subjects/AsyncSubjectTest.java
Patch:
@@ -273,7 +273,7 @@ public void run() {
     // FIXME subscriber methods are not allowed to throw
 //    @Test
 //    public void testOnErrorThrowsDoesntPreventDelivery() {
-//        NbpAsyncSubject<String> ps = NbpAsyncSubject.create();
+//        AsyncSubject<String> ps = AsyncSubject.create();
 //
 //        ps.subscribe();
 //        TestObserver<String> ts = new TestObserver<String>();
@@ -296,7 +296,7 @@ public void run() {
 //     */
 //    @Test
 //    public void testOnErrorThrowsDoesntPreventDelivery2() {
-//        NbpAsyncSubject<String> ps = NbpAsyncSubject.create();
+//        AsyncSubject<String> ps = AsyncSubject.create();
 //
 //        ps.subscribe();
 //        ps.subscribe();

File: src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java
Patch:
@@ -32,7 +32,7 @@
 public class ReplaySubjectConcurrencyTest {
 
     @Test(timeout = 4000)
-    public void testNbpReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {
+    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {
         final ReplaySubject<Long> replay = ReplaySubject.create();
         Thread source = new Thread(new Runnable() {
 
@@ -142,7 +142,7 @@ public void onNext(Long args) {
     }
 
     @Test
-    public void testNbpReplaySubjectConcurrentSubscriptions() throws InterruptedException {
+    public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {
         final ReplaySubject<Long> replay = ReplaySubject.create();
         Thread source = new Thread(new Runnable() {
 
@@ -323,7 +323,7 @@ public void run() {
         }
     }
     @Test
-    public void testNbpReplaySubjectEmissionSubscriptionRace() throws Exception {
+    public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
         Scheduler s = Schedulers.io();
         Scheduler.Worker worker = Schedulers.io().createWorker();
         try {

File: src/test/java/io/reactivex/subjects/SerializedSubjectTest.java
Patch:
@@ -388,7 +388,7 @@ public void testReplaySubjectBoundedError() {
     }
 
     @Test
-    public void testDontWrapNbpSerializedSubjectAgain() {
+    public void testDontWrapSerializedSubjectAgain() {
         PublishSubject<Object> s = PublishSubject.create();
         Subject<Object> s1 = s.toSerialized();
         Subject<Object> s2 = s1.toSerialized();

File: src/test/java/io/reactivex/tck/DelayTckTest.java
Patch:
@@ -26,7 +26,9 @@ public class DelayTckTest extends BaseTck<Integer> {
     @Override
     public Publisher<Integer> createPublisher(long elements) {
         return FlowableTck.wrap(
+            FlowableAwaitOnSubscribeTck.wrap(
                 Flowable.range(0, (int)elements).delay(1, TimeUnit.MILLISECONDS)
+            )
         );
     }
 }

File: src/test/java/io/reactivex/tck/ObserveOnTckTest.java
Patch:
@@ -25,7 +25,9 @@ public class ObserveOnTckTest extends BaseTck<Integer> {
     @Override
     public Publisher<Integer> createPublisher(long elements) {
         return FlowableTck.wrap(
+            FlowableAwaitOnSubscribeTck.wrap(
                 Flowable.range(0, (int)elements).observeOn(Schedulers.single())
+            )
         );
     }
 }

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Wait for and iterate over the latest values of the source observable. If the source works faster than the
- * iterator, values may be skipped, but not the {@code onError} or {@code onCompleted} events.
+ * iterator, values may be skipped, but not the {@code onError} or {@code onComplete} events.
  */
 public enum BlockingFlowableLatest {
     ;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
Patch:
@@ -21,7 +21,6 @@
 
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.BooleanSupplier;
-import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -142,7 +142,7 @@ public void subscribeActual(Subscriber<? super R> s) {
             new FlowableMap<T, R>((Publisher<T>)a[0], new Function<T, R>() {
                 @Override
                 public R apply(T t) throws Exception {
-                    return combiner.apply((T[])new Object[] { t });
+                    return combiner.apply(new Object[] { t });
                 }
             }).subscribe(s);
             return;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -19,7 +19,6 @@
 
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -21,7 +21,6 @@
 
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -20,7 +20,6 @@
 import io.reactivex.Scheduler;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.exceptions.*;
-import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java
Patch:
@@ -58,10 +58,9 @@ protected void subscribeActual(MaybeObserver<? super R> observer) {
 
         if (n == 1) {
             a[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new Function<T, R>() {
-                @SuppressWarnings("unchecked")
                 @Override
                 public R apply(T t) throws Exception {
-                    return zipper.apply((T[])new Object[] { t });
+                    return zipper.apply(new Object[] { t });
                 }
             }));
             return;

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -1063,6 +1063,7 @@ public void toObservableError() {
 
     @Test
     public void zipIterableObject() {
+        @SuppressWarnings("unchecked")
         final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));
         Flowable.zip(flowables, new Function<Object[], Object>() {
             @Override
@@ -1078,6 +1079,7 @@ public Object apply(Object[] o) throws Exception {
 
     @Test
     public void combineLatestObject() {
+        @SuppressWarnings("unchecked")
         final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));
         Flowable.combineLatest(flowables, new Function<Object[], Object>() {
             @Override

File: src/test/java/io/reactivex/maybe/MaybeTest.java
Patch:
@@ -2860,6 +2860,7 @@ public void ambWith2SignalsSuccess() {
 
     @Test
     public void zipIterableObject() {
+        @SuppressWarnings("unchecked")
         final List<Maybe<Integer>> maybes = Arrays.asList(Maybe.just(1), Maybe.just(4));
         Maybe.zip(maybes, new Function<Object[], Object>() {
             @Override

File: src/test/java/io/reactivex/observable/ObservableTest.java
Patch:
@@ -1059,6 +1059,7 @@ public void singleDefault() {
 
     @Test
     public void zipIterableObject() {
+        @SuppressWarnings("unchecked")
         final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));
         Observable.zip(observables, new Function<Object[], Object>() {
             @Override
@@ -1074,6 +1075,7 @@ public Object apply(Object[] o) throws Exception {
 
     @Test
     public void combineLatestObject() {
+        @SuppressWarnings("unchecked")
         final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));
         Observable.combineLatest(observables, new Function<Object[], Object>() {
             @Override

File: src/test/java/io/reactivex/single/SingleTest.java
Patch:
@@ -518,6 +518,7 @@ public void toFlowableIterableRemove() {
 
     @Test
     public void zipIterableObject() {
+        @SuppressWarnings("unchecked")
         final List<Single<Integer>> singles = Arrays.asList(Single.just(1), Single.just(4));
         Single.zip(singles, new Function<Object[], Object>() {
             @Override

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java
Patch:
@@ -25,9 +25,9 @@ public final class MaybeZipIterable<T, R> extends Maybe<R> {
 
     final Iterable<? extends MaybeSource<? extends T>> sources;
 
-    final Function<? super T[], ? extends R> zipper;
+    final Function<? super Object[], ? extends R> zipper;
 
-    public MaybeZipIterable(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super T[], ? extends R> zipper) {
+    public MaybeZipIterable(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
         this.sources = sources;
         this.zipper = zipper;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java
Patch:
@@ -296,9 +296,9 @@ public static <T> Function<Observable<Notification<Object>>, ObservableSource<?>
 
     static final class ZipIterableFunction<T, R>
     implements Function<List<ObservableSource<? extends T>>, ObservableSource<? extends R>> {
-        private final Function<? super T[], ? extends R> zipper;
+        private final Function<? super Object[], ? extends R> zipper;
 
-        ZipIterableFunction(Function<? super T[], ? extends R> zipper) {
+        ZipIterableFunction(Function<? super Object[], ? extends R> zipper) {
             this.zipper = zipper;
         }
 
@@ -308,7 +308,7 @@ public ObservableSource<? extends R> apply(List<ObservableSource<? extends T>> l
         }
     }
 
-    public static <T, R> Function<List<ObservableSource<? extends T>>, ObservableSource<? extends R>> zipIterable(final Function<? super T[], ? extends R> zipper) {
+    public static <T, R> Function<List<ObservableSource<? extends T>>, ObservableSource<? extends R>> zipIterable(final Function<? super Object[], ? extends R> zipper) {
         return new ZipIterableFunction<T, R>(zipper);
     }
 

File: src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java
Patch:
@@ -41,7 +41,7 @@ public void testOnErrorCalledOnScheduler() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Thread> thread = new AtomicReference<Thread>();
 
-        Completable.<String>error(new Exception())
+        Completable.error(new Exception())
                 .delay(0, TimeUnit.MILLISECONDS, Schedulers.newThread())
                 .doOnError(new Consumer<Throwable>() {
                     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -175,6 +175,7 @@ public void request(long n) {
         public void cancel() {
             if (!cancelled) {
                 cancelled = true;
+                s.cancel();
 
                 disposeInner();
             }
@@ -186,7 +187,7 @@ void disposeInner() {
             if (a != CANCELLED) {
                 a = active.getAndSet((SwitchMapInnerSubscriber<T, R>)CANCELLED);
                 if (a != CANCELLED && a != null) {
-                    s.cancel();
+                    a.cancel();
                 }
             }
         }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -160,7 +160,7 @@ public void onComplete() {
         public void dispose() {
             if (!cancelled) {
                 cancelled = true;
-
+                s.dispose();
                 disposeInner();
             }
         }
@@ -176,7 +176,7 @@ void disposeInner() {
             if (a != CANCELLED) {
                 a = active.getAndSet((SwitchMapInnerSubscriber<T, R>)CANCELLED);
                 if (a != CANCELLED && a != null) {
-                    s.dispose();
+                    a.cancel();
                 }
             }
         }

File: src/main/java/io/reactivex/MaybeObserver.java
Patch:
@@ -21,7 +21,7 @@
  * first the Maybe calls {@link #onSubscribe(Disposable)} with a {@link Disposable} that allows
  * cancelling the sequence at any time, then the
  * {@code Maybe} calls only one of the MaybeObserver's {@link #onSuccess}, {@link #onError} or
- * {@lingk onComplete} methods to provide notifications.
+ * {@link #onComplete} methods to provide notifications.
  *
  * @see <a href="http://reactivex.io/documentation/observable.html">ReactiveX documentation: Observable</a>
  * @param <T>

File: src/main/java/io/reactivex/CompletableEmitter.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Cancellable;
 
 /**
- * Abstraction over a RxJava CompletableObserver that allows associating
+ * Abstraction over an RxJava {@link CompletableObserver} that allows associating
  * a resource with it.
  * <p>
  * All methods are safe to call from multiple threads.

File: src/main/java/io/reactivex/FlowableEmitter.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Cancellable;
 
 /**
- * Abstraction over a RxJava Subscriber that allows associating
+ * Abstraction over a Reactive Streams {@link org.reactivestreams.Subscriber} that allows associating
  * a resource with it and exposes the current number of downstream
  * requested amount.
  * <p>
@@ -43,6 +43,7 @@ public interface FlowableEmitter<T> extends Emitter<T> {
      * @param c the cancellable resource, null is allowed
      */
     void setCancellable(Cancellable c);
+
     /**
      * The current outstanding request amount.
      * <p>This method is thread-safe.
@@ -62,6 +63,7 @@ public interface FlowableEmitter<T> extends Emitter<T> {
      * @return the serialized FlowableEmitter
      */
     FlowableEmitter<T> serialize();
+
     /**
      * Options to handle backpressure in the emitter.
      */

File: src/main/java/io/reactivex/MaybeEmitter.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Cancellable;
 
 /**
- * Abstraction over a RxJava MaybeObserver that allows associating
+ * Abstraction over an RxJava {@link MaybeObserver} that allows associating
  * a resource with it.
  * <p>
  * All methods are safe to call from multiple threads.

File: src/main/java/io/reactivex/ObservableEmitter.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Cancellable;
 
 /**
- * Abstraction over a RxJava Observer that allows associating
+ * Abstraction over an RxJava {@link Observer} that allows associating
  * a resource with it.
  * <p>
  * The onNext, onError and onComplete methods should be called

File: src/main/java/io/reactivex/ObservableOnSubscribe.java
Patch:
@@ -14,7 +14,7 @@
 
 /**
  * A functional interface that has a {@code subscribe()} method that receives
- * an instance of a {@link ObservableEmitter} instance that allows pushing
+ * an instance of an {@link ObservableEmitter} instance that allows pushing
  * events in a cancellation-safe manner.
  *
  * @param <T> the value type pushed

File: src/main/java/io/reactivex/SingleEmitter.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Cancellable;
 
 /**
- * Abstraction over a RxJava SingleObserver that allows associating
+ * Abstraction over an RxJava {@link SingleObserver} that allows associating
  * a resource with it.
  * <p>
  * All methods are safe to call from multiple threads.

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
Patch:
@@ -132,7 +132,7 @@ public void accept(Integer t1) {
                         if (count.incrementAndGet() == 500000) {
                             // give it a small break halfway through
                             try {
-                                Thread.sleep(1);
+                                Thread.sleep(5);
                             } catch (InterruptedException ex) {
                                 // ignored
                             }

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -1711,7 +1711,7 @@ public void reduceFunctionReturnsNull() {
             public Integer apply(Integer a, Integer b) {
                 return null;
             }
-        }).blockingSubscribe();
+        }).toFlowable().blockingSubscribe();
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -207,6 +207,7 @@ public Integer apply(Integer t1, Integer t2) {
                 return t1 + t2;
             }
         })
+        .toFlowable()
         .subscribe(w);
         // we should be called only once
         verify(w, times(1)).onNext(anyInt());
@@ -225,6 +226,7 @@ public Integer apply(Integer t1, Integer t2) {
                 return t1 + t2;
             }
         })
+        .toFlowable()
         .blockingForEach(new Consumer<Integer>() {
             @Override
             public void accept(Integer t1) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java
Patch:
@@ -38,6 +38,7 @@ public Integer apply(Integer a, Integer b) {
                 return Math.max(a, b);
             }
         })
+        .toFlowable()
         .flatMapIterable(new Function<Integer, Iterable<Integer>>() {
             @Override
             public Iterable<Integer> apply(Integer v) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReduceTest.java
Patch:
@@ -123,9 +123,9 @@ public Integer apply(Integer t1) {
     @Test
     public void testBackpressureWithNoInitialValue() throws InterruptedException {
         Flowable<Integer> source = Flowable.just(1, 2, 3, 4, 5, 6);
-        Flowable<Integer> reduced = source.reduce(sum);
+        Single<Integer> reduced = source.reduce(sum);
 
-        Integer r = reduced.blockingFirst();
+        Integer r = reduced.blockingGet();
         assertEquals(21, r.intValue());
     }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
Patch:
@@ -435,14 +435,14 @@ public void onNext(Integer integer) {
     public void testIssue1527() throws InterruptedException {
         //https://github.com/ReactiveX/RxJava/pull/1527
         Flowable<Integer> source = Flowable.just(1, 2, 3, 4, 5, 6);
-        Flowable<Integer> reduced = source.reduce(new BiFunction<Integer, Integer, Integer>() {
+        Single<Integer> reduced = source.reduce(new BiFunction<Integer, Integer, Integer>() {
             @Override
             public Integer apply(Integer i1, Integer i2) {
                 return i1 + i2;
             }
         });
 
-        Integer r = reduced.blockingFirst();
+        Integer r = reduced.blockingGet();
         assertEquals(21, r.intValue());
     }
 }
\ No newline at end of file

File: src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
Patch:
@@ -98,7 +98,7 @@ public void forEachWhile(Predicate<? super T> consumer) throws Exception {
     public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Exception {
         Object[] a = head;
         final int c = capacity;
-        while (a != null) {
+        for (;;) {
             for (int i = 0; i < c; i++) {
                 Object o = a[i];
                 if (o == null) {

File: src/main/java/io/reactivex/plugins/RxJavaPlugins.java
Patch:
@@ -665,10 +665,10 @@ public static void setOnFlowableSubscribe(BiFunction<Flowable, Subscriber, Subsc
     
     /**
      * Sets the specific hook function.
-     * @param onFlowableSubscribe the hook function to set, null allowed
+     * @param onMaybeSubscribe the hook function to set, null allowed
      */
     @SuppressWarnings("rawtypes")
-    public static void setOnMaybeSubscribe(BiFunction<Maybe, MaybeObserver, MaybeObserver> onFlowableSubscribe) {
+    public static void setOnMaybeSubscribe(BiFunction<Maybe, MaybeObserver, MaybeObserver> onMaybeSubscribe) {
         if (lockdown) {
             throw new IllegalStateException("Plugins can't be changed anymore");
         }

File: src/main/java/io/reactivex/schedulers/Schedulers.java
Patch:
@@ -45,8 +45,9 @@ public final class Schedulers {
         NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(NewThreadScheduler.instance());
     }
     
+    /** Utility class. */
     private Schedulers() {
-        throw new IllegalStateException("No instances");
+        throw new IllegalStateException("No instances!");
     }
     
     /**

File: src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
Patch:
@@ -235,7 +235,7 @@ public boolean test(Throwable e) throws Exception {
     public void timeout() throws Exception {
         Single.never().timeout(100, TimeUnit.MILLISECONDS, Schedulers.io())
         .test()
-        .awaitDone()
+        .awaitDone(5, TimeUnit.SECONDS)
         .assertFailure(TimeoutException.class);
     }
 
@@ -244,7 +244,7 @@ public void timeoutOther() throws Exception {
         Single.never()
         .timeout(100, TimeUnit.MILLISECONDS, Schedulers.io(), Single.just(1))
         .test()
-        .awaitDone()
+        .awaitDone(5, TimeUnit.SECONDS)
         .assertResult(1);
     }
     

File: src/test/java/io/reactivex/observers/SerializedObserverTest.java
Patch:
@@ -212,7 +212,7 @@ public void runConcurrencyTest() {
             TestConcurrencySubscriber tw = new TestConcurrencySubscriber();
             // we need Synchronized + SafeSubscriber to handle synchronization plus life-cycle
             Subscriber<String> w = serializedSubscriber(new SafeSubscriber<String>(tw));
-            w.onSubscribe(EmptySubscription.INSTANCE);
+            w.onSubscribe(new BooleanSubscription());
 
             Future<?> f1 = tp.submit(new OnNextThread(w, 12000));
             Future<?> f2 = tp.submit(new OnNextThread(w, 5000));

File: src/main/java/io/reactivex/internal/functions/Functions.java
Patch:
@@ -31,15 +31,15 @@ private Functions() {
     }
     
     @SuppressWarnings("unchecked")
-    public static <T1, T2, R> Function<Object[], R> toFunction(final BiFunction<? super T1, ? super T2, ? extends R> biFunction) {
-        ObjectHelper.requireNonNull(biFunction, "biFunction is null");
+    public static <T1, T2, R> Function<Object[], R> toFunction(final BiFunction<? super T1, ? super T2, ? extends R> f) {
+        ObjectHelper.requireNonNull(f, "f is null");
         return new Function<Object[], R>() {
             @Override
             public R apply(Object[] a) throws Exception {
                 if (a.length != 2) {
                     throw new IllegalArgumentException("Array of size 2 expected but got " + a.length);
                 }
-                return ((BiFunction<Object, Object, R>)biFunction).apply(a[0], a[1]);
+                return ((BiFunction<Object, Object, R>)f).apply(a[0], a[1]);
             }
         };
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -180,7 +180,7 @@ public static <T> ConnectableFlowable<T> create(Flowable<T> source,
      * @param unit the unit of measure of the age amount
      * @param scheduler the target scheduler providing the current time
      * @param bufferSize the maximum number of elements to hold
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableFlowable instance
      */
     public static <T> ConnectableFlowable<T> create(Flowable<T> source,
             final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
Patch:
@@ -276,7 +276,7 @@ void drainLoop() {
                         
                         if (p == null) {
                             cancelled = true;
-                            a.onError(new NullPointerException("The NbpObservable supplied is null"));
+                            a.onError(new NullPointerException("The ObservableSource supplied is null"));
                             continue;
                         }
                         

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
Patch:
@@ -95,7 +95,7 @@ public void onSubscribe(Disposable s) {
                 
                 if (p == null) {
                     s.dispose();
-                    a.onError(new NullPointerException("The first window NbpObservable supplied is null"));
+                    a.onError(new NullPointerException("The first window ObservableSource supplied is null"));
                     return;
                 }
                 
@@ -242,7 +242,7 @@ void drainLoop() {
                         
                         if (p == null) {
                             DisposableHelper.dispose(boundary);
-                            a.onError(new NullPointerException("The NbpObservable supplied is null"));
+                            a.onError(new NullPointerException("The ObservableSource supplied is null"));
                             return;
                         }
                         

File: src/main/java/io/reactivex/internal/subscribers/flowable/InnerQueuedSubscriber.java
Patch:
@@ -40,7 +40,7 @@ public final class InnerQueuedSubscriber<T>
     
     final int limit;
 
-    SimpleQueue<T> queue;
+    volatile SimpleQueue<T> queue;
     
     volatile boolean done;
     

File: src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
Patch:
@@ -28,7 +28,7 @@
  * @param <U> the value type in the queue
  * @param <V> the value type the child subscriber accepts
  */
-public abstract class QueueDrainObserver<T, U, V> extends QueueDrainSubscriberPad2 implements Observer<T>, NbpQueueDrain<U, V> {
+public abstract class QueueDrainObserver<T, U, V> extends QueueDrainSubscriberPad2 implements Observer<T>, ObservableQueueDrain<U, V> {
     protected final Observer<? super V> actual;
     protected final SimpleQueue<U> queue;
     

File: src/main/java/io/reactivex/internal/util/NotificationLite.java
Patch:
@@ -226,11 +226,11 @@ public static <T> boolean accept(Object o, Subscriber<? super T> s) {
     }
 
     /**
-     * Calls the appropriate NbpSubscriber method based on the type of the notification.
+     * Calls the appropriate Observer method based on the type of the notification.
      * <p>Does not check for a subscription notification.
      * @param <T> the expected value type when unwrapped
      * @param o the notification object
-     * @param s the NbpSubscriber to call methods on
+     * @param s the Observer to call methods on
      * @return true if the notification was a terminal event (i.e., complete or error)
      */
     @SuppressWarnings("unchecked")
@@ -274,7 +274,7 @@ public static <T> boolean acceptFull(Object o, Subscriber<? super T> s) {
     }
     
     /**
-     * Calls the appropriate NbpSubscriber method based on the type of the notification.
+     * Calls the appropriate Observer method based on the type of the notification.
      * @param <T> the expected value type when unwrapped
      * @param o the notification object
      * @param s the subscriber to call methods on

File: src/main/java/io/reactivex/internal/util/ObservableQueueDrain.java
Patch:
@@ -15,7 +15,7 @@
 
 import io.reactivex.Observer;
 
-public interface NbpQueueDrain<T, U> {
+public interface ObservableQueueDrain<T, U> {
     
     boolean cancelled();
     

File: src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
Patch:
@@ -183,7 +183,7 @@ public static <T, U> boolean checkTerminated(boolean d, boolean empty,
         return false;
     }
     
-    public static <T, U> void drainLoop(SimpleQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, NbpQueueDrain<T, U> qd) {
+    public static <T, U> void drainLoop(SimpleQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, ObservableQueueDrain<T, U> qd) {
         
         int missed = 1;
         
@@ -225,7 +225,7 @@ public static <T, U> void drainLoop(SimpleQueue<T> q, Observer<? super U> a, boo
     }
 
     public static <T, U> boolean checkTerminated(boolean d, boolean empty, 
-            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, NbpQueueDrain<T, U> qd) {
+            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, ObservableQueueDrain<T, U> qd) {
         if (qd.cancelled()) {
             q.clear();
             disposable.dispose();

File: src/main/java/io/reactivex/subjects/AsyncSubject.java
Patch:
@@ -22,10 +22,10 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
- * An NbpSubject that emits the very last value followed by a completion event or the received error to NbpSubscribers.
+ * An Subject that emits the very last value followed by a completion event or the received error to Observers.
  *
  * <p>The implementation of onXXX methods are technically thread-safe but non-serialized calls
- * to them may lead to undefined state in the currently subscribed NbpSubscribers.
+ * to them may lead to undefined state in the currently subscribed Observers.
  * 
  * @param <T> the value type
  */

File: src/main/java/io/reactivex/subjects/Subject.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.*;
 
 /**
- * Represents a NbpSubscriber and a NbpObservable at the same time, allowing
+ * Represents an Observer and a Observable at the same time, allowing
  * multicasting events from a single source to multiple child Subscribers.
  * <p>All methods except the onSubscribe, onNext, onError and onComplete are thread-safe.
  * Use {@link #toSerialized()} to make these methods thread-safe as well.

File: src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java
Patch:
@@ -260,9 +260,9 @@ public Publisher<Integer> apply(Integer i) {
         ts.assertNoErrors();
         System.out.println("testFlatMapAsync => Received: " + ts.valueCount() + "  Emitted: " + c.get() + " Size: " + Flowable.bufferSize());
         assertEquals(NUM, ts.valueCount());
-        // even though we only need 10, it will request at least Observable.bufferSize(), and then as it drains keep requesting more
+        // even though we only need 10, it will request at least Flowable.bufferSize(), and then as it drains keep requesting more
         // and then it will be non-deterministic when the take() causes the unsubscribe as it is scheduled on 10 different schedulers (threads)
-        // normally this number is ~250 but can get up to ~1200 when Observable.bufferSize() == 1024
+        // normally this number is ~250 but can get up to ~1200 when Flowable.bufferSize() == 1024
         assertTrue(c.get() <= Flowable.bufferSize() * 2);
     }
 

File: src/test/java/io/reactivex/flowable/FlowableConcatTests.java
Patch:
@@ -38,7 +38,7 @@ public void testConcatSimple() {
     }
 
     @Test
-    public void testConcatWithObservableOfObservable() {
+    public void testConcatWithFlowableOfFlowable() {
         Flowable<String> o1 = Flowable.just("one", "two");
         Flowable<String> o2 = Flowable.just("three", "four");
         Flowable<String> o3 = Flowable.just("five", "six");
@@ -56,7 +56,7 @@ public void testConcatWithObservableOfObservable() {
     }
 
     @Test
-    public void testConcatWithIterableOfObservable() {
+    public void testConcatWithIterableOfFlowable() {
         Flowable<String> o1 = Flowable.just("one", "two");
         Flowable<String> o2 = Flowable.just("three", "four");
         Flowable<String> o3 = Flowable.just("five", "six");

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
Patch:
@@ -151,7 +151,7 @@ public void testSkipLastTimedWhenAllElementsAreValid() {
     
     @Test
     public void skipLastTimedDefaultScheduler() {
-        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        Flowable.just(1).concatWith(Flowable.just(2).delay(500, TimeUnit.MILLISECONDS))
         .skipLast(300, TimeUnit.MILLISECONDS)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
@@ -160,7 +160,7 @@ public void skipLastTimedDefaultScheduler() {
 
     @Test
     public void skipLastTimedDefaultSchedulerDelayError() {
-        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        Flowable.just(1).concatWith(Flowable.just(2).delay(500, TimeUnit.MILLISECONDS))
         .skipLast(300, TimeUnit.MILLISECONDS, true)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
@@ -169,7 +169,7 @@ public void skipLastTimedDefaultSchedulerDelayError() {
 
     @Test
     public void skipLastTimedCustomSchedulerDelayError() {
-        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        Flowable.just(1).concatWith(Flowable.just(2).delay(500, TimeUnit.MILLISECONDS))
         .skipLast(300, TimeUnit.MILLISECONDS, Schedulers.io(), true)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
Patch:
@@ -126,7 +126,7 @@ public void testTakeTimedErrorAfterTime() {
     
     @Test
     public void timedDefaultScheduler() {
-        Observable.range(1, 5).take(1, TimeUnit.MINUTES)
+        Flowable.range(1, 5).take(1, TimeUnit.MINUTES)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
         .assertResult(1, 2, 3, 4, 5);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToFutureTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.TestSubscriber;
 
-public class FlowableToObservableFutureTest {
+public class FlowableToFutureTest {
 
     @Test
     public void testSuccess() throws Exception {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
Patch:
@@ -148,6 +148,5 @@ public void accept(HashSet<Integer> s, Integer v) throws Exception {
         })
         .test()
         .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));
-        
     }
 }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFromIterableTest.java
Patch:
@@ -227,7 +227,7 @@ public void onNext(Integer t) {
         });
         assertFalse(called.get());
     }
- 
+
     @Test
     public void fusionWithConcatMap() {
         TestObserver<Integer> to = new TestObserver<Integer>();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
Patch:
@@ -150,7 +150,7 @@ private void verifyError(Observable<Boolean> NbpObservable) {
     }
     
     @Test
-    public void sequenceEqualBufferSize() {
+    public void prefetch() {
         Observable.sequenceEqual(Observable.range(1, 20), Observable.range(1, 20), 2)
         .test()
         .assertResult(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableToListTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.Observer;
 import io.reactivex.TestHelper;
 
-public class ObservableToObservableListTest {
+public class ObservableToListTest {
 
     @Test
     public void testList() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableToSortedListTest.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.Observer;
 import io.reactivex.TestHelper;
 
-public class ObservableToObservableSortedListTest {
+public class ObservableToSortedListTest {
 
     @Test
     public void testSortedList() {

File: src/test/java/io/reactivex/observable/ObservableConcatTests.java
Patch:
@@ -39,7 +39,7 @@ public void testConcatSimple() {
     }
 
     @Test
-    public void testConcatWithNbpObservableOfNbpObservable() {
+    public void testConcatWithObservableOfObservable() {
         Observable<String> o1 = Observable.just("one", "two");
         Observable<String> o2 = Observable.just("three", "four");
         Observable<String> o3 = Observable.just("five", "six");
@@ -57,7 +57,7 @@ public void testConcatWithNbpObservableOfNbpObservable() {
     }
 
     @Test
-    public void testConcatWithIterableOfNbpObservable() {
+    public void testConcatWithIterableOfObservable() {
         Observable<String> o1 = Observable.just("one", "two");
         Observable<String> o2 = Observable.just("three", "four");
         Observable<String> o3 = Observable.just("five", "six");

File: src/test/java/io/reactivex/observable/ObservableDoOnTest.java
Patch:
@@ -101,6 +101,5 @@ public void run() {
         .test()
         .assertFailure(TestException.class);
         assertTrue(r.get());
-        
     }
 }
\ No newline at end of file

File: src/test/java/io/reactivex/observable/ObservableReduceTests.java
Patch:
@@ -83,13 +83,13 @@ public Movie apply(Movie t1, Movie t2) {
     public void reduceCovariance() {
         // must type it to <Movie>
         Observable<Movie> horrorMovies = Observable.<Movie> just(new HorrorMovie());
-        libraryFunctionActingOnMovieNbpObservables(horrorMovies);
+        libraryFunctionActingOnMovieObservables(horrorMovies);
     }
 
     /*
      * This accepts <Movie> instead of <? super Movie> since `reduce` can't handle covariants
      */
-    public void libraryFunctionActingOnMovieNbpObservables(Observable<Movie> obs) {
+    public void libraryFunctionActingOnMovieObservables(Observable<Movie> obs) {
 
         obs.reduce(new BiFunction<Movie, Movie, Movie>() {
             @Override

File: src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatten.java
Patch:
@@ -28,11 +28,11 @@
  * @param <T> the source value type
  * @param <R> the result value type
  */
-public final class MaybeFlatMap<T, R> extends AbstractMaybeWithUpstream<T, R> {
+public final class MaybeFlatten<T, R> extends AbstractMaybeWithUpstream<T, R> {
 
     final Function<? super T, ? extends MaybeSource<? extends R>> mapper;
 
-    public MaybeFlatMap(MaybeSource<T> source, Function<? super T, ? extends MaybeSource<? extends R>> mapper) {
+    public MaybeFlatten(MaybeSource<T> source, Function<? super T, ? extends MaybeSource<? extends R>> mapper) {
         super(source);
         this.mapper = mapper;
     }

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -101,7 +101,7 @@ public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancel
      * @since 2.0
      */
     UnicastProcessor(int capacityHint) {
-        this.queue = new SpscLinkedArrayQueue<T>(verifyPositive(capacityHint, "capacityHint"));
+        this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));
         this.onTerminate = new AtomicReference<Runnable>();
         this.actual = new AtomicReference<Subscriber<? super T>>();
         this.once = new AtomicBoolean();
@@ -117,7 +117,7 @@ public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancel
      * @since 2.0
      */
     UnicastProcessor(int capacityHint, Runnable onTerminate) {
-        this.queue = new SpscLinkedArrayQueue<T>(verifyPositive(capacityHint, "capacityHint"));
+        this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));
         this.onTerminate = new AtomicReference<Runnable>(ObjectHelper.requireNonNull(onTerminate, "onTerminate"));
         this.actual = new AtomicReference<Subscriber<? super T>>();
         this.once = new AtomicBoolean();

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -115,7 +115,7 @@ public static <T> UnicastSubject<T> create(int capacityHint, Runnable onCancelle
      * @since 2.0
      */
     UnicastSubject(int capacityHint) {
-        this.queue = new SpscLinkedArrayQueue<T>(verifyPositive(capacityHint, "capacityHint"));
+        this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));
         this.onTerminate = new AtomicReference<Runnable>();
         this.actual = new AtomicReference<Observer<? super T>>();
         this.once = new AtomicBoolean();
@@ -130,7 +130,7 @@ public static <T> UnicastSubject<T> create(int capacityHint, Runnable onCancelle
      * @since 2.0
      */
     UnicastSubject(int capacityHint, Runnable onTerminate) {
-        this.queue = new SpscLinkedArrayQueue<T>(verifyPositive(capacityHint, "capacityHint"));
+        this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));
         this.onTerminate = new AtomicReference<Runnable>(ObjectHelper.requireNonNull(onTerminate, "onTerminate"));
         this.actual = new AtomicReference<Observer<? super T>>();
         this.once = new AtomicBoolean();

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -5086,7 +5086,7 @@ public final T blockingSingle(T defaultItem) {
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>
      */
     public final Future<T> toFuture() {
-        return FlowableToFuture.toFuture(this);
+        return subscribeWith(new FutureSubscriber<T>());
     }
     
     /**

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -4538,7 +4538,7 @@ public final T blockingSingle(T defaultItem) {
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>
      */
     public final Future<T> toFuture() {
-        return ObservableToFuture.toFuture(this);
+        return subscribeWith(new FutureObserver<T>());
     }
     
     /**

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -103,7 +103,7 @@ public void onSubscribe(final Disposable d) {
                     return;
                 }
                 
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         try {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUnsubscribeOn.java
Patch:
@@ -43,7 +43,7 @@ public void onError(Throwable e) {
 
             @Override
             public void onSubscribe(final Disposable d) {
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         scheduler.scheduleDirect(new Runnable() {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
Patch:
@@ -130,7 +130,7 @@ public void onError(Throwable e) {
             @Override
             public void onSubscribe(Disposable d) {
                 this.d = d;
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         disposeThis();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -179,7 +179,7 @@ void doSubscribe(final Subscriber<? super T> subscriber, final CompositeDisposab
     }
 
     private Disposable disconnect(final CompositeDisposable current) {
-        return Disposables.from(new Runnable() {
+        return Disposables.fromRunnable(new Runnable() {
             @Override
             public void run() {
                 lock.lock();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
Patch:
@@ -115,7 +115,7 @@ void doSubscribe(final Observer<? super T> subscriber, final CompositeDisposable
     }
 
     private Disposable disconnect(final CompositeDisposable current) {
-        return Disposables.from(new Runnable() {
+        return Disposables.fromRunnable(new Runnable() {
             @Override
             public void run() {
                 lock.lock();

File: src/main/java/io/reactivex/internal/operators/single/SingleUsing.java
Patch:
@@ -71,7 +71,7 @@ public void onSubscribe(Disposable d) {
                 if (eager) {
                     CompositeDisposable set = new CompositeDisposable();
                     set.add(d);
-                    set.add(Disposables.from(new Runnable() {
+                    set.add(Disposables.fromRunnable(new Runnable() {
                         @Override
                         public void run() {
                             try {

File: src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
Patch:
@@ -45,7 +45,7 @@ public Disposable scheduleDirect(Runnable run) {
         try {
             if (executor instanceof ExecutorService) {
                 Future<?> f = ((ExecutorService)executor).submit(decoratedRun);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             }
             
             BooleanRunnable br = new BooleanRunnable(decoratedRun);
@@ -63,7 +63,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
         if (executor instanceof ScheduledExecutorService) {
             try {
                 Future<?> f = ((ScheduledExecutorService)executor).schedule(decoratedRun, delay, unit);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             } catch (RejectedExecutionException ex) {
                 RxJavaPlugins.onError(ex);
                 return EmptyDisposable.INSTANCE;
@@ -91,7 +91,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
             Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
             try {
                 Future<?> f = ((ScheduledExecutorService)executor).scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             } catch (RejectedExecutionException ex) {
                 RxJavaPlugins.onError(ex);
                 return EmptyDisposable.INSTANCE;

File: src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
Patch:
@@ -64,7 +64,7 @@ public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit un
             } else {
                 f = executor.schedule(decoratedRun, delayTime, unit);
             }
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
@@ -84,7 +84,7 @@ public Disposable schedulePeriodicallyDirect(final Runnable run, long initialDel
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             Future<?> f = executor.scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;

File: src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java
Patch:
@@ -85,7 +85,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
             } else {
                 f = executor.get().schedule(decoratedRun, delay, unit);
             }
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
@@ -97,7 +97,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             Future<?> f = executor.get().scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;

File: src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
Patch:
@@ -111,7 +111,7 @@ Disposable enqueue(Runnable action, long execTime) {
                 return EmptyDisposable.INSTANCE;
             } else {
                 // queue wasn't empty, a parent is already processing so we just add to the end of the queue
-                return Disposables.from(new Runnable() {
+                return Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         timedRunnable.disposed = true;

File: src/main/java/io/reactivex/schedulers/TestScheduler.java
Patch:
@@ -145,7 +145,7 @@ public Disposable schedule(Runnable run, long delayTime, TimeUnit unit) {
             final TimedRunnable timedAction = new TimedRunnable(this, time + unit.toNanos(delayTime), run, counter++);
             queue.add(timedAction);
             
-            return Disposables.from(new Runnable() {
+            return Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                     queue.remove(timedAction);
@@ -160,7 +160,7 @@ public Disposable schedule(Runnable run) {
             }
             final TimedRunnable timedAction = new TimedRunnable(this, 0, run, counter++);
             queue.add(timedAction);
-            return Disposables.from(new Runnable() {
+            return Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                     queue.remove(timedAction);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
Patch:
@@ -207,7 +207,7 @@ private void performTestUsingWithObservableFactoryError(boolean disposeEagerly)
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
@@ -245,7 +245,7 @@ private void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean dis
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
Patch:
@@ -132,7 +132,7 @@ public void testUnSubscribeObservableOfObservables() throws InterruptedException
             @Override
             public void subscribe(final Observer<? super Observable<Long>> NbpObserver) {
                 // verbose on purpose so I can track the inside of it
-                final Disposable s = Disposables.from(new Runnable() {
+                final Disposable s = Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         System.out.println("*** unsubscribed");
@@ -502,7 +502,7 @@ public void subscribe(final Observer<? super Long> child) {
                 .subscribe(new Observer<Long>() {
                     @Override
                     public void onSubscribe(final Disposable s) {
-                        child.onSubscribe(Disposables.from(new Runnable() {
+                        child.onSubscribe(Disposables.fromRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 unsubscribed.set(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -301,7 +301,7 @@ private Observable<Long> synchronousInterval() {
             @Override
             public void subscribe(Observer<? super Long> NbpSubscriber) {
                 final AtomicBoolean cancel = new AtomicBoolean();
-                NbpSubscriber.onSubscribe(Disposables.from(new Runnable() {
+                NbpSubscriber.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         cancel.set(true);
@@ -329,7 +329,7 @@ public void onlyFirstShouldSubscribeAndLastUnsubscribe() {
             @Override
             public void subscribe(Observer<? super Integer> NbpObserver) {
                 subscriptionCount.incrementAndGet();
-                NbpObserver.onSubscribe(Disposables.from(new Runnable() {
+                NbpObserver.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                             unsubscriptionCount.incrementAndGet();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
Patch:
@@ -429,7 +429,7 @@ public void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubscribed() throw
             @Override
             public void subscribe(Observer<? super String> s) {
                 subsCount.incrementAndGet();
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                             subsCount.decrementAndGet();
@@ -533,7 +533,7 @@ public SlowObservable(int emitDelay, int countNext) {
         @Override
         public void subscribe(final Observer<? super Long> NbpSubscriber) {
             final AtomicBoolean terminate = new AtomicBoolean(false);
-            NbpSubscriber.onSubscribe(Disposables.from(new Runnable() {
+            NbpSubscriber.onSubscribe(Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                         terminate.set(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
Patch:
@@ -206,7 +206,7 @@ private void performTestUsingWithObservableFactoryError(boolean disposeEagerly)
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
@@ -244,7 +244,7 @@ private void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean dis
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 

File: src/test/java/io/reactivex/single/SingleTest.java
Patch:
@@ -265,7 +265,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
@@ -339,7 +339,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
@@ -395,7 +395,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -5086,7 +5086,7 @@ public final T blockingSingle(T defaultItem) {
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>
      */
     public final Future<T> toFuture() {
-        return FlowableToFuture.toFuture(this);
+        return subscribeWith(new FutureSubscriber<T>());
     }
     
     /**

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -4538,7 +4538,7 @@ public final T blockingSingle(T defaultItem) {
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>
      */
     public final Future<T> toFuture() {
-        return ObservableToFuture.toFuture(this);
+        return subscribeWith(new FutureObserver<T>());
     }
     
     /**

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -103,7 +103,7 @@ public void onSubscribe(final Disposable d) {
                     return;
                 }
                 
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         try {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUnsubscribeOn.java
Patch:
@@ -43,7 +43,7 @@ public void onError(Throwable e) {
 
             @Override
             public void onSubscribe(final Disposable d) {
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         scheduler.scheduleDirect(new Runnable() {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
Patch:
@@ -130,7 +130,7 @@ public void onError(Throwable e) {
             @Override
             public void onSubscribe(Disposable d) {
                 this.d = d;
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         disposeThis();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -179,7 +179,7 @@ void doSubscribe(final Subscriber<? super T> subscriber, final CompositeDisposab
     }
 
     private Disposable disconnect(final CompositeDisposable current) {
-        return Disposables.from(new Runnable() {
+        return Disposables.fromRunnable(new Runnable() {
             @Override
             public void run() {
                 lock.lock();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
Patch:
@@ -115,7 +115,7 @@ void doSubscribe(final Observer<? super T> subscriber, final CompositeDisposable
     }
 
     private Disposable disconnect(final CompositeDisposable current) {
-        return Disposables.from(new Runnable() {
+        return Disposables.fromRunnable(new Runnable() {
             @Override
             public void run() {
                 lock.lock();

File: src/main/java/io/reactivex/internal/operators/single/SingleUsing.java
Patch:
@@ -71,7 +71,7 @@ public void onSubscribe(Disposable d) {
                 if (eager) {
                     CompositeDisposable set = new CompositeDisposable();
                     set.add(d);
-                    set.add(Disposables.from(new Runnable() {
+                    set.add(Disposables.fromRunnable(new Runnable() {
                         @Override
                         public void run() {
                             try {

File: src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
Patch:
@@ -45,7 +45,7 @@ public Disposable scheduleDirect(Runnable run) {
         try {
             if (executor instanceof ExecutorService) {
                 Future<?> f = ((ExecutorService)executor).submit(decoratedRun);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             }
             
             BooleanRunnable br = new BooleanRunnable(decoratedRun);
@@ -63,7 +63,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
         if (executor instanceof ScheduledExecutorService) {
             try {
                 Future<?> f = ((ScheduledExecutorService)executor).schedule(decoratedRun, delay, unit);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             } catch (RejectedExecutionException ex) {
                 RxJavaPlugins.onError(ex);
                 return EmptyDisposable.INSTANCE;
@@ -91,7 +91,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
             Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
             try {
                 Future<?> f = ((ScheduledExecutorService)executor).scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             } catch (RejectedExecutionException ex) {
                 RxJavaPlugins.onError(ex);
                 return EmptyDisposable.INSTANCE;

File: src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
Patch:
@@ -64,7 +64,7 @@ public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit un
             } else {
                 f = executor.schedule(decoratedRun, delayTime, unit);
             }
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
@@ -84,7 +84,7 @@ public Disposable schedulePeriodicallyDirect(final Runnable run, long initialDel
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             Future<?> f = executor.scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;

File: src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java
Patch:
@@ -85,7 +85,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
             } else {
                 f = executor.get().schedule(decoratedRun, delay, unit);
             }
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
@@ -97,7 +97,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             Future<?> f = executor.get().scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;

File: src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
Patch:
@@ -111,7 +111,7 @@ Disposable enqueue(Runnable action, long execTime) {
                 return EmptyDisposable.INSTANCE;
             } else {
                 // queue wasn't empty, a parent is already processing so we just add to the end of the queue
-                return Disposables.from(new Runnable() {
+                return Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         timedRunnable.disposed = true;

File: src/main/java/io/reactivex/schedulers/TestScheduler.java
Patch:
@@ -145,7 +145,7 @@ public Disposable schedule(Runnable run, long delayTime, TimeUnit unit) {
             final TimedRunnable timedAction = new TimedRunnable(this, time + unit.toNanos(delayTime), run, counter++);
             queue.add(timedAction);
             
-            return Disposables.from(new Runnable() {
+            return Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                     queue.remove(timedAction);
@@ -160,7 +160,7 @@ public Disposable schedule(Runnable run) {
             }
             final TimedRunnable timedAction = new TimedRunnable(this, 0, run, counter++);
             queue.add(timedAction);
-            return Disposables.from(new Runnable() {
+            return Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                     queue.remove(timedAction);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
Patch:
@@ -207,7 +207,7 @@ private void performTestUsingWithObservableFactoryError(boolean disposeEagerly)
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
@@ -245,7 +245,7 @@ private void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean dis
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
Patch:
@@ -132,7 +132,7 @@ public void testUnSubscribeObservableOfObservables() throws InterruptedException
             @Override
             public void subscribe(final Observer<? super Observable<Long>> NbpObserver) {
                 // verbose on purpose so I can track the inside of it
-                final Disposable s = Disposables.from(new Runnable() {
+                final Disposable s = Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         System.out.println("*** unsubscribed");
@@ -502,7 +502,7 @@ public void subscribe(final Observer<? super Long> child) {
                 .subscribe(new Observer<Long>() {
                     @Override
                     public void onSubscribe(final Disposable s) {
-                        child.onSubscribe(Disposables.from(new Runnable() {
+                        child.onSubscribe(Disposables.fromRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 unsubscribed.set(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -301,7 +301,7 @@ private Observable<Long> synchronousInterval() {
             @Override
             public void subscribe(Observer<? super Long> NbpSubscriber) {
                 final AtomicBoolean cancel = new AtomicBoolean();
-                NbpSubscriber.onSubscribe(Disposables.from(new Runnable() {
+                NbpSubscriber.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         cancel.set(true);
@@ -329,7 +329,7 @@ public void onlyFirstShouldSubscribeAndLastUnsubscribe() {
             @Override
             public void subscribe(Observer<? super Integer> NbpObserver) {
                 subscriptionCount.incrementAndGet();
-                NbpObserver.onSubscribe(Disposables.from(new Runnable() {
+                NbpObserver.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                             unsubscriptionCount.incrementAndGet();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
Patch:
@@ -429,7 +429,7 @@ public void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubscribed() throw
             @Override
             public void subscribe(Observer<? super String> s) {
                 subsCount.incrementAndGet();
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                             subsCount.decrementAndGet();
@@ -533,7 +533,7 @@ public SlowObservable(int emitDelay, int countNext) {
         @Override
         public void subscribe(final Observer<? super Long> NbpSubscriber) {
             final AtomicBoolean terminate = new AtomicBoolean(false);
-            NbpSubscriber.onSubscribe(Disposables.from(new Runnable() {
+            NbpSubscriber.onSubscribe(Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                         terminate.set(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
Patch:
@@ -206,7 +206,7 @@ private void performTestUsingWithObservableFactoryError(boolean disposeEagerly)
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
@@ -244,7 +244,7 @@ private void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean dis
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 

File: src/test/java/io/reactivex/single/SingleTest.java
Patch:
@@ -265,7 +265,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
@@ -339,7 +339,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
@@ -395,7 +395,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
Patch:
@@ -108,12 +108,12 @@ public void onNext(T t) {
                if (dq.size() == bufferSize) {
                    switch (strategy) {
                    case DROP_LATEST:
-                       dq.poll();
+                       dq.pollLast();
                        dq.offer(t);
                        callOnOverflow = true;
                        break;
                    case DROP_OLDEST:
-                       dq.pollLast();
+                       dq.poll();
                        dq.offer(t);
                        callOnOverflow = true;
                        break;
@@ -123,6 +123,7 @@ public void onNext(T t) {
                    }
                } else {
                    dq.offer(t);
+                   drain();
                    return;
                }
             }

File: src/main/java/io/reactivex/disposables/SerialDisposable.java
Patch:
@@ -15,7 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 /**
  * A Disposable container that allows atomically updating/replacing the contained

File: src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
Patch:
@@ -42,6 +42,7 @@ public ListCompositeDisposable(Disposable... resources) {
     
     public ListCompositeDisposable(Iterable<? extends Disposable> resources) {
         ObjectHelper.requireNonNull(resources, "resources is null");
+        this.resources = new LinkedList<Disposable>();
         for (Disposable d : resources) {
             ObjectHelper.requireNonNull(d, "Disposable item is null");
             this.resources.add(d);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.flowable.QueueDrainSubscriber;
 import io.reactivex.internal.subscriptions.*;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -19,11 +19,11 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.*;
+import io.reactivex.Scheduler;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.flowable.QueueDrainSubscriber;
 import io.reactivex.internal.subscriptions.*;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -18,10 +18,10 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.*;
+import io.reactivex.Scheduler;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.MissingBackpressureException;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.flowable.QueueDrainSubscriber;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.*;
 import io.reactivex.plugins.RxJavaPlugins;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.*;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class ObservableInterval extends Observable<Long> {
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableIntervalRange.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class ObservableIntervalRange extends Observable<Long> {
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableSampleWithObservable<T> extends AbstractObservableWithUpstream<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObserverResourceWrapper.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class ObserverResourceWrapper<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
     /** */

File: src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 

File: src/main/java/io/reactivex/internal/subscribers/completable/CallbackCompletableObserver.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CallbackCompletableObserver

File: src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableObserver.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class EmptyCompletableObserver

File: src/main/java/io/reactivex/internal/subscribers/flowable/ForEachWhileSubscriber.java
Patch:
@@ -18,7 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -85,7 +85,7 @@ public void onError(Throwable t) {
             onError.accept(t);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
+            RxJavaPlugins.onError(new CompositeException(t, ex));
         }
     }
     

File: src/main/java/io/reactivex/internal/subscribers/observable/BlockingObserver.java
Patch:
@@ -16,9 +16,9 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.*;
+import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.util.NotificationLite;
 
 public final class BlockingObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class LambdaObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {

File: src/main/java/io/reactivex/internal/subscribers/single/BiConsumerSingleObserver.java
Patch:
@@ -17,9 +17,9 @@
 
 import io.reactivex.SingleObserver;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.BiConsumer;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class BiConsumerSingleObserver<T>
@@ -40,7 +40,7 @@ public void onError(Throwable e) {
             onCallback.accept(null, e);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
+            RxJavaPlugins.onError(new CompositeException(e, ex));
         }
     }
     

File: src/main/java/io/reactivex/internal/subscribers/single/ConsumerSingleObserver.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ConsumerSingleObserver<T>

File: src/main/java/io/reactivex/observers/DisposableObserver.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 /**
  * An abstract Observer that allows asynchronous cancellation by implementing Disposable.

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
Patch:
@@ -30,7 +30,7 @@ public void fromFutureTimeout() throws Exception {
         Observable.fromFuture(Observable.never()
         .toFuture(), 100, TimeUnit.MILLISECONDS, Schedulers.io())
         .test()
-        .awaitDone()
+        .awaitDone(5, TimeUnit.SECONDS)
         .assertFailure(TimeoutException.class);
     }
     

File: src/test/java/io/reactivex/subjects/PublishSubjectTest.java
Patch:
@@ -649,7 +649,7 @@ public void run() {
 
             TestHelper.race(r1, r2, Schedulers.io());
             
-            ts.awaitDone()
+            ts.awaitDone(5, TimeUnit.SECONDS)
             .assertResult();
         }
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java
Patch:
@@ -20,6 +20,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
@@ -75,7 +76,7 @@ public void run() {
                     actual.onNext(0L);
                     actual.onComplete();
                 } else {
-                    actual.onError(new IllegalStateException("Can't deliver value due to lack of requests"));
+                    actual.onError(new MissingBackpressureException("Can't deliver value due to lack of requests"));
                 }
                 lazySet(EmptyDisposable.INSTANCE);
             }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSequenceEqual.java
Patch:
@@ -39,6 +39,7 @@ public ObservableSequenceEqual(ObservableSource<? extends T> first, ObservableSo
     @Override
     public void subscribeActual(Observer<? super Boolean> s) {
         EqualCoordinator<T> ec = new EqualCoordinator<T>(s, bufferSize, first, second, comparer);
+        s.onSubscribe(ec);
         ec.subscribe();
     }
     

File: src/main/java/io/reactivex/internal/operators/single/SingleAmbArray.java
Patch:
@@ -60,13 +60,15 @@ public void onSubscribe(Disposable d) {
                 @Override
                 public void onSuccess(T value) {
                     if (once.compareAndSet(false, true)) {
+                        set.dispose();
                         s.onSuccess(value);
                     }
                 }
 
                 @Override
                 public void onError(Throwable e) {
                     if (once.compareAndSet(false, true)) {
+                        set.dispose();
                         s.onError(e);
                     } else {
                         RxJavaPlugins.onError(e);

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java
Patch:
@@ -73,7 +73,7 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(U value) {
-            get().dispose();
+            s.cancel();
             onComplete();
         }
         

File: src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
Patch:
@@ -45,7 +45,7 @@ public final class SpscLinkedArrayQueue<T> implements SimpleQueue<T> {
     private static final Object HAS_NEXT = new Object();
 
     public SpscLinkedArrayQueue(final int bufferSize) {
-        int p2capacity = Pow2.roundToPowerOfTwo(bufferSize);
+        int p2capacity = Pow2.roundToPowerOfTwo(Math.max(8, bufferSize));
         int mask = p2capacity - 1;
         AtomicReferenceArray<Object> buffer = new AtomicReferenceArray<Object>(p2capacity + 1);
         producerBuffer = buffer;

File: src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
Patch:
@@ -54,6 +54,7 @@ public Disposable scheduleDirect(Runnable run) {
     public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
         try {
             unit.sleep(delay);
+            run.run();
         } catch (InterruptedException ex) {
             Thread.currentThread().interrupt();
             RxJavaPlugins.onError(ex);

File: src/main/java/io/reactivex/observers/TestObserver.java
Patch:
@@ -895,15 +895,16 @@ public final TestObserver<T> awaitDone() throws InterruptedException {
      * @param time the waiting time
      * @param unit the time unit of the waiting time
      * @return this
-     * @throws InterruptedException if the wait is interrupted
+     * @throws RuntimeException wrapping an InterruptedException if the wait is interrupted
      */
-    public final TestObserver<T> awaitDone(long time, TimeUnit unit) throws InterruptedException {
+    public final TestObserver<T> awaitDone(long time, TimeUnit unit) {
         try {
             if (!done.await(time, unit)) {
                 cancel();
             }
         } catch (InterruptedException ex) {
             cancel();
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return this;
     }

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -957,15 +957,16 @@ public final TestSubscriber<T> awaitDone() throws InterruptedException {
      * @param time the waiting time
      * @param unit the time unit of the waiting time
      * @return this
-     * @throws InterruptedException if the wait is interrupted
+     * @throws RuntimeException wrapping an InterruptedException if the wait is interrupted
      */
-    public final TestSubscriber<T> awaitDone(long time, TimeUnit unit) throws InterruptedException {
+    public final TestSubscriber<T> awaitDone(long time, TimeUnit unit) {
         try {
             if (!done.await(time, unit)) {
                 cancel();
             }
         } catch (InterruptedException ex) {
             cancel();
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return this;
     }

File: src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java
Patch:
@@ -57,12 +57,12 @@ public void accept(String t) {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     @Test(timeout = 60000)

File: src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
Patch:
@@ -139,12 +139,12 @@ public void accept(String t) {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     @Test(timeout = 60000)

File: src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
Patch:
@@ -27,12 +27,12 @@ protected Scheduler getScheduler() {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     // FIXME no longer testable due to internal changes

File: src/test/java/io/reactivex/schedulers/SchedulerTestHelper.java
Patch:
@@ -20,8 +20,8 @@
 import io.reactivex.*;
 import io.reactivex.subscribers.DefaultSubscriber;
 
-final class SchedulerTests {
-    private SchedulerTests() {
+final class SchedulerTestHelper {
+    private SchedulerTestHelper() {
         // No instances.
     }
 

File: src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java
Patch:
@@ -13,7 +13,7 @@
 
 package io.reactivex.schedulers;
 
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -83,7 +83,7 @@ public void run() {
 
             Thread.sleep(150);
             
-            s.drift = -1000 - TimeUnit.NANOSECONDS.toMillis(Scheduler.clockDriftTolerance());
+            s.drift = -TimeUnit.SECONDS.toNanos(1) - Scheduler.clockDriftTolerance();
             
             Thread.sleep(400);
             
@@ -125,7 +125,7 @@ public void run() {
 
             Thread.sleep(150);
             
-            s.drift = 1000 + TimeUnit.NANOSECONDS.toMillis(Scheduler.clockDriftTolerance());
+            s.drift = TimeUnit.SECONDS.toNanos(1) + Scheduler.clockDriftTolerance();
             
             Thread.sleep(400);
             

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -4848,7 +4848,7 @@ public final void blockingForEach(Consumer<? super T> onNext) {
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 ((Disposable)it).dispose();
-                throw Exceptions.propagate(e);
+                throw ExceptionHelper.wrapOrThrow(e);
             }
         }
     }
@@ -13181,7 +13181,7 @@ public final <R> R to(Function<? super Flowable<T>, R> converter) {
             return converter.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -4346,7 +4346,7 @@ public final void blockingForEach(Consumer<? super T> onNext) {
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 ((Disposable)it).dispose();
-                throw Exceptions.propagate(e);
+                throw ExceptionHelper.wrapOrThrow(e);
             }
         }
     }
@@ -11154,7 +11154,7 @@ public final <R> R to(Function<? super Observable<T>, R> converter) {
             return converter.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.internal.operators.flowable.*;
 import io.reactivex.internal.operators.single.*;
 import io.reactivex.internal.subscribers.single.*;
-import io.reactivex.internal.util.ErrorMode;
+import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -249,7 +249,6 @@ public static <T> Flowable<T> concat(
      * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}
      * @return the new Single instance
      * @see FlowableOnSubscribe
-     * @see FlowableEmitter.BackpressureMode
      * @see Cancellable
      */
     public static <T> Single<T> create(SingleOnSubscribe<T> source) {
@@ -2366,7 +2365,7 @@ public final <R> R to(Function<? super Single<T>, R> convert) {
             return convert.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 

File: src/main/java/io/reactivex/disposables/ActionDisposable.java
Patch:
@@ -12,8 +12,8 @@
  */
 package io.reactivex.disposables;
 
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.util.ExceptionHelper;
 
 final class ActionDisposable extends ReferenceDisposable<Action> {
     /** */
@@ -28,8 +28,7 @@ protected void onDisposed(Action value) {
         try {
             value.run();
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 }

File: src/main/java/io/reactivex/disposables/SerialDisposable.java
Patch:
@@ -81,6 +81,6 @@ public void dispose() {
     
     @Override
     public boolean isDisposed() {
-        return DisposableHelper.isDisposed(get());
+        return DisposableHelper.isDisposed(resource.get());
     }
 }

File: src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
Patch:
@@ -17,6 +17,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.ExceptionHelper;
 
 /**
  * A disposable container that can hold onto multiple other disposables.
@@ -177,7 +178,7 @@ void dispose(List<Disposable> set) {
         }
         if (errors != null) {
             if (errors.size() == 1) {
-                throw Exceptions.propagate(errors.get(0));
+                throw ExceptionHelper.wrapOrThrow(errors.get(0));
             }
             throw new CompositeException(errors);
         }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
Patch:
@@ -93,6 +93,7 @@ public void onError(Throwable t) {
                 actual.onError(t);
                 return;
             }
+            done = true;
             RxJavaPlugins.onError(t);
         }
         

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
Patch:
@@ -20,9 +20,9 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public final class BlockingFlowableIterator<T> 
 extends AtomicReference<Subscription>
@@ -67,7 +67,7 @@ public boolean hasNext() {
             if (d) {
                 Throwable e = error;
                 if (e != null) {
-                    throw Exceptions.propagate(e);
+                    throw ExceptionHelper.wrapOrThrow(e);
                 } else
                 if (empty) {
                     return false;
@@ -81,7 +81,7 @@ public boolean hasNext() {
                     }
                 } catch (InterruptedException ex) {
                     run();
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 } finally {
                     lock.unlock();
                 }

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -17,8 +17,7 @@
 
 import org.reactivestreams.Publisher;
 
-import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.subscribers.DefaultSubscriber;
 
 /**
@@ -109,7 +108,7 @@ public T next() {
                             throw new NoSuchElementException();
                         }
                         if (NotificationLite.isError(buf)) {
-                            throw Exceptions.propagate(NotificationLite.getError(buf));
+                            throw ExceptionHelper.wrapOrThrow(NotificationLite.getError(buf));
                         }
                         return NotificationLite.getValue(buf);
                     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
Patch:
@@ -108,7 +108,7 @@ public void accept(Subscription s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
Patch:
@@ -21,10 +21,10 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.flowables.ConnectableFlowable;
-import io.reactivex.functions.*;
+import io.reactivex.functions.Consumer;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -180,7 +180,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -217,7 +217,7 @@ public void subscribe(Subscriber<? super T> child) {
                             buf = bufferFactory.call();
                         } catch (Throwable ex) {
                             Exceptions.throwIfFatal(ex);
-                            throw Exceptions.propagate(ex);
+                            throw ExceptionHelper.wrapOrThrow(ex);
                         }
                         // create a new subscriber to source
                         ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);
@@ -287,7 +287,7 @@ public void connect(Consumer<? super Disposable> connection) {
                     buf = bufferFactory.call();
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 }
                 
                 // create a new subscriber-to-source
@@ -322,7 +322,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);

File: src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
Patch:
@@ -18,9 +18,9 @@
 import java.util.concurrent.locks.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public final class BlockingObservableIterator<T> 
 extends AtomicReference<Disposable>
@@ -57,7 +57,7 @@ public boolean hasNext() {
             if (d) {
                 Throwable e = error;
                 if (e != null) {
-                    throw Exceptions.propagate(e);
+                    throw ExceptionHelper.wrapOrThrow(e);
                 } else
                 if (empty) {
                     return false;
@@ -71,7 +71,7 @@ public boolean hasNext() {
                     }
                 } catch (InterruptedException ex) {
                     run();
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 } finally {
                     lock.unlock();
                 }

File: src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
Patch:
@@ -17,8 +17,7 @@
 import java.util.*;
 
 import io.reactivex.ObservableSource;
-import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.observers.DefaultObserver;
 
 /**
@@ -109,7 +108,7 @@ public T next() {
                             throw new NoSuchElementException();
                         }
                         if (NotificationLite.isError(buf)) {
-                            throw Exceptions.propagate(NotificationLite.getError(buf));
+                            throw ExceptionHelper.wrapOrThrow(NotificationLite.getError(buf));
                         }
                         return NotificationLite.getValue(buf);
                     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAutoConnect.java
Patch:
@@ -35,9 +35,6 @@ public final class ObservableAutoConnect<T> extends Observable<T> {
     public ObservableAutoConnect(ConnectableObservable<? extends T> source,
             int numberOfSubscribers,
             Consumer<? super Disposable> connection) {
-        if (numberOfSubscribers <= 0) {
-            throw new IllegalArgumentException("numberOfSubscribers > 0 required");
-        }
         this.source = source;
         this.numberOfSubscribers = numberOfSubscribers;
         this.connection = connection;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
Patch:
@@ -108,7 +108,7 @@ public void accept(Disposable s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java
Patch:
@@ -187,7 +187,7 @@ void disposeAll() {
                     inner = observers.poll();
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 }
                 if (inner == null) {
                     return;

File: src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.observables.ConnectableObservable;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -209,7 +209,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);

File: src/main/java/io/reactivex/internal/operators/single/SingleAwait.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public enum SingleAwait {
     ;
@@ -54,7 +54,7 @@ public void onSuccess(T value) {
         }
         Throwable e = errorRef.get();
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
         return valueRef.get();
     }

File: src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
Patch:
@@ -17,7 +17,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public abstract class BlockingSingleSubscriber<T> extends CountDownLatch
 implements Subscriber<T>, Disposable {
@@ -74,13 +74,13 @@ public final T blockingGet() {
                 await();
             } catch (InterruptedException ex) {
                 dispose();
-                throw Exceptions.propagate(ex);
+                throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
         
         Throwable e = error;
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
         return value;
     }

File: src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
Patch:
@@ -16,7 +16,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public abstract class BlockingSingleObserver<T> extends CountDownLatch
 implements Observer<T>, Disposable {
@@ -70,13 +70,13 @@ public final T blockingGet() {
                 await();
             } catch (InterruptedException ex) {
                 dispose();
-                throw Exceptions.propagate(ex);
+                throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
         
         Throwable e = error;
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
         return value;
     }

File: src/test/java/io/reactivex/completable/CompletableTest.java
Patch:
@@ -33,6 +33,7 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
@@ -3439,7 +3440,7 @@ private static void expectUncaughtTestException(Action action) {
             assertTrue("A TestException should have been delivered to the handler",
                     caught instanceof TestException);
         } catch (Throwable ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         } finally {
             Thread.setDefaultUncaughtExceptionHandler(originalHandler);
         }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
Patch:
@@ -23,8 +23,8 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableDoAfterTerminateTest {
@@ -43,7 +43,7 @@ private void checkActionCalled(Flowable<String> input) {
         try {
             verify(aAction0, times(1)).run();
         } catch (Throwable ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFinallyTest.java
Patch:
@@ -18,8 +18,8 @@
 import org.junit.*;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public class ObservableFinallyTest {
 
@@ -38,7 +38,7 @@ private void checkActionCalled(Observable<String> input) {
         try {
             verify(aAction0, times(1)).run();
         } catch (Throwable e) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
 

File: src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
Patch:
@@ -26,9 +26,9 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public class TestSchedulerTest {
 
@@ -49,7 +49,7 @@ public void run() {
                     try {
                         calledOp.apply(scheduler.now(TimeUnit.MILLISECONDS));
                     } catch (Throwable ex) {
-                        Exceptions.propagate(ex);
+                        ExceptionHelper.wrapOrThrow(ex);
                     }
                 }
             }, 1, 2, TimeUnit.SECONDS);
@@ -99,7 +99,7 @@ public void run() {
                     try {
                         calledOp.apply(scheduler.now(TimeUnit.MILLISECONDS));
                     } catch (Throwable ex) {
-                        Exceptions.propagate(ex);
+                        ExceptionHelper.wrapOrThrow(ex);
                     }
                 }
             }, 1, 2, TimeUnit.SECONDS);

File: src/main/java/io/reactivex/package-info.java
Patch:
@@ -47,7 +47,7 @@
  * {@link io.reactivex.Flowable}, {@link io.reactivex.Observable}, {@link io.reactivex.Single}
  * or {@link io.reactivex.Completable} class which then allow consumers to subscribe to them
  * and receive events.</p>
- * <p>Usage examples can be found on the {@link rx.Observable} and {@link org.reactivestreams.Subscriber} classes.</p>
+ * <p>Usage examples can be found on the {@link io.reactivex.Flowable}/{@link io.reactivex.Observable} and {@link org.reactivestreams.Subscriber} classes.</p>
  */
 package io.reactivex;
 

File: src/main/java/io/reactivex/FlowableEmitter.java
Patch:
@@ -24,7 +24,7 @@
  * The onNext, onError and onComplete methods should be called 
  * in a sequential manner, just like the Subscriber's methods.
  * Use {@link #serialize()} if you want to ensure this. 
- * The other methods are threadsafe.
+ * The other methods are thread-safe.
  *
  * @param <T> the value type to emit
  */
@@ -45,13 +45,14 @@ public interface FlowableEmitter<T> extends Emitter<T> {
     void setCancellable(Cancellable c);
     /**
      * The current outstanding request amount.
-     * <p>This method it threadsafe.
+     * <p>This method is thread-safe.
      * @return the current outstanding request amount
      */
     long requested();
     
     /**
      * Returns true if the downstream cancelled the sequence.
+     * <p>This method is thread-safe.
      * @return true if the downstream cancelled the sequence
      */
     boolean isCancelled();

File: src/main/java/io/reactivex/ObservableEmitter.java
Patch:
@@ -23,7 +23,7 @@
  * The onNext, onError and onComplete methods should be called 
  * in a sequential manner, just like the Observer's methods.
  * Use {@link #serialize()} if you want to ensure this. 
- * The other methods are threadsafe.
+ * The other methods are thread-safe.
  *
  * @param <T> the value type to emit
  */

File: src/main/java/io/reactivex/SingleObserver.java
Patch:
@@ -34,7 +34,7 @@ public interface SingleObserver<T> {
     /**
      * Provides the SingleObserver with the means of cancelling (disposing) the
      * connection (channel) with the Single in both
-     * synchronous (from within {@link #onSubscribe(Disposable)} itself) and asynchronous manner. 
+     * synchronous (from within {@code onSubscribe(Disposable)} itself) and asynchronous manner.
      * @param d the Disposable instance whose {@link Disposable#dispose()} can
      * be called anytime to cancel the connection
      * @since 2.0

File: src/main/java/io/reactivex/disposables/CompositeDisposable.java
Patch:
@@ -104,7 +104,7 @@ public boolean add(Disposable d) {
     }
 
     /**
-     * Atomically adds the givel array of Disposables to the container or
+     * Atomically adds the given array of Disposables to the container or
      * disposes them all if the container has been disposed.
      * @param ds the array of Disposables
      * @return true if the operation was successful, false if the container has been disposed

File: src/main/java/io/reactivex/disposables/Disposables.java
Patch:
@@ -89,8 +89,8 @@ public static Disposable from(Subscription subscription) {
     }
 
     /**
-     * Returns a new, undisposed Disposable instance.
-     * @return a new, undisposed Disposable instance
+     * Returns a new, non-disposed Disposable instance.
+     * @return a new, non-disposed Disposable instance
      */
     public static Disposable empty() {
         return from(Functions.EMPTY_RUNNABLE);

File: src/main/java/io/reactivex/internal/functions/ObjectHelper.java
Patch:
@@ -29,7 +29,7 @@ public enum ObjectHelper {
      * @return the object itself
      * @throws NullPointerException if object is null
      */
-    public static final <T> T requireNonNull(T object, String message) {
+    public static <T> T requireNonNull(T object, String message) {
         if (object == null) {
             throw new NullPointerException(message);
         }
@@ -85,7 +85,7 @@ public boolean test(Object o1, Object o2) {
     /**
      * Returns a BiPredicate that compares its parameters via Objects.equals().
      * @param <T> the value type
-     * @return the bipredicate
+     * @return the bi-predicate instance
      */
     @SuppressWarnings("unchecked")
     public static <T> BiPredicate<T, T> equalsPredicate() {

File: src/main/java/io/reactivex/internal/fuseable/ScalarCallable.java
Patch:
@@ -18,7 +18,7 @@
  * A marker interface indicating that a scalar, constant value
  * is held by the implementing reactive type which can be
  * safely extracted during assembly time can be used for
- * optimiziation.
+ * optimization.
  * <p>
  * Implementors of {@link #call()} should not throw any exception.
  * <p>

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
Patch:
@@ -44,10 +44,10 @@ public void subscribeActual(final CompletableObserver s) {
                 NullPointerException npe = new NullPointerException("A completable source is null");
                 if (once.compareAndSet(false, true)) {
                     s.onError(npe);
-                    return;
                 } else {
                     RxJavaPlugins.onError(npe);
                 }
+                return;
             }
             
             c.subscribe(new CompletableObserver() {

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -61,7 +61,7 @@ public Iterator<T> iterator() {
     static final class MostRecentObserver<T> extends DefaultSubscriber<T> {
         volatile Object value;
         
-        private MostRecentObserver(T value) {
+        MostRecentObserver(T value) {
             this.value = NotificationLite.next(value);
         }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
Patch:
@@ -64,7 +64,7 @@ public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T>
                 if (o == BlockingSubscriber.TERMINATED) {
                     break;
                 }
-                if (NotificationLite.acceptFull(o, subscriber)) {
+                if (NotificationLite.acceptFull(v, subscriber)) {
                     break;
                 }
             }
@@ -108,7 +108,7 @@ public void accept(Subscription s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
     }
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
Patch:
@@ -95,7 +95,7 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(T t) {
-            synchronized (t) {
+            synchronized (this) {
                 for (U b : buffers) {
                     b.add(t);
                 }
@@ -235,7 +235,7 @@ void close(U b, Disposable d) {
             }
             
             if (e) {
-                fastpathOrderedEmitMax(b, false, this);
+                fastPathOrderedEmitMax(b, false, this);
             }
             
             if (resources.remove(d)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java
Patch:
@@ -94,8 +94,8 @@ public void onError(Throwable t) {
         @Override
         public void onComplete() {
             if (wip.getAndIncrement() == 0) {
-                Publisher<? extends T>[] srcs = sources;
-                int n = srcs.length;
+                Publisher<? extends T>[] sources = this.sources;
+                int n = sources.length;
                 int i = index;
                 for (;;) {
                     
@@ -113,7 +113,7 @@ public void onComplete() {
                         return;
                     }
                     
-                    Publisher<? extends T> p = srcs[i];
+                    Publisher<? extends T> p = sources[i];
                     
                     if (p == null) {
                         Throwable ex = new NullPointerException("A Publisher entry is null");

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java
Patch:
@@ -34,7 +34,6 @@ public void subscribeActual(Subscriber<? super T> s) {
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;
-            return;
         }
         if (error == null) {
             error = new NullPointerException();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -66,9 +66,9 @@ public void subscribeActual(Subscriber<? super R> s) {
             Iterator<? extends R> it;
 
             try {
-                Iterable<? extends R> iter = mapper.apply(v);
+                Iterable<? extends R> iterable = mapper.apply(v);
 
-                it = iter.iterator();
+                it = iterable.iterator();
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 EmptySubscription.error(ex, s);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
Patch:
@@ -173,9 +173,8 @@ public void cancel() {
             cancelled = true;
             s.cancel();
             
-            Deque<T> dq = deque;
             if (getAndIncrement() == 0) {
-                clear(dq);
+                clear(deque);
             }
         }
         

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
Patch:
@@ -126,7 +126,6 @@ public void onSubscribe(Subscription s) {
                 windows.getAndIncrement();
                 s.request(Long.MAX_VALUE);
                 p.subscribe(inner);
-                return;
             }
         }
         

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
Patch:
@@ -720,7 +720,6 @@ public void run() {
             } else {
                 s.cancel();
                 actual.onError(new IllegalStateException("Could not emit the first window due to lack of requests"));
-                return;
             }
         }
         
@@ -843,7 +842,7 @@ void drainLoop() {
                             }
                         } else {
                             for (UnicastProcessor<T> w : ws) {
-                                w.onError(e);
+                                w.onComplete();
                             }
                         }
                         ws.clear();

File: src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
Patch:
@@ -61,7 +61,7 @@ public Iterator<T> iterator() {
     static final class MostRecentObserver<T> extends DefaultObserver<T> {
         volatile Object value;
         
-        private MostRecentObserver(T value) {
+        MostRecentObserver(T value) {
             this.value = NotificationLite.next(value);
         }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java
Patch:
@@ -38,7 +38,7 @@ public void subscribeActual(Observer<? super T> s) {
             sources = new Observable[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Observable<? extends T>[] b = new Observable[count + (count >> 2)];
+                    ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
Patch:
@@ -65,7 +65,7 @@ public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? sup
                 if (o == BlockingSubscriber.TERMINATED) {
                     break;
                 }
-                if (NotificationLite.acceptFull(o, subscriber)) {
+                if (NotificationLite.acceptFull(v, subscriber)) {
                     break;
                 }
             }
@@ -108,7 +108,7 @@ public void accept(Disposable s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
     }
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java
Patch:
@@ -93,7 +93,7 @@ public void onSubscribe(Disposable s) {
         
         @Override
         public void onNext(T t) {
-            synchronized (t) {
+            synchronized (this) {
                 for (U b : buffers) {
                     b.add(t);
                 }
@@ -221,7 +221,7 @@ void close(U b, Disposable d) {
             }
             
             if (e) {
-                fastpathOrderedEmit(b, false, this);
+                fastPathOrderedEmit(b, false, this);
             }
             
             if (resources.remove(d)) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
Patch:
@@ -41,7 +41,7 @@ protected void subscribeActual(Observer<? super U> t) {
         }
         
         if (u == null) {
-            EmptyDisposable.error(new NullPointerException("The inital supplier returned a null value"), t);
+            EmptyDisposable.error(new NullPointerException("The initialSupplier returned a null value"), t);
             return;
         }
         

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
Patch:
@@ -52,7 +52,7 @@ public void subscribeActual(Observer<? super R> s) {
             sources = new Observable[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Observable<? extends T>[] b = new Observable[count + (count >> 2)];
+                    ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
Patch:
@@ -48,8 +48,8 @@ public void subscribeActual(Observer<? super U> s) {
         }
         
         if (delayErrors == ErrorMode.IMMEDIATE) {
-            SerializedObserver<U> ssub = new SerializedObserver<U>(s);
-            source.subscribe(new SourceSubscriber<T, U>(ssub, mapper, bufferSize));
+            SerializedObserver<U> serial = new SerializedObserver<U>(s);
+            source.subscribe(new SourceSubscriber<T, U>(serial, mapper, bufferSize));
         } else {
             source.subscribe(new ConcatMapDelayErrorObserver<T, U>(s, mapper, bufferSize, delayErrors == ErrorMode.END));
         }
@@ -229,7 +229,7 @@ void drain() {
                 if (decrementAndGet() == 0) {
                     break;
                 }
-            };
+            }
         }
         
         static final class InnerSubscriber<U> implements Observer<U> {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableError.java
Patch:
@@ -32,7 +32,6 @@ public void subscribeActual(Observer<? super T> s) {
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;
-            return;
         }
         if (error == null) {
             error = new NullPointerException();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
Patch:
@@ -35,7 +35,6 @@ public ObservableRedo(ObservableSource<T> source,
     @Override
     public void subscribeActual(Observer<? super T> s) {
         
-        // FIXE use BehaviorSubject? (once available)
         BehaviorSubject<Notification<Object>> subject = BehaviorSubject.create();
         
         final RedoSubscriber<T> parent = new RedoSubscriber<T>(s, subject, source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
Patch:
@@ -69,7 +69,6 @@ public void onSubscribe(Disposable s) {
                     Disposable d = scheduler.schedulePeriodicallyDirect(this, period, period, unit);
                     if (!timer.compareAndSet(null, d)) {
                         d.dispose();
-                        return;
                     }
                 }
             }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
Patch:
@@ -110,7 +110,6 @@ public void onSubscribe(Disposable s) {
                 if (boundary.compareAndSet(null, inner)) {
                     windows.getAndIncrement();
                     p.subscribe(inner);
-                    return;
                 }
             }
         }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
Patch:
@@ -121,7 +121,6 @@ public void onSubscribe(Disposable s) {
                     Disposable d = scheduler.schedulePeriodicallyDirect(this, timespan, timespan, unit);
                     if (!timer.compareAndSet(null, d)) {
                         d.dispose();
-                        return;
                     }
                     
                 }
@@ -343,7 +342,6 @@ public void onSubscribe(Disposable s) {
                 
                 if (!timer.compareAndSet(null, d)) {
                     d.dispose();
-                    return;
                 }
             }
         }
@@ -728,7 +726,7 @@ void drainLoop() {
                             }
                         } else {
                             for (UnicastSubject<T> w : ws) {
-                                w.onError(e);
+                                w.onComplete();
                             }
                         }
                         ws.clear();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
Patch:
@@ -52,7 +52,7 @@ public void subscribeActual(Observer<? super R> s) {
             sources = new Observable[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Observable<? extends T>[] b = new Observable[count + (count >> 2)];
+                    ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java
Patch:
@@ -22,7 +22,7 @@ public final class RxThreadFactory extends AtomicLong implements ThreadFactory {
     
     final String prefix;
     
-    static volatile boolean CREATE_TRACE = false;
+    static volatile boolean CREATE_TRACE;
     
     public RxThreadFactory(String prefix) {
         this.prefix = prefix;

File: src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
Patch:
@@ -62,7 +62,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
     }
 
     static final class TrampolineWorker extends Scheduler.Worker implements Disposable {
-        private final PriorityBlockingQueue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>();
+        final PriorityBlockingQueue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>();
         
         private final AtomicInteger wip = new AtomicInteger();
 

File: src/main/java/io/reactivex/internal/subscribers/completable/SubscriberCompletableObserver.java
Patch:
@@ -49,7 +49,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void request(long n) {
-        // ingored, no values emitted anyway
+        // ignored, no values emitted anyway
     }
 
     @Override

File: src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
Patch:
@@ -80,7 +80,7 @@ public final T blockingGet() {
         
         Throwable e = error;
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
         return value;
     }

File: src/main/java/io/reactivex/internal/subscribers/observable/BasicFuseableObserver.java
Patch:
@@ -187,7 +187,7 @@ protected final int transitiveBoundaryFusion(int mode) {
     }
 
     // --------------------------------------------------------------
-    // Default implementation of the RS and QS protocol (overridable)
+    // Default implementation of the RS and QS protocol (can be overridden)
     // --------------------------------------------------------------
     
     @Override

File: src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
Patch:
@@ -76,7 +76,7 @@ public final T blockingGet() {
         
         Throwable e = error;
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
         return value;
     }

File: src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
Patch:
@@ -81,7 +81,7 @@ public boolean isDisposed() {
     /**
      * Sets a new resource and disposes the currently held resource.
      * @param r the new resource to set
-     * @return false if this AyncSubscription has been cancelled/disposed
+     * @return false if this AsyncSubscription has been cancelled/disposed
      * @see #replaceResource(Disposable)
      */
     public boolean setResource(Disposable r) {

File: src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
Patch:
@@ -49,10 +49,9 @@ public void request(long n) {
             return;
         }
         if (compareAndSet(NO_REQUEST, REQUESTED)) {
-            T v = value;
             Subscriber<? super T> s = subscriber;
 
-            s.onNext(v);
+            s.onNext(value);
             if (get() != CANCELLED) {
                 s.onComplete();
             }

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
Patch:
@@ -133,7 +133,7 @@ public static boolean setOnce(AtomicReference<Subscription> field, Subscription
 
     /**
      * Atomically sets the subscription on the field but does not
-     * cancel the previouls subscription.
+     * cancel the previous subscription.
      * @param field the target field to set the new subscription on
      * @param s the new subscription
      * @return true if the operation succeeded, false if the target field

File: src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
Patch:
@@ -22,7 +22,7 @@
  */
 public class AppendOnlyLinkedArrayList<T> {
     final int capacity;
-    Object[] head;
+    final Object[] head;
     Object[] tail;
     int offset;
     
@@ -65,7 +65,7 @@ public void setFirst(T value) {
     /**
      * Loops through all elements of the list.
      * @param consumer the consumer of elements
-     * @throws Exception
+     * @throws Exception if the consumer throws
      */
     @SuppressWarnings("unchecked")
     public void forEach(Consumer<? super T> consumer) throws Exception {
@@ -87,7 +87,7 @@ public void forEach(Consumer<? super T> consumer) throws Exception {
      * Loops over all elements of the array until a null element is encountered or
      * the given predicate returns true.
      * @param consumer the consumer of values that returns true if the forEach should terminate
-     * @throws Exception
+     * @throws Exception if the predicate throws
      */
     @SuppressWarnings("unchecked")
     public void forEachWhile(Predicate<? super T> consumer) throws Exception {

File: src/main/java/io/reactivex/internal/util/LinkedArrayList.java
Patch:
@@ -40,7 +40,7 @@ public class LinkedArrayList {
     int indexInTail;
     /**
      * Constructor with the capacity hint of each array segment.
-     * @param capacityHint
+     * @param capacityHint the expected number of elements to hold (can grow beyond that)
      */
     public LinkedArrayList(int capacityHint) {
         this.capacityHint = capacityHint;

File: src/main/java/io/reactivex/internal/util/NotificationLite.java
Patch:
@@ -35,7 +35,7 @@ private enum Complete {
         @Override
         public String toString() {
             return "NotificationLite.Complete";
-        };
+        }
     }
     
     /**

File: src/main/java/io/reactivex/internal/util/OpenHashSet.java
Patch:
@@ -141,9 +141,7 @@ public void clear(Consumer<? super T> clearAction) throws Exception {
             return;
         }
         T[] a = keys;
-        int len = a.length;
-        for (int i = 0; i < len; i++) {
-            T e = a[i];
+        for (T e : a) {
             if (e != null) {
                 clearAction.accept(e);
             }

File: src/main/java/io/reactivex/processors/FlowableProcessor.java
Patch:
@@ -72,4 +72,4 @@ public final FlowableProcessor<T> toSerialized() {
         }
         return new SerializedProcessor<T>(this);
     }
-}
+}
\ No newline at end of file

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -338,7 +338,7 @@ public PublishSubscriber(Subscriber<? super T> actual, State<T> state) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            // not called because requests are handled locally and cancel is forwared to state
+            // not called because requests are handled locally and cancel is forwarded to state
         }
         
         @Override

File: src/main/java/io/reactivex/processors/SerializedProcessor.java
Patch:
@@ -29,7 +29,7 @@
 /* public */ final class SerializedProcessor<T> extends FlowableProcessor<T> {
     /** The actual subscriber to serialize Subscriber calls to. */
     final FlowableProcessor<T> actual;
-    /** Indicates an emission is going on, guarted by this. */
+    /** Indicates an emission is going on, guarded by this. */
     boolean emitting;
     /** If not null, it holds the missed NotificationLite events. */
     AppendOnlyLinkedArrayList<Object> queue;
@@ -107,7 +107,6 @@ public void onError(Throwable t) {
         synchronized (this) {
             if (done) {
                 reportError = true;
-                return;
             } else {
                 done = true;
                 if (emitting) {

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -36,7 +36,7 @@
  * or the Subscribers receive the terminal event (error or completion) if this
  * Subject has terminated.
  * 
- * @param <T> the value type unicasted
+ * @param <T> the value type received and emitted by this Subject subclass
  */
 public final class UnicastProcessor<T> extends FlowableProcessor<T> {
 

File: src/main/java/io/reactivex/schedulers/Schedulers.java
Patch:
@@ -132,7 +132,7 @@ public static Scheduler from(Executor executor) {
     
     /**
      * Shuts down those standard Schedulers which support the SchedulerLifecycle interface.
-     * <p>The operation is idempotent and threadsafe.
+     * <p>The operation is idempotent and thread-safe.
      */
     public static void shutdown() {
         computation().shutdown();
@@ -145,7 +145,7 @@ public static void shutdown() {
     
     /**
      * Starts those standard Schedulers which support the SchedulerLifecycle interface.
-     * <p>The operation is idempotent and threadsafe.
+     * <p>The operation is idempotent and thread-safe.
      */
     public static void start() {
         computation().start();

File: src/main/java/io/reactivex/schedulers/Timed.java
Patch:
@@ -87,7 +87,7 @@ public boolean equals(Object other) {
     @Override
     public int hashCode() {
          int h = value != null ? value.hashCode() : 0;
-         h = h * 31 + (int)((time >>> 31) ^ (time & 0xFFFFFFFF));
+         h = h * 31 + (int)((time >>> 31) ^ time);
          h = h * 31 + unit.hashCode();
          return h;
     }

File: src/main/java/io/reactivex/subjects/SerializedSubject.java
Patch:
@@ -29,7 +29,7 @@
 /* public */ final class SerializedSubject<T> extends Subject<T> {
     /** The actual subscriber to serialize Subscriber calls to. */
     final Subject<T> actual;
-    /** Indicates an emission is going on, guarted by this. */
+    /** Indicates an emission is going on, guarded by this. */
     boolean emitting;
     /** If not null, it holds the missed NotificationLite events. */
     AppendOnlyLinkedArrayList<Object> queue;
@@ -89,7 +89,6 @@ public void onError(Throwable t) {
         synchronized (this) {
             if (done) {
                 reportError = true;
-                return;
             } else {
                 done = true;
                 if (emitting) {

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -33,7 +33,7 @@
  * or the Subscribers receive the terminal event (error or completion) if this
  * Subject has terminated.
  * 
- * @param <T> the value type unicasted
+ * @param <T> the value type received and emitted by this Subject subclass
  */
 public final class UnicastSubject<T> extends Subject<T> {
     /** The subject state. */
@@ -325,7 +325,7 @@ public void onComplete() {
     
     @Override
     public boolean hasObservers() {
-        return state.subscriber != null;
+        return state.subscriber.get() != null;
     }
     
     @Override

File: src/test/java/io/reactivex/completable/CompletableTest.java
Patch:
@@ -3855,7 +3855,7 @@ public void onComplete() {
         Assert.assertTrue("Closure called before onComplete", doneAfter.get());
     }
     
-    @Test(timeout = 5000)
+    @Test
     public void doAfterTerminateWithError() {
         final AtomicBoolean doneAfter = new AtomicBoolean();
         
@@ -3867,13 +3867,13 @@ public void run() {
         });
         
         try {
-            c.blockingAwait();
+            c.blockingAwait(5, TimeUnit.SECONDS);
             Assert.fail("Did not throw TestException");
         } catch (TestException ex) {
             // expected
         }
         
-        Assert.assertFalse("Closure called", doneAfter.get());
+        Assert.assertTrue("Closure not called", doneAfter.get());
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -1666,7 +1666,7 @@ public void onErrorReturnFunctionNull() {
     
     @Test(expected = NullPointerException.class)
     public void onErrorReturnValueNull() {
-        just1.onErrorReturnValue(null);
+        just1.onErrorReturnItem(null);
     }
 
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -1723,7 +1723,7 @@ public void onErrorReturnFunctionNull() {
     
     @Test(expected = NullPointerException.class)
     public void onErrorReturnValueNull() {
-        just1.onErrorReturnValue(null);
+        just1.onErrorReturnItem(null);
     }
 
     @Test(expected = NullPointerException.class)

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
Patch:
@@ -117,7 +117,7 @@ public void subscribe(Subscriber<? super T> child) {
                 }
             }
         };
-        return new FlowablePublish<T>(onSubscribe, source, curr, bufferSize);
+        return RxJavaPlugins.onAssembly(new FlowablePublish<T>(onSubscribe, source, curr, bufferSize));
     }
 
     private FlowablePublish(Publisher<T> onSubscribe, Publisher<T> source,

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -113,7 +113,7 @@ public void accept(Disposable r) {
      */
     public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> co, final Scheduler scheduler) {
         final Flowable<T> observable = co.observeOn(scheduler);
-        return new ConnectableFlowable<T>() {
+        return RxJavaPlugins.onAssembly(new ConnectableFlowable<T>() {
             @Override
             public void connect(Consumer<? super Disposable> connection) {
                 co.connect(connection);
@@ -123,7 +123,7 @@ public void connect(Consumer<? super Disposable> connection) {
             protected void subscribeActual(Subscriber<? super T> s) {
                 observable.subscribe(s);
             }
-        };
+        });
     }
     
     /**
@@ -248,7 +248,7 @@ public void subscribe(Subscriber<? super T> child) {
                 }
             }
         };
-        return new FlowableReplay<T>(onSubscribe, source, curr, bufferFactory);
+        return RxJavaPlugins.onAssembly(new FlowableReplay<T>(onSubscribe, source, curr, bufferFactory));
     }
     
     private FlowableReplay(Publisher<T> onSubscribe, Flowable<T> source,

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryWhen.java
Patch:
@@ -37,7 +37,7 @@ public FlowableRetryWhen(Publisher<T> source,
     public void subscribeActual(Subscriber<? super T> s) {
         SerializedSubscriber<T> z = new SerializedSubscriber<T>(s);
         
-        FlowProcessor<Throwable> processor = new UnicastProcessor<Throwable>(8).toSerialized();
+        FlowableProcessor<Throwable> processor = new UnicastProcessor<Throwable>(8).toSerialized();
         
         Publisher<?> when;
         
@@ -67,7 +67,7 @@ static final class RetryWhenSubscriber<T> extends WhenSourceSubscriber<T, Throwa
         /** */
         private static final long serialVersionUID = -2680129890138081029L;
 
-        public RetryWhenSubscriber(Subscriber<? super T> actual, FlowProcessor<Throwable> processor,
+        public RetryWhenSubscriber(Subscriber<? super T> actual, FlowableProcessor<Throwable> processor,
                 Subscription receiver) {
             super(actual, processor, receiver);
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.functions.Function;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.*;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * Utility classes to work with scalar-sourced XMap operators (where X == { flat, concat, switch }).
@@ -104,7 +105,7 @@ public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,
      * @return the new Flowable instance
      */
     public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {
-        return new ScalarXMapFlowable<T, U>(value, mapper);
+        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));
     }
     
     /**

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * Utility classes to work with scalar-sourced XMap operators (where X == { flat, concat, switch }).
@@ -105,7 +106,7 @@ public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source,
      */
     public static <T, U> Observable<U> scalarXMap(T value, 
             Function<? super T, ? extends ObservableSource<? extends U>> mapper) {
-        return new ScalarXMapObservable<T, U>(value, mapper);
+        return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper));
     }
     
     /**

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -38,7 +38,7 @@
  * 
  * @param <T> the value type unicasted
  */
-public final class UnicastProcessor<T> extends FlowProcessor<T> {
+public final class UnicastProcessor<T> extends FlowableProcessor<T> {
 
     final SpscLinkedArrayQueue<T> queue;
     

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -966,7 +966,7 @@ public String apply(Integer v) {
     
     @Test
     public void testErrorThrownIssue1685() {
-        FlowProcessor<Object> subject = ReplayProcessor.create();
+        FlowableProcessor<Object> subject = ReplayProcessor.create();
 
         Flowable.error(new RuntimeException("oops"))
             .materialize()

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecentTest.java
Patch:
@@ -33,7 +33,7 @@ public void testMostRecentNull() {
 
     @Test
     public void testMostRecent() {
-        FlowProcessor<String> s = PublishProcessor.create();
+        FlowableProcessor<String> s = PublishProcessor.create();
 
         Iterator<String> it = s.blockingMostRecent("default").iterator();
 
@@ -58,7 +58,7 @@ public void testMostRecent() {
 
     @Test(expected = TestException.class)
     public void testMostRecentWithException() {
-        FlowProcessor<String> s = PublishProcessor.create();
+        FlowableProcessor<String> s = PublishProcessor.create();
 
         Iterator<String> it = s.blockingMostRecent("default").iterator();
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -733,7 +733,7 @@ public Flowable<Integer> apply(Integer t) {
                 Flowable<Integer> observable = Flowable.just(t)
                         .subscribeOn(sch)
                 ;
-                FlowProcessor<Integer> subject = new UnicastProcessor<Integer>();
+                FlowableProcessor<Integer> subject = new UnicastProcessor<Integer>();
                 observable.subscribe(subject);
                 return subject;
             }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java
Patch:
@@ -50,7 +50,7 @@ public boolean test(Integer input) {
 
     @Test
     public void testTakeWhileOnSubject1() {
-        FlowProcessor<Integer> s = PublishProcessor.create();
+        FlowableProcessor<Integer> s = PublishProcessor.create();
         Flowable<Integer> take = s.takeWhile(new Predicate<Integer>() {
             @Override
             public boolean test(Integer input) {

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableNextTest.java
Patch:
@@ -294,7 +294,7 @@ public void run() {
 
     @Test /* (timeout = 8000) */
     public void testSingleSourceManyIterators() throws InterruptedException {
-        Observable<Long> o = Observable.interval(100, TimeUnit.MILLISECONDS);
+        Observable<Long> o = Observable.interval(250, TimeUnit.MILLISECONDS);
         PublishSubject<Integer> terminal = PublishSubject.create();
         Observable<Long> source = o.takeUntil(terminal);
 

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -42,13 +42,13 @@ public class ObservableNullTests {
     
     @Test(expected = NullPointerException.class)
     public void ambVarargsNull() {
-        Observable.amb((Observable<Object>[])null);
+        Observable.ambArray((Observable<Object>[])null);
     }
     
     @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void ambVarargsOneIsNull() {
-        Observable.amb(Observable.never(), null).blockingLast();
+        Observable.ambArray(Observable.never(), null).blockingLast();
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/single/SingleNullTests.java
Patch:
@@ -56,13 +56,13 @@ public void ambIterableOneIsNull() {
 
     @Test(expected = NullPointerException.class)
     public void ambArrayNull() {
-        Single.amb((Single<Integer>[])null);
+        Single.ambArray((Single<Integer>[])null);
     }
     
     @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void ambArrayOneIsNull() {
-        Single.amb(null, just1).blockingGet();
+        Single.ambArray(null, just1).blockingGet();
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/flowable/Burst.java
Patch:
@@ -29,6 +29,7 @@
  * Creates {@link Flowable} of a number of items followed by either an error or
  * completion. Cancellation has no effect on preventing emissions until the
  * currently outstanding requests have been met.
+ * @param <T> the value type
  */
 public final class Burst<T> extends Flowable<T> {
 

File: src/main/java/io/reactivex/disposables/ReferenceDisposable.java
Patch:
@@ -15,7 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 /**
  * Base class for Disposable containers that manage some other type that
@@ -28,7 +28,7 @@ abstract class ReferenceDisposable<T> extends AtomicReference<T> implements Disp
     private static final long serialVersionUID = 6537757548749041217L;
 
     ReferenceDisposable(T value) {
-        super(Objects.requireNonNull(value, "value is null"));
+        super(ObjectHelper.requireNonNull(value, "value is null"));
     }
 
     protected abstract void onDisposed(T value);

File: src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -54,7 +54,7 @@ public static boolean set(AtomicReference<Disposable> field, Disposable d) {
     }
     
     public static boolean setOnce(AtomicReference<Disposable> field, Disposable d) {
-        Objects.requireNonNull(d, "d is null");
+        ObjectHelper.requireNonNull(d, "d is null");
         if (!field.compareAndSet(null, d)) {
             d.dispose();
             if (field.get() != DISPOSED) {

File: src/main/java/io/reactivex/internal/functions/ObjectHelper.java
Patch:
@@ -18,7 +18,7 @@
  * Utility methods containing the backport of Java 7's Objects utility class.
  * <p>Named as such to avoid clash with java.util.Objects.
  */
-public enum Objects {
+public enum ObjectHelper {
     ;
     /**
      * Verifies if the object is not null and returns it or throws a NullPointerException
@@ -78,7 +78,7 @@ public static int compare(long v1, long v2) {
     static final BiPredicate<Object, Object> EQUALS = new BiPredicate<Object, Object>() {
         @Override
         public boolean test(Object o1, Object o2) {
-            return Objects.equals(o1, o2);
+            return ObjectHelper.equals(o1, o2);
         }
     };
     

File: src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 public enum CompletableAwait {
     ;
@@ -64,7 +64,7 @@ public void onSubscribe(Disposable d) {
     }
     
     public static boolean await(CompletableSource cc, long timeout, TimeUnit unit) {
-        Objects.requireNonNull(unit, "unit is null");
+        ObjectHelper.requireNonNull(unit, "unit is null");
         
         final CountDownLatch cdl = new CountDownLatch(1);
         final Throwable[] err = new Throwable[1];
@@ -145,7 +145,7 @@ public void onSubscribe(Disposable d) {
     }
     
     public static Throwable get(CompletableSource cc, long timeout, TimeUnit unit) {
-        Objects.requireNonNull(unit, "unit is null");
+        ObjectHelper.requireNonNull(unit, "unit is null");
         
         final CountDownLatch cdl = new CountDownLatch(1);
         final Throwable[] err = new Throwable[1];

File: src/main/java/io/reactivex/internal/operators/completable/CompletableEmpty.java
Patch:
@@ -24,7 +24,6 @@ private CompletableEmpty() {
 
     @Override
     public void subscribeActual(CompletableObserver s) {
-        s.onSubscribe(EmptyDisposable.INSTANCE);
-        s.onComplete();
+        EmptyDisposable.complete(s);
     }
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableError.java
Patch:
@@ -26,7 +26,6 @@ public CompletableError(Throwable error) {
     
     @Override
     protected void subscribeActual(CompletableObserver s) {
-        s.onSubscribe(EmptyDisposable.INSTANCE);
-        s.onError(error);
+        EmptyDisposable.error(error, s);
     }
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java
Patch:
@@ -29,7 +29,6 @@ public CompletableErrorSupplier(Callable<? extends Throwable> errorSupplier) {
 
     @Override
     protected void subscribeActual(CompletableObserver s) {
-        s.onSubscribe(EmptyDisposable.INSTANCE);
         Throwable error;
         
         try {
@@ -42,7 +41,7 @@ protected void subscribeActual(CompletableObserver s) {
         if (error == null) {
             error = new NullPointerException("The error supplied is null");
         }
-        s.onError(error);
+        EmptyDisposable.error(error, s);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
Patch:
@@ -99,8 +99,7 @@ public void onSubscribe(final Disposable d) {
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
                     d.dispose();
-                    s.onSubscribe(EmptyDisposable.INSTANCE);
-                    s.onError(ex);
+                    EmptyDisposable.error(ex, s);
                     return;
                 }
                 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.EmptyDisposable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CompletableUsing<R> extends Completable {
@@ -57,7 +57,7 @@ protected void subscribeActual(final CompletableObserver s) {
         CompletableSource cs;
         
         try {
-            cs = Objects.requireNonNull(completableFunction.apply(resource), "The completableFunction returned a null Completable");
+            cs = ObjectHelper.requireNonNull(completableFunction.apply(resource), "The completableFunction returned a null Completable");
         } catch (Throwable e) {
             try {
                 disposer.accept(resource);

File: src/main/java/io/reactivex/internal/operators/flowable/AbstractFlowableWithUpstream.java
Patch:
@@ -16,7 +16,7 @@
 import org.reactivestreams.Publisher;
 
 import io.reactivex.Flowable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 /**
  * Abstract base class for operators that take an upstream
@@ -38,7 +38,7 @@ abstract class AbstractFlowableWithUpstream<T, R> extends Flowable<R> implements
      * @param source the source (upstream) Publisher instance, not null (verified)
      */
     public AbstractFlowableWithUpstream(Publisher<T> source) {
-        this.source = Objects.requireNonNull(source, "source is null");
+        this.source = ObjectHelper.requireNonNull(source, "source is null");
     }
     
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.BooleanSupplier;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -49,7 +49,7 @@ public FlowableBuffer(Publisher<T> source, int size, int skip, Callable<C> buffe
 
         this.size = size;
         this.skip = skip;
-        this.bufferSupplier = Objects.requireNonNull(bufferSupplier, "bufferSupplier");
+        this.bufferSupplier = ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier");
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscribers.flowable.*;
@@ -116,7 +116,7 @@ public void onNext(T t) {
             Publisher<? extends R> p;
             
             try {
-                p = Objects.requireNonNull(mapper.apply(t), "The mapper returned a null Publisher");
+                p = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null Publisher");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 s.cancel();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -70,7 +70,7 @@ public boolean test(T t) {
                         }
                         Object o = last;
                         last = t;
-                        return !Objects.equals(o, t);
+                        return !ObjectHelper.equals(o, t);
                     }
                 };
             }
@@ -93,7 +93,7 @@ public boolean test(K t) {
                         }
                         Object o = last;
                         last = t;
-                        return !Objects.equals(o, t);
+                        return !ObjectHelper.equals(o, t);
                     }
                 };
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -44,7 +44,7 @@ public FlowableFlatMap(Publisher<T> source,
     
     @Override
     protected void subscribeActual(Subscriber<? super U> s) {
-        if (ScalarXMap.tryScalarXMapSubscribe(source, s, mapper)) {
+        if (FlowableScalarXMap.tryScalarXMapSubscribe(source, s, mapper)) {
             return;
         }
         source.subscribe(new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize));
@@ -136,8 +136,8 @@ public void onNext(T t) {
                     u  = ((Callable<U>)p).call();
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    s.cancel();
-                    onError(ex);
+                    getErrorQueue().offer(ex);
+                    drain();
                     return;
                 }
                 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;
@@ -40,7 +40,7 @@ public FlowableFlattenIterable(Publisher<T> source,
         if (prefetch <= 0) {
             throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
         }
-        this.mapper = Objects.requireNonNull(mapper, "mapper");
+        this.mapper = ObjectHelper.requireNonNull(mapper, "mapper");
         this.prefetch = prefetch;
     }
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -16,7 +16,7 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.Flowable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.ConditionalSubscriber;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
@@ -68,7 +68,7 @@ public final T poll() {
             }
             
             index = i + 1;
-            return Objects.requireNonNull(arr[i], "array element is null");
+            return ObjectHelper.requireNonNull(arr[i], "array element is null");
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.DeferredScalarSubscription;
 
 public final class FlowableFromCallable<T> extends Flowable<T> implements Callable<T> {
@@ -34,7 +34,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         
         T t;
         try {
-            t = Objects.requireNonNull(callable.call(), "The callable returned a null value");
+            t = ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             s.onError(ex);
@@ -46,6 +46,6 @@ public void subscribeActual(Subscriber<? super T> s) {
     
     @Override
     public T call() throws Exception {
-        return Objects.requireNonNull(callable.call(), "The callable returned a null value");
+        return ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");
     }
 }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.ConditionalSubscriber;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
@@ -97,7 +97,7 @@ public final T poll() {
                     return null;
                 }
             }
-            return Objects.requireNonNull(it.next(), "Iterator.next() returned a null value");
+            return ObjectHelper.requireNonNull(it.next(), "Iterator.next() returned a null value");
         }
 
         

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.flowables.GroupedFlowable;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
@@ -133,7 +133,7 @@ public void onNext(T t) {
             
             V v;
             try {
-                v = Objects.requireNonNull(valueSelector.apply(t), "The valueSelector returned null");
+                v = ObjectHelper.requireNonNull(valueSelector.apply(t), "The valueSelector returned null");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 s.cancel();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.Scheduler;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.exceptions.*;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;
@@ -42,7 +42,7 @@ public FlowableObserveOn(
         if (prefetch <= 0) {
             throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
         }
-        this.scheduler = Objects.requireNonNull(scheduler, "scheduler");
+        this.scheduler = ObjectHelper.requireNonNull(scheduler, "scheduler");
         this.delayError = delayError;
         this.prefetch = prefetch;
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.*;
@@ -60,7 +60,7 @@ protected void subscribeActual(Subscriber<? super R> s) {
         Publisher<? extends R> other;
         
         try {
-            other = Objects.requireNonNull(selector.apply(mp), "selector returned a null Publisher");
+            other = ObjectHelper.requireNonNull(selector.apply(mp), "selector returned a null Publisher");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptySubscription.error(ex, s);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatWhen.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.*;
 import io.reactivex.subscribers.SerializedSubscriber;
@@ -44,7 +44,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         Publisher<?> when;
         
         try {
-            when = Objects.requireNonNull(handler.apply(processor), "handler returned a null Publisher");
+            when = ObjectHelper.requireNonNull(handler.apply(processor), "handler returned a null Publisher");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptySubscription.error(ex, s);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryWhen.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.operators.flowable.FlowableRepeatWhen.*;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.processors.*;
@@ -42,7 +42,7 @@ public void subscribeActual(Subscriber<? super T> s) {
         Publisher<?> when;
         
         try {
-            when = Objects.requireNonNull(handler.apply(processor), "handler returned a null Publisher");
+            when = ObjectHelper.requireNonNull(handler.apply(processor), "handler returned a null Publisher");
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
             EmptySubscription.error(ex, s);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -40,7 +40,7 @@ public FlowableSwitchMap(Publisher<T> source,
     
     @Override
     protected void subscribeActual(Subscriber<? super R> s) {
-        if (ScalarXMap.tryScalarXMapSubscribe(source, s, mapper)) {
+        if (FlowableScalarXMap.tryScalarXMapSubscribe(source, s, mapper)) {
             return;
         }
         source.subscribe(new SwitchMapSubscriber<T, R>(s, mapper, bufferSize, delayErrors));

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -170,7 +170,7 @@ public void onNext(T t) {
             R v;
             
             try {
-                v = Objects.requireNonNull(combiner.apply(objects), "combiner returned a null value");
+                v = ObjectHelper.requireNonNull(combiner.apply(objects), "combiner returned a null value");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 cancel();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -70,7 +70,7 @@ public boolean test(T t) {
                         }
                         Object o = last[0];
                         last[0] = t;
-                        return !Objects.equals(o, t);
+                        return !ObjectHelper.equals(o, t);
                     }
                 };
             }
@@ -93,7 +93,7 @@ public boolean test(K t) {
                         }
                         Object o = last[0];
                         last[0] = t;
-                        return !Objects.equals(o, t);
+                        return !ObjectHelper.equals(o, t);
                     }
                 };
             }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableEmpty.java
Patch:
@@ -25,8 +25,7 @@ private ObservableEmpty() {
 
     @Override
     protected void subscribeActual(Observer<? super Object> o) {
-        o.onSubscribe(EmptyDisposable.INSTANCE);
-        o.onComplete();
+        EmptyDisposable.complete(o);
     }
 
     @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromArray.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscribers.observable.BaseQueueDisposable;
 
 public final class ObservableFromArray<T> extends Observable<T> {
@@ -70,7 +70,7 @@ public T poll() {
             T[] a = array;
             if (i != a.length) {
                 index = i + 1;
-                return Objects.requireNonNull(a[i], "The array element is null");
+                return ObjectHelper.requireNonNull(a[i], "The array element is null");
             }
             return null;
         }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromIterable.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.EmptyDisposable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscribers.observable.BaseQueueDisposable;
 
 public final class ObservableFromIterable<T> extends Observable<T> {
@@ -87,7 +87,7 @@ void run() {
                 T v;
                 
                 try {
-                    v = Objects.requireNonNull(it.next(), "The iterator returned a null value");
+                    v = ObjectHelper.requireNonNull(it.next(), "The iterator returned a null value");
                 } catch (Throwable e) {
                     Exceptions.throwIfFatal(e);
                     actual.onError(e);
@@ -136,7 +136,7 @@ public T poll() {
                 checkNext = true;
             }
             
-            return Objects.requireNonNull(it.next(), "The iterator returned a null value");
+            return ObjectHelper.requireNonNull(it.next(), "The iterator returned a null value");
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromMany.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.*;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -165,7 +165,7 @@ public void onNext(T t) {
             R v;
             
             try {
-                v = Objects.requireNonNull(combiner.apply(objects), "combiner returned a null value");
+                v = ObjectHelper.requireNonNull(combiner.apply(objects), "combiner returned a null value");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 dispose();

File: src/main/java/io/reactivex/internal/operators/single/SingleDoOnSubscribe.java
Patch:
@@ -44,8 +44,7 @@ public void onSubscribe(Disposable d) {
                     Exceptions.throwIfFatal(ex);
                     done = true;
                     d.dispose();
-                    s.onSubscribe(EmptyDisposable.INSTANCE);
-                    s.onError(ex);
+                    EmptyDisposable.error(ex, s);
                     return;
                 }
                 

File: src/main/java/io/reactivex/internal/operators/single/SingleEquals.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class SingleEquals<T> extends Single<Boolean> {
@@ -54,7 +54,7 @@ public void onSuccess(T value) {
                 values[index] = value;
                 
                 if (count.incrementAndGet() == 2) {
-                    s.onSuccess(Objects.equals(values[0], values[1]));
+                    s.onSuccess(ObjectHelper.equals(values[0], values[1]));
                 }
             }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleError.java
Patch:
@@ -42,8 +42,7 @@ protected void subscribeActual(SingleObserver<? super T> s) {
             error = new NullPointerException();
         }
         
-        s.onSubscribe(EmptyDisposable.INSTANCE);
-        s.onError(error);
+        EmptyDisposable.error(error, s);
     }
 
 }

File: src/main/java/io/reactivex/internal/operators/single/SingleFlatMapCompletable.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 /**
  * Maps the success value of the source SingleSource into a Completable. 
@@ -82,7 +82,7 @@ public void onSuccess(T value) {
             CompletableSource cs;
             
             try {
-                cs = Objects.requireNonNull(mapper.apply(value), "The mapper returned a null CompletableSource");
+                cs = ObjectHelper.requireNonNull(mapper.apply(value), "The mapper returned a null CompletableSource");
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 onError(ex);

File: src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java
Patch:
@@ -16,7 +16,7 @@
 import org.reactivestreams.Subscription;
 
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -153,7 +153,7 @@ public void onComplete() {
      * @return the value if not null
      */
     protected final <V> V nullCheck(V value, String message) {
-        return Objects.requireNonNull(value, message);
+        return ObjectHelper.requireNonNull(value, message);
     }
     
     /**

File: src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java
Patch:
@@ -16,7 +16,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -138,7 +138,7 @@ public void onComplete() {
      * @return the value if not null
      */
     protected final <V> V nullCheck(V value, String message) {
-        return Objects.requireNonNull(value, message);
+        return ObjectHelper.requireNonNull(value, message);
     }
     
     /**

File: src/main/java/io/reactivex/internal/subscribers/flowable/InnerQueuedSubscriber.java
Patch:
@@ -85,11 +85,11 @@ public void onSubscribe(Subscription s) {
     
     @Override
     public void onNext(T t) {
-        if (fusionMode == QueueSubscription.SYNC) {
+        if (fusionMode == QueueSubscription.NONE) {
+            parent.innerNext(this, t);
+        } else {
             parent.drain();
-            return;
         }
-        parent.innerNext(this, t);
     }
     
     @Override

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -29,7 +29,7 @@
 
 import org.reactivestreams.Subscription;
 
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
 /**
@@ -84,7 +84,7 @@ public final void setSubscription(Subscription s) {
             return;
         }
 
-        Objects.requireNonNull(s, "s is null");
+        ObjectHelper.requireNonNull(s, "s is null");
         
         if (get() == 0 && compareAndSet(0, 1)) {
             Subscription a = actual;

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.reactivestreams.Subscription;
 
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -120,7 +120,7 @@ public static boolean set(AtomicReference<Subscription> field, Subscription d) {
      * @return true if the operation succeeded, false if the target field was not null.
      */
     public static boolean setOnce(AtomicReference<Subscription> field, Subscription d) {
-        Objects.requireNonNull(d, "d is null");
+        ObjectHelper.requireNonNull(d, "d is null");
         if (!field.compareAndSet(null, d)) {
             d.cancel();
             if (field.get() != CANCELLED) {

File: src/main/java/io/reactivex/internal/util/NotificationLite.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 /**
  * Lightweight notification handling utility class.
@@ -63,7 +63,7 @@ public int hashCode() {
         public boolean equals(Object obj) {
             if (obj instanceof ErrorNotification) {
                 ErrorNotification n = (ErrorNotification) obj;
-                return Objects.equals(e, n.e);
+                return ObjectHelper.equals(e, n.e);
             }
             return false;
         }

File: src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
Patch:
@@ -395,7 +395,7 @@ public static <T, U> boolean checkTerminated(boolean d, boolean empty,
      * spsc-linked-array if capacityHint is negative; in both cases, the
      * capacity is the absolute value of prefetch.
      * @param <T> the value type of the queue
-     * @param capacityHint the capacity hint
+     * @param capacityHint the capacity hint, negative value will create an array-based SPSC queue
      * @return the queue instance
      */
     public static <T> SimpleQueue<T> createQueue(int capacityHint) {

File: src/main/java/io/reactivex/observers/ResourceObserver.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 /**
  * An abstract Observer that allows asynchronous cancellation of its subscription and associated resources.
@@ -42,7 +42,7 @@ public abstract class ResourceObserver<T> implements Observer<T>, Disposable {
      * @throws NullPointerException if resource is null
      */
     public final void add(Disposable resource) {
-        Objects.requireNonNull(resource, "resource is null");
+        ObjectHelper.requireNonNull(resource, "resource is null");
         resources.add(resource);
     }
     

File: src/main/java/io/reactivex/processors/BehaviorProcessor.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Predicate;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -95,7 +95,7 @@ public static <T> BehaviorProcessor<T> create() {
      * @return the constructed {@link BehaviorProcessor}
      */
     public static <T> BehaviorProcessor<T> createDefault(T defaultValue) {
-        Objects.requireNonNull(defaultValue, "defaultValue is null");
+        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");
         State<T> state = new State<T>();
         state.lazySet(defaultValue);
         return new BehaviorProcessor<T>(state);

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Scheduler;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -211,8 +211,8 @@ public static <T> ReplayProcessor<T> createWithTime(long maxAge, TimeUnit unit,
      * @return the created subject
      */
     public static <T> ReplayProcessor<T> createWithTimeAndSize(long maxAge, TimeUnit unit, Scheduler scheduler, int size) {
-        Objects.requireNonNull(unit, "unit is null");
-        Objects.requireNonNull(scheduler, "scheduler is null");
+        ObjectHelper.requireNonNull(unit, "unit is null");
+        ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         if (size <= 0) {
             throw new IllegalArgumentException("size > 0 required but it was " + size);
         }

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.*;
@@ -84,7 +84,7 @@ public UnicastProcessor(int capacityHint) {
      */
     public UnicastProcessor(int capacityHint, Runnable onTerminate) {
         this.queue = new SpscLinkedArrayQueue<T>(capacityHint);
-        this.onTerminate = new AtomicReference<Runnable>(Objects.requireNonNull(onTerminate, "onTerminate"));
+        this.onTerminate = new AtomicReference<Runnable>(ObjectHelper.requireNonNull(onTerminate, "onTerminate"));
         this.actual = new AtomicReference<Subscriber<? super T>>();
         this.once = new AtomicBoolean();
         this.wip = new UnicastQueueSubscription();

File: src/main/java/io/reactivex/schedulers/TestScheduler.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.Scheduler;
 import io.reactivex.disposables.*;
 import io.reactivex.internal.disposables.EmptyDisposable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 
 /**
  * A special, non thread-safe scheduler for testing operators that require
@@ -56,9 +56,9 @@ public String toString() {
         @Override
         public int compareTo(TimedRunnable o) {
             if (time == o.time) {
-                return Objects.compare(count, o.count);
+                return ObjectHelper.compare(count, o.count);
             }
-            return Objects.compare(time, o.time);
+            return ObjectHelper.compare(time, o.time);
         }
     }
 

File: src/main/java/io/reactivex/subjects/BehaviorSubject.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Predicate;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -95,7 +95,7 @@ public static <T> BehaviorSubject<T> create() {
      * @return the constructed {@link BehaviorSubject}
      */
     public static <T> BehaviorSubject<T> createDefault(T defaultValue) {
-        Objects.requireNonNull(defaultValue, "defaultValue is null");
+        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");
         State<T> state = new State<T>();
         state.lazySet(defaultValue);
         return new BehaviorSubject<T>(state);

File: src/main/java/io/reactivex/subjects/ReplaySubject.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.*;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.util.NotificationLite;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -208,8 +208,8 @@ public static <T> ReplaySubject<T> createWithTime(long maxAge, TimeUnit unit, Sc
      * @return the created subject
      */
     public static <T> ReplaySubject<T> createWithTimeAndSize(long maxAge, TimeUnit unit, Scheduler scheduler, int size) {
-        Objects.requireNonNull(unit, "unit is null");
-        Objects.requireNonNull(scheduler, "scheduler is null");
+        ObjectHelper.requireNonNull(unit, "unit is null");
+        ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         if (size <= 0) {
             throw new IllegalArgumentException("size > 0 required but it was " + size);
         }

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -148,8 +148,7 @@ public void subscribe(Observer<? super T> s) {
                 subscriber.lazySet(s); // full barrier in drain
                 drain();
             } else {
-                s.onSubscribe(EmptyDisposable.INSTANCE);
-                s.onError(new IllegalStateException("Only a single subscriber allowed."));
+                EmptyDisposable.error(new IllegalStateException("Only a single subscriber allowed."), s);
             }
         }
         

File: src/main/java/io/reactivex/subscribers/ResourceSubscriber.java
Patch:
@@ -18,7 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.*;
-import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
@@ -51,7 +51,7 @@ public abstract class ResourceSubscriber<T> implements Subscriber<T>, Disposable
      * @throws NullPointerException if resource is null
      */
     public final void add(Disposable resource) {
-        Objects.requireNonNull(resource, "resource is null");
+        ObjectHelper.requireNonNull(resource, "resource is null");
         resources.add(resource);
     }
     

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableNextTest.java
Patch:
@@ -25,8 +25,8 @@
 import io.reactivex.Observable;
 import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.processors.BehaviorProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subjects.*;
@@ -238,7 +238,7 @@ public void testNoBufferingOrBlockingOfSequence() throws Throwable {
 
             @Override
             public void subscribe(final Observer<? super Integer> o) {
-                o.onSubscribe(EmptyDisposable.INSTANCE);
+                o.onSubscribe(Disposables.empty());
                 new Thread(new Runnable() {
 
                     @Override

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToIteratorTest.java
Patch:
@@ -20,8 +20,8 @@
 import org.junit.*;
 
 import io.reactivex.*;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.internal.disposables.EmptyDisposable;
 
 public class BlockingObservableToIteratorTest {
 
@@ -50,7 +50,7 @@ public void testToIteratorWithException() {
 
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 NbpObserver.onNext("one");
                 NbpObserver.onError(new TestException());
             }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCreateTest.java
Patch:
@@ -13,7 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertTrue;
+
 import org.junit.Test;
 
 import io.reactivex.*;

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDoOnSubscribeTest.java
Patch:
@@ -20,9 +20,8 @@
 import org.junit.Test;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.disposables.*;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.EmptyDisposable;
 
 public class ObservableDoOnSubscribeTest {
 
@@ -71,7 +70,7 @@ public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
 
             @Override
             public void subscribe(Observer<? super Integer> s) {
-                s.onSubscribe(EmptyDisposable.INSTANCE);
+                s.onSubscribe(Disposables.empty());
                 onSubscribed.incrementAndGet();
                 sref.set(s);
             }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMaterializeTest.java
Patch:
@@ -23,8 +23,8 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.*;
 
 public class ObservableMaterializeTest {
@@ -149,7 +149,7 @@ private static class TestAsyncErrorObservable implements ObservableSource<String
 
         @Override
         public void subscribe(final Observer<? super String> NbpObserver) {
-            NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpObserver.onSubscribe(Disposables.empty());
             t = new Thread(new Runnable() {
 
                 @Override

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeMaxConcurrentTest.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
-import io.reactivex.internal.disposables.EmptyDisposable;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.internal.schedulers.IoScheduler;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
@@ -98,7 +98,7 @@ private static class SubscriptionCheckObservable implements ObservableSource<Str
 
         @Override
         public void subscribe(final Observer<? super String> t1) {
-            t1.onSubscribe(EmptyDisposable.INSTANCE);
+            t1.onSubscribe(Disposables.empty());
             new Thread(new Runnable() {
 
                 @Override

File: src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
-import org.junit.*;
+import org.junit.Test;
 import org.mockito.InOrder;
 
 import io.reactivex.*;

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturnTest.java
Patch:
@@ -23,8 +23,8 @@
 import org.mockito.Mockito;
 
 import io.reactivex.*;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
 
@@ -187,7 +187,7 @@ public TestObservable(String... values) {
 
         @Override
         public void subscribe(final Observer<? super String> NbpSubscriber) {
-            NbpSubscriber.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpSubscriber.onSubscribe(Disposables.empty());
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnExceptionResumeNextViaObservableTest.java
Patch:
@@ -21,9 +21,8 @@
 import org.mockito.Mockito;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.disposables.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
 
@@ -225,7 +224,7 @@ public TestObservable(String... values) {
 
         @Override
         public void subscribe(final Observer<? super String> NbpObserver) {
-            NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpObserver.onSubscribe(Disposables.empty());
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java
Patch:
@@ -26,9 +26,9 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
 
@@ -71,7 +71,7 @@ public void testRepeatTakeWithSubscribeOn() throws InterruptedException {
 
             @Override
             public void subscribe(Observer<? super Integer> sub) {
-                sub.onSubscribe(EmptyDisposable.INSTANCE);
+                sub.onSubscribe(Disposables.empty());
                 counter.incrementAndGet();
                 sub.onNext(1);
                 sub.onNext(2);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSampleTest.java
Patch:
@@ -22,8 +22,7 @@
 import org.mockito.InOrder;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.EmptyDisposable;
+import io.reactivex.disposables.*;
 import io.reactivex.schedulers.TestScheduler;
 import io.reactivex.subjects.PublishSubject;
 
@@ -47,7 +46,7 @@ public void testSample() {
         Observable<Long> source = Observable.unsafeCreate(new ObservableSource<Long>() {
             @Override
             public void subscribe(final Observer<? super Long> observer1) {
-                observer1.onSubscribe(EmptyDisposable.INSTANCE);
+                observer1.onSubscribe(Disposables.empty());
                 innerScheduler.schedule(new Runnable() {
                     @Override
                     public void run() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSerializeTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.*;
 
 import io.reactivex.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.observers.DefaultObserver;
 
 public class ObservableSerializeTest {
@@ -219,7 +219,7 @@ public TestSingleThreadedObservable(final String... values) {
 
         @Override
         public void subscribe(final Observer<? super String> NbpObserver) {
-            NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpObserver.onSubscribe(Disposables.empty());
             System.out.println("TestSingleThreadedObservable subscribed to ...");
             t = new Thread(new Runnable() {
 
@@ -270,7 +270,7 @@ public TestMultiThreadedObservable(String... values) {
 
         @Override
         public void subscribe(final Observer<? super String> NbpObserver) {
-            NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpObserver.onSubscribe(Disposables.empty());
             System.out.println("TestMultiThreadedObservable subscribed to ...");
             final NullPointerException npe = new NullPointerException();
             t = new Thread(new Runnable() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSubscribeOnTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.*;
 
@@ -42,7 +41,7 @@ public void testIssue813() throws InterruptedException {
             @Override
             public void subscribe(
                     final Observer<? super Integer> NbpSubscriber) {
-                NbpSubscriber.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpSubscriber.onSubscribe(Disposables.empty());
                 scheduled.countDown();
                 try {
                     try {
@@ -94,7 +93,7 @@ public void testOnError() {
 
             @Override
             public void subscribe(Observer<? super String> s) {
-                s.onSubscribe(EmptyDisposable.INSTANCE);
+                s.onSubscribe(Disposables.empty());
                 s.onError(new RuntimeException("fail"));
             }
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subjects.PublishSubject;
@@ -112,7 +111,7 @@ public void testTakeDoesntLeakErrors() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 NbpObserver.onNext("one");
                 NbpObserver.onError(new Throwable("test failed"));
             }
@@ -240,7 +239,7 @@ public TestObservableFunc(String... values) {
 
         @Override
         public void subscribe(final Observer<? super String> NbpObserver) {
-            NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpObserver.onSubscribe(Disposables.empty());
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeWhileTest.java
Patch:
@@ -20,10 +20,9 @@
 import org.junit.*;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Predicate;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.subjects.*;
 
@@ -103,7 +102,7 @@ public void testTakeWhileDoesntLeakErrors() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 NbpObserver.onNext("one");
                 NbpObserver.onError(new Throwable("test failed"));
             }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
Patch:
@@ -22,8 +22,8 @@
 import org.mockito.InOrder;
 
 import io.reactivex.*;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.schedulers.TestScheduler;
 import io.reactivex.subjects.PublishSubject;
 
@@ -45,7 +45,7 @@ public void testThrottlingWithCompleted() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 publishNext(NbpObserver, 100, "one");    // publish as it's first
                 publishNext(NbpObserver, 300, "two");    // skip as it's last within the first 400
                 publishNext(NbpObserver, 900, "three");   // publish
@@ -73,7 +73,7 @@ public void testThrottlingWithError() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 Exception error = new TestException();
                 publishNext(NbpObserver, 100, "one");    // Should be published since it is first
                 publishNext(NbpObserver, 200, "two");    // Should be skipped since onError will arrive before the timeout expires

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutWithSelectorTest.java
Patch:
@@ -27,10 +27,9 @@
 import org.mockito.stubbing.Answer;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subjects.PublishSubject;
@@ -328,7 +327,7 @@ public Observable<Integer> apply(Integer t1) {
                     return Observable.unsafeCreate(new ObservableSource<Integer>() {
                         @Override
                         public void subscribe(Observer<? super Integer> NbpSubscriber) {
-                            NbpSubscriber.onSubscribe(EmptyDisposable.INSTANCE);
+                            NbpSubscriber.onSubscribe(Disposables.empty());
                             enteredTimeoutOne.countDown();
                             // force the timeout message be sent after NbpObserver.onNext(2)
                             while (true) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
Patch:
@@ -24,8 +24,8 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.TestScheduler;
 
@@ -49,7 +49,7 @@ public void testTimedAndCount() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 push(NbpObserver, "one", 10);
                 push(NbpObserver, "two", 90);
                 push(NbpObserver, "three", 110);
@@ -83,7 +83,7 @@ public void testTimed() {
         Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
-                NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+                NbpObserver.onSubscribe(Disposables.empty());
                 push(NbpObserver, "one", 98);
                 push(NbpObserver, "two", 99);
                 push(NbpObserver, "three", 99); // FIXME happens after the window is open

File: src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java
Patch:
@@ -29,7 +29,6 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
@@ -623,7 +622,7 @@ private static class TestObservable implements ObservableSource<String> {
         public void subscribe(Observer<? super String> NbpObserver) {
             // just store the variable where it can be accessed so we can manually trigger it
             this.NbpObserver = NbpObserver;
-            NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
+            NbpObserver.onSubscribe(Disposables.empty());
         }
 
     }

File: src/test/java/io/reactivex/subjects/ReplaySubjectBoundedConcurrencyTest.java
Patch:
@@ -24,8 +24,8 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
 
@@ -42,7 +42,7 @@ public void run() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
-                        o.onSubscribe(EmptyDisposable.INSTANCE);
+                        o.onSubscribe(Disposables.empty());
                         System.out.println("********* Start Source Data ***********");
                         for (long l = 1; l <= 10000; l++) {
                             o.onNext(l);
@@ -152,7 +152,7 @@ public void run() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
-                        o.onSubscribe(EmptyDisposable.INSTANCE);
+                        o.onSubscribe(Disposables.empty());
                         System.out.println("********* Start Source Data ***********");
                         for (long l = 1; l <= 10000; l++) {
                             o.onNext(l);

File: src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java
Patch:
@@ -24,8 +24,8 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
 
@@ -42,7 +42,7 @@ public void run() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
-                        o.onSubscribe(EmptyDisposable.INSTANCE);
+                        o.onSubscribe(Disposables.empty());
                         System.out.println("********* Start Source Data ***********");
                         for (long l = 1; l <= 10000; l++) {
                             o.onNext(l);
@@ -152,7 +152,7 @@ public void run() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
-                        o.onSubscribe(EmptyDisposable.INSTANCE);
+                        o.onSubscribe(Disposables.empty());
                         System.out.println("********* Start Source Data ***********");
                         for (long l = 1; l <= 10000; l++) {
                             o.onNext(l);

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2511,7 +2511,7 @@ public final void safeSubscribe(Subscriber<? super T> s) {
      * @see <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
      */
     public final Disposable subscribe() {
-        return subscribe(Functions.emptyConsumer(), RxJavaPlugins.errorConsumer());
+        return subscribe(Functions.emptyConsumer(), Functions.ERROR_CONSUMER);
     }
     
     /**
@@ -2553,7 +2553,7 @@ public final Disposable subscribe(final BiConsumer<? super T, ? super Throwable>
      * @see <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
      */
     public final Disposable subscribe(Consumer<? super T> onSuccess) {
-        return subscribe(onSuccess, RxJavaPlugins.errorConsumer());
+        return subscribe(onSuccess, Functions.ERROR_CONSUMER);
     }
     
     /**

File: src/main/java/io/reactivex/observers/DefaultObserver.java
Patch:
@@ -39,6 +39,7 @@ public final void onSubscribe(Disposable s) {
      */
     protected final void cancel() {
         s.dispose();
+        s = null;
     }
     /**
      * Called once the subscription has been set on this observer; override this

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -2061,7 +2061,7 @@ public final Single<T> doOnError(final Consumer<? super Throwable> onError) {
      * @return the new Single instance
      * @since 2.0
      */
-    public final Single<T> doOnCancel(final Runnable onCancel) {
+    public final Single<T> doOnCancel(final Action onCancel) {
         Objects.requireNonNull(onCancel, "onCancel is null");
         return new SingleDoOnCancel<T>(this, onCancel);
     }

File: src/main/java/io/reactivex/flowables/BlockingFlowable.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.Optional;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.operators.flowable.*;
 import io.reactivex.internal.subscribers.flowable.*;
@@ -276,7 +276,7 @@ public void accept(Throwable e) {
                 error[0] = e;
                 cdl.countDown();
             }
-        }, new Runnable() {
+        }, new Action() {
             @Override
             public void run() {
                 cdl.countDown();

File: src/main/java/io/reactivex/internal/subscribers/flowable/LambdaSubscriber.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -28,11 +28,11 @@ public final class LambdaSubscriber<T> extends AtomicReference<Subscription> imp
     private static final long serialVersionUID = -7251123623727029452L;
     final Consumer<? super T> onNext;
     final Consumer<? super Throwable> onError;
-    final Runnable onComplete;
+    final Action onComplete;
     final Consumer<? super Subscription> onSubscribe;
     
     public LambdaSubscriber(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
-            Runnable onComplete,
+            Action onComplete,
             Consumer<? super Subscription> onSubscribe) {
         super();
         this.onNext = onNext;

File: src/main/java/io/reactivex/internal/subscribers/flowable/SubscriptionLambdaSubscriber.java
Patch:
@@ -23,14 +23,14 @@ public final class SubscriptionLambdaSubscriber<T> implements Subscriber<T>, Sub
     final Subscriber<? super T> actual;
     final Consumer<? super Subscription> onSubscribe;
     final LongConsumer onRequest;
-    final Runnable onCancel;
+    final Action onCancel;
     
     Subscription s;
     
     public SubscriptionLambdaSubscriber(Subscriber<? super T> actual, 
             Consumer<? super Subscription> onSubscribe,
             LongConsumer onRequest,
-            Runnable onCancel) {
+            Action onCancel) {
         this.actual = actual;
         this.onSubscribe = onSubscribe;
         this.onCancel = onCancel;

File: src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -27,11 +27,11 @@ public final class LambdaObserver<T> extends AtomicReference<Disposable> impleme
     private static final long serialVersionUID = -7251123623727029452L;
     final Consumer<? super T> onNext;
     final Consumer<? super Throwable> onError;
-    final Runnable onComplete;
+    final Action onComplete;
     final Consumer<? super Disposable> onSubscribe;
     
     public LambdaObserver(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
-            Runnable onComplete,
+            Action onComplete,
             Consumer<? super Disposable> onSubscribe) {
         super();
         this.onNext = onNext;

File: src/main/java/io/reactivex/internal/subscribers/observable/SubscriptionLambdaObserver.java
Patch:
@@ -15,20 +15,20 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class SubscriptionLambdaObserver<T> implements Observer<T>, Disposable {
     final Observer<? super T> actual;
     final Consumer<? super Disposable> onSubscribe;
-    final Runnable onCancel;
+    final Action onCancel;
     
     Disposable s;
     
     public SubscriptionLambdaObserver(Observer<? super T> actual, 
             Consumer<? super Disposable> onSubscribe,
-            Runnable onCancel) {
+            Action onCancel) {
         this.actual = actual;
         this.onSubscribe = onSubscribe;
         this.onCancel = onCancel;

File: src/main/java/io/reactivex/observables/BlockingObservable.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.Optional;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.operators.observable.*;
 import io.reactivex.internal.subscribers.flowable.BlockingSubscriber;
@@ -75,7 +75,7 @@ public void accept(Throwable e) {
                     queue.offer(NotificationLite.error(e));
                 }
             },
-            new Runnable() {
+            new Action() {
                 @Override
                 public void run() {
                     queue.offer(NotificationLite.complete());
@@ -354,7 +354,7 @@ public void accept(Throwable e) {
                     error[0] = e;
                     cdl.countDown();
                 }
-            }, new Runnable() {
+            }, new Action() {
                 @Override
                 public void run() {
                     cdl.countDown();

File: src/test/java/io/reactivex/flowable/FlowableDoOnTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.junit.Test;
 
 import io.reactivex.Flowable;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 
 public class FlowableDoOnTest {
 
@@ -62,7 +62,7 @@ public void accept(Throwable v) {
     @Test
     public void testDoOnCompleted() {
         final AtomicBoolean r = new AtomicBoolean();
-        String output = Flowable.just("one").doOnComplete(new Runnable() {
+        String output = Flowable.just("one").doOnComplete(new Action() {
             @Override
             public void run() {
                 r.set(true);

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -1200,7 +1200,7 @@ public void doOnLifecycleOnSubscribeNull() {
         just1.doOnLifecycle(null, new LongConsumer() {
             @Override
             public void accept(long v) { }
-        }, new Runnable() {
+        }, new Action() {
             @Override
             public void run() { }
         });
@@ -1211,7 +1211,7 @@ public void doOnLifecycleOnRequestNull() {
         just1.doOnLifecycle(new Consumer<Subscription>() {
             @Override
             public void accept(Subscription s) { }
-        }, null, new Runnable() {
+        }, null, new Action() {
             @Override
             public void run() { }
         });
@@ -2132,7 +2132,7 @@ public void subscribeOnCompleteNull() {
     
     @Test(expected = NullPointerException.class)
     public void subscribeOnSubscribeNull() {
-        just1.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.EMPTY_RUNNABLE, null);
+        just1.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.EMPTY_ACTION, null);
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -131,8 +131,8 @@ public void accept(String v) {
     }
 
     @Test
-    public void testUnsubscribeSource() {
-        Runnable unsubscribe = mock(Runnable.class);
+    public void testUnsubscribeSource() throws Exception {
+        Action unsubscribe = mock(Action.class);
         Flowable<Integer> o = Flowable.just(1).doOnCancel(unsubscribe).cache();
         o.subscribe();
         o.subscribe();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.junit.*;
 
 import io.reactivex.Flowable;
-import io.reactivex.functions.LongConsumer;
+import io.reactivex.functions.*;
 import io.reactivex.subscribers.DefaultSubscriber;
 
 public class FlowableDoOnRequestTest {
@@ -31,7 +31,7 @@ public void testUnsubscribeHappensAgainstParent() {
         final AtomicBoolean unsubscribed = new AtomicBoolean(false);
         Flowable.just(1)
         //
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
Patch:
@@ -310,7 +310,7 @@ public void accept(Subscription s) {
                         Assert.fail("Too many subscriptions! " + (n + 1));
                     }
             }
-        }).doOnComplete(new Runnable() {
+        }).doOnComplete(new Action() {
             @Override
             public void run() {
                     int n = subscriptionCount.decrementAndGet();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.*;
+import io.reactivex.functions.Cancellable;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.*;
 
@@ -658,7 +659,7 @@ public void onNext(Integer v) {
             
             subject.subscribe(as);
             
-            t.setCancellation(new FlowableEmitter.Cancellable() {
+            t.setCancellation(new Cancellable() {
                 @Override
                 public void cancel() throws Exception {
                     as.dispose();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.subscribers.*;
 
 public class FlowableIgnoreElementsTest {
@@ -80,7 +80,7 @@ public void testErrorReceived() {
     @Test
     public void testUnsubscribesFromUpstream() {
         final AtomicBoolean unsub = new AtomicBoolean();
-        Flowable.range(1, 10).doOnCancel(new Runnable() {
+        Flowable.range(1, 10).doOnCancel(new Action() {
             @Override
             public void run() {
                 unsub.set(true);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
Patch:
@@ -1241,7 +1241,7 @@ public void accept(long n) {
                     // log count
                     .doOnNext(printCount())
                     // release latch
-                    .doOnComplete(new Runnable() {
+                    .doOnComplete(new Action() {
                         @Override
                         public void run() {
                                 latch.countDown();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
Patch:
@@ -117,7 +117,7 @@ public void accept(String t1) {
                 assertTrue(correctThreadName);
             }
 
-        }).doAfterTerminate(new Runnable() {
+        }).doAfterTerminate(new Action() {
 
             @Override
             public void run() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.MissingBackpressureException;
+import io.reactivex.functions.Action;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
@@ -122,7 +123,7 @@ public void onNext(Long t) {
 
         ts.request(100);
         infinite.subscribeOn(Schedulers.computation())
-             .onBackpressureBuffer(500, new Runnable() {
+             .onBackpressureBuffer(500, new Action() {
                  @Override
                  public void run() {
                      backpressureCallback.countDown();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
Patch:
@@ -169,7 +169,7 @@ public void accept(Subscription s) {
                             subscribeCount.incrementAndGet();
                     }
                 })
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                             System.out.println("******************************* Unsubscribe received");
@@ -214,7 +214,7 @@ public void accept(Subscription s) {
                             subscribeLatch.countDown();
                     }
                 })
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                             System.out.println("******************************* Unsubscribe received");
@@ -252,7 +252,7 @@ public void testConnectUnsubscribeRaceConditionLoop() throws InterruptedExceptio
     public void testConnectUnsubscribeRaceCondition() throws InterruptedException {
         final AtomicInteger subUnsubCount = new AtomicInteger();
         Flowable<Long> o = synchronousInterval()
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                             System.out.println("******************************* Unsubscribe received");

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastOneTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.junit.Test;
 
 import io.reactivex.Flowable;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.subscribers.*;
 
 public class FlowableTakeLastOneTest {
@@ -62,7 +62,7 @@ public void testLastOfOneReturnsLast() {
     @Test
     public void testUnsubscribesFromUpstream() {
         final AtomicBoolean unsubscribed = new AtomicBoolean(false);
-        Runnable unsubscribeAction = new Runnable() {
+        Action unsubscribeAction = new Action() {
             @Override
             public void run() {
                 unsubscribed.set(true);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToCompletableTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.Test;
 
 import io.reactivex.*;
+import io.reactivex.functions.Action;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableToCompletableTest {
@@ -83,7 +84,7 @@ public void testNeverObservable() {
     public void testShouldUseUnsafeSubscribeInternallyNotSubscribe() {
         TestSubscriber<String> subscriber = TestSubscriber.create();
         final AtomicBoolean unsubscribed = new AtomicBoolean(false);
-        Completable cmp = Flowable.just("Hello World!").doOnCancel(new Runnable() {
+        Completable cmp = Flowable.just("Hello World!").doOnCancel(new Action() {
 
             @Override
             public void run() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToSingleTest.java
Patch:
@@ -19,6 +19,7 @@
 import org.junit.*;
 
 import io.reactivex.*;
+import io.reactivex.functions.Action;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableToSingleTest {
@@ -73,7 +74,7 @@ public void testRepeatObservableThrowsError() {
     public void testShouldUseUnsafeSubscribeInternallyNotSubscribe() {
         TestSubscriber<String> subscriber = TestSubscriber.create();
         final AtomicBoolean unsubscribed = new AtomicBoolean(false);
-        Single<String> single = Flowable.just("Hello World!").doOnCancel(new Runnable() {
+        Single<String> single = Flowable.just("Hello World!").doOnCancel(new Action() {
 
             @Override
             public void run() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
Patch:
@@ -186,7 +186,7 @@ public void testTakeFlatMapCompletes() {
         FlowableWindowWithSizeTest.hotStream()
         .window(300, TimeUnit.MILLISECONDS)
         .take(10)
-        .doOnComplete(new Runnable() {
+        .doOnComplete(new Action() {
             @Override
             public void run() {
                 System.out.println("Main done!");
@@ -196,7 +196,7 @@ public void run() {
             @Override
             public Flowable<Integer> apply(Flowable<Integer> w) {
                 return w.startWith(indicator)
-                        .doOnComplete(new Runnable() {
+                        .doOnComplete(new Action() {
                             @Override
                             public void run() {
                                 System.out.println("inner done: " + wip.incrementAndGet());

File: src/test/java/io/reactivex/internal/operators/observable/ObservableCacheTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
@@ -106,8 +106,8 @@ public void accept(String v) {
     }
 
     @Test
-    public void testUnsubscribeSource() {
-        Runnable unsubscribe = mock(Runnable.class);
+    public void testUnsubscribeSource() throws Exception {
+        Action unsubscribe = mock(Action.class);
         Observable<Integer> o = Observable.just(1).doOnCancel(unsubscribe).cache();
         o.subscribe();
         o.subscribe();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java
Patch:
@@ -311,7 +311,7 @@ public void accept(Disposable s) {
                         Assert.fail("Too many subscriptions! " + (n + 1));
                     }
             }
-        }).doOnComplete(new Runnable() {
+        }).doOnComplete(new Action() {
             @Override
             public void run() {
                     int n = subscriptionCount.decrementAndGet();

File: src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.Observable;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.observers.TestObserver;
 
 public class ObservableIgnoreElementsTest {
@@ -80,7 +80,7 @@ public void testErrorReceived() {
     @Test
     public void testUnsubscribesFromUpstream() {
         final AtomicBoolean unsub = new AtomicBoolean();
-        Observable.range(1, 10).doOnCancel(new Runnable() {
+        Observable.range(1, 10).doOnCancel(new Action() {
             @Override
             public void run() {
                 unsub.set(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
Patch:
@@ -113,7 +113,7 @@ public void accept(String t1) {
                 assertTrue(correctThreadName);
             }
 
-        }).doAfterTerminate(new Runnable() {
+        }).doAfterTerminate(new Action() {
 
             @Override
             public void run() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -170,7 +170,7 @@ public void accept(Disposable s) {
                             subscribeCount.incrementAndGet();
                     }
                 })
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                             System.out.println("******************************* Unsubscribe received");
@@ -215,7 +215,7 @@ public void accept(Disposable s) {
                             subscribeLatch.countDown();
                     }
                 })
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                             System.out.println("******************************* Unsubscribe received");
@@ -253,7 +253,7 @@ public void testConnectUnsubscribeRaceConditionLoop() throws InterruptedExceptio
     public void testConnectUnsubscribeRaceCondition() throws InterruptedException {
         final AtomicInteger subUnsubCount = new AtomicInteger();
         Observable<Long> o = synchronousInterval()
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                             System.out.println("******************************* Unsubscribe received");

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeLastOneTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.observers.TestObserver;
 
 public class ObservableTakeLastOneTest {
@@ -61,7 +61,7 @@ public void testLastOfOneReturnsLast() {
     @Test
     public void testUnsubscribesFromUpstream() {
         final AtomicBoolean unsubscribed = new AtomicBoolean(false);
-        Runnable unsubscribeAction = new Runnable() {
+        Action unsubscribeAction = new Action() {
             @Override
             public void run() {
                 unsubscribed.set(true);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
Patch:
@@ -187,7 +187,7 @@ public void testTakeFlatMapCompletes() {
         ObservableWindowWithSizeTest.hotStream()
         .window(300, TimeUnit.MILLISECONDS)
         .take(10)
-        .doOnComplete(new Runnable() {
+        .doOnComplete(new Action() {
             @Override
             public void run() {
                 System.out.println("Main done!");
@@ -197,7 +197,7 @@ public void run() {
             @Override
             public Observable<Integer> apply(Observable<Integer> w) {
                 return w.startWith(indicator)
-                        .doOnComplete(new Runnable() {
+                        .doOnComplete(new Action() {
                             @Override
                             public void run() {
                                 System.out.println("inner done: " + wip.incrementAndGet());

File: src/test/java/io/reactivex/observable/ObservableDoOnTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 
 public class ObservableDoOnTest {
 
@@ -62,7 +62,7 @@ public void accept(Throwable v) {
     @Test
     public void testDoOnCompleted() {
         final AtomicBoolean r = new AtomicBoolean();
-        String output = Observable.just("one").doOnComplete(new Runnable() {
+        String output = Observable.just("one").doOnComplete(new Action() {
             @Override
             public void run() {
                 r.set(true);

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -1294,7 +1294,7 @@ public void doOnErrorNull() {
     
     @Test(expected = NullPointerException.class)
     public void doOnLifecycleOnSubscribeNull() {
-        just1.doOnLifecycle(null, Functions.EMPTY_RUNNABLE);
+        just1.doOnLifecycle(null, Functions.EMPTY_ACTION);
     }
     
     @Test(expected = NullPointerException.class)
@@ -2209,7 +2209,7 @@ public void accept(Integer e) { }
         }, new Consumer<Throwable>() {
             @Override
             public void accept(Throwable e) { }
-        }, Functions.EMPTY_RUNNABLE, null);
+        }, Functions.EMPTY_ACTION, null);
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/subscribers/TestSubscriberTest.java
Patch:
@@ -28,6 +28,7 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.exceptions.*;
+import io.reactivex.functions.Action;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
@@ -146,7 +147,7 @@ public void testAwaitTerminalEventWithDurationAndUnsubscribeOnTimeout() {
         final AtomicBoolean unsub = new AtomicBoolean(false);
         Flowable.just(1)
         //
-                .doOnCancel(new Runnable() {
+                .doOnCancel(new Action() {
                     @Override
                     public void run() {
                         unsub.set(true);

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -7281,7 +7281,7 @@ public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {
     }
 
     /**
-     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecylcle events of
+     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of
      * the sequence (subscription, cancellation, requesting).
      * <p>
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.png" alt="">

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -628,7 +628,7 @@ public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T
         Objects.requireNonNull(v5, "The fifth value is null");
         Objects.requireNonNull(v6, "The sixth value is null");
         Objects.requireNonNull(v7, "The seventh value is null");
-        Objects.requireNonNull(v8, "The eigth value is null");
+        Objects.requireNonNull(v8, "The eighth value is null");
         
         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
     }
@@ -643,7 +643,7 @@ public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T
         Objects.requireNonNull(v5, "The fifth value is null");
         Objects.requireNonNull(v6, "The sixth value is null");
         Objects.requireNonNull(v7, "The seventh value is null");
-        Objects.requireNonNull(v8, "The eigth value is null");
+        Objects.requireNonNull(v8, "The eighth value is null");
         Objects.requireNonNull(v9, "The ninth is null");
         
         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);

File: src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java
Patch:
@@ -386,7 +386,7 @@ public void testUserSubscriberUsingRequestSync() {
         final AtomicInteger totalReceived = new AtomicInteger();
         final AtomicInteger batches = new AtomicInteger();
         final AtomicInteger received = new AtomicInteger();
-        incrementingIntegers(c).subscribe(new AsyncSubscriber<Integer>() {
+        incrementingIntegers(c).subscribe(new ResourceSubscriber<Integer>() {
 
             @Override
             public void onStart() {
@@ -433,7 +433,7 @@ public void testUserSubscriberUsingRequestAsync() throws InterruptedException {
         final AtomicInteger batches = new AtomicInteger();
         final CountDownLatch latch = new CountDownLatch(1);
         incrementingIntegers(c).subscribeOn(Schedulers.newThread()).subscribe(
-                new AsyncSubscriber<Integer>() {
+                new ResourceSubscriber<Integer>() {
 
             @Override
             public void onStart() {

File: src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
Patch:
@@ -204,7 +204,7 @@ public void cancel() {
 
                 });
 
-                AsyncSubscriber<String> as = new AsyncSubscriber<String>() {
+                ResourceSubscriber<String> as = new ResourceSubscriber<String>() {
                     
                     @Override
                     protected void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
Patch:
@@ -989,7 +989,7 @@ public void testBufferWithTimeDoesntUnsubscribeDownstream() throws InterruptedEx
         final Subscriber<Object> o = TestHelper.mockSubscriber();
         
         final CountDownLatch cdl = new CountDownLatch(1);
-        AsyncSubscriber<Object> s = new AsyncSubscriber<Object>() {
+        ResourceSubscriber<Object> s = new ResourceSubscriber<Object>() {
             @Override
             public void onNext(Object t) {
                 o.onNext(t);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
Patch:
@@ -637,7 +637,7 @@ public void subscribe(final FlowableEmitter<Integer> t) {
 
             this.current = t;
             
-            final AsyncSubscriber<Integer> as = new AsyncSubscriber<Integer>() {
+            final ResourceSubscriber<Integer> as = new ResourceSubscriber<Integer>() {
 
                 @Override
                 public void onComplete() {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
Patch:
@@ -763,7 +763,7 @@ public void testBufferWithTimeDoesntUnsubscribeDownstream() throws InterruptedEx
         final Observer<Object> o = TestHelper.mockObserver();
         
         final CountDownLatch cdl = new CountDownLatch(1);
-        AsyncObserver<Object> s = new AsyncObserver<Object>() {
+        ResourceObserver<Object> s = new ResourceObserver<Object>() {
             @Override
             public void onNext(Object t) {
                 o.onNext(t);

File: src/test/java/io/reactivex/schedulers/AbstractSchedulerConcurrencyTests.java
Patch:
@@ -317,7 +317,7 @@ public void request(long n) {
     
             final AtomicInteger count = new AtomicInteger();
             final AtomicBoolean completed = new AtomicBoolean(false);
-            AsyncSubscriber<Integer> s = new AsyncSubscriber<Integer>() {
+            ResourceSubscriber<Integer> s = new ResourceSubscriber<Integer>() {
                 @Override
                 public void onComplete() {
                     System.out.println("Completed");

File: src/test/java/io/reactivex/subscribers/SerializedObserverTest.java
Patch:
@@ -375,13 +375,13 @@ public void onNext(String t) {
         AtomicInteger p2 = new AtomicInteger();
 
         o.onSubscribe(EmptySubscription.INSTANCE);
-        AsyncSubscriber<String> as1 = Subscribers.createAsync(new Consumer<String>() {
+        ResourceSubscriber<String> as1 = Subscribers.createResource(new Consumer<String>() {
             @Override
             public void accept(String v) {
                 o.onNext(v);
             }
         });
-        AsyncSubscriber<String> as2 = Subscribers.createAsync(new Consumer<String>() {
+        ResourceSubscriber<String> as2 = Subscribers.createResource(new Consumer<String>() {
             @Override
             public void accept(String v) {
                 o.onNext(v);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromSource.java
Patch:
@@ -38,6 +38,8 @@ static final class DisposeAwareCompletableObserver
     extends AtomicBoolean
     implements CompletableObserver, Disposable {
 
+        /** */
+        private static final long serialVersionUID = -1520879094105684863L;
         private final CompletableObserver o;
         private Disposable d;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromSource.java
Patch:
@@ -38,6 +38,8 @@ static final class DisposedAwareObserver<T>
     extends AtomicBoolean
     implements Observer<T>, Disposable {
 
+        /** */
+        private static final long serialVersionUID = -7920748056724379224L;
         private final Observer<? super T> o;
         private Disposable d;
 

File: src/main/java/io/reactivex/internal/operators/single/SingleFromSource.java
Patch:
@@ -36,6 +36,8 @@ public SingleFromSource(SingleSource<T> source) {
     static final class DisposeAwareSingleObserver<T>
     extends AtomicBoolean
     implements SingleObserver<T>, Disposable {
+        /** */
+        private static final long serialVersionUID = -166991076349162358L;
         private final SingleObserver<? super T> o;
         private Disposable d;
 

File: src/test/java/io/reactivex/subscribers/SafeSubscriberWithPluginTest.java
Patch:
@@ -13,7 +13,7 @@
 
 package io.reactivex.subscribers;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -55,7 +55,7 @@ public void onComplete() {
         SafeSubscriber<Integer> safe = new SafeSubscriber<Integer>(ts);
         try {
             safe.onComplete();
-            Assert.fail();
+            fail();
         } catch (RuntimeException e) {
             // FIXME no longer assertable
             // assertTrue(safe.isUnsubscribed());

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableAll<T> extends FlowableWithUpstream<T, Boolean> {
+public final class FlowableAll<T> extends AbstractFlowableWithUpstream<T, Boolean> {
     
     final Predicate<? super T> predicate;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableAny<T> extends FlowableWithUpstream<T, Boolean> {
+public final class FlowableAny<T> extends AbstractFlowableWithUpstream<T, Boolean> {
     final Predicate<? super T> predicate;
     public FlowableAny(Publisher<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableWithUpstream<T, C> {
+public final class FlowableBuffer<T, C extends Collection<? super T>> extends AbstractFlowableWithUpstream<T, C> {
     final int size;
 
     final int skip;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
Patch:
@@ -30,7 +30,7 @@
 import io.reactivex.subscribers.*;
 
 public final class FlowableBufferBoundary<T, U extends Collection<? super T>, Open, Close> 
-extends FlowableWithUpstream<T, U> {
+extends AbstractFlowableWithUpstream<T, U> {
     final Callable<U> bufferSupplier;
     final Publisher<? extends Open> bufferOpen;
     final Function<? super Open, ? extends Publisher<? extends Close>> bufferClose;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.subscribers.*;
 
 public final class FlowableBufferBoundarySupplier<T, U extends Collection<? super T>, B> 
-extends FlowableWithUpstream<T, U> {
+extends AbstractFlowableWithUpstream<T, U> {
     final Callable<? extends Publisher<B>> boundarySupplier;
     final Callable<U> bufferSupplier;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.subscribers.*;
 
 public final class FlowableBufferExactBoundary<T, U extends Collection<? super T>, B> 
-extends FlowableWithUpstream<T, U> {
+extends AbstractFlowableWithUpstream<T, U> {
     final Publisher<B> boundary;
     final Callable<U> bufferSupplier;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.internal.util.QueueDrainHelper;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableBufferTimed<T, U extends Collection<? super T>> extends FlowableWithUpstream<T, U> {
+public final class FlowableBufferTimed<T, U extends Collection<? super T>> extends AbstractFlowableWithUpstream<T, U> {
 
     final long timespan;
     final long timeskip;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
Patch:
@@ -28,7 +28,7 @@
  *
  * @param <T> the source element type
  */
-public final class FlowableCache<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableCache<T> extends AbstractFlowableWithUpstream<T, T> {
     /** The cache and replay state. */
     final CacheState<T> state;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.functions.BiConsumer;
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableCollect<T, U> extends FlowableWithUpstream<T, U> {
+public final class FlowableCollect<T, U> extends AbstractFlowableWithUpstream<T, U> {
     
     final Callable<? extends U> initialSupplier;
     final BiConsumer<? super U, ? super T> collector;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableConcatMap<T, R> extends FlowableWithUpstream<T, R> {
+public final class FlowableConcatMap<T, R> extends AbstractFlowableWithUpstream<T, R> {
 
     final Function<? super T, ? extends Publisher<? extends R>> mapper;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
Patch:
@@ -28,7 +28,7 @@
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public class FlowableConcatMapEager<T, R> extends FlowableWithUpstream<T, R> {
+public class FlowableConcatMapEager<T, R> extends AbstractFlowableWithUpstream<T, R> {
 
     final Function<? super T, ? extends Publisher<? extends R>> mapper;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableCount<T> extends FlowableWithUpstream<T, Long> {
+public final class FlowableCount<T> extends AbstractFlowableWithUpstream<T, Long> {
 
     public FlowableCount(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.*;
 
-public final class FlowableDebounce<T, U> extends FlowableWithUpstream<T, T> {
+public final class FlowableDebounce<T, U> extends AbstractFlowableWithUpstream<T, T> {
     final Function<? super T, ? extends Publisher<U>> debounceSelector;
 
     public FlowableDebounce(Publisher<T> source, Function<? super T, ? extends Publisher<U>> debounceSelector) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableDebounceTimed<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableDebounceTimed<T> extends AbstractFlowableWithUpstream<T, T> {
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableDelay<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableDelay<T> extends AbstractFlowableWithUpstream<T, T> {
     final long delay;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableDematerialize<T> extends FlowableWithUpstream<Try<Optional<T>>, T> {
+public final class FlowableDematerialize<T> extends AbstractFlowableWithUpstream<Try<Optional<T>>, T> {
 
     public FlowableDematerialize(Publisher<Try<Optional<T>>> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDetach.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.internal.subscribers.flowable.EmptyComponent;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableDetach<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableDetach<T> extends AbstractFlowableWithUpstream<T, T> {
 
     public FlowableDetach(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.functions.*;
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableDistinct<T, K> extends FlowableWithUpstream<T, T> {
+public final class FlowableDistinct<T, K> extends AbstractFlowableWithUpstream<T, T> {
     final Function<? super T, K> keySelector;
     final Callable<? extends Predicate<? super K>> predicateSupplier;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.internal.fuseable.ConditionalSubscriber;
 import io.reactivex.internal.subscribers.flowable.*;
 
-public final class FlowableDistinctUntilChanged<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableDistinctUntilChanged<T> extends AbstractFlowableWithUpstream<T, T> {
 
     final BiPredicate<? super T, ? super T> comparer;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscribers.flowable.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableDoOnEach<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableDoOnEach<T> extends AbstractFlowableWithUpstream<T, T> {
     final Consumer<? super T> onNext;
     final Consumer<? super Throwable> onError;
     final Runnable onComplete;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycle.java
Patch:
@@ -19,7 +19,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
-public final class FlowableDoOnLifecycle<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableDoOnLifecycle<T> extends AbstractFlowableWithUpstream<T, T> {
     private final Consumer<? super Subscription> onSubscribe;
     private final LongConsumer onRequest;
     private final Runnable onCancel;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableElementAt<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableElementAt<T> extends AbstractFlowableWithUpstream<T, T> {
     final long index;
     final T defaultValue;
     public FlowableElementAt(Publisher<T> source, long index, T defaultValue) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.subscribers.flowable.*;
 
-public final class FlowableFilter<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableFilter<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public FlowableFilter(Publisher<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableFlatMap<T, U> extends FlowableWithUpstream<T, U> {
+public final class FlowableFlatMap<T, U> extends AbstractFlowableWithUpstream<T, U> {
     final Function<? super T, ? extends Publisher<? extends U>> mapper;
     final boolean delayErrors;
     final int maxConcurrency;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
Patch:
@@ -28,7 +28,7 @@
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableFlattenIterable<T, R> extends FlowableWithUpstream<T, R> {
+public final class FlowableFlattenIterable<T, R> extends AbstractFlowableWithUpstream<T, R> {
 
     final Function<? super T, ? extends Iterable<? extends R>> mapper;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -28,7 +28,7 @@
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableGroupBy<T, K, V> extends FlowableWithUpstream<T, GroupedFlowable<K, V>> {
+public final class FlowableGroupBy<T, K, V> extends AbstractFlowableWithUpstream<T, GroupedFlowable<K, V>> {
     final Function<? super T, ? extends K> keySelector;
     final Function<? super T, ? extends V> valueSelector;
     final int bufferSize;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java
Patch:
@@ -33,7 +33,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.UnicastProcessor;
 
-public class FlowableGroupJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends FlowableWithUpstream<TLeft, R> {
+public class FlowableGroupJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends AbstractFlowableWithUpstream<TLeft, R> {
 
     final Publisher<? extends TRight> other;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableHide.java
Patch:
@@ -23,7 +23,7 @@
  * 
  * @since 2.0
  */
-public class FlowableHide<T> extends FlowableWithUpstream<T, T> {
+public class FlowableHide<T> extends AbstractFlowableWithUpstream<T, T> {
     
     public FlowableHide(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElements.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableIgnoreElements<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableIgnoreElements<T> extends AbstractFlowableWithUpstream<T, T> {
 
     public FlowableIgnoreElements(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableJoin.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public class FlowableJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends FlowableWithUpstream<TLeft, R> {
+public class FlowableJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends AbstractFlowableWithUpstream<TLeft, R> {
 
     final Publisher<? extends TRight> other;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableLift.java
Patch:
@@ -27,7 +27,7 @@
  * @param <T> the upstream value type
  * @param <R> the downstream parameter type
  */
-public final class FlowableLift<R, T> extends FlowableWithUpstream<T, R> {
+public final class FlowableLift<R, T> extends AbstractFlowableWithUpstream<T, R> {
     /** The actual operator. */
     final FlowableOperator<? extends R, ? super T> operator;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.fuseable.ConditionalSubscriber;
 import io.reactivex.internal.subscribers.flowable.*;
 
-public final class FlowableMap<T, U> extends FlowableWithUpstream<T, U> {
+public final class FlowableMap<T, U> extends AbstractFlowableWithUpstream<T, U> {
     final Function<? super T, ? extends U> mapper;
     public FlowableMap(Publisher<T> source, Function<? super T, ? extends U> mapper) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableMapNotification<T, R> extends FlowableWithUpstream<T, R> {
+public final class FlowableMapNotification<T, R> extends AbstractFlowableWithUpstream<T, R> {
 
     final Function<? super T, ? extends R> onNextMapper;
     final Function<? super Throwable, ? extends R> onErrorMapper;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMaterialize.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableMaterialize<T> extends FlowableWithUpstream<T, Try<Optional<T>>> {
+public final class FlowableMaterialize<T> extends AbstractFlowableWithUpstream<T, Try<Optional<T>>> {
 
     public FlowableMaterialize(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableObserveOn<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableObserveOn<T> extends AbstractFlowableWithUpstream<T, T> {
 final Scheduler scheduler;
     
     final boolean delayError;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableOnBackpressureBuffer<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableOnBackpressureBuffer<T> extends AbstractFlowableWithUpstream<T, T> {
     final int bufferSize;
     final boolean unbounded;
     final boolean delayError;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDrop.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableOnBackpressureDrop<T> extends FlowableWithUpstream<T, T> implements Consumer<T> {
+public final class FlowableOnBackpressureDrop<T> extends AbstractFlowableWithUpstream<T, T> implements Consumer<T> {
 
     final Consumer<? super T> onDrop;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatest.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableOnBackpressureLatest<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableOnBackpressureLatest<T> extends AbstractFlowableWithUpstream<T, T> {
 
     public FlowableOnBackpressureLatest(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorNext.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableOnErrorNext<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableOnErrorNext<T> extends AbstractFlowableWithUpstream<T, T> {
     final Function<? super Throwable, ? extends Publisher<? extends T>> nextSupplier;
     final boolean allowFatal;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableOnErrorReturn<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableOnErrorReturn<T> extends AbstractFlowableWithUpstream<T, T> {
     final Function<? super Throwable, ? extends T> valueSupplier;
     public FlowableOnErrorReturn(Publisher<T> source, Function<? super Throwable, ? extends T> valueSupplier) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.processors.*;
 
 // FIXME split and update to the Rsc version
-public final class FlowableRedo<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableRedo<T> extends AbstractFlowableWithUpstream<T, T> {
     final Function<? super Flowable<Try<Optional<Object>>>, ? extends Publisher<?>> manager;
 
     public FlowableRedo(Publisher<T> source,

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -30,7 +30,7 @@
  * @param <T>
  *            the value type
  */
-public final class FlowableRefCount<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableRefCount<T> extends AbstractFlowableWithUpstream<T, T> {
     final ConnectableFlowable<? extends T> source;
     volatile CompositeDisposable baseSubscription = new CompositeDisposable();
     final AtomicInteger subscriptionCount = new AtomicInteger(0);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
-public final class FlowableRepeat<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableRepeat<T> extends AbstractFlowableWithUpstream<T, T> {
     final long count;
     public FlowableRepeat(Publisher<T> source, long count) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.functions.BooleanSupplier;
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
-public final class FlowableRepeatUntil<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableRepeatUntil<T> extends AbstractFlowableWithUpstream<T, T> {
     final BooleanSupplier until;
     public FlowableRepeatUntil(Publisher<T> source, BooleanSupplier until) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryBiPredicate.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.functions.BiPredicate;
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
-public final class FlowableRetryBiPredicate<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableRetryBiPredicate<T> extends AbstractFlowableWithUpstream<T, T> {
     final BiPredicate<? super Integer, ? super Throwable> predicate;
     public FlowableRetryBiPredicate(
             Publisher<T> source,

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRetryPredicate.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
-public final class FlowableRetryPredicate<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableRetryPredicate<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super Throwable> predicate;
     final long count;
     public FlowableRetryPredicate(Publisher<T> source,

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSampleTimed.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableSampleTimed<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSampleTimed<T> extends AbstractFlowableWithUpstream<T, T> {
     final long period;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableScan<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableScan<T> extends AbstractFlowableWithUpstream<T, T> {
     final BiFunction<T, T, T> accumulator;
     public FlowableScan(Publisher<T> source, BiFunction<T, T, T> accumulator) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableScanSeed<T, R> extends FlowableWithUpstream<T, R> {
+public final class FlowableScanSeed<T, R> extends AbstractFlowableWithUpstream<T, R> {
     final BiFunction<R, ? super T, R> accumulator;
     final Callable<R> seedSupplier;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSerialized.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.subscribers.SerializedSubscriber;
 import org.reactivestreams.Subscriber;
 
-public final class FlowableSerialized<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSerialized<T> extends AbstractFlowableWithUpstream<T, T> {
     public FlowableSerialized(Flowable<T> source) {
         super(source);
     }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableSingle<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSingle<T> extends AbstractFlowableWithUpstream<T, T> {
     
     final T defaultValue;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkip.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableSkip<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSkip<T> extends AbstractFlowableWithUpstream<T, T> {
     final long n;
     public FlowableSkip(Publisher<T> source, long n) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLast.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableSkipLast<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSkipLast<T> extends AbstractFlowableWithUpstream<T, T> {
     final int skip;
     
     public FlowableSkipLast(Publisher<T> source, int skip) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableSkipLastTimed<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSkipLastTimed<T> extends AbstractFlowableWithUpstream<T, T> {
     final long time;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipUntil.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableSkipUntil<T, U> extends FlowableWithUpstream<T, T> {
+public final class FlowableSkipUntil<T, U> extends AbstractFlowableWithUpstream<T, T> {
     final Publisher<U> other;
     public FlowableSkipUntil(Publisher<T> source, Publisher<U> other) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipWhile.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableSkipWhile<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSkipWhile<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public FlowableSkipWhile(Publisher<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableSubscribeOn<T> extends FlowableWithUpstream<T , T> {
+public final class FlowableSubscribeOn<T> extends AbstractFlowableWithUpstream<T , T> {
     final Scheduler scheduler;
     
     public FlowableSubscribeOn(Publisher<T> source, Scheduler scheduler) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmpty.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
-public final class FlowableSwitchIfEmpty<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableSwitchIfEmpty<T> extends AbstractFlowableWithUpstream<T, T> {
     final Publisher<? extends T> other;
     public FlowableSwitchIfEmpty(Publisher<T> source, Publisher<? extends T> other) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class FlowableSwitchMap<T, R> extends FlowableWithUpstream<T, R> {
+public final class FlowableSwitchMap<T, R> extends AbstractFlowableWithUpstream<T, R> {
     final Function<? super T, ? extends Publisher<? extends R>> mapper;
     final int bufferSize;
 

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableTake<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTake<T> extends AbstractFlowableWithUpstream<T, T> {
     final long limit;
     public FlowableTake(Publisher<T> source, long limit) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLast.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableTakeLast<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTakeLast<T> extends AbstractFlowableWithUpstream<T, T> {
     final int count;
     
     public FlowableTakeLast(Publisher<T> source, int count) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastOne.java
Patch:
@@ -16,7 +16,7 @@
 
 import io.reactivex.internal.subscriptions.*;
 
-public final class FlowableTakeLastOne<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTakeLastOne<T> extends AbstractFlowableWithUpstream<T, T> {
 
     public FlowableTakeLastOne(Publisher<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimed.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableTakeLastTimed<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTakeLastTimed<T> extends AbstractFlowableWithUpstream<T, T> {
     final long count;
     final long time;
     final TimeUnit unit;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntil.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableTakeUntil<T, U> extends FlowableWithUpstream<T, T> {
+public final class FlowableTakeUntil<T, U> extends AbstractFlowableWithUpstream<T, T> {
     final Publisher<? extends U> other;
     public FlowableTakeUntil(Publisher<T> source, Publisher<? extends U> other) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableTakeUntilPredicate<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTakeUntilPredicate<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public FlowableTakeUntilPredicate(Publisher<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeWhile.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableTakeWhile<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTakeWhile<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public FlowableTakeWhile(Publisher<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableThrottleFirstTimed<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableThrottleFirstTimed<T> extends AbstractFlowableWithUpstream<T, T> {
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeInterval.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.schedulers.Timed;
 
-public final class FlowableTimeInterval<T> extends FlowableWithUpstream<T, Timed<T>> {
+public final class FlowableTimeInterval<T> extends AbstractFlowableWithUpstream<T, Timed<T>> {
     final Scheduler scheduler;
     final TimeUnit unit;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.*;
 
-public final class FlowableTimeout<T, U, V> extends FlowableWithUpstream<T, T> {
+public final class FlowableTimeout<T, U, V> extends AbstractFlowableWithUpstream<T, T> {
     final Callable<? extends Publisher<U>> firstTimeoutSelector;
     final Function<? super T, ? extends Publisher<V>> timeoutSelector; 
     final Publisher<? extends T> other;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableTimeoutTimed<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableTimeoutTimed<T> extends AbstractFlowableWithUpstream<T, T> {
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.ArrayListSupplier;
 
-public final class FlowableToList<T, U extends Collection<? super T>> extends FlowableWithUpstream<T, U> {
+public final class FlowableToList<T, U extends Collection<? super T>> extends AbstractFlowableWithUpstream<T, U> {
     final Callable<U> collectionSupplier;
 
     @SuppressWarnings("unchecked")

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOn.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class FlowableUnsubscribeOn<T> extends FlowableWithUpstream<T, T> {
+public final class FlowableUnsubscribeOn<T> extends AbstractFlowableWithUpstream<T, T> {
     final Scheduler scheduler;
     public FlowableUnsubscribeOn(Publisher<T> source, Scheduler scheduler) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindow.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.UnicastProcessor;
 
-public final class FlowableWindow<T> extends FlowableWithUpstream<T, Flowable<T>> {
+public final class FlowableWindow<T> extends AbstractFlowableWithUpstream<T, Flowable<T>> {
     final long size;
     
     final long skip;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
Patch:
@@ -30,7 +30,7 @@
 import io.reactivex.processors.UnicastProcessor;
 import io.reactivex.subscribers.*;
 
-public final class FlowableWindowBoundary<T, B> extends FlowableWithUpstream<T, Flowable<T>> {
+public final class FlowableWindowBoundary<T, B> extends AbstractFlowableWithUpstream<T, Flowable<T>> {
     final Publisher<B> other;
     final int bufferSize;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.processors.UnicastProcessor;
 import io.reactivex.subscribers.*;
 
-public final class FlowableWindowBoundarySelector<T, B, V> extends FlowableWithUpstream<T, Flowable<T>> {
+public final class FlowableWindowBoundarySelector<T, B, V> extends AbstractFlowableWithUpstream<T, Flowable<T>> {
     final Publisher<B> open;
     final Function<? super B, ? extends Publisher<V>> close;
     final int bufferSize;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
Patch:
@@ -31,7 +31,7 @@
 import io.reactivex.processors.UnicastProcessor;
 import io.reactivex.subscribers.*;
 
-public final class FlowableWindowBoundarySupplier<T, B> extends FlowableWithUpstream<T, Flowable<T>> {
+public final class FlowableWindowBoundarySupplier<T, B> extends AbstractFlowableWithUpstream<T, Flowable<T>> {
     final Callable<? extends Publisher<B>> other;
     final int bufferSize;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.processors.UnicastProcessor;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableWindowTimed<T> extends FlowableWithUpstream<T, Flowable<T>> {
+public final class FlowableWindowTimed<T> extends AbstractFlowableWithUpstream<T, Flowable<T>> {
     final long timespan;
     final long timeskip;
     final TimeUnit unit;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.SerializedSubscriber;
 
-public final class FlowableWithLatestFrom<T, U, R> extends FlowableWithUpstream<T, R> {
+public final class FlowableWithLatestFrom<T, U, R> extends AbstractFlowableWithUpstream<T, R> {
     final BiFunction<? super T, ? super U, ? extends R> combiner;
     final Publisher<? extends U> other;
     public FlowableWithLatestFrom(Publisher<T> source, BiFunction<? super T, ? super U, ? extends R> combiner, Publisher<? extends U> other) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableAll<T> extends ObservableWithUpstream<T, Boolean> {
+public final class ObservableAll<T> extends AbstractObservableWithUpstream<T, Boolean> {
     final Predicate<? super T> predicate;
     public ObservableAll(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAny.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableAny<T> extends ObservableWithUpstream<T, Boolean> {
+public final class ObservableAny<T> extends AbstractObservableWithUpstream<T, Boolean> {
     final Predicate<? super T> predicate;
     public ObservableAny(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
 
-public final class ObservableBuffer<T, U extends Collection<? super T>> extends ObservableWithUpstream<T, U> {
+public final class ObservableBuffer<T, U extends Collection<? super T>> extends AbstractObservableWithUpstream<T, U> {
     final int count;
     final int skip;
     final Callable<U> bufferSupplier;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java
Patch:
@@ -30,7 +30,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableBufferBoundary<T, U extends Collection<? super T>, Open, Close> 
-extends ObservableWithUpstream<T, U> {
+extends AbstractObservableWithUpstream<T, U> {
     final Callable<U> bufferSupplier;
     final ObservableSource<? extends Open> bufferOpen;
     final Function<? super Open, ? extends ObservableSource<? extends Close>> bufferClose;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableBufferBoundarySupplier<T, U extends Collection<? super T>, B> 
-extends ObservableWithUpstream<T, U> {
+extends AbstractObservableWithUpstream<T, U> {
     final Callable<? extends ObservableSource<B>> boundarySupplier;
     final Callable<U> bufferSupplier;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableBufferExactBoundary<T, U extends Collection<? super T>, B> 
-extends ObservableWithUpstream<T, U> {
+extends AbstractObservableWithUpstream<T, U> {
     final ObservableSource<B> boundary;
     final Callable<U> bufferSupplier;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
Patch:
@@ -28,7 +28,7 @@
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableBufferTimed<T, U extends Collection<? super T>> 
-extends ObservableWithUpstream<T, U> {
+extends AbstractObservableWithUpstream<T, U> {
 
     final long timespan;
     final long timeskip;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCache.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @param <T> the source element type
  */
-public final class ObservableCache<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableCache<T> extends AbstractObservableWithUpstream<T, T> {
     /** The cache and replay state. */
     final CacheState<T> state;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.functions.BiConsumer;
 import io.reactivex.internal.disposables.*;
 
-public final class ObservableCollect<T, U> extends ObservableWithUpstream<T, U> {
+public final class ObservableCollect<T, U> extends AbstractObservableWithUpstream<T, U> {
     final Callable<? extends U> initialSupplier;
     final BiConsumer<? super U, ? super T> collector;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableConcatMap<T, U> extends ObservableWithUpstream<T, U> {
+public final class ObservableConcatMap<T, U> extends AbstractObservableWithUpstream<T, U> {
     final Function<? super T, ? extends ObservableSource<? extends U>> mapper;
     final int bufferSize;
     public ObservableConcatMap(ObservableSource<T> source, Function<? super T, ? extends ObservableSource<? extends U>> mapper, int bufferSize) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCount.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableCount<T> extends ObservableWithUpstream<T, Long> {
+public final class ObservableCount<T> extends AbstractObservableWithUpstream<T, Long> {
     public ObservableCount(ObservableSource<T> source) {
         super(source);
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableDebounce<T, U> extends ObservableWithUpstream<T, T> {
+public final class ObservableDebounce<T, U> extends AbstractObservableWithUpstream<T, T> {
     final Function<? super T, ? extends ObservableSource<U>> debounceSelector;
 
     public ObservableDebounce(ObservableSource<T> source, Function<? super T, ? extends ObservableSource<U>> debounceSelector) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableDebounceTimed<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableDebounceTimed<T> extends AbstractObservableWithUpstream<T, T> {
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.observers.SerializedObserver;
 
-public final class ObservableDelay<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableDelay<T> extends AbstractObservableWithUpstream<T, T> {
     final long delay;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDematerialize.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableDematerialize<T> extends ObservableWithUpstream<Try<Optional<T>>, T> {
+public final class ObservableDematerialize<T> extends AbstractObservableWithUpstream<Try<Optional<T>>, T> {
     
     public ObservableDematerialize(ObservableSource<Try<Optional<T>>> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.*;
 
-public final class ObservableDistinct<T, K> extends ObservableWithUpstream<T, T> {
+public final class ObservableDistinct<T, K> extends AbstractObservableWithUpstream<T, T> {
     final Function<? super T, K> keySelector;
     final Callable<? extends Predicate<? super K>> predicateSupplier;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoOnEach.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableDoOnEach<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableDoOnEach<T> extends AbstractObservableWithUpstream<T, T> {
     final Consumer<? super T> onNext;
     final Consumer<? super Throwable> onError;
     final Runnable onComplete;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDoOnLifecycle.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.subscribers.observable.SubscriptionLambdaObserver;
 
-public final class ObservableDoOnLifecycle<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableDoOnLifecycle<T> extends AbstractObservableWithUpstream<T, T> {
     private final Consumer<? super Disposable> onSubscribe;
     private final Runnable onCancel;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAt.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableElementAt<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableElementAt<T> extends AbstractObservableWithUpstream<T, T> {
     final long index;
     final T defaultValue;
     public ObservableElementAt(ObservableSource<T> source, long index, T defaultValue) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableFilter<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableFilter<T> extends AbstractObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public ObservableFilter(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.*;
 
-public final class ObservableFlatMap<T, U> extends ObservableWithUpstream<T, U> {
+public final class ObservableFlatMap<T, U> extends AbstractObservableWithUpstream<T, U> {
     final Function<? super T, ? extends ObservableSource<? extends U>> mapper;
     final boolean delayErrors;
     final int maxConcurrency;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.observables.GroupedObservable;
 
-public final class ObservableGroupBy<T, K, V> extends ObservableWithUpstream<T, GroupedObservable<K, V>> {
+public final class ObservableGroupBy<T, K, V> extends AbstractObservableWithUpstream<T, GroupedObservable<K, V>> {
     final Function<? super T, ? extends K> keySelector;
     final Function<? super T, ? extends V> valueSelector;
     final int bufferSize;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupJoin.java
Patch:
@@ -34,7 +34,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.UnicastSubject;
 
-public class ObservableGroupJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends ObservableWithUpstream<TLeft, R> {
+public class ObservableGroupJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends AbstractObservableWithUpstream<TLeft, R> {
 
     final ObservableSource<? extends TRight> other;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableIgnoreElements.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 
-public final class ObservableIgnoreElements<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableIgnoreElements<T> extends AbstractObservableWithUpstream<T, T> {
 
     public ObservableIgnoreElements(ObservableSource<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableJoin.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public class ObservableJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends ObservableWithUpstream<TLeft, R> {
+public class ObservableJoin<TLeft, TRight, TLeftEnd, TRightEnd, R> extends AbstractObservableWithUpstream<TLeft, R> {
 
     final ObservableSource<? extends TRight> other;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableLift.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> the upstream value type
  * @param <R> the downstream parameter type
  */
-public final class ObservableLift<R, T> extends ObservableWithUpstream<T, R> {
+public final class ObservableLift<R, T> extends AbstractObservableWithUpstream<T, R> {
     /** The actual operator. */
     final ObservableOperator<? extends R, ? super T> operator;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableMap<T, U> extends ObservableWithUpstream<T, U> {
+public final class ObservableMap<T, U> extends AbstractObservableWithUpstream<T, U> {
     final Function<? super T, ? extends U> function;
     
     public ObservableMap(ObservableSource<T> source, Function<? super T, ? extends U> function) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMapNotification.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableMapNotification<T, R> extends ObservableWithUpstream<T, ObservableSource<? extends R>> {
+public final class ObservableMapNotification<T, R> extends AbstractObservableWithUpstream<T, ObservableSource<? extends R>> {
 
     final Function<? super T, ? extends ObservableSource<? extends R>> onNextMapper;
     final Function<? super Throwable, ? extends ObservableSource<? extends R>> onErrorMapper;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMaterialize.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableMaterialize<T> extends ObservableWithUpstream<T, Try<Optional<T>>> {
+public final class ObservableMaterialize<T> extends AbstractObservableWithUpstream<T, Try<Optional<T>>> {
     
     
     public ObservableMaterialize(ObservableSource<T> source) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableObserveOn.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.internal.schedulers.TrampolineScheduler;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableObserveOn<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableObserveOn<T> extends AbstractObservableWithUpstream<T, T> {
     final Scheduler scheduler;
     final boolean delayError;
     final int bufferSize;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableOnErrorNext.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.functions.Function;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableOnErrorNext<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableOnErrorNext<T> extends AbstractObservableWithUpstream<T, T> {
     final Function<? super Throwable, ? extends ObservableSource<? extends T>> nextSupplier;
     final boolean allowFatal;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturn.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableOnErrorReturn<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableOnErrorReturn<T> extends AbstractObservableWithUpstream<T, T> {
     final Function<? super Throwable, ? extends T> valueSupplier;
     public ObservableOnErrorReturn(ObservableSource<T> source, Function<? super Throwable, ? extends T> valueSupplier) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.internal.subscribers.observable.ToNotificationObserver;
 import io.reactivex.subjects.BehaviorSubject;
 
-public final class ObservableRedo<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableRedo<T> extends AbstractObservableWithUpstream<T, T> {
     final Function<? super Observable<Try<Optional<Object>>>, ? extends ObservableSource<?>> manager;
 
     public ObservableRedo(ObservableSource<T> source,

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
Patch:
@@ -29,7 +29,7 @@
  * @param <T>
  *            the value type
  */
-public final class ObservableRefCount<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableRefCount<T> extends AbstractObservableWithUpstream<T, T> {
 
     final ConnectableObservable<? extends T> source;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeat.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 
-public final class ObservableRepeat<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableRepeat<T> extends AbstractObservableWithUpstream<T, T> {
     final long count;
     public ObservableRepeat(Observable<T> source, long count) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatUntil.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.*;
 import io.reactivex.functions.BooleanSupplier;
 
-public final class ObservableRepeatUntil<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableRepeatUntil<T> extends AbstractObservableWithUpstream<T, T> {
     final BooleanSupplier until;
     public ObservableRepeatUntil(Observable<T> source, BooleanSupplier until) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryBiPredicate.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.BiPredicate;
 
-public final class ObservableRetryBiPredicate<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableRetryBiPredicate<T> extends AbstractObservableWithUpstream<T, T> {
     final BiPredicate<? super Integer, ? super Throwable> predicate;
     public ObservableRetryBiPredicate(
             Observable<T> source,

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRetryPredicate.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Predicate;
 
-public final class ObservableRetryPredicate<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableRetryPredicate<T> extends AbstractObservableWithUpstream<T, T> {
     final Predicate<? super Throwable> predicate;
     final long count;
     public ObservableRetryPredicate(Observable<T> source,

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.observers.SerializedObserver;
 
-public final class ObservableSampleTimed<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSampleTimed<T> extends AbstractObservableWithUpstream<T, T> {
     final long period;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.observers.SerializedObserver;
 
-public final class ObservableSampleWithObservable<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSampleWithObservable<T> extends AbstractObservableWithUpstream<T, T> {
     final ObservableSource<?> other;
     
     public ObservableSampleWithObservable(ObservableSource<T> source, ObservableSource<?> other) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableScan<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableScan<T> extends AbstractObservableWithUpstream<T, T> {
     final BiFunction<T, T, T> accumulator;
     public ObservableScan(ObservableSource<T> source, BiFunction<T, T, T> accumulator) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableScanSeed<T, R> extends ObservableWithUpstream<T, R> {
+public final class ObservableScanSeed<T, R> extends AbstractObservableWithUpstream<T, R> {
     final BiFunction<R, ? super T, R> accumulator;
     final Callable<R> seedSupplier;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSerialized.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.Observer;
 import io.reactivex.observers.SerializedObserver;
 
-public final class ObservableSerialized<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSerialized<T> extends AbstractObservableWithUpstream<T, T> {
     public ObservableSerialized(Observable<T> upstream) {
         super(upstream);
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingle.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableSingle<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSingle<T> extends AbstractObservableWithUpstream<T, T> {
     
     final T defaultValue;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkip.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 
-public final class ObservableSkip<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSkip<T> extends AbstractObservableWithUpstream<T, T> {
     final long n;
     public ObservableSkip(ObservableSource<T> source, long n) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLast.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableSkipLast<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSkipLast<T> extends AbstractObservableWithUpstream<T, T> {
     final int skip;
     
     public ObservableSkipLast(ObservableSource<T> source, int skip) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimed.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 
-public final class ObservableSkipLastTimed<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSkipLastTimed<T> extends AbstractObservableWithUpstream<T, T> {
     final long time;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipUntil.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 
-public final class ObservableSkipUntil<T, U> extends ObservableWithUpstream<T, T> {
+public final class ObservableSkipUntil<T, U> extends AbstractObservableWithUpstream<T, T> {
     final ObservableSource<U> other;
     public ObservableSkipUntil(ObservableSource<T> source, ObservableSource<U> other) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipWhile.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableSkipWhile<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSkipWhile<T> extends AbstractObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public ObservableSkipWhile(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSubscribeOn.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableSubscribeOn<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {
     final Scheduler scheduler;
     
     public ObservableSubscribeOn(Observable<T> source, Scheduler scheduler) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchIfEmpty.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 
-public final class ObservableSwitchIfEmpty<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableSwitchIfEmpty<T> extends AbstractObservableWithUpstream<T, T> {
     final ObservableSource<? extends T> other;
     public ObservableSwitchIfEmpty(ObservableSource<T> source, ObservableSource<? extends T> other) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableSwitchMap<T, R> extends ObservableWithUpstream<T, R> {
+public final class ObservableSwitchMap<T, R> extends AbstractObservableWithUpstream<T, R> {
     final Function<? super T, ? extends ObservableSource<? extends R>> mapper;
     final int bufferSize;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTake.java
Patch:
@@ -17,7 +17,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableTake<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTake<T> extends AbstractObservableWithUpstream<T, T> {
     final long limit;
     public ObservableTake(ObservableSource<T> source, long limit) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLast.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableTakeLast<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTakeLast<T> extends AbstractObservableWithUpstream<T, T> {
     final int count;
     
     public ObservableTakeLast(ObservableSource<T> source, int count) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLastOne.java
Patch:
@@ -16,7 +16,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableTakeLastOne<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTakeLastOne<T> extends AbstractObservableWithUpstream<T, T> {
     
     public ObservableTakeLastOne(ObservableSource<T> source) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimed.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 
-public final class ObservableTakeLastTimed<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTakeLastTimed<T> extends AbstractObservableWithUpstream<T, T> {
     final long count;
     final long time;
     final TimeUnit unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 
-public final class ObservableTakeUntil<T, U> extends ObservableWithUpstream<T, T> {
+public final class ObservableTakeUntil<T, U> extends AbstractObservableWithUpstream<T, T> {
     final ObservableSource<? extends U> other;
     public ObservableTakeUntil(ObservableSource<T> source, ObservableSource<? extends U> other) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntilPredicate.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableTakeUntilPredicate<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTakeUntilPredicate<T> extends AbstractObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public ObservableTakeUntilPredicate(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeWhile.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableTakeWhile<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTakeWhile<T> extends AbstractObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
     public ObservableTakeWhile(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableThrottleFirstTimed<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableThrottleFirstTimed<T> extends AbstractObservableWithUpstream<T, T> {
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeInterval.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.schedulers.Timed;
 
-public final class ObservableTimeInterval<T> extends ObservableWithUpstream<T, Timed<T>> {
+public final class ObservableTimeInterval<T> extends AbstractObservableWithUpstream<T, Timed<T>> {
     final Scheduler scheduler;
     final TimeUnit unit;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableTimeout<T, U, V> extends ObservableWithUpstream<T, T> {
+public final class ObservableTimeout<T, U, V> extends AbstractObservableWithUpstream<T, T> {
     final Callable<? extends ObservableSource<U>> firstTimeoutSelector;
     final Function<? super T, ? extends ObservableSource<V>> timeoutSelector;
     final ObservableSource<? extends T> other;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableTimeoutTimed<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableTimeoutTimed<T> extends AbstractObservableWithUpstream<T, T> {
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableToList.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.internal.disposables.*;
 
 public final class ObservableToList<T, U extends Collection<? super T>> 
-extends ObservableWithUpstream<T, U> {
+extends AbstractObservableWithUpstream<T, U> {
     
     final Callable<U> collectionSupplier;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableUnsubscribeOn.java
Patch:
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class ObservableUnsubscribeOn<T> extends ObservableWithUpstream<T, T> {
+public final class ObservableUnsubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {
     final Scheduler scheduler;
     public ObservableUnsubscribeOn(ObservableSource<T> source, Scheduler scheduler) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindow.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.subjects.UnicastSubject;
 
-public final class ObservableWindow<T> extends ObservableWithUpstream<T, Observable<T>> {
+public final class ObservableWindow<T> extends AbstractObservableWithUpstream<T, Observable<T>> {
     final long count;
     final long skip;
     final int capacityHint;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.UnicastSubject;
 
-public final class ObservableWindowBoundary<T, B> extends ObservableWithUpstream<T, Observable<T>> {
+public final class ObservableWindowBoundary<T, B> extends AbstractObservableWithUpstream<T, Observable<T>> {
     final ObservableSource<B> other;
     final int bufferSize;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
Patch:
@@ -31,7 +31,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.UnicastSubject;
 
-public final class ObservableWindowBoundarySelector<T, B, V> extends ObservableWithUpstream<T, Observable<T>> {
+public final class ObservableWindowBoundarySelector<T, B, V> extends AbstractObservableWithUpstream<T, Observable<T>> {
     final ObservableSource<B> open;
     final Function<? super B, ? extends ObservableSource<V>> close;
     final int bufferSize;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.UnicastSubject;
 
-public final class ObservableWindowBoundarySupplier<T, B> extends ObservableWithUpstream<T, Observable<T>> {
+public final class ObservableWindowBoundarySupplier<T, B> extends AbstractObservableWithUpstream<T, Observable<T>> {
     final Callable<? extends ObservableSource<B>> other;
     final int bufferSize;
     

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.subjects.UnicastSubject;
 
-public final class ObservableWindowTimed<T> extends ObservableWithUpstream<T, Observable<T>> {
+public final class ObservableWindowTimed<T> extends AbstractObservableWithUpstream<T, Observable<T>> {
     final long timespan;
     final long timeskip;
     final TimeUnit unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class ObservableWithLatestFrom<T, U, R> extends ObservableWithUpstream<T, R> {
+public final class ObservableWithLatestFrom<T, U, R> extends AbstractObservableWithUpstream<T, R> {
     final BiFunction<? super T, ? super U, ? extends R> combiner;
     final ObservableSource<? extends U> other;
     public ObservableWithLatestFrom(ObservableSource<T> source,

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -25,6 +25,7 @@
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.operators.completable.CompletableFromObservable;
 import io.reactivex.internal.operators.flowable.FlowableFromObservable;
 import io.reactivex.internal.operators.single.SingleFromObservable;
 import io.reactivex.internal.operators.observable.*;
@@ -2867,7 +2868,7 @@ public final BlockingObservable<T> toBlocking() {
     
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Completable toCompletable() {
-        return Completable.fromObservable(this);
+        return new CompletableFromObservable<T>(this);
     }
 
     @SchedulerSupport(SchedulerSupport.NONE)

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java
Patch:
@@ -18,11 +18,11 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposables;
 
-public final class CompletableFromFlowable<T> extends Completable {
+public final class CompletableFromPublisher<T> extends Completable {
 
     final Publisher<T> flowable;
     
-    public CompletableFromFlowable(Publisher<T> flowable) {
+    public CompletableFromPublisher(Publisher<T> flowable) {
         this.flowable = flowable;
     }
 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -1050,7 +1050,7 @@ public final Observable<Boolean> any(Predicate<? super T> predicate) {
 
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> asObservable() {
-        return new ObservableWrapper<T>(this);
+        return new ObservableFromSource<T>(this);
     }
 
     @SchedulerSupport(SchedulerSupport.NONE)

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFromPublisher.java
Patch:
@@ -36,6 +36,9 @@ static final class PublisherSubscriber<T>
     extends AtomicBoolean
     implements Subscriber<T>, Disposable {
 
+        /** */
+        private static final long serialVersionUID = -7306579371159152354L;
+        
         private final Observer<? super T> o;
         private Subscription inner;
 

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -266,7 +266,7 @@ public Object call() throws Exception {
      * @throws NullPointerException if flowable is null
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Completable fromObservable(final ObservableConsumable<T> observable) {
+    public static <T> Completable fromObservable(final ObservableSource<T> observable) {
         Objects.requireNonNull(observable, "observable is null");
         return new CompletableFromObservable<T>(observable);
     }
@@ -817,7 +817,7 @@ public final Completable endWith(CompletableSource other) {
      * @throws NullPointerException if next is null
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
-    public final <T> Observable<T> endWith(ObservableConsumable<T> next) {
+    public final <T> Observable<T> endWith(ObservableSource<T> next) {
         return this.<T>toObservable().endWith(next);
     }
     

File: src/main/java/io/reactivex/ObservableSource.java
Patch:
@@ -17,12 +17,12 @@
  * consumable via an {@link Observer}.
  * <p>
  * This class also serves the base type for custom operators wrapped into
- * Observable via {@link Observable#create(ObservableConsumable)}.
+ * Observable via {@link Observable#create(ObservableSource)}.
  * 
  * @param <T> the element type
  * @since 2.0
  */
-public interface ObservableConsumable<T> {
+public interface ObservableSource<T> {
 
     void subscribe(Observer<? super T> observer);
 }

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -641,7 +641,7 @@ public final <U> Single<T> delaySubscription(SingleSource<U> other) {
         return new SingleDelayWithSingle<T, U>(this, other);
     }
 
-    public final <U> Single<T> delaySubscription(ObservableConsumable<U> other) {
+    public final <U> Single<T> delaySubscription(ObservableSource<U> other) {
         return new SingleDelayWithObservable<T, U>(this, other);
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -18,9 +18,9 @@
 
 public final class CompletableFromObservable<T> extends Completable {
 
-    final ObservableConsumable<T> observable;
+    final ObservableSource<T> observable;
 
-    public CompletableFromObservable(ObservableConsumable<T> observable) {
+    public CompletableFromObservable(ObservableSource<T> observable) {
         this.observable = observable;
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
Patch:
@@ -40,14 +40,14 @@ public enum BlockingObservableLatest {
      * @return an {@code Iterable} that blocks until or unless the {@code Observable} emits an item that has not
      *         been returned by the {@code Iterable}, then returns that item
      */
-    public static <T> Iterable<T> latest(final ObservableConsumable<? extends T> source) {
+    public static <T> Iterable<T> latest(final ObservableSource<? extends T> source) {
         return new Iterable<T>() {
             @Override
             public Iterator<T> iterator() {
                 LatestObserverIterator<T> lio = new LatestObserverIterator<T>();
                 
                 @SuppressWarnings("unchecked")
-                Observable<Try<Optional<T>>> materialized = Observable.wrap((ObservableConsumable<T>)source).materialize();
+                Observable<Try<Optional<T>>> materialized = Observable.wrap((ObservableSource<T>)source).materialize();
                 
                 materialized.subscribe(lio);
                 return lio;
@@ -126,4 +126,4 @@ public void remove() {
         }
 
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
Patch:
@@ -16,7 +16,7 @@
 
 import java.util.*;
 
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.util.NotificationLite;
 import io.reactivex.observers.DefaultObserver;
@@ -41,7 +41,7 @@ public enum BlockingObservableMostRecent {
      * @return an {@code Iterable} that always returns the item most recently emitted by {@code source}, or
      *         {@code initialValue} if {@code source} has not yet emitted any items
      */
-    public static <T> Iterable<T> mostRecent(final ObservableConsumable<? extends T> source, final T initialValue) {
+    public static <T> Iterable<T> mostRecent(final ObservableSource<? extends T> source, final T initialValue) {
         return new Iterable<T>() {
             @Override
             public Iterator<T> iterator() {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java
Patch:
@@ -19,10 +19,10 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableAll<T> extends Observable<Boolean> {
-    final ObservableConsumable<T> source;
+    final ObservableSource<T> source;
     
     final Predicate<? super T> predicate;
-    public ObservableAll(ObservableConsumable<T> source, Predicate<? super T> predicate) {
+    public ObservableAll(ObservableSource<T> source, Predicate<? super T> predicate) {
         this.source = source;
         this.predicate = predicate;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableAny.java
Patch:
@@ -18,9 +18,9 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 
 public final class ObservableAny<T> extends Observable<Boolean> {
-    final ObservableConsumable<T> source;
+    final ObservableSource<T> source;
     final Predicate<? super T> predicate;
-    public ObservableAny(ObservableConsumable<T> source, Predicate<? super T> predicate) {
+    public ObservableAny(ObservableSource<T> source, Predicate<? super T> predicate) {
         this.source = source;
         this.predicate = predicate;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java
Patch:
@@ -18,18 +18,18 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.reactivex.Observable;
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
 
 public final class ObservableBuffer<T, U extends Collection<? super T>> extends Observable<U> {
-    final ObservableConsumable<T> source;
+    final ObservableSource<T> source;
     final int count;
     final int skip;
     final Callable<U> bufferSupplier;
     
-    public ObservableBuffer(ObservableConsumable<T> source, int count, int skip, Callable<U> bufferSupplier) {
+    public ObservableBuffer(ObservableSource<T> source, int count, int skip, Callable<U> bufferSupplier) {
         this.source = source;
         this.count = count;
         this.skip = skip;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
Patch:
@@ -31,7 +31,7 @@
 public final class ObservableBufferTimed<T, U extends Collection<? super T>> 
 extends Observable<U> {
 
-    final ObservableConsumable<T> source;
+    final ObservableSource<T> source;
     final long timespan;
     final long timeskip;
     final TimeUnit unit;
@@ -40,8 +40,8 @@ public final class ObservableBufferTimed<T, U extends Collection<? super T>>
     final int maxSize;
     final boolean restartTimerOnMaxSize;
     
-    public ObservableBufferTimed(ObservableConsumable<T> source, long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable<U> bufferSupplier, int maxSize,
-            boolean restartTimerOnMaxSize) {
+    public ObservableBufferTimed(ObservableSource<T> source, long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable<U> bufferSupplier, int maxSize,
+                                 boolean restartTimerOnMaxSize) {
         this.source = source;
         this.timespan = timespan;
         this.timeskip = timeskip;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
Patch:
@@ -23,7 +23,7 @@ public final class ObservableCollect<T, U> extends ObservableWithUpstream<T, U>
     final Callable<? extends U> initialSupplier;
     final BiConsumer<? super U, ? super T> collector;
     
-    public ObservableCollect(ObservableConsumable<T> source, 
+    public ObservableCollect(ObservableSource<T> source,
             Callable<? extends U> initialSupplier, BiConsumer<? super U, ? super T> collector) {
         super(source);
         this.initialSupplier = initialSupplier;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableCount.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 
 public final class ObservableCount<T> extends ObservableWithUpstream<T, Long> {
-    public ObservableCount(ObservableConsumable<T> source) {
+    public ObservableCount(ObservableSource<T> source) {
         super(source);
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
Patch:
@@ -28,7 +28,7 @@ public final class ObservableDebounceTimed<T> extends ObservableWithUpstream<T,
     final TimeUnit unit;
     final Scheduler scheduler;
 
-    public ObservableDebounceTimed(ObservableConsumable<T> source, long timeout, TimeUnit unit, Scheduler scheduler) {
+    public ObservableDebounceTimed(ObservableSource<T> source, long timeout, TimeUnit unit, Scheduler scheduler) {
         super(source);
         this.timeout = timeout;
         this.unit = unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDefer.java
Patch:
@@ -19,13 +19,13 @@
 import io.reactivex.internal.disposables.EmptyDisposable;
 
 public final class ObservableDefer<T> extends Observable<T> {
-    final Callable<? extends ObservableConsumable<? extends T>> supplier;
-    public ObservableDefer(Callable<? extends ObservableConsumable<? extends T>> supplier) {
+    final Callable<? extends ObservableSource<? extends T>> supplier;
+    public ObservableDefer(Callable<? extends ObservableSource<? extends T>> supplier) {
         this.supplier = supplier;
     }
     @Override
     public void subscribeActual(Observer<? super T> s) {
-        ObservableConsumable<? extends T> pub;
+        ObservableSource<? extends T> pub;
         try {
             pub = supplier.call();
         } catch (Throwable t) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java
Patch:
@@ -27,7 +27,7 @@ public final class ObservableDelay<T> extends ObservableWithUpstream<T, T> {
     final Scheduler scheduler;
     final boolean delayError;
     
-    public ObservableDelay(ObservableConsumable<T> source, long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {
+    public ObservableDelay(ObservableSource<T> source, long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {
         super(source);
         this.delay = delay;
         this.unit = unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableDematerialize.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class ObservableDematerialize<T> extends ObservableWithUpstream<Try<Optional<T>>, T> {
     
-    public ObservableDematerialize(ObservableConsumable<Try<Optional<T>>> source) {
+    public ObservableDematerialize(ObservableSource<Try<Optional<T>>> source) {
         super(source);
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableElementAt.java
Patch:
@@ -20,7 +20,7 @@
 public final class ObservableElementAt<T> extends ObservableWithUpstream<T, T> {
     final long index;
     final T defaultValue;
-    public ObservableElementAt(ObservableConsumable<T> source, long index, T defaultValue) {
+    public ObservableElementAt(ObservableSource<T> source, long index, T defaultValue) {
         super(source);
         this.index = index;
         this.defaultValue = defaultValue;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class ObservableFilter<T> extends ObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
-    public ObservableFilter(ObservableConsumable<T> source, Predicate<? super T> predicate) {
+    public ObservableFilter(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);
         this.predicate = predicate;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.*;
 
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
@@ -31,7 +31,7 @@ public final class ObservableGroupBy<T, K, V> extends ObservableWithUpstream<T,
     final int bufferSize;
     final boolean delayError;
     
-    public ObservableGroupBy(ObservableConsumable<T> source, 
+    public ObservableGroupBy(ObservableSource<T> source,
             Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector, 
             int bufferSize, boolean delayError) {
         super(source);
@@ -208,7 +208,7 @@ public void onComplete() {
         }
     }
     
-    static final class State<T, K> extends AtomicInteger implements Disposable, ObservableConsumable<T> {
+    static final class State<T, K> extends AtomicInteger implements Disposable, ObservableSource<T> {
         /** */
         private static final long serialVersionUID = -3852313036005250360L;
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableIgnoreElements.java
Patch:
@@ -18,7 +18,7 @@
 
 public final class ObservableIgnoreElements<T> extends ObservableWithUpstream<T, T> {
 
-    public ObservableIgnoreElements(ObservableConsumable<T> source) {
+    public ObservableIgnoreElements(ObservableSource<T> source) {
         super(source);
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableJust.java
Patch:
@@ -38,11 +38,11 @@ public T value() {
         return value;
     }
     
-    public <U> Observable<U> scalarFlatMap(final Function<? super T, ? extends ObservableConsumable<? extends U>> mapper) {
+    public <U> Observable<U> scalarFlatMap(final Function<? super T, ? extends ObservableSource<? extends U>> mapper) {
         return new Observable<U>() {
             @Override
             public void subscribeActual(Observer<? super U> s) {
-                ObservableConsumable<? extends U> other;
+                ObservableSource<? extends U> other;
                 try {
                     other = mapper.apply(value);
                 } catch (Throwable e) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
Patch:
@@ -23,7 +23,7 @@
 public final class ObservableMap<T, U> extends ObservableWithUpstream<T, U> {
     final Function<? super T, ? extends U> function;
     
-    public ObservableMap(ObservableConsumable<T> source, Function<? super T, ? extends U> function) {
+    public ObservableMap(ObservableSource<T> source, Function<? super T, ? extends U> function) {
         super(source);
         this.function = function;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableMaterialize.java
Patch:
@@ -20,7 +20,7 @@
 public final class ObservableMaterialize<T> extends ObservableWithUpstream<T, Try<Optional<T>>> {
     
     
-    public ObservableMaterialize(ObservableConsumable<T> source) {
+    public ObservableMaterialize(ObservableSource<T> source) {
         super(source);
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableObserveOn.java
Patch:
@@ -27,7 +27,7 @@ public final class ObservableObserveOn<T> extends ObservableWithUpstream<T, T> {
     final Scheduler scheduler;
     final boolean delayError;
     final int bufferSize;
-    public ObservableObserveOn(ObservableConsumable<T> source, Scheduler scheduler, boolean delayError, int bufferSize) {
+    public ObservableObserveOn(ObservableSource<T> source, Scheduler scheduler, boolean delayError, int bufferSize) {
         super(source);
         this.scheduler = scheduler;
         this.delayError = delayError;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturn.java
Patch:
@@ -21,7 +21,7 @@
 
 public final class ObservableOnErrorReturn<T> extends ObservableWithUpstream<T, T> {
     final Function<? super Throwable, ? extends T> valueSupplier;
-    public ObservableOnErrorReturn(ObservableConsumable<T> source, Function<? super Throwable, ? extends T> valueSupplier) {
+    public ObservableOnErrorReturn(ObservableSource<T> source, Function<? super Throwable, ? extends T> valueSupplier) {
         super(source);
         this.valueSupplier = valueSupplier;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
Patch:
@@ -26,7 +26,7 @@ public final class ObservableSampleTimed<T> extends ObservableWithUpstream<T, T>
     final TimeUnit unit;
     final Scheduler scheduler;
     
-    public ObservableSampleTimed(ObservableConsumable<T> source, long period, TimeUnit unit, Scheduler scheduler) {
+    public ObservableSampleTimed(ObservableSource<T> source, long period, TimeUnit unit, Scheduler scheduler) {
         super(source);
         this.period = period;
         this.unit = unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class ObservableScan<T> extends ObservableWithUpstream<T, T> {
     final BiFunction<T, T, T> accumulator;
-    public ObservableScan(ObservableConsumable<T> source, BiFunction<T, T, T> accumulator) {
+    public ObservableScan(ObservableSource<T> source, BiFunction<T, T, T> accumulator) {
         super(source);
         this.accumulator = accumulator;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java
Patch:
@@ -24,7 +24,7 @@ public final class ObservableScanSeed<T, R> extends ObservableWithUpstream<T, R>
     final BiFunction<R, ? super T, R> accumulator;
     final Callable<R> seedSupplier;
 
-    public ObservableScanSeed(ObservableConsumable<T> source, Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {
+    public ObservableScanSeed(ObservableSource<T> source, Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {
         super(source);
         this.accumulator = accumulator;
         this.seedSupplier = seedSupplier;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSingle.java
Patch:
@@ -23,7 +23,7 @@ public final class ObservableSingle<T> extends ObservableWithUpstream<T, T> {
     
     final T defaultValue;
     
-    public ObservableSingle(ObservableConsumable<T> source, T defaultValue) {
+    public ObservableSingle(ObservableSource<T> source, T defaultValue) {
         super(source);
         this.defaultValue = defaultValue;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkip.java
Patch:
@@ -18,7 +18,7 @@
 
 public final class ObservableSkip<T> extends ObservableWithUpstream<T, T> {
     final long n;
-    public ObservableSkip(ObservableConsumable<T> source, long n) {
+    public ObservableSkip(ObservableSource<T> source, long n) {
         super(source);
         this.n = n;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLast.java
Patch:
@@ -22,7 +22,7 @@
 public final class ObservableSkipLast<T> extends ObservableWithUpstream<T, T> {
     final int skip;
     
-    public ObservableSkipLast(ObservableConsumable<T> source, int skip) {
+    public ObservableSkipLast(ObservableSource<T> source, int skip) {
         super(source);
         this.skip = skip;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimed.java
Patch:
@@ -28,7 +28,7 @@ public final class ObservableSkipLastTimed<T> extends ObservableWithUpstream<T,
     final int bufferSize;
     final boolean delayError;
 
-    public ObservableSkipLastTimed(ObservableConsumable<T> source, 
+    public ObservableSkipLastTimed(ObservableSource<T> source,
             long time, TimeUnit unit, Scheduler scheduler, int bufferSize, boolean delayError) {
         super(source);
         this.time = time;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipUntil.java
Patch:
@@ -21,8 +21,8 @@
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableSkipUntil<T, U> extends ObservableWithUpstream<T, T> {
-    final ObservableConsumable<U> other;
-    public ObservableSkipUntil(ObservableConsumable<T> source, ObservableConsumable<U> other) {
+    final ObservableSource<U> other;
+    public ObservableSkipUntil(ObservableSource<T> source, ObservableSource<U> other) {
         super(source);
         this.other = other;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableSkipWhile.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class ObservableSkipWhile<T> extends ObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
-    public ObservableSkipWhile(ObservableConsumable<T> source, Predicate<? super T> predicate) {
+    public ObservableSkipWhile(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);
         this.predicate = predicate;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTake.java
Patch:
@@ -19,7 +19,7 @@
 
 public final class ObservableTake<T> extends ObservableWithUpstream<T, T> {
     final long limit;
-    public ObservableTake(ObservableConsumable<T> source, long limit) {
+    public ObservableTake(ObservableSource<T> source, long limit) {
         super(source);
         this.limit = limit;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLast.java
Patch:
@@ -22,7 +22,7 @@
 public final class ObservableTakeLast<T> extends ObservableWithUpstream<T, T> {
     final int count;
     
-    public ObservableTakeLast(ObservableConsumable<T> source, int count) {
+    public ObservableTakeLast(ObservableSource<T> source, int count) {
         super(source);
         this.count = count;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLastOne.java
Patch:
@@ -18,7 +18,7 @@
 
 public final class ObservableTakeLastOne<T> extends ObservableWithUpstream<T, T> {
     
-    public ObservableTakeLastOne(ObservableConsumable<T> source) {
+    public ObservableTakeLastOne(ObservableSource<T> source) {
         super(source);
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimed.java
Patch:
@@ -29,7 +29,7 @@ public final class ObservableTakeLastTimed<T> extends ObservableWithUpstream<T,
     final int bufferSize;
     final boolean delayError;
 
-    public ObservableTakeLastTimed(ObservableConsumable<T> source, 
+    public ObservableTakeLastTimed(ObservableSource<T> source,
             long count, long time, TimeUnit unit, Scheduler scheduler, int bufferSize, boolean delayError) {
         super(source);
         this.count = count;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntil.java
Patch:
@@ -21,8 +21,8 @@
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableTakeUntil<T, U> extends ObservableWithUpstream<T, T> {
-    final ObservableConsumable<? extends U> other;
-    public ObservableTakeUntil(ObservableConsumable<T> source, ObservableConsumable<? extends U> other) {
+    final ObservableSource<? extends U> other;
+    public ObservableTakeUntil(ObservableSource<T> source, ObservableSource<? extends U> other) {
         super(source);
         this.other = other;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeUntilPredicate.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class ObservableTakeUntilPredicate<T> extends ObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
-    public ObservableTakeUntilPredicate(ObservableConsumable<T> source, Predicate<? super T> predicate) {
+    public ObservableTakeUntilPredicate(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);
         this.predicate = predicate;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTakeWhile.java
Patch:
@@ -20,7 +20,7 @@
 
 public final class ObservableTakeWhile<T> extends ObservableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
-    public ObservableTakeWhile(ObservableConsumable<T> source, Predicate<? super T> predicate) {
+    public ObservableTakeWhile(ObservableSource<T> source, Predicate<? super T> predicate) {
         super(source);
         this.predicate = predicate;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java
Patch:
@@ -28,7 +28,7 @@ public final class ObservableThrottleFirstTimed<T> extends ObservableWithUpstrea
     final TimeUnit unit;
     final Scheduler scheduler;
 
-    public ObservableThrottleFirstTimed(ObservableConsumable<T> source, 
+    public ObservableThrottleFirstTimed(ObservableSource<T> source,
             long timeout, TimeUnit unit, Scheduler scheduler) {
         super(source);
         this.timeout = timeout;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeInterval.java
Patch:
@@ -24,7 +24,7 @@ public final class ObservableTimeInterval<T> extends ObservableWithUpstream<T, T
     final Scheduler scheduler;
     final TimeUnit unit;
     
-    public ObservableTimeInterval(ObservableConsumable<T> source, TimeUnit unit, Scheduler scheduler) {
+    public ObservableTimeInterval(ObservableSource<T> source, TimeUnit unit, Scheduler scheduler) {
         super(source);
         this.scheduler = scheduler;
         this.unit = unit;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableToList.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.*;
 import java.util.concurrent.Callable;
 
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
@@ -26,7 +26,7 @@ public final class ObservableToList<T, U extends Collection<? super T>>
     
     final Callable<U> collectionSupplier;
     
-    public ObservableToList(ObservableConsumable<T> source, final int defaultCapacityHint) {
+    public ObservableToList(ObservableSource<T> source, final int defaultCapacityHint) {
         super(source);
         this.collectionSupplier = new Callable<U>() {
             @Override
@@ -37,7 +37,7 @@ public U call() throws Exception {
         };
     }
 
-    public ObservableToList(ObservableConsumable<T> source, Callable<U> collectionSupplier) {
+    public ObservableToList(ObservableSource<T> source, Callable<U> collectionSupplier) {
         super(source);
         this.collectionSupplier = collectionSupplier;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableUnsubscribeOn.java
Patch:
@@ -21,7 +21,7 @@
 
 public final class ObservableUnsubscribeOn<T> extends ObservableWithUpstream<T, T> {
     final Scheduler scheduler;
-    public ObservableUnsubscribeOn(ObservableConsumable<T> source, Scheduler scheduler) {
+    public ObservableUnsubscribeOn(ObservableSource<T> source, Scheduler scheduler) {
         super(source);
         this.scheduler = scheduler;
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableUsing.java
Patch:
@@ -25,12 +25,12 @@
 
 public final class ObservableUsing<T, D> extends Observable<T> {
     final Callable<? extends D> resourceSupplier;
-    final Function<? super D, ? extends ObservableConsumable<? extends T>> sourceSupplier;
+    final Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier;
     final Consumer<? super D> disposer;
     final boolean eager;
     
     public ObservableUsing(Callable<? extends D> resourceSupplier,
-            Function<? super D, ? extends ObservableConsumable<? extends T>> sourceSupplier, 
+            Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier,
             Consumer<? super D> disposer,
             boolean eager) {
         this.resourceSupplier = resourceSupplier;
@@ -50,7 +50,7 @@ public void subscribeActual(Observer<? super T> s) {
             return;
         }
         
-        ObservableConsumable<? extends T> source;
+        ObservableSource<? extends T> source;
         try {
             source = sourceSupplier.apply(resource);
         } catch (Throwable e) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindow.java
Patch:
@@ -26,7 +26,7 @@ public final class ObservableWindow<T> extends ObservableWithUpstream<T, Observa
     final long skip;
     final int capacityHint;
     
-    public ObservableWindow(ObservableConsumable<T> source, long count, long skip, int capacityHint) {
+    public ObservableWindow(ObservableSource<T> source, long count, long skip, int capacityHint) {
         super(source);
         this.count = count;
         this.skip = skip;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
Patch:
@@ -42,7 +42,7 @@ public final class ObservableWindowTimed<T> extends ObservableWithUpstream<T, Ob
     final boolean restartTimerOnMaxSize;
 
     public ObservableWindowTimed(
-            ObservableConsumable<T> source, 
+            ObservableSource<T> source,
             long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, long maxSize,
             int bufferSize, boolean restartTimerOnMaxSize) {
         super(source);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java
Patch:
@@ -24,9 +24,9 @@
 
 public final class ObservableWithLatestFrom<T, U, R> extends ObservableWithUpstream<T, R> {
     final BiFunction<? super T, ? super U, ? extends R> combiner;
-    final ObservableConsumable<? extends U> other;
-    public ObservableWithLatestFrom(ObservableConsumable<T> source, 
-            BiFunction<? super T, ? super U, ? extends R> combiner, ObservableConsumable<? extends U> other) {
+    final ObservableSource<? extends U> other;
+    public ObservableWithLatestFrom(ObservableSource<T> source,
+            BiFunction<? super T, ? super U, ? extends R> combiner, ObservableSource<? extends U> other) {
         super(source);
         this.combiner = combiner;
         this.other = other;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWithUpstream.java
Patch:
@@ -24,13 +24,13 @@
 public abstract class ObservableWithUpstream<T, U> extends Observable<U> {
 
     /** The source consumable Observable. */
-    protected final ObservableConsumable<T> source;
+    protected final ObservableSource<T> source;
     
     /**
      * Constructs the ObservableSource with the given consumable.
      * @param source the consumable Observable
      */
-    public ObservableWithUpstream(ObservableConsumable<T> source) {
+    public ObservableWithUpstream(ObservableSource<T> source) {
         this.source = source;
     }
     
@@ -39,7 +39,7 @@ public ObservableWithUpstream(ObservableConsumable<T> source) {
      * <p>Allows discovering the chain of observables.
      * @return the source ObservableConsumable
      */
-    public final ObservableConsumable<T> source() {
+    public final ObservableSource<T> source() {
         return source;
     }
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWrapper.java
Patch:
@@ -16,9 +16,9 @@
 import io.reactivex.*;
 
 public final class ObservableWrapper<T> extends Observable<T> {
-    final ObservableConsumable<T> onSubscribe;
+    final ObservableSource<T> onSubscribe;
 
-    public ObservableWrapper(ObservableConsumable<T> onSubscribe) {
+    public ObservableWrapper(ObservableSource<T> onSubscribe) {
         this.onSubscribe = onSubscribe;
     }
     

File: src/main/java/io/reactivex/internal/operators/single/SingleDelayWithObservable.java
Patch:
@@ -25,9 +25,9 @@ public final class SingleDelayWithObservable<T, U> extends Single<T> {
 
     final SingleSource<T> source;
     
-    final ObservableConsumable<U> other;
+    final ObservableSource<U> other;
     
-    public SingleDelayWithObservable(SingleSource<T> source, ObservableConsumable<U> other) {
+    public SingleDelayWithObservable(SingleSource<T> source, ObservableSource<U> other) {
         this.source = source;
         this.other = other;
     }

File: src/main/java/io/reactivex/subjects/AsyncSubject.java
Patch:
@@ -142,7 +142,7 @@ public boolean hasValue() {
         return o != null && !NotificationLite.isComplete(o) && !NotificationLite.isError(o);
     }
     
-    static final class State<T> extends AtomicReference<Object> implements ObservableConsumable<T>, Observer<T> {
+    static final class State<T> extends AtomicReference<Object> implements ObservableSource<T>, Observer<T> {
         /** */
         private static final long serialVersionUID = 4876574210612691772L;
 
@@ -307,4 +307,4 @@ public void onComplete() {
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/subjects/BehaviorSubject.java
Patch:
@@ -146,7 +146,7 @@ public boolean hasValue() {
         return o != null && !NotificationLite.isComplete(o) && !NotificationLite.isError(o);
     }
     
-    static final class State<T> extends AtomicReference<Object> implements ObservableConsumable<T>, Observer<T> {
+    static final class State<T> extends AtomicReference<Object> implements ObservableSource<T>, Observer<T> {
         /** */
         private static final long serialVersionUID = -4311717003288339429L;
 

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -101,7 +101,7 @@ public boolean hasValue() {
         return false;
     }
     
-    static final class State<T> extends AtomicReference<Object> implements ObservableConsumable<T>, Observer<T> {
+    static final class State<T> extends AtomicReference<Object> implements ObservableSource<T>, Observer<T> {
         /** */
         private static final long serialVersionUID = 4876574210612691772L;
 
@@ -263,4 +263,4 @@ public void onComplete() {
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/subjects/ReplaySubject.java
Patch:
@@ -170,7 +170,7 @@ public boolean hasValue() {
         return state.buffer.size();
     }
     
-    static final class State<T> extends AtomicReference<Object> implements ObservableConsumable<T>, Observer<T> {
+    static final class State<T> extends AtomicReference<Object> implements ObservableSource<T>, Observer<T> {
         /** */
         private static final long serialVersionUID = -4673197222000219014L;
 

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -100,7 +100,7 @@ static abstract class StatePad0 extends AtomicInteger {
     }
     
     /** The state of the UnicastSubject. */
-    static final class State<T> extends StatePad0 implements ObservableConsumable<T>, Disposable, Observer<T> {
+    static final class State<T> extends StatePad0 implements ObservableSource<T>, Disposable, Observer<T> {
         /** */
         private static final long serialVersionUID = 5058617037583835632L;
 
@@ -367,4 +367,4 @@ public T[] getValues(T[] array) {
         }
         return array;
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableNextTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.*;
 
 import io.reactivex.Observable;
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -235,7 +235,7 @@ public void testNoBufferingOrBlockingOfSequence() throws Throwable {
         final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
         final AtomicBoolean running = new AtomicBoolean(true);
         final AtomicInteger count = new AtomicInteger(0);
-        final Observable<Integer> obs = Observable.create(new ObservableConsumable<Integer>() {
+        final Observable<Integer> obs = Observable.create(new ObservableSource<Integer>() {
 
             @Override
             public void subscribe(final Observer<? super Integer> o) {
@@ -318,4 +318,4 @@ public void testSynchronousNext() {
         assertEquals(2, BehaviorProcessor.createDefault(2).toBlocking().iterator().next().intValue());
         assertEquals(3, BehaviorProcessor.createDefault(3).toBlocking().next().iterator().next().intValue());
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToIteratorTest.java
Patch:
@@ -46,7 +46,7 @@ public void testToIterator() {
 
     @Test(expected = TestException.class)
     public void testToIteratorWithException() {
-        Observable<String> obs = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> obs = Observable.create(new ObservableSource<String>() {
 
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
@@ -68,7 +68,7 @@ public void subscribe(Observer<? super String> NbpObserver) {
     @Ignore("subscribe() should not throw")
     @Test(expected = TestException.class)
     public void testExceptionThrownFromOnSubscribe() {
-        Iterable<String> strings = Observable.create(new ObservableConsumable<String>() {
+        Iterable<String> strings = Observable.create(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpSubscriber) {
                 throw new TestException("intentional");
@@ -79,4 +79,4 @@ public void subscribe(Observer<? super String> NbpSubscriber) {
             System.out.println(string);
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java
Patch:
@@ -43,7 +43,7 @@ public void setUp() {
 
     private Observable<String> createObservable(final String[] values,
             final long interval, final Throwable e) {
-        return Observable.create(new ObservableConsumable<String>() {
+        return Observable.create(new ObservableSource<String>() {
 
             @Override
             public void subscribe(final Observer<? super String> NbpSubscriber) {
@@ -220,4 +220,4 @@ public void testAmbCancelsOthers() {
         assertFalse("Source 2 still has subscribers!", source3.hasSubscribers());
         
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableDoOnSubscribeTest.java
Patch:
@@ -67,7 +67,7 @@ public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
         final AtomicInteger countBefore = new AtomicInteger();
         final AtomicInteger countAfter = new AtomicInteger();
         final AtomicReference<Observer<? super Integer>> sref = new AtomicReference<Observer<? super Integer>>();
-        Observable<Integer> o = Observable.create(new ObservableConsumable<Integer>() {
+        Observable<Integer> o = Observable.create(new ObservableSource<Integer>() {
 
             @Override
             public void subscribe(Observer<? super Integer> s) {
@@ -104,4 +104,4 @@ public void accept(Disposable s) {
         assertEquals(6, countAfter.get());
     }
 
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableFromIterableTest.java
Patch:
@@ -233,9 +233,9 @@ public void fusionWithConcatMap() {
         TestObserver<Integer> to = new TestObserver<Integer>();
         
         Observable.fromIterable(Arrays.asList(1, 2, 3, 4)).concatMap(
-        new Function<Integer, ObservableConsumable<Integer>>() {
+        new Function<Integer, ObservableSource<Integer>>() {
             @Override
-            public ObservableConsumable<Integer> apply(Integer v) {
+            public ObservableSource<Integer> apply(Integer v) {
                 return Observable.range(v, 2);
             }
         }).subscribe(to);
@@ -244,4 +244,4 @@ public ObservableConsumable<Integer> apply(Integer v) {
         to.assertNoErrors();
         to.assertComplete();
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMaterializeTest.java
Patch:
@@ -132,7 +132,7 @@ public void onNext(Try<Optional<String>> value) {
 
     }
 
-    private static class TestAsyncErrorObservable implements ObservableConsumable<String> {
+    private static class TestAsyncErrorObservable implements ObservableSource<String> {
 
         String[] valuesToReturn;
 
@@ -171,4 +171,4 @@ public void run() {
             t.start();
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableMergeMaxConcurrentTest.java
Patch:
@@ -85,7 +85,7 @@ public void testMaxConcurrent() {
         }
     }
 
-    private static class SubscriptionCheckObservable implements ObservableConsumable<String> {
+    private static class SubscriptionCheckObservable implements ObservableSource<String> {
 
         private final AtomicInteger subscriptionCount;
         private final int maxConcurrent;
@@ -268,4 +268,4 @@ public void testTake() throws Exception {
         ts.assertNoErrors();
         ts.assertValueCount(5);
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturnTest.java
Patch:
@@ -176,7 +176,7 @@ public Integer apply(Integer t1) {
         ts.assertNoErrors();
     }
 
-    private static class TestObservable implements ObservableConsumable<String> {
+    private static class TestObservable implements ObservableSource<String> {
 
         final String[] values;
         Thread t = null;
@@ -214,4 +214,4 @@ public void run() {
     
     
     
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnExceptionResumeNextViaObservableTest.java
Patch:
@@ -214,7 +214,7 @@ public Integer apply(Integer t1) {
     }
 
 
-    private static class TestObservable implements ObservableConsumable<String> {
+    private static class TestObservable implements ObservableSource<String> {
 
         final String[] values;
         Thread t = null;
@@ -259,4 +259,4 @@ else if ("THROWABLE".equals(s))
             System.out.println("done starting TestObservable thread");
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservablePublishTest.java
Patch:
@@ -36,7 +36,7 @@ public class ObservablePublishTest {
     @Test
     public void testPublish() throws InterruptedException {
         final AtomicInteger counter = new AtomicInteger();
-        ConnectableObservable<String> o = Observable.create(new ObservableConsumable<String>() {
+        ConnectableObservable<String> o = Observable.create(new ObservableSource<String>() {
 
             @Override
             public void subscribe(final Observer<? super String> NbpObserver) {
@@ -344,7 +344,7 @@ static boolean checkPublishDisposed(Disposable d) {
     @Test
     public void testConnectIsIdempotent() {
         final AtomicInteger calls = new AtomicInteger();
-        Observable<Integer> source = Observable.create(new ObservableConsumable<Integer>() {
+        Observable<Integer> source = Observable.create(new ObservableSource<Integer>() {
             @Override
             public void subscribe(Observer<? super Integer> t) {
                 t.onSubscribe(EmptyDisposable.INSTANCE);
@@ -393,4 +393,4 @@ public void testObserveOn() {
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -290,7 +290,7 @@ public void accept(Disposable s) {
     }
 
     private Observable<Long> synchronousInterval() {
-        return Observable.create(new ObservableConsumable<Long>() {
+        return Observable.create(new ObservableSource<Long>() {
             @Override
             public void subscribe(Observer<? super Long> NbpSubscriber) {
                 final AtomicBoolean cancel = new AtomicBoolean();
@@ -318,7 +318,7 @@ public void run() {
     public void onlyFirstShouldSubscribeAndLastUnsubscribe() {
         final AtomicInteger subscriptionCount = new AtomicInteger();
         final AtomicInteger unsubscriptionCount = new AtomicInteger();
-        Observable<Integer> o = Observable.create(new ObservableConsumable<Integer>() {
+        Observable<Integer> o = Observable.create(new ObservableSource<Integer>() {
             @Override
             public void subscribe(Observer<? super Integer> NbpObserver) {
                 subscriptionCount.incrementAndGet();
@@ -585,4 +585,4 @@ public void onError(Throwable t) {
         public void onComplete() {
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java
Patch:
@@ -38,7 +38,7 @@ public class ObservableRepeatTest {
     public void testRepetition() {
         int NUM = 10;
         final AtomicInteger count = new AtomicInteger();
-        int value = Observable.create(new ObservableConsumable<Integer>() {
+        int value = Observable.create(new ObservableSource<Integer>() {
 
             @Override
             public void subscribe(final Observer<? super Integer> o) {
@@ -67,7 +67,7 @@ public void testNoStackOverFlow() {
     public void testRepeatTakeWithSubscribeOn() throws InterruptedException {
 
         final AtomicInteger counter = new AtomicInteger();
-        Observable<Integer> oi = Observable.create(new ObservableConsumable<Integer>() {
+        Observable<Integer> oi = Observable.create(new ObservableSource<Integer>() {
 
             @Override
             public void subscribe(Observer<? super Integer> sub) {
@@ -194,4 +194,4 @@ public Observable<Integer> apply(Integer x) {
         
         assertEquals(Arrays.asList(1, 2, 1, 2, 1, 2, 1, 2, 1, 2), concatBase);
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
Patch:
@@ -798,7 +798,7 @@ public void testColdReplayNoBackpressure() {
     @Test
     public void testCache() throws InterruptedException {
         final AtomicInteger counter = new AtomicInteger();
-        Observable<String> o = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> o = Observable.create(new ObservableSource<String>() {
 
             @Override
             public void subscribe(final Observer<? super String> NbpObserver) {
@@ -934,7 +934,7 @@ public void testAsyncComeAndGo() {
     @Test
     public void testNoMissingBackpressureException() {
         final int m = 4 * 1000 * 1000;
-        Observable<Integer> firehose = Observable.create(new ObservableConsumable<Integer>() {
+        Observable<Integer> firehose = Observable.create(new ObservableSource<Integer>() {
             @Override
             public void subscribe(Observer<? super Integer> t) {
                 t.onSubscribe(EmptyDisposable.INSTANCE);
@@ -1005,4 +1005,4 @@ public void onNext(Integer t) {
         ts.assertNotComplete();
         ts.assertError(TestException.class);
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSampleTest.java
Patch:
@@ -44,7 +44,7 @@ public void before() {
 
     @Test
     public void testSample() {
-        Observable<Long> source = Observable.create(new ObservableConsumable<Long>() {
+        Observable<Long> source = Observable.create(new ObservableSource<Long>() {
             @Override
             public void subscribe(final Observer<? super Long> observer1) {
                 observer1.onSubscribe(EmptyDisposable.INSTANCE);
@@ -266,7 +266,7 @@ public void sampleWithSamplerThrows() {
     public void testSampleUnsubscribe() {
         final Disposable s = mock(Disposable.class);
         Observable<Integer> o = Observable.create(
-                new ObservableConsumable<Integer>() {
+                new ObservableSource<Integer>() {
                     @Override
                     public void subscribe(Observer<? super Integer> NbpSubscriber) {
                         NbpSubscriber.onSubscribe(s);
@@ -276,4 +276,4 @@ public void subscribe(Observer<? super Integer> NbpSubscriber) {
         o.throttleLast(1, TimeUnit.MILLISECONDS).subscribe().dispose();
         verify(s).dispose();
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSerializeTest.java
Patch:
@@ -207,7 +207,7 @@ private static enum TestConcurrencyobserverEvent {
     /**
      * This spawns a single thread for the subscribe execution
      */
-    private static class TestSingleThreadedObservable implements ObservableConsumable<String> {
+    private static class TestSingleThreadedObservable implements ObservableSource<String> {
 
         final String[] values;
         private Thread t = null;
@@ -256,7 +256,7 @@ public void waitToFinish() {
     /**
      * This spawns a thread for the subscription, then a separate thread for each onNext call.
      */
-    private static class TestMultiThreadedObservable implements ObservableConsumable<String> {
+    private static class TestMultiThreadedObservable implements ObservableSource<String> {
         final String[] values;
         Thread t = null;
         AtomicInteger threadsRunning = new AtomicInteger();
@@ -399,4 +399,4 @@ public void onNext(String args) {
         }
 
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeUntilTest.java
Patch:
@@ -151,7 +151,7 @@ public void testTakeUntilOtherCompleted() {
 
     }
 
-    private static class TestObservable implements ObservableConsumable<String> {
+    private static class TestObservable implements ObservableSource<String> {
 
         Observer<? super String> NbpObserver;
         Disposable s;
@@ -252,4 +252,4 @@ public void testDownstreamUnsubscribes() {
         assertFalse("Until still has observers", until.hasSubscribers());
         assertFalse("NbpTestSubscriber is unsubscribed", ts.isCancelled());
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTakeWhileTest.java
Patch:
@@ -100,7 +100,7 @@ public boolean test(String input) {
 
     @Test
     public void testTakeWhileDoesntLeakErrors() {
-        Observable<String> source = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> source = Observable.create(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
                 NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
@@ -176,7 +176,7 @@ public boolean test(String s) {
         verify(s, times(1)).dispose();
     }
 
-    private static class TestObservable implements ObservableConsumable<String> {
+    private static class TestObservable implements ObservableSource<String> {
 
         final Disposable s;
         final String[] values;
@@ -249,4 +249,4 @@ public boolean test(String t1) {
 //        assertTrue(ts.getOnErrorEvents().get(0).getCause().getMessage().contains("abc"));
     }
     
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
Patch:
@@ -42,7 +42,7 @@ public void before() {
 
     @Test
     public void testThrottlingWithCompleted() {
-        Observable<String> source = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> source = Observable.create(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
                 NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
@@ -70,7 +70,7 @@ public void subscribe(Observer<? super String> NbpObserver) {
 
     @Test
     public void testThrottlingWithError() {
-        Observable<String> source = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> source = Observable.create(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
                 NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
@@ -149,4 +149,4 @@ public void testThrottle() {
         inOrder.verify(NbpObserver).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutWithSelectorTest.java
Patch:
@@ -325,7 +325,7 @@ public void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() throws Interr
             public Observable<Integer> apply(Integer t1) {
                 if (t1 == 1) {
                     // Force "unsubscribe" run on another thread
-                    return Observable.create(new ObservableConsumable<Integer>() {
+                    return Observable.create(new ObservableSource<Integer>() {
                         @Override
                         public void subscribe(Observer<? super Integer> NbpSubscriber) {
                             NbpSubscriber.onSubscribe(EmptyDisposable.INSTANCE);
@@ -417,4 +417,4 @@ public void run() {
         inOrder.verify(o).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUnsubscribeOnTest.java
Patch:
@@ -33,7 +33,7 @@ public void testUnsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnSameThread() thro
         try {
             final ThreadSubscription subscription = new ThreadSubscription();
             final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>();
-            Observable<Integer> w = Observable.create(new ObservableConsumable<Integer>() {
+            Observable<Integer> w = Observable.create(new ObservableSource<Integer>() {
 
                 @Override
                 public void subscribe(Observer<? super Integer> t1) {
@@ -77,7 +77,7 @@ public void testUnsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnDifferentThreads(
         try {
             final ThreadSubscription subscription = new ThreadSubscription();
             final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>();
-            Observable<Integer> w = Observable.create(new ObservableConsumable<Integer>() {
+            Observable<Integer> w = Observable.create(new ObservableSource<Integer>() {
 
                 @Override
                 public void subscribe(Observer<? super Integer> t1) {
@@ -181,4 +181,4 @@ public Thread getThread() {
         }
 
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
Patch:
@@ -253,7 +253,7 @@ public Disposable call() {
         Function<Disposable, Observable<Integer>> observableFactory = new Function<Disposable, Observable<Integer>>() {
             @Override
             public Observable<Integer> apply(Disposable subscription) {
-                return Observable.create(new ObservableConsumable<Integer>() {
+                return Observable.create(new ObservableSource<Integer>() {
                     @Override
                     public void subscribe(Observer<? super Integer> t1) {
                         throw new TestException();
@@ -433,4 +433,4 @@ public void run() {
         };
     }
     
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.*;
@@ -198,7 +198,7 @@ private List<String> list(String... args) {
     
 
     public static Observable<Integer> hotStream() {
-        return Observable.create(new ObservableConsumable<Integer>() {
+        return Observable.create(new ObservableSource<Integer>() {
             @Override
             public void subscribe(Observer<? super Integer> s) {
                 Disposable d = Disposables.empty();
@@ -241,4 +241,4 @@ public Observable<Integer> apply(Observable<Integer> w) {
         ts.assertComplete();
         ts.assertValueCount(22);
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
Patch:
@@ -46,7 +46,7 @@ public void testTimedAndCount() {
         final List<String> list = new ArrayList<String>();
         final List<List<String>> lists = new ArrayList<List<String>>();
 
-        Observable<String> source = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> source = Observable.create(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
                 NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
@@ -80,7 +80,7 @@ public void testTimed() {
         final List<String> list = new ArrayList<String>();
         final List<List<String>> lists = new ArrayList<List<String>>();
 
-        Observable<String> source = Observable.create(new ObservableConsumable<String>() {
+        Observable<String> source = Observable.create(new ObservableSource<String>() {
             @Override
             public void subscribe(Observer<? super String> NbpObserver) {
                 NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
@@ -219,4 +219,4 @@ public void accept(Integer pv) {
         Assert.assertTrue(ts.valueCount() != 0);
     }
     
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/observable/ObservableConcatTests.java
Patch:
@@ -19,7 +19,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.ObservableConsumable;
+import io.reactivex.ObservableSource;
 import io.reactivex.Observer;
 import io.reactivex.observable.ObservableCovarianceTest.*;
 
@@ -145,7 +145,7 @@ public void testConcatCovariance4() {
         Media media = new Media();
         HorrorMovie horrorMovie2 = new HorrorMovie();
         
-        Observable<Movie> o1 = Observable.create(new ObservableConsumable<Movie>() {
+        Observable<Movie> o1 = Observable.create(new ObservableSource<Movie>() {
             @Override
             public void subscribe(Observer<? super Movie> o) {
                     o.onNext(horrorMovie1);
@@ -165,4 +165,4 @@ public void subscribe(Observer<? super Movie> o) {
         assertEquals(horrorMovie2, values.get(3));
         assertEquals(4, values.size());
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/observable/ObservableCovarianceTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.Transformer;
+import io.reactivex.ObservableTransformer;
 import io.reactivex.functions.*;
 import io.reactivex.observables.GroupedObservable;
 import io.reactivex.observers.TestObserver;
@@ -207,7 +207,7 @@ public Observable<Movie> apply(List<List<Movie>> listOfLists) {
         }
     };
     
-    static Transformer<List<Movie>, Movie> deltaTransformer = new Transformer<List<Movie>, Movie>() {
+    static ObservableTransformer<List<Movie>, Movie> deltaTransformer = new ObservableTransformer<List<Movie>, Movie>() {
         @Override
         public Observable<Movie> apply(Observable<List<Movie>> movieList) {
             return movieList

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.*;
 import io.reactivex.Observable;
-import io.reactivex.Observable.Operator;
+import io.reactivex.ObservableOperator;
 import io.reactivex.Observer;
 import io.reactivex.Optional;
 import io.reactivex.disposables.Disposable;
@@ -1618,7 +1618,7 @@ public void liftNull() {
     
     @Test(expected = NullPointerException.class)
     public void liftReturnsNull() {
-        just1.lift(new Operator<Object, Integer>() {
+        just1.lift(new ObservableOperator<Object, Integer>() {
             @Override
             public Observer<? super Integer> apply(Observer<? super Object> s) {
                 return null;
@@ -2787,4 +2787,4 @@ public Object apply(Integer a, Integer b) {
         }).toBlocking().run();
     }
     
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.junit.Test;
 
 import io.reactivex.*;
-import io.reactivex.Observable.Operator;
+import io.reactivex.ObservableOperator;
 import io.reactivex.observers.DefaultObserver;
 
 public class ObservableSubscriberTest {
@@ -85,7 +85,7 @@ public void onNext(Integer t) {
     @Test
     public void testOnStartCalledOnceViaLift() {
         final AtomicInteger c = new AtomicInteger();
-        Observable.just(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {
+        Observable.just(1, 2, 3, 4).lift(new ObservableOperator<Integer, Integer>() {
 
             @Override
             public Observer<? super Integer> apply(final Observer<? super Integer> child) {
@@ -118,4 +118,4 @@ public void onNext(Integer t) {
 
         assertEquals(1, c.get());
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/subjects/ReplaySubjectBoundedConcurrencyTest.java
Patch:
@@ -38,7 +38,7 @@ public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther(
 
             @Override
             public void run() {
-                Observable.create(new ObservableConsumable<Long>() {
+                Observable.create(new ObservableSource<Long>() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
@@ -148,7 +148,7 @@ public void testReplaySubjectConcurrentSubscriptions() throws InterruptedExcepti
 
             @Override
             public void run() {
-                Observable.create(new ObservableConsumable<Long>() {
+                Observable.create(new ObservableSource<Long>() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
@@ -554,4 +554,4 @@ public void run() {
         
         t.join();
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java
Patch:
@@ -38,7 +38,7 @@ public void testNbpReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOth
 
             @Override
             public void run() {
-                Observable.create(new ObservableConsumable<Long>() {
+                Observable.create(new ObservableSource<Long>() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
@@ -148,7 +148,7 @@ public void testNbpReplaySubjectConcurrentSubscriptions() throws InterruptedExce
 
             @Override
             public void run() {
-                Observable.create(new ObservableConsumable<Long>() {
+                Observable.create(new ObservableSource<Long>() {
 
                     @Override
                     public void subscribe(Observer<? super Long> o) {
@@ -444,4 +444,4 @@ public void run() {
         
         t.join();
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/CompletableObserver.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * Represents the subscription API callbacks when subscribing to a Completable instance.
  */
-public interface CompletableSubscriber {
+public interface CompletableObserver {
     /**
      * Called once the deferred computation completes normally.
      */
@@ -36,4 +36,4 @@ public interface CompletableSubscriber {
      * @param d the Disposable instance to call dispose on for cancellation, not null
      */
     void onSubscribe(Disposable d);
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/Single.java
Patch:
@@ -633,7 +633,7 @@ public final Single<T> delay(final long time, final TimeUnit unit, final Schedul
         return new SingleDelay<T>(this, time, unit, scheduler);
     }
 
-    public final Single<T> delaySubscription(CompletableConsumable other) {
+    public final Single<T> delaySubscription(CompletableSource other) {
         return new SingleDelayWithCompletable<T>(this, other);
     }
 

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -40,12 +40,12 @@ public static void error(Throwable e, Observer<?> s) {
         s.onError(e);
     }
 
-    public static void complete(CompletableSubscriber s) {
+    public static void complete(CompletableObserver s) {
         s.onSubscribe(INSTANCE);
         s.onComplete();
     }
     
-    public static void error(Throwable e, CompletableSubscriber s) {
+    public static void error(Throwable e, CompletableObserver s) {
         s.onSubscribe(INSTANCE);
         s.onError(e);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableEmpty.java
Patch:
@@ -18,7 +18,7 @@
 
 public final class CompletableEmpty extends Completable {
     @Override
-    public void subscribeActual(CompletableSubscriber s) {
+    public void subscribeActual(CompletableObserver s) {
         s.onSubscribe(EmptyDisposable.INSTANCE);
         s.onComplete();
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableError.java
Patch:
@@ -25,7 +25,7 @@ public CompletableError(Throwable error) {
     }
     
     @Override
-    protected void subscribeActual(CompletableSubscriber s) {
+    protected void subscribeActual(CompletableObserver s) {
         s.onSubscribe(EmptyDisposable.INSTANCE);
         s.onError(error);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java
Patch:
@@ -27,7 +27,7 @@ public CompletableErrorSupplier(Callable<? extends Throwable> errorSupplier) {
     }
 
     @Override
-    protected void subscribeActual(CompletableSubscriber s) {
+    protected void subscribeActual(CompletableObserver s) {
         s.onSubscribe(EmptyDisposable.INSTANCE);
         Throwable error;
         

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromCallable.java
Patch:
@@ -27,7 +27,7 @@ public CompletableFromCallable(Callable<?> callable) {
     }
     
     @Override
-    protected void subscribeActual(CompletableSubscriber s) {
+    protected void subscribeActual(CompletableObserver s) {
         Disposable d = Disposables.empty();
         s.onSubscribe(d);
         try {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromFlowable.java
Patch:
@@ -27,7 +27,7 @@ public CompletableFromFlowable(Publisher<T> flowable) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableSubscriber cs) {
+    protected void subscribeActual(final CompletableObserver cs) {
         flowable.subscribe(new Subscriber<T>() {
 
             @Override

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromObservable.java
Patch:
@@ -25,7 +25,7 @@ public CompletableFromObservable(ObservableConsumable<T> observable) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableSubscriber s) {
+    protected void subscribeActual(final CompletableObserver s) {
         observable.subscribe(new Observer<T>() {
 
             @Override

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromRunnable.java
Patch:
@@ -25,7 +25,7 @@ public CompletableFromRunnable(Runnable run) {
     }
 
     @Override
-    protected void subscribeActual(CompletableSubscriber s) {
+    protected void subscribeActual(CompletableObserver s) {
         Disposable d = Disposables.empty();
         s.onSubscribe(d);
         try {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -25,7 +25,7 @@ public CompletableFromSingle(SingleSource<T> single) {
     }
 
     @Override
-    protected void subscribeActual(final CompletableSubscriber s) {
+    protected void subscribeActual(final CompletableObserver s) {
         single.subscribe(new SingleObserver<T>() {
 
             @Override

File: src/main/java/io/reactivex/internal/operators/completable/CompletableNever.java
Patch:
@@ -19,7 +19,7 @@
 public final class CompletableNever extends Completable {
 
     @Override
-    protected void subscribeActual(CompletableSubscriber s) {
+    protected void subscribeActual(CompletableObserver s) {
         s.onSubscribe(EmptyDisposable.INSTANCE);
     }
 

File: src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java
Patch:
@@ -16,19 +16,19 @@
 import io.reactivex.*;
 
 public final class CompletableSubscribeOn extends Completable {
-    final CompletableConsumable source;
+    final CompletableSource source;
     
     final Scheduler scheduler;
     
-    public CompletableSubscribeOn(CompletableConsumable source, Scheduler scheduler) {
+    public CompletableSubscribeOn(CompletableSource source, Scheduler scheduler) {
         this.source = source;
         this.scheduler = scheduler;
     }
 
 
 
     @Override
-    protected void subscribeActual(final CompletableSubscriber s) {
+    protected void subscribeActual(final CompletableObserver s) {
      // FIXME cancellation of this schedule
         scheduler.scheduleDirect(new Runnable() {
             @Override

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTimer.java
Patch:
@@ -33,7 +33,7 @@ public CompletableTimer(long delay, TimeUnit unit, Scheduler scheduler) {
 
 
     @Override
-    protected void subscribeActual(final CompletableSubscriber s) {
+    protected void subscribeActual(final CompletableObserver s) {
         SerialDisposable sd = new SerialDisposable();
         s.onSubscribe(sd);
         if (!sd.isDisposed()) {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableToSingle.java
Patch:
@@ -19,13 +19,13 @@
 import io.reactivex.disposables.Disposable;
 
 public final class CompletableToSingle<T> extends Single<T> {
-    final CompletableConsumable source;
+    final CompletableSource source;
     
     final Callable<? extends T> completionValueSupplier;
     
     final T completionValue;
     
-    public CompletableToSingle(CompletableConsumable source, 
+    public CompletableToSingle(CompletableSource source,
             Callable<? extends T> completionValueSupplier, T completionValue) {
         this.source = source;
         this.completionValue = completionValue;
@@ -34,7 +34,7 @@ public CompletableToSingle(CompletableConsumable source,
 
     @Override
     protected void subscribeActual(final SingleObserver<? super T> s) {
-        source.subscribe(new CompletableSubscriber() {
+        source.subscribe(new CompletableObserver() {
 
             @Override
             public void onComplete() {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableWrapper.java
Patch:
@@ -17,14 +17,14 @@
 
 public final class CompletableWrapper extends Completable {
 
-    final CompletableConsumable onSubscribe;
+    final CompletableSource onSubscribe;
 
-    public CompletableWrapper(CompletableConsumable onSubscribe) {
+    public CompletableWrapper(CompletableSource onSubscribe) {
         this.onSubscribe = onSubscribe;
     }
     
     @Override
-    protected void subscribeActual(CompletableSubscriber s) {
+    protected void subscribeActual(CompletableObserver s) {
         onSubscribe.subscribe(s);
     }
 }

File: src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableObserver.java
Patch:
@@ -15,14 +15,14 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.CompletableSubscriber;
+import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class EmptyCompletableSubscriber 
+public final class EmptyCompletableObserver
 extends AtomicReference<Disposable>
-implements CompletableSubscriber, Disposable {
+implements CompletableObserver, Disposable {
 
     /** */
     private static final long serialVersionUID = -7545121636549663526L;

File: src/main/java/io/reactivex/internal/subscribers/completable/ObserverCompletableObserver.java
Patch:
@@ -16,10 +16,10 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 
-public final class ObserverCompletableSubscriber<T> implements CompletableSubscriber {
+public final class ObserverCompletableObserver<T> implements CompletableObserver {
     final Observer<? super T> observer;
 
-    public ObserverCompletableSubscriber(Observer<? super T> observer) {
+    public ObserverCompletableObserver(Observer<? super T> observer) {
         this.observer = observer;
     }
 

File: src/main/java/io/reactivex/internal/subscribers/completable/SubscriberCompletableObserver.java
Patch:
@@ -15,16 +15,16 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.CompletableSubscriber;
+import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class SubscriberCompletableSubscriber<T> implements CompletableSubscriber, Subscription {
+public final class SubscriberCompletableObserver<T> implements CompletableObserver, Subscription {
     final Subscriber<? super T> subscriber;
 
     Disposable d;
     
-    public SubscriberCompletableSubscriber(Subscriber<? super T> observer) {
+    public SubscriberCompletableObserver(Subscriber<? super T> observer) {
         this.subscriber = observer;
     }
 

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable.Operator;
+import io.reactivex.FlowableOperator;
 import io.reactivex.Optional;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
@@ -1642,7 +1642,7 @@ public void liftNull() {
     
     @Test(expected = NullPointerException.class)
     public void liftReturnsNull() {
-        just1.lift(new Operator<Object, Integer>() {
+        just1.lift(new FlowableOperator<Object, Integer>() {
             @Override
             public Subscriber<? super Integer> apply(Subscriber<? super Object> s) {
                 return null;

File: src/test/java/io/reactivex/flowable/FlowableTests.java
Patch:
@@ -26,7 +26,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable.Transformer;
+import io.reactivex.FlowableTransformer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
@@ -999,7 +999,7 @@ public void accept(List<Boolean> booleans) {
     @Test
     public void testCompose() {
         TestSubscriber<String> ts = new TestSubscriber<String>();
-        Flowable.just(1, 2, 3).compose(new Transformer<Integer, String>() {
+        Flowable.just(1, 2, 3).compose(new FlowableTransformer<Integer, String>() {
             @Override
             public Publisher<String> apply(Flowable<Integer> t1) {
                 return t1.map(new Function<Integer, String>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorResumeNextViaFunctionTest.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable.Operator;
+import io.reactivex.FlowableOperator;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
@@ -151,7 +151,7 @@ public Flowable<String> apply(Throwable t1) {
     @Ignore("Failed operator may leave the child subscriber in an inconsistent state which prevents further error delivery.")
     public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator() {
         TestSubscriber<String> ts = new TestSubscriber<String>();
-        Flowable.just(1).lift(new Operator<String, Integer>() {
+        Flowable.just(1).lift(new FlowableOperator<String, Integer>() {
 
             @Override
             public Subscriber<? super Integer> apply(Subscriber<? super String> t1) {
@@ -184,7 +184,7 @@ public Flowable<String> apply(Throwable t1) {
     @Ignore("A crashing operator may leave the downstream in an inconsistent state and not suitable for event delivery")
     public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperatorOnNext() {
         TestSubscriber<String> ts = new TestSubscriber<String>();
-        Flowable.just(1).lift(new Operator<String, Integer>() {
+        Flowable.just(1).lift(new FlowableOperator<String, Integer>() {
 
             @Override
             public Subscriber<? super Integer> apply(final Subscriber<? super String> t1) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable.Operator;
+import io.reactivex.FlowableOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.*;
@@ -218,7 +218,7 @@ public void onNext(Integer t) {
     @Test
     public void testSetProducerSynchronousRequest() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
-        Flowable.just(1, 2, 3).lift(new Operator<Integer, Integer>() {
+        Flowable.just(1, 2, 3).lift(new FlowableOperator<Integer, Integer>() {
 
             @Override
             public Subscriber<? super Integer> apply(final Subscriber<? super Integer> child) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmptyTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Flowable;
+import io.reactivex.FlowableOperator;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
@@ -98,7 +99,7 @@ public void subscribe(final Subscriber<? super Long> subscriber) {
 
         Flowable.<Long>empty()
                 .switchIfEmpty(withProducer)
-                .lift(new Flowable.Operator<Long, Long>() {
+                .lift(new FlowableOperator<Long, Long>() {
             @Override
             public Subscriber<? super Long> apply(final Subscriber<? super Long> child) {
                 return new DefaultSubscriber<Long>() {

File: src/main/java/io/reactivex/Completable.java
Patch:
@@ -310,7 +310,7 @@ public static Completable fromRunnable(final Runnable run) {
      * @throws NullPointerException if single is null
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Completable fromSingle(final SingleConsumable<T> single) {
+    public static <T> Completable fromSingle(final SingleSource<T> single) {
         Objects.requireNonNull(single, "single is null");
         return new CompletableFromSingle<T>(single);
     }

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -3152,9 +3152,9 @@ public void request(long n) {
 
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Single<T> toSingle() {
-        return Single.create(new SingleConsumable<T>() {
+        return Single.create(new SingleSource<T>() {
             @Override
-            public void subscribe(final SingleSubscriber<? super T> s) {
+            public void subscribe(final SingleObserver<? super T> s) {
                 Observable.this.subscribe(new Observer<T>() {
                     T last;
                     @Override

File: src/main/java/io/reactivex/SingleObserver.java
Patch:
@@ -15,11 +15,11 @@
 
 import io.reactivex.disposables.Disposable;
 
-public interface SingleSubscriber<T> {
+public interface SingleObserver<T> {
     
     void onSubscribe(Disposable d);
     
     void onSuccess(T value);
 
     void onError(Throwable e);
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -50,7 +50,7 @@ public static void error(Throwable e, CompletableSubscriber s) {
         s.onError(e);
     }
 
-    public static void error(Throwable e, SingleSubscriber<?> s) {
+    public static void error(Throwable e, SingleObserver<?> s) {
         s.onSubscribe(INSTANCE);
         s.onError(e);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableFromSingle.java
Patch:
@@ -18,15 +18,15 @@
 
 public final class CompletableFromSingle<T> extends Completable {
 
-    final SingleConsumable<T> single;
+    final SingleSource<T> single;
     
-    public CompletableFromSingle(SingleConsumable<T> single) {
+    public CompletableFromSingle(SingleSource<T> single) {
         this.single = single;
     }
 
     @Override
     protected void subscribeActual(final CompletableSubscriber s) {
-        single.subscribe(new SingleSubscriber<T>() {
+        single.subscribe(new SingleObserver<T>() {
 
             @Override
             public void onError(Throwable e) {

File: src/main/java/io/reactivex/internal/operators/completable/CompletableToSingle.java
Patch:
@@ -33,7 +33,7 @@ public CompletableToSingle(CompletableConsumable source,
     }
 
     @Override
-    protected void subscribeActual(final SingleSubscriber<? super T> s) {
+    protected void subscribeActual(final SingleObserver<? super T> s) {
         source.subscribe(new CompletableSubscriber() {
 
             @Override

File: src/main/java/io/reactivex/internal/operators/single/SingleAwait.java
Patch:
@@ -23,12 +23,12 @@
 public enum SingleAwait {
     ;
     
-    public static <T> T get(SingleConsumable<T> source) {
+    public static <T> T get(SingleSource<T> source) {
         final AtomicReference<T> valueRef = new AtomicReference<T>();
         final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();
         final CountDownLatch cdl = new CountDownLatch(1);
         
-        source.subscribe(new SingleSubscriber<T>() {
+        source.subscribe(new SingleObserver<T>() {
             @Override
             public void onError(Throwable e) {
                 errorRef.lazySet(e);

File: src/main/java/io/reactivex/internal/operators/single/SingleError.java
Patch:
@@ -27,7 +27,7 @@ public SingleError(Callable<? extends Throwable> errorSupplier) {
     }
 
     @Override
-    protected void subscribeActual(SingleSubscriber<? super T> s) {
+    protected void subscribeActual(SingleObserver<? super T> s) {
         Throwable error;
         
         try {

File: src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java
Patch:
@@ -27,7 +27,7 @@ public SingleFromCallable(Callable<? extends T> callable) {
     }
 
     @Override
-    protected void subscribeActual(SingleSubscriber<? super T> s) {
+    protected void subscribeActual(SingleObserver<? super T> s) {
 
         s.onSubscribe(EmptyDisposable.INSTANCE);
         try {

File: src/main/java/io/reactivex/internal/operators/single/SingleFromPublisher.java
Patch:
@@ -31,12 +31,12 @@ public SingleFromPublisher(Publisher<? extends T> publisher) {
     }
 
     @Override
-    protected void subscribeActual(final SingleSubscriber<? super T> s) {
+    protected void subscribeActual(final SingleObserver<? super T> s) {
         publisher.subscribe(new ToSingleSubscriber<T>(s));
     }
     
     static final class ToSingleSubscriber<T> implements Subscriber<T>, Disposable {
-        final SingleSubscriber<? super T> actual;
+        final SingleObserver<? super T> actual;
         
         Subscription s;
         
@@ -46,7 +46,7 @@ static final class ToSingleSubscriber<T> implements Subscriber<T>, Disposable {
         
         volatile boolean disposed;
 
-        public ToSingleSubscriber(SingleSubscriber<? super T> actual) {
+        public ToSingleSubscriber(SingleObserver<? super T> actual) {
             this.actual = actual;
         }
         

File: src/main/java/io/reactivex/internal/operators/single/SingleJust.java
Patch:
@@ -25,7 +25,7 @@ public SingleJust(T value) {
     }
 
     @Override
-    protected void subscribeActual(SingleSubscriber<? super T> s) {
+    protected void subscribeActual(SingleObserver<? super T> s) {
         s.onSubscribe(EmptyDisposable.INSTANCE);
         s.onSuccess(value);
     }

File: src/main/java/io/reactivex/internal/operators/single/SingleNever.java
Patch:
@@ -19,7 +19,7 @@
 public final class SingleNever<T> extends Single<T> {
 
     @Override
-    protected void subscribeActual(SingleSubscriber<? super T> s) {
+    protected void subscribeActual(SingleObserver<? super T> s) {
         s.onSubscribe(EmptyDisposable.INSTANCE);
     }
 

File: src/main/java/io/reactivex/internal/operators/single/SingleSubscribeOn.java
Patch:
@@ -16,17 +16,17 @@
 import io.reactivex.*;
 
 public final class SingleSubscribeOn<T> extends Single<T> {
-    final SingleConsumable<? extends T> source;
+    final SingleSource<? extends T> source;
 
     final Scheduler scheduler;
     
-    public SingleSubscribeOn(SingleConsumable<? extends T> source, Scheduler scheduler) {
+    public SingleSubscribeOn(SingleSource<? extends T> source, Scheduler scheduler) {
         this.source = source;
         this.scheduler = scheduler;
     }
 
     @Override
-    protected void subscribeActual(final SingleSubscriber<? super T> s) {
+    protected void subscribeActual(final SingleObserver<? super T> s) {
 
         // FIXME cancel schedule
         scheduler.scheduleDirect(new Runnable() {

File: src/main/java/io/reactivex/internal/operators/single/SingleTimer.java
Patch:
@@ -31,7 +31,7 @@ public SingleTimer(long delay, TimeUnit unit, Scheduler scheduler) {
     }
 
     @Override
-    protected void subscribeActual(final SingleSubscriber<? super Long> s) {
+    protected void subscribeActual(final SingleObserver<? super Long> s) {
         SerialDisposable sd = new SerialDisposable();
         
         s.onSubscribe(sd);

File: src/main/java/io/reactivex/internal/operators/single/SingleToObservable.java
Patch:
@@ -23,9 +23,9 @@
  */
 public final class SingleToObservable<T> extends Observable<T> {
     
-    final SingleConsumable<? extends T> source;
+    final SingleSource<? extends T> source;
     
-    public SingleToObservable(SingleConsumable<? extends T> source) {
+    public SingleToObservable(SingleSource<? extends T> source) {
         this.source = source;
     }
     
@@ -35,7 +35,7 @@ public void subscribeActual(final Observer<? super T> s) {
     }
     
     static final class SingleToObservableObserver<T> 
-    implements SingleSubscriber<T>, Disposable {
+    implements SingleObserver<T>, Disposable {
 
         final Observer<? super T> actual;
         

File: src/main/java/io/reactivex/internal/operators/single/SingleWrapper.java
Patch:
@@ -16,14 +16,14 @@
 import io.reactivex.*;
 
 public final class SingleWrapper<T> extends Single<T> {
-    final SingleConsumable<T> onSubscribe;
+    final SingleSource<T> onSubscribe;
 
-    public SingleWrapper(SingleConsumable<T> onSubscribe) {
+    public SingleWrapper(SingleSource<T> onSubscribe) {
         this.onSubscribe = onSubscribe;
     }
     
     @Override
-    protected void subscribeActual(SingleSubscriber<? super T> subscriber) {
+    protected void subscribeActual(SingleObserver<? super T> subscriber) {
         onSubscribe.subscribe(subscriber);
     }
 }

File: src/perf/java/io/reactivex/LatchedSingleObserver.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.disposables.Disposable;
 
-public final class LatchedSingleObserver<T> implements SingleSubscriber<T> {
+public final class LatchedSingleObserver<T> implements SingleObserver<T> {
     final CountDownLatch cdl;
     final Blackhole bh;
     public LatchedSingleObserver(Blackhole bh) {
@@ -40,4 +40,4 @@ public void onError(Throwable e) {
         e.printStackTrace();
         cdl.countDown();
     }
-}
\ No newline at end of file
+}

File: src/test/java/io/reactivex/completable/CompletableTest.java
Patch:
@@ -3869,7 +3869,7 @@ public void andThenSingleError() {
         Completable.error(e)
             .andThen(Single.<String>create(new Single<String>() {
                 @Override
-                public void subscribeActual(SingleSubscriber<? super String> s) {
+                public void subscribeActual(SingleObserver<? super String> s) {
                     hasRun.set(true);
                     s.onSuccess("foo");
                 }
@@ -4765,4 +4765,4 @@ public void run() {
         
         Assert.assertEquals(1, calls.get());
     }
-}
\ No newline at end of file
+}

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -862,7 +862,7 @@ public static <T> Observable<T> never() {
     @SchedulerSupport(SchedulerSupport.NONE)
     public static Observable<Integer> range(final int start, final int count) {
         if (count < 0) {
-            throw new IllegalArgumentException("count >= required but it was " + count);
+            throw new IllegalArgumentException("count >= 0 required but it was " + count);
         } else
         if (count == 0) {
             return empty();

File: src/main/java/io/reactivex/flowables/BlockingFlowable.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.internal.subscribers.flowable.*;
 import io.reactivex.internal.util.NotificationLite;
 import io.reactivex.plugins.RxJavaPlugins;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 public final class BlockingFlowable<T> implements Publisher<T>, Iterable<T> {
     final Publisher<? extends T> o;
@@ -373,7 +373,7 @@ public void subscribe(final Consumer<? super T> onNext, final Consumer<? super T
      * @param onComplete the callback action for the completion event.
      */
     public void subscribe(final Consumer<? super T> onNext, final Consumer<? super Throwable> onError, final Runnable onComplete) {
-        subscribe(new DefaultObserver<T>() {
+        subscribe(new DefaultSubscriber<T>() {
             boolean done;
             @Override
             public void onNext(T t) {

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
Patch:
@@ -19,7 +19,7 @@
 
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.util.NotificationLite;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 /**
  * Returns an Iterable that always returns the item most recently emitted by an Observable, or a
@@ -58,7 +58,7 @@ public Iterator<T> iterator() {
         };
     }
 
-    static final class MostRecentObserver<T> extends DefaultObserver<T> {
+    static final class MostRecentObserver<T> extends DefaultSubscriber<T> {
         volatile Object value;
         
         private MostRecentObserver(T value) {

File: src/main/java/io/reactivex/subscribers/DefaultSubscriber.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public abstract class DefaultObserver<T> implements Subscriber<T> {
+public abstract class DefaultSubscriber<T> implements Subscriber<T> {
     private Subscription s;
     @Override
     public final void onSubscribe(Subscription s) {

File: src/main/java/io/reactivex/subscribers/Subscribers.java
Patch:
@@ -274,7 +274,7 @@ public void onComplete() {
         };
     }
     
-    public static <T> DefaultObserver<T> create(
+    public static <T> DefaultSubscriber<T> create(
             final Consumer<? super T> onNext, 
             final Consumer<? super Throwable> onError, 
             final Runnable onComplete, 
@@ -283,7 +283,7 @@ public static <T> DefaultObserver<T> create(
         Objects.requireNonNull(onError, "onError is null");
         Objects.requireNonNull(onComplete, "onComplete is null");
         Objects.requireNonNull(onStart, "onStart is null");
-        return new DefaultObserver<T>() {
+        return new DefaultSubscriber<T>() {
             boolean done;
             @Override
             protected void onStart() {

File: src/perf/java/io/reactivex/InputWithIncrementingInteger.java
Patch:
@@ -20,7 +20,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.internal.subscriptions.EmptySubscription;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 /**
  * Exposes an Observable and Observer that increments n Integers and consumes them in a Blackhole.
@@ -83,7 +83,7 @@ public PerfSubscriber newLatchedObserver() {
     }
 
     public Subscriber<Integer> newSubscriber() {
-        return new DefaultObserver<Integer>() {
+        return new DefaultSubscriber<Integer>() {
 
             @Override
             public void onComplete() {

File: src/test/java/io/reactivex/flowable/FlowableConversionTest.java
Patch:
@@ -147,7 +147,7 @@ public Flowable<T> apply(final Publisher<T> onSubscribe) {
     
     @Test
     public void testConversionBetweenObservableClasses() {
-        final TestSubscriber<String> subscriber = new TestSubscriber<String>(new DefaultObserver<String>() {
+        final TestSubscriber<String> subscriber = new TestSubscriber<String>(new DefaultSubscriber<String>() {
 
             @Override
             public void onComplete() {
@@ -229,7 +229,7 @@ public Integer apply(Integer k) {
                         @Override
                         public ConcurrentLinkedQueue<Integer> apply(Flowable<Integer> onSubscribe) {
                             final ConcurrentLinkedQueue<Integer> q = new ConcurrentLinkedQueue<Integer>();
-                            onSubscribe.subscribe(new DefaultObserver<Integer>(){
+                            onSubscribe.subscribe(new DefaultSubscriber<Integer>(){
                                 @Override
                                 public void onComplete() {
                                     isFinished.set(true);

File: src/test/java/io/reactivex/flowable/FlowableErrorHandlingTests.java
Patch:
@@ -23,7 +23,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.schedulers.Schedulers;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 public class FlowableErrorHandlingTests {
 
@@ -36,7 +36,7 @@ public void testOnNextError() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();
         Flowable<Long> o = Flowable.interval(50, TimeUnit.MILLISECONDS);
-        Subscriber<Long> observer = new DefaultObserver<Long>() {
+        Subscriber<Long> observer = new DefaultSubscriber<Long>() {
 
             @Override
             public void onComplete() {
@@ -72,7 +72,7 @@ public void testOnNextErrorAcrossThread() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();
         Flowable<Long> o = Flowable.interval(50, TimeUnit.MILLISECONDS);
-        Subscriber<Long> observer = new DefaultObserver<Long>() {
+        Subscriber<Long> observer = new DefaultSubscriber<Long>() {
 
             @Override
             public void onComplete() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
Patch:
@@ -104,7 +104,7 @@ public void testAmb() {
                 Flowable2, Flowable3);
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         o.subscribe(observer);
 
         scheduler.advanceTimeBy(100000, TimeUnit.MILLISECONDS);
@@ -134,7 +134,7 @@ public void testAmb2() {
                 Flowable2, Flowable3);
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         o.subscribe(observer);
 
         scheduler.advanceTimeBy(100000, TimeUnit.MILLISECONDS);
@@ -162,7 +162,7 @@ public void testAmb3() {
                 Flowable2, Flowable3);
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         o.subscribe(observer);
 
         scheduler.advanceTimeBy(100000, TimeUnit.MILLISECONDS);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAsObservableTest.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.processors.PublishProcessor;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 public class FlowableAsObservableTest {
     @Test
@@ -54,7 +54,7 @@ public void testHidingError() {
         assertFalse(dst instanceof PublishProcessor);
         
         @SuppressWarnings("unchecked")
-        DefaultObserver<Object> o = mock(DefaultObserver.class);
+        DefaultSubscriber<Object> o = mock(DefaultSubscriber.class);
         
         dst.subscribe(o);
         

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
Patch:
@@ -960,7 +960,7 @@ public void cancel() {
                 });
             }
 
-        }).buffer(3, 2).subscribe(new DefaultObserver<List<Integer>>() {
+        }).buffer(3, 2).subscribe(new DefaultSubscriber<List<Integer>>() {
 
             @Override
             public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
Patch:
@@ -480,7 +480,7 @@ public List<Object> apply(Object[] args) {
 
             final CountDownLatch cdl = new CountDownLatch(1);
 
-            Subscriber<List<Object>> s = new DefaultObserver<List<Object>>() {
+            Subscriber<List<Object>> s = new DefaultSubscriber<List<Object>>() {
 
                 @Override
                 public void onNext(List<Object> t) {
@@ -811,7 +811,7 @@ public Integer apply(Object[] args) {
             }});
         //should get at least 4
         final CountDownLatch latch = new CountDownLatch(4);
-        o.subscribeOn(Schedulers.computation()).subscribe(new DefaultObserver<Integer>() {
+        o.subscribeOn(Schedulers.computation()).subscribe(new DefaultSubscriber<Integer>() {
             
             @Override
             public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -742,7 +742,7 @@ public Flowable<Integer> apply(Integer t) {
         int n = 5000;
         final AtomicInteger counter = new AtomicInteger();
 
-        Flowable.range(1, n).concatMap(func).subscribe(new DefaultObserver<Integer>() {
+        Flowable.range(1, n).concatMap(func).subscribe(new DefaultSubscriber<Integer>() {
             @Override
             public void onNext(Integer t) {
                 // Consume after sleep for 1 ms
@@ -778,7 +778,7 @@ public void testRequestOverflowDoesNotStallStream() {
         Flowable<Integer> o1 = Flowable.just(1,2,3);
         Flowable<Integer> o2 = Flowable.just(4,5,6);
         final AtomicBoolean completed = new AtomicBoolean(false);
-        o1.concatWith(o2).subscribe(new DefaultObserver<Integer>() {
+        o1.concatWith(o2).subscribe(new DefaultSubscriber<Integer>() {
 
             @Override
             public void onComplete() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDefaultIfEmptyTest.java
Patch:
@@ -61,7 +61,7 @@ public void testDefaultIfEmptyWithEmpty() {
     public void testEmptyButClientThrows() {
         final Subscriber<Integer> o = TestHelper.mockSubscriber();
         
-        Flowable.<Integer>empty().defaultIfEmpty(1).subscribe(new DefaultObserver<Integer>() {
+        Flowable.<Integer>empty().defaultIfEmpty(1).subscribe(new DefaultSubscriber<Integer>() {
             @Override
             public void onNext(Integer t) {
                 throw new TestException();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDeferTest.java
Patch:
@@ -23,7 +23,7 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 @SuppressWarnings("unchecked")
 public class FlowableDeferTest {
@@ -71,7 +71,7 @@ public void testDeferFunctionThrows() throws Exception {
         
         Flowable<String> result = Flowable.defer(factory);
         
-        DefaultObserver<String> o = mock(DefaultObserver.class);
+        DefaultSubscriber<String> o = mock(DefaultSubscriber.class);
         
         result.subscribe(o);
         

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.functions.LongConsumer;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 public class FlowableDoOnRequestTest {
 
@@ -61,7 +61,7 @@ public void accept(long n) {
                     }
                 })
                 //
-                .subscribe(new DefaultObserver<Integer>() {
+                .subscribe(new DefaultSubscriber<Integer>() {
 
                     @Override
                     public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
Patch:
@@ -173,7 +173,7 @@ public void testFromIterableRequestOverflow() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(expectedCount);
         
         o.subscribeOn(Schedulers.computation())
-        .subscribe(new DefaultObserver<Integer>() {
+        .subscribe(new DefaultSubscriber<Integer>() {
             
             @Override
             public void onStart() {
@@ -203,7 +203,7 @@ public void testFromEmptyIterableWhenZeroRequestedShouldStillEmitOnCompletedEage
         
         final AtomicBoolean completed = new AtomicBoolean(false);
         
-        Flowable.fromIterable(Collections.emptyList()).subscribe(new DefaultObserver<Object>() {
+        Flowable.fromIterable(Collections.emptyList()).subscribe(new DefaultSubscriber<Object>() {
 
             @Override
             public void onStart() {
@@ -297,7 +297,7 @@ public Integer next() {
                 };
             }
         };
-        Flowable.fromIterable(iterable).subscribe(new DefaultObserver<Integer>() {
+        Flowable.fromIterable(iterable).subscribe(new DefaultSubscriber<Integer>() {
 
             @Override
             public void onComplete() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
Patch:
@@ -113,7 +113,7 @@ public void accept(Integer t) {
                     }
                 })
                 //
-                .subscribe(new DefaultObserver<Integer>() {
+                .subscribe(new DefaultSubscriber<Integer>() {
 
                     @Override
                     public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java
Patch:
@@ -196,7 +196,7 @@ public void testUnsubscribeJustBeforeCompletionNotificationShouldPreventThatNoti
 //        ts.assertUnsubscribed();
     }
 
-    private static class TestObserver extends DefaultObserver<Try<Optional<String>>> {
+    private static class TestObserver extends DefaultSubscriber<Try<Optional<String>>> {
 
         boolean onCompleted = false;
         boolean onError = false;

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
Patch:
@@ -295,7 +295,7 @@ public void testSynchronousError() {
         final Flowable<Flowable<String>> o1 = Flowable.error(new RuntimeException("unit test"));
 
         final CountDownLatch latch = new CountDownLatch(1);
-        Flowable.mergeDelayError(o1).subscribe(new DefaultObserver<String>() {
+        Flowable.mergeDelayError(o1).subscribe(new DefaultSubscriber<String>() {
             @Override
             public void onComplete() {
                 fail("Expected onError path");
@@ -417,7 +417,7 @@ public void run() {
         }
     }
 
-    private static class CaptureObserver extends DefaultObserver<String> {
+    private static class CaptureObserver extends DefaultSubscriber<String> {
         volatile Throwable e;
 
         @Override
@@ -458,7 +458,7 @@ public void subscribe(Subscriber<? super Integer> t1) {
         final Subscriber<Integer> o = TestHelper.mockSubscriber();
         InOrder inOrder = inOrder(o);
         
-        result.unsafeSubscribe(new DefaultObserver<Integer>() {
+        result.unsafeSubscribe(new DefaultSubscriber<Integer>() {
             int calls;
             @Override
             public void onNext(Integer t) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
Patch:
@@ -230,7 +230,7 @@ public void testSynchronizationOfMultipleSequences() throws Throwable {
         final AtomicInteger totalCounter = new AtomicInteger();
 
         Flowable<String> m = Flowable.merge(Flowable.create(o1), Flowable.create(o2));
-        m.subscribe(new DefaultObserver<String>() {
+        m.subscribe(new DefaultSubscriber<String>() {
 
             @Override
             public void onComplete() {
@@ -1264,7 +1264,7 @@ public void testMergeRequestOverflow() throws InterruptedException {
                 .mergeWith(Flowable.fromIterable(Arrays.asList(3,4)));
         final int expectedCount = 4;
         final CountDownLatch latch = new CountDownLatch(expectedCount);
-        o.subscribeOn(Schedulers.computation()).subscribe(new DefaultObserver<Integer>() {
+        o.subscribeOn(Schedulers.computation()).subscribe(new DefaultSubscriber<Integer>() {
             
             @Override
             public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java
Patch:
@@ -44,7 +44,7 @@ public void testNoBackpressureSupport() {
     public void testFixBackpressureWithBuffer() throws InterruptedException {
         final CountDownLatch l1 = new CountDownLatch(100);
         final CountDownLatch l2 = new CountDownLatch(150);
-        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultObserver<Long>() {
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
 
             @Override
             protected void onStart() {
@@ -101,7 +101,7 @@ public void testFixBackpressureBufferZeroCapacity() throws InterruptedException
     public void testFixBackpressureBoundedBuffer() throws InterruptedException {
         final CountDownLatch l1 = new CountDownLatch(100);
         final CountDownLatch backpressureCallback = new CountDownLatch(1);
-        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultObserver<Long>() {
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
 
             @Override
             protected void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDropTest.java
Patch:
@@ -51,7 +51,7 @@ public void testWithObserveOn() throws InterruptedException {
     public void testFixBackpressureWithBuffer() throws InterruptedException {
         final CountDownLatch l1 = new CountDownLatch(100);
         final CountDownLatch l2 = new CountDownLatch(150);
-        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultObserver<Long>() {
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {
 
             @Override
             protected void onStart() {
@@ -93,7 +93,7 @@ public void onNext(Long t) {
     public void testRequestOverflow() throws InterruptedException {
         final AtomicInteger count = new AtomicInteger();
         int n = 10;
-        range(n).onBackpressureDrop().subscribe(new DefaultObserver<Long>() {
+        range(n).onBackpressureDrop().subscribe(new DefaultSubscriber<Long>() {
 
             @Override
             public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorResumeNextViaFunctionTest.java
Patch:
@@ -126,7 +126,7 @@ public Flowable<String> apply(Throwable t1) {
         Flowable<String> observable = Flowable.create(w).onErrorResumeNext(resume);
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         observable.subscribe(observer);
 
         try {
@@ -258,7 +258,7 @@ public Flowable<String> apply(Throwable t1) {
         });
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         
         TestSubscriber<String> ts = new TestSubscriber<String>(observer, Long.MAX_VALUE);
         observable.subscribe(ts);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorResumeNextViaObservableTest.java
Patch:
@@ -134,7 +134,7 @@ public void subscribe(Subscriber<? super String> t1) {
         Flowable<String> observable = testObservable.subscribeOn(Schedulers.io()).onErrorResumeNext(resume);
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         TestSubscriber<String> ts = new TestSubscriber<String>(observer, Long.MAX_VALUE);
         observable.subscribe(ts);
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java
Patch:
@@ -48,7 +48,7 @@ public String apply(Throwable e) {
         });
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         observable.subscribe(observer);
 
         try {
@@ -84,7 +84,7 @@ public String apply(Throwable e) {
         });
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         observable.subscribe(observer);
 
         try {
@@ -129,7 +129,7 @@ public String apply(Throwable t1) {
         });
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<String> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<String> observer = mock(DefaultSubscriber.class);
         TestSubscriber<String> ts = new TestSubscriber<String>(observer, Long.MAX_VALUE);
         observable.subscribe(ts);
         ts.awaitTerminalEvent();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
Patch:
@@ -196,7 +196,7 @@ public void testWithBackpressureRequestWayMore() {
     public void testRequestOverflow() {
         final AtomicInteger count = new AtomicInteger();
         int n = 10;
-        Flowable.range(1, n).subscribe(new DefaultObserver<Integer>() {
+        Flowable.range(1, n).subscribe(new DefaultSubscriber<Integer>() {
 
             @Override
             public void onStart() {
@@ -224,7 +224,7 @@ public void onNext(Integer t) {
     @Test
     public void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() {
         final AtomicBoolean completed = new AtomicBoolean(false);
-        Flowable.range(1, 0).subscribe(new DefaultObserver<Integer>() {
+        Flowable.range(1, 0).subscribe(new DefaultSubscriber<Integer>() {
 
             @Override
             public void onStart() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -613,7 +613,7 @@ public void run() {
     }
 
     /** Observer for listener on seperate thread */
-    static final class AsyncObserver<T> extends DefaultObserver<T> {
+    static final class AsyncObserver<T> extends DefaultSubscriber<T> {
 
         protected CountDownLatch latch = new CountDownLatch(1);
 
@@ -660,7 +660,7 @@ public void onNext(T v) {
     public void testUnsubscribeAfterError() {
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<Long> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<Long> observer = mock(DefaultSubscriber.class);
 
         // Observable that always fails after 100ms
         SlowObservable so = new SlowObservable(100, 0);
@@ -685,7 +685,7 @@ public void testUnsubscribeAfterError() {
     public void testTimeoutWithRetry() {
 
         @SuppressWarnings("unchecked")
-        DefaultObserver<Long> observer = mock(DefaultObserver.class);
+        DefaultSubscriber<Long> observer = mock(DefaultSubscriber.class);
 
         // Observable that sends every 100ms (timeout fails instead)
         SlowObservable so = new SlowObservable(100, 10);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableScanTest.java
Patch:
@@ -142,7 +142,7 @@ public Integer apply(Integer t1, Integer t2) {
                     }
 
                 })
-                .subscribe(new DefaultObserver<Integer>() {
+                .subscribe(new DefaultSubscriber<Integer>() {
 
                     @Override
                     public void onStart() {
@@ -183,7 +183,7 @@ public Integer apply(Integer t1, Integer t2) {
                     }
 
                 })
-                .subscribe(new DefaultObserver<Integer>() {
+                .subscribe(new DefaultSubscriber<Integer>() {
 
                     @Override
                     public void onStart() {
@@ -224,7 +224,7 @@ public Integer apply(Integer t1, Integer t2) {
                     }
 
                 })
-                .subscribe(new DefaultObserver<Integer>() {
+                .subscribe(new DefaultSubscriber<Integer>() {
 
                     @Override
                     public void onComplete() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java
Patch:
@@ -187,7 +187,7 @@ public void subscribe(Subscriber<? super Integer> sub) {
     @Test
     public void testBackpressureReschedulesCorrectly() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(10);
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(new DefaultObserver<Integer>() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(new DefaultSubscriber<Integer>() {
 
             @Override
             public void onComplete() {
@@ -238,7 +238,7 @@ public void cancel() {
                     }
 
                 });
-                Subscriber<Integer> parent = new DefaultObserver<Integer>() {
+                Subscriber<Integer> parent = new DefaultSubscriber<Integer>() {
 
                     @Override
                     public void onComplete() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmptyTest.java
Patch:
@@ -101,7 +101,7 @@ public void subscribe(final Subscriber<? super Long> subscriber) {
                 .lift(new Flowable.Operator<Long, Long>() {
             @Override
             public Subscriber<? super Long> apply(final Subscriber<? super Long> child) {
-                return new DefaultObserver<Long>() {
+                return new DefaultSubscriber<Long>() {
                     @Override
                     public void onComplete() {
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
Patch:
@@ -448,7 +448,7 @@ public void testBackpressure() {
 
         
         final TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
-        Flowable.switchOnNext(o).subscribe(new DefaultObserver<String>() {
+        Flowable.switchOnNext(o).subscribe(new DefaultSubscriber<String>() {
 
             private int requested = 0;
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastOneTest.java
Patch:
@@ -97,7 +97,7 @@ public void accept(Integer t) {
         assertEquals(0L, count);
     }
     
-    private static class MySubscriber<T> extends DefaultObserver<T> {
+    private static class MySubscriber<T> extends DefaultSubscriber<T> {
 
         private long initialRequest;
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java
Patch:
@@ -225,7 +225,7 @@ public void testWithMultipleStaggeredSubscribersAndPublish() {
     public void testOnceObserverThrows() {
         Flowable<Long> source = Flowable.timer(100, TimeUnit.MILLISECONDS, scheduler);
         
-        source.safeSubscribe(new DefaultObserver<Long>() {
+        source.safeSubscribe(new DefaultSubscriber<Long>() {
 
             @Override
             public void onNext(Long t) {
@@ -255,7 +255,7 @@ public void testPeriodicObserverThrows() {
         
         InOrder inOrder = inOrder(observer);
         
-        source.safeSubscribe(new DefaultObserver<Long>() {
+        source.safeSubscribe(new DefaultSubscriber<Long>() {
 
             @Override
             public void onNext(Long t) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java
Patch:
@@ -205,14 +205,14 @@ public void testBackpressureOuter() {
         
         final Subscriber<Integer> o = TestHelper.mockSubscriber();
         
-        source.subscribe(new DefaultObserver<Flowable<Integer>>() {
+        source.subscribe(new DefaultSubscriber<Flowable<Integer>>() {
             @Override
             public void onStart() {
                 request(1);
             }
             @Override
             public void onNext(Flowable<Integer> t) {
-                t.subscribe(new DefaultObserver<Integer>() {
+                t.subscribe(new DefaultSubscriber<Integer>() {
                     @Override
                     public void onNext(Integer t) {
                         list.add(t);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithStartEndObservableTest.java
Patch:
@@ -170,7 +170,7 @@ private Consumer<Flowable<String>> observeWindow(final List<String> list, final
         return new Consumer<Flowable<String>>() {
             @Override
             public void accept(Flowable<String> stringObservable) {
-                stringObservable.subscribe(new DefaultObserver<String>() {
+                stringObservable.subscribe(new DefaultSubscriber<String>() {
                     @Override
                     public void onComplete() {
                         lists.add(new ArrayList<String>(list));

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
Patch:
@@ -134,7 +134,7 @@ private <T> Consumer<Flowable<T>> observeWindow(final List<T> list, final List<L
         return new Consumer<Flowable<T>>() {
             @Override
             public void accept(Flowable<T> stringObservable) {
-                stringObservable.subscribe(new DefaultObserver<T>() {
+                stringObservable.subscribe(new DefaultSubscriber<T>() {
                     @Override
                     public void onComplete() {
                         lists.add(new ArrayList<T>(list));

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
Patch:
@@ -730,7 +730,7 @@ public void testStartWithOnCompletedTwice() {
                     public Integer apply(Integer a, Integer b) {
                         return a + b;
                     }
-                }).subscribe(new DefaultObserver<Integer>() {
+                }).subscribe(new DefaultSubscriber<Integer>() {
 
             @Override
             public void onComplete() {
@@ -819,7 +819,7 @@ public String apply(Integer a, Integer b) {
                 });
 
         final ArrayList<String> list = new ArrayList<String>();
-        os.subscribe(new DefaultObserver<String>() {
+        os.subscribe(new DefaultSubscriber<String>() {
 
             @Override
             public void onComplete() {

File: src/test/java/io/reactivex/processors/BehaviorProcessorTest.java
Patch:
@@ -252,7 +252,7 @@ public Flowable<String> apply(String t1) {
                         return Flowable.just(t1 + ", " + t1);
                     }
                 })
-                .subscribe(new DefaultObserver<String>() {
+                .subscribe(new DefaultSubscriber<String>() {
                     @Override
                     public void onNext(String t) {
                         o.onNext(t);
@@ -426,7 +426,7 @@ public void run() {
                 final AtomicReference<Object> o = new AtomicReference<Object>();
                 
                 rs.subscribeOn(s).observeOn(Schedulers.io())
-                .subscribe(new DefaultObserver<Object>() {
+                .subscribe(new DefaultSubscriber<Object>() {
     
                     @Override
                     public void onComplete() {

File: src/test/java/io/reactivex/processors/PublishProcessorTest.java
Patch:
@@ -307,7 +307,7 @@ public Flowable<String> apply(String t1) {
                         return Flowable.just(t1 + ", " + t1);
                     }
                 })
-                .subscribe(new DefaultObserver<String>() {
+                .subscribe(new DefaultSubscriber<String>() {
                     @Override
                     public void onNext(String t) {
                         o.onNext(t);

File: src/test/java/io/reactivex/processors/ReplayProcessorBoundedConcurrencyTest.java
Patch:
@@ -61,7 +61,7 @@ public void subscribe(Subscriber<? super Long> o) {
 
             @Override
             public void run() {
-                Subscriber<Long> slow = new DefaultObserver<Long>() {
+                Subscriber<Long> slow = new DefaultSubscriber<Long>() {
 
                     @Override
                     public void onComplete() {
@@ -102,7 +102,7 @@ public void onNext(Long args) {
             @Override
             public void run() {
                 final CountDownLatch fastLatch = new CountDownLatch(1);
-                Subscriber<Long> fast = new DefaultObserver<Long>() {
+                Subscriber<Long> fast = new DefaultSubscriber<Long>() {
 
                     @Override
                     public void onComplete() {
@@ -355,7 +355,7 @@ public void run() {
                 .subscribeOn(s)
                 .observeOn(Schedulers.io())
 //                .doOnNext(e -> System.out.println(">>> " + j))
-                .subscribe(new DefaultObserver<Object>() {
+                .subscribe(new DefaultSubscriber<Object>() {
     
                     @Override
                     protected void onStart() {

File: src/test/java/io/reactivex/processors/ReplayProcessorConcurrencyTest.java
Patch:
@@ -61,7 +61,7 @@ public void subscribe(Subscriber<? super Long> o) {
 
             @Override
             public void run() {
-                Subscriber<Long> slow = new DefaultObserver<Long>() {
+                Subscriber<Long> slow = new DefaultSubscriber<Long>() {
 
                     @Override
                     public void onComplete() {
@@ -102,7 +102,7 @@ public void onNext(Long args) {
             @Override
             public void run() {
                 final CountDownLatch fastLatch = new CountDownLatch(1);
-                Subscriber<Long> fast = new DefaultObserver<Long>() {
+                Subscriber<Long> fast = new DefaultSubscriber<Long>() {
 
                     @Override
                     public void onComplete() {
@@ -347,7 +347,7 @@ public void run() {
                 final AtomicReference<Object> o = new AtomicReference<Object>();
                 
                 rs.subscribeOn(s).observeOn(Schedulers.io())
-                .subscribe(new DefaultObserver<Object>() {
+                .subscribe(new DefaultSubscriber<Object>() {
     
                     @Override
                     public void onComplete() {

File: src/test/java/io/reactivex/schedulers/AbstractSchedulerConcurrencyTests.java
Patch:
@@ -55,7 +55,7 @@ public Long apply(Long aLong) {
                 })
                 .subscribeOn(getScheduler())
                 .observeOn(getScheduler())
-                .subscribe(new DefaultObserver<Long>() {
+                .subscribe(new DefaultSubscriber<Long>() {
                     @Override
                     public void onComplete() {
                         System.out.println("--- completed");

File: src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.*;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 /**
  * Base tests for all schedulers including Immediate/Current.
@@ -461,7 +461,7 @@ public void subscribe(Subscriber<? super String> observer) {
      * 
      * @param <T>
      */
-    private static class ConcurrentObserverValidator<T> extends DefaultObserver<T> {
+    private static class ConcurrentObserverValidator<T> extends DefaultSubscriber<T> {
 
         final AtomicInteger concurrentCounter = new AtomicInteger();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();

File: src/test/java/io/reactivex/schedulers/SchedulerTests.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.*;
 
 import io.reactivex.*;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.DefaultSubscriber;
 
 final class SchedulerTests {
     private SchedulerTests() {
@@ -110,7 +110,7 @@ public void uncaughtException(Thread t, Throwable e) {
         }
     }
 
-    private static final class CapturingObserver<T> extends DefaultObserver<T> {
+    private static final class CapturingObserver<T> extends DefaultSubscriber<T> {
         CountDownLatch completed = new CountDownLatch(1);
         int errorCount = 0;
         int nextCount = 0;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableLift.java
Patch:
@@ -27,11 +27,11 @@
  */
 public final class ObservableLift<R, T> extends Observable<R> {
     /** The actual operator. */
-    final NbpOperator<? extends R, ? super T> operator;
+    final Operator<? extends R, ? super T> operator;
     /** The source publisher. */
     final ObservableConsumable<? extends T> source;
     
-    public ObservableLift(ObservableConsumable<? extends T> source, NbpOperator<? extends R, ? super T> operator) {
+    public ObservableLift(ObservableConsumable<? extends T> source, Operator<? extends R, ? super T> operator) {
         this.source = source;
         this.operator = operator;
     }
@@ -40,7 +40,7 @@ public ObservableLift(ObservableConsumable<? extends T> source, NbpOperator<? ex
      * Returns the operator of this lift publisher.
      * @return the operator of this lift publisher
      */
-    public NbpOperator<? extends R, ? super T> operator() {
+    public Operator<? extends R, ? super T> operator() {
         return operator;
     }
     

File: src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorResumeNextViaFunctionTest.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.Subscription;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOperator;
+import io.reactivex.Observable.Operator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -152,7 +152,7 @@ public Observable<String> apply(Throwable t1) {
     @Ignore("Failed operator may leave the child NbpSubscriber in an inconsistent state which prevents further error delivery.")
     public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator() {
         TestObserver<String> ts = new TestObserver<String>();
-        Observable.just(1).lift(new NbpOperator<String, Integer>() {
+        Observable.just(1).lift(new Operator<String, Integer>() {
 
             @Override
             public Observer<? super Integer> apply(Observer<? super String> t1) {
@@ -185,7 +185,7 @@ public Observable<String> apply(Throwable t1) {
     @Ignore("A crashing operator may leave the downstream in an inconsistent state and not suitable for event delivery")
     public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperatorOnNext() {
         TestObserver<String> ts = new TestObserver<String>();
-        Observable.just(1).lift(new NbpOperator<String, Integer>() {
+        Observable.just(1).lift(new Operator<String, Integer>() {
 
             @Override
             public Observer<? super Integer> apply(final Observer<? super String> t1) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchIfEmptyTest.java
Patch:
@@ -67,7 +67,7 @@ public void subscribe(final Observer<? super Long> NbpSubscriber) {
 
         Observable.<Long>empty()
                 .switchIfEmpty(withProducer)
-                .lift(new Observable.NbpOperator<Long, Long>() {
+                .lift(new Observable.Operator<Long, Long>() {
             @Override
             public Observer<? super Long> apply(final Observer<? super Long> child) {
                 return new DefaultObserver<Long>() {

File: src/test/java/io/reactivex/observable/ObservableCovarianceTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpTransformer;
+import io.reactivex.Observable.Transformer;
 import io.reactivex.functions.*;
 import io.reactivex.observables.GroupedObservable;
 import io.reactivex.observers.TestObserver;
@@ -207,7 +207,7 @@ public Observable<Movie> apply(List<List<Movie>> listOfLists) {
         }
     };
     
-    static NbpTransformer<List<Movie>, Movie> deltaTransformer = new NbpTransformer<List<Movie>, Movie>() {
+    static Transformer<List<Movie>, Movie> deltaTransformer = new Transformer<List<Movie>, Movie>() {
         @Override
         public Observable<Movie> apply(Observable<List<Movie>> movieList) {
             return movieList

File: src/test/java/io/reactivex/observable/ObservableNullTests.java
Patch:
@@ -21,7 +21,7 @@
 
 import io.reactivex.*;
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOperator;
+import io.reactivex.Observable.Operator;
 import io.reactivex.Observer;
 import io.reactivex.Optional;
 import io.reactivex.disposables.Disposable;
@@ -1618,7 +1618,7 @@ public void liftNull() {
     
     @Test(expected = NullPointerException.class)
     public void liftReturnsNull() {
-        just1.lift(new NbpOperator<Object, Integer>() {
+        just1.lift(new Operator<Object, Integer>() {
             @Override
             public Observer<? super Integer> apply(Observer<? super Object> s) {
                 return null;

File: src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.junit.Test;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOperator;
+import io.reactivex.Observable.Operator;
 import io.reactivex.observers.DefaultObserver;
 
 public class ObservableSubscriberTest {
@@ -85,7 +85,7 @@ public void onNext(Integer t) {
     @Test
     public void testOnStartCalledOnceViaLift() {
         final AtomicInteger c = new AtomicInteger();
-        Observable.just(1, 2, 3, 4).lift(new NbpOperator<Integer, Integer>() {
+        Observable.just(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {
 
             @Override
             public Observer<? super Integer> apply(final Observer<? super Integer> child) {

File: src/main/java/io/reactivex/functions/BiConsumer.java
Patch:
@@ -15,5 +15,5 @@
 
 public interface BiConsumer<T1, T2> {
     
-    void accept(T1 t1, T2 t2);
+    void accept(T1 t1, T2 t2) throws Exception;
 }

File: src/main/java/io/reactivex/functions/BiFunction.java
Patch:
@@ -15,5 +15,5 @@
 
 public interface BiFunction<T1, T2, R> {
     
-    R apply(T1 t1, T2 t2);
+    R apply(T1 t1, T2 t2) throws Exception;
 }

File: src/main/java/io/reactivex/functions/BiPredicate.java
Patch:
@@ -15,5 +15,5 @@
 
 public interface BiPredicate<T1, T2> {
     
-    boolean test(T1 t1, T2 t2);
+    boolean test(T1 t1, T2 t2) throws Exception;
 }

File: src/main/java/io/reactivex/functions/BooleanSupplier.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface BooleanSupplier {
-    boolean getAsBoolean(); // NOPMD
+    boolean getAsBoolean() throws Exception; // NOPMD
 }

File: src/main/java/io/reactivex/functions/Consumer.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Consumer<T> {
-    void accept(T t);
+    void accept(T t) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function<T, R> {
-    R apply(T t);
+    R apply(T t) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function3.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function3<T1, T2, T3, R> {
-    R apply(T1 t1, T2 t2, T3 t3);
+    R apply(T1 t1, T2 t2, T3 t3) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function4.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function4<T1, T2, T3, T4, R> {
-    R apply(T1 t1, T2 t2, T3 t3, T4 t4);
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function5.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function5<T1, T2, T3, T4, T5, R> {
-    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function6.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function6<T1, T2, T3, T4, T5, T6, R> {
-    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function7.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {
-    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function8.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
-    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Function9.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
-    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
+    R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) throws Exception;
 }

File: src/main/java/io/reactivex/functions/IntFunction.java
Patch:
@@ -13,5 +13,5 @@
 package io.reactivex.functions;
 
 public interface IntFunction<T> {
-    T apply(int i);
+    T apply(int i) throws Exception;
 }

File: src/main/java/io/reactivex/functions/LongConsumer.java
Patch:
@@ -13,5 +13,5 @@
 package io.reactivex.functions;
 
 public interface LongConsumer {
-    void accept(long t);
+    void accept(long t) throws Exception;
 }

File: src/main/java/io/reactivex/functions/Predicate.java
Patch:
@@ -14,5 +14,5 @@
 package io.reactivex.functions;
 
 public interface Predicate<T> {
-    boolean test(T t);
+    boolean test(T t) throws Exception;
 }

File: src/main/java/io/reactivex/internal/disposables/NbpFullArbiter.java
Patch:
@@ -112,13 +112,11 @@ void drain() {
         for (;;) {
             
             for (;;) {
-                Object o = q.peek();
-                
+                Object o = q.poll();
                 if (o == null) {
                     break;
                 }
                 
-                q.poll();
                 Object v = q.poll();
                 
                 if (o != s) {

File: src/main/java/io/reactivex/internal/fuseable/QueueDisposable.java
Patch:
@@ -51,7 +51,7 @@
  * </ul>
  * @param <T> the value type transmitted through the queue
  */
-public interface QueueDisposable<T> extends Queue<T>, Disposable {
+public interface QueueDisposable<T> extends SimpleQueue<T>, Disposable {
     /**
      * Returned by the {@link #requestFusion(int)} if the upstream doesn't support
      * the requested mode.

File: src/main/java/io/reactivex/internal/fuseable/QueueSubscription.java
Patch:
@@ -53,7 +53,7 @@
  * </ul>
  * @param <T> the value type transmitted through the queue
  */
-public interface QueueSubscription<T> extends Queue<T>, Subscription {
+public interface QueueSubscription<T> extends SimpleQueue<T>, Subscription {
     /**
      * Returned by the {@link #requestFusion(int)} if the upstream doesn't support
      * the requested mode.

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorArray.java
Patch:
@@ -13,12 +13,12 @@
 
 package io.reactivex.internal.operators.completable;
 
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
+import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.queue.MpscLinkedQueue;
 
 public final class CompletableMergeDelayErrorArray extends Completable {
     final CompletableConsumable[] sources;
@@ -32,7 +32,7 @@ public void subscribeActual(final CompletableSubscriber s) {
         final CompositeDisposable set = new CompositeDisposable();
         final AtomicInteger wip = new AtomicInteger(sources.length + 1);
         
-        final Queue<Throwable> q = new ConcurrentLinkedQueue<Throwable>();
+        final SimpleQueue<Throwable> q = new MpscLinkedQueue<Throwable>();
         
         s.onSubscribe(set);
         

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java
Patch:
@@ -13,11 +13,12 @@
 
 package io.reactivex.internal.operators.completable;
 
-import java.util.*;
+import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
+import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 
 public final class CompletableMergeDelayErrorIterable extends Completable {
@@ -49,7 +50,7 @@ public void subscribeActual(final CompletableSubscriber s) {
 
         final AtomicInteger wip = new AtomicInteger(1);
         
-        final Queue<Throwable> queue = new MpscLinkedQueue<Throwable>();
+        final SimpleQueue<Throwable> queue = new MpscLinkedQueue<Throwable>();
 
         for (;;) {
             if (set.isDisposed()) {

File: src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
Patch:
@@ -31,7 +31,7 @@ public final class BlockingFlowableIterator<T>
     /** */
     private static final long serialVersionUID = 6695226475494099826L;
 
-    final Queue<T> queue;
+    final SpscLinkedArrayQueue<T> queue;
     
     final long batchSize;
     

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -145,7 +145,7 @@ public void subscribeActual(Subscriber<? super R> s) {
         if (n == 1) {
             new FlowableMap<T, R>((Publisher<T>)a[0], new Function<T, R>() {
                 @Override
-                public R apply(T t) {
+                public R apply(T t) throws Exception {
                     return combiner.apply(new Object[] { t });
                 }
             }).subscribe(s);
@@ -425,7 +425,7 @@ void drain() {
             }
         }
         
-        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, Queue<?> q) {
+        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, SpscLinkedArrayQueue<?> q) {
             if (cancelled) {
                 cancelAll();
                 q.clear();
@@ -482,7 +482,7 @@ public int requestFusion(int requestedMode) {
         
         @SuppressWarnings("unchecked")
         @Override
-        public R poll() {
+        public R poll() throws Exception {
             Object e = queue.poll();
             if (e == null) {
                 return null;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java
Patch:
@@ -12,15 +12,14 @@
  */
 package io.reactivex.internal.operators.flowable;
 
-import java.util.Queue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.*;
 
 import org.reactivestreams.*;
 
 import io.reactivex.functions.Function;
 import io.reactivex.internal.functions.Objects;
-import io.reactivex.internal.fuseable.QueueSubscription;
+import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.Exceptions;
@@ -99,7 +98,7 @@ static abstract class BaseConcatMapSubscriber<T, R>
 
         int consumed;
         
-        Queue<T> queue;
+        SimpleQueue<T> queue;
         
         volatile boolean done;
         

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
Patch:
@@ -97,7 +97,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public T poll() {
+        public T poll() throws Exception {
             for (;;) {
                 T v = qs.poll();
                 if (v == null) {
@@ -108,6 +108,7 @@ public T poll() {
                     last = v;
                     return v;
                 }
+                
                 if (!comparer.test(last, v)) {
                     last = v;
                     return v;
@@ -176,7 +177,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public T poll() {
+        public T poll() throws Exception {
             for (;;) {
                 T v = qs.poll();
                 if (v == null) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -146,7 +146,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public T poll() {
+        public T poll() throws Exception {
             T v = qs.poll();
             
             if (v != null) {
@@ -280,7 +280,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public T poll() {
+        public T poll() throws Exception {
             T v = qs.poll();
             
             if (v != null) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -80,7 +80,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public T poll() {
+        public T poll() throws Exception {
             QueueSubscription<T> qs = this.qs;
             Predicate<? super T> f = filter;
             
@@ -144,7 +144,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public T poll() {
+        public T poll() throws Exception {
             QueueSubscription<T> qs = this.qs;
             Predicate<? super T> f = filter;
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java
Patch:
@@ -26,6 +26,7 @@
 import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
@@ -179,7 +180,7 @@ void errorAll(Subscriber<?> a) {
             a.onError(ex);
         }
         
-        void fail(Throwable exc, Subscriber<?> a, Queue<?> q) {
+        void fail(Throwable exc, Subscriber<?> a, SimpleQueue<?> q) {
             Exceptions.throwIfFatal(exc);
             Exceptions.addThrowable(error, exc);
             q.clear();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableJoin.java
Patch:
@@ -9,6 +9,7 @@
 import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.operators.flowable.FlowableGroupJoin.*;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
@@ -145,7 +146,7 @@ void errorAll(Subscriber<?> a) {
             a.onError(ex);
         }
         
-        void fail(Throwable exc, Subscriber<?> a, Queue<?> q) {
+        void fail(Throwable exc, Subscriber<?> a, SimpleQueue<?> q) {
             Exceptions.throwIfFatal(exc);
             Exceptions.addThrowable(error, exc);
             q.clear();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
Patch:
@@ -74,7 +74,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public U poll() {
+        public U poll() throws Exception {
             T t = qs.poll();
             return t != null ? nullCheck(mapper.apply(t), "The mapper function returned a null value.") : null;
         }
@@ -137,7 +137,7 @@ public int requestFusion(int mode) {
         }
 
         @Override
-        public U poll() {
+        public U poll() throws Exception {
             T t = qs.poll();
             return t != null ? nullCheck(mapper.apply(t), "The mapper function returned a null value.") : null;
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindow.java
Patch:
@@ -325,7 +325,7 @@ static final class WindowOverlapSubscriber<T>
 
         final Subscriber<? super Flowable<T>> actual;
 
-        final Queue<UnicastProcessor<T>> queue;
+        final SpscLinkedArrayQueue<UnicastProcessor<T>> queue;
         
         final long size;
         
@@ -460,7 +460,7 @@ void drain() {
             }
             
             final Subscriber<? super Flowable<T>> a = actual;
-            final Queue<UnicastProcessor<T>> q = queue;
+            final SpscLinkedArrayQueue<UnicastProcessor<T>> q = queue;
             int missed = 1;
             
             for (;;) {
@@ -505,7 +505,7 @@ void drain() {
             }
         }
         
-        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, Queue<?> q) {
+        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, SpscLinkedArrayQueue<?> q) {
             if (cancelled) {
                 q.clear();
                 return true;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
Patch:
@@ -12,15 +12,14 @@
  */
 package io.reactivex.internal.operators.observable;
 
-import java.util.Queue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.functions.Objects;
-import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.util.Exceptions;
 import io.reactivex.observers.SerializedObserver;
@@ -49,7 +48,7 @@ static final class SourceSubscriber<T, U> extends AtomicInteger implements Obser
         final Observer<U> inner;
         final int bufferSize;
 
-        Queue<T> queue;
+        SimpleQueue<T> queue;
 
         Disposable s;
         

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java
Patch:
@@ -213,7 +213,7 @@ static final class State<T, K> extends AtomicInteger implements Disposable, Obse
         private static final long serialVersionUID = -3852313036005250360L;
 
         final K key;
-        final Queue<T> queue;
+        final SpscLinkedArrayQueue<T> queue;
         final GroupBySubscriber<?, K, T> parent;
         final boolean delayError;
         
@@ -282,7 +282,7 @@ void drain() {
             }
             int missed = 1;
             
-            final Queue<T> q = queue;
+            final SpscLinkedArrayQueue<T> q = queue;
             final boolean delayError = this.delayError;
             Observer<? super T> a = actual.get();
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/observable/ObservableGroupJoin.java
Patch:
@@ -177,7 +177,7 @@ void errorAll(Observer<?> a) {
             a.onError(ex);
         }
         
-        void fail(Throwable exc, Observer<?> a, Queue<?> q) {
+        void fail(Throwable exc, Observer<?> a, SpscLinkedArrayQueue<?> q) {
             Exceptions.throwIfFatal(exc);
             Exceptions.addThrowable(error, exc);
             q.clear();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableJoin.java
Patch:
@@ -158,7 +158,7 @@ void errorAll(Observer<?> a) {
             a.onError(ex);
         }
         
-        void fail(Throwable exc, Observer<?> a, Queue<?> q) {
+        void fail(Throwable exc, Observer<?> a, SpscLinkedArrayQueue<?> q) {
             Exceptions.throwIfFatal(exc);
             Exceptions.addThrowable(error, exc);
             q.clear();

File: src/main/java/io/reactivex/internal/operators/observable/ObservableObserveOn.java
Patch:
@@ -13,7 +13,6 @@
 
 package io.reactivex.internal.operators.observable;
 
-import java.util.Queue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
@@ -64,7 +63,7 @@ static final class ObserveOnSubscriber<T> extends Padding0 implements Observer<T
         final Scheduler.Worker worker;
         final boolean delayError;
         final int bufferSize;
-        final Queue<T> queue;
+        final SpscLinkedArrayQueue<T> queue;
         
         Disposable s;
         
@@ -147,7 +146,7 @@ void schedule() {
         public void run() {
             int missed = 1;
             
-            final Queue<T> q = queue;
+            final SpscLinkedArrayQueue<T> q = queue;
             final Observer<? super T> a = actual;
             
             for (;;) {

File: src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
Patch:
@@ -13,13 +13,12 @@
 
 package io.reactivex.internal.schedulers;
 
-import java.util.Queue;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.Scheduler;
 import io.reactivex.disposables.*;
-import io.reactivex.internal.disposables.*;
+import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.BooleanRunnable;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -232,7 +231,7 @@ public boolean isDisposed() {
         @Override
         public void run() {
             int missed = 1;
-            final Queue<Runnable> q = queue;
+            final MpscLinkedQueue<Runnable> q = queue;
             for (;;) {
                 
                 if (disposed) {

File: src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
Patch:
@@ -132,13 +132,11 @@ void drain() {
         for (;;) {
             
             for (;;) {
-                Object o = q.peek();
                 
+                Object o = q.poll();
                 if (o == null) {
                     break;
                 }
-                
-                q.poll();
                 Object v = q.poll();
                 
                 if (o == REQUEST) {

File: src/main/java/io/reactivex/internal/util/OpenHashSet.java
Patch:
@@ -136,7 +136,7 @@ boolean removeEntry(int pos, T[] a, int m) {
         }
     }
     
-    public void clear(Consumer<? super T> clearAction) {
+    public void clear(Consumer<? super T> clearAction) throws Exception {
         if (size == 0) {
             return;
         }
@@ -186,7 +186,7 @@ static int mix(int x) {
         return h ^ (h >>> 16);
     }
     
-    public void forEach(Consumer<? super T> consumer) {
+    public void forEach(Consumer<? super T> consumer) throws Exception  {
         for (T k : keys) {
             if (k != null) {
                 consumer.accept(k);

File: src/test/java/io/reactivex/flowable/FlowableMergeTests.java
Patch:
@@ -16,13 +16,13 @@
 import static org.junit.Assert.*;
 
 import java.util.List;
+import java.util.concurrent.Callable;
 
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 
 import io.reactivex.Flowable;
 import io.reactivex.flowable.FlowableCovarianceTest.*;
-import io.reactivex.functions.Supplier;
 
 public class FlowableMergeTests {
 
@@ -76,9 +76,9 @@ public void testMergeCovariance3() {
     @Test
     public void testMergeCovariance4() {
 
-        Flowable<Movie> o1 = Flowable.defer(new Supplier<Publisher<Movie>>() {
+        Flowable<Movie> o1 = Flowable.defer(new Callable<Publisher<Movie>>() {
             @Override
-            public Publisher<Movie> get() {
+            public Publisher<Movie> call() {
                 return Flowable.just(
                         new HorrorMovie(),
                         new Movie()

File: src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
Patch:
@@ -78,7 +78,7 @@ public void cancel() {
     }
 
     @Test
-    public void testRequestFromChainedOperator() {
+    public void testRequestFromChainedOperator() throws Exception {
         TestSubscriber<String> s = new TestSubscriber<String>();
         Operator<String, String> o = new Operator<String, String>() {
             @Override
@@ -131,7 +131,7 @@ public void cancel() {
     }
 
     @Test
-    public void testRequestFromDecoupledOperator() {
+    public void testRequestFromDecoupledOperator() throws Exception {
         TestSubscriber<String> s = new TestSubscriber<String>(0L);
         Operator<String, String> o = new Operator<String, String>() {
             @Override
@@ -184,7 +184,7 @@ public void cancel() {
     }
 
     @Test
-    public void testRequestFromDecoupledOperatorThatRequestsN() {
+    public void testRequestFromDecoupledOperatorThatRequestsN() throws Exception {
         TestSubscriber<String> s = new TestSubscriber<String>();
         final AtomicLong innerR = new AtomicLong();
         Operator<String, String> o = new Operator<String, String>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
Patch:
@@ -247,9 +247,9 @@ public void subscribe(Subscriber<? super String> observer) {
             }
         });
 
-        Supplier<Flowable<Object>> closer = new Supplier<Flowable<Object>>() {
+        Callable<Flowable<Object>> closer = new Callable<Flowable<Object>>() {
             @Override
-            public Flowable<Object> get() {
+            public Flowable<Object> call() {
                 return Flowable.create(new Publisher<Object>() {
                     @Override
                     public void subscribe(Subscriber<? super Object> observer) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupJoinTest.java
Patch:
@@ -62,7 +62,7 @@ public Flowable<R> apply(T t1) {
         public Flowable<Integer> apply(final Integer leftValue, Flowable<Integer> rightValues) {
             return rightValues.map(new Function<Integer, Integer>() {
                 @Override
-                public Integer apply(Integer rightValue) {
+                public Integer apply(Integer rightValue) throws Exception {
                     return add.apply(leftValue, rightValue);
                 }
             });

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
Patch:
@@ -30,7 +30,7 @@
 import io.reactivex.functions.*;
 import io.reactivex.processors.ReplayProcessor;
 import io.reactivex.schedulers.*;
-import io.reactivex.subscribers.*;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableRefCountTest {
 
@@ -522,9 +522,9 @@ public void accept(Subscription s) {
                         .flatMap(new Function<Long, Publisher<String>>() {
                             @Override
                             public Publisher<String> apply(Long t1) {
-                                    return Flowable.defer(new Supplier<Publisher<String>>() {
+                                    return Flowable.defer(new Callable<Publisher<String>>() {
                                         @Override
-                                        public Publisher<String> get() {
+                                        public Publisher<String> call() {
                                                 return Flowable.<String>error(new Exception("Some exception"));
                                         }
                                     });

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.operators.flowable.FlowableReplay.*;
-import io.reactivex.internal.subscriptions.*;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.TestSubscriber;
@@ -503,12 +503,12 @@ public void run() {
     }
 
 
-    /**
+    /*
      * test the basic expectation of OperatorMulticast via replay
      */
     @SuppressWarnings("unchecked")
     @Test
-    public void testIssue2191_UnsubscribeSource() {
+    public void testIssue2191_UnsubscribeSource() throws Exception {
         // setup mocks
         Consumer<Integer> sourceNext = mock(Consumer.class);
         Runnable sourceCompleted = mock(Runnable.class);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
Patch:
@@ -339,14 +339,14 @@ public void testInfiniteRetry() {
         inOrder.verifyNoMoreInteractions();
     }
 
-    /**
+    /*
      * Checks in a simple and synchronous way that retry resubscribes
      * after error. This test fails against 0.16.1-0.17.4, hangs on 0.17.5 and
      * passes in 0.17.6 thanks to fix for issue #1027.
      */
     @SuppressWarnings("unchecked")
     @Test
-    public void testRetrySubscribesAgainAfterError() {
+    public void testRetrySubscribesAgainAfterError() throws Exception {
 
         // record emitted values with this action
         Consumer<Integer> record = mock(Consumer.class);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
Patch:
@@ -246,9 +246,9 @@ public void subscribe(Observer<? super String> NbpObserver) {
             }
         });
 
-        Supplier<Observable<Object>> closer = new Supplier<Observable<Object>>() {
+        Callable<Observable<Object>> closer = new Callable<Observable<Object>>() {
             @Override
-            public Observable<Object> get() {
+            public Observable<Object> call() {
                 return Observable.create(new ObservableConsumable<Object>() {
                     @Override
                     public void subscribe(Observer<? super Object> NbpObserver) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableGroupJoinTest.java
Patch:
@@ -62,7 +62,7 @@ public Observable<R> apply(T t1) {
         public Observable<Integer> apply(final Integer leftValue, Observable<Integer> rightValues) {
             return rightValues.map(new Function<Integer, Integer>() {
                 @Override
-                public Integer apply(Integer rightValue) {
+                public Integer apply(Integer rightValue) throws Exception {
                     return add.apply(leftValue, rightValue);
                 }
             });

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
Patch:
@@ -512,9 +512,9 @@ public void accept(Disposable s) {
                         .flatMap(new Function<Long, Observable<String>>() {
                             @Override
                             public Observable<String> apply(Long t1) {
-                                    return Observable.defer(new Supplier<Observable<String>>() {
+                                    return Observable.defer(new Callable<Observable<String>>() {
                                         @Override
-                                        public Observable<String> get() {
+                                        public Observable<String> call() {
                                                 return Observable.<String>error(new Exception("Some exception"));
                                         }
                                     });

File: src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
Patch:
@@ -504,12 +504,12 @@ public void run() {
     }
 
 
-    /**
+    /*
      * test the basic expectation of OperatorMulticast via replay
      */
     @SuppressWarnings("unchecked")
     @Test
-    public void testIssue2191_UnsubscribeSource() {
+    public void testIssue2191_UnsubscribeSource() throws Exception {
         // setup mocks
         Consumer<Integer> sourceNext = mock(Consumer.class);
         Runnable sourceCompleted = mock(Runnable.class);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
Patch:
@@ -341,14 +341,14 @@ public void testInfiniteRetry() {
         inOrder.verifyNoMoreInteractions();
     }
 
-    /**
+    /*
      * Checks in a simple and synchronous way that retry resubscribes
      * after error. This test fails against 0.16.1-0.17.4, hangs on 0.17.5 and
      * passes in 0.17.6 thanks to fix for issue #1027.
      */
     @SuppressWarnings("unchecked")
     @Test
-    public void testRetrySubscribesAgainAfterError() {
+    public void testRetrySubscribesAgainAfterError() throws Exception {
 
         // record emitted values with this action
         Consumer<Integer> record = mock(Consumer.class);

File: src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java
Patch:
@@ -18,6 +18,7 @@
 import static org.mockito.Mockito.*;
 
 import java.util.*;
+import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
@@ -172,10 +173,10 @@ public void onNext(Integer t) {
     @Test
     public void testSeedFactory() {
         Observable<List<Integer>> o = Observable.range(1, 10)
-                .collect(new Supplier<List<Integer>>() {
+                .collect(new Callable<List<Integer>>() {
 
                     @Override
-                    public List<Integer> get() {
+                    public List<Integer> call() {
                         return new ArrayList<Integer>();
                     }
                     

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java
Patch:
@@ -16,7 +16,7 @@
 import static org.junit.Assert.*;
 
 import java.util.*;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.*;
 
 import org.junit.*;
 
@@ -109,10 +109,10 @@ public void subscribe(Observer<? super String> NbpObserver) {
             }
         });
 
-        Supplier<Observable<Object>> closer = new Supplier<Observable<Object>>() {
+        Callable<Observable<Object>> closer = new Callable<Observable<Object>>() {
             int calls;
             @Override
-            public Observable<Object> get() {
+            public Observable<Object> call() {
                 return Observable.create(new ObservableConsumable<Object>() {
                     @Override
                     public void subscribe(Observer<? super Object> NbpObserver) {

File: src/test/java/io/reactivex/observable/ObservableMergeTests.java
Patch:
@@ -16,11 +16,11 @@
 import static org.junit.Assert.*;
 
 import java.util.List;
+import java.util.concurrent.Callable;
 
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.functions.Supplier;
 import io.reactivex.observable.ObservableCovarianceTest.*;
 
 public class ObservableMergeTests {
@@ -75,9 +75,9 @@ public void testMergeCovariance3() {
     @Test
     public void testMergeCovariance4() {
 
-        Observable<Movie> o1 = Observable.defer(new Supplier<Observable<Movie>>() {
+        Observable<Movie> o1 = Observable.defer(new Callable<Observable<Movie>>() {
             @Override
-            public Observable<Movie> get() {
+            public Observable<Movie> call() {
                 return Observable.just(
                         new HorrorMovie(),
                         new Movie()

File: src/test/java/io/reactivex/flowable/FlowableNullTests.java
Patch:
@@ -1315,7 +1315,7 @@ public void filterNull() {
     
     @Test(expected = NullPointerException.class)
     public void finallyDoNull() {
-        just1.finallyDo(null);
+        just1.doAfterTerminate(null);
     }
     
     @Test(expected = NullPointerException.class)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
Patch:
@@ -118,7 +118,7 @@ public void accept(String t1) {
                 assertTrue(correctThreadName);
             }
 
-        }).finallyDo(new Runnable() {
+        }).doAfterTerminate(new Runnable() {
 
             @Override
             public void run() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
Patch:
@@ -18,15 +18,15 @@
 import static org.mockito.Mockito.*;
 
 import java.util.*;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.*;
 
-import org.junit.Test;
+import org.junit.*;
 import org.mockito.InOrder;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
 import io.reactivex.functions.*;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.*;
 
 public class FlowableSingleTest {
 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -2637,7 +2637,7 @@ public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super T
     public final void subscribe(Observer<? super T> observer) {
         Objects.requireNonNull(observer, "observer is null");
         
-        // TODO plugin wrappings
+        observer = RxJavaPlugins.onSubscribe(this, observer);
         
         subscribeActual(observer);
     }

File: src/main/java/io/reactivex/exceptions/UnsubscribeFailedException.java
Patch:
@@ -18,7 +18,7 @@ public final class UnsubscribeFailedException extends RuntimeException {
     private static final long serialVersionUID = 8947024194181365640L;
 
     public UnsubscribeFailedException(Throwable cause) {
-        super(cause);
+        super(cause != null ? cause : new NullPointerException());
     }
     
 }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.flowables.GroupedFlowable;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.Objects;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.*;

File: src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.reactivex.internal.util.SuppressAnimalSniffer;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -62,9 +63,10 @@ public static void start() {
                 
                 next.scheduleAtFixedRate(new Runnable() {
                     @Override
+                    @SuppressAnimalSniffer
                     public void run() {
                         try {
-                            for (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {
+                            for (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {  // CHM.keySet returns KeySetView in Java 8+; false positive here
                                 if (e.isShutdown()) {
                                     POOLS.remove(e);
                                 } else {

File: src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
Patch:
@@ -107,6 +107,7 @@ public final void complete(T v) {
                 if (get() != CANCELLED) {
                     actual.onComplete();
                 }
+                lazySet(HAS_REQUEST_HAS_VALUE);
                 return;
             }
             this.value = v;

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
Patch:
@@ -156,7 +156,7 @@ public static boolean replace(AtomicReference<Subscription> field, Subscription
     
     /**
      * Atomically swaps in the common cancelled subscription instance
-     * and disposes the previous subscription if any.
+     * and cancels the previous subscription if any.
      * @param field the target field to dispose the contents of
      * @return true if the swap from the non-cancelled instance to the
      * common cancelled instance happened in the caller's thread (allows

File: src/main/java/io/reactivex/internal/util/Exceptions.java
Patch:
@@ -103,9 +103,7 @@ public static <T> boolean addThrowable(AtomicReference<Throwable> field, Throwab
             if (current == null) {
                 update = exception;
             } else {
-                update = new Throwable("Multiple exceptions");
-                update.addSuppressed(current);
-                update.addSuppressed(exception);
+                update = new CompositeException(current, exception);
             }
             
             if (field.compareAndSet(current, update)) {

File: src/main/java/io/reactivex/plugins/RxJavaPlugins.java
Patch:
@@ -439,12 +439,12 @@ public static <T> Subscriber<? super T> onSubscribe(Flowable<T> source, Subscrib
     }
 
     @SuppressWarnings({ "rawtypes", "unchecked" })
-    public static <T> Observer<? super T> onSubscribe(Observable<T> source, Observer<? super T> subscriber) {
+    public static <T> Observer<? super T> onSubscribe(Observable<T> source, Observer<? super T> observer) {
         BiFunction<Observable, Observer, Observer> f = onObservableSubscribe;
         if (f != null) {
-            return f.apply(source, subscriber);
+            return f.apply(source, observer);
         }
-        return subscriber;
+        return observer;
     }
 
     @SuppressWarnings({ "rawtypes", "unchecked" })

File: src/main/java/io/reactivex/Flowable.java
Patch:
@@ -443,7 +443,6 @@ public static <T> Flowable<T> create(Publisher<T> onSubscribe) {
         if (onSubscribe instanceof Flowable) {
             throw new IllegalArgumentException("create(Flowable) should be upgraded");
         }
-        onSubscribe = RxJavaPlugins.onCreate(onSubscribe);
         return fromPublisher(onSubscribe);
     }
 
@@ -3079,7 +3078,7 @@ public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super T
     public final void subscribe(Subscriber<? super T> s) {
         Objects.requireNonNull(s, "s is null");
         try {
-            s = RxJavaPlugins.onSubscribe(s);
+            s = RxJavaPlugins.onSubscribe(this, s);
 
             if (s == null) {
                 throw new NullPointerException("Plugin returned null Subscriber");

File: src/main/java/io/reactivex/internal/operators/completable/CompletableOnErrorComplete.java
Patch:
@@ -46,7 +46,7 @@ public void onError(Throwable e) {
                 try {
                     b = predicate.test(e);
                 } catch (Throwable ex) {
-                    s.onError(new CompositeException(ex, e));
+                    s.onError(new CompositeException(e, ex));
                     return;
                 }
                 

File: src/main/java/io/reactivex/internal/operators/single/SingleDelay.java
Patch:
@@ -38,7 +38,7 @@ protected void subscribeActual(final SingleSubscriber<? super T> s) {
 
         final SerialDisposable sd = new SerialDisposable();
         s.onSubscribe(sd);
-        subscribe(new SingleSubscriber<T>() {
+        source.subscribe(new SingleSubscriber<T>() {
             @Override
             public void onSubscribe(Disposable d) {
                 sd.replace(d);

File: src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableSubscriber.java
Patch:
@@ -40,10 +40,12 @@ public boolean isDisposed() {
     @Override
     public void onComplete() {
         // no-op
+        lazySet(DisposableHelper.DISPOSED);
     }
 
     @Override
     public void onError(Throwable e) {
+        lazySet(DisposableHelper.DISPOSED);
         RxJavaPlugins.onError(e);
     }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
Patch:
@@ -141,7 +141,7 @@ public Publisher<Integer> apply(Boolean t1) {
     
     @Test
     public void testBackpressureIfNoneRequestedNoneShouldBeDelivered() {
-        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>((Long)null);
+        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(0L);
         Flowable.empty().all(new Predicate<Object>() {
             @Override
             public boolean test(Object t1) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
Patch:
@@ -171,7 +171,7 @@ public void testAmb3() {
     @SuppressWarnings("unchecked")
     @Test
     public void testProducerRequestThroughAmb() {
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         ts.request(3);
         final AtomicLong requested1 = new AtomicLong();
         final AtomicLong requested2 = new AtomicLong();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
Patch:
@@ -240,7 +240,7 @@ public Publisher<Integer> apply(Boolean t1) {
     
     @Test
     public void testBackpressureIfNoneRequestedNoneShouldBeDelivered() {
-        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>((Long)null);
+        TestSubscriber<Boolean> ts = new TestSubscriber<Boolean>(0L);
         
         Flowable.just(1).any(new Predicate<Integer>() {
             @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
Patch:
@@ -341,7 +341,7 @@ public void testBufferStopsWhenUnsubscribed1() {
         Flowable<Integer> source = Flowable.never();
 
         Subscriber<List<Integer>> o = TestHelper.mockSubscriber();
-        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(o, (Long)null);
+        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(o, 0L);
 
         source.buffer(100, 200, TimeUnit.MILLISECONDS, scheduler)
         .doOnNext(new Consumer<List<Integer>>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
Patch:
@@ -59,7 +59,7 @@ public void testColdReplayBackpressure() {
         
         assertFalse("Source is connected!", source.isConnected());
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         ts.request(10);
         
         source.subscribe(ts);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -402,7 +402,7 @@ public void testConcatUnsubscribe() {
         final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, "four", "five", "six");
 
         Subscriber<String> observer = TestHelper.mockSubscriber();
-        TestSubscriber<String> ts = new TestSubscriber<String>(observer, null);
+        TestSubscriber<String> ts = new TestSubscriber<String>(observer, 0L);
 
         final Flowable<String> concat = Flowable.concat(Flowable.create(w1), Flowable.create(w2));
 
@@ -444,7 +444,7 @@ public void testConcatUnsubscribeConcurrent() {
         final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, "four", "five", "six");
 
         Subscriber<String> observer = TestHelper.mockSubscriber();
-        TestSubscriber<String> ts = new TestSubscriber<String>(observer, null);
+        TestSubscriber<String> ts = new TestSubscriber<String>(observer, 0L);
         
         @SuppressWarnings("unchecked")
         TestObservable<Flowable<String>> observableOfObservables = new TestObservable<Flowable<String>>(Flowable.create(w1), Flowable.create(w2));

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDefaultIfEmptyTest.java
Patch:
@@ -85,7 +85,7 @@ public void onComplete() {
     
     @Test
     public void testBackpressureEmpty() {
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         Flowable.<Integer>empty().defaultIfEmpty(1).subscribe(ts);
         ts.assertNoValues();
         ts.assertNotTerminated();
@@ -97,7 +97,7 @@ public void testBackpressureEmpty() {
     
     @Test
     public void testBackpressureNonEmpty() {
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         Flowable.just(1,2,3).defaultIfEmpty(1).subscribe(ts);
         ts.assertNoValues();
         ts.assertNotTerminated();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOtherTest.java
Patch:
@@ -195,7 +195,7 @@ public void testBackpressurePassesThrough() {
         
         PublishProcessor<Object> other = PublishProcessor.create();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         final AtomicInteger subscribed = new AtomicInteger();
         

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
Patch:
@@ -119,7 +119,7 @@ public void testBackpressureViaRequest() {
         }
         Flowable<Integer> o = Flowable.fromIterable(list);
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         ts.assertNoValues();
         ts.request(1);
@@ -139,7 +139,7 @@ public void testBackpressureViaRequest() {
     public void testNoBackpressure() {
         Flowable<Integer> o = Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5));
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         ts.assertNoValues();
         ts.request(Long.MAX_VALUE); // infinite

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
Patch:
@@ -1527,7 +1527,7 @@ public Object apply(Integer i) {
      */
     @Test
     public void testBackpressureInnerDoesntOverflowOuter() {
-        TestSubscriber<GroupedFlowable<Integer, Integer>> ts = new TestSubscriber<GroupedFlowable<Integer, Integer>>((Long)null);
+        TestSubscriber<GroupedFlowable<Integer, Integer>> ts = new TestSubscriber<GroupedFlowable<Integer, Integer>>(0L);
         
         Flowable.fromArray(1, 2)
                 .groupBy(new Function<Integer, Integer>() {
@@ -1553,8 +1553,8 @@ public void accept(GroupedFlowable<Integer, Integer> g) {
     
     @Test
     public void testOneGroupInnerRequestsTwiceBuffer() {
-        TestSubscriber<Object> ts1 = new TestSubscriber<Object>((Long)null);
-        final TestSubscriber<Object> ts2 = new TestSubscriber<Object>((Long)null);
+        TestSubscriber<Object> ts1 = new TestSubscriber<Object>(0L);
+        final TestSubscriber<Object> ts2 = new TestSubscriber<Object>(0L);
         
         Flowable.range(1, Flowable.bufferSize() * 2)
         .groupBy(new Function<Integer, Object>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeMaxConcurrentTest.java
Patch:
@@ -260,7 +260,7 @@ public void testBackpressureHonored() throws Exception {
         
         final CountDownLatch cdl = new CountDownLatch(5);
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null) {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L) {
             @Override
             public void onNext(Integer t) {
                 super.onNext(t);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java
Patch:
@@ -30,7 +30,7 @@ public class FlowableOnBackpressureBufferTest {
 
     @Test
     public void testNoBackpressureSupport() {
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         // this will be ignored
         ts.request(100);
         // we take 500 so it unsubscribes
@@ -64,7 +64,7 @@ public void onNext(Long t) {
                 l2.countDown();
             }
 
-        }, null);
+        }, 0L);
         // this will be ignored
         ts.request(100);
         // we take 500 so it unsubscribes
@@ -118,7 +118,7 @@ public void onNext(Long t) {
                 l1.countDown();
             }
 
-        }, null);
+        }, 0L);
 
         ts.request(100);
         infinite.subscribeOn(Schedulers.computation())

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDropTest.java
Patch:
@@ -30,7 +30,7 @@ public class FlowableOnBackpressureDropTest {
 
     @Test
     public void testNoBackpressureSupport() {
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         // this will be ignored
         ts.request(100);
         // we take 500 so it unsubscribes
@@ -71,7 +71,7 @@ public void onNext(Long t) {
                 l2.countDown();
             }
 
-        }, null);
+        }, 0L);
         // this will be ignored
         ts.request(100);
         // we take 500 so it unsubscribes

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatestTest.java
Patch:
@@ -60,7 +60,7 @@ public void testSimpleBackpressure() {
     @Test
     public void testSynchronousDrop() {
         PublishProcessor<Integer> source = PublishProcessor.create();
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         source.onBackpressureLatest().subscribe(ts);
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java
Patch:
@@ -344,7 +344,7 @@ static boolean checkPublishDisposed(Disposable d) {
     public void testZeroRequested() {
         ConnectableFlowable<Integer> source = Flowable.just(1).publish();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         source.subscribe(ts);
         

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -878,7 +878,7 @@ public void testColdReplayNoBackpressure() {
     public void testColdReplayBackpressure() {
         Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         ts.request(10);
         
         source.subscribe(ts);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTest.java
Patch:
@@ -142,7 +142,7 @@ public void testSkipError() {
     @Test
     public void testBackpressureMultipleSmallAsyncRequests() throws InterruptedException {
         final AtomicLong requests = new AtomicLong(0);
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         Flowable.interval(100, TimeUnit.MILLISECONDS)
                 .doOnRequest(new LongConsumer() {
                     @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchIfEmptyTest.java
Patch:
@@ -157,15 +157,15 @@ public void testSwitchRequestAlternativeObservableWithBackpressure() {
     }
     @Test
     public void testBackpressureNoRequest() {
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         Flowable.<Integer>empty().switchIfEmpty(Flowable.just(1, 2, 3)).subscribe(ts);
         ts.assertNoValues();
         ts.assertNoErrors();
     }
     
     @Test
     public void testBackpressureOnFirstObservable() {
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         Flowable.just(1,2,3).switchIfEmpty(Flowable.just(4, 5, 6)).subscribe(ts);
         ts.assertNotComplete();
         ts.assertNoErrors();
@@ -174,7 +174,7 @@ public void testBackpressureOnFirstObservable() {
     
     @Test(timeout = 10000)
     public void testRequestsNotLost() throws InterruptedException {
-        final TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        final TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         Flowable.create(new Publisher<Long>() {
 
             @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
Patch:
@@ -547,7 +547,7 @@ public void onNext(String t) {
     
     @Test(timeout = 10000)
     public void testInitialRequestsAreAdditive() {
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         Flowable.switchOnNext(
                 Flowable.interval(100, TimeUnit.MILLISECONDS)
                           .map(
@@ -566,7 +566,7 @@ public Flowable<Long> apply(Long t) {
     
     @Test(timeout = 10000)
     public void testInitialRequestsDontOverflow() {
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         Flowable.switchOnNext(
                 Flowable.interval(100, TimeUnit.MILLISECONDS)
                         .map(new Function<Long, Flowable<Long>>() {
@@ -584,7 +584,7 @@ public Flowable<Long> apply(Long t) {
     
     @Test(timeout = 10000)
     public void testSecondaryRequestsDontOverflow() throws InterruptedException {
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         Flowable.switchOnNext(
                 Flowable.interval(100, TimeUnit.MILLISECONDS)
                         .map(new Function<Long, Flowable<Long>>() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimedTest.java
Patch:
@@ -206,7 +206,7 @@ public void takeLastTimedWithZeroCapacity() {
     public void testContinuousDelivery() {
         TestScheduler scheduler = Schedulers.test();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         PublishProcessor<Integer> ps = PublishProcessor.create();
         

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
Patch:
@@ -380,7 +380,7 @@ public void accept(Integer t1) {
     @Test
     public void testDoesntRequestMoreThanNeededFromUpstream() throws InterruptedException {
         final AtomicLong requests = new AtomicLong();
-        TestSubscriber<Long> ts = new TestSubscriber<Long>((Long)null);
+        TestSubscriber<Long> ts = new TestSubscriber<Long>(0L);
         Flowable.interval(100, TimeUnit.MILLISECONDS)
             //
             .doOnRequest(new LongConsumer() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java
Patch:
@@ -255,7 +255,7 @@ public void testDownstreamUnsubscribes() {
     public void testBackpressure() {
         PublishProcessor<Integer> until = PublishProcessor.create();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         Flowable.range(1, 10).takeUntil(until).unsafeSubscribe(ts);
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableListTest.java
Patch:
@@ -98,7 +98,7 @@ public void testListWithBlockingFirst() {
     @Test
     public void testBackpressureHonored() {
         Flowable<List<Integer>> w = Flowable.just(1, 2, 3, 4, 5).toList();
-        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>((Long)null);
+        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(0L);
         
         w.subscribe(ts);
         
@@ -131,7 +131,7 @@ public void testAsyncRequested() {
                 Flowable<List<Integer>> sorted = source.toList();
 
                 final CyclicBarrier cb = new CyclicBarrier(2);
-                final TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>((Long)null);
+                final TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(0L);
                 sorted.subscribe(ts);
                 
                 w.schedule(new Runnable() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableSortedListTest.java
Patch:
@@ -70,7 +70,7 @@ public void testWithFollowingFirst() {
     @Test
     public void testBackpressureHonored() {
         Flowable<List<Integer>> w = Flowable.just(1, 3, 2, 5, 4).toSortedList();
-        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>((Long)null);
+        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(0L);
         
         w.subscribe(ts);
         
@@ -103,7 +103,7 @@ public void testAsyncRequested() {
                 Flowable<List<Integer>> sorted = source.toSortedList();
 
                 final CyclicBarrier cb = new CyclicBarrier(2);
-                final TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>((Long)null);
+                final TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(0L);
                 sorted.subscribe(ts);
                 w.schedule(new Runnable() {
                     @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java
Patch:
@@ -292,7 +292,7 @@ public Flowable<Integer> apply(Flowable<Integer> w) {
     @SuppressWarnings("unchecked")
     @Test
     public void testBackpressureOuterInexact() {
-        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>((Long)null);
+        TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(0L);
         
         Flowable.range(1, 5)
         .window(2, 1)

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java
Patch:
@@ -260,7 +260,7 @@ public void testBackpressure() {
         
         Flowable<Integer> result = source.withLatestFrom(other, COMBINER);
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         result.subscribe(ts);
 

File: src/test/java/io/reactivex/processors/ReplayProcessorTest.java
Patch:
@@ -829,7 +829,7 @@ public void testBackpressureHonored() {
         rs.onNext(3);
         rs.onComplete();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         rs.subscribe(ts);
         
@@ -858,7 +858,7 @@ public void testBackpressureHonoredSizeBound() {
         rs.onNext(3);
         rs.onComplete();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         rs.subscribe(ts);
         
@@ -887,7 +887,7 @@ public void testBackpressureHonoredTimeBound() {
         rs.onNext(3);
         rs.onComplete();
         
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>((Long)null);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
         
         rs.subscribe(ts);
         

File: src/test/java/io/reactivex/single/SingleTest.java
Patch:
@@ -433,7 +433,7 @@ public void subscribe(SingleSubscriber<? super String> t) {
             }
         });
 
-        TestSubscriber<String> ts = new TestSubscriber<String>((Long)null);
+        TestSubscriber<String> ts = new TestSubscriber<String>(0L);
 
         s.subscribe(ts);
 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -1659,7 +1659,7 @@ public final Observable<T> doOnLifecycle(final Consumer<? super Disposable> onSu
         return lift(new NbpOperator<T, T>() {
             @Override
             public Observer<? super T> apply(Observer<? super T> s) {
-                return new NbpSubscriptionLambdaSubscriber<T>(s, onSubscribe, onCancel);
+                return new SubscriptionLambdaObserver<T>(s, onSubscribe, onCancel);
             }
         });
     }
@@ -2626,7 +2626,7 @@ public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super T
         Objects.requireNonNull(onComplete, "onComplete is null");
         Objects.requireNonNull(onSubscribe, "onSubscribe is null");
 
-        NbpLambdaSubscriber<T> ls = new NbpLambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);
+        LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);
 
         unsafeSubscribe(ls);
 

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java
Patch:
@@ -52,7 +52,7 @@ protected void subscribeActual(Observer<? super U> t) {
     }
     
     static final class BufferBoundarySubscriber<T, U extends Collection<? super T>, Open, Close>
-    extends NbpQueueDrainSubscriber<T, U, U> implements Disposable {
+    extends QueueDrainObserver<T, U, U> implements Disposable {
         final ObservableConsumable<? extends Open> bufferOpen;
         final Function<? super Open, ? extends ObservableConsumable<? extends Close>> bufferClose;
         final Supplier<U> bufferSupplier;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java
Patch:
@@ -44,7 +44,7 @@ protected void subscribeActual(Observer<? super U> t) {
     }
     
     static final class BufferBondarySupplierSubscriber<T, U extends Collection<? super T>, B>
-    extends NbpQueueDrainSubscriber<T, U, U> implements Observer<T>, Disposable {
+    extends QueueDrainObserver<T, U, U> implements Observer<T>, Disposable {
         /** */
         final Supplier<U> bufferSupplier;
         final Supplier<? extends ObservableConsumable<B>> boundarySupplier;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java
Patch:
@@ -42,7 +42,7 @@ protected void subscribeActual(Observer<? super U> t) {
     }
     
     static final class BufferExactBondarySubscriber<T, U extends Collection<? super T>, B>
-    extends NbpQueueDrainSubscriber<T, U, U> implements Observer<T>, Disposable {
+    extends QueueDrainObserver<T, U, U> implements Observer<T>, Disposable {
         /** */
         final Supplier<U> bufferSupplier;
         final ObservableConsumable<B> boundary;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
Patch:
@@ -18,7 +18,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.*;
-import io.reactivex.internal.subscribers.observable.NbpToNotificationSubscriber;
+import io.reactivex.internal.subscribers.observable.ToNotificationObserver;
 import io.reactivex.subjects.BehaviorSubject;
 
 public final class ObservableRedo<T> extends Observable<T> {
@@ -43,7 +43,7 @@ public void subscribeActual(Observer<? super T> s) {
 
         ObservableConsumable<?> action = manager.apply(subject);
         
-        action.subscribe(new NbpToNotificationSubscriber<Object>(new Consumer<Try<Optional<Object>>>() {
+        action.subscribe(new ToNotificationObserver<Object>(new Consumer<Try<Optional<Object>>>() {
             @Override
             public void accept(Try<Optional<Object>> o) {
                 parent.handle(o);

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java
Patch:
@@ -100,11 +100,11 @@ public void onSubscribe(Disposable s) {
                     TimeoutInnerSubscriber<T, U, V> tis = new TimeoutInnerSubscriber<T, U, V>(this, 0);
                     
                     if (compareAndSet(null, tis)) {
-                        a.onSubscribe(s);
+                        a.onSubscribe(this);
                         p.subscribe(tis);
                     }
                 } else {
-                    a.onSubscribe(s);
+                    a.onSubscribe(this);
                 }
             }
         }
@@ -360,7 +360,7 @@ public boolean isDisposed() {
         public void timeout(long idx) {
             if (idx == index) {
                 dispose();
-                other.subscribe(new NbpFullArbiterSubscriber<T>(arbiter));
+                other.subscribe(new FullArbiterObserver<T>(arbiter));
             }
         }
     }

File: src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java
Patch:
@@ -20,7 +20,7 @@
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
-import io.reactivex.internal.subscribers.observable.NbpFullArbiterSubscriber;
+import io.reactivex.internal.subscribers.observable.FullArbiterObserver;
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -147,7 +147,7 @@ public void run() {
         }
         
         void subscribeNext() {
-            other.subscribe(new NbpFullArbiterSubscriber<T>(arbiter));
+            other.subscribe(new FullArbiterObserver<T>(arbiter));
         }
         
         @Override
@@ -220,7 +220,7 @@ public TimeoutTimedSubscriber(Observer<? super T> actual, long timeout, TimeUnit
         public void onSubscribe(Disposable s) {
             if (DisposableHelper.validate(this.s, s)) {
                 this.s = s;
-                actual.onSubscribe(s);
+                actual.onSubscribe(this);
                 scheduleTimeout(0L);
             }
             

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java
Patch:
@@ -42,7 +42,7 @@ public void subscribeActual(Observer<? super Observable<T>> t) {
     }
     
     static final class WindowBoundaryMainSubscriber<T, B> 
-    extends NbpQueueDrainSubscriber<T, Object, Observable<T>> 
+    extends QueueDrainObserver<T, Object, Observable<T>> 
     implements Disposable {
         
         final ObservableConsumable<B> other;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
Patch:
@@ -52,7 +52,7 @@ public void subscribeActual(Observer<? super Observable<T>> t) {
     }
     
     static final class WindowBoundaryMainSubscriber<T, B, V>
-    extends NbpQueueDrainSubscriber<T, Object, Observable<T>>
+    extends QueueDrainObserver<T, Object, Observable<T>>
     implements Disposable {
         final ObservableConsumable<B> open;
         final Function<? super B, ? extends ObservableConsumable<V>> close;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
Patch:
@@ -45,7 +45,7 @@ public void subscribeActual(Observer<? super Observable<T>> t) {
     }
     
     static final class WindowBoundaryMainSubscriber<T, B> 
-    extends NbpQueueDrainSubscriber<T, Object, Observable<T>> 
+    extends QueueDrainObserver<T, Object, Observable<T>> 
     implements Disposable {
         
         final Supplier<? extends ObservableConsumable<B>> other;

File: src/main/java/io/reactivex/internal/subscribers/observable/BlockingObserver.java
Patch:
@@ -21,15 +21,15 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.util.NotificationLite;
 
-public final class NbpBlockingSubscriber<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
+public final class BlockingObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
     /** */
     private static final long serialVersionUID = -4875965440900746268L;
 
     public static final Object TERMINATED = new Object();
 
     final Queue<Object> queue;
     
-    public NbpBlockingSubscriber(Queue<Object> queue) {
+    public BlockingObserver(Queue<Object> queue) {
         this.queue = queue;
     }
     

File: src/main/java/io/reactivex/internal/subscribers/observable/EmptyObserver.java
Patch:
@@ -20,15 +20,15 @@
 /**
  * A subscriber that ignores all events (onError is forwarded to RxJavaPlugins though).
  */
-public enum NbpEmptySubscriber implements Observer<Object> {
+public enum EmptyObserver implements Observer<Object> {
     /** Empty instance that reports error to the plugins. */
     INSTANCE(false),
     /** Empty instance that disposes disposables. */
     DISPOSED(true);
     
     private final boolean disposeDisposable;
     
-    NbpEmptySubscriber(boolean disposeDisposable) {
+    EmptyObserver(boolean disposeDisposable) {
         this.disposeDisposable = disposeDisposable;
     }
     

File: src/main/java/io/reactivex/internal/subscribers/observable/FullArbiterObserver.java
Patch:
@@ -22,12 +22,12 @@
  *
  * @param <T> the value type
  */
-public final class NbpFullArbiterSubscriber<T> implements Observer<T> {
+public final class FullArbiterObserver<T> implements Observer<T> {
     final NbpFullArbiter<T> arbiter;
 
     Disposable s;
 
-    public NbpFullArbiterSubscriber(NbpFullArbiter<T> arbiter) {
+    public FullArbiterObserver(NbpFullArbiter<T> arbiter) {
         this.arbiter = arbiter;
     }
 

File: src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java
Patch:
@@ -21,15 +21,15 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpLambdaSubscriber<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
+public final class LambdaObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
     /** */
     private static final long serialVersionUID = -7251123623727029452L;
     final Consumer<? super T> onNext;
     final Consumer<? super Throwable> onError;
     final Runnable onComplete;
     final Consumer<? super Disposable> onSubscribe;
     
-    public NbpLambdaSubscriber(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
+    public LambdaObserver(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
             Runnable onComplete,
             Consumer<? super Disposable> onSubscribe) {
         super();

File: src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
Patch:
@@ -28,7 +28,7 @@
  * @param <U> the value type in the queue
  * @param <V> the value type the child subscriber accepts
  */
-public abstract class NbpQueueDrainSubscriber<T, U, V> extends QueueDrainSubscriberPad2 implements Observer<T>, NbpQueueDrain<U, V> {
+public abstract class QueueDrainObserver<T, U, V> extends QueueDrainSubscriberPad2 implements Observer<T>, NbpQueueDrain<U, V> {
     protected final Observer<? super V> actual;
     protected final Queue<U> queue;
     
@@ -37,7 +37,7 @@ public abstract class NbpQueueDrainSubscriber<T, U, V> extends QueueDrainSubscri
     protected volatile boolean done;
     protected Throwable error;
     
-    public NbpQueueDrainSubscriber(Observer<? super V> actual, Queue<U> queue) {
+    public QueueDrainObserver(Observer<? super V> actual, Queue<U> queue) {
         this.actual = actual;
         this.queue = queue;
     }

File: src/main/java/io/reactivex/internal/subscribers/observable/SubscriptionLambdaObserver.java
Patch:
@@ -19,14 +19,14 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpSubscriptionLambdaSubscriber<T> implements Observer<T>, Disposable {
+public final class SubscriptionLambdaObserver<T> implements Observer<T>, Disposable {
     final Observer<? super T> actual;
     final Consumer<? super Disposable> onSubscribe;
     final Runnable onCancel;
     
     Disposable s;
     
-    public NbpSubscriptionLambdaSubscriber(Observer<? super T> actual, 
+    public SubscriptionLambdaObserver(Observer<? super T> actual, 
             Consumer<? super Disposable> onSubscribe,
             Runnable onCancel) {
         this.actual = actual;

File: src/main/java/io/reactivex/internal/subscribers/observable/ToNotificationObserver.java
Patch:
@@ -18,12 +18,12 @@
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.disposables.DisposableHelper;
 
-public final class NbpToNotificationSubscriber<T> implements Observer<T> {
+public final class ToNotificationObserver<T> implements Observer<T> {
     final Consumer<? super Try<Optional<Object>>> consumer;
     
     Disposable s;
     
-    public NbpToNotificationSubscriber(Consumer<? super Try<Optional<Object>>> consumer) {
+    public ToNotificationObserver(Consumer<? super Try<Optional<Object>>> consumer) {
         this.consumer = consumer;
     }
     

File: src/main/java/io/reactivex/observables/BlockingObservable.java
Patch:
@@ -61,7 +61,7 @@ public void forEach(Consumer<? super T> action) {
     static <T> BlockingIterator<T> iterate(Observable<? extends T> p) {
         final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();
 
-        NbpLambdaSubscriber<T> ls = new NbpLambdaSubscriber<T>(
+        LambdaObserver<T> ls = new LambdaObserver<T>(
             new Consumer<T>() {
                 @Override
                 public void accept(T v) {
@@ -345,7 +345,7 @@ private void awaitForComplete(CountDownLatch latch, Disposable subscription) {
     public void run() {
         final CountDownLatch cdl = new CountDownLatch(1);
         final Throwable[] error = { null };
-        NbpLambdaSubscriber<T> ls = new NbpLambdaSubscriber<T>(
+        LambdaObserver<T> ls = new LambdaObserver<T>(
             Functions.emptyConsumer(), 
             new Consumer<Throwable>() {
                 @Override
@@ -378,7 +378,7 @@ public void run() {
     public void subscribe(Observer<? super T> subscriber) {
         final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();
         
-        NbpBlockingSubscriber<T> bs = new NbpBlockingSubscriber<T>(queue);
+        BlockingObserver<T> bs = new BlockingObserver<T>(queue);
         
         o.subscribe(bs);
         

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
Patch:
@@ -68,7 +68,7 @@ public CompletableConcatSubscriber(CompletableSubscriber actual, int prefetch) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(prefetch);

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
Patch:
@@ -82,7 +82,7 @@ public boolean isDisposed() {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 set.add(Disposables.from(s));
                 actual.onSubscribe(this);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java
Patch:
@@ -50,7 +50,7 @@ public AllSubscriber(Subscriber<? super Boolean> actual, Predicate<? super T> pr
         }
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java
Patch:
@@ -95,7 +95,7 @@ public void subscribe(Publisher<? extends T>[] sources) {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             
@@ -172,7 +172,7 @@ public void request(long n) {
             Subscription s = get();
             if (s != null) {
                 s.request(n);
-            } else if (SubscriptionHelper.validateRequest(n)) {
+            } else if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(missedRequested, n);
                 s = get();
                 if (s != null && s != SubscriptionHelper.CANCELLED) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java
Patch:
@@ -47,7 +47,7 @@ public AnySubscriber(Subscriber<? super Boolean> actual, Predicate<? super T> pr
         }
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
Patch:
@@ -77,7 +77,7 @@ public BufferBoundarySubscriber(Subscriber<? super U> actual,
         }
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
 
                 BufferOpenSubscriber<T, U, Open, Close> bos = new BufferOpenSubscriber<T, U, Open, Close>(this);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
Patch:
@@ -67,7 +67,7 @@ public BufferBondarySupplierSubscriber(Subscriber<? super U> actual, Supplier<U>
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
Patch:
@@ -64,7 +64,7 @@ public BufferExactBondarySubscriber(Subscriber<? super U> actual, Supplier<U> bu
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -106,7 +106,7 @@ public BufferExactUnboundedSubscriber(
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -283,7 +283,7 @@ public BufferSkipBoundedSubscriber(Subscriber<? super U> actual,
     
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -459,7 +459,7 @@ public BufferExactBoundedSubscriber(
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
Patch:
@@ -275,7 +275,7 @@ public ReplaySubscription(Subscriber<? super T> child, CacheState<T> state) {
         }
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java
Patch:
@@ -66,7 +66,7 @@ public CollectSubscriber(Subscriber<? super U> actual, U u, BiConsumer<? super U
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -128,7 +128,7 @@ public void subscribe(Publisher<? extends T>[] sources) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java
Patch:
@@ -47,7 +47,7 @@ public CountSubscriber(Subscriber<? super Long> actual) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -66,7 +66,7 @@ public DebounceSubscriber(Subscriber<? super T> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -134,7 +134,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -73,7 +73,7 @@ public DebounceTimedSubscriber(Subscriber<? super T> actual, long timeout, TimeU
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -134,7 +134,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java
Patch:
@@ -71,7 +71,7 @@ public DelaySubscriber(Subscriber<? super T> actual, long delay, TimeUnit unit,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
Patch:
@@ -45,7 +45,7 @@ public DematerializeSubscriber(Subscriber<? super T> actual) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -135,7 +135,7 @@ public DistinctSubscriber(Subscriber<? super T> actual, Function<? super T, K> k
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -70,7 +70,7 @@ public DoOnEachSubscriber(
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java
Patch:
@@ -54,7 +54,7 @@ public ElementAtSubscriber(Subscriber<? super T> actual, long index, T defaultVa
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -83,7 +83,7 @@ public final void clear() {
 
         @Override
         public final void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 if (BackpressureHelper.add(this, n) == 0L) {
                     if (n == Long.MAX_VALUE) {
                         fastPath();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGenerate.java
Patch:
@@ -76,7 +76,7 @@ public GeneratorSubscription(Subscriber<? super T> actual,
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) != 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java
Patch:
@@ -86,7 +86,7 @@ public GroupBySubscriber(Subscriber<? super GroupedFlowable<K, V>> actual, Funct
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(bufferSize);
@@ -177,7 +177,7 @@ public void onComplete() {
 
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }
@@ -352,7 +352,7 @@ public State(int bufferSize, GroupBySubscriber<?, K, T> parent, K key, boolean d
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             BackpressureHelper.add(requested, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableHide.java
Patch:
@@ -56,7 +56,7 @@ public void cancel() {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElements.java
Patch:
@@ -45,7 +45,7 @@ public IgnoreElementsSubscriber(Subscriber<? super T> actual) {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
Patch:
@@ -65,7 +65,7 @@ public IntervalSubscriber(Subscriber<? super Long> actual) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
Patch:
@@ -71,7 +71,7 @@ public IntervalRangeSubscriber(Subscriber<? super Long> actual, long start, long
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
Patch:
@@ -83,7 +83,7 @@ public MapNotificationSubscriber(Subscriber<? super Publisher<? extends R>> actu
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }
@@ -183,7 +183,7 @@ void tryEmit(Publisher<? extends R> p) {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMaterialize.java
Patch:
@@ -59,7 +59,7 @@ public MaterializeSubscriber(Subscriber<? super Try<Optional<T>>> actual) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }
@@ -122,7 +122,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             BackpressureHelper.add(this, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
Patch:
@@ -84,7 +84,7 @@ public BackpressureBufferSubscriber(Subscriber<? super T> actual, int bufferSize
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -122,7 +122,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDrop.java
Patch:
@@ -67,7 +67,7 @@ public BackpressureDropSubscriber(Subscriber<? super T> actual, Consumer<? super
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -116,7 +116,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatest.java
Patch:
@@ -57,7 +57,7 @@ public BackpressureLatestSubscriber(Subscriber<? super T> actual) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -85,7 +85,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -63,7 +63,7 @@ public OnErrorReturnSubscriber(Subscriber<? super T> actual, Function<? super Th
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }
@@ -136,7 +136,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             BackpressureHelper.add(this, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRange.java
Patch:
@@ -82,7 +82,7 @@ public final void clear() {
 
         @Override
         public final void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 if (BackpressureHelper.add(this, n) == 0L) {
                     if (n == Long.MAX_VALUE) {
                         fastPath();

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -57,7 +57,7 @@ final class ConnectionSubscriber implements Subscriber<T>, Subscription {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 subscriber.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -610,7 +610,7 @@ public InnerSubscription(ReplaySubscriber<T> parent, Subscriber<? super T> child
         @Override
         public void request(long n) {
             // ignore negative requests
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             // In general, RxJava doesn't prevent concurrent requests (with each other or with

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java
Patch:
@@ -57,7 +57,7 @@ public SamplePublisherSubscriber(Subscriber<? super T> actual, Publisher<?> othe
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 if (other.get() == null) {
@@ -97,7 +97,7 @@ boolean setOther(Subscription o) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSampleTimed.java
Patch:
@@ -68,7 +68,7 @@ public SampleTimedSubscriber(Subscriber<? super T> actual, long period, TimeUnit
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 if (timer.get() == null) {
@@ -105,7 +105,7 @@ void cancelTimer() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java
Patch:
@@ -47,7 +47,7 @@ public ScanSubscriber(Subscriber<? super T> actual, BiFunction<T, T, T> accumula
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java
Patch:
@@ -68,7 +68,7 @@ public ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T,
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java
Patch:
@@ -85,7 +85,7 @@ void subscribe() {
 
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             if (once.compareAndSet(false, true)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java
Patch:
@@ -54,7 +54,7 @@ public SingleElementSubscriber(Subscriber<? super T> actual, T defaultValue) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkip.java
Patch:
@@ -44,7 +44,7 @@ public SkipSubscriber(Subscriber<? super T> actual, long n) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 long n = remaining;
                 this.s = s;
                 actual.onSubscribe(this);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLast.java
Patch:
@@ -50,7 +50,7 @@ public SkipLastSubscriber(Subscriber<? super T> actual, int skip) {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
Patch:
@@ -75,7 +75,7 @@ public SkipLastTimedSubscriber(Subscriber<? super T> actual, long time, TimeUnit
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -108,7 +108,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipUntil.java
Patch:
@@ -41,7 +41,7 @@ protected void subscribeActual(Subscriber<? super T> child) {
             Subscription s;
             @Override
             public void onSubscribe(Subscription s) {
-                if (SubscriptionHelper.validateSubscription(this.s, s)) {
+                if (SubscriptionHelper.validate(this.s, s)) {
                     this.s = s;
                     if (frc.setResource(1, s)) {
                         s.request(Long.MAX_VALUE);
@@ -94,7 +94,7 @@ public SkipUntilSubscriber(Subscriber<? super T> actual, ArrayCompositeSubscript
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 if (frc.setResource(0, s)) {
                     if (compareAndSet(false, true)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipWhile.java
Patch:
@@ -44,7 +44,7 @@ public SkipWhileSubscriber(Subscriber<? super T> actual, Predicate<? super T> pr
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java
Patch:
@@ -70,7 +70,7 @@ public SubscribeOnSubscriber(Subscriber<? super T> actual, Scheduler.Worker work
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 lazySet(Thread.currentThread());
                 actual.onSubscribe(this);
@@ -102,7 +102,7 @@ public void onComplete() {
         
         @Override
         public void request(final long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             if (Thread.currentThread() == get()) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -80,7 +80,7 @@ public SwitchMapSubscriber(Subscriber<? super R> actual, Function<? super T, ? e
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }
@@ -147,7 +147,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             BackpressureHelper.add(requested, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java
Patch:
@@ -49,7 +49,7 @@ public TakeSubscriber(Subscriber<? super T> actual, long limit) {
         }
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.subscription, s)) {
+            if (SubscriptionHelper.validate(this.subscription, s)) {
                 subscription = s;
                 actual.onSubscribe(this);
             }
@@ -60,6 +60,7 @@ public void onNext(T t) {
                 boolean stop = remaining == 0;
                 actual.onNext(t);
                 if (stop) {
+                    subscription.cancel();
                     onComplete();
                 }
             }
@@ -76,13 +77,12 @@ public void onError(Throwable t) {
         public void onComplete() {
             if (!done) {
                 done = true;
-                subscription.cancel();
                 actual.onComplete();
             }
         }
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLast.java
Patch:
@@ -57,7 +57,7 @@ public TakeLastSubscriber(Subscriber<? super T> actual, int count) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -85,7 +85,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastOne.java
Patch:
@@ -43,7 +43,7 @@ public TakeLastOneSubscriber(Subscriber<? super T> actual) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimed.java
Patch:
@@ -82,7 +82,7 @@ public TakeLastTimedSubscriber(Subscriber<? super T> actual, long count, long ti
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -136,7 +136,7 @@ void trim(long now, Queue<Object> q) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntil.java
Patch:
@@ -91,7 +91,7 @@ public TakeUntilSubscriber(Subscriber<? super T> actual, ArrayCompositeSubscript
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 if (frc.setResource(0, s)) {
                     if (compareAndSet(false, true)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
Patch:
@@ -44,7 +44,7 @@ public InnerSubscriber(Subscriber<? super T> actual, Predicate<? super T> predic
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeWhile.java
Patch:
@@ -47,7 +47,7 @@ public TakeWhileSubscriber(Subscriber<? super T> actual, Predicate<? super T> pr
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
Patch:
@@ -83,7 +83,7 @@ public DebounceTimedSubscriber(Subscriber<? super T> actual, long timeout, TimeU
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);
@@ -157,7 +157,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeInterval.java
Patch:
@@ -55,7 +55,7 @@ public TimeIntervalSubscriber(Subscriber<? super Timed<T>> actual, TimeUnit unit
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 lastTime = scheduler.now(unit);
                 this.s = s;
                 actual.onSubscribe(this);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
Patch:
@@ -79,7 +79,7 @@ public TimeoutSubscriber(Subscriber<? super T> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -257,7 +257,7 @@ public TimeoutOtherSubscriber(Subscriber<? super T> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
Patch:
@@ -95,7 +95,7 @@ public TimeoutTimedOtherSubscriber(Subscriber<? super T> actual, long timeout, T
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 if (arbiter.setSubscription(s)) {
                     actual.onSubscribe(arbiter);
@@ -221,7 +221,7 @@ public TimeoutTimedSubscriber(Subscriber<? super T> actual, long timeout, TimeUn
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 scheduleTimeout(0L);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java
Patch:
@@ -58,7 +58,7 @@ public IntervalOnceSubscriber(Subscriber<? super Long> actual) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 requested = true;
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java
Patch:
@@ -71,7 +71,7 @@ public ToListSubscriber(Subscriber<? super U> actual, U collection) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
                 s.request(Long.MAX_VALUE);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOn.java
Patch:
@@ -49,7 +49,7 @@ public UnsubscribeSubscriber(Subscriber<? super T> actual, Scheduler scheduler)
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableUsing.java
Patch:
@@ -89,7 +89,7 @@ public UsingSubscriber(Subscriber<? super T> actual, D resource, Consumer<? supe
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
Patch:
@@ -74,7 +74,7 @@ public WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual, Publ
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -86,7 +86,7 @@ public void onSubscribe(Subscription s) {
                 return;
             }
             
-            UnicastProcessor<T> w = UnicastProcessor.create(bufferSize);
+            UnicastProcessor<T> w = new UnicastProcessor<T>(bufferSize);
             
             long r = requested();
             if (r != 0L) {
@@ -217,7 +217,7 @@ void drainLoop() {
                             continue;
                         }
                         
-                        w = UnicastProcessor.create(bufferSize);
+                        w = new UnicastProcessor<T>(bufferSize);
                         
                         long r = requested();
                         if (r != 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java
Patch:
@@ -82,7 +82,7 @@ public WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             
@@ -251,7 +251,7 @@ void drainLoop() {
                         }
                         
 
-                        w = UnicastProcessor.create(bufferSize);
+                        w = new UnicastProcessor<T>(bufferSize);
                         
                         long r = requested();
                         if (r != 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
Patch:
@@ -75,7 +75,7 @@ public WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual, Supp
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validate(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -103,7 +103,7 @@ public void onSubscribe(Subscription s) {
                 return;
             }
             
-            UnicastProcessor<T> w = UnicastProcessor.create(bufferSize);
+            UnicastProcessor<T> w = new UnicastProcessor<T>(bufferSize);
             
             long r = requested();
             if (r != 0L) {
@@ -251,7 +251,7 @@ void drainLoop() {
                             return;
                         }
                         
-                        w = UnicastProcessor.create(bufferSize);
+                        w = new UnicastProcessor<T>(bufferSize);
                         
                         long r = requested();
                         if (r != 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableZipIterable.java
Patch:
@@ -86,7 +86,7 @@ public ZipIterableSubscriber(Subscriber<? super V> actual, Iterator<U> iterator,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
                 actual.onSubscribe(this);
             }

File: src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java
Patch:
@@ -57,7 +57,7 @@ public BasicFuseableConditionalSubscriber(ConditionalSubscriber<? super R> actua
     @SuppressWarnings("unchecked")
     @Override
     public final void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validateSubscription(this.s, s)) {
+        if (SubscriptionHelper.validate(this.s, s)) {
             
             this.s = s;
             if (s instanceof QueueSubscription) {

File: src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java
Patch:
@@ -57,7 +57,7 @@ public BasicFuseableSubscriber(Subscriber<? super R> actual) {
     @SuppressWarnings("unchecked")
     @Override
     public final void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validateSubscription(this.s, s)) {
+        if (SubscriptionHelper.validate(this.s, s)) {
             
             this.s = s;
             if (s instanceof QueueSubscription) {

File: src/main/java/io/reactivex/internal/subscribers/flowable/FullArbiterSubscriber.java
Patch:
@@ -33,7 +33,7 @@ public FullArbiterSubscriber(FullArbiter<T> arbiter) {
 
     @Override
     public void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validateSubscription(this.s, s)) {
+        if (SubscriptionHelper.validate(this.s, s)) {
             this.s = s;
             arbiter.setSubscription(s);
         }

File: src/main/java/io/reactivex/internal/subscribers/flowable/QueueDrainSubscriber.java
Patch:
@@ -206,7 +206,7 @@ public final long produced(long n) {
     }
     
     public final void requested(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (SubscriptionHelper.validate(n)) {
             BackpressureHelper.add(requested, n);
         }
     }

File: src/main/java/io/reactivex/internal/subscribers/flowable/SubscriberResourceWrapper.java
Patch:
@@ -74,7 +74,7 @@ public void onComplete() {
     
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (SubscriptionHelper.validate(n)) {
             subscription.get().request(n);
         }
     }

File: src/main/java/io/reactivex/internal/subscribers/flowable/SubscriptionLambdaSubscriber.java
Patch:
@@ -48,7 +48,7 @@ public void onSubscribe(Subscription s) {
             EmptySubscription.error(e, actual);
             return;
         }
-        if (SubscriptionHelper.validateSubscription(this.s, s)) {
+        if (SubscriptionHelper.validate(this.s, s)) {
             this.s = s;
             actual.onSubscribe(this);
         }

File: src/main/java/io/reactivex/internal/subscribers/flowable/ToNotificationSubscriber.java
Patch:
@@ -30,7 +30,7 @@ public ToNotificationSubscriber(Consumer<? super Try<Optional<Object>>> consumer
     
     @Override
     public void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validateSubscription(this.s, s)) {
+        if (SubscriptionHelper.validate(this.s, s)) {
             this.s = s;
             s.request(Long.MAX_VALUE);
         }

File: src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
Patch:
@@ -50,7 +50,7 @@ public void request(long n) {
         Subscription s = actual.get();
         if (s != null) {
             s.request(n);
-        } else if (SubscriptionHelper.validateRequest(n)) {
+        } else if (SubscriptionHelper.validate(n)) {
             BackpressureHelper.add(this, n);
             s = actual.get();
             if (s != null) {

File: src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java
Patch:
@@ -26,7 +26,7 @@ public final class BooleanSubscription extends AtomicBoolean implements Subscrip
 
     @Override
     public void request(long n) {
-        SubscriptionHelper.validateRequest(n);
+        SubscriptionHelper.validate(n);
     }
     
     @Override

File: src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
Patch:
@@ -59,7 +59,7 @@ public DeferredScalarSubscription(Subscriber<? super T> actual) {
     
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (SubscriptionHelper.validate(n)) {
             for (;;) {
                 long state = get();
                 if (state == HAS_REQUEST_NO_VALUE || state == HAS_REQUEST_HAS_VALUE || state == CANCELLED) {
@@ -100,6 +100,7 @@ public final void complete(T v) {
             if (state == HAS_REQUEST_NO_VALUE) {
                 // no need to CAS in the terminal state because complete() is called at most once
                 if (fusionState == EMPTY) {
+                    value = v;
                     fusionState = HAS_VALUE;
                 }
                 actual.onNext(v);

File: src/main/java/io/reactivex/internal/subscriptions/EmptySubscription.java
Patch:
@@ -28,7 +28,7 @@ public enum EmptySubscription implements QueueSubscription<Object> {
     
     @Override
     public void request(long n) {
-        SubscriptionHelper.validateRequest(n);
+        SubscriptionHelper.validate(n);
     }
     @Override
     public void cancel() {

File: src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
Patch:
@@ -62,7 +62,7 @@ public FullArbiter(Subscriber<? super T> actual, Disposable resource, int capaci
 
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (SubscriptionHelper.validate(n)) {
             BackpressureHelper.add(missedRequested, n);
             queue.offer(REQUEST, REQUEST);
             drain();

File: src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
Patch:
@@ -46,7 +46,7 @@ public ScalarSubscription(Subscriber<? super T> subscriber, T value) {
     
     @Override
     public void request(long n) {
-        if (!SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validate(n)) {
             return;
         }
         if (compareAndSet(NO_REQUEST, REQUESTED)) {

File: src/main/java/io/reactivex/processors/AsyncProcessor.java
Patch:
@@ -327,7 +327,7 @@ public void setError(Throwable e) {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/processors/BehaviorProcessor.java
Patch:
@@ -341,7 +341,7 @@ public BehaviorSubscription(Subscriber<? super T> actual, State<T> state) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -319,7 +319,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -362,7 +362,7 @@ public ReplaySubscription(Subscriber<? super T> actual, State<T> state) {
         }
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validate(n)) {
                 BackpressureHelper.add(requested, n);
                 state.buffer.replay(this);
             }

File: src/main/java/io/reactivex/subscribers/AsyncSubscriber.java
Patch:
@@ -122,7 +122,7 @@ protected void onStart() {
      * @param n the request amount, must be positive
      */
     protected final void request(long n) {
-        if (!SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validate(n)) {
             return;
         }
         Subscription a = s.get();

File: src/main/java/io/reactivex/subscribers/DefaultObserver.java
Patch:
@@ -21,7 +21,7 @@ public abstract class DefaultObserver<T> implements Subscriber<T> {
     private Subscription s;
     @Override
     public final void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validateSubscription(this.s, s)) {
+        if (SubscriptionHelper.validate(this.s, s)) {
             this.s = s;
             onStart();
         }

File: src/main/java/io/reactivex/subscribers/SerializedSubscriber.java
Patch:
@@ -52,7 +52,7 @@ public SerializedSubscriber(Subscriber<? super T> actual, boolean delayError) {
     }
     @Override
     public void onSubscribe(Subscription s) {
-        if (SubscriptionHelper.validateSubscription(this.subscription, s)) {
+        if (SubscriptionHelper.validate(this.subscription, s)) {
             this.subscription = s;
             actual.onSubscribe(this);
         }

File: src/main/java/io/reactivex/subscribers/Subscribers.java
Patch:
@@ -191,7 +191,7 @@ public static <T> Subscriber<T> create(
             Subscription s;
             @Override
             public void onSubscribe(Subscription s) {
-                if (!SubscriptionHelper.validateSubscription(this.s, s)) {
+                if (!SubscriptionHelper.validate(this.s, s)) {
                     return;
                 }
                 this.s = s;

File: src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java
Patch:
@@ -47,7 +47,7 @@ private FirehoseNoBackpressure(AtomicInteger counter, Subscriber<? super Integer
 
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validate(n)) {
                 return;
             }
             if (compareAndSet(false, true)) {
@@ -688,7 +688,7 @@ public void subscribe(final Subscriber<? super Integer> s) {
 
                     @Override
                     public void request(long n) {
-                        if (!SubscriptionHelper.validateRequest(n)) {
+                        if (!SubscriptionHelper.validate(n)) {
                             return;
                         }
                         if (threadsSeen != null) {

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingOperatorNextTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.flowables.BlockingFlowable;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.processors.*;
 import io.reactivex.schedulers.Schedulers;
 
@@ -237,7 +237,7 @@ public void testNoBufferingOrBlockingOfSequence() throws Throwable {
 
             @Override
             public void subscribe(final Subscriber<? super Integer> o) {
-                o.onSubscribe(EmptySubscription.INSTANCE);
+                o.onSubscribe(new BooleanSubscription());
                 new Thread(new Runnable() {
 
                     @Override

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingOperatorToIteratorTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
 
 public class BlockingOperatorToIteratorTest {
 
@@ -51,7 +51,7 @@ public void testToIteratorWithException() {
 
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 observer.onNext("one");
                 observer.onError(new TestException());
             }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -87,7 +87,7 @@ public void testCache() throws InterruptedException {
 
             @Override
             public void subscribe(final Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 new Thread(new Runnable() {
 
                     @Override
@@ -220,7 +220,7 @@ public void testNoMissingBackpressureException() {
         Flowable<Integer> firehose = Flowable.create(new Publisher<Integer>() {
             @Override
             public void subscribe(Subscriber<? super Integer> t) {
-                t.onSubscribe(EmptySubscription.INSTANCE);
+                t.onSubscribe(new BooleanSubscription());
                 for (int i = 0; i < m; i++) {
                     t.onNext(i);
                 }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnSubscribeTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 
 public class FlowableDoOnSubscribeTest {
 
@@ -71,7 +71,7 @@ public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
 
             @Override
             public void subscribe(Subscriber<? super Integer> s) {
-                s.onSubscribe(EmptySubscription.INSTANCE);
+                s.onSubscribe(new BooleanSubscription());
                 onSubscribed.incrementAndGet();
                 sref.set(s);
             }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeMaxConcurrentTest.java
Patch:
@@ -24,7 +24,7 @@
 
 import io.reactivex.*;
 import io.reactivex.internal.schedulers.IoScheduler;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -97,7 +97,7 @@ private static class SubscriptionCheckObservable implements Publisher<String> {
 
         @Override
         public void subscribe(final Subscriber<? super String> t1) {
-            t1.onSubscribe(EmptySubscription.INSTANCE);
+            t1.onSubscribe(new BooleanSubscription());
             new Thread(new Runnable() {
 
                 @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.Optional;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.DefaultObserver;
@@ -541,7 +541,7 @@ public void testQueueFullEmitsError() {
 
             @Override
             public void subscribe(Subscriber<? super Integer> o) {
-                o.onSubscribe(EmptySubscription.INSTANCE);
+                o.onSubscribe(new BooleanSubscription());
                 for (int i = 0; i < Flowable.bufferSize() + 10; i++) {
                     o.onNext(i);
                 }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorResumeNextViaFunctionTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.*;
 import io.reactivex.Flowable.Operator;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -39,7 +39,7 @@ public void testResumeNextWithSynchronousExecution() {
 
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 observer.onNext("one");
                 observer.onError(new Throwable("injected failure"));
                 observer.onNext("two");
@@ -285,7 +285,7 @@ public TestObservable(Subscription s, String... values) {
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
             System.out.println("TestObservable subscribed to ...");
-            observer.onSubscribe(EmptySubscription.INSTANCE);
+            observer.onSubscribe(new BooleanSubscription());
             t = new Thread(new Runnable() {
 
                 @Override

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -188,7 +188,7 @@ public TestObservable(String... values) {
 
         @Override
         public void subscribe(final Subscriber<? super String> subscriber) {
-            subscriber.onSubscribe(EmptySubscription.INSTANCE);
+            subscriber.onSubscribe(new BooleanSubscription());
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableOnExceptionResumeNextViaObservableTest.java
Patch:
@@ -23,7 +23,7 @@
 
 import io.reactivex.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -225,7 +225,7 @@ public TestObservable(String... values) {
 
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
-            observer.onSubscribe(EmptySubscription.INSTANCE);
+            observer.onSubscribe(new BooleanSubscription());
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java
Patch:
@@ -26,7 +26,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -39,7 +39,7 @@ public void testPublish() throws InterruptedException {
 
             @Override
             public void subscribe(final Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 new Thread(new Runnable() {
 
                     @Override
@@ -370,7 +370,7 @@ public void testConnectIsIdempotent() {
         Flowable<Integer> source = Flowable.create(new Publisher<Integer>() {
             @Override
             public void subscribe(Subscriber<? super Integer> t) {
-                t.onSubscribe(EmptySubscription.INSTANCE);
+                t.onSubscribe(new BooleanSubscription());
                 calls.getAndIncrement();
             }
         });

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java
Patch:
@@ -27,7 +27,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -70,7 +70,7 @@ public void testRepeatTakeWithSubscribeOn() throws InterruptedException {
 
             @Override
             public void subscribe(Subscriber<? super Integer> sub) {
-                sub.onSubscribe(EmptySubscription.INSTANCE);
+                sub.onSubscribe(new BooleanSubscription());
                 counter.incrementAndGet();
                 sub.onNext(1);
                 sub.onNext(2);

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -32,7 +32,7 @@
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.operators.flowable.FlowableReplay.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.TestSubscriber;
@@ -902,7 +902,7 @@ public void testCache() throws InterruptedException {
 
             @Override
             public void subscribe(final Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 new Thread(new Runnable() {
 
                     @Override
@@ -1037,7 +1037,7 @@ public void testNoMissingBackpressureException() {
         Flowable<Integer> firehose = Flowable.create(new Publisher<Integer>() {
             @Override
             public void subscribe(Subscriber<? super Integer> t) {
-                t.onSubscribe(EmptySubscription.INSTANCE);
+                t.onSubscribe(new BooleanSubscription());
                 for (int i = 0; i < m; i++) {
                     t.onNext(i);
                 }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
 
@@ -47,7 +47,7 @@ public void testSample() {
         Flowable<Long> source = Flowable.create(new Publisher<Long>() {
             @Override
             public void subscribe(final Subscriber<? super Long> observer1) {
-                observer1.onSubscribe(EmptySubscription.INSTANCE);
+                observer1.onSubscribe(new BooleanSubscription());
                 innerScheduler.schedule(new Runnable() {
                     @Override
                     public void run() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSerializeTest.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.subscribers.DefaultObserver;
 
 public class FlowableSerializeTest {
@@ -220,7 +220,7 @@ public TestSingleThreadedObservable(final String... values) {
 
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
-            observer.onSubscribe(EmptySubscription.INSTANCE);
+            observer.onSubscribe(new BooleanSubscription());
             System.out.println("TestSingleThreadedObservable subscribed to ...");
             t = new Thread(new Runnable() {
 
@@ -271,7 +271,7 @@ public TestMultiThreadedObservable(String... values) {
 
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
-            observer.onSubscribe(EmptySubscription.INSTANCE);
+            observer.onSubscribe(new BooleanSubscription());
             System.out.println("TestMultiThreadedObservable subscribed to ...");
             final NullPointerException npe = new NullPointerException();
             t = new Thread(new Runnable() {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOnTest.java
Patch:
@@ -44,7 +44,7 @@ public void testIssue813() throws InterruptedException {
             @Override
             public void subscribe(
                     final Subscriber<? super Integer> subscriber) {
-                subscriber.onSubscribe(EmptySubscription.INSTANCE);
+                subscriber.onSubscribe(new BooleanSubscription());
                 scheduled.countDown();
                 try {
                     try {
@@ -96,7 +96,7 @@ public void testOnError() {
 
             @Override
             public void subscribe(Subscriber<? super String> s) {
-                s.onSubscribe(EmptySubscription.INSTANCE);
+                s.onSubscribe(new BooleanSubscription());
                 s.onError(new RuntimeException("fail"));
             }
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
Patch:
@@ -112,7 +112,7 @@ public void testTakeDoesntLeakErrors() {
         Flowable<String> source = Flowable.create(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 observer.onNext("one");
                 observer.onError(new Throwable("test failed"));
             }
@@ -240,7 +240,7 @@ public TestObservableFunc(String... values) {
 
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
-            observer.onSubscribe(EmptySubscription.INSTANCE);
+            observer.onSubscribe(new BooleanSubscription());
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Predicate;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.*;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -103,7 +103,7 @@ public void testTakeWhileDoesntLeakErrors() {
         Flowable<String> source = Flowable.create(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 observer.onNext("one");
                 observer.onError(new Throwable("test failed"));
             }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
Patch:
@@ -24,7 +24,7 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
 
@@ -46,7 +46,7 @@ public void testThrottlingWithCompleted() {
         Flowable<String> source = Flowable.create(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 publishNext(observer, 100, "one");    // publish as it's first
                 publishNext(observer, 300, "two");    // skip as it's last within the first 400
                 publishNext(observer, 900, "three");   // publish
@@ -74,7 +74,7 @@ public void testThrottlingWithError() {
         Flowable<String> source = Flowable.create(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 Exception error = new TestException();
                 publishNext(observer, 100, "one");    // Should be published since it is first
                 publishNext(observer, 200, "two");    // Should be skipped since onError will arrive before the timeout expires

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
 import io.reactivex.subscribers.TestSubscriber;
@@ -242,7 +242,7 @@ public void run() {
 
                     @Override
                     public void subscribe(Subscriber<? super String> subscriber) {
-                        subscriber.onSubscribe(EmptySubscription.INSTANCE);
+                        subscriber.onSubscribe(new BooleanSubscription());
                         try {
                             timeoutSetuped.countDown();
                             exit.await();

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java
Patch:
@@ -30,7 +30,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -328,7 +328,7 @@ public Flowable<Integer> apply(Integer t1) {
                     return Flowable.create(new Publisher<Integer>() {
                         @Override
                         public void subscribe(Subscriber<? super Integer> subscriber) {
-                            subscriber.onSubscribe(EmptySubscription.INSTANCE);
+                            subscriber.onSubscribe(new BooleanSubscription());
                             enteredTimeoutOne.countDown();
                             // force the timeout message be sent after observer.onNext(2)
                             while (true) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
Patch:
@@ -24,7 +24,7 @@
 
 import io.reactivex.*;
 import io.reactivex.functions.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.schedulers.TestScheduler;
 import io.reactivex.subscribers.DefaultObserver;
 import io.reactivex.subscribers.TestSubscriber;
@@ -49,7 +49,7 @@ public void testTimedAndCount() {
         Flowable<String> source = Flowable.create(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 push(observer, "one", 10);
                 push(observer, "two", 90);
                 push(observer, "three", 110);
@@ -83,7 +83,7 @@ public void testTimed() {
         Flowable<String> source = Flowable.create(new Publisher<String>() {
             @Override
             public void subscribe(Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 push(observer, "one", 98);
                 push(observer, "two", 99);
                 push(observer, "three", 99); // FIXME happens after the window is open

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
Patch:
@@ -623,7 +623,7 @@ private static class TestObservable implements Publisher<String> {
         public void subscribe(Subscriber<? super String> observer) {
             // just store the variable where it can be accessed so we can manually trigger it
             this.observer = observer;
-            observer.onSubscribe(EmptySubscription.INSTANCE);
+            observer.onSubscribe(new BooleanSubscription());
         }
 
     }

File: src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java
Patch:
@@ -368,7 +368,7 @@ public final void testConcurrentOnNextFailsValidation() throws InterruptedExcept
 
             @Override
             public void subscribe(final Subscriber<? super String> observer) {
-                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onSubscribe(new BooleanSubscription());
                 for (int i = 0; i < count; i++) {
                     final int v = i;
                     new Thread(new Runnable() {
@@ -430,7 +430,7 @@ public Flowable<String> apply(final String v) {
 
                             @Override
                             public void subscribe(Subscriber<? super String> observer) {
-                                observer.onSubscribe(EmptySubscription.INSTANCE);
+                                observer.onSubscribe(new BooleanSubscription());
                                 observer.onNext("value_after_map-" + v);
                                 observer.onComplete();
                             }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -721,7 +721,7 @@ public void subscribe(Subscriber<? super String> s) {
         ts.assertValues("hello", "hello");
     }
 
-    @Test(timeout = 10000)
+    @Test(timeout = 30000)
     public void testIssue2890NoStackoverflow() throws InterruptedException {
         final ExecutorService executor = Executors.newFixedThreadPool(2);
         final Scheduler sch = Schedulers.from(executor);
@@ -767,7 +767,7 @@ public void onError(Throwable e) {
             }
         });
 
-        executor.awaitTermination(12000, TimeUnit.MILLISECONDS);
+        executor.awaitTermination(20000, TimeUnit.MILLISECONDS);
         
         assertEquals(n, counter.get());
     }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
Patch:
@@ -1003,7 +1003,7 @@ public void testAsyncComeAndGo() {
                 .subscribeOn(Schedulers.io());
         Flowable<Long> cached = source.replay().autoConnect();
         
-        Flowable<Long> output = cached.observeOn(Schedulers.computation());
+        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);
         
         List<TestSubscriber<Long>> list = new ArrayList<TestSubscriber<Long>>(100);
         for (int i = 0; i < 100; i++) {

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java
Patch:
@@ -188,7 +188,7 @@ public void accept(Integer t1) {
         ts.assertTerminated();
         ts.assertValues(1, 2, 3, 4, 5, 5, 6, 7, 8, 9);
         // make sure we don't emit all values ... the unsubscribe should propagate
-        assertTrue(count.get() < 100000);
+        // assertTrue(count.get() < 100000); // disabled: a small hiccup in the consumption may allow the source to run to completion
     }
 
     private List<String> list(String... args) {

File: src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java
Patch:
@@ -679,7 +679,7 @@ public void subscribe(Observer<? super String> s) {
         ts.assertValues("hello", "hello");
     }
 
-    @Test(timeout = 10000)
+    @Test(timeout = 30000)
     public void testIssue2890NoStackoverflow() throws InterruptedException {
         final ExecutorService executor = Executors.newFixedThreadPool(2);
         final Scheduler sch = Schedulers.from(executor);
@@ -725,7 +725,7 @@ public void onError(Throwable e) {
             }
         });
 
-        executor.awaitTermination(12000, TimeUnit.MILLISECONDS);
+        executor.awaitTermination(20000, TimeUnit.MILLISECONDS);
         
         assertEquals(n, counter.get());
     }

File: src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
Patch:
@@ -185,7 +185,7 @@ public void accept(Integer t1) {
         ts.assertTerminated();
         ts.assertValues(1, 2, 3, 4, 5, 5, 6, 7, 8, 9);
         // make sure we don't emit all values ... the unsubscribe should propagate
-        assertTrue(count.get() < 100000);
+        // assertTrue(count.get() < 100000); // disabled: a small hiccup in the consumption may allow the source to run to completion
     }
 
     private List<String> list(String... args) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java
Patch:
@@ -59,10 +59,9 @@ public AllSubscriber(Subscriber<? super Boolean> actual, Predicate<? super T> pr
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java
Patch:
@@ -56,10 +56,9 @@ public AnySubscriber(Subscriber<? super Boolean> actual, Predicate<? super T> pr
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
Patch:
@@ -67,7 +67,7 @@ public BufferBondarySupplierSubscriber(Subscriber<? super U> actual, Supplier<U>
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
Patch:
@@ -64,7 +64,7 @@ public BufferExactBondarySubscriber(Subscriber<? super U> actual, Supplier<U> bu
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
Patch:
@@ -106,7 +106,7 @@ public BufferExactUnboundedSubscriber(
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -283,7 +283,7 @@ public BufferSkipBoundedSubscriber(Subscriber<? super U> actual,
     
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -459,7 +459,7 @@ public BufferExactBoundedSubscriber(
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java
Patch:
@@ -63,10 +63,9 @@ public CollectSubscriber(Subscriber<? super U> actual, U u, BiConsumer<? super U
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java
Patch:
@@ -72,10 +72,9 @@ public DelaySubscriber(Subscriber<? super T> actual, long delay, TimeUnit unit,
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java
Patch:
@@ -136,10 +136,9 @@ public DistinctSubscriber(Subscriber<? super T> actual, Function<? super T, K> k
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(s);
             }
-            this.s = s;
-            actual.onSubscribe(s);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java
Patch:
@@ -71,10 +71,9 @@ public DoOnEachSubscriber(
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(s);
             }
-            this.s = s;
-            actual.onSubscribe(s);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFilter.java
Patch:
@@ -47,10 +47,9 @@ public FilterSubscriber(Subscriber<? super T> actual, Predicate<? super T> filte
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.subscription, s)) {
-                return;
+                subscription = s;
+                actual.onSubscribe(s);
             }
-            subscription = s;
-            actual.onSubscribe(s);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
Patch:
@@ -49,10 +49,9 @@ public MapperSubscriber(Subscriber<? super U> actual, Function<? super T, ? exte
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.subscription, s)) {
-                return;
+                subscription = s;
+                actual.onSubscribe(s);
             }
-            subscription = s;
-            actual.onSubscribe(s);
         }
         @Override
         public void onNext(T t) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
Patch:
@@ -83,10 +83,9 @@ public MapNotificationSubscriber(Subscriber<? super Publisher<? extends R>> actu
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMaterialize.java
Patch:
@@ -59,10 +59,9 @@ public MaterializeSubscriber(Subscriber<? super Try<Optional<T>>> actual) {
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -63,10 +63,9 @@ public OnErrorReturnSubscriber(Subscriber<? super T> actual, Function<? super Th
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
Patch:
@@ -51,10 +51,9 @@ private ConnectionSubscriber(Subscriber<? super T> subscriber,
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                subscriber.onSubscribe(this);
             }
-            this.s = s;
-            subscriber.onSubscribe(this);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java
Patch:
@@ -48,10 +48,9 @@ public ScanSubscriber(Subscriber<? super T> actual, BiFunction<T, T, T> accumula
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(s);
             }
-            this.s = s;
-            actual.onSubscribe(s);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java
Patch:
@@ -68,10 +68,9 @@ public ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T,
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -78,10 +78,9 @@ public SwitchMapSubscriber(Subscriber<? super R> actual, Function<? super T, ? e
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeWhile.java
Patch:
@@ -48,10 +48,9 @@ public TakeWhileSubscriber(Subscriber<? super T> actual, Predicate<? super T> pr
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(s);
             }
-            this.s = s;
-            actual.onSubscribe(s);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
Patch:
@@ -79,7 +79,7 @@ public TimeoutSubscriber(Subscriber<? super T> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -257,7 +257,7 @@ public TimeoutOtherSubscriber(Subscriber<? super T> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOn.java
Patch:
@@ -50,10 +50,9 @@ public UnsubscribeSubscriber(Subscriber<? super T> actual, Scheduler scheduler)
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableUsing.java
Patch:
@@ -90,10 +90,9 @@ public UsingSubscriber(Subscriber<? super T> actual, D resource, Consumer<? supe
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(this);
             }
-            this.s = s;
-            actual.onSubscribe(this);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
Patch:
@@ -74,7 +74,7 @@ public WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual, Publ
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java
Patch:
@@ -83,7 +83,7 @@ public WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
Patch:
@@ -75,7 +75,7 @@ public WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual, Supp
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
Patch:
@@ -106,7 +106,7 @@ public WindowExactUnboundedSubscriber(Subscriber<? super Flowable<T>> actual, lo
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;
@@ -337,7 +337,7 @@ public WindowExactBoundedSubscriber(
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             
@@ -664,7 +664,7 @@ public WindowSkipSubscriber(Subscriber<? super Flowable<T>> actual,
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+            if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableZipIterable.java
Patch:
@@ -87,10 +87,9 @@ public ZipIterableSubscriber(Subscriber<? super V> actual, Iterator<U> iterator,
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
-                return;
+                this.s = s;
+                actual.onSubscribe(s);
             }
-            this.s = s;
-            actual.onSubscribe(s);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/subscribers/flowable/FullArbiterSubscriber.java
Patch:
@@ -34,10 +34,9 @@ public FullArbiterSubscriber(FullArbiter<T> arbiter) {
     @Override
     public void onSubscribe(Subscription s) {
         if (SubscriptionHelper.validateSubscription(this.s, s)) {
-            return;
+            this.s = s;
+            arbiter.setSubscription(s);
         }
-        this.s = s;
-        arbiter.setSubscription(s);
     }
 
     @Override

File: src/main/java/io/reactivex/internal/subscribers/flowable/SubscriptionLambdaSubscriber.java
Patch:
@@ -49,10 +49,9 @@ public void onSubscribe(Subscription s) {
             return;
         }
         if (SubscriptionHelper.validateSubscription(this.s, s)) {
-            return;
+            this.s = s;
+            actual.onSubscribe(this);
         }
-        this.s = s;
-        actual.onSubscribe(this);
     }
     
     @Override

File: src/main/java/io/reactivex/internal/subscribers/flowable/ToNotificationSubscriber.java
Patch:
@@ -31,10 +31,9 @@ public ToNotificationSubscriber(Consumer<? super Try<Optional<Object>>> consumer
     @Override
     public void onSubscribe(Subscription s) {
         if (SubscriptionHelper.validateSubscription(this.s, s)) {
-            return;
+            this.s = s;
+            s.request(Long.MAX_VALUE);
         }
-        this.s = s;
-        s.request(Long.MAX_VALUE);
     }
     
     @Override

File: src/main/java/io/reactivex/subscribers/DefaultObserver.java
Patch:
@@ -22,10 +22,9 @@ public abstract class DefaultObserver<T> implements Subscriber<T> {
     @Override
     public final void onSubscribe(Subscription s) {
         if (SubscriptionHelper.validateSubscription(this.s, s)) {
-            return;
+            this.s = s;
+            onStart();
         }
-        this.s = s;
-        onStart();
     }
     
     protected final Subscription subscription() {

File: src/main/java/io/reactivex/subscribers/Subscribers.java
Patch:
@@ -191,7 +191,7 @@ public static <T> Subscriber<T> create(
             Subscription s;
             @Override
             public void onSubscribe(Subscription s) {
-                if (SubscriptionHelper.validateSubscription(this.s, s)) {
+                if (!SubscriptionHelper.validateSubscription(this.s, s)) {
                     return;
                 }
                 this.s = s;

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java
Patch:
@@ -126,7 +126,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java
Patch:
@@ -119,7 +119,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
Patch:
@@ -279,7 +279,7 @@ public ReplaySubscription(Subscriber<? super T> child, CacheState<T> state) {
         }
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java
Patch:
@@ -93,9 +93,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                s.request(Long.MAX_VALUE);
             }
-            s.request(Long.MAX_VALUE);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
Patch:
@@ -129,10 +129,9 @@ public void subscribe(Publisher<? extends T>[] sources) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java
Patch:
@@ -72,7 +72,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 s.request(Long.MAX_VALUE);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
Patch:
@@ -137,10 +137,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
Patch:
@@ -137,9 +137,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java
Patch:
@@ -103,7 +103,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 s.request(Long.MAX_VALUE);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
Patch:
@@ -304,10 +304,9 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromArray.java
Patch:
@@ -57,7 +57,7 @@ public ArraySourceSubscription(T[] array, Subscriber<? super T> subscriber) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) == 0L) {
@@ -137,7 +137,7 @@ public ConditionalArraySourceSubscription(T[] array, ConditionalSubscriber<? sup
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) == 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
Patch:
@@ -66,7 +66,7 @@ public IteratorSourceSubscription(Iterator<? extends T> it, Subscriber<? super T
         }
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) != 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableGenerate.java
Patch:
@@ -76,7 +76,7 @@ public GeneratorSubscription(Subscriber<? super T> actual,
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) != 0L) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
Patch:
@@ -68,10 +68,8 @@ public IntervalSubscriber(Subscriber<? super Long> actual) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
Patch:
@@ -74,7 +74,7 @@ public IntervalRangeSubscriber(Subscriber<? super Long> actual, long start, long
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 BackpressureHelper.add(this, n);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
Patch:
@@ -183,7 +183,7 @@ void tryEmit(Publisher<? extends R> p) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableMaterialize.java
Patch:
@@ -122,7 +122,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(this, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
Patch:
@@ -157,10 +157,9 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                schedule();
             }
-            BackpressureHelper.add(requested, n);
-            schedule();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
Patch:
@@ -124,10 +124,9 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureDrop.java
Patch:
@@ -118,9 +118,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatest.java
Patch:
@@ -89,7 +89,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturn.java
Patch:
@@ -136,7 +136,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(this, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
Patch:
@@ -612,7 +612,7 @@ public InnerSubscription(ReplaySubscriber<T> parent, Subscriber<? super T> child
         @Override
         public void request(long n) {
             // ignore negative requests
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             // In general, RxJava doesn't prevent concurrent requests (with each other or with

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java
Patch:
@@ -100,10 +100,8 @@ boolean setOther(Subscription o) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
             }
-            
-            BackpressureHelper.add(requested, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSampleTimed.java
Patch:
@@ -108,10 +108,8 @@ void cancelTimer() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
             }
-            
-            BackpressureHelper.add(requested, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java
Patch:
@@ -86,7 +86,7 @@ void subscribe() {
 
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (once.compareAndSet(false, true)) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java
Patch:
@@ -108,9 +108,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                s.request(Long.MAX_VALUE);
             }
-            s.request(Long.MAX_VALUE);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
Patch:
@@ -110,10 +110,9 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java
Patch:
@@ -105,7 +105,7 @@ public void onComplete() {
         
         @Override
         public void request(final long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (Thread.currentThread() == get()) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
Patch:
@@ -145,7 +145,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(requested, n);

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java
Patch:
@@ -87,7 +87,7 @@ public void onComplete() {
         }
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLast.java
Patch:
@@ -90,10 +90,9 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastOne.java
Patch:
@@ -91,7 +91,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimed.java
Patch:
@@ -138,10 +138,9 @@ void trim(long now, Queue<Object> q) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
Patch:
@@ -156,9 +156,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java
Patch:
@@ -62,7 +62,7 @@ public IntervalOnceSubscriber(Subscriber<? super Long> actual) {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 requested = true;
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java
Patch:
@@ -101,7 +101,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 s.request(Long.MAX_VALUE);
             }
         }

File: src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
Patch:
@@ -117,7 +117,7 @@ public void subscribe(Publisher<? extends T>[] sources, int bufferSize) {
         
         @Override
         public void request(long n) {
-            if (!SubscriptionHelper.validateRequest(n)) {
+            if (SubscriptionHelper.validateRequest(n)) {
                 BackpressureHelper.add(requested, n);
                 drain();
             }

File: src/main/java/io/reactivex/internal/subscribers/flowable/QueueDrainSubscriber.java
Patch:
@@ -207,9 +207,8 @@ public final long produced(long n) {
     
     public final void requested(long n) {
         if (SubscriptionHelper.validateRequest(n)) {
-            return;
+            BackpressureHelper.add(requested, n);
         }
-        BackpressureHelper.add(requested, n);
     }
     
     public void drain(boolean delayError) {

File: src/main/java/io/reactivex/internal/subscribers/flowable/SubscriberResourceWrapper.java
Patch:
@@ -78,9 +78,8 @@ public void onComplete() {
     @Override
     public void request(long n) {
         if (SubscriptionHelper.validateRequest(n)) {
-            return;
+            subscription.get().request(n);
         }
-        subscription.get().request(n);
     }
     
     @Override

File: src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java
Patch:
@@ -26,9 +26,7 @@ public final class BooleanSubscription extends AtomicBoolean implements Subscrip
 
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
-            return;
-        }
+        SubscriptionHelper.validateRequest(n);
     }
     
     @Override

File: src/main/java/io/reactivex/internal/subscriptions/ScalarAsyncSubscription.java
Patch:
@@ -42,7 +42,7 @@ public ScalarAsyncSubscription(Subscriber<? super T> subscriber) {
     
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validateRequest(n)) {
             return;
         }
         for (;;) {

File: src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
Patch:
@@ -38,7 +38,7 @@ public ScalarSubscription(Subscriber<? super T> subscriber, T value) {
     
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validateRequest(n)) {
             return;
         }
         if (compareAndSet(false, true)) {

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -62,7 +62,7 @@ private long addRequested(long n) {
     
     @Override
     public void request(final long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validateRequest(n)) {
             return;
         }
         if (cancelled) {

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
Patch:
@@ -62,9 +62,9 @@ public static void reportSubscriptionSet() {
     public static boolean validateRequest(long n) {
         if (n <= 0) {
             RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
-            return true;
+            return false;
         }
-        return false;
+        return true;
     }
     
     /** Singleton instance of a function which calls cancel on the supplied Subscription. */

File: src/main/java/io/reactivex/processors/AsyncProcessor.java
Patch:
@@ -328,7 +328,7 @@ public void setError(Throwable e) {
         
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/processors/BehaviorProcessor.java
Patch:
@@ -343,10 +343,8 @@ public BehaviorSubscription(Subscriber<? super T> actual, State<T> state) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -320,9 +320,8 @@ public void onComplete() {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(this, n);
             }
-            BackpressureHelper.add(this, n);
         }
         
         @Override

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -364,10 +364,9 @@ public ReplaySubscription(Subscriber<? super T> actual, State<T> state) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                state.buffer.replay(this);
             }
-            BackpressureHelper.add(requested, n);
-            state.buffer.replay(this);
         }
         
         @Override

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -187,10 +187,9 @@ public void subscribe(Subscriber<? super T> s) {
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
-                return;
+                BackpressureHelper.add(requested, n);
+                drain();
             }
-            BackpressureHelper.add(requested, n);
-            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/subscribers/AsyncSubscriber.java
Patch:
@@ -122,7 +122,7 @@ protected void onStart() {
      * @param n the request amount, must be positive
      */
     protected final void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validateRequest(n)) {
             return;
         }
         Subscription a = s.get();

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -201,7 +201,7 @@ public void onComplete() {
     
     @Override
     public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
+        if (!SubscriptionHelper.validateRequest(n)) {
             return;
         }
         Subscription s = subscription.get();

File: src/test/java/io/reactivex/flowable/BackpressureTests.java
Patch:
@@ -47,7 +47,7 @@ private FirehoseNoBackpressure(AtomicInteger counter, Subscriber<? super Integer
 
         @Override
         public void request(long n) {
-            if (SubscriptionHelper.validateRequest(n)) {
+            if (!SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (compareAndSet(false, true)) {
@@ -688,7 +688,7 @@ public void subscribe(final Subscriber<? super Integer> s) {
 
                     @Override
                     public void request(long n) {
-                        if (SubscriptionHelper.validateRequest(n)) {
+                        if (!SubscriptionHelper.validateRequest(n)) {
                             return;
                         }
                         if (threadsSeen != null) {

File: src/main/java/io/reactivex/processors/AsyncProcessor.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @param <T> the value type
  */
-public final class AsyncProcessor<T> extends FlowProcessor<T, T> {
+public final class AsyncProcessor<T> extends FlowProcessor<T> {
     
     /**
      * Constructs an empty AsyncSubject.

File: src/main/java/io/reactivex/processors/BehaviorProcessor.java
Patch:
@@ -25,7 +25,7 @@
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class BehaviorProcessor<T> extends FlowProcessor<T, T> {
+public final class BehaviorProcessor<T> extends FlowProcessor<T> {
 
     public static <T> BehaviorProcessor<T> create() {
         return new BehaviorProcessor<T>(new State<T>());

File: src/main/java/io/reactivex/processors/PublishProcessor.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @param <T> the value type multicast to Subscribers.
  */
-public final class PublishProcessor<T> extends FlowProcessor<T, T> {
+public final class PublishProcessor<T> extends FlowProcessor<T> {
     
     /**
      * Constructs a PublishSubject.

File: src/main/java/io/reactivex/processors/ReplayProcessor.java
Patch:
@@ -34,7 +34,7 @@
  * 
  * @param <T> the value type
  */
-public final class ReplayProcessor<T> extends FlowProcessor<T, T> {
+public final class ReplayProcessor<T> extends FlowProcessor<T> {
 
     public static <T> ReplayProcessor<T> create() {
         return create(16);

File: src/main/java/io/reactivex/processors/UnicastProcessor.java
Patch:
@@ -36,7 +36,7 @@
  * 
  * @param <T> the value type unicasted
  */
-public final class UnicastProcessor<T> extends FlowProcessor<T, T> {
+public final class UnicastProcessor<T> extends FlowProcessor<T> {
     
     /**
      * Creates an UnicastSubject with an internal buffer capacity hint 16.

File: src/main/java/io/reactivex/subjects/AsyncSubject.java
Patch:
@@ -33,7 +33,7 @@
  * @param <T> the value type
  */
 
-public final class AsyncSubject<T> extends Subject<T, T> {
+public final class AsyncSubject<T> extends Subject<T> {
     public static <T> AsyncSubject<T> create() {
         return new AsyncSubject<T>();
     }

File: src/main/java/io/reactivex/subjects/BehaviorSubject.java
Patch:
@@ -24,7 +24,7 @@
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class BehaviorSubject<T> extends Subject<T, T> {
+public final class BehaviorSubject<T> extends Subject<T> {
 
     public static <T> BehaviorSubject<T> create() {
         State<T> state = new State<T>();

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.internal.util.NotificationLite;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class PublishSubject<T> extends Subject<T, T> {
+public final class PublishSubject<T> extends Subject<T> {
     public static <T> PublishSubject<T> create() {
         return new PublishSubject<T>();
     }

File: src/main/java/io/reactivex/subjects/ReplaySubject.java
Patch:
@@ -33,7 +33,7 @@
  * 
  * @param <T> the value type
  */
-public final class ReplaySubject<T> extends Subject<T, T> {
+public final class ReplaySubject<T> extends Subject<T> {
 
     public static <T> ReplaySubject<T> create() {
         return create(16);

File: src/main/java/io/reactivex/subjects/UnicastSubject.java
Patch:
@@ -35,7 +35,7 @@
  * 
  * @param <T> the value type unicasted
  */
-public final class UnicastSubject<T> extends Subject<T, T> {
+public final class UnicastSubject<T> extends Subject<T> {
     
     /**
      * Creates an UnicastSubject with an internal buffer capacity hint 16.

File: src/test/java/io/reactivex/flowable/ObservableTests.java
Patch:
@@ -1019,7 +1019,7 @@ public String apply(Integer v) {
     
     @Test
     public void testErrorThrownIssue1685() {
-        FlowProcessor<Object, Object> subject = ReplayProcessor.create();
+        FlowProcessor<Object> subject = ReplayProcessor.create();
 
         Flowable.error(new RuntimeException("oops"))
             .materialize()

File: src/test/java/io/reactivex/internal/operators/flowable/BlockingOperatorMostRecentTest.java
Patch:
@@ -35,7 +35,7 @@ public void testMostRecentNull() {
 
     @Test
     public void testMostRecent() {
-        FlowProcessor<String, String> s = PublishProcessor.create();
+        FlowProcessor<String> s = PublishProcessor.create();
 
         Iterator<String> it = mostRecent(s, "default").iterator();
 
@@ -60,7 +60,7 @@ public void testMostRecent() {
 
     @Test(expected = TestException.class)
     public void testMostRecentWithException() {
-        FlowProcessor<String, String> s = PublishProcessor.create();
+        FlowProcessor<String> s = PublishProcessor.create();
 
         Iterator<String> it = mostRecent(s, "default").iterator();
 

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
Patch:
@@ -732,7 +732,7 @@ public Flowable<Integer> apply(Integer t) {
                 Flowable<Integer> observable = Flowable.just(t)
                         .subscribeOn(sch)
                 ;
-                FlowProcessor<Integer, Integer> subject = UnicastProcessor.create();
+                FlowProcessor<Integer> subject = UnicastProcessor.create();
                 observable.subscribe(subject);
                 return subject;
             }

File: src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java
Patch:
@@ -51,7 +51,7 @@ public boolean test(Integer input) {
 
     @Test
     public void testTakeWhileOnSubject1() {
-        FlowProcessor<Integer, Integer> s = PublishProcessor.create();
+        FlowProcessor<Integer> s = PublishProcessor.create();
         Flowable<Integer> take = s.takeWhile(new Predicate<Integer>() {
             @Override
             public boolean test(Integer input) {

File: src/test/java/io/reactivex/internal/operators/observable/NbpBlockingOperatorMostRecentTest.java
Patch:
@@ -35,7 +35,7 @@ public void testMostRecentNull() {
 
     @Test
     public void testMostRecent() {
-        Subject<String, String> s = PublishSubject.create();
+        Subject<String> s = PublishSubject.create();
 
         Iterator<String> it = mostRecent(s, "default").iterator();
 
@@ -60,7 +60,7 @@ public void testMostRecent() {
 
     @Test(expected = TestException.class)
     public void testMostRecentWithException() {
-        Subject<String, String> s = PublishSubject.create();
+        Subject<String> s = PublishSubject.create();
 
         Iterator<String> it = mostRecent(s, "default").iterator();
 

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorConcatTest.java
Patch:
@@ -685,7 +685,7 @@ public Observable<Integer> apply(Integer t) {
                 Observable<Integer> o = Observable.just(t)
                         .subscribeOn(sch)
                 ;
-                Subject<Integer, Integer> subject = UnicastSubject.create();
+                Subject<Integer> subject = UnicastSubject.create();
                 o.subscribe(subject);
                 return subject;
             }

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorTakeWhileTest.java
Patch:
@@ -51,7 +51,7 @@ public boolean test(Integer input) {
 
     @Test
     public void testTakeWhileOnSubject1() {
-        Subject<Integer, Integer> s = PublishSubject.create();
+        Subject<Integer> s = PublishSubject.create();
         Observable<Integer> take = s.takeWhile(new Predicate<Integer>() {
             @Override
             public boolean test(Integer input) {

File: src/test/java/io/reactivex/observable/NbpObservableTests.java
Patch:
@@ -1018,7 +1018,7 @@ public String apply(Integer v) {
     
     @Test
     public void testErrorThrownIssue1685() {
-        Subject<Object, Object> subject = ReplaySubject.create();
+        Subject<Object> subject = ReplaySubject.create();
 
         Observable.error(new RuntimeException("oops"))
             .materialize()

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -3106,7 +3106,7 @@ public Collection<V> apply(K k) {
         });
     }
     
-    public final Flowable<T> toObservable(BackpressureStrategy strategy) {
+    public final Flowable<T> toFlowable(BackpressureStrategy strategy) {
         Flowable<T> o = Flowable.create(new Publisher<T>() {
             @Override
             public void subscribe(final Subscriber<? super T> s) {

File: src/main/java/io/reactivex/internal/disposables/ArrayCompositeResource.java
Patch:
@@ -26,7 +26,9 @@
  * and should be used by internal means only.
  * 
  * @param <T> the resource tpye
+ * @deprecated Use more type-specific and inlined resource management
  */
+@Deprecated
 public final class ArrayCompositeResource<T> extends AtomicReferenceArray<Object> implements Disposable {
     /** */
     private static final long serialVersionUID = 2746389416410565408L;

File: src/main/java/io/reactivex/internal/disposables/ListCompositeResource.java
Patch:
@@ -22,7 +22,9 @@
  * A linked-list-based composite resource with custom disposer callback.
  *
  * @param <T> the resource type
+ * @deprecated Use more type-specific and inlined resource management
  */
+@Deprecated
 public final class ListCompositeResource<T> implements CompositeResource<T>, Disposable {
     final Consumer<? super T> disposer;
     

File: src/main/java/io/reactivex/internal/disposables/MultipleAssignmentResource.java
Patch:
@@ -31,7 +31,9 @@
  * and should be used by internal means only.
  * 
  * @param <T> the resource type
+ * @deprecated Use more type-specific and inlined resource management
  */
+@Deprecated
 public final class MultipleAssignmentResource<T> extends AtomicReference<Object> implements Disposable {
     /** */
     private static final long serialVersionUID = 5247635821051810205L;

File: src/main/java/io/reactivex/internal/disposables/SerialResource.java
Patch:
@@ -31,7 +31,9 @@
  * and should be used by internal means only.
  * 
  * @param <T> the resource type
+ * @deprecated Use more type-specific and inlined resource management
  */
+@Deprecated
 public final class SerialResource<T> extends AtomicReference<Object> implements Disposable {
     /** */
     private static final long serialVersionUID = 5247635821051810205L;

File: src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java
Patch:
@@ -21,7 +21,9 @@
  * A set-based composite resource with custom disposer callback.
  *
  * @param <T> the resource type
+ * @deprecated Use more type-specific and inlined resource management
  */
+@Deprecated
 public final class SetCompositeResource<T> implements CompositeResource<T>, Disposable {
     final Consumer<? super T> disposer;
     

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
Patch:
@@ -25,17 +25,17 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeConcat implements CompletableConsumable {
+public final class CompletableConcat extends Completable {
     final Publisher<? extends CompletableConsumable> sources;
     final int prefetch;
     
-    public CompletableOnSubscribeConcat(Publisher<? extends CompletableConsumable> sources, int prefetch) {
+    public CompletableConcat(Publisher<? extends CompletableConsumable> sources, int prefetch) {
         this.sources = sources;
         this.prefetch = prefetch;
     }
     
     @Override
-    public void subscribe(CompletableSubscriber s) {
+    public void subscribeActual(CompletableSubscriber s) {
         CompletableConcatSubscriber parent = new CompletableConcatSubscriber(s, prefetch);
         sources.subscribe(parent);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java
Patch:
@@ -18,15 +18,15 @@
 import io.reactivex.*;
 import io.reactivex.disposables.*;
 
-public final class CompletableOnSubscribeConcatArray implements CompletableConsumable {
+public final class CompletableConcatArray extends Completable {
     final CompletableConsumable[] sources;
     
-    public CompletableOnSubscribeConcatArray(CompletableConsumable[] sources) {
+    public CompletableConcatArray(CompletableConsumable[] sources) {
         this.sources = sources;
     }
     
     @Override
-    public void subscribe(CompletableSubscriber s) {
+    public void subscribeActual(CompletableSubscriber s) {
         ConcatInnerSubscriber inner = new ConcatInnerSubscriber(s, sources);
         s.onSubscribe(inner.sd);
         inner.next();

File: src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java
Patch:
@@ -20,15 +20,15 @@
 import io.reactivex.disposables.*;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
-public final class CompletableOnSubscribeConcatIterable implements CompletableConsumable {
+public final class CompletableConcatIterable extends Completable {
     final Iterable<? extends CompletableConsumable> sources;
     
-    public CompletableOnSubscribeConcatIterable(Iterable<? extends CompletableConsumable> sources) {
+    public CompletableConcatIterable(Iterable<? extends CompletableConsumable> sources) {
         this.sources = sources;
     }
     
     @Override
-    public void subscribe(CompletableSubscriber s) {
+    public void subscribeActual(CompletableSubscriber s) {
         
         Iterator<? extends CompletableConsumable> it;
         

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
Patch:
@@ -26,19 +26,19 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeMerge implements CompletableConsumable {
+public final class CompletableMerge extends Completable {
     final Publisher<? extends CompletableConsumable> source;
     final int maxConcurrency;
     final boolean delayErrors;
     
-    public CompletableOnSubscribeMerge(Publisher<? extends CompletableConsumable> source, int maxConcurrency, boolean delayErrors) {
+    public CompletableMerge(Publisher<? extends CompletableConsumable> source, int maxConcurrency, boolean delayErrors) {
         this.source = source;
         this.maxConcurrency = maxConcurrency;
         this.delayErrors = delayErrors;
     }
     
     @Override
-    public void subscribe(CompletableSubscriber s) {
+    public void subscribeActual(CompletableSubscriber s) {
         CompletableMergeSubscriber parent = new CompletableMergeSubscriber(s, maxConcurrency, delayErrors);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
Patch:
@@ -19,15 +19,15 @@
 import io.reactivex.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeMergeArray implements CompletableConsumable {
+public final class CompletableMergeArray extends Completable {
     final CompletableConsumable[] sources;
     
-    public CompletableOnSubscribeMergeArray(CompletableConsumable[] sources) {
+    public CompletableMergeArray(CompletableConsumable[] sources) {
         this.sources = sources;
     }
     
     @Override
-    public void subscribe(final CompletableSubscriber s) {
+    public void subscribeActual(final CompletableSubscriber s) {
         final CompositeDisposable set = new CompositeDisposable();
         final AtomicInteger wip = new AtomicInteger(sources.length + 1);
         final AtomicBoolean once = new AtomicBoolean();

File: src/main/java/io/reactivex/internal/operators/completable/CompletableMergeIterable.java
Patch:
@@ -20,15 +20,15 @@
 import io.reactivex.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeMergeIterable implements CompletableConsumable {
+public final class CompletableMergeIterable extends Completable {
     final Iterable<? extends CompletableConsumable> sources;
     
-    public CompletableOnSubscribeMergeIterable(Iterable<? extends CompletableConsumable> sources) {
+    public CompletableMergeIterable(Iterable<? extends CompletableConsumable> sources) {
         this.sources = sources;
     }
     
     @Override
-    public void subscribe(final CompletableSubscriber s) {
+    public void subscribeActual(final CompletableSubscriber s) {
         final CompositeDisposable set = new CompositeDisposable();
         final AtomicInteger wip = new AtomicInteger(1);
         final AtomicBoolean once = new AtomicBoolean();

File: src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java
Patch:
@@ -20,15 +20,15 @@
 import io.reactivex.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeTimeout implements CompletableConsumable {
+public final class CompletableTimeout extends Completable {
     
     final CompletableConsumable source;
     final long timeout;
     final TimeUnit unit;
     final Scheduler scheduler;
     final CompletableConsumable other;
 
-    public CompletableOnSubscribeTimeout(CompletableConsumable source, long timeout, 
+    public CompletableTimeout(CompletableConsumable source, long timeout, 
             TimeUnit unit, Scheduler scheduler, CompletableConsumable other) {
         this.source = source;
         this.timeout = timeout;
@@ -38,7 +38,7 @@ public CompletableOnSubscribeTimeout(CompletableConsumable source, long timeout,
     }
 
     @Override
-    public void subscribe(final CompletableSubscriber s) {
+    public void subscribeActual(final CompletableSubscriber s) {
         final CompositeDisposable set = new CompositeDisposable();
         s.onSubscribe(set);
         

File: src/main/java/io/reactivex/internal/operators/completable/CompletableOnSubscribeConcat.java
Patch:
@@ -18,15 +18,14 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Completable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.disposables.SerialResource;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeConcat implements CompletableOnSubscribe {
+public final class CompletableOnSubscribeConcat implements CompletableConsumable {
     final Flowable<? extends Completable> sources;
     final int prefetch;
     
@@ -36,7 +35,7 @@ public CompletableOnSubscribeConcat(Flowable<? extends Completable> sources, int
     }
     
     @Override
-    public void accept(CompletableSubscriber s) {
+    public void subscribe(CompletableSubscriber s) {
         CompletableConcatSubscriber parent = new CompletableConcatSubscriber(s, prefetch);
         sources.subscribe(parent);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableOnSubscribeMerge.java
Patch:
@@ -20,14 +20,13 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Completable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.internal.disposables.SetCompositeResource;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeMerge implements CompletableOnSubscribe {
+public final class CompletableOnSubscribeMerge implements CompletableConsumable {
     final Flowable<? extends Completable> source;
     final int maxConcurrency;
     final boolean delayErrors;
@@ -39,7 +38,7 @@ public CompletableOnSubscribeMerge(Flowable<? extends Completable> source, int m
     }
     
     @Override
-    public void accept(CompletableSubscriber s) {
+    public void subscribe(CompletableSubscriber s) {
         CompletableMergeSubscriber parent = new CompletableMergeSubscriber(s, maxConcurrency, delayErrors);
         source.subscribe(parent);
     }

File: src/main/java/io/reactivex/internal/operators/completable/CompletableOnSubscribeTimeout.java
Patch:
@@ -17,11 +17,10 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.reactivex.*;
-import io.reactivex.Completable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class CompletableOnSubscribeTimeout implements CompletableOnSubscribe {
+public final class CompletableOnSubscribeTimeout implements CompletableConsumable {
     
     final Completable source;
     final long timeout;
@@ -39,7 +38,7 @@ public CompletableOnSubscribeTimeout(Completable source, long timeout,
     }
 
     @Override
-    public void accept(final CompletableSubscriber s) {
+    public void subscribe(final CompletableSubscriber s) {
         final CompositeDisposable set = new CompositeDisposable();
         s.onSubscribe(set);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpObservableScalarSource.java
Patch:
@@ -38,10 +38,10 @@ public T value() {
         return value;
     }
     
-    public <U> NbpOnSubscribe<U> scalarFlatMap(final Function<? super T, ? extends Observable<? extends U>> mapper) {
-        return new NbpOnSubscribe<U>() {
+    public <U> ObservableConsumable<U> scalarFlatMap(final Function<? super T, ? extends Observable<? extends U>> mapper) {
+        return new ObservableConsumable<U>() {
             @Override
-            public void accept(Observer<? super U> s) {
+            public void subscribe(Observer<? super U> s) {
                 Observable<? extends U> other;
                 try {
                     other = mapper.apply(value);

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeAmb.java
Patch:
@@ -16,13 +16,12 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeAmb<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeAmb<T> implements ObservableConsumable<T> {
     final Observable<? extends T>[] sources;
     final Iterable<? extends Observable<? extends T>> sourcesIterable;
     
@@ -33,7 +32,7 @@ public NbpOnSubscribeAmb(Observable<? extends T>[] sources, Iterable<? extends O
     
     @Override
     @SuppressWarnings("unchecked")
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         Observable<? extends T>[] sources = this.sources;
         int count = 0;
         if (sources == null) {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeDefer.java
Patch:
@@ -14,17 +14,16 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.functions.Supplier;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
-public final class NbpOnSubscribeDefer<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeDefer<T> implements ObservableConsumable<T> {
     final Supplier<? extends Observable<? extends T>> supplier;
     public NbpOnSubscribeDefer(Supplier<? extends Observable<? extends T>> supplier) {
         this.supplier = supplier;
     }
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         Observable<? extends T> pub;
         try {
             pub = supplier.get();

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeDelaySubscriptionOther.java
Patch:
@@ -14,7 +14,6 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -24,7 +23,7 @@
  * @param <T> the main type
  * @param <U> the other value type, ignored
  */
-public final class NbpOnSubscribeDelaySubscriptionOther<T, U> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeDelaySubscriptionOther<T, U> implements ObservableConsumable<T> {
     final Observable<? extends T> main;
     final Observable<U> other;
     
@@ -34,7 +33,7 @@ public NbpOnSubscribeDelaySubscriptionOther(Observable<? extends T> main, Observ
     }
     
     @Override
-    public void accept(final Observer<? super T> child) {
+    public void subscribe(final Observer<? super T> child) {
         final SerialDisposable serial = new SerialDisposable();
         child.onSubscribe(serial);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeIntervalRangeSource.java
Patch:
@@ -17,11 +17,10 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeIntervalRangeSource implements NbpOnSubscribe<Long> {
+public final class NbpOnSubscribeIntervalRangeSource implements ObservableConsumable<Long> {
     final Scheduler scheduler;
     final long start;
     final long end;
@@ -39,7 +38,7 @@ public NbpOnSubscribeIntervalRangeSource(long start, long end, long initialDelay
     }
     
     @Override
-    public void accept(Observer<? super Long> s) {
+    public void subscribe(Observer<? super Long> s) {
         IntervalRangeSubscriber is = new IntervalRangeSubscriber(s, start, end);
         s.onSubscribe(is);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeIntervalSource.java
Patch:
@@ -17,11 +17,10 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeIntervalSource implements NbpOnSubscribe<Long> {
+public final class NbpOnSubscribeIntervalSource implements ObservableConsumable<Long> {
     final Scheduler scheduler;
     final long initialDelay;
     final long period;
@@ -35,7 +34,7 @@ public NbpOnSubscribeIntervalSource(long initialDelay, long period, TimeUnit uni
     }
     
     @Override
-    public void accept(Observer<? super Long> s) {
+    public void subscribe(Observer<? super Long> s) {
         IntervalSubscriber is = new IntervalSubscriber(s);
         s.onSubscribe(is);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeLift.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -26,7 +26,7 @@
  * @param <T> the upstream value type
  * @param <R> the downstream parameter type
  */
-public final class NbpOnSubscribeLift<R, T> implements NbpOnSubscribe<R> {
+public final class NbpOnSubscribeLift<R, T> implements ObservableConsumable<R> {
     /** The actual operator. */
     final NbpOperator<? extends R, ? super T> operator;
     /** The source publisher. */
@@ -54,7 +54,7 @@ public Observable<? extends T> source() {
     }
     
     @Override
-    public void accept(Observer<? super R> s) {
+    public void subscribe(Observer<? super R> s) {
         try {
             if (s == null) {
                 throw new NullPointerException("Operator " + operator + " received a null Subscriber");

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeRedo.java
Patch:
@@ -16,13 +16,12 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscribers.observable.NbpToNotificationSubscriber;
 import io.reactivex.subjects.BehaviorSubject;
 
-public final class NbpOnSubscribeRedo<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeRedo<T> implements ObservableConsumable<T> {
     final Observable<? extends T> source;
     final Function<? super Observable<Try<Optional<Object>>>, ? extends Observable<?>> manager;
 
@@ -33,7 +32,7 @@ public NbpOnSubscribeRedo(Observable<? extends T> source,
     }
     
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         
         // FIXE use BehaviorSubject? (once available)
         BehaviorSubject<Try<Optional<Object>>> subject = BehaviorSubject.create();

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeRepeat.java
Patch:
@@ -16,10 +16,9 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 
-public final class NbpOnSubscribeRepeat<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeRepeat<T> implements ObservableConsumable<T> {
     final Observable<? extends T> source;
     final long count;
     public NbpOnSubscribeRepeat(Observable<? extends T> source, long count) {
@@ -28,7 +27,7 @@ public NbpOnSubscribeRepeat(Observable<? extends T> source, long count) {
     }
     
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         MultipleAssignmentDisposable mad = new MultipleAssignmentDisposable();
         s.onSubscribe(mad);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeRepeatUntil.java
Patch:
@@ -16,11 +16,10 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.BooleanSupplier;
 
-public final class NbpOnSubscribeRepeatUntil<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeRepeatUntil<T> implements ObservableConsumable<T> {
     final Observable<? extends T> source;
     final BooleanSupplier until;
     public NbpOnSubscribeRepeatUntil(Observable<? extends T> source, BooleanSupplier until) {
@@ -29,7 +28,7 @@ public NbpOnSubscribeRepeatUntil(Observable<? extends T> source, BooleanSupplier
     }
     
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         MultipleAssignmentDisposable sa = new MultipleAssignmentDisposable();
         s.onSubscribe(sa);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeRetryBiPredicate.java
Patch:
@@ -16,12 +16,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.BiPredicate;
 
-public final class NbpOnSubscribeRetryBiPredicate<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeRetryBiPredicate<T> implements ObservableConsumable<T> {
     final Observable<? extends T> source;
     final BiPredicate<? super Integer, ? super Throwable> predicate;
     public NbpOnSubscribeRetryBiPredicate(
@@ -32,7 +31,7 @@ public NbpOnSubscribeRetryBiPredicate(
     }
     
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         SerialDisposable sa = new SerialDisposable();
         s.onSubscribe(sa);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeRetryPredicate.java
Patch:
@@ -16,12 +16,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Predicate;
 
-public final class NbpOnSubscribeRetryPredicate<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeRetryPredicate<T> implements ObservableConsumable<T> {
     final Observable<? extends T> source;
     final Predicate<? super Throwable> predicate;
     final long count;
@@ -34,7 +33,7 @@ public NbpOnSubscribeRetryPredicate(Observable<? extends T> source,
     }
     
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         SerialDisposable sa = new SerialDisposable();
         s.onSubscribe(sa);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeSequenceEqual.java
Patch:
@@ -17,13 +17,12 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.BiPredicate;
 import io.reactivex.internal.disposables.ArrayCompositeResource;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 
-public final class NbpOnSubscribeSequenceEqual<T> implements NbpOnSubscribe<Boolean> {
+public final class NbpOnSubscribeSequenceEqual<T> implements ObservableConsumable<Boolean> {
     final Observable<? extends T> first;
     final Observable<? extends T> second;
     final BiPredicate<? super T, ? super T> comparer;
@@ -38,7 +37,7 @@ public NbpOnSubscribeSequenceEqual(Observable<? extends T> first, Observable<? e
     }
     
     @Override
-    public void accept(Observer<? super Boolean> s) {
+    public void subscribe(Observer<? super Boolean> s) {
         EqualCoordinator<T> ec = new EqualCoordinator<T>(s, bufferSize, first, second, comparer);
         ec.subscribe();
     }

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeSubscribeOn.java
Patch:
@@ -16,11 +16,10 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
-public final class NbpOnSubscribeSubscribeOn<T> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeSubscribeOn<T> implements ObservableConsumable<T> {
     final Observable<? extends T> source;
     final Scheduler scheduler;
     
@@ -30,7 +29,7 @@ public NbpOnSubscribeSubscribeOn(Observable<? extends T> source, Scheduler sched
     }
     
     @Override
-    public void accept(final Observer<? super T> s) {
+    public void subscribe(final Observer<? super T> s) {
         /*
          * TODO can't use the returned disposable because to dispose it,
          * one must set a Subscription on s on the current thread, but

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeTimerOnceSource.java
Patch:
@@ -17,11 +17,10 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeTimerOnceSource implements NbpOnSubscribe<Long> {
+public final class NbpOnSubscribeTimerOnceSource implements ObservableConsumable<Long> {
     final Scheduler scheduler;
     final long delay;
     final TimeUnit unit;
@@ -32,7 +31,7 @@ public NbpOnSubscribeTimerOnceSource(long delay, TimeUnit unit, Scheduler schedu
     }
     
     @Override
-    public void accept(Observer<? super Long> s) {
+    public void subscribe(Observer<? super Long> s) {
         IntervalOnceSubscriber ios = new IntervalOnceSubscriber(s);
         s.onSubscribe(ios);
         

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeUsing.java
Patch:
@@ -16,15 +16,14 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeUsing<T, D> implements NbpOnSubscribe<T> {
+public final class NbpOnSubscribeUsing<T, D> implements ObservableConsumable<T> {
     final Supplier<? extends D> resourceSupplier;
     final Function<? super D, ? extends Observable<? extends T>> sourceSupplier;
     final Consumer<? super D> disposer;
@@ -41,7 +40,7 @@ public NbpOnSubscribeUsing(Supplier<? extends D> resourceSupplier,
     }
     
     @Override
-    public void accept(Observer<? super T> s) {
+    public void subscribe(Observer<? super T> s) {
         D resource;
         
         try {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeZip.java
Patch:
@@ -17,14 +17,13 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeZip<T, R> implements NbpOnSubscribe<R> {
+public final class NbpOnSubscribeZip<T, R> implements ObservableConsumable<R> {
     
     final Observable<? extends T>[] sources;
     final Iterable<? extends Observable<? extends T>> sourcesIterable;
@@ -46,7 +45,7 @@ public NbpOnSubscribeZip(Observable<? extends T>[] sources,
     
     @Override
     @SuppressWarnings("unchecked")
-    public void accept(Observer<? super R> s) {
+    public void subscribe(Observer<? super R> s) {
         Observable<? extends T>[] sources = this.sources;
         int count = 0;
         if (sources == null) {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeZipIterable.java
Patch:
@@ -16,14 +16,13 @@
 import java.util.Iterator;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
-public final class NbpOnSubscribeZipIterable<T, U, V> implements NbpOnSubscribe<V> {
+public final class NbpOnSubscribeZipIterable<T, U, V> implements ObservableConsumable<V> {
     final Observable<? extends T> source;
     final Iterable<U> other;
     final BiFunction<? super T, ? super U, ? extends V> zipper;
@@ -37,7 +36,7 @@ public NbpOnSubscribeZipIterable(
     }
     
     @Override
-    public void accept(Observer<? super V> t) {
+    public void subscribe(Observer<? super V> t) {
         Iterator<U> it;
         
         try {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorAll.java
Patch:
@@ -12,8 +12,8 @@
  */
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorAny.java
Patch:
@@ -12,8 +12,8 @@
  */
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBuffer.java
Patch:
@@ -16,8 +16,8 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Supplier;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferBoundary.java
Patch:
@@ -16,9 +16,9 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.reactivex.Observer;
 import io.reactivex.Observable;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
+import io.reactivex.Observer;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.SetCompositeResource;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferBoundarySupplier.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Supplier;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferExactBoundary.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.Collection;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Supplier;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorCollect.java
Patch:
@@ -12,8 +12,8 @@
  */
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorConcatMap.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorCount.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounce.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscribers.observable.NbpDisposableSubscriber;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounceTimed.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDelay.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.TimeUnit;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDematerialize.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDistinct.java
Patch:
@@ -15,8 +15,8 @@
 
 import java.util.Collection;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.*;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDoOnEach.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorElementAt.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorFilter.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorFlatMap.java
Patch:
@@ -16,9 +16,9 @@
 import java.util.*;
 import java.util.concurrent.atomic.*;
 
-import io.reactivex.Observer;
 import io.reactivex.Observable;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
+import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorIgnoreElements.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 
 public enum NbpOperatorIgnoreElements implements NbpOperator<Object, Object> {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorMap.java
Patch:
@@ -14,8 +14,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorMapNotification.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorMaterialize.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorObserveOn.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorOnErrorNext.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Function;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorOnErrorReturn.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Function;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSampleTimed.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.observers.SerializedObserver;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSampleWithObservable.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.observers.SerializedObserver;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorScan.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorScanSeed.java
Patch:
@@ -12,8 +12,8 @@
  */
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSingle.java
Patch:
@@ -15,8 +15,8 @@
 
 import java.util.NoSuchElementException;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSkip.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 
 public final class NbpOperatorSkip<T> implements NbpOperator<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSkipLast.java
Patch:
@@ -15,8 +15,8 @@
 
 import java.util.ArrayDeque;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 
 public final class NbpOperatorSkipLast<T> implements NbpOperator<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSkipLastTimed.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSkipUntil.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.*;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSkipWhile.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchIfEmpty.java
Patch:
@@ -14,7 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.*;
 
 public final class NbpOperatorSwitchIfEmpty<T> implements NbpOperator<T, T> {

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java
Patch:
@@ -19,7 +19,7 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.queue.*;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTake.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTakeLast.java
Patch:
@@ -15,8 +15,8 @@
 
 import java.util.ArrayDeque;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTakeLastOne.java
Patch:
@@ -12,8 +12,8 @@
  */
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTakeLastTimed.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTakeUntil.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.*;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTakeUntilPredicate.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTakeWhile.java
Patch:
@@ -13,8 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorThrottleFirstTimed.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeInterval.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.TimeUnit;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.schedulers.Timed;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeout.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.*;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeoutTimed.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.NbpFullArbiter;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorToList.java
Patch:
@@ -15,8 +15,8 @@
 
 import java.util.*;
 
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.Observer;
-import io.reactivex.Observable.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Supplier;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorUnsubscribeOn.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindow.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.subjects.UnicastSubject;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.observable.*;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java
Patch:
@@ -16,9 +16,9 @@
 import java.util.*;
 import java.util.concurrent.atomic.*;
 
-import io.reactivex.Observer;
 import io.reactivex.Observable;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
+import io.reactivex.Observer;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.SetCompositeResource;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Supplier;
 import io.reactivex.internal.queue.MpscLinkedQueue;

File: src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWithLatestFrom.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.*;
-import io.reactivex.Observable.*;
+import io.reactivex.Observable.NbpOperator;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.disposables.EmptyDisposable;

File: src/main/java/io/reactivex/internal/operators/observable/ObservableWrapper.java
Patch:
@@ -3,14 +3,14 @@
 import io.reactivex.*;
 
 public final class ObservableWrapper<T> extends Observable<T> {
-    final NbpOnSubscribe<T> onSubscribe;
+    final ObservableConsumable<T> onSubscribe;
 
-    public ObservableWrapper(NbpOnSubscribe<T> onSubscribe) {
+    public ObservableWrapper(ObservableConsumable<T> onSubscribe) {
         this.onSubscribe = onSubscribe;
     }
     
     @Override
     protected void subscribeActual(Observer<? super T> observer) {
-        onSubscribe.accept(observer);
+        onSubscribe.subscribe(observer);
     }
 }

File: src/main/java/io/reactivex/internal/operators/single/SingleOperatorFlatMap.java
Patch:
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.single;
 
-import io.reactivex.Single;
+import io.reactivex.*;
 import io.reactivex.Single.*;
 import io.reactivex.disposables.*;
 import io.reactivex.functions.Function;

File: src/main/java/io/reactivex/internal/operators/single/SingleOperatorMap.java
Patch:
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.single;
 
 import io.reactivex.Single.*;
+import io.reactivex.SingleSubscriber;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 

File: src/main/java/io/reactivex/subscribers/completable/CompletableSerializedSubscriber.java
Patch:
@@ -15,7 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import io.reactivex.Completable.CompletableSubscriber;
+import io.reactivex.CompletableSubscriber;
 import io.reactivex.disposables.Disposable;
 
 public final class CompletableSerializedSubscriber implements CompletableSubscriber {

File: src/perf/java/io/reactivex/LatchedSingleObserver.java
Patch:
@@ -17,7 +17,6 @@
 
 import org.openjdk.jmh.infra.Blackhole;
 
-import io.reactivex.Single.SingleSubscriber;
 import io.reactivex.disposables.Disposable;
 
 public final class LatchedSingleObserver<T> implements SingleSubscriber<T> {

File: src/test/java/io/reactivex/internal/operators/observable/NbpBlockingOperatorNextTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.*;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOnSubscribe;
+import io.reactivex.ObservableConsumable;
 import io.reactivex.Observer;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -235,10 +235,10 @@ public void testNoBufferingOrBlockingOfSequence() throws Throwable {
         final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
         final AtomicBoolean running = new AtomicBoolean(true);
         final AtomicInteger count = new AtomicInteger(0);
-        final Observable<Integer> obs = Observable.create(new NbpOnSubscribe<Integer>() {
+        final Observable<Integer> obs = Observable.create(new ObservableConsumable<Integer>() {
 
             @Override
-            public void accept(final Observer<? super Integer> o) {
+            public void subscribe(final Observer<? super Integer> o) {
                 o.onSubscribe(EmptyDisposable.INSTANCE);
                 new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/observable/NbpOnSubscribeAmbTest.java
Patch:
@@ -24,7 +24,6 @@
 import org.mockito.InOrder;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.disposables.*;
 import io.reactivex.flowable.TestHelper;
 import io.reactivex.functions.Consumer;
@@ -45,10 +44,10 @@ public void setUp() {
 
     private Observable<String> createObservable(final String[] values,
             final long interval, final Throwable e) {
-        return Observable.create(new NbpOnSubscribe<String>() {
+        return Observable.create(new ObservableConsumable<String>() {
 
             @Override
-            public void accept(final Observer<? super String> NbpSubscriber) {
+            public void subscribe(final Observer<? super String> NbpSubscriber) {
                 CompositeDisposable parentSubscription = new CompositeDisposable();
                 
                 NbpSubscriber.onSubscribe(parentSubscription);

File: src/test/java/io/reactivex/internal/operators/observable/NbpOnSubscribeCombineLatestTest.java
Patch:
@@ -24,10 +24,10 @@
 import org.junit.Test;
 import org.mockito.*;
 
-import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.Optional;
+import io.reactivex.Try;
 import io.reactivex.flowable.TestHelper;
 import io.reactivex.functions.*;
 import io.reactivex.observers.*;

File: src/test/java/io/reactivex/internal/operators/observable/NbpOnSubscribeUsingTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.mockito.InOrder;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOnSubscribe;
+import io.reactivex.ObservableConsumable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
@@ -253,9 +253,9 @@ public Disposable get() {
         Function<Disposable, Observable<Integer>> observableFactory = new Function<Disposable, Observable<Integer>>() {
             @Override
             public Observable<Integer> apply(Disposable subscription) {
-                return Observable.create(new NbpOnSubscribe<Integer>() {
+                return Observable.create(new ObservableConsumable<Integer>() {
                     @Override
-                    public void accept(Observer<? super Integer> t1) {
+                    public void subscribe(Observer<? super Integer> t1) {
                         throw new TestException();
                     }
                 });

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorDoOnEachTest.java
Patch:
@@ -161,15 +161,15 @@ public void accept(List<Boolean> booleans) {
         assertEquals(expectedCount, count.get());
     }
 
-    // FIXME crashing NbpOnSubscribe can't propagate to a NbpSubscriber
+    // FIXME crashing ObservableConsumable can't propagate to a NbpSubscriber
 //    @Test
 //    public void testFatalError() {
 //        try {
 //            NbpObservable.just(1, 2, 3)
 //                    .flatMap(new Function<Integer, NbpObservable<?>>() {
 //                        @Override
 //                        public NbpObservable<?> apply(Integer integer) {
-//                            return NbpObservable.create(new NbpOnSubscribe<Object>() {
+//                            return NbpObservable.create(new ObservableConsumable<Object>() {
 //                                @Override
 //                                public void accept(NbpSubscriber<Object> o) {
 //                                    throw new NullPointerException("Test NPE");

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorDoOnSubscribeTest.java
Patch:
@@ -20,7 +20,6 @@
 import org.junit.Test;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -68,10 +67,10 @@ public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
         final AtomicInteger countBefore = new AtomicInteger();
         final AtomicInteger countAfter = new AtomicInteger();
         final AtomicReference<Observer<? super Integer>> sref = new AtomicReference<Observer<? super Integer>>();
-        Observable<Integer> o = Observable.create(new NbpOnSubscribe<Integer>() {
+        Observable<Integer> o = Observable.create(new ObservableConsumable<Integer>() {
 
             @Override
-            public void accept(Observer<? super Integer> s) {
+            public void subscribe(Observer<? super Integer> s) {
                 s.onSubscribe(EmptyDisposable.INSTANCE);
                 onSubscribed.incrementAndGet();
                 sref.set(s);

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorMapTest.java
Patch:
@@ -251,7 +251,7 @@ public Integer apply(Integer i) {
 //    @Test(expected = OnErrorNotImplementedException.class)
 //    public void verifyExceptionIsThrownIfThereIsNoExceptionHandler() {
 //
-//        NbpOnSubscribe<Object> creator = new NbpOnSubscribe<Object>() {
+//        ObservableConsumable<Object> creator = new ObservableConsumable<Object>() {
 //
 //            @Override
 //            public void accept(NbpSubscriber<? super Object> NbpObserver) {

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorMaterializeTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import io.reactivex.*;
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.Observer;
 import io.reactivex.Optional;
 import io.reactivex.functions.Consumer;
@@ -133,7 +132,7 @@ public void onNext(Try<Optional<String>> value) {
 
     }
 
-    private static class TestAsyncErrorObservable implements NbpOnSubscribe<String> {
+    private static class TestAsyncErrorObservable implements ObservableConsumable<String> {
 
         String[] valuesToReturn;
 
@@ -144,7 +143,7 @@ private static class TestAsyncErrorObservable implements NbpOnSubscribe<String>
         volatile Thread t;
 
         @Override
-        public void accept(final Observer<? super String> NbpObserver) {
+        public void subscribe(final Observer<? super String> NbpObserver) {
             NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
             t = new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorMergeMaxConcurrentTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.*;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOnSubscribe;
+import io.reactivex.ObservableConsumable;
 import io.reactivex.Observer;
 import io.reactivex.flowable.TestHelper;
 import io.reactivex.internal.disposables.EmptyDisposable;
@@ -86,7 +86,7 @@ public void testMaxConcurrent() {
         }
     }
 
-    private static class SubscriptionCheckObservable implements NbpOnSubscribe<String> {
+    private static class SubscriptionCheckObservable implements ObservableConsumable<String> {
 
         private final AtomicInteger subscriptionCount;
         private final int maxConcurrent;
@@ -98,7 +98,7 @@ private static class SubscriptionCheckObservable implements NbpOnSubscribe<Strin
         }
 
         @Override
-        public void accept(final Observer<? super String> t1) {
+        public void subscribe(final Observer<? super String> t1) {
             t1.onSubscribe(EmptyDisposable.INSTANCE);
             new Thread(new Runnable() {
 

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorOnErrorReturnTest.java
Patch:
@@ -23,7 +23,6 @@
 import org.mockito.Mockito;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.observers.*;
@@ -177,7 +176,7 @@ public Integer apply(Integer t1) {
         ts.assertNoErrors();
     }
 
-    private static class TestObservable implements NbpOnSubscribe<String> {
+    private static class TestObservable implements ObservableConsumable<String> {
 
         final String[] values;
         Thread t = null;
@@ -187,7 +186,7 @@ public TestObservable(String... values) {
         }
 
         @Override
-        public void accept(final Observer<? super String> NbpSubscriber) {
+        public void subscribe(final Observer<? super String> NbpSubscriber) {
             NbpSubscriber.onSubscribe(EmptyDisposable.INSTANCE);
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorOnExceptionResumeNextViaObservableTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.mockito.Mockito;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.flowable.TestHelper;
 import io.reactivex.functions.Function;
@@ -216,7 +215,7 @@ public Integer apply(Integer t1) {
     }
 
 
-    private static class TestObservable implements NbpOnSubscribe<String> {
+    private static class TestObservable implements ObservableConsumable<String> {
 
         final String[] values;
         Thread t = null;
@@ -226,7 +225,7 @@ public TestObservable(String... values) {
         }
 
         @Override
-        public void accept(final Observer<? super String> NbpObserver) {
+        public void subscribe(final Observer<? super String> NbpObserver) {
             NbpObserver.onSubscribe(EmptyDisposable.INSTANCE);
             System.out.println("TestObservable subscribed to ...");
             t = new Thread(new Runnable() {

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorTakeUntilTest.java
Patch:
@@ -19,7 +19,6 @@
 import org.junit.Test;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.flowable.TestHelper;
 import io.reactivex.observers.TestObserver;
@@ -153,7 +152,7 @@ public void testTakeUntilOtherCompleted() {
 
     }
 
-    private static class TestObservable implements NbpOnSubscribe<String> {
+    private static class TestObservable implements ObservableConsumable<String> {
 
         Observer<? super String> NbpObserver;
         Disposable s;
@@ -178,7 +177,7 @@ public void sendOnError(Throwable e) {
         }
 
         @Override
-        public void accept(Observer<? super String> NbpObserver) {
+        public void subscribe(Observer<? super String> NbpObserver) {
             this.NbpObserver = NbpObserver;
             NbpObserver.onSubscribe(s);
         }

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorTimeoutWithSelectorTest.java
Patch:
@@ -27,7 +27,6 @@
 import org.mockito.stubbing.Answer;
 
 import io.reactivex.*;
-import io.reactivex.Observable.NbpOnSubscribe;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.flowable.TestHelper;
@@ -327,9 +326,9 @@ public void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() throws Interr
             public Observable<Integer> apply(Integer t1) {
                 if (t1 == 1) {
                     // Force "unsubscribe" run on another thread
-                    return Observable.create(new NbpOnSubscribe<Integer>() {
+                    return Observable.create(new ObservableConsumable<Integer>() {
                         @Override
-                        public void accept(Observer<? super Integer> NbpSubscriber) {
+                        public void subscribe(Observer<? super Integer> NbpSubscriber) {
                             NbpSubscriber.onSubscribe(EmptyDisposable.INSTANCE);
                             enteredTimeoutOne.countDown();
                             // force the timeout message be sent after NbpObserver.onNext(2)

File: src/test/java/io/reactivex/internal/operators/observable/NbpOperatorWindowWithSizeTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOnSubscribe;
+import io.reactivex.ObservableConsumable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.BooleanDisposable;
 import io.reactivex.functions.*;
@@ -198,9 +198,9 @@ private List<String> list(String... args) {
     
 
     public static Observable<Integer> hotStream() {
-        return Observable.create(new NbpOnSubscribe<Integer>() {
+        return Observable.create(new ObservableConsumable<Integer>() {
             @Override
-            public void accept(Observer<? super Integer> s) {
+            public void subscribe(Observer<? super Integer> s) {
                 BooleanDisposable bs = new BooleanDisposable();
                 s.onSubscribe(bs);
                 while (!bs.isDisposed()) {

File: src/test/java/io/reactivex/observable/NbpConcatTests.java
Patch:
@@ -19,7 +19,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
-import io.reactivex.Observable.NbpOnSubscribe;
+import io.reactivex.ObservableConsumable;
 import io.reactivex.Observer;
 import io.reactivex.observable.NbpCovarianceTest.*;
 
@@ -145,9 +145,9 @@ public void testConcatCovariance4() {
         Media media = new Media();
         HorrorMovie horrorMovie2 = new HorrorMovie();
         
-        Observable<Movie> o1 = Observable.create(new NbpOnSubscribe<Movie>() {
+        Observable<Movie> o1 = Observable.create(new ObservableConsumable<Movie>() {
             @Override
-            public void accept(Observer<? super Movie> o) {
+            public void subscribe(Observer<? super Movie> o) {
                     o.onNext(horrorMovie1);
                     o.onNext(movie);
                     //                o.onNext(new Media()); // correctly doesn't compile

File: src/main/java/io/reactivex/BackpressureStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/NbpObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Observer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/BackpressureKind.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/BackpressureSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/Beta.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/Experimental.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/SchedulerKind.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/SchedulerSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/Disposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/MultipleAssignmentDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -19,11 +19,11 @@ public final class MultipleAssignmentDisposable implements Disposable {
     final MultipleAssignmentResource<Disposable> resource;
     
     public MultipleAssignmentDisposable() {
-        this.resource = new MultipleAssignmentResource<>(Disposable::dispose);
+        this.resource = new MultipleAssignmentResource<Disposable>(Disposables.consumeAndDispose());
     }
     
     public MultipleAssignmentDisposable(Disposable initialDisposable) {
-        this.resource = new MultipleAssignmentResource<>(Disposable::dispose, initialDisposable);
+        this.resource = new MultipleAssignmentResource<Disposable>(Disposables.consumeAndDispose(), initialDisposable);
     }
     
     public void set(Disposable d) {

File: src/main/java/io/reactivex/disposables/SerialDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -19,11 +19,11 @@ public final class SerialDisposable implements Disposable {
     final SerialResource<Disposable> resource;
     
     public SerialDisposable() {
-        this.resource = new SerialResource<>(Disposable::dispose);
+        this.resource = new SerialResource<Disposable>(Disposables.consumeAndDispose());
     }
     
     public SerialDisposable(Disposable initialDisposable) {
-        this.resource = new SerialResource<>(Disposable::dispose, initialDisposable);
+        this.resource = new SerialResource<Disposable>(Disposables.consumeAndDispose(), initialDisposable);
     }
 
     

File: src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/OnCompleteFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/OnErrorFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/UnsubscribeFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/ArrayCompositeResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,9 +14,9 @@
 package io.reactivex.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReferenceArray;
-import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 
 /**
  * A composite resource with a fixed number of slots.

File: src/main/java/io/reactivex/internal/disposables/CompositeResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/MultipleAssignmentResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,9 +14,9 @@
 package io.reactivex.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.internal.util.TerminalAtomicsHelper;
 
 /**

File: src/main/java/io/reactivex/internal/disposables/SerialResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,9 +14,9 @@
 package io.reactivex.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.internal.util.TerminalAtomicsHelper;
 
 /**
@@ -62,6 +62,7 @@ public SerialResource(Consumer<? super T> disposer, T initialResource) {
      * Atomically replaces the current resource with the new resource but doesn't call the disposer
      * for it.
      * @param newResource the new resource to replace the old one
+     * @return true if the set succeeded, false if the container is disposed
      */
     @SuppressWarnings("unchecked")
     public boolean setResource(T newResource) {

File: src/main/java/io/reactivex/internal/operators/OperatorAll.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -13,11 +13,11 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Predicate;
 
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -29,7 +29,7 @@ public OperatorAll(Predicate<? super T> predicate) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super Boolean> t) {
-        return new AllSubscriber<>(t, predicate);
+        return new AllSubscriber<T>(t, predicate);
     }
     
     static final class AllSubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorAny.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -13,11 +13,11 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Predicate;
 
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
 public final class OperatorAny<T> implements Operator<Boolean, T> {
@@ -28,7 +28,7 @@ public OperatorAny(Predicate<? super T> predicate) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super Boolean> t) {
-        return new AnySubscriber<>(t, predicate);
+        return new AnySubscriber<T>(t, predicate);
     }
     
     static final class AnySubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorCount.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/OperatorElementAt.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public OperatorElementAt(long index, T defaultValue) {
     }
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        return new ElementAtSubscriber<>(t, index, defaultValue);
+        return new ElementAtSubscriber<T>(t, index, defaultValue);
     }
     
     static final class ElementAtSubscriber<T> implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorIgnoreElements.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -25,7 +25,7 @@ public static <T> Operator<T, T> instance() {
     }
     
     @Override
-    public Subscriber<? super Object> apply(Subscriber<? super Object> t) {
+    public Subscriber<? super Object> apply(final Subscriber<? super Object> t) {
         return new Subscriber<Object>() {
             @Override
             public void onSubscribe(Subscription s) {

File: src/main/java/io/reactivex/internal/operators/OperatorSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -23,7 +23,7 @@
 
 public final class OperatorSingle<T> implements Operator<T, T> {
     
-    static final OperatorSingle<Object> NO_DEFAULT = new OperatorSingle<>(null);
+    static final OperatorSingle<Object> NO_DEFAULT = new OperatorSingle<Object>(null);
     
     @SuppressWarnings("unchecked")
     public static <T> OperatorSingle<T> instanceNoDefault() {
@@ -36,7 +36,7 @@ public OperatorSingle(T defaultValue) {
     }
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        return new SingleElementSubscriber<>(t, defaultValue);
+        return new SingleElementSubscriber<T>(t, defaultValue);
     }
     
     static final class SingleElementSubscriber<T> implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorSkipLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -29,7 +29,7 @@ public OperatorSkipLast(int skip) {
 
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> s) {
-        return new SkipLastSubscriber<>(s, skip);
+        return new SkipLastSubscriber<T>(s, skip);
     }
     
     static final class SkipLastSubscriber<T> extends ArrayDeque<T> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/OperatorSwitchIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public OperatorSwitchIfEmpty(Publisher<? extends T> other) {
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
         // TODO Auto-generated method stub
-        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<>(t, other);
+        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<T>(t, other);
         t.onSubscribe(parent.arbiter);
         return parent;
     }

File: src/main/java/io/reactivex/internal/operators/OperatorTakeLastOne.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -30,7 +30,7 @@ public static <T> Operator<T, T> instance() {
     
     @Override
     public Subscriber<? super Object> apply(Subscriber<? super Object> s) {
-        return new TakeLastOneSubscriber<>(s);
+        return new TakeLastOneSubscriber<Object>(s);
     }
     
     static final class TakeLastOneSubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/PublisherAutoConnect.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,11 +14,11 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
 
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.observables.ConnectableObservable;
 
 /**

File: src/main/java/io/reactivex/internal/operators/PublisherEmptySource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/PublisherGenerate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.*;
 
 import org.reactivestreams.*;
 
+import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -45,7 +45,7 @@ public void subscribe(Subscriber<? super T> s) {
             return;
         }
         
-        s.onSubscribe(new GeneratorSubscription<>(s, generator, disposeState, state));
+        s.onSubscribe(new GeneratorSubscription<T, S>(s, generator, disposeState, state));
     }
     
     static final class GeneratorSubscription<T, S> 

File: src/main/java/io/reactivex/internal/operators/PublisherLift.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/PublisherRepeat.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -32,7 +32,7 @@ public void subscribe(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter();
         s.onSubscribe(sa);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/PublisherRepeatUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
 
 import org.reactivestreams.*;
 
+import io.reactivex.functions.BooleanSupplier;
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
 public final class PublisherRepeatUntil<T> implements Publisher<T> {
@@ -33,7 +33,7 @@ public void subscribe(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter();
         s.onSubscribe(sa);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, until, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, until, sa, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/PublisherZipIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators;
 
 import java.util.Iterator;
-import java.util.function.BiFunction;
 
 import org.reactivestreams.*;
 
+import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -64,7 +64,7 @@ public void subscribe(Subscriber<? super V> t) {
             return;
         }
         
-        source.subscribe(new ZipIterableSubscriber<>(t, it, zipper));
+        source.subscribe(new ZipIterableSubscriber<T, U, V>(t, it, zipper));
     }
     
     static final class ZipIterableSubscriber<T, U, V> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeAutoConnect.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators.nbp;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
 
 import io.reactivex.NbpObservable.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.observables.nbp.NbpConnectableObservable;
 
 /**

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeLift.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeRepeat.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -32,7 +32,7 @@ public void accept(NbpSubscriber<? super T> s) {
         MultipleAssignmentDisposable mad = new MultipleAssignmentDisposable();
         s.onSubscribe(mad);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, mad, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, mad, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeRepeatUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,11 +14,11 @@
 package io.reactivex.internal.operators.nbp;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
 
 import io.reactivex.NbpObservable;
 import io.reactivex.NbpObservable.*;
 import io.reactivex.disposables.*;
+import io.reactivex.functions.BooleanSupplier;
 
 public final class NbpOnSubscribeRepeatUntil<T> implements NbpOnSubscribe<T> {
     final NbpObservable<? extends T> source;
@@ -33,7 +33,7 @@ public void accept(NbpSubscriber<? super T> s) {
         MultipleAssignmentDisposable sa = new MultipleAssignmentDisposable();
         s.onSubscribe(sa);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, until, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, until, sa, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeZipIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,11 +14,11 @@
 package io.reactivex.internal.operators.nbp;
 
 import java.util.Iterator;
-import java.util.function.BiFunction;
 
 import io.reactivex.NbpObservable;
 import io.reactivex.NbpObservable.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -66,7 +66,7 @@ public void accept(NbpSubscriber<? super V> t) {
             return;
         }
         
-        source.subscribe(new ZipIterableSubscriber<>(t, it, zipper));
+        source.subscribe(new ZipIterableSubscriber<T, U, V>(t, it, zipper));
     }
     
     static final class ZipIterableSubscriber<T, U, V> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorCount.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorElementAt.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -26,7 +26,7 @@ public NbpOperatorElementAt(long index, T defaultValue) {
     }
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        return new ElementAtSubscriber<>(t, index, defaultValue);
+        return new ElementAtSubscriber<T>(t, index, defaultValue);
     }
     
     static final class ElementAtSubscriber<T> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorIgnoreElements.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -25,7 +25,7 @@ public static <T> NbpOperator<T, T> instance() {
     }
     
     @Override
-    public NbpSubscriber<? super Object> apply(NbpSubscriber<? super Object> t) {
+    public NbpSubscriber<? super Object> apply(final NbpSubscriber<? super Object> t) {
         return new NbpSubscriber<Object>() {
             @Override
             public void onSubscribe(Disposable s) {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -21,7 +21,7 @@
 
 public final class NbpOperatorSingle<T> implements NbpOperator<T, T> {
     
-    static final NbpOperatorSingle<Object> NO_DEFAULT = new NbpOperatorSingle<>(null);
+    static final NbpOperatorSingle<Object> NO_DEFAULT = new NbpOperatorSingle<Object>(null);
     
     @SuppressWarnings("unchecked")
     public static <T> NbpOperatorSingle<T> instanceNoDefault() {
@@ -34,7 +34,7 @@ public NbpOperatorSingle(T defaultValue) {
     }
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        return new SingleElementSubscriber<>(t, defaultValue);
+        return new SingleElementSubscriber<T>(t, defaultValue);
     }
     
     static final class SingleElementSubscriber<T> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorSkipLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public NbpOperatorSkipLast(int skip) {
 
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> s) {
-        return new SkipLastSubscriber<>(s, skip);
+        return new SkipLastSubscriber<T>(s, skip);
     }
     
     static final class SkipLastSubscriber<T> extends ArrayDeque<T> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorSwitchIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -25,7 +25,7 @@ public NbpOperatorSwitchIfEmpty(NbpObservable<? extends T> other) {
     
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<>(t, other);
+        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<T>(t, other);
         t.onSubscribe(parent.arbiter);
         return parent;
     }

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -28,7 +28,7 @@ public NbpOperatorTakeLast(int count) {
 
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        return new TakeLastSubscriber<>(t, count);
+        return new TakeLastSubscriber<T>(t, count);
     }
     
     static final class TakeLastSubscriber<T> extends ArrayDeque<T> implements NbpSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeLastOne.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public static <T> NbpOperator<T, T> instance() {
     
     @Override
     public NbpSubscriber<? super Object> apply(NbpSubscriber<? super Object> s) {
-        return new TakeLastOneSubscriber<>(s);
+        return new TakeLastOneSubscriber<Object>(s);
     }
     
     static final class TakeLastOneSubscriber<T> implements NbpSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/BackpressureStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/NbpObserver.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/Observer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/BackpressureKind.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/BackpressureSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/Beta.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/Experimental.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/SchedulerKind.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/annotations/SchedulerSupport.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/Disposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/disposables/MultipleAssignmentDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -19,11 +19,11 @@ public final class MultipleAssignmentDisposable implements Disposable {
     final MultipleAssignmentResource<Disposable> resource;
     
     public MultipleAssignmentDisposable() {
-        this.resource = new MultipleAssignmentResource<>(Disposable::dispose);
+        this.resource = new MultipleAssignmentResource<Disposable>(Disposables.consumeAndDispose());
     }
     
     public MultipleAssignmentDisposable(Disposable initialDisposable) {
-        this.resource = new MultipleAssignmentResource<>(Disposable::dispose, initialDisposable);
+        this.resource = new MultipleAssignmentResource<Disposable>(Disposables.consumeAndDispose(), initialDisposable);
     }
     
     public void set(Disposable d) {

File: src/main/java/io/reactivex/disposables/SerialDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -19,11 +19,11 @@ public final class SerialDisposable implements Disposable {
     final SerialResource<Disposable> resource;
     
     public SerialDisposable() {
-        this.resource = new SerialResource<>(Disposable::dispose);
+        this.resource = new SerialResource<Disposable>(Disposables.consumeAndDispose());
     }
     
     public SerialDisposable(Disposable initialDisposable) {
-        this.resource = new SerialResource<>(Disposable::dispose, initialDisposable);
+        this.resource = new SerialResource<Disposable>(Disposables.consumeAndDispose(), initialDisposable);
     }
 
     

File: src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/OnCompleteFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/OnErrorFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/exceptions/UnsubscribeFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/ArrayCompositeResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,9 +14,9 @@
 package io.reactivex.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReferenceArray;
-import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 
 /**
  * A composite resource with a fixed number of slots.

File: src/main/java/io/reactivex/internal/disposables/CompositeResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/disposables/MultipleAssignmentResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,9 +14,9 @@
 package io.reactivex.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.internal.util.TerminalAtomicsHelper;
 
 /**

File: src/main/java/io/reactivex/internal/disposables/SerialResource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,9 +14,9 @@
 package io.reactivex.internal.disposables;
 
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.internal.util.TerminalAtomicsHelper;
 
 /**
@@ -62,6 +62,7 @@ public SerialResource(Consumer<? super T> disposer, T initialResource) {
      * Atomically replaces the current resource with the new resource but doesn't call the disposer
      * for it.
      * @param newResource the new resource to replace the old one
+     * @return true if the set succeeded, false if the container is disposed
      */
     @SuppressWarnings("unchecked")
     public boolean setResource(T newResource) {

File: src/main/java/io/reactivex/internal/operators/OperatorAll.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -13,11 +13,11 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Predicate;
 
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -29,7 +29,7 @@ public OperatorAll(Predicate<? super T> predicate) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super Boolean> t) {
-        return new AllSubscriber<>(t, predicate);
+        return new AllSubscriber<T>(t, predicate);
     }
     
     static final class AllSubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorAny.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -13,11 +13,11 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Predicate;
 
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
 public final class OperatorAny<T> implements Operator<Boolean, T> {
@@ -28,7 +28,7 @@ public OperatorAny(Predicate<? super T> predicate) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super Boolean> t) {
-        return new AnySubscriber<>(t, predicate);
+        return new AnySubscriber<T>(t, predicate);
     }
     
     static final class AnySubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorCount.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/OperatorElementAt.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public OperatorElementAt(long index, T defaultValue) {
     }
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        return new ElementAtSubscriber<>(t, index, defaultValue);
+        return new ElementAtSubscriber<T>(t, index, defaultValue);
     }
     
     static final class ElementAtSubscriber<T> implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorIgnoreElements.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -25,7 +25,7 @@ public static <T> Operator<T, T> instance() {
     }
     
     @Override
-    public Subscriber<? super Object> apply(Subscriber<? super Object> t) {
+    public Subscriber<? super Object> apply(final Subscriber<? super Object> t) {
         return new Subscriber<Object>() {
             @Override
             public void onSubscribe(Subscription s) {

File: src/main/java/io/reactivex/internal/operators/OperatorSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -23,7 +23,7 @@
 
 public final class OperatorSingle<T> implements Operator<T, T> {
     
-    static final OperatorSingle<Object> NO_DEFAULT = new OperatorSingle<>(null);
+    static final OperatorSingle<Object> NO_DEFAULT = new OperatorSingle<Object>(null);
     
     @SuppressWarnings("unchecked")
     public static <T> OperatorSingle<T> instanceNoDefault() {
@@ -36,7 +36,7 @@ public OperatorSingle(T defaultValue) {
     }
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        return new SingleElementSubscriber<>(t, defaultValue);
+        return new SingleElementSubscriber<T>(t, defaultValue);
     }
     
     static final class SingleElementSubscriber<T> implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/OperatorSkipLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -29,7 +29,7 @@ public OperatorSkipLast(int skip) {
 
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> s) {
-        return new SkipLastSubscriber<>(s, skip);
+        return new SkipLastSubscriber<T>(s, skip);
     }
     
     static final class SkipLastSubscriber<T> extends ArrayDeque<T> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/OperatorSwitchIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public OperatorSwitchIfEmpty(Publisher<? extends T> other) {
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
         // TODO Auto-generated method stub
-        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<>(t, other);
+        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<T>(t, other);
         t.onSubscribe(parent.arbiter);
         return parent;
     }

File: src/main/java/io/reactivex/internal/operators/OperatorTakeLastOne.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -30,7 +30,7 @@ public static <T> Operator<T, T> instance() {
     
     @Override
     public Subscriber<? super Object> apply(Subscriber<? super Object> s) {
-        return new TakeLastOneSubscriber<>(s);
+        return new TakeLastOneSubscriber<Object>(s);
     }
     
     static final class TakeLastOneSubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

File: src/main/java/io/reactivex/internal/operators/PublisherAutoConnect.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,11 +14,11 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
 
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.observables.ConnectableObservable;
 
 /**

File: src/main/java/io/reactivex/internal/operators/PublisherEmptySource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/PublisherGenerate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.*;
 
 import org.reactivestreams.*;
 
+import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -45,7 +45,7 @@ public void subscribe(Subscriber<? super T> s) {
             return;
         }
         
-        s.onSubscribe(new GeneratorSubscription<>(s, generator, disposeState, state));
+        s.onSubscribe(new GeneratorSubscription<T, S>(s, generator, disposeState, state));
     }
     
     static final class GeneratorSubscription<T, S> 

File: src/main/java/io/reactivex/internal/operators/PublisherLift.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/PublisherRepeat.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -32,7 +32,7 @@ public void subscribe(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter();
         s.onSubscribe(sa);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, sa, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/PublisherRepeatUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
 
 import org.reactivestreams.*;
 
+import io.reactivex.functions.BooleanSupplier;
 import io.reactivex.internal.subscriptions.SubscriptionArbiter;
 
 public final class PublisherRepeatUntil<T> implements Publisher<T> {
@@ -33,7 +33,7 @@ public void subscribe(Subscriber<? super T> s) {
         SubscriptionArbiter sa = new SubscriptionArbiter();
         s.onSubscribe(sa);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, until, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, until, sa, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/PublisherZipIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators;
 
 import java.util.Iterator;
-import java.util.function.BiFunction;
 
 import org.reactivestreams.*;
 
+import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -64,7 +64,7 @@ public void subscribe(Subscriber<? super V> t) {
             return;
         }
         
-        source.subscribe(new ZipIterableSubscriber<>(t, it, zipper));
+        source.subscribe(new ZipIterableSubscriber<T, U, V>(t, it, zipper));
     }
     
     static final class ZipIterableSubscriber<T, U, V> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeAutoConnect.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,10 +14,10 @@
 package io.reactivex.internal.operators.nbp;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
 
 import io.reactivex.NbpObservable.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import io.reactivex.observables.nbp.NbpConnectableObservable;
 
 /**

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeLift.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeRepeat.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -32,7 +32,7 @@ public void accept(NbpSubscriber<? super T> s) {
         MultipleAssignmentDisposable mad = new MultipleAssignmentDisposable();
         s.onSubscribe(mad);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, mad, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, count != Long.MAX_VALUE ? count - 1 : Long.MAX_VALUE, mad, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeRepeatUntil.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,11 +14,11 @@
 package io.reactivex.internal.operators.nbp;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
 
 import io.reactivex.NbpObservable;
 import io.reactivex.NbpObservable.*;
 import io.reactivex.disposables.*;
+import io.reactivex.functions.BooleanSupplier;
 
 public final class NbpOnSubscribeRepeatUntil<T> implements NbpOnSubscribe<T> {
     final NbpObservable<? extends T> source;
@@ -33,7 +33,7 @@ public void accept(NbpSubscriber<? super T> s) {
         MultipleAssignmentDisposable sa = new MultipleAssignmentDisposable();
         s.onSubscribe(sa);
         
-        RepeatSubscriber<T> rs = new RepeatSubscriber<>(s, until, sa, source);
+        RepeatSubscriber<T> rs = new RepeatSubscriber<T>(s, until, sa, source);
         rs.subscribeNext();
     }
     

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeZipIterable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -14,11 +14,11 @@
 package io.reactivex.internal.operators.nbp;
 
 import java.util.Iterator;
-import java.util.function.BiFunction;
 
 import io.reactivex.NbpObservable;
 import io.reactivex.NbpObservable.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.BiFunction;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -66,7 +66,7 @@ public void accept(NbpSubscriber<? super V> t) {
             return;
         }
         
-        source.subscribe(new ZipIterableSubscriber<>(t, it, zipper));
+        source.subscribe(new ZipIterableSubscriber<T, U, V>(t, it, zipper));
     }
     
     static final class ZipIterableSubscriber<T, U, V> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorCount.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorElementAt.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -26,7 +26,7 @@ public NbpOperatorElementAt(long index, T defaultValue) {
     }
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        return new ElementAtSubscriber<>(t, index, defaultValue);
+        return new ElementAtSubscriber<T>(t, index, defaultValue);
     }
     
     static final class ElementAtSubscriber<T> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorIgnoreElements.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -25,7 +25,7 @@ public static <T> NbpOperator<T, T> instance() {
     }
     
     @Override
-    public NbpSubscriber<? super Object> apply(NbpSubscriber<? super Object> t) {
+    public NbpSubscriber<? super Object> apply(final NbpSubscriber<? super Object> t) {
         return new NbpSubscriber<Object>() {
             @Override
             public void onSubscribe(Disposable s) {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorSingle.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -21,7 +21,7 @@
 
 public final class NbpOperatorSingle<T> implements NbpOperator<T, T> {
     
-    static final NbpOperatorSingle<Object> NO_DEFAULT = new NbpOperatorSingle<>(null);
+    static final NbpOperatorSingle<Object> NO_DEFAULT = new NbpOperatorSingle<Object>(null);
     
     @SuppressWarnings("unchecked")
     public static <T> NbpOperatorSingle<T> instanceNoDefault() {
@@ -34,7 +34,7 @@ public NbpOperatorSingle(T defaultValue) {
     }
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        return new SingleElementSubscriber<>(t, defaultValue);
+        return new SingleElementSubscriber<T>(t, defaultValue);
     }
     
     static final class SingleElementSubscriber<T> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorSkipLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public NbpOperatorSkipLast(int skip) {
 
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> s) {
-        return new SkipLastSubscriber<>(s, skip);
+        return new SkipLastSubscriber<T>(s, skip);
     }
     
     static final class SkipLastSubscriber<T> extends ArrayDeque<T> implements NbpSubscriber<T> {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorSwitchIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -25,7 +25,7 @@ public NbpOperatorSwitchIfEmpty(NbpObservable<? extends T> other) {
     
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<>(t, other);
+        SwitchIfEmptySubscriber<T> parent = new SwitchIfEmptySubscriber<T>(t, other);
         t.onSubscribe(parent.arbiter);
         return parent;
     }

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeLast.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -28,7 +28,7 @@ public NbpOperatorTakeLast(int count) {
 
     @Override
     public NbpSubscriber<? super T> apply(NbpSubscriber<? super T> t) {
-        return new TakeLastSubscriber<>(t, count);
+        return new TakeLastSubscriber<T>(t, count);
     }
     
     static final class TakeLastSubscriber<T> extends ArrayDeque<T> implements NbpSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/operators/nbp/NbpOperatorTakeLastOne.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2015 Netflix, Inc.
+ * Copyright 2016 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
@@ -27,7 +27,7 @@ public static <T> NbpOperator<T, T> instance() {
     
     @Override
     public NbpSubscriber<? super Object> apply(NbpSubscriber<? super Object> s) {
-        return new TakeLastOneSubscriber<>(s);
+        return new TakeLastOneSubscriber<Object>(s);
     }
     
     static final class TakeLastOneSubscriber<T> implements NbpSubscriber<T>, Disposable {

File: src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
Patch:
@@ -79,7 +79,7 @@ public final boolean offer(final T e) {
             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                 return writeToQueue(buffer, e, index, offset);
-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
                 return writeToQueue(buffer, e, index, offset);
             } else {
                 resize(buffer, index, offset, e, mask); // add a buffer and link old to new

File: src/main/java/io/reactivex/internal/operators/OperatorTake.java
Patch:
@@ -62,9 +62,10 @@ public void onSubscribe(Subscription s) {
         }
         @Override
         public void onNext(T t) {
-            if (!done) {
+            if (!done && remaining-- > 0) {
+                boolean stop = remaining == 0;
                 actual.onNext(t);
-                if (--remaining == 0L) {
+                if (stop) {
                     onComplete();
                 }
             }

File: src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
Patch:
@@ -79,7 +79,7 @@ public final boolean offer(final T e) {
             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                 return writeToQueue(buffer, e, index, offset);
-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
                 return writeToQueue(buffer, e, index, offset);
             } else {
                 resize(buffer, index, offset, e, mask); // add a buffer and link old to new

File: src/main/java/io/reactivex/internal/operators/OperatorTake.java
Patch:
@@ -62,9 +62,10 @@ public void onSubscribe(Subscription s) {
         }
         @Override
         public void onNext(T t) {
-            if (!done) {
+            if (!done && remaining-- > 0) {
+                boolean stop = remaining == 0;
                 actual.onNext(t);
-                if (--remaining == 0L) {
+                if (stop) {
                     onComplete();
                 }
             }

File: src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
Patch:
@@ -122,9 +122,9 @@ public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, Time
         Future<?> f;
         try {
             if (delayTime <= 0) {
-                f = executor.submit(run);
+                f = executor.submit(sr);
             } else {
-                f = executor.schedule(run, delayTime, unit);
+                f = executor.schedule(sr, delayTime, unit);
             }
             sr.setFuture(f);
         } catch (RejectedExecutionException ex) {

File: src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
Patch:
@@ -122,9 +122,9 @@ public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, Time
         Future<?> f;
         try {
             if (delayTime <= 0) {
-                f = executor.submit(run);
+                f = executor.submit(sr);
             } else {
-                f = executor.schedule(run, delayTime, unit);
+                f = executor.schedule(sr, delayTime, unit);
             }
             sr.setFuture(f);
         } catch (RejectedExecutionException ex) {

File: src/main/java/io/reactivex/internal/operators/OperatorWithLatestFrom.java
Patch:
@@ -121,8 +121,6 @@ public void onNext(T t) {
                     return;
                 }
                 actual.onNext(r);
-            } else {
-                s.request(1);
             }
         }
         

File: src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java
Patch:
@@ -67,6 +67,8 @@ public void run() {
                     if (compareAndSet(FUTURE_INDEX, o, DONE)) {
                         break;
                     }
+                } else {
+                    break;
                 }
             }
         }

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -20,6 +20,7 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.subscribers.EmptySubscriber;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
 /**
@@ -199,8 +200,7 @@ public void onComplete() {
     
     @Override
     public void request(long n) {
-        if (n <= 0) {
-            errors.add(new IllegalArgumentException("n > 0 required but it was " + n));
+        if (SubscriptionHelper.validateRequest(n)) {
             return;
         }
         Subscription s = subscription;

File: src/test/java/io/reactivex/internal/operators/OperatorReplayTest.java
Patch:
@@ -602,7 +602,7 @@ public void testIssue2191_SchedulerUnsubscribe() throws Exception {
 //        verify(spiedWorker, times(1)).isUnsubscribed();
         // FIXME publish calls cancel too
         verify(spiedWorker, times(2)).dispose();
-        verify(sourceUnsubscribed, times(2)).run();
+        verify(sourceUnsubscribed, times(1)).run();
 
         verifyNoMoreInteractions(sourceNext);
         verifyNoMoreInteractions(sourceCompleted);
@@ -668,7 +668,7 @@ public void testIssue2191_SchedulerUnsubscribeOnError() throws Exception {
 //        verify(spiedWorker, times(1)).isUnsubscribed();
         // FIXME publish also calls cancel
         verify(spiedWorker, times(2)).dispose();
-        verify(sourceUnsubscribed, times(2)).run();
+        verify(sourceUnsubscribed, times(1)).run();
 
         verifyNoMoreInteractions(sourceNext);
         verifyNoMoreInteractions(sourceCompleted);

File: src/test/java/io/reactivex/internal/operators/OperatorToObservableListTest.java
Patch:
@@ -78,6 +78,7 @@ public void testListMultipleSubscribers() {
     }
 
     @Test
+    @Ignore("Null values are not allowed")
     public void testListWithNullValue() {
         Observable<String> w = Observable.fromIterable(Arrays.asList("one", null, "three"));
         Observable<List<String>> observable = w.toList();

File: src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java
Patch:
@@ -19,6 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -92,11 +93,11 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(REQUESTED, this, n);
+            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java
Patch:
@@ -19,6 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -92,11 +93,11 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(REQUESTED, this, n);
+            drain();
         }
         
         @Override

File: src/main/java/io/reactivex/subscribers/SerializedSubscriber.java
Patch:
@@ -98,6 +98,7 @@ public void onError(Throwable t) {
                 reportError = true;
             } else
             if (emitting) {
+                done = true;
                 AppendOnlyLinkedArrayList<Object> q = queue;
                 if (q == null) {
                     q = new AppendOnlyLinkedArrayList<>(QUEUE_LINK_SIZE);

File: src/main/java/io/reactivex/subscribers/SerializedSubscriber.java
Patch:
@@ -98,6 +98,7 @@ public void onError(Throwable t) {
                 reportError = true;
             } else
             if (emitting) {
+                done = true;
                 AppendOnlyLinkedArrayList<Object> q = queue;
                 if (q == null) {
                     q = new AppendOnlyLinkedArrayList<>(QUEUE_LINK_SIZE);

File: src/main/java/io/reactivex/Try.java
Patch:
@@ -108,7 +108,7 @@ public int hashCode() {
     @Override
     public String toString() {
         if (error != null) {
-            return "Try[" + error + "]";
+            return "Try[ " + error + " ]";
         }
         return "Try[" + value + "]";
     }

File: src/main/java/io/reactivex/internal/operators/OperatorReplay.java
Patch:
@@ -296,6 +296,7 @@ public void dispose() {
             // current.compareAndSet(ReplaySubscriber.this, null);
             // we don't care if it fails because it means the current has 
             // been replaced in the meantime
+            subscription.cancel();
         }
 
         /**

File: src/main/java/io/reactivex/internal/operators/SubscriberResourceWrapper.java
Patch:
@@ -19,6 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class SubscriberResourceWrapper<T, R> extends AtomicReference<Object> implements Subscriber<T>, Disposable, Subscription {
@@ -62,7 +63,7 @@ public void onSubscribe(Subscription s) {
             }
             if (current != null) {
                 s.cancel();
-                RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
+                SubscriptionHelper.reportSubscriptionSet();
                 return;
             }
             if (SUBSCRIPTION.compareAndSet(this, null, s)) {
@@ -91,8 +92,7 @@ public void onComplete() {
     
     @Override
     public void request(long n) {
-        if (n <= 0) {
-            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+        if (SubscriptionHelper.validateRequest(n)) {
             return;
         }
         subscription.request(n);

File: src/main/java/io/reactivex/internal/operators/PublisherRedo.java
Patch:
@@ -115,6 +115,9 @@ void handle(Try<Optional<Object>> notification) {
                         if (WIP.getAndIncrement(this) == 0) {
                             int missed = 1;
                             for (;;) {
+                                if (arbiter.isCancelled()) {
+                                    return;
+                                }
                                 source.subscribe(this);
                             
                                 missed = WIP.addAndGet(this, -missed);

File: src/main/java/io/reactivex/internal/operators/PublisherRetryPredicate.java
Patch:
@@ -106,6 +106,9 @@ void subscribeNext() {
             if (getAndIncrement() == 0) {
                 int missed = 1;
                 for (;;) {
+                    if (sa.isCancelled()) {
+                        return;
+                    }
                     source.subscribe(this);
                     
                     missed = addAndGet(-missed);

File: src/main/java/io/reactivex/internal/operators/PublisherRedo.java
Patch:
@@ -115,6 +115,9 @@ void handle(Try<Optional<Object>> notification) {
                         if (WIP.getAndIncrement(this) == 0) {
                             int missed = 1;
                             for (;;) {
+                                if (arbiter.isCancelled()) {
+                                    return;
+                                }
                                 source.subscribe(this);
                             
                                 missed = WIP.addAndGet(this, -missed);

File: src/main/java/io/reactivex/internal/operators/PublisherRetryPredicate.java
Patch:
@@ -106,6 +106,9 @@ void subscribeNext() {
             if (getAndIncrement() == 0) {
                 int missed = 1;
                 for (;;) {
+                    if (sa.isCancelled()) {
+                        return;
+                    }
                     source.subscribe(this);
                     
                     missed = addAndGet(-missed);

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -1467,6 +1467,7 @@ public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayErr
     }
 
     public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded) {
+        validateBufferSize(bufferSize);
         return lift(new OperatorOnBackpressureBuffer<>(bufferSize, unbounded, delayError, () -> { }));
     }
 

File: src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureBuffer.java
Patch:
@@ -19,6 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.queue.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
@@ -96,13 +97,14 @@ public void onSubscribe(Subscription s) {
         public void onNext(T t) {
             if (!queue.offer(t)) {
                 s.cancel();
-                IllegalStateException ex = new IllegalStateException("Buffer is full?!");
+                MissingBackpressureException ex = new MissingBackpressureException("Buffer is full");
                 try {
                     onOverflow.run();
                 } catch (Throwable e) {
                     ex.addSuppressed(e);
                 }
                 onError(ex);
+                return;
             }
             drain();
         }

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -1467,6 +1467,7 @@ public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayErr
     }
 
     public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded) {
+        validateBufferSize(bufferSize);
         return lift(new OperatorOnBackpressureBuffer<>(bufferSize, unbounded, delayError, () -> { }));
     }
 

File: src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureBuffer.java
Patch:
@@ -19,6 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.queue.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
@@ -96,13 +97,14 @@ public void onSubscribe(Subscription s) {
         public void onNext(T t) {
             if (!queue.offer(t)) {
                 s.cancel();
-                IllegalStateException ex = new IllegalStateException("Buffer is full?!");
+                MissingBackpressureException ex = new MissingBackpressureException("Buffer is full");
                 try {
                     onOverflow.run();
                 } catch (Throwable e) {
                     ex.addSuppressed(e);
                 }
                 onError(ex);
+                return;
             }
             drain();
         }

File: src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java
Patch:
@@ -188,6 +188,9 @@ void combine(T value, int index) {
                 if (!empty) {
                     if (value != null && f) {
                         queue.offer(cs, latest.clone());
+                    } else
+                    if (value == null && error != null) {
+                        done = true; // if this source completed without a value
                     }
                 } else {
                     done = true;

File: src/main/java/io/reactivex/subjects/PublishSubject.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -303,7 +304,7 @@ public void onNext(T t) {
                 }
             } else {
                 cancel();
-                actual.onError(new IllegalStateException("Could not emit value due to lack of requests"));
+                actual.onError(new MissingBackpressureException("Could not emit value due to lack of requests"));
             }
         }
         

File: src/main/java/io/reactivex/internal/operators/OperatorTakeLastOne.java
Patch:
@@ -18,7 +18,6 @@
 
 import io.reactivex.Observable.Operator;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
-import io.reactivex.plugins.RxJavaPlugins;
 
 public enum OperatorTakeLastOne implements Operator<Object, Object> {
     INSTANCE
@@ -93,8 +92,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/observables/BlockingObservable.java
Patch:
@@ -226,6 +226,7 @@ protected void onStart() {
                 f.whenComplete((v, e) -> {
                     cancel();
                 });
+                request(Long.MAX_VALUE);
             }
             
             @Override

File: src/test/java/io/reactivex/internal/operators/OnSubscribeRefCountTest.java
Patch:
@@ -194,7 +194,7 @@ public void testConnectUnsubscribe() throws InterruptedException {
 
     @Test
     public void testConnectUnsubscribeRaceConditionLoop() throws InterruptedException {
-        for (int i = 0; i < 1000; i++) {
+        for (int i = 0; i < 100; i++) {
             testConnectUnsubscribeRaceCondition();
         }
     }
@@ -221,7 +221,7 @@ public void testConnectUnsubscribeRaceCondition() throws InterruptedException {
         s.dispose();
         // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled
         // give time to the counter to update
-        Thread.sleep(5);
+        Thread.sleep(10);
         // either we subscribed and then unsubscribed, or we didn't ever even subscribe
         assertEquals(0, subUnsubCount.get());
 

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -755,7 +755,7 @@ protected Observable(Publisher<T> onSubscribe) {
 
     public final Observable<Boolean> all(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
-        return lift(new OperatorAny<>(predicate));
+        return lift(new OperatorAll<>(predicate));
     }
 
     public final Observable<T> ambWith(Publisher<? extends T> other) {
@@ -1257,7 +1257,7 @@ public final Observable<T> ignoreElements() {
     }
 
     public final Observable<Boolean> isEmpty() {
-        return any(v -> true);
+        return all(v -> false);
     }
 
     public static final <T> Observable<T> just(T v1, T v2) {

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -755,7 +755,7 @@ protected Observable(Publisher<T> onSubscribe) {
 
     public final Observable<Boolean> all(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
-        return lift(new OperatorAny<>(predicate));
+        return lift(new OperatorAll<>(predicate));
     }
 
     public final Observable<T> ambWith(Publisher<? extends T> other) {
@@ -1257,7 +1257,7 @@ public final Observable<T> ignoreElements() {
     }
 
     public final Observable<Boolean> isEmpty() {
-        return any(v -> true);
+        return all(v -> false);
     }
 
     public static final <T> Observable<T> just(T v1, T v2) {

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -551,6 +551,9 @@ public static <T> Observable<T> never() {
     }
 
     public static Observable<Integer> range(int start, int count) {
+        if (count < 0) {
+            throw new IllegalArgumentException("count >= required but it was " + count);
+        } else
         if (count == 0) {
             return empty();
         } else

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -551,6 +551,9 @@ public static <T> Observable<T> never() {
     }
 
     public static Observable<Integer> range(int start, int count) {
+        if (count < 0) {
+            throw new IllegalArgumentException("count >= required but it was " + count);
+        } else
         if (count == 0) {
             return empty();
         } else

File: src/main/java/io/reactivex/internal/operators/PublisherAmb.java
Patch:
@@ -39,7 +39,7 @@ public void subscribe(Subscriber<? super T> s) {
             sources = new Publisher[8];
             for (Publisher<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Publisher<? extends T>[] b = new Publisher[count + count >> 2];
+                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/operators/PublisherZip.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super R> s) {
             sources = new Publisher[8];
             for (Publisher<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Publisher<? extends T>[] b = new Publisher[count + count >> 2];
+                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/operators/PublisherAmb.java
Patch:
@@ -39,7 +39,7 @@ public void subscribe(Subscriber<? super T> s) {
             sources = new Publisher[8];
             for (Publisher<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Publisher<? extends T>[] b = new Publisher[count + count >> 2];
+                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/operators/PublisherZip.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super R> s) {
             sources = new Publisher[8];
             for (Publisher<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Publisher<? extends T>[] b = new Publisher[count + count >> 2];
+                    Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }

File: src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
Patch:
@@ -47,7 +47,7 @@ public MpscLinkedQueue() {
      */
     @Override
     public final boolean offer(final T nextValue) {
-        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<>();
+        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<>(nextValue);
         final LinkedQueueNode<T> prevProducerNode = xchgProducerNode(nextNode);
         // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed
         // and completes the store in prev.next.

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -68,8 +68,7 @@ private long addRequested(long n) {
     
     @Override
     public void request(long n) {
-        if (n <= 0) {
-            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+        if (SubscriptionHelper.validateRequest(n)) {
             return;
         }
         if (cancelled) {

File: src/main/java/io/reactivex/internal/operators/OperatorScan.java
Patch:
@@ -28,8 +28,7 @@ public OperatorScan(BiFunction<T, T, T> accumulator) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        // TODO Auto-generated method stub
-        return null;
+        return new ScanSubscriber<>(t, accumulator);
     }
     
     static final class ScanSubscriber<T> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java
Patch:
@@ -60,6 +60,7 @@ public ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T,
             super(actual, new SpscArrayQueue<>(2));
             this.accumulator = accumulator;
             this.value = value;
+            queue.offer(value);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/OperatorTake.java
Patch:
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -86,8 +87,7 @@ public void onComplete() {
         }
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/PublisherAmb.java
Patch:
@@ -107,7 +107,7 @@ public void request(long n) {
             } else
             if (w == 0) {
                 for (AmbInnerSubscriber<T> a : subscribers) {
-                    a.cancel();
+                    a.request(n);
                 }
             }
         }

File: src/main/java/io/reactivex/observables/ConnectableObservable.java
Patch:
@@ -55,7 +55,7 @@ protected ConnectableObservable(Publisher<T> onSubscribe) {
      * Instructs the {@code ConnectableObservable} to begin emitting the items from its underlying
      * {@link Observable} to its {@link Subscriber}s.
      * <p>
-     * To disconnect from a synchronous source, use the {@link #connect(rx.functions.Action1)} method.
+     * To disconnect from a synchronous source, use the {@link #connect(java.util.function.Consumer)} method.
      *
      * @return the subscription representing the connection
      * @see <a href="http://reactivex.io/documentation/operators/connect.html">ReactiveX documentation: Connect</a>

File: src/main/java/io/reactivex/observables/ConnectableObservable.java
Patch:
@@ -55,7 +55,7 @@ protected ConnectableObservable(Publisher<T> onSubscribe) {
      * Instructs the {@code ConnectableObservable} to begin emitting the items from its underlying
      * {@link Observable} to its {@link Subscriber}s.
      * <p>
-     * To disconnect from a synchronous source, use the {@link #connect(rx.functions.Action1)} method.
+     * To disconnect from a synchronous source, use the {@link #connect(java.util.function.Consumer)} method.
      *
      * @return the subscription representing the connection
      * @see <a href="http://reactivex.io/documentation/operators/connect.html">ReactiveX documentation: Connect</a>

File: src/main/java/io/reactivex/internal/operators/OperatorScan.java
Patch:
@@ -28,8 +28,7 @@ public OperatorScan(BiFunction<T, T, T> accumulator) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        // TODO Auto-generated method stub
-        return null;
+        return new ScanSubscriber<>(t, accumulator);
     }
     
     static final class ScanSubscriber<T> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java
Patch:
@@ -60,6 +60,7 @@ public ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T,
             super(actual, new SpscArrayQueue<>(2));
             this.accumulator = accumulator;
             this.value = value;
+            queue.offer(value);
         }
 
         @Override

File: src/main/java/io/reactivex/internal/operators/OperatorTake.java
Patch:
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -86,8 +87,7 @@ public void onComplete() {
         }
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {

File: src/main/java/io/reactivex/internal/operators/PublisherAmb.java
Patch:
@@ -107,7 +107,7 @@ public void request(long n) {
             } else
             if (w == 0) {
                 for (AmbInnerSubscriber<T> a : subscribers) {
-                    a.cancel();
+                    a.request(n);
                 }
             }
         }

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -85,7 +85,7 @@ public void cancel() {
      * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.
      */
     public TestSubscriber() {
-        this(EmptySubscriber.INSTANCE, Long.MAX_VALUE);
+        this(EmptySubscriber.INSTANCE_NOERROR, Long.MAX_VALUE);
     }
 
     /**
@@ -95,7 +95,7 @@ public TestSubscriber() {
      * @param initialRequest the initial request value if not null
      */
     public TestSubscriber(Long initialRequest) {
-        this(EmptySubscriber.INSTANCE, initialRequest);
+        this(EmptySubscriber.INSTANCE_NOERROR, initialRequest);
     }
 
     /**

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -85,7 +85,7 @@ public void cancel() {
      * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.
      */
     public TestSubscriber() {
-        this(EmptySubscriber.INSTANCE, Long.MAX_VALUE);
+        this(EmptySubscriber.INSTANCE_NOERROR, Long.MAX_VALUE);
     }
 
     /**
@@ -95,7 +95,7 @@ public TestSubscriber() {
      * @param initialRequest the initial request value if not null
      */
     public TestSubscriber(Long initialRequest) {
-        this(EmptySubscriber.INSTANCE, initialRequest);
+        this(EmptySubscriber.INSTANCE_NOERROR, initialRequest);
     }
 
     /**

File: src/main/java/io/reactivex/internal/operators/OperatorDoOnEach.java
Patch:
@@ -38,8 +38,7 @@ public OperatorDoOnEach(Consumer<? super T> onNext,
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        // TODO Auto-generated method stub
-        return null;
+        return new DoOnEachSubscriber<>(t, onNext, onError, onComplete, onAfterTerminate);
     }
     
     static final class DoOnEachSubscriber<T> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/PublisherSubscribeOn.java
Patch:
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Scheduler;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class PublisherSubscribeOn<T> implements Publisher<T> {
@@ -95,8 +96,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (Thread.currentThread() == get()) {

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -404,7 +404,7 @@ public void assertNotComplete() {
     /**
      * Assert that this TestSubscriber has not received any onError event.
      */
-    public void assertNoError() {
+    public void assertNoErrors() {
         String prefix = "";
         if (done.getCount() != 0) {
             prefix = "Subscriber still running! ";

File: src/main/java/io/reactivex/internal/operators/OperatorDoOnEach.java
Patch:
@@ -38,8 +38,7 @@ public OperatorDoOnEach(Consumer<? super T> onNext,
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        // TODO Auto-generated method stub
-        return null;
+        return new DoOnEachSubscriber<>(t, onNext, onError, onComplete, onAfterTerminate);
     }
     
     static final class DoOnEachSubscriber<T> implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/PublisherSubscribeOn.java
Patch:
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Scheduler;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class PublisherSubscribeOn<T> implements Publisher<T> {
@@ -95,8 +96,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (Thread.currentThread() == get()) {

File: src/main/java/io/reactivex/subscribers/TestSubscriber.java
Patch:
@@ -404,7 +404,7 @@ public void assertNotComplete() {
     /**
      * Assert that this TestSubscriber has not received any onError event.
      */
-    public void assertNoError() {
+    public void assertNoErrors() {
         String prefix = "";
         if (done.getCount() != 0) {
             prefix = "Subscriber still running! ";

File: src/main/java/io/reactivex/internal/operators/OperatorDebounceTimed.java
Patch:
@@ -59,7 +59,7 @@ static final class DebounceTimedSubscriber<T> extends AtomicInteger
         volatile Disposable timer;
         @SuppressWarnings("rawtypes")
         static final AtomicReferenceFieldUpdater<DebounceTimedSubscriber, Disposable> TIMER =
-                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "debouncer");
+                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "timer");
 
         static final Disposable CANCELLED = () -> { };
 
@@ -91,6 +91,7 @@ public void disposeTimer() {
                 }
             }
         }
+        
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {

File: src/main/java/io/reactivex/internal/operators/OperatorReplay.java
Patch:
@@ -49,10 +49,10 @@ public final class OperatorReplay<T> extends ConnectableObservable<T> {
      */
     public static <T, U, R> Observable<R> multicastSelector(
             final Supplier<? extends ConnectableObservable<U>> connectableFactory,
-            final Function<? super Observable<U>, ? extends Observable<R>> selector) {
+            final Function<? super Observable<U>, ? extends Publisher<R>> selector) {
         return Observable.create(child -> {
             ConnectableObservable<U> co;
-            Observable<R> observable;
+            Publisher<R> observable;
             try {
                 co = connectableFactory.get();
                 observable = selector.apply(co);

File: src/main/java/io/reactivex/internal/operators/OperatorDebounceTimed.java
Patch:
@@ -59,7 +59,7 @@ static final class DebounceTimedSubscriber<T> extends AtomicInteger
         volatile Disposable timer;
         @SuppressWarnings("rawtypes")
         static final AtomicReferenceFieldUpdater<DebounceTimedSubscriber, Disposable> TIMER =
-                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "debouncer");
+                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "timer");
 
         static final Disposable CANCELLED = () -> { };
 
@@ -91,6 +91,7 @@ public void disposeTimer() {
                 }
             }
         }
+        
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {

File: src/main/java/io/reactivex/internal/operators/OperatorReplay.java
Patch:
@@ -49,10 +49,10 @@ public final class OperatorReplay<T> extends ConnectableObservable<T> {
      */
     public static <T, U, R> Observable<R> multicastSelector(
             final Supplier<? extends ConnectableObservable<U>> connectableFactory,
-            final Function<? super Observable<U>, ? extends Observable<R>> selector) {
+            final Function<? super Observable<U>, ? extends Publisher<R>> selector) {
         return Observable.create(child -> {
             ConnectableObservable<U> co;
-            Observable<R> observable;
+            Publisher<R> observable;
             try {
                 co = connectableFactory.get();
                 observable = selector.apply(co);

File: src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java
Patch:
@@ -84,7 +84,7 @@ public boolean add(T newResource) {
      * Removes the given resource from this composite and calls the disposer if the resource
      * was indeed in the composite.
      * @param resource the resource to remove, not-null (not verified)
-     * @return
+     * @return true if the resource was removed, false otherwise
      */
     @Override
     public boolean remove(T resource) {

File: src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java
Patch:
@@ -84,7 +84,7 @@ public boolean add(T newResource) {
      * Removes the given resource from this composite and calls the disposer if the resource
      * was indeed in the composite.
      * @param resource the resource to remove, not-null (not verified)
-     * @return
+     * @return true if the resource was removed, false otherwise
      */
     @Override
     public boolean remove(T resource) {

File: src/main/java/io/reactivex/internal/operators/PublisherRedo.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
         s.onSubscribe(parent.arbiter);
 
         // trigger first subscription
-        parent.handle(Notification.ofNull());
+        parent.handle(Notification.complete());
     }
     
     static final class RedoSubscriber<T> extends AtomicBoolean implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/operators/PublisherRedo.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
         s.onSubscribe(parent.arbiter);
 
         // trigger first subscription
-        parent.handle(Notification.ofNull());
+        parent.handle(Notification.complete());
     }
     
     static final class RedoSubscriber<T> extends AtomicBoolean implements Subscriber<T> {

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -93,6 +93,9 @@ public void produced(long n) {
         }
         QueueDrainHelper.queueDrainLoop(this, () -> {
             long r = requested;
+            if (r == Long.MAX_VALUE) {
+                return;
+            }
             long u = r - n;
             if (u < 0L) {
                 RxJavaPlugins.onError(new IllegalArgumentException("More produced than requested: " + u));

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -93,6 +93,9 @@ public void produced(long n) {
         }
         QueueDrainHelper.queueDrainLoop(this, () -> {
             long r = requested;
+            if (r == Long.MAX_VALUE) {
+                return;
+            }
             long u = r - n;
             if (u < 0L) {
                 RxJavaPlugins.onError(new IllegalArgumentException("More produced than requested: " + u));

File: src/main/java/io/reactivex/internal/queue/BaseArrayQueue.java
Patch:
@@ -29,7 +29,7 @@ abstract class BaseArrayQueue<E> extends AtomicReferenceArray<E> implements Queu
     protected final int mask;
     public BaseArrayQueue(int capacity) {
         super(Pow2.roundToPowerOfTwo(capacity));
-        this.mask = size() - 1;
+        this.mask = length() - 1;
     }
     @Override
     public Iterator<E> iterator() {

File: src/main/java/io/reactivex/internal/queue/BaseArrayQueue.java
Patch:
@@ -29,7 +29,7 @@ abstract class BaseArrayQueue<E> extends AtomicReferenceArray<E> implements Queu
     protected final int mask;
     public BaseArrayQueue(int capacity) {
         super(Pow2.roundToPowerOfTwo(capacity));
-        this.mask = size() - 1;
+        this.mask = length() - 1;
     }
     @Override
     public Iterator<E> iterator() {

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -100,7 +100,7 @@ public void produced(long n) {
             }
             requested = u;
         }, () -> {
-            BackpressureHelper.add(MISSED_REQUESTED, this, n);
+            BackpressureHelper.add(MISSED_PRODUCED, this, n);
         }, this::drain);
     }
     

File: src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
Patch:
@@ -100,7 +100,7 @@ public void produced(long n) {
             }
             requested = u;
         }, () -> {
-            BackpressureHelper.add(MISSED_REQUESTED, this, n);
+            BackpressureHelper.add(MISSED_PRODUCED, this, n);
         }, this::drain);
     }
     

File: src/main/java/io/reactivex/Observable.java
Patch:
@@ -477,7 +477,7 @@ public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends
     }
 
     public final ConnectableObservable<T> replay() {
-        return OperatorReplay.create(this);
+        return OperatorReplay.createFrom(this);
     }
 
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Observable<R>> selector) {
@@ -547,5 +547,4 @@ public final ConnectableObservable<T> replay(final long time, final TimeUnit uni
     public final ConnectableObservable<T> replay(final Scheduler scheduler) {
         return OperatorReplay.observeOn(replay(), scheduler);
     }
-
 }

File: src/main/java/io/reactivex/internal/operators/OperatorReplay.java
Patch:
@@ -92,8 +92,9 @@ public void connect(Consumer<? super Disposable> connection) {
      * @param source
      * @return
      */
+    // TODO javac 1.8 fails with ambiguity error if this method is called create(), works properly
     @SuppressWarnings("unchecked")
-    public static <T> ConnectableObservable<T> create(Observable<? extends T> source) {
+    public static <T> ConnectableObservable<T> createFrom(Observable<? extends T> source) {
         return create(source, DEFAULT_UNBOUNDED_FACTORY);
     }
     
@@ -106,7 +107,7 @@ public static <T> ConnectableObservable<T> create(Observable<? extends T> source
     public static <T> ConnectableObservable<T> create(Observable<? extends T> source, 
             final int bufferSize) {
         if (bufferSize == Integer.MAX_VALUE) {
-            return create(source);
+            return createFrom(source);
         }
         return create(source, () -> new SizeBoundReplayBuffer<>(bufferSize));
     }

File: src/main/java/io/reactivex/Observer.java
Patch:
@@ -15,14 +15,15 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 public abstract class Observer<T> implements Subscriber<T> {
     private Subscription s;
     @Override
     public final void onSubscribe(Subscription s) {
         if (this.s != null) {
             s.cancel();
-            // TODO plugin error handler
-            new IllegalStateException("Subscription already set!").printStackTrace();
+            RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
             return;
         }
         this.s = s;

File: src/main/java/io/reactivex/internal/operators/PublisherArraySource.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * 
@@ -54,7 +55,7 @@ public ArraySourceSubscription(T[] array, Subscriber<? super T> subscriber) {
         @Override
         public void request(long n) {
             if (n <= 0) {
-                new IllegalArgumentException("n > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
                 return;
             }
             if (BackpressureHelper.add(this, n) == 0L) {

File: src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java
Patch:
@@ -22,6 +22,7 @@
 
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  *
@@ -62,7 +63,7 @@ public IteratorSourceSubscription(Iterator<? extends T> it, Subscriber<? super T
         @Override
         public void request(long n) {
             if (n <= 0) {
-                new IllegalArgumentException("n > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
                 return;
             }
             if (BackpressureHelper.add(this, n) != 0L) {

File: src/main/java/io/reactivex/internal/operators/PublisherRangeSource.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * 
@@ -61,7 +62,7 @@ public void request(long n) {
                     slowpath(n);
                 }
             } else {
-                new IllegalArgumentException("request > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("request > 0 required but it was " + n));
             }
         }
         

File: src/main/java/io/reactivex/internal/operators/PublisherStreamSource.java
Patch:
@@ -23,6 +23,7 @@
 
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  *
@@ -75,7 +76,7 @@ public StreamSourceSubscription(Stream<? extends T> stream, Iterator<? extends T
         @Override
         public void request(long n) {
             if (n <= 0) {
-                new IllegalArgumentException("n > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
                 return;
             }
             BackpressureHelper.add(this, n);

File: src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java
Patch:
@@ -18,6 +18,7 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ScheduledRunnable extends AtomicReferenceArray<Object> implements Runnable, Disposable {
     /** */
@@ -40,8 +41,7 @@ public void run() {
         try {
             actual.run();
         } catch (Throwable e) {
-            // TODO error management with plugins, etc.
-            e.printStackTrace();
+            RxJavaPlugins.onError(e);
         } finally {
             Object o = get(0);
             if (o != DISPOSED) {

File: src/main/java/io/reactivex/internal/subscriptions/EmptySubscription.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.reactivestreams.Subscription;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 /**
  * 
  */
@@ -26,7 +28,7 @@ public enum EmptySubscription implements Subscription {
     @Override
     public void request(long n) {
         if (n <= 0) {
-            new IllegalArgumentException("n > 0 required").printStackTrace();
+            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required"));
         }
     }
     @Override

File: src/main/java/io/reactivex/internal/subscriptions/ScalarAsyncSubscription.java
Patch:
@@ -21,6 +21,8 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 /**
  * 
  */
@@ -43,7 +45,7 @@ public ScalarAsyncSubscription(Subscriber<? super T> subscriber) {
     @Override
     public void request(long n) {
         if (n <= 0) {
-            new IllegalArgumentException("n > 0 required").printStackTrace();
+            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
             return;
         }
         for (;;) {

File: src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
Patch:
@@ -20,6 +20,8 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 /**
  * 
  */
@@ -39,7 +41,7 @@ public ScalarSubscription(Subscriber<? super T> subscriber, T value) {
     @Override
     public void request(long n) {
         if (n <= 0) {
-            new IllegalArgumentException("n > 0 required").printStackTrace();
+            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
             return;
         }
         if (compareAndSet(false, true)) {

File: src/main/java/io/reactivex/Observer.java
Patch:
@@ -15,14 +15,15 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 public abstract class Observer<T> implements Subscriber<T> {
     private Subscription s;
     @Override
     public final void onSubscribe(Subscription s) {
         if (this.s != null) {
             s.cancel();
-            // TODO plugin error handler
-            new IllegalStateException("Subscription already set!").printStackTrace();
+            RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
             return;
         }
         this.s = s;

File: src/main/java/io/reactivex/internal/operators/PublisherArraySource.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * 
@@ -54,7 +55,7 @@ public ArraySourceSubscription(T[] array, Subscriber<? super T> subscriber) {
         @Override
         public void request(long n) {
             if (n <= 0) {
-                new IllegalArgumentException("n > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
                 return;
             }
             if (BackpressureHelper.add(this, n) == 0L) {

File: src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java
Patch:
@@ -22,6 +22,7 @@
 
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  *
@@ -62,7 +63,7 @@ public IteratorSourceSubscription(Iterator<? extends T> it, Subscriber<? super T
         @Override
         public void request(long n) {
             if (n <= 0) {
-                new IllegalArgumentException("n > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
                 return;
             }
             if (BackpressureHelper.add(this, n) != 0L) {

File: src/main/java/io/reactivex/internal/operators/PublisherRangeSource.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * 
@@ -61,7 +62,7 @@ public void request(long n) {
                     slowpath(n);
                 }
             } else {
-                new IllegalArgumentException("request > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("request > 0 required but it was " + n));
             }
         }
         

File: src/main/java/io/reactivex/internal/operators/PublisherStreamSource.java
Patch:
@@ -23,6 +23,7 @@
 
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  *
@@ -75,7 +76,7 @@ public StreamSourceSubscription(Stream<? extends T> stream, Iterator<? extends T
         @Override
         public void request(long n) {
             if (n <= 0) {
-                new IllegalArgumentException("n > 0 required").printStackTrace();
+                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
                 return;
             }
             BackpressureHelper.add(this, n);

File: src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java
Patch:
@@ -18,6 +18,7 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ScheduledRunnable extends AtomicReferenceArray<Object> implements Runnable, Disposable {
     /** */
@@ -40,8 +41,7 @@ public void run() {
         try {
             actual.run();
         } catch (Throwable e) {
-            // TODO error management with plugins, etc.
-            e.printStackTrace();
+            RxJavaPlugins.onError(e);
         } finally {
             Object o = get(0);
             if (o != DISPOSED) {

File: src/main/java/io/reactivex/internal/subscriptions/EmptySubscription.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.reactivestreams.Subscription;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 /**
  * 
  */
@@ -26,7 +28,7 @@ public enum EmptySubscription implements Subscription {
     @Override
     public void request(long n) {
         if (n <= 0) {
-            new IllegalArgumentException("n > 0 required").printStackTrace();
+            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required"));
         }
     }
     @Override

File: src/main/java/io/reactivex/internal/subscriptions/ScalarAsyncSubscription.java
Patch:
@@ -21,6 +21,8 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 /**
  * 
  */
@@ -43,7 +45,7 @@ public ScalarAsyncSubscription(Subscriber<? super T> subscriber) {
     @Override
     public void request(long n) {
         if (n <= 0) {
-            new IllegalArgumentException("n > 0 required").printStackTrace();
+            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
             return;
         }
         for (;;) {

File: src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
Patch:
@@ -20,6 +20,8 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.plugins.RxJavaPlugins;
+
 /**
  * 
  */
@@ -39,7 +41,7 @@ public ScalarSubscription(Subscriber<? super T> subscriber, T value) {
     @Override
     public void request(long n) {
         if (n <= 0) {
-            new IllegalArgumentException("n > 0 required").printStackTrace();
+            RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
             return;
         }
         if (compareAndSet(false, true)) {

File: src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java
Patch:
@@ -27,7 +27,6 @@
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.functions.Action0;
-import rx.functions.Action1;
 import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
 import rx.subscriptions.Subscriptions;

File: src/main/java/rx/functions/Actions.java
Patch:
@@ -24,14 +24,14 @@ private Actions() {
     }
 
     @SuppressWarnings("unchecked")
-    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> empty() {
+    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {
         return EMPTY_ACTION;
     }
 
     @SuppressWarnings("rawtypes")
     private static final EmptyAction EMPTY_ACTION = new EmptyAction();
 
-    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> implements
+    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements
             Action0,
             Action1<T0>,
             Action2<T0, T1>,

File: src/main/java/rx/internal/operators/BackpressureUtils.java
Patch:
@@ -61,9 +61,7 @@ public static <T> long getAndAddRequest(AtomicLongFieldUpdater<T> requested, T o
      * {@code requested} field to {@code Long.MAX_VALUE}.
      * 
      * @param requested
-     *            atomic field updater for a request count
-     * @param object
-     *            contains the field updated by the updater
+     *            atomic long that should be updated
      * @param n
      *            the number of requests to add to the requested count
      * @return requested value just prior to successful addition

File: src/main/java/rx/internal/operators/BackpressureUtils.java
Patch:
@@ -61,9 +61,7 @@ public static <T> long getAndAddRequest(AtomicLongFieldUpdater<T> requested, T o
      * {@code requested} field to {@code Long.MAX_VALUE}.
      * 
      * @param requested
-     *            atomic field updater for a request count
-     * @param object
-     *            contains the field updated by the updater
+     *            atomic long that should be updated
      * @param n
      *            the number of requests to add to the requested count
      * @return requested value just prior to successful addition

File: src/main/java/rx/Observable.java
Patch:
@@ -6576,6 +6576,8 @@ public final Observable<T> retry(final long count) {
      * <p>
      * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png" alt="">
      * <dl>
+     *  <dt><b>Backpressure Support:</b></dt>
+     *  <dd>This operator honors backpressure.</td>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code retry} operates by default on the {@code trampoline} {@link Scheduler}.</dd>
      * </dl>

File: src/main/java/rx/Observable.java
Patch:
@@ -6576,6 +6576,8 @@ public final Observable<T> retry(final long count) {
      * <p>
      * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png" alt="">
      * <dl>
+     *  <dt><b>Backpressure Support:</b></dt>
+     *  <dd>This operator honors backpressure.</td>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code retry} operates by default on the {@code trampoline} {@link Scheduler}.</dd>
      * </dl>

File: src/main/java/rx/functions/Actions.java
Patch:
@@ -24,14 +24,14 @@ private Actions() {
     }
 
     @SuppressWarnings("unchecked")
-    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> empty() {
+    public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8> EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> empty() {
         return EMPTY_ACTION;
     }
 
     @SuppressWarnings("rawtypes")
     private static final EmptyAction EMPTY_ACTION = new EmptyAction();
 
-    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> implements
+    private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8> implements
             Action0,
             Action1<T0>,
             Action2<T0, T1>,

File: src/main/java/rx/Observable.java
Patch:
@@ -9059,7 +9059,7 @@ public final <U, R> Observable<R> withLatestFrom(Observable<? extends U> other,
      * @see <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
      */
     public final <TClosing> Observable<Observable<T>> window(Func0<? extends Observable<? extends TClosing>> closingSelector) {
-        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));
+        return lift(new OperatorWindowWithObservableFactory<T, TClosing>(closingSelector));
     }
 
     /**

File: src/main/java/rx/internal/operators/OnSubscribeSingle.java
Patch:
@@ -80,7 +80,7 @@ public void onNext(T t) {
             }
         };
         child.add(parent);
-        observable.subscribe(parent);
+        observable.unsafeSubscribe(parent);
     }
 
     public static <T> OnSubscribeSingle<T> create(Observable<T> observable) {

File: src/test/java/rx/internal/operators/OperatorSwitchIfEmptyTest.java
Patch:
@@ -27,7 +27,6 @@
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.functions.Action0;
-import rx.functions.Action1;
 import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
 import rx.subscriptions.Subscriptions;

File: src/test/java/rx/observers/SerializedObserverTest.java
Patch:
@@ -674,6 +674,7 @@ public TestMultiThreadedObservable(String... values) {
 
         @Override
         public void call(final Subscriber<? super String> observer) {
+            final NullPointerException npe = new NullPointerException();
             System.out.println("TestMultiThreadedObservable subscribed to ...");
             t = new Thread(new Runnable() {
 
@@ -694,7 +695,7 @@ public void run() {
                                         System.out.println("TestMultiThreadedObservable onNext: " + s + " on thread " + Thread.currentThread().getName());
                                         if (s == null) {
                                             // force an error
-                                            throw new NullPointerException();
+                                            throw npe;
                                         } else {
                                              // allow the exception to queue up
                                             int sleep = (fj % 3) * 10;

File: src/main/java/rx/internal/operators/OperatorTakeLast.java
Patch:
@@ -22,7 +22,7 @@
 import rx.Subscriber;
 
 /**
- * Returns an Observable that emits the last <code>count</code> items emitted by the source Observable.
+ * Returns an Observable that emits the at most the last <code>count</code> items emitted by the source Observable.
  * <p>
  * <img width="640" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/last.png" alt="">
  */
@@ -32,7 +32,7 @@ public final class OperatorTakeLast<T> implements Operator<T, T> {
 
     public OperatorTakeLast(int count) {
         if (count < 0) {
-            throw new IndexOutOfBoundsException("count could not be negative");
+            throw new IndexOutOfBoundsException("count cannot be negative");
         }
         this.count = count;
     }

File: src/main/java/rx/Observable.java
Patch:
@@ -9060,7 +9060,7 @@ public final <U, R> Observable<R> withLatestFrom(Observable<? extends U> other,
      * @see <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
      */
     public final <TClosing> Observable<Observable<T>> window(Func0<? extends Observable<? extends TClosing>> closingSelector) {
-        return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));
+        return lift(new OperatorWindowWithObservableFactory<T, TClosing>(closingSelector));
     }
 
     /**

File: src/main/java/rx/internal/operators/OperatorTakeLast.java
Patch:
@@ -22,7 +22,7 @@
 import rx.Subscriber;
 
 /**
- * Returns an Observable that emits the last <code>count</code> items emitted by the source Observable.
+ * Returns an Observable that emits the at most the last <code>count</code> items emitted by the source Observable.
  * <p>
  * <img width="640" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/last.png" alt="">
  */
@@ -32,7 +32,7 @@ public final class OperatorTakeLast<T> implements Operator<T, T> {
 
     public OperatorTakeLast(int count) {
         if (count < 0) {
-            throw new IndexOutOfBoundsException("count could not be negative");
+            throw new IndexOutOfBoundsException("count cannot be negative");
         }
         this.count = count;
     }

File: src/main/java/rx/Observable.java
Patch:
@@ -9017,7 +9017,7 @@ public final Observable<Observable<T>> window(int count) {
      * <img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.png" alt="">
      * <dl>
      *  <dt><b>Backpressure Support:</b></dt>
-     *  <dd>The operator has limited backpressure support. If {@code count} == {@code skip}, the operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables 
+     *  <dd>The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables 
      *  but each of them will emit at most {@code count} elements.</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -259,7 +259,9 @@ public void call() {
                         }
 
                     }).unsafeSubscribe(new Subscriber<T>(o) {
-
+                        @Override
+                        public void onStart() {
+                        }
                         @Override
                         public void onCompleted() {
                             o.onCompleted();

File: src/main/java/rx/observers/TestSubscriber.java
Patch:
@@ -99,8 +99,6 @@ public TestSubscriber() {
     public void onStart() {
         if  (initialRequest >= 0) {
             requestMore(initialRequest);
-        } else {
-            super.onStart();
         }
     }
 

File: src/test/java/rx/internal/operators/OperatorPublishTest.java
Patch:
@@ -226,7 +226,8 @@ public void call() {
             public void call() {
                 child1Unsubscribed.set(true);
             }
-        }).take(5).subscribe(ts1);
+        }).take(5)
+        .subscribe(ts1);
         
         ts1.awaitTerminalEvent();
         ts2.awaitTerminalEvent();

File: src/perf/java/rx/ObservablePerfBaseline.java
Patch:
@@ -30,7 +30,7 @@
 
 @BenchmarkMode(Mode.Throughput)
 @OutputTimeUnit(TimeUnit.SECONDS)
-public class PerfBaseline {
+public class ObservablePerfBaseline {
 
     @State(Scope.Thread)
     public static class Input extends InputWithIncrementingInteger {

File: src/perf/java/rx/ObservablePerfBaseline.java
Patch:
@@ -30,7 +30,7 @@
 
 @BenchmarkMode(Mode.Throughput)
 @OutputTimeUnit(TimeUnit.SECONDS)
-public class PerfBaseline {
+public class ObservablePerfBaseline {
 
     @State(Scope.Thread)
     public static class Input extends InputWithIncrementingInteger {

File: src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -114,7 +114,7 @@ public void call(SubjectObserver<T> o) {
                 boolean skipFinal = false;
                 try {
                     for (;;) {
-                        int idx = o.index();
+                        int idx = o.<Integer>index();
                         int sidx = state.index;
                         if (idx != sidx) {
                             Integer j = state.replayObserverFromIndex(idx, o);

File: src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -114,7 +114,7 @@ public void call(SubjectObserver<T> o) {
                 boolean skipFinal = false;
                 try {
                     for (;;) {
-                        int idx = o.index();
+                        int idx = o.<Integer>index();
                         int sidx = state.index;
                         if (idx != sidx) {
                             Integer j = state.replayObserverFromIndex(idx, o);

File: src/main/java/rx/observers/TestSubscriber.java
Patch:
@@ -380,7 +380,7 @@ public void assertError(Throwable throwable) {
         if (err.size() > 1) {
             throw new AssertionError("Multiple errors: " + err.size(), new CompositeException(err));
         } else
-        if (throwable.equals(err.get(0))) {
+        if (!throwable.equals(err.get(0))) {
             throw new AssertionError("Exceptions differ; expected: " + throwable + ", actual: " + err.get(0), err.get(0));
         }
     }

File: src/main/java/rx/observers/TestSubscriber.java
Patch:
@@ -380,7 +380,7 @@ public void assertError(Throwable throwable) {
         if (err.size() > 1) {
             throw new AssertionError("Multiple errors: " + err.size(), new CompositeException(err));
         } else
-        if (throwable.equals(err.get(0))) {
+        if (!throwable.equals(err.get(0))) {
             throw new AssertionError("Exceptions differ; expected: " + throwable + ", actual: " + err.get(0), err.get(0));
         }
     }

File: src/main/java/rx/internal/producers/ProducerArbiter.java
Patch:
@@ -95,7 +95,7 @@ public void produced(long n) {
             if (r != Long.MAX_VALUE) {
                 long u = r - n;
                 if (u < 0) {
-                    throw new IllegalStateException();
+                    throw new IllegalStateException("more items arrived than were requested");
                 }
                 requested = u;
             }

File: src/main/java/rx/internal/producers/ProducerArbiter.java
Patch:
@@ -95,7 +95,7 @@ public void produced(long n) {
             if (r != Long.MAX_VALUE) {
                 long u = r - n;
                 if (u < 0) {
-                    throw new IllegalStateException();
+                    throw new IllegalStateException("more items arrived than were requested");
                 }
                 requested = u;
             }

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -259,7 +259,9 @@ public void call() {
                         }
 
                     }).unsafeSubscribe(new Subscriber<T>(o) {
-
+                        @Override
+                        public void onStart() {
+                        }
                         @Override
                         public void onCompleted() {
                             o.onCompleted();

File: src/main/java/rx/observers/TestSubscriber.java
Patch:
@@ -99,8 +99,6 @@ public TestSubscriber() {
     public void onStart() {
         if  (initialRequest >= 0) {
             requestMore(initialRequest);
-        } else {
-            super.onStart();
         }
     }
 

File: src/test/java/rx/internal/operators/OperatorPublishTest.java
Patch:
@@ -226,7 +226,8 @@ public void call() {
             public void call() {
                 child1Unsubscribed.set(true);
             }
-        }).take(5).subscribe(ts1);
+        }).take(5)
+        .subscribe(ts1);
         
         ts1.awaitTerminalEvent();
         ts2.awaitTerminalEvent();

File: src/main/java/rx/Observable.java
Patch:
@@ -9017,7 +9017,7 @@ public final Observable<Observable<T>> window(int count) {
      * <img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.png" alt="">
      * <dl>
      *  <dt><b>Backpressure Support:</b></dt>
-     *  <dd>The operator has limited backpressure support. If {@code count} == {@code skip}, the operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables 
+     *  <dd>The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables 
      *  but each of them will emit at most {@code count} elements.</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.</dd>

File: src/main/java/rx/internal/operators/OperatorConcat.java
Patch:
@@ -115,7 +115,7 @@ public void onStart() {
         private void requestFromChild(long n) {
             // we track 'requested' so we know whether we should subscribe the next or not
             ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;
-            if (REQUESTED_UPDATER.getAndAdd(this, n) == 0) {
+            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {
                 if (actualSubscriber == null && wip > 0) {
                     // this means we may be moving from one subscriber to another after having stopped processing
                     // so need to kick off the subscribe via this request notification

File: src/main/java/rx/internal/operators/OperatorPublish.java
Patch:
@@ -535,10 +535,11 @@ void dispatch() {
                         // may contain less than requested
                         int d = 0;
                         while (d < maxRequested) {
+                            term = terminalEvent;
                             Object v = queue.poll();
                             empty = v == null;
                             // let's check if there is a terminal event and the queue became empty just now
-                            if (checkTerminated(terminalEvent, empty)) {
+                            if (checkTerminated(term, empty)) {
                                 skipFinal = true;
                                 return;
                             }

File: src/main/java/rx/internal/operators/OperatorPublish.java
Patch:
@@ -535,10 +535,11 @@ void dispatch() {
                         // may contain less than requested
                         int d = 0;
                         while (d < maxRequested) {
+                            term = terminalEvent;
                             Object v = queue.poll();
                             empty = v == null;
                             // let's check if there is a terminal event and the queue became empty just now
-                            if (checkTerminated(terminalEvent, empty)) {
+                            if (checkTerminated(term, empty)) {
                                 skipFinal = true;
                                 return;
                             }

File: src/main/java/rx/internal/operators/OperatorWindowWithObservable.java
Patch:
@@ -119,7 +119,7 @@ public void onNext(T t) {
                 do {
                     drain(localQueue);
                     if (once) {
-                        once = true;
+                        once = false;
                         emitValue(t);
                     }
                     

File: src/main/java/rx/internal/operators/OperatorWindowWithObservable.java
Patch:
@@ -119,7 +119,7 @@ public void onNext(T t) {
                 do {
                     drain(localQueue);
                     if (once) {
-                        once = true;
+                        once = false;
                         emitValue(t);
                     }
                     

File: src/main/java/rx/internal/operators/OperatorConcat.java
Patch:
@@ -158,11 +158,11 @@ public void onCompleted() {
         }
 
         void completeInner() {
-            request(1);
             currentSubscriber = null;
             if (WIP_UPDATER.decrementAndGet(this) > 0) {
                 subscribeNext();
             }
+            request(1);
         }
 
         void subscribeNext() {

File: src/main/java/rx/internal/operators/OperatorConcat.java
Patch:
@@ -158,11 +158,11 @@ public void onCompleted() {
         }
 
         void completeInner() {
-            request(1);
             currentSubscriber = null;
             if (WIP_UPDATER.decrementAndGet(this) > 0) {
                 subscribeNext();
             }
+            request(1);
         }
 
         void subscribeNext() {

File: src/main/java/rx/internal/operators/OnSubscribeRange.java
Patch:
@@ -55,12 +55,11 @@ private RangeProducer(Subscriber<? super Integer> o, int start, int end) {
 
         @Override
         public void request(long n) {
-            if (REQUESTED_UPDATER.get(this) == Long.MAX_VALUE) {
+            if (requested == Long.MAX_VALUE) {
                 // already started with fast-path
                 return;
             }
-            if (n == Long.MAX_VALUE) {
-                REQUESTED_UPDATER.set(this, n);
+            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {
                 // fast-path without backpressure
                 for (long i = index; i <= end; i++) {
                     if (o.isUnsubscribed()) {

File: src/main/java/rx/internal/operators/OnSubscribeRange.java
Patch:
@@ -55,12 +55,11 @@ private RangeProducer(Subscriber<? super Integer> o, int start, int end) {
 
         @Override
         public void request(long n) {
-            if (REQUESTED_UPDATER.get(this) == Long.MAX_VALUE) {
+            if (requested == Long.MAX_VALUE) {
                 // already started with fast-path
                 return;
             }
-            if (n == Long.MAX_VALUE) {
-                REQUESTED_UPDATER.set(this, n);
+            if (n == Long.MAX_VALUE && REQUESTED_UPDATER.compareAndSet(this, 0, Long.MAX_VALUE)) {
                 // fast-path without backpressure
                 for (long i = index; i <= end; i++) {
                     if (o.isUnsubscribed()) {

File: src/main/java/rx/internal/operators/OperatorScan.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observable.Operator;
 import rx.Producer;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func0;
 import rx.functions.Func2;
@@ -103,7 +104,9 @@ public void onNext(T currentValue) {
                     try {
                         this.value = accumulator.call(this.value, currentValue);
                     } catch (Throwable e) {
+                        Exceptions.throwIfFatal(e);
                         child.onError(OnErrorThrowable.addValueAsLastCause(e, currentValue));
+                        return;
                     }
                 }
                 child.onNext(this.value);

File: src/main/java/rx/internal/operators/OperatorScan.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observable.Operator;
 import rx.Producer;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func0;
 import rx.functions.Func2;
@@ -103,7 +104,9 @@ public void onNext(T currentValue) {
                     try {
                         this.value = accumulator.call(this.value, currentValue);
                     } catch (Throwable e) {
+                        Exceptions.throwIfFatal(e);
                         child.onError(OnErrorThrowable.addValueAsLastCause(e, currentValue));
+                        return;
                     }
                 }
                 child.onNext(this.value);

File: src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java
Patch:
@@ -27,7 +27,6 @@
  */
 public final class SubscriptionIndexedRingBuffer<T extends Subscription> implements Subscription {
 
-    @SuppressWarnings("unchecked")
     private volatile IndexedRingBuffer<T> subscriptions = IndexedRingBuffer.getInstance();
     private volatile int unsubscribed = 0;
     @SuppressWarnings("rawtypes")

File: src/perf/java/rx/internal/IndexedRingBufferPerf.java
Patch:
@@ -29,7 +29,6 @@ public class IndexedRingBufferPerf {
 
     @Benchmark
     public void indexedRingBufferAdd(IndexedRingBufferInput input) throws InterruptedException, MissingBackpressureException {
-        @SuppressWarnings("unchecked")
         IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();
         for (int i = 0; i < input.size; i++) {
             list.add(i);
@@ -40,7 +39,6 @@ public void indexedRingBufferAdd(IndexedRingBufferInput input) throws Interrupte
 
     @Benchmark
     public void indexedRingBufferAddRemove(IndexedRingBufferInput input) throws InterruptedException, MissingBackpressureException {
-        @SuppressWarnings("unchecked")
         IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();
         for (int i = 0; i < input.size; i++) {
             list.add(i);

File: src/main/java/rx/functions/Action1.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * A one-argument action.
  */
-public interface Action1<T1> extends Action {
-    void call(T1 t1);
+public interface Action1<T> extends Action {
+    void call(T t);
 }

File: src/main/java/rx/functions/Func1.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Represents a function with one argument.
  */
-public interface Func1<T1, R> extends Function {
-    R call(T1 t1);
+public interface Func1<T, R> extends Function {
+    R call(T t);
 }

File: src/main/java/rx/internal/util/SubscriptionIndexedRingBuffer.java
Patch:
@@ -27,7 +27,6 @@
  */
 public final class SubscriptionIndexedRingBuffer<T extends Subscription> implements Subscription {
 
-    @SuppressWarnings("unchecked")
     private volatile IndexedRingBuffer<T> subscriptions = IndexedRingBuffer.getInstance();
     private volatile int unsubscribed = 0;
     @SuppressWarnings("rawtypes")

File: src/perf/java/rx/internal/IndexedRingBufferPerf.java
Patch:
@@ -29,7 +29,6 @@ public class IndexedRingBufferPerf {
 
     @Benchmark
     public void indexedRingBufferAdd(IndexedRingBufferInput input) throws InterruptedException, MissingBackpressureException {
-        @SuppressWarnings("unchecked")
         IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();
         for (int i = 0; i < input.size; i++) {
             list.add(i);
@@ -40,7 +39,6 @@ public void indexedRingBufferAdd(IndexedRingBufferInput input) throws Interrupte
 
     @Benchmark
     public void indexedRingBufferAddRemove(IndexedRingBufferInput input) throws InterruptedException, MissingBackpressureException {
-        @SuppressWarnings("unchecked")
         IndexedRingBuffer<Integer> list = IndexedRingBuffer.getInstance();
         for (int i = 0; i < input.size; i++) {
             list.add(i);

File: src/main/java/rx/internal/operators/OperatorDoOnRequest.java
Patch:
@@ -48,7 +48,7 @@ public void request(long n) {
             }
 
         });
-
+        child.add(parent);
         return parent;
     }
 

File: src/main/java/rx/internal/operators/OperatorDoOnRequest.java
Patch:
@@ -48,7 +48,7 @@ public void request(long n) {
             }
 
         });
-
+        child.add(parent);
         return parent;
     }
 

File: src/main/java/rx/internal/operators/OnSubscribeRedo.java
Patch:
@@ -213,12 +213,14 @@ public void call() {
                 Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {
                     @Override
                     public void onCompleted() {
+                        currentProducer.set(null);
                         unsubscribe();
                         terminals.onNext(Notification.createOnCompleted());
                     }
 
                     @Override
                     public void onError(Throwable e) {
+                        currentProducer.set(null);
                         unsubscribe();
                         terminals.onNext(Notification.createOnError(e));
                     }

File: src/main/java/rx/internal/operators/OnSubscribeRedo.java
Patch:
@@ -213,12 +213,14 @@ public void call() {
                 Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {
                     @Override
                     public void onCompleted() {
+                        currentProducer.set(null);
                         unsubscribe();
                         terminals.onNext(Notification.createOnCompleted());
                     }
 
                     @Override
                     public void onError(Throwable e) {
+                        currentProducer.set(null);
                         unsubscribe();
                         terminals.onNext(Notification.createOnError(e));
                     }

File: src/main/java/rx/Observable.java
Patch:
@@ -96,7 +96,7 @@ public final static <T> Observable<T> create(OnSubscribe<T> f) {
     }
 
     /**
-     * Invoked when Obserable.subscribe is called.
+     * Invoked when Observable.subscribe is called.
      */
     public interface OnSubscribe<T> extends Action1<Subscriber<? super T>> {
         // cover for generics insanity

File: src/main/java/rx/Observable.java
Patch:
@@ -96,7 +96,7 @@ public final static <T> Observable<T> create(OnSubscribe<T> f) {
     }
 
     /**
-     * Invoked when Obserable.subscribe is called.
+     * Invoked when Observable.subscribe is called.
      */
     public interface OnSubscribe<T> extends Action1<Subscriber<? super T>> {
         // cover for generics insanity

File: src/main/java/rx/Observable.java
Patch:
@@ -5610,7 +5610,7 @@ public final <R> Observable<R> reduce(R initialValue, Func2<R, ? super T, R> acc
      * </dl>
      * 
      * @return an Observable that emits the items emitted by the source Observable repeatedly and in sequence
-     * @see <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeahttp://reactivex.io/documentation/operators/create.htmlt</a>
+     * @see <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
      */
     public final Observable<T> repeat() {
         return OnSubscribeRedo.<T>repeat(this);

File: src/main/java/rx/Observable.java
Patch:
@@ -5610,7 +5610,7 @@ public final <R> Observable<R> reduce(R initialValue, Func2<R, ? super T, R> acc
      * </dl>
      * 
      * @return an Observable that emits the items emitted by the source Observable repeatedly and in sequence
-     * @see <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeahttp://reactivex.io/documentation/operators/create.htmlt</a>
+     * @see <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
      */
     public final Observable<T> repeat() {
         return OnSubscribeRedo.<T>repeat(this);

File: src/test/java/rx/BackpressureTests.java
Patch:
@@ -446,7 +446,7 @@ public void testOnBackpressureDropWithAction() {
             final AtomicInteger emitCount = new AtomicInteger();
             final AtomicInteger dropCount = new AtomicInteger();
             final AtomicInteger passCount = new AtomicInteger();
-            final int NUM = RxRingBuffer.SIZE * 3 / 2; // > 1 so that take doesn't prevent buffer overflow
+            final int NUM = RxRingBuffer.SIZE * 3; // > 1 so that take doesn't prevent buffer overflow
             TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
             firehose(emitCount).onBackpressureDrop(new Action1<Integer>() {
                 @Override

File: src/test/java/rx/BackpressureTests.java
Patch:
@@ -446,7 +446,7 @@ public void testOnBackpressureDropWithAction() {
             final AtomicInteger emitCount = new AtomicInteger();
             final AtomicInteger dropCount = new AtomicInteger();
             final AtomicInteger passCount = new AtomicInteger();
-            final int NUM = RxRingBuffer.SIZE * 3 / 2; // > 1 so that take doesn't prevent buffer overflow
+            final int NUM = RxRingBuffer.SIZE * 3; // > 1 so that take doesn't prevent buffer overflow
             TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
             firehose(emitCount).onBackpressureDrop(new Action1<Integer>() {
                 @Override

File: src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -167,7 +167,7 @@ public boolean hasCompleted() {
     /**
      * Returns the current value of the Subject if there is such a value and
      * the subject hasn't terminated with an exception.
-     * <p>The can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
+     * <p>The method can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
      * and {@link #hasCompleted()} to determine if such {@code null} is a valid value, there was an
      * exception or the Subject terminated without receiving any value. 
      * @return the current value or {@code null} if the Subject doesn't have a value,

File: src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -202,7 +202,7 @@ public boolean hasCompleted() {
     /**
      * Returns the current value of the Subject if there is such a value and
      * the subject hasn't terminated yet.
-     * <p>The can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
+     * <p>The method can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
      * and {@link #hasCompleted()} to determine if such {@code null} is a valid value, there was an
      * exception or the Subject terminated (with or without receiving any value). 
      * @return the current value or {@code null} if the Subject doesn't have a value,

File: src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -167,7 +167,7 @@ public boolean hasCompleted() {
     /**
      * Returns the current value of the Subject if there is such a value and
      * the subject hasn't terminated with an exception.
-     * <p>The can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
+     * <p>The method can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
      * and {@link #hasCompleted()} to determine if such {@code null} is a valid value, there was an
      * exception or the Subject terminated without receiving any value. 
      * @return the current value or {@code null} if the Subject doesn't have a value,

File: src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -202,7 +202,7 @@ public boolean hasCompleted() {
     /**
      * Returns the current value of the Subject if there is such a value and
      * the subject hasn't terminated yet.
-     * <p>The can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
+     * <p>The method can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
      * and {@link #hasCompleted()} to determine if such {@code null} is a valid value, there was an
      * exception or the Subject terminated (with or without receiving any value). 
      * @return the current value or {@code null} if the Subject doesn't have a value,

File: src/test/java/rx/BackpressureTests.java
Patch:
@@ -446,7 +446,7 @@ public void testOnBackpressureDropWithAction() {
             final AtomicInteger emitCount = new AtomicInteger();
             final AtomicInteger dropCount = new AtomicInteger();
             final AtomicInteger passCount = new AtomicInteger();
-            final int NUM = (int) (RxRingBuffer.SIZE * 1.5); // > 1 so that take doesn't prevent buffer overflow
+            final int NUM = RxRingBuffer.SIZE * 3; // > 1 so that take doesn't prevent buffer overflow
             TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
             firehose(emitCount).onBackpressureDrop(new Action1<Integer>() {
                 @Override

File: src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java
Patch:
@@ -93,7 +93,7 @@ public void testFixBackpressureBufferNegativeCapacity() throws InterruptedExcept
 
     @Test(expected = IllegalArgumentException.class)
     public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {
-        Observable.empty().onBackpressureBuffer(-1);
+        Observable.empty().onBackpressureBuffer(0);
     }
 
     @Test

File: src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java
Patch:
@@ -47,7 +47,7 @@ public void testNoBackpressureSupport() {
     @Test(timeout = 500)
     public void testWithObserveOn() throws InterruptedException {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
-        Observable.range(0, RxRingBuffer.SIZE * 10).onBackpressureDrop().onBackpressureDrop().observeOn(Schedulers.io()).subscribe(ts);
+        Observable.range(0, RxRingBuffer.SIZE * 10).onBackpressureDrop().observeOn(Schedulers.io()).subscribe(ts);
         ts.awaitTerminalEvent();
     }
 

File: src/main/java/rx/internal/operators/OperatorMulticast.java
Patch:
@@ -46,7 +46,7 @@ public final class OperatorMulticast<T, R> extends ConnectableObservable<R> {
 
     /** Guarded by guard. */
     private Subscriber<T> subscription;
-    // wraps subscription above with for unsubscription using guard
+    // wraps subscription above for unsubscription using guard
     private Subscription guardedSubscription;
 
     public OperatorMulticast(Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory) {

File: src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java
Patch:
@@ -93,7 +93,7 @@ public void testFixBackpressureBufferNegativeCapacity() throws InterruptedExcept
 
     @Test(expected = IllegalArgumentException.class)
     public void testFixBackpressureBufferZeroCapacity() throws InterruptedException {
-        Observable.empty().onBackpressureBuffer(-1);
+        Observable.empty().onBackpressureBuffer(0);
     }
 
     @Test

File: src/test/java/rx/internal/operators/OperatorOnBackpressureDropTest.java
Patch:
@@ -46,7 +46,7 @@ public void testNoBackpressureSupport() {
     @Test(timeout = 500)
     public void testWithObserveOn() throws InterruptedException {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
-        Observable.range(0, RxRingBuffer.SIZE * 10).onBackpressureDrop().onBackpressureDrop().observeOn(Schedulers.io()).subscribe(ts);
+        Observable.range(0, RxRingBuffer.SIZE * 10).onBackpressureDrop().observeOn(Schedulers.io()).subscribe(ts);
         ts.awaitTerminalEvent();
     }
 

File: src/main/java/rx/observables/AbstractOnSubscribe.java
Patch:
@@ -84,7 +84,7 @@
  * instance into an {@code Observable} fluently.
  * 
  * <h1>Examples</h1>
- * Note: these examples use the lambda-helper factories to avoid boilerplane.
+ * Note: these examples use the lambda-helper factories to avoid boilerplate.
  * 
  * <h3>Implement: just</h3>
  * <pre><code>

File: src/main/java/rx/internal/operators/OperatorSwitch.java
Patch:
@@ -49,7 +49,9 @@ public static <T> OperatorSwitch<T> instance() {
     private OperatorSwitch() { }
     @Override
     public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super T> child) {
-        return new SwitchSubscriber<T>(child);
+        SwitchSubscriber<T> sws = new SwitchSubscriber<T>(child);
+        child.add(sws);
+        return sws;
     }
 
     private static final class SwitchSubscriber<T> extends Subscriber<Observable<? extends T>> {
@@ -75,7 +77,6 @@ private static final class SwitchSubscriber<T> extends Subscriber<Observable<? e
         volatile boolean infinite = false;
 
         public SwitchSubscriber(Subscriber<? super T> child) {
-            super(child);
             s = new SerializedSubscriber<T>(child);
             ssub = new SerialSubscription();
             child.add(ssub);

File: src/main/java/rx/internal/operators/OperatorSwitch.java
Patch:
@@ -49,7 +49,9 @@ public static <T> OperatorSwitch<T> instance() {
     private OperatorSwitch() { }
     @Override
     public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super T> child) {
-        return new SwitchSubscriber<T>(child);
+        SwitchSubscriber<T> sws = new SwitchSubscriber<T>(child);
+        child.add(sws);
+        return sws;
     }
 
     private static final class SwitchSubscriber<T> extends Subscriber<Observable<? extends T>> {
@@ -75,7 +77,6 @@ private static final class SwitchSubscriber<T> extends Subscriber<Observable<? e
         volatile boolean infinite = false;
 
         public SwitchSubscriber(Subscriber<? super T> child) {
-            super(child);
             s = new SerializedSubscriber<T>(child);
             ssub = new SerialSubscription();
             child.add(ssub);

File: src/main/java/rx/Observable.java
Patch:
@@ -4538,6 +4538,7 @@ public final <R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? e
      *         by the source Observable and merging the results of the Observables obtained from this
      *         transformation
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
+     * @since 1.0.6
      */
     @Beta
     public final <R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? extends R>> func, int maxConcurrent) {

File: src/main/java/rx/internal/operators/OperatorTakeWhile.java
Patch:
@@ -45,7 +45,7 @@ public OperatorTakeWhile(Func2<? super T, ? super Integer, Boolean> predicate) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {
-        return new Subscriber<T>(subscriber) {
+        Subscriber<T> s = new Subscriber<T>(subscriber, false) {
 
             private int counter = 0;
 
@@ -86,6 +86,8 @@ public void onError(Throwable e) {
             }
 
         };
+        subscriber.add(s);
+        return s;
     }
 
 }

File: src/main/java/rx/internal/util/unsafe/UnsafeAccess.java
Patch:
@@ -41,7 +41,7 @@ private UnsafeAccess() {
             Field field = Unsafe.class.getDeclaredField("theUnsafe");
             field.setAccessible(true);
             u = (Unsafe) field.get(null);
-        } catch (Exception e) {
+        } catch (Throwable e) {
             // do nothing, hasUnsafe() will return false
         }
         UNSAFE = u;

File: src/main/java/rx/internal/util/unsafe/UnsafeAccess.java
Patch:
@@ -41,7 +41,7 @@ private UnsafeAccess() {
             Field field = Unsafe.class.getDeclaredField("theUnsafe");
             field.setAccessible(true);
             u = (Unsafe) field.get(null);
-        } catch (Exception e) {
+        } catch (Throwable e) {
             // do nothing, hasUnsafe() will return false
         }
         UNSAFE = u;

File: src/main/java/rx/Observable.java
Patch:
@@ -7289,6 +7289,9 @@ public final void onNext(T args) {
      * @see <a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>
      */
     public final Subscription subscribe(final Observer<? super T> observer) {
+        if (observer instanceof Subscriber) {
+            return subscribe((Subscriber<? super T>)observer);
+        }
         return subscribe(new Subscriber<T>() {
 
             @Override

File: src/main/java/rx/internal/operators/OperatorPublish.java
Patch:
@@ -163,7 +163,7 @@ public void onError(Throwable e) {
                     errors.add(e2);
                 }
             }
-            Exceptions.throwIfAny(errors, " while propagating an exception.");
+            Exceptions.throwIfAny(errors, " while emitting onError");
         }
 
         @Override

File: src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -120,7 +120,7 @@ public void onError(final Throwable e) {
                 }
             }
 
-            Exceptions.throwIfAny(errors, " while propagating an exception.");
+            Exceptions.throwIfAny(errors, " while emitting AsyncSubject.onError");
         }
     }
 

File: src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -146,7 +146,7 @@ public void onError(Throwable e) {
                 }
             }
 
-            Exceptions.throwIfAny(errors, " while propagating an exception.");
+            Exceptions.throwIfAny(errors, " while emitting BehaviorSubject.onError");
         }
     }
 

File: src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -104,7 +104,7 @@ public void onError(final Throwable e) {
                     errors.add(e2);
                 }
             }
-            Exceptions.throwIfAny(errors, " while propagating an exception.");
+            Exceptions.throwIfAny(errors, " while emitting PublishSubject.onError");
         }
     }
 

File: src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -391,7 +391,7 @@ public void onError(final Throwable e) {
                 }
             }
 
-            Exceptions.throwIfAny(errors, " while propagating an exception.");
+            Exceptions.throwIfAny(errors, " while emitting ReplaySubject.onError");
         }
     }
     

File: src/main/java/rx/observers/TestSubscriber.java
Patch:
@@ -226,9 +226,7 @@ public void awaitTerminalEvent() {
      */
     public void awaitTerminalEvent(long timeout, TimeUnit unit) {
         try {
-            if (!latch.await(timeout, unit)) {
-                throw new RuntimeException(new TimeoutException());
-            }
+            latch.await(timeout, unit);
         } catch (InterruptedException e) {
             throw new RuntimeException("Interrupted", e);
         }

File: src/main/java/rx/internal/operators/OnSubscribeRedo.java
Patch:
@@ -323,7 +323,7 @@ public void setProducer(Producer producer) {
 
             @Override
             public void request(final long n) {
-                long c = consumerCapacity.getAndAdd(n);
+                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);
                 Producer producer = currentProducer.get();
                 if (producer != null) {
                     producer.request(n);

File: src/main/java/rx/internal/operators/OnSubscribeRedo.java
Patch:
@@ -323,7 +323,7 @@ public void setProducer(Producer producer) {
 
             @Override
             public void request(final long n) {
-                long c = consumerCapacity.getAndAdd(n);
+                long c = BackpressureUtils.getAndAddRequest(consumerCapacity, n);
                 Producer producer = currentProducer.get();
                 if (producer != null) {
                     producer.request(n);

File: src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java
Patch:
@@ -47,7 +47,7 @@ public void testNoBackpressureSupport() {
         ts.assertNoErrors();
     }
 
-    @Test(timeout = 500)
+    @Test(timeout = 2000)
     public void testFixBackpressureWithBuffer() throws InterruptedException {
         final CountDownLatch l1 = new CountDownLatch(100);
         final CountDownLatch l2 = new CountDownLatch(150);

File: src/main/java/rx/schedulers/EventLoopsScheduler.java
Patch:
@@ -45,7 +45,7 @@
         if (maxThreads <= 0 || maxThreads > ncpu) {
             max = ncpu;
         } else {
-            max =maxThreads;
+            max = maxThreads;
         }
         MAX_THREADS = max;
     }

File: src/main/java/rx/exceptions/OnErrorThrowable.java
Patch:
@@ -148,7 +148,7 @@ private static String renderValue(Object value){
                 return (String) value;
             }
             if (value instanceof Enum) {
-                return ((Enum) value).name();
+                return ((Enum<?>) value).name();
             }
             return value.getClass().getName() + ".class";
         }

File: src/main/java/rx/functions/Actions.java
Patch:
@@ -15,8 +15,6 @@
  */
 package rx.functions;
 
-import rx.Observer;
-
 /**
  * Utility class for the Action interfaces.
  */

File: src/main/java/rx/internal/operators/BlockingOperatorNext.java
Patch:
@@ -147,6 +147,7 @@ public void remove() {
 
     private static class NextObserver<T> extends Subscriber<Notification<? extends T>> {
         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);
+        @SuppressWarnings("unused")
         volatile int waiting;
         @SuppressWarnings("rawtypes")
         static final AtomicIntegerFieldUpdater<NextObserver> WAITING_UPDATER

File: src/main/java/rx/internal/operators/OnSubscribeCache.java
Patch:
@@ -20,7 +20,6 @@
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.Subscriber;
-import rx.observers.Subscribers;
 import rx.subjects.ReplaySubject;
 import rx.subjects.Subject;
 

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -15,12 +15,10 @@
  */
 package rx.internal.operators;
 
-import java.util.Map;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
@@ -206,6 +204,7 @@ private Object groupedKey(K key) {
             return key == null ? NULL_KEY : key;
         }
 
+        @SuppressWarnings("unchecked")
         private K getKey(Object groupedKey) {
             return groupedKey == NULL_KEY ? null : (K) groupedKey;
         }

File: src/main/java/rx/internal/operators/OperatorObserveOn.java
Patch:
@@ -72,10 +72,12 @@ private static final class ObserveOnSubscriber<T> extends Subscriber<T> {
         private boolean completed = false;
         private boolean failure = false;
 
+        @SuppressWarnings("unused")
         private volatile long requested = 0;
         @SuppressWarnings("rawtypes")
         static final AtomicLongFieldUpdater<ObserveOnSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, "requested");
 
+        @SuppressWarnings("unused")
         volatile long counter;
         @SuppressWarnings("rawtypes")
         static final AtomicLongFieldUpdater<ObserveOnSubscriber> COUNTER_UPDATER = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, "counter");

File: src/main/java/rx/internal/operators/OperatorPublish.java
Patch:
@@ -16,7 +16,6 @@
 package rx.internal.operators;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -266,6 +265,7 @@ public synchronized void removeSubscriber(Subscriber<? super T> subscriber) {
             resetAfterSubscriberUpdate();
         }
 
+        @SuppressWarnings("unchecked")
         private long resetAfterSubscriberUpdate() {
             subscribers = new Subscriber[ss.size()];
             int i = 0;

File: src/main/java/rx/internal/operators/OperatorScan.java
Patch:
@@ -23,7 +23,6 @@
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func0;
 import rx.functions.Func2;
-import rx.internal.util.UtilityFunctions;
 
 /**
  * Returns an Observable that applies a function to the first item emitted by a source Observable, then feeds

File: src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -26,7 +26,6 @@
 import rx.Subscription;
 import rx.functions.Action1;
 import rx.functions.Func1;
-import rx.functions.Functions;
 import rx.internal.operators.BlockingOperatorLatest;
 import rx.internal.operators.BlockingOperatorMostRecent;
 import rx.internal.operators.BlockingOperatorNext;

File: src/main/java/rx/schedulers/CachedThreadScheduler.java
Patch:
@@ -110,6 +110,7 @@ public Worker createWorker() {
     private static final class EventLoopWorker extends Scheduler.Worker {
         private final CompositeSubscription innerSubscription = new CompositeSubscription();
         private final ThreadWorker threadWorker;
+        @SuppressWarnings("unused")
         volatile int once;
         static final AtomicIntegerFieldUpdater<EventLoopWorker> ONCE_UPDATER
                 = AtomicIntegerFieldUpdater.newUpdater(EventLoopWorker.class, "once");

File: src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -47,7 +47,8 @@ public Worker createWorker() {
 
     private static class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {
 
-        private static final AtomicIntegerFieldUpdater COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerCurrentThreadScheduler.class, "counter");
+        private static final AtomicIntegerFieldUpdater<InnerCurrentThreadScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerCurrentThreadScheduler.class, "counter");
+        @SuppressWarnings("unused")
         volatile int counter;
         private final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();
         private final BooleanSubscription innerSubscription = new BooleanSubscription();

File: src/main/java/rx/subjects/TestSubject.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-import rx.Observable;
 import rx.Observer;
 import rx.Scheduler;
 import rx.functions.Action0;

File: src/main/java/rx/subscriptions/Subscriptions.java
Patch:
@@ -16,12 +16,10 @@
 package rx.subscriptions;
 
 import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import rx.Subscription;
 import rx.annotations.Experimental;
 import rx.functions.Action0;
-import rx.functions.Actions;
 
 /**
  * Helper methods and utilities for creating and working with {@link Subscription} objects

File: src/main/java/rx/exceptions/OnErrorThrowable.java
Patch:
@@ -148,7 +148,7 @@ private static String renderValue(Object value){
                 return (String) value;
             }
             if (value instanceof Enum) {
-                return ((Enum) value).name();
+                return ((Enum<?>) value).name();
             }
             return value.getClass().getName() + ".class";
         }

File: src/main/java/rx/functions/Actions.java
Patch:
@@ -15,8 +15,6 @@
  */
 package rx.functions;
 
-import rx.Observer;
-
 /**
  * Utility class for the Action interfaces.
  */

File: src/main/java/rx/internal/operators/BlockingOperatorNext.java
Patch:
@@ -147,6 +147,7 @@ public void remove() {
 
     private static class NextObserver<T> extends Subscriber<Notification<? extends T>> {
         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);
+        @SuppressWarnings("unused")
         volatile int waiting;
         @SuppressWarnings("rawtypes")
         static final AtomicIntegerFieldUpdater<NextObserver> WAITING_UPDATER

File: src/main/java/rx/internal/operators/OnSubscribeCache.java
Patch:
@@ -20,7 +20,6 @@
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.Subscriber;
-import rx.observers.Subscribers;
 import rx.subjects.ReplaySubject;
 import rx.subjects.Subject;
 

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -15,12 +15,10 @@
  */
 package rx.internal.operators;
 
-import java.util.Map;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
@@ -206,6 +204,7 @@ private Object groupedKey(K key) {
             return key == null ? NULL_KEY : key;
         }
 
+        @SuppressWarnings("unchecked")
         private K getKey(Object groupedKey) {
             return groupedKey == NULL_KEY ? null : (K) groupedKey;
         }

File: src/main/java/rx/internal/operators/OperatorObserveOn.java
Patch:
@@ -72,10 +72,12 @@ private static final class ObserveOnSubscriber<T> extends Subscriber<T> {
         private boolean completed = false;
         private boolean failure = false;
 
+        @SuppressWarnings("unused")
         private volatile long requested = 0;
         @SuppressWarnings("rawtypes")
         static final AtomicLongFieldUpdater<ObserveOnSubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, "requested");
 
+        @SuppressWarnings("unused")
         volatile long counter;
         @SuppressWarnings("rawtypes")
         static final AtomicLongFieldUpdater<ObserveOnSubscriber> COUNTER_UPDATER = AtomicLongFieldUpdater.newUpdater(ObserveOnSubscriber.class, "counter");

File: src/main/java/rx/internal/operators/OperatorPublish.java
Patch:
@@ -16,7 +16,6 @@
 package rx.internal.operators;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -266,6 +265,7 @@ public synchronized void removeSubscriber(Subscriber<? super T> subscriber) {
             resetAfterSubscriberUpdate();
         }
 
+        @SuppressWarnings("unchecked")
         private long resetAfterSubscriberUpdate() {
             subscribers = new Subscriber[ss.size()];
             int i = 0;

File: src/main/java/rx/internal/operators/OperatorScan.java
Patch:
@@ -23,7 +23,6 @@
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func0;
 import rx.functions.Func2;
-import rx.internal.util.UtilityFunctions;
 
 /**
  * Returns an Observable that applies a function to the first item emitted by a source Observable, then feeds

File: src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -26,7 +26,6 @@
 import rx.Subscription;
 import rx.functions.Action1;
 import rx.functions.Func1;
-import rx.functions.Functions;
 import rx.internal.operators.BlockingOperatorLatest;
 import rx.internal.operators.BlockingOperatorMostRecent;
 import rx.internal.operators.BlockingOperatorNext;

File: src/main/java/rx/schedulers/CachedThreadScheduler.java
Patch:
@@ -110,6 +110,7 @@ public Worker createWorker() {
     private static final class EventLoopWorker extends Scheduler.Worker {
         private final CompositeSubscription innerSubscription = new CompositeSubscription();
         private final ThreadWorker threadWorker;
+        @SuppressWarnings("unused")
         volatile int once;
         static final AtomicIntegerFieldUpdater<EventLoopWorker> ONCE_UPDATER
                 = AtomicIntegerFieldUpdater.newUpdater(EventLoopWorker.class, "once");

File: src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -47,7 +47,8 @@ public Worker createWorker() {
 
     private static class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {
 
-        private static final AtomicIntegerFieldUpdater COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerCurrentThreadScheduler.class, "counter");
+        private static final AtomicIntegerFieldUpdater<InnerCurrentThreadScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(InnerCurrentThreadScheduler.class, "counter");
+        @SuppressWarnings("unused")
         volatile int counter;
         private final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();
         private final BooleanSubscription innerSubscription = new BooleanSubscription();

File: src/main/java/rx/subjects/TestSubject.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-import rx.Observable;
 import rx.Observer;
 import rx.Scheduler;
 import rx.functions.Action0;

File: src/main/java/rx/subscriptions/Subscriptions.java
Patch:
@@ -16,12 +16,10 @@
 package rx.subscriptions;
 
 import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import rx.Subscription;
 import rx.annotations.Experimental;
 import rx.functions.Action0;
-import rx.functions.Actions;
 
 /**
  * Helper methods and utilities for creating and working with {@link Subscription} objects

File: src/main/java/rx/Observable.java
Patch:
@@ -7840,8 +7840,8 @@ public final Observable<T> takeWhile(final Func1<? super T, Boolean> predicate)
      * @see Observable#takeWhile(Func1)
      */
     @Experimental
-    public final Observable<T> doTakeWhile(final Func1<? super T, Boolean> predicate) {
-        return lift(new OperatorDoTakeWhile<T>(predicate));
+    public final Observable<T> takeUntil(final Func1<? super T, Boolean> predicate) {
+        return lift(new OperatorTakeUntilPredicate<T>(predicate));
     }
     
     /**

File: src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -75,7 +75,7 @@ private Subscription enqueue(Action0 action, long execTime) {
                 do {
                     final TimedAction polled = queue.poll();
                     if (polled != null) {
-                      polled.action.call();
+                        polled.action.call();
                     }
                 } while (wip.decrementAndGet() > 0);
                 return Subscriptions.unsubscribed();

File: src/main/java/rx/internal/operators/OnSubscribeCache.java
Patch:
@@ -64,9 +64,10 @@ public OnSubscribeCache(Observable<? extends T> source, int capacity) {
     @Override
     public void call(Subscriber<? super T> s) {
         if (SRC_SUBSCRIBED_UPDATER.compareAndSet(this, 0, 1)) {
-            source.unsafeSubscribe(Subscribers.from(cache));
+            source.subscribe(cache);
             /*
-             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values.
+             * Note that we will never unsubscribe from 'source' unless we receive `onCompleted` or `onError`,
+             * as we want to receive and cache all of its values.
              * 
              * This means this should never be used on an infinite or very large sequence, similar to toList().
              */

File: src/test/java/rx/internal/operators/OnSubscribeRefCountTest.java
Patch:
@@ -62,7 +62,7 @@ public void setUp() {
     public void testRefCountAsync() {
         final AtomicInteger subscribeCount = new AtomicInteger();
         final AtomicInteger nextCount = new AtomicInteger();
-        Observable<Long> r = Observable.timer(0, 1, TimeUnit.MILLISECONDS)
+        Observable<Long> r = Observable.timer(0, 5, TimeUnit.MILLISECONDS)
                 .doOnSubscribe(new Action0() {
 
                     @Override
@@ -94,7 +94,7 @@ public void call(Long l) {
 
         // give time to emit
         try {
-            Thread.sleep(50);
+            Thread.sleep(52);
         } catch (InterruptedException e) {
         }
 

File: src/main/java/rx/internal/util/SynchronizedQueue.java
Patch:
@@ -138,7 +138,9 @@ public synchronized boolean offer(T e) {
 
     @Override
     public synchronized Object clone() {
-        return list.clone();
+        SynchronizedQueue<T> q = new SynchronizedQueue<T>(size);
+        q.addAll(list);
+        return q;
     }
 
     @Override

File: src/main/java/rx/internal/util/SynchronizedQueue.java
Patch:
@@ -138,7 +138,9 @@ public synchronized boolean offer(T e) {
 
     @Override
     public synchronized Object clone() {
-        return list.clone();
+        SynchronizedQueue<T> q = new SynchronizedQueue<T>(size);
+        q.addAll(list);
+        return q;
     }
 
     @Override

File: src/main/java/rx/internal/operators/OperatorMulticast.java
Patch:
@@ -143,7 +143,7 @@ public void call() {
                 subscriptionIsNull = subscription == null;
             }
             if (!subscriptionIsNull)
-                source.unsafeSubscribe(subscription);
+                source.subscribe(subscription);
         }
     }
 }
\ No newline at end of file

File: src/test/java/rx/internal/operators/OperatorMergeTest.java
Patch:
@@ -494,7 +494,7 @@ public void call() {
         });
     }
 
-    @Test
+    @Test(timeout = 10000)
     public void testConcurrency() {
         Observable<Integer> o = Observable.range(1, 10000).subscribeOn(Schedulers.newThread());
 

File: src/test/java/rx/internal/operators/OperatorOnBackpressureBufferTest.java
Patch:
@@ -47,7 +47,7 @@ public void testNoBackpressureSupport() {
         ts.assertNoErrors();
     }
 
-    @Test(timeout = 500)
+    @Test(timeout = 2000)
     public void testFixBackpressureWithBuffer() throws InterruptedException {
         final CountDownLatch l1 = new CountDownLatch(100);
         final CountDownLatch l2 = new CountDownLatch(150);

File: src/main/java/rx/internal/operators/OperatorMulticast.java
Patch:
@@ -143,7 +143,7 @@ public void call() {
                 subscriptionIsNull = subscription == null;
             }
             if (!subscriptionIsNull)
-                source.unsafeSubscribe(subscription);
+                source.subscribe(subscription);
         }
     }
 }
\ No newline at end of file

File: src/test/java/rx/subscriptions/CompositeSubscriptionTest.java
Patch:
@@ -340,8 +340,8 @@ public void testTryRemoveIfNotIn() {
 
     @Test(expected = IllegalArgumentException.class)
     public void testAddingNullSubscriptionIllegal() {
-      CompositeSubscription csub = new CompositeSubscription();
-      csub.add(null);
+        CompositeSubscription csub = new CompositeSubscription();
+        csub.add(null);
     }
 
 }

File: src/main/java/rx/internal/operators/OperatorAsObservable.java
Patch:
@@ -31,12 +31,13 @@ private static final class Holder {
         static final OperatorAsObservable<Object> INSTANCE = new OperatorAsObservable<Object>();
     }
     /**
-     * @return an singleton instance of this stateless operator.
+     * @return a singleton instance of this stateless operator.
      */
     @SuppressWarnings("unchecked")
     public static <T> OperatorAsObservable<T> instance() {
         return (OperatorAsObservable<T>)Holder.INSTANCE;
     }
+    private OperatorAsObservable() { }
     @Override
     public Subscriber<? super T> call(Subscriber<? super T> s) {
         return s;

File: src/main/java/rx/internal/operators/OperatorConcat.java
Patch:
@@ -43,13 +43,13 @@ private static final class Holder {
         static final OperatorConcat<Object> INSTANCE = new OperatorConcat<Object>();
     }
     /**
-     * @return an singleton instance of this stateless operator.
+     * @return a singleton instance of this stateless operator.
      */
     @SuppressWarnings("unchecked")
     public static <T> OperatorConcat<T> instance() {
         return (OperatorConcat<T>)Holder.INSTANCE;
     }
-    
+    private OperatorConcat() { }
     @Override
     public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super T> child) {
         final SerializedSubscriber<T> s = new SerializedSubscriber<T>(child);

File: src/main/java/rx/internal/operators/OperatorDematerialize.java
Patch:
@@ -36,12 +36,13 @@ private static final class Holder {
         static final OperatorDematerialize<Object> INSTANCE = new OperatorDematerialize<Object>();
     }
     /**
-     * @return an singleton instance of this stateless operator.
+     * @return a singleton instance of this stateless operator.
      */
     @SuppressWarnings({ "rawtypes" })
     public static OperatorDematerialize instance() {
         return Holder.INSTANCE; // using raw types because the type inference is not good enough
     }
+    private OperatorDematerialize() { }
     @Override
     public Subscriber<? super Notification<T>> call(final Subscriber<? super T> child) {
         return new Subscriber<Notification<T>>(child) {

File: src/main/java/rx/internal/operators/OperatorMaterialize.java
Patch:
@@ -35,12 +35,13 @@ private static final class Holder {
         static final OperatorMaterialize<Object> INSTANCE = new OperatorMaterialize<Object>();
     }
     /**
-     * @return an singleton instance of this stateless operator.
+     * @return a singleton instance of this stateless operator.
      */
     @SuppressWarnings("unchecked")
     public static <T> OperatorMaterialize<T> instance() {
         return (OperatorMaterialize<T>)Holder.INSTANCE;
     }
+    private OperatorMaterialize() { }
     @Override
     public Subscriber<? super T> call(final Subscriber<? super Notification<T>> child) {
         return new Subscriber<T>(child) {

File: src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -69,7 +69,7 @@ private static final class HolderDelayErrors {
     }
     /**
      * @param delayErrors should the merge delay errors?
-     * @return an singleton instance of this stateless operator.
+     * @return a singleton instance of this stateless operator.
      */
     @SuppressWarnings("unchecked")
     public static <T> OperatorMerge<T> instance(boolean delayErrors) {

File: src/main/java/rx/internal/operators/OnSubscribeCache.java
Patch:
@@ -64,9 +64,10 @@ public OnSubscribeCache(Observable<? extends T> source, int capacity) {
     @Override
     public void call(Subscriber<? super T> s) {
         if (SRC_SUBSCRIBED_UPDATER.compareAndSet(this, 0, 1)) {
-            source.unsafeSubscribe(Subscribers.from(cache));
+            source.subscribe(cache);
             /*
-             * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values.
+             * Note that we will never unsubscribe from 'source' unless we receive `onCompleted` or `onError`,
+             * as we want to receive and cache all of its values.
              * 
              * This means this should never be used on an infinite or very large sequence, similar to toList().
              */

File: src/main/java/rx/internal/operators/OperatorMap.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func1;
 
@@ -53,6 +54,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(transformer.call(t));
                 } catch (Throwable e) {
+                    Exceptions.throwIfFatal(e);
                     onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }

File: src/main/java/rx/internal/operators/OperatorMap.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func1;
 
@@ -53,6 +54,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(transformer.call(t));
                 } catch (Throwable e) {
+                    Exceptions.throwIfFatal(e);
                     onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }

File: src/main/java/rx/internal/operators/OperatorSampleWithTime.java
Patch:
@@ -50,6 +50,7 @@ public Subscriber<? super T> call(Subscriber<? super T> child) {
         child.add(worker);
         
         SamplerSubscriber<T> sampler = new SamplerSubscriber<T>(s);
+        child.add(sampler);
         worker.schedulePeriodically(sampler, time, time, unit);
 
         return sampler;

File: src/main/java/rx/Observable.java
Patch:
@@ -7321,7 +7321,7 @@ public final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {
                 // TODO why aren't we throwing the hook's return value.
                 throw r;
             }
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
     }
 
@@ -7410,7 +7410,7 @@ public final Subscription subscribe(Subscriber<? super T> subscriber) {
                 // TODO why aren't we throwing the hook's return value.
                 throw r;
             }
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
     }
 

File: src/main/java/rx/internal/operators/OperatorTimeoutWithSelector.java
Patch:
@@ -51,7 +51,7 @@ public Subscription call(
                     } catch (Throwable t) {
                         Exceptions.throwIfFatal(t);
                         timeoutSubscriber.onError(t);
-                        return Subscriptions.empty();
+                        return Subscriptions.unsubscribed();
                     }
                     return o.unsafeSubscribe(new Subscriber<U>() {
 
@@ -72,7 +72,7 @@ public void onNext(U t) {
 
                     });
                 } else {
-                    return Subscriptions.empty();
+                    return Subscriptions.unsubscribed();
                 }
             }
         }, new TimeoutStub<T>() {
@@ -87,7 +87,7 @@ public Subscription call(
                 } catch (Throwable t) {
                     Exceptions.throwIfFatal(t);
                     timeoutSubscriber.onError(t);
-                    return Subscriptions.empty();
+                    return Subscriptions.unsubscribed();
                 }
                 return o.unsafeSubscribe(new Subscriber<V>() {
 

File: src/main/java/rx/internal/schedulers/NewThreadWorker.java
Patch:
@@ -58,7 +58,7 @@ public Subscription schedule(final Action0 action) {
     @Override
     public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {
         if (isUnsubscribed) {
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
         return scheduleActual(action, delayTime, unit);
     }

File: src/main/java/rx/schedulers/CachedThreadScheduler.java
Patch:
@@ -141,7 +141,7 @@ public Subscription schedule(Action0 action) {
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             if (innerSubscription.isUnsubscribed()) {
                 // don't schedule, we are unsubscribed
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
 
             ScheduledAction s = threadWorker.scheduleActual(action, delayTime, unit);

File: src/main/java/rx/schedulers/EventLoopsScheduler.java
Patch:
@@ -95,7 +95,7 @@ public Subscription schedule(Action0 action) {
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             if (innerSubscription.isUnsubscribed()) {
                 // don't schedule, we are unsubscribed
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             
             ScheduledAction s = poolWorker.scheduleActual(action, delayTime, unit);

File: src/main/java/rx/schedulers/ExecutorScheduler.java
Patch:
@@ -71,7 +71,7 @@ public ExecutorSchedulerWorker(Executor executor) {
         @Override
         public Subscription schedule(Action0 action) {
             if (isUnsubscribed()) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             ExecutorAction ea = new ExecutorAction(action, tasks);
             tasks.add(ea);
@@ -106,7 +106,7 @@ public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit
                 return schedule(action);
             }
             if (isUnsubscribed()) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             ScheduledExecutorService service;
             if (executor instanceof ScheduledExecutorService) {

File: src/main/java/rx/schedulers/ImmediateScheduler.java
Patch:
@@ -56,7 +56,7 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
         @Override
         public Subscription schedule(Action0 action) {
             action.call();
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
 
         @Override

File: src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -68,7 +68,7 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
 
         private Subscription enqueue(Action0 action, long execTime) {
             if (innerSubscription.isUnsubscribed()) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));
             queue.add(timedAction);
@@ -81,7 +81,7 @@ private Subscription enqueue(Action0 action, long execTime) {
                         polled.action.call();
                     }
                 } while (wip.decrementAndGet() > 0);
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             } else {
                 // queue wasn't empty, a parent is already processing so we just add to the end of the queue
                 return Subscriptions.create(new Action0() {

File: src/main/java/rx/subscriptions/MultipleAssignmentSubscription.java
Patch:
@@ -25,9 +25,8 @@
  * if unsubscribed.
  */
 public final class MultipleAssignmentSubscription implements Subscription {
-    /** The shared empty state. */
-    static final State EMPTY_STATE = new State(false, Subscriptions.empty());
-    volatile State state = EMPTY_STATE;
+
+    volatile State state = new State(false, Subscriptions.empty());
     static final AtomicReferenceFieldUpdater<MultipleAssignmentSubscription, State> STATE_UPDATER
             = AtomicReferenceFieldUpdater.newUpdater(MultipleAssignmentSubscription.class, State.class, "state");
     

File: src/main/java/rx/subscriptions/RefCountSubscription.java
Patch:
@@ -80,7 +80,7 @@ public Subscription get() {
         do {
             oldState = state;
             if (oldState.isUnsubscribed) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             } else {
                 newState = oldState.addChild();
             }

File: src/main/java/rx/subscriptions/SerialSubscription.java
Patch:
@@ -24,8 +24,7 @@
  * the previous underlying subscription to be unsubscribed.
  */
 public final class SerialSubscription implements Subscription {
-    static final State EMPTY_STATE = new State(false, Subscriptions.empty());
-    volatile State state = EMPTY_STATE;
+    volatile State state = new State(false, Subscriptions.empty());
     static final AtomicReferenceFieldUpdater<SerialSubscription, State> STATE_UPDATER
             = AtomicReferenceFieldUpdater.newUpdater(SerialSubscription.class, State.class, "state");
 

File: src/main/java/rx/internal/operators/OperatorAll.java
Patch:
@@ -34,7 +34,7 @@ public OperatorAll(Func1<? super T, Boolean> predicate) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super Boolean> child) {
-        return new Subscriber<T>(child) {
+        Subscriber<T> s = new Subscriber<T>() {
             boolean done;
 
             @Override
@@ -65,5 +65,7 @@ public void onCompleted() {
                 }
             }
         };
+        child.add(s);
+        return s;
     }
 }

File: src/main/java/rx/internal/operators/OperatorAny.java
Patch:
@@ -36,7 +36,7 @@ public OperatorAny(Func1<? super T, Boolean> predicate, boolean returnOnEmpty) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super Boolean> child) {
-        return new Subscriber<T>(child) {
+        Subscriber<T> s = new Subscriber<T>() {
             boolean hasElements;
             boolean done;
 
@@ -74,5 +74,7 @@ public void onCompleted() {
             }
 
         };
+        child.add(s);
+        return s;
     }
 }

File: src/main/java/rx/internal/operators/OperatorSampleWithTime.java
Patch:
@@ -50,6 +50,7 @@ public Subscriber<? super T> call(Subscriber<? super T> child) {
         child.add(worker);
         
         SamplerSubscriber<T> sampler = new SamplerSubscriber<T>(s);
+        child.add(sampler);
         worker.schedulePeriodically(sampler, time, time, unit);
 
         return sampler;

File: src/main/java/rx/Observable.java
Patch:
@@ -7305,7 +7305,7 @@ public final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {
                 // TODO why aren't we throwing the hook's return value.
                 throw r;
             }
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
     }
 
@@ -7394,7 +7394,7 @@ public final Subscription subscribe(Subscriber<? super T> subscriber) {
                 // TODO why aren't we throwing the hook's return value.
                 throw r;
             }
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
     }
 

File: src/main/java/rx/internal/operators/OperatorTimeoutWithSelector.java
Patch:
@@ -51,7 +51,7 @@ public Subscription call(
                     } catch (Throwable t) {
                         Exceptions.throwIfFatal(t);
                         timeoutSubscriber.onError(t);
-                        return Subscriptions.empty();
+                        return Subscriptions.unsubscribed();
                     }
                     return o.unsafeSubscribe(new Subscriber<U>() {
 
@@ -72,7 +72,7 @@ public void onNext(U t) {
 
                     });
                 } else {
-                    return Subscriptions.empty();
+                    return Subscriptions.unsubscribed();
                 }
             }
         }, new TimeoutStub<T>() {
@@ -87,7 +87,7 @@ public Subscription call(
                 } catch (Throwable t) {
                     Exceptions.throwIfFatal(t);
                     timeoutSubscriber.onError(t);
-                    return Subscriptions.empty();
+                    return Subscriptions.unsubscribed();
                 }
                 return o.unsafeSubscribe(new Subscriber<V>() {
 

File: src/main/java/rx/internal/schedulers/NewThreadWorker.java
Patch:
@@ -58,7 +58,7 @@ public Subscription schedule(final Action0 action) {
     @Override
     public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {
         if (isUnsubscribed) {
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
         return scheduleActual(action, delayTime, unit);
     }

File: src/main/java/rx/schedulers/CachedThreadScheduler.java
Patch:
@@ -141,7 +141,7 @@ public Subscription schedule(Action0 action) {
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             if (innerSubscription.isUnsubscribed()) {
                 // don't schedule, we are unsubscribed
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
 
             ScheduledAction s = threadWorker.scheduleActual(action, delayTime, unit);

File: src/main/java/rx/schedulers/EventLoopsScheduler.java
Patch:
@@ -95,7 +95,7 @@ public Subscription schedule(Action0 action) {
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             if (innerSubscription.isUnsubscribed()) {
                 // don't schedule, we are unsubscribed
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             
             ScheduledAction s = poolWorker.scheduleActual(action, delayTime, unit);

File: src/main/java/rx/schedulers/ExecutorScheduler.java
Patch:
@@ -71,7 +71,7 @@ public ExecutorSchedulerWorker(Executor executor) {
         @Override
         public Subscription schedule(Action0 action) {
             if (isUnsubscribed()) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             ExecutorAction ea = new ExecutorAction(action, tasks);
             tasks.add(ea);
@@ -106,7 +106,7 @@ public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit
                 return schedule(action);
             }
             if (isUnsubscribed()) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             ScheduledExecutorService service;
             if (executor instanceof ScheduledExecutorService) {

File: src/main/java/rx/schedulers/ImmediateScheduler.java
Patch:
@@ -56,7 +56,7 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
         @Override
         public Subscription schedule(Action0 action) {
             action.call();
-            return Subscriptions.empty();
+            return Subscriptions.unsubscribed();
         }
 
         @Override

File: src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -68,7 +68,7 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
 
         private Subscription enqueue(Action0 action, long execTime) {
             if (innerSubscription.isUnsubscribed()) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             }
             final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));
             queue.add(timedAction);
@@ -81,7 +81,7 @@ private Subscription enqueue(Action0 action, long execTime) {
                         polled.action.call();
                     }
                 } while (wip.decrementAndGet() > 0);
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             } else {
                 // queue wasn't empty, a parent is already processing so we just add to the end of the queue
                 return Subscriptions.create(new Action0() {

File: src/main/java/rx/subscriptions/MultipleAssignmentSubscription.java
Patch:
@@ -26,7 +26,7 @@
  */
 public final class MultipleAssignmentSubscription implements Subscription {
     /** The shared empty state. */
-    static final State EMPTY_STATE = new State(false, Subscriptions.empty());
+    static final State EMPTY_STATE = new State(false, Subscriptions.unsubscribed());
     volatile State state = EMPTY_STATE;
     static final AtomicReferenceFieldUpdater<MultipleAssignmentSubscription, State> STATE_UPDATER
             = AtomicReferenceFieldUpdater.newUpdater(MultipleAssignmentSubscription.class, State.class, "state");

File: src/main/java/rx/subscriptions/RefCountSubscription.java
Patch:
@@ -80,7 +80,7 @@ public Subscription get() {
         do {
             oldState = state;
             if (oldState.isUnsubscribed) {
-                return Subscriptions.empty();
+                return Subscriptions.unsubscribed();
             } else {
                 newState = oldState.addChild();
             }

File: src/main/java/rx/subscriptions/SerialSubscription.java
Patch:
@@ -24,7 +24,7 @@
  * the previous underlying subscription to be unsubscribed.
  */
 public final class SerialSubscription implements Subscription {
-    static final State EMPTY_STATE = new State(false, Subscriptions.empty());
+    static final State EMPTY_STATE = new State(false, Subscriptions.unsubscribed());
     volatile State state = EMPTY_STATE;
     static final AtomicReferenceFieldUpdater<SerialSubscription, State> STATE_UPDATER
             = AtomicReferenceFieldUpdater.newUpdater(SerialSubscription.class, State.class, "state");

File: src/main/java/rx/internal/operators/OperatorAll.java
Patch:
@@ -34,7 +34,7 @@ public OperatorAll(Func1<? super T, Boolean> predicate) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super Boolean> child) {
-        return new Subscriber<T>(child) {
+        Subscriber<T> s = new Subscriber<T>() {
             boolean done;
 
             @Override
@@ -65,5 +65,7 @@ public void onCompleted() {
                 }
             }
         };
+        child.add(s);
+        return s;
     }
 }

File: src/main/java/rx/internal/schedulers/NewThreadWorker.java
Patch:
@@ -37,8 +37,8 @@ public NewThreadWorker(ThreadFactory threadFactory) {
         // Java 7+: cancelled future tasks can be removed from the executor thus avoiding memory leak
         for (Method m : executor.getClass().getMethods()) {
             if (m.getName().equals("setRemoveOnCancelPolicy")
-                    && m.getParameterCount() == 1
-                    && m.getParameters()[0].getType() == Boolean.TYPE) {
+                    && m.getParameterTypes().length == 1
+                    && m.getParameterTypes()[0] == Boolean.TYPE) {
                 try {
                     m.invoke(executor, true);
                 } catch (Exception ex) {

File: src/main/java/rx/schedulers/TestScheduler.java
Patch:
@@ -111,7 +111,8 @@ private void triggerActions(long targetTimeInNanos) {
             if (current.time > targetTimeInNanos) {
                 break;
             }
-            time = current.time;
+            // if scheduled time is 0 (immediate) use current virtual time
+            time = current.time == 0 ? time : current.time;
             queue.remove();
 
             // Only execute if not unsubscribed
@@ -129,7 +130,7 @@ public Worker createWorker() {
 
     private final class InnerTestScheduler extends Worker {
 
-        private BooleanSubscription s = new BooleanSubscription();
+        private final BooleanSubscription s = new BooleanSubscription();
 
         @Override
         public void unsubscribe() {

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -306,7 +306,7 @@ private void pollQueue(GroupState<K, T> groupState) {
         }
 
         private void requestMoreIfNecessary() {
-            if (REQUESTED.get(this) == 0) {
+            if (REQUESTED.get(this) == 0 && terminated == 0) {
                 long toRequest = MAX_QUEUE_SIZE - BUFFERED_COUNT.get(this);
                 if (toRequest > 0 && REQUESTED.compareAndSet(this, 0, toRequest)) {
                     request(toRequest);

File: src/main/java/rx/schedulers/TestScheduler.java
Patch:
@@ -111,7 +111,8 @@ private void triggerActions(long targetTimeInNanos) {
             if (current.time > targetTimeInNanos) {
                 break;
             }
-            time = current.time;
+            // if scheduled time is 0 (immediate) use current virtual time
+            time = current.time == 0 ? time : current.time;
             queue.remove();
 
             // Only execute if not unsubscribed
@@ -129,7 +130,7 @@ public Worker createWorker() {
 
     private final class InnerTestScheduler extends Worker {
 
-        private BooleanSubscription s = new BooleanSubscription();
+        private final BooleanSubscription s = new BooleanSubscription();
 
         @Override
         public void unsubscribe() {

File: src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java
Patch:
@@ -24,7 +24,7 @@
 import rx.Subscriber;
 
 /**
- * Operator that uses blocks the producer thread in case a backpressure is needed.
+ * Operator that blocks the producer thread in case a backpressure is needed.
  */
 public class OperatorOnBackpressureBlock<T> implements Operator<T, T> {
     final int max;

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -306,7 +306,7 @@ private void pollQueue(GroupState<K, T> groupState) {
         }
 
         private void requestMoreIfNecessary() {
-            if (REQUESTED.get(this) == 0) {
+            if (REQUESTED.get(this) == 0 && terminated == 0) {
                 long toRequest = MAX_QUEUE_SIZE - BUFFERED_COUNT.get(this);
                 if (toRequest > 0 && REQUESTED.compareAndSet(this, 0, toRequest)) {
                     request(toRequest);

File: src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -501,7 +501,7 @@ public void request(long n) {
                 REQUESTED.getAndAdd(this, n);
                 if (ms.drainQueuesIfNeeded()) {
                     boolean sendComplete = false;
-                    synchronized (this) {
+                    synchronized (ms) {
                         if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {
                             sendComplete = true;
                         }

File: src/main/java/rx/internal/operators/OperatorBufferWithTime.java
Patch:
@@ -75,7 +75,7 @@ public Subscriber<? super T> call(final Subscriber<? super List<T>> child) {
         SerializedSubscriber<List<T>> serialized = new SerializedSubscriber<List<T>>(child);
         
         if (timespan == timeshift) {
-			ExactSubscriber bsub = new ExactSubscriber(serialized, inner);
+            ExactSubscriber bsub = new ExactSubscriber(serialized, inner);
             bsub.add(inner);
             child.add(bsub);
             bsub.scheduleExact();

File: src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -501,7 +501,7 @@ public void request(long n) {
                 REQUESTED.getAndAdd(this, n);
                 if (ms.drainQueuesIfNeeded()) {
                     boolean sendComplete = false;
-                    synchronized (this) {
+                    synchronized (ms) {
                         if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {
                             sendComplete = true;
                         }

File: src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -26,7 +26,6 @@
 import rx.exceptions.Exceptions;
 import rx.functions.Action1;
 import rx.functions.Func1;
-import rx.functions.Functions;
 import rx.internal.operators.NotificationLite;
 import rx.internal.util.UtilityFunctions;
 import rx.schedulers.Timestamped;
@@ -358,6 +357,7 @@ private boolean caughtUp(SubjectObserver<? super T> o) {
         if (!o.caughtUp) {
             o.caughtUp = true;
             state.replayObserver(o);
+            o.index(null); // once caught up, no need for the index anymore
             return false;
         } else {
             // it was caught up so proceed the "raw route"

File: src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -26,7 +26,6 @@
 import rx.exceptions.Exceptions;
 import rx.functions.Action1;
 import rx.functions.Func1;
-import rx.functions.Functions;
 import rx.internal.operators.NotificationLite;
 import rx.internal.util.UtilityFunctions;
 import rx.schedulers.Timestamped;
@@ -358,6 +357,7 @@ private boolean caughtUp(SubjectObserver<? super T> o) {
         if (!o.caughtUp) {
             o.caughtUp = true;
             state.replayObserver(o);
+            o.index(null); // once caught up, no need for the index anymore
             return false;
         } else {
             // it was caught up so proceed the "raw route"

File: src/main/java/rx/observers/Observers.java
Patch:
@@ -61,8 +61,8 @@ public static <T> Observer<T> empty() {
 
     /**
      * Creates an {@link Observer} that receives the emissions of any {@code Observable} it subscribes to via
-     * {@link Observer#onNext onNext} but ignores {@link Observer#onCompleted onCompleted} notifications. 
-     * It will throw an {@link OnErrorNotImplementedException} if {@link Observer#onError onError} is invoked.
+     * {@link Observer#onNext onNext} but ignores {@link Observer#onCompleted onCompleted} notifications; 
+     * it will throw an {@link OnErrorNotImplementedException} if {@link Observer#onError onError} is invoked.
      *
      * @param onNext
      *          a function that handles each item emitted by an {@code Observable}

File: src/main/java/rx/internal/operators/OperatorZip.java
Patch:
@@ -227,7 +227,7 @@ void tick() {
             if (COUNTER_UPDATER.getAndIncrement(this) == 0) {
                 do {
                     // we only emit if requested > 0
-                    if (requested.get() > 0) {
+                    while (requested.get() > 0) {
                         final Object[] vs = new Object[observers.length];
                         boolean allHaveValues = true;
                         for (int i = 0; i < observers.length; i++) {
@@ -279,6 +279,8 @@ void tick() {
                                 }
                                 emitted = 0;
                             }
+                        } else {
+                            break;
                         }
                     }
                 } while (COUNTER_UPDATER.decrementAndGet(this) > 0);

File: src/main/java/rx/internal/operators/OperatorZip.java
Patch:
@@ -227,7 +227,7 @@ void tick() {
             if (COUNTER_UPDATER.getAndIncrement(this) == 0) {
                 do {
                     // we only emit if requested > 0
-                    if (requested.get() > 0) {
+                    while (requested.get() > 0) {
                         final Object[] vs = new Object[observers.length];
                         boolean allHaveValues = true;
                         for (int i = 0; i < observers.length; i++) {
@@ -279,6 +279,8 @@ void tick() {
                                 }
                                 emitted = 0;
                             }
+                        } else {
+                            break;
                         }
                     }
                 } while (COUNTER_UPDATER.decrementAndGet(this) > 0);

File: src/main/java/rx/internal/operators/OperatorSequenceEqual.java
Patch:
@@ -21,7 +21,7 @@
 import rx.Observable;
 import rx.functions.Func1;
 import rx.functions.Func2;
-import rx.functions.Functions;
+import rx.internal.util.UtilityFunctions;
 
 /**
  * Returns an {@link Observable} that emits a single {@code Boolean} value that indicates whether two source
@@ -84,6 +84,6 @@ public Boolean call(Object t1, Object t2) {
                         return equality.call((T)t1, (T)t2);
                     }
 
-                }).all(Functions.<Boolean> identity());
+                }).all(UtilityFunctions.<Boolean> identity());
     }
 }

File: src/test/java/rx/internal/operators/OperatorGroupByTest.java
Patch:
@@ -50,7 +50,7 @@
 import rx.functions.Action0;
 import rx.functions.Action1;
 import rx.functions.Func1;
-import rx.functions.Functions;
+import rx.internal.util.UtilityFunctions;
 import rx.observables.GroupedObservable;
 import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
@@ -1103,7 +1103,7 @@ public Integer call(Integer t1) {
             return t1 * 2;
         }
     };
-    Func1<Integer, Integer> identity = Functions.identity();
+    Func1<Integer, Integer> identity = UtilityFunctions.identity();
 
     @Before
     public void before() {

File: src/test/java/rx/internal/operators/OperatorTakeLastTest.java
Patch:
@@ -32,8 +32,8 @@
 import rx.Observer;
 import rx.Subscriber;
 import rx.functions.Func1;
-import rx.functions.Functions;
 import rx.internal.util.RxRingBuffer;
+import rx.internal.util.UtilityFunctions;
 import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
 
@@ -156,7 +156,7 @@ public void testIssue1522() {
         assertEquals(0, Observable
                 .empty()
                 .count()
-                .filter(Functions.alwaysFalse())
+                .filter(UtilityFunctions.alwaysFalse())
                 .toList()
                 .toBlocking().single().size());
     }

File: src/test/java/rx/internal/operators/OperatorToMapTest.java
Patch:
@@ -33,7 +33,7 @@
 import rx.Observer;
 import rx.functions.Func0;
 import rx.functions.Func1;
-import rx.functions.Functions;
+import rx.internal.util.UtilityFunctions;
 
 public class OperatorToMapTest {
     @Mock
@@ -179,7 +179,7 @@ public Integer call(String t1) {
                 return t1.length();
             }
         };
-        Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, Functions.<String>identity(), mapFactory);
+        Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, UtilityFunctions.<String>identity(), mapFactory);
 
         Map<Integer, String> expected = new LinkedHashMap<Integer, String>();
         expected.put(2, "bb");
@@ -210,7 +210,7 @@ public Integer call(String t1) {
                 return t1.length();
             }
         };
-        Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, Functions.<String>identity(), mapFactory);
+        Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, UtilityFunctions.<String>identity(), mapFactory);
 
         Map<Integer, String> expected = new LinkedHashMap<Integer, String>();
         expected.put(2, "bb");

File: src/main/java/rx/Observable.java
Patch:
@@ -6510,7 +6510,7 @@ public final Observable<T> serialize() {
 
     /**
      * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as
-     * there is more than one {@link Subscriber} this {@link Observable} will be subscribed and emitting data. 
+     * there is at least one {@link Subscriber} this {@link Observable} will be subscribed and emitting data. 
      * When all subscribers have unsubscribed it will unsubscribe from the source {@link Observable}. 
      * <p>
      * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}.

File: src/test/java/rx/subjects/BehaviorSubjectTest.java
Patch:
@@ -16,6 +16,7 @@
 package rx.subjects;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.inOrder;
@@ -370,6 +371,7 @@ public void testTakeOneSubscriber() {
         verify(o, never()).onError(any(Throwable.class));
         
         assertEquals(0, source.subscriberCount());
+        assertFalse(source.hasObservers());
     }
     
     @Test

File: src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -188,7 +188,7 @@ public void onNext(T t) {
         private GroupState<K, T> createNewGroup(final K key) {
             final GroupState<K, T> groupState = new GroupState<K, T>();
 
-            GroupedObservable<K, R> go = new GroupedObservable<K, R>(key, new OnSubscribe<R>() {
+            GroupedObservable<K, R> go = GroupedObservable.create(key, new OnSubscribe<R>() {
 
                 @Override
                 public void call(final Subscriber<? super R> o) {

File: src/test/java/rx/ObservableTests.java
Patch:
@@ -517,7 +517,7 @@ public void run() {
                     }
                 }).start();
             }
-        }).publishLast();
+        }).takeLast(1).publish();
 
         // subscribe once
         final CountDownLatch latch = new CountDownLatch(1);

File: src/test/java/rx/plugins/RxJavaPluginsTest.java
Patch:
@@ -16,6 +16,7 @@
 package rx.plugins;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -41,7 +42,7 @@ public void resetAfter() {
     @Test
     public void testErrorHandlerDefaultImpl() {
         RxJavaErrorHandler impl = new RxJavaPlugins().getErrorHandler();
-        assertTrue(impl instanceof RxJavaErrorHandlerDefault);
+        assertSame(RxJavaPlugins.DEFAULT_ERROR_HANDLER, impl);
     }
 
     @Test

File: src/test/java/rx/internal/operators/BlockingOperatorNextTest.java
Patch:
@@ -296,7 +296,7 @@ public void run() {
 
     @Test /* (timeout = 8000) */
     public void testSingleSourceManyIterators() throws InterruptedException {
-        Observable<Long> o = Observable.interval(10, TimeUnit.MILLISECONDS);
+        Observable<Long> o = Observable.interval(100, TimeUnit.MILLISECONDS);
         PublishSubject<Void> terminal = PublishSubject.create();
         BlockingObservable<Long> source = o.takeUntil(terminal).toBlocking();
 

File: src/main/java/rx/schedulers/ExecutorScheduler.java
Patch:
@@ -173,6 +173,8 @@ public void run() {
                 actual.call();
             } catch (Throwable t) {
                 RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+                Thread thread = Thread.currentThread();
+                thread.getUncaughtExceptionHandler().uncaughtException(thread, t);
             } finally {
                 unsubscribe();
             }

File: src/main/java/rx/internal/schedulers/ScheduledAction.java
Patch:
@@ -51,8 +51,9 @@ public void run() {
             } else {
                 ie = new IllegalStateException("Fatal Exception thrown on Scheduler.Worker thread.", e);
             }
-            ie.printStackTrace();
             RxJavaPlugins.getInstance().getErrorHandler().handleError(ie);
+            Thread thread = Thread.currentThread();
+            thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);
         } finally {
             unsubscribe();
         }

File: src/main/java/rx/internal/schedulers/ScheduledAction.java
Patch:
@@ -51,8 +51,9 @@ public void run() {
             } else {
                 ie = new IllegalStateException("Fatal Exception thrown on Scheduler.Worker thread.", e);
             }
-            ie.printStackTrace();
             RxJavaPlugins.getInstance().getErrorHandler().handleError(ie);
+            Thread thread = Thread.currentThread();
+            thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);
         } finally {
             unsubscribe();
         }

File: src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
Patch:
@@ -35,14 +35,14 @@ public final class OnSubscribeFromIterable<T> implements OnSubscribe<T> {
     final Iterable<? extends T> is;
 
     public OnSubscribeFromIterable(Iterable<? extends T> iterable) {
+        if (iterable == null) {
+            throw new NullPointerException("iterable must not be null");
+        }
         this.is = iterable;
     }
 
     @Override
     public void call(final Subscriber<? super T> o) {
-        if (is == null) {
-            o.onCompleted();
-        }
         final Iterator<? extends T> it = is.iterator();
         o.setProducer(new IterableProducer<T>(o, it));
     }

File: src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
Patch:
@@ -35,14 +35,14 @@ public final class OnSubscribeFromIterable<T> implements OnSubscribe<T> {
     final Iterable<? extends T> is;
 
     public OnSubscribeFromIterable(Iterable<? extends T> iterable) {
+        if (iterable == null) {
+            throw new NullPointerException("iterable must not be null");
+        }
         this.is = iterable;
     }
 
     @Override
     public void call(final Subscriber<? super T> o) {
-        if (is == null) {
-            o.onCompleted();
-        }
         final Iterator<? extends T> it = is.iterator();
         o.setProducer(new IterableProducer<T>(o, it));
     }

File: src/main/java/rx/internal/operators/OperatorDoOnSubscribe.java
Patch:
@@ -28,7 +28,7 @@ public class OperatorDoOnSubscribe<T> implements Operator<T, T> {
 
     /**
      * Constructs an instance of the operator with the callback that gets invoked when the modified Observable is subscribed
-     * @param unsubscribe The action that gets invoked when the modified {@link rx.Observable} is subscribed
+     * @param subscribe the action that gets invoked when the modified {@link rx.Observable} is subscribed
      */
     public OperatorDoOnSubscribe(Action0 subscribe) {
         this.subscribe = subscribe;

File: src/main/java/rx/Observable.java
Patch:
@@ -5722,7 +5722,7 @@ public final Observable<T> repeat(final long count, Scheduler scheduler) {
     /**
      * Returns an Observable that emits the same values as the source Observable with the exception of an
      * {@code onCompleted}. An {@code onCompleted} notification from the source will result in the emission of
-     * a {@link void} item to the Observable provided as an argument to the {@code notificationHandler}
+     * a {@code void} item to the Observable provided as an argument to the {@code notificationHandler}
      * function. If that Observable calls {@code onComplete} or {@code onError} then {@code repeatWhen} will
      * call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will
      * resubscribe to the source Observable, on a particular Scheduler.
@@ -5759,7 +5759,7 @@ public Void call(Notification<?> notification) {
     /**
      * Returns an Observable that emits the same values as the source Observable with the exception of an
      * {@code onCompleted}. An {@code onCompleted} notification from the source will result in the emission of
-     * a {@link void} item to the Observable provided as an argument to the {@code notificationHandler}
+     * a {@code void} item to the Observable provided as an argument to the {@code notificationHandler}
      * function. If that Observable calls {@code onComplete} or {@code onError} then {@code repeatWhen} will
      * call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will
      * resubscribe to the source observable.

File: src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -409,7 +409,7 @@ public void onError(Throwable e) {
                 boolean sendOnComplete = false;
                 synchronized (this) {
                     wip--;
-                    if (wip == 0 && completed) {
+                    if ((wip == 0 && completed) || (wip < 0)) {
                         sendOnComplete = true;
                     }
                 }

File: src/main/java/rx/internal/operators/NotificationLite.java
Patch:
@@ -76,7 +76,7 @@ public OnErrorSentinel(Throwable e) {
         }
         
         public String toString() {
-            return "Notification=>Error:" + e.getMessage();
+            return "Notification=>Error:" + e;
         }
     }
 

File: src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java
Patch:
@@ -138,7 +138,6 @@ public void request(long n) {
          * This will only allow one thread at a time to do the work, but ensures via `counter` increment/decrement
          * that there is always once who acts on each `tick`. Same concept as used in OperationObserveOn.
          */
-        @SuppressWarnings("unchecked")
         void tick() {
             if (WIP.getAndIncrement(this) == 0) {
                 int emitted = 0;
@@ -150,7 +149,7 @@ void tick() {
                             if (buffer.isCompleted(o)) {
                                 child.onCompleted();
                             } else {
-                                child.onNext(NotificationLite.<R>instance().getValue(o));
+                                buffer.accept(o, child);
                                 emitted++;
                                 requested.decrementAndGet();
                             }

File: src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java
Patch:
@@ -150,7 +150,7 @@ void tick() {
                             if (buffer.isCompleted(o)) {
                                 child.onCompleted();
                             } else {
-                                child.onNext((R) o);
+                                child.onNext(NotificationLite.<R>instance().getValue(o));
                                 emitted++;
                                 requested.decrementAndGet();
                             }

File: src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java
Patch:
@@ -150,7 +150,7 @@ void tick() {
                             if (buffer.isCompleted(o)) {
                                 child.onCompleted();
                             } else {
-                                child.onNext((R) o);
+                                child.onNext(NotificationLite.<R>instance().getValue(o));
                                 emitted++;
                                 requested.decrementAndGet();
                             }

File: src/main/java/rx/internal/operators/NotificationLite.java
Patch:
@@ -76,7 +76,7 @@ public OnErrorSentinel(Throwable e) {
         }
         
         public String toString() {
-            return "Notification=>Error:" + e.getMessage();
+            return "Notification=>Error:" + e;
         }
     }
 

File: src/main/java/rx/internal/operators/OperatorScan.java
Patch:
@@ -129,7 +129,7 @@ public void setProducer(final Producer producer) {
                     @Override
                     public void request(long n) {
                         if (once.compareAndSet(false, true)) {
-                            if (initialValue == NO_INITIAL_VALUE) {
+                            if (initialValue == NO_INITIAL_VALUE || n == Long.MAX_VALUE) {
                                 producer.request(n);
                             } else {
                                 producer.request(n - 1);

File: src/main/java/rx/internal/operators/OperatorSwitch.java
Patch:
@@ -62,6 +62,7 @@ private static final class SwitchSubscriber<T> extends Subscriber<Observable<? e
         volatile boolean infinite = false;
 
         public SwitchSubscriber(Subscriber<? super T> child) {
+            super(child);
             s = new SerializedSubscriber<T>(child);
             ssub = new SerialSubscription();
             child.add(ssub);

File: src/main/java/rx/internal/operators/OperatorTakeUntil.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.observers.SerializedSubscriber;
 
 /**
  * Returns an Observable that emits the items from the source Observable until another Observable
@@ -35,7 +36,7 @@ public OperatorTakeUntil(final Observable<? extends E> other) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super T> child) {
-        final Subscriber<T> parent = new Subscriber<T>(child) {
+        final Subscriber<T> parent = new SerializedSubscriber<T>(child) {
 
             @Override
             public void onCompleted() {

File: src/main/java/rx/internal/operators/OperatorSwitch.java
Patch:
@@ -62,6 +62,7 @@ private static final class SwitchSubscriber<T> extends Subscriber<Observable<? e
         volatile boolean infinite = false;
 
         public SwitchSubscriber(Subscriber<? super T> child) {
+            super(child);
             s = new SerializedSubscriber<T>(child);
             ssub = new SerialSubscription();
             child.add(ssub);

File: rxjava/src/main/java/rx/internal/operators/OperatorDoOnEach.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 
 /**
@@ -54,6 +55,8 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
+                // need to throwIfFatal since we swallow errors after terminated
+                Exceptions.throwIfFatal(e);
                 if (done) {
                     return;
                 }

File: rxjava/src/main/java/rx/schedulers/Schedulers.java
Patch:
@@ -32,21 +32,21 @@ public final class Schedulers {
     private static final Schedulers INSTANCE = new Schedulers();
 
     private Schedulers() {
-        Scheduler c = RxJavaPlugins.getInstance().getDefaultSchedulers().getComputationScheduler();
+        Scheduler c = RxJavaPlugins.getInstance().getSchedulersHook().getComputationScheduler();
         if (c != null) {
             computationScheduler = c;
         } else {
             computationScheduler = new EventLoopsScheduler();
         }
 
-        Scheduler io = RxJavaPlugins.getInstance().getDefaultSchedulers().getIOScheduler();
+        Scheduler io = RxJavaPlugins.getInstance().getSchedulersHook().getIOScheduler();
         if (io != null) {
             ioScheduler = io;
         } else {
             ioScheduler = new CachedThreadScheduler();
         }
 
-        Scheduler nt = RxJavaPlugins.getInstance().getDefaultSchedulers().getNewThreadScheduler();
+        Scheduler nt = RxJavaPlugins.getInstance().getSchedulersHook().getNewThreadScheduler();
         if (nt != null) {
             newThreadScheduler = nt;
         } else {

File: rxjava/src/test/java/rx/ObservableTests.java
Patch:
@@ -959,7 +959,7 @@ public void testIgnoreElements() {
     @Test
             public void testJustWithScheduler() {
                 TestScheduler scheduler = new TestScheduler();
-                Observable<Integer> observable = Observable.from(Arrays.asList(1, 2), scheduler);
+                Observable<Integer> observable = Observable.from(Arrays.asList(1, 2)).subscribeOn(scheduler);
         
                 @SuppressWarnings("unchecked")
                 Observer<Integer> observer = mock(Observer.class);
@@ -977,7 +977,7 @@ public void testJustWithScheduler() {
     @Test
     public void testStartWithWithScheduler() {
         TestScheduler scheduler = new TestScheduler();
-        Observable<Integer> observable = Observable.just(3, 4).startWith(Arrays.asList(1, 2), scheduler);
+        Observable<Integer> observable = Observable.just(3, 4).startWith(Arrays.asList(1, 2)).subscribeOn(scheduler);
 
         @SuppressWarnings("unchecked")
         Observer<Integer> observer = mock(Observer.class);

File: rxjava/src/test/java/rx/internal/operators/BlockingOperatorLatestTest.java
Patch:
@@ -115,7 +115,7 @@ public void testSimpleJustNext() {
     public void testHasNextThrows() {
         TestScheduler scheduler = new TestScheduler();
 
-        BlockingObservable<Long> source = Observable.<Long> error(new RuntimeException("Forced failure!"), scheduler).toBlocking();
+        BlockingObservable<Long> source = Observable.<Long> error(new RuntimeException("Forced failure!")).subscribeOn(scheduler).toBlocking();
 
         Iterable<Long> iter = source.latest();
 
@@ -130,7 +130,7 @@ public void testHasNextThrows() {
     public void testNextThrows() {
         TestScheduler scheduler = new TestScheduler();
 
-        BlockingObservable<Long> source = Observable.<Long> error(new RuntimeException("Forced failure!"), scheduler).toBlocking();
+        BlockingObservable<Long> source = Observable.<Long> error(new RuntimeException("Forced failure!")).subscribeOn(scheduler).toBlocking();
 
         Iterable<Long> iter = source.latest();
         Iterator<Long> it = iter.iterator();

File: rxjava/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java
Patch:
@@ -114,7 +114,7 @@ public Integer call(Long t1) {
 
         Observable<Integer> source2 = source1
                 .repeat(4)
-                .zip(Observable.timer(0, 10, TimeUnit.MILLISECONDS, Schedulers.newThread()), new Func2<Integer, Long, Integer>() {
+                .zipWith(Observable.timer(0, 10, TimeUnit.MILLISECONDS, Schedulers.newThread()), new Func2<Integer, Long, Integer>() {
                     @Override
                     public Integer call(Integer t1, Long t2) {
                         return t1;

File: rxjava/src/test/java/rx/internal/operators/OnSubscribeCombineLatestTest.java
Patch:
@@ -791,7 +791,7 @@ public void testBackpressure() {
 
         int NUM = RxRingBuffer.SIZE * 4;
         TestSubscriber<String> ts = new TestSubscriber<String>();
-        Observable.combineLatest(Observable.from("one", "two"),
+        Observable.combineLatest(Observable.just("one", "two"),
                 Observable.range(2, NUM), combineLatestFunction).
                 observeOn(Schedulers.computation()).subscribe(ts);
 

File: rxjava/src/test/java/rx/internal/operators/OperatorWindowTest.java
Patch:
@@ -98,7 +98,7 @@ public void testSkipAndCountGaplessWindows() {
 
     @Test
     public void testOverlappingWindows() {
-        Observable<String> subject = Observable.from(new String[] { "zero", "one", "two", "three", "four", "five" }, Schedulers.trampoline());
+        Observable<String> subject = Observable.from(new String[] { "zero", "one", "two", "three", "four", "five" });
         Observable<Observable<String>> windowed = subject.window(3, 1);
 
         List<List<String>> windows = toLists(windowed);

File: rxjava/src/test/java/rx/internal/operators/OperatorZipTest.java
Patch:
@@ -804,7 +804,7 @@ public void onNext(Integer args) {
     @Test
     public void testStart() {
         Observable<String> os = OBSERVABLE_OF_5_INTEGERS
-                .zip(OBSERVABLE_OF_5_INTEGERS, new Func2<Integer, Integer, String>() {
+                .zipWith(OBSERVABLE_OF_5_INTEGERS, new Func2<Integer, Integer, String>() {
 
                     @Override
                     public String call(Integer a, Integer b) {
@@ -832,7 +832,7 @@ public void call(String s) {
     public void testStartAsync() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         Observable<String> os = ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(new CountDownLatch(1)).onBackpressureBuffer()
-                .zip(ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(new CountDownLatch(1)).onBackpressureBuffer(), new Func2<Integer, Integer, String>() {
+                .zipWith(ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(new CountDownLatch(1)).onBackpressureBuffer(), new Func2<Integer, Integer, String>() {
 
                     @Override
                     public String call(Integer a, Integer b) {
@@ -857,7 +857,7 @@ public void testStartInfiniteAndFinite() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final CountDownLatch infiniteObservable = new CountDownLatch(1);
         Observable<String> os = OBSERVABLE_OF_5_INTEGERS
-                .zip(ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(infiniteObservable), new Func2<Integer, Integer, String>() {
+                .zipWith(ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(infiniteObservable), new Func2<Integer, Integer, String>() {
 
                     @Override
                     public String call(Integer a, Integer b) {

File: rxjava/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -112,13 +112,13 @@ public void call() {
     @Test
     public final void testNestedScheduling() {
 
-        Observable<Integer> ids = Observable.from(Arrays.asList(1, 2), getScheduler());
+        Observable<Integer> ids = Observable.from(Arrays.asList(1, 2)).subscribeOn(getScheduler());
 
         Observable<String> m = ids.flatMap(new Func1<Integer, Observable<String>>() {
 
             @Override
             public Observable<String> call(Integer id) {
-                return Observable.from(Arrays.asList("a-" + id, "b-" + id), getScheduler())
+                return Observable.from(Arrays.asList("a-" + id, "b-" + id)).subscribeOn(getScheduler())
                         .map(new Func1<String, String>() {
 
                             @Override
@@ -406,7 +406,7 @@ public final void testSubscribeOnNestedConcurrency() throws InterruptedException
         final Scheduler scheduler = getScheduler();
 
         Observable<String> o = Observable.just("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten")
-                .mergeMap(new Func1<String, Observable<String>>() {
+                .flatMap(new Func1<String, Observable<String>>() {
 
                     @Override
                     public Observable<String> call(final String v) {

File: rxjava-core/src/main/java/rx/observables/GroupedObservable.java
Patch:
@@ -46,7 +46,9 @@ public class GroupedObservable<K, T> extends Observable<T> {
      * @param o
      *          the {@link Observable} to convert
      * @return a {@code GroupedObservable} representation of {@code o}, with key {@code key}
+     * @deprecated Use Observable.groupBy with element selector instead. 
      */
+    @Deprecated
     public static <K, T> GroupedObservable<K, T> from(K key, final Observable<T> o) {
         return new GroupedObservable<K, T>(key, new OnSubscribe<T>() {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSequenceEqual.java
Patch:
@@ -16,7 +16,7 @@
 package rx.internal.operators;
 
 import static rx.Observable.concat;
-import static rx.Observable.from;
+import static rx.Observable.just;
 import static rx.Observable.zip;
 import rx.Observable;
 import rx.functions.Func1;
@@ -43,7 +43,7 @@ public Object call(T t1) {
                         return t1;
                     }
 
-                }), from(LOCAL_ONCOMPLETED));
+                }), just(LOCAL_ONCOMPLETED));
     }
 
     /**

File: rxjava-core/src/test/java/rx/CombineLatestTests.java
Patch:
@@ -33,8 +33,8 @@ public class CombineLatestTests {
      */
     @Test
     public void testCovarianceOfCombineLatest() {
-        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());
-        Observable<CoolRating> ratings = Observable.from(new CoolRating());
+        Observable<HorrorMovie> horrors = Observable.just(new HorrorMovie());
+        Observable<CoolRating> ratings = Observable.just(new CoolRating());
 
         Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlocking().forEach(action);
         Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlocking().forEach(action);

File: rxjava-core/src/test/java/rx/CovarianceTest.java
Patch:
@@ -33,7 +33,7 @@ public class CovarianceTest {
      */
     @Test
     public void testCovarianceOfFrom() {
-        Observable.<Movie> from(new HorrorMovie());
+        Observable.<Movie> just(new HorrorMovie());
         Observable.<Movie> from(new ArrayList<HorrorMovie>());
         // Observable.<HorrorMovie>from(new Movie()); // may not compile
     }
@@ -49,11 +49,11 @@ public Integer call(Media t1, Media t2) {
         };
 
         // this one would work without the covariance generics
-        Observable<Media> o = Observable.from(new Movie(), new TVSeason(), new Album());
+        Observable<Media> o = Observable.just(new Movie(), new TVSeason(), new Album());
         o.toSortedList(SORT_FUNCTION);
 
         // this one would NOT work without the covariance generics
-        Observable<Movie> o2 = Observable.from(new Movie(), new ActionMovie(), new HorrorMovie());
+        Observable<Movie> o2 = Observable.just(new Movie(), new ActionMovie(), new HorrorMovie());
         o2.toSortedList(SORT_FUNCTION);
     }
 

File: rxjava-core/src/test/java/rx/ObservableDoOnTest.java
Patch:
@@ -33,7 +33,7 @@ public class ObservableDoOnTest {
     @Test
     public void testDoOnEach() {
         final AtomicReference<String> r = new AtomicReference<String>();
-        String output = Observable.from("one").doOnNext(new Action1<String>() {
+        String output = Observable.just("one").doOnNext(new Action1<String>() {
 
             @Override
             public void call(String v) {
@@ -69,7 +69,7 @@ public void call(Throwable v) {
     @Test
     public void testDoOnCompleted() {
         final AtomicBoolean r = new AtomicBoolean();
-        String output = Observable.from("one").doOnCompleted(new Action0() {
+        String output = Observable.just("one").doOnCompleted(new Action0() {
 
             @Override
             public void call() {

File: rxjava-core/src/test/java/rx/ObservableWindowTests.java
Patch:
@@ -32,7 +32,7 @@ public class ObservableWindowTests {
     public void testWindow() {
         final ArrayList<List<Integer>> lists = new ArrayList<List<Integer>>();
 
-        Observable.concat(Observable.from(1, 2, 3, 4, 5, 6).window(3).map(new Func1<Observable<Integer>, Observable<List<Integer>>>() {
+        Observable.concat(Observable.just(1, 2, 3, 4, 5, 6).window(3).map(new Func1<Observable<Integer>, Observable<List<Integer>>>() {
             @Override
             public Observable<List<Integer>> call(Observable<Integer> xs) {
                 return xs.toList();

File: rxjava-core/src/test/java/rx/StartWithTests.java
Patch:
@@ -26,7 +26,7 @@ public class StartWithTests {
 
     @Test
     public void startWith1() {
-        List<String> values = Observable.from("one", "two").startWith("zero").toList().toBlocking().single();
+        List<String> values = Observable.just("one", "two").startWith("zero").toList().toBlocking().single();
 
         assertEquals("zero", values.get(0));
         assertEquals("two", values.get(2));
@@ -37,7 +37,7 @@ public void startWithIterable() {
         List<String> li = new ArrayList<String>();
         li.add("alpha");
         li.add("beta");
-        List<String> values = Observable.from("one", "two").startWith(li).toList().toBlocking().single();
+        List<String> values = Observable.just("one", "two").startWith(li).toList().toBlocking().single();
 
         assertEquals("alpha", values.get(0));
         assertEquals("beta", values.get(1));
@@ -50,7 +50,7 @@ public void startWithObservable() {
         List<String> li = new ArrayList<String>();
         li.add("alpha");
         li.add("beta");
-        List<String> values = Observable.from("one", "two").startWith(Observable.from(li)).toList().toBlocking().single();
+        List<String> values = Observable.just("one", "two").startWith(Observable.from(li)).toList().toBlocking().single();
 
         assertEquals("alpha", values.get(0));
         assertEquals("beta", values.get(1));

File: rxjava-core/src/test/java/rx/SubscriberTest.java
Patch:
@@ -320,7 +320,7 @@ public void request(long n) {
     @Test
     public void testOnStartCalledOnceViaSubscribe() {
         final AtomicInteger c = new AtomicInteger();
-        Observable.from(1, 2, 3, 4).take(2).subscribe(new Subscriber<Integer>() {
+        Observable.just(1, 2, 3, 4).take(2).subscribe(new Subscriber<Integer>() {
 
             @Override
             public void onStart() {
@@ -352,7 +352,7 @@ public void onNext(Integer t) {
     @Test
     public void testOnStartCalledOnceViaUnsafeSubscribe() {
         final AtomicInteger c = new AtomicInteger();
-        Observable.from(1, 2, 3, 4).take(2).unsafeSubscribe(new Subscriber<Integer>() {
+        Observable.just(1, 2, 3, 4).take(2).unsafeSubscribe(new Subscriber<Integer>() {
 
             @Override
             public void onStart() {
@@ -384,7 +384,7 @@ public void onNext(Integer t) {
     @Test
     public void testOnStartCalledOnceViaLift() {
         final AtomicInteger c = new AtomicInteger();
-        Observable.from(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {
+        Observable.just(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {
 
             @Override
             public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {

File: rxjava-core/src/test/java/rx/ZipTests.java
Patch:
@@ -86,8 +86,8 @@ public void call(Map<String, String> v) {
      */
     @Test
     public void testCovarianceOfZip() {
-        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());
-        Observable<CoolRating> ratings = Observable.from(new CoolRating());
+        Observable<HorrorMovie> horrors = Observable.just(new HorrorMovie());
+        Observable<CoolRating> ratings = Observable.just(new CoolRating());
 
         Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlocking().forEach(action);
         Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlocking().forEach(action);

File: rxjava-core/src/test/java/rx/exceptions/ExceptionsTest.java
Patch:
@@ -29,7 +29,7 @@ public class ExceptionsTest {
 
     @Test(expected = OnErrorNotImplementedException.class)
     public void testOnErrorNotImplementedIsThrown() {
-        Observable.from(1, 2, 3).subscribe(new Action1<Integer>() {
+        Observable.just(1, 2, 3).subscribe(new Action1<Integer>() {
 
             @Override
             public void call(Integer t1) {
@@ -117,7 +117,7 @@ public void onNext(Integer args) {
 
     @Test(expected = ThreadDeath.class)
     public void testThreadDeathIsThrown() {
-        Observable.from(1).subscribe(new Observer<Integer>() {
+        Observable.just(1).subscribe(new Observer<Integer>() {
 
             @Override
             public void onCompleted() {

File: rxjava-core/src/test/java/rx/exceptions/OnNextValueTest.java
Patch:
@@ -80,7 +80,7 @@ public static String stackTraceAsString(Throwable e) {
     public void addOnNextValueExceptionAdded() throws Exception {
         Observer<BadToString> observer = new BadToStringObserver();
 
-        Observable.from(new BadToString(false))
+        Observable.just(new BadToString(false))
                 .map(new Func1<BadToString, BadToString>() {
                     @Override
                     public BadToString call(BadToString badToString) {
@@ -94,7 +94,7 @@ public BadToString call(BadToString badToString) {
     public void addOnNextValueExceptionNotAddedWithBadString() throws Exception {
         Observer<BadToString> observer = new BadToStringObserver();
 
-        Observable.from(new BadToString(true))
+        Observable.just(new BadToString(true))
                 .map(new Func1<BadToString, BadToString>() {
                     @Override
                     public BadToString call(BadToString badToString) {

File: rxjava-core/src/test/java/rx/internal/operators/BlockingOperatorToIteratorTest.java
Patch:
@@ -31,7 +31,7 @@ public class BlockingOperatorToIteratorTest {
 
     @Test
     public void testToIterator() {
-        Observable<String> obs = Observable.from("one", "two", "three");
+        Observable<String> obs = Observable.just("one", "two", "three");
 
         Iterator<String> it = toIterator(obs);
 

File: rxjava-core/src/test/java/rx/internal/operators/OnSubscribeCacheTest.java
Patch:
@@ -96,7 +96,7 @@ public void call(String v) {
     }
 
     private void testWithCustomSubjectAndRepeat(Subject<Integer, Integer> subject, Integer... expected) {
-        Observable<Integer> source0 = Observable.from(1, 2, 3)
+        Observable<Integer> source0 = Observable.just(1, 2, 3)
                 .subscribeOn(Schedulers.io())
                 .flatMap(new Func1<Integer, Observable<Integer>>() {
                     @Override

File: rxjava-core/src/test/java/rx/internal/operators/OnSubscribeDeferTest.java
Patch:
@@ -38,8 +38,8 @@ public void testDefer() throws Throwable {
 
         Func0<Observable<String>> factory = mock(Func0.class);
 
-        Observable<String> firstObservable = Observable.from("one", "two");
-        Observable<String> secondObservable = Observable.from("three", "four");
+        Observable<String> firstObservable = Observable.just("one", "two");
+        Observable<String> secondObservable = Observable.just("three", "four");
         when(factory.call()).thenReturn(firstObservable, secondObservable);
 
         Observable<String> deferred = Observable.defer(factory);

File: rxjava-core/src/test/java/rx/internal/operators/OnSubscribeDelayTest.java
Patch:
@@ -201,7 +201,7 @@ public void testDelayWithMultipleSubscriptions() {
 
     @Test
     public void testDelaySubscription() {
-        Observable<Integer> result = Observable.from(1, 2, 3).delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);
+        Observable<Integer> result = Observable.just(1, 2, 3).delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);
 
         @SuppressWarnings("unchecked")
         Observer<Object> o = mock(Observer.class);
@@ -224,7 +224,7 @@ public void testDelaySubscription() {
 
     @Test
     public void testDelaySubscriptionCancelBeforeTime() {
-        Observable<Integer> result = Observable.from(1, 2, 3).delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);
+        Observable<Integer> result = Observable.just(1, 2, 3).delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);
 
         @SuppressWarnings("unchecked")
         Observer<Object> o = mock(Observer.class);

File: rxjava-core/src/test/java/rx/internal/operators/OperatorAllTest.java
Patch:
@@ -33,7 +33,7 @@ public class OperatorAllTest {
     @Test
     @SuppressWarnings("unchecked")
     public void testAll() {
-        Observable<String> obs = Observable.from("one", "two", "six");
+        Observable<String> obs = Observable.just("one", "two", "six");
 
         Observer<Boolean> observer = mock(Observer.class);
         obs.all(new Func1<String, Boolean>() {
@@ -51,7 +51,7 @@ public Boolean call(String s) {
     @Test
     @SuppressWarnings("unchecked")
     public void testNotAll() {
-        Observable<String> obs = Observable.from("one", "two", "three", "six");
+        Observable<String> obs = Observable.just("one", "two", "three", "six");
 
         Observer<Boolean> observer = mock(Observer.class);
         obs.all(new Func1<String, Boolean>() {

File: rxjava-core/src/test/java/rx/internal/operators/OperatorBufferTest.java
Patch:
@@ -315,7 +315,7 @@ public void call(Subscriber<? super Object> observer) {
     public void testLongTimeAction() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         LongTimeAction action = new LongTimeAction(latch);
-        Observable.from(1).buffer(10, TimeUnit.MILLISECONDS, 10)
+        Observable.just(1).buffer(10, TimeUnit.MILLISECONDS, 10)
                 .subscribe(action);
         latch.await();
         assertFalse(action.fail);
@@ -526,7 +526,7 @@ public void bufferWithBOBoundaryThrows() {
     }
     @Test(timeout = 2000)
     public void bufferWithSizeTake1() {
-        Observable<Integer> source = Observable.from(1).repeat();
+        Observable<Integer> source = Observable.just(1).repeat();
         
         Observable<List<Integer>> result = source.buffer(2).take(1);
         
@@ -542,7 +542,7 @@ public void bufferWithSizeTake1() {
     
     @Test(timeout = 2000)
     public void bufferWithSizeSkipTake1() {
-        Observable<Integer> source = Observable.from(1).repeat();
+        Observable<Integer> source = Observable.just(1).repeat();
         
         Observable<List<Integer>> result = source.buffer(2, 3).take(1);
         

File: rxjava-core/src/test/java/rx/internal/operators/OperatorCastTest.java
Patch:
@@ -29,7 +29,7 @@ public class OperatorCastTest {
 
     @Test
     public void testCast() {
-        Observable<?> source = Observable.from(1, 2);
+        Observable<?> source = Observable.just(1, 2);
         Observable<Integer> observable = source.cast(Integer.class);
 
         @SuppressWarnings("unchecked")
@@ -44,7 +44,7 @@ public void testCast() {
 
     @Test
     public void testCastWithWrongType() {
-        Observable<?> source = Observable.from(1, 2);
+        Observable<?> source = Observable.just(1, 2);
         Observable<Boolean> observable = source.cast(Boolean.class);
 
         @SuppressWarnings("unchecked")

File: rxjava-core/src/test/java/rx/internal/operators/OperatorConcatTest.java
Patch:
@@ -600,7 +600,7 @@ public void call(Subscriber<? super Observable<Integer>> s) {
                     if (s.isUnsubscribed()) {
                         return;
                     }
-                    s.onNext(Observable.from(i));
+                    s.onNext(Observable.just(i));
                 }
                 s.onCompleted();
             }
@@ -632,7 +632,7 @@ public void call(Subscriber<? super Observable<Integer>> s) {
                     if (s.isUnsubscribed()) {
                         return;
                     }
-                    s.onNext(Observable.from(i));
+                    s.onNext(Observable.just(i));
                 }
                 s.onCompleted();
             }

File: rxjava-core/src/test/java/rx/internal/operators/OperatorDefaultIfEmptyTest.java
Patch:
@@ -31,7 +31,7 @@ public class OperatorDefaultIfEmptyTest {
 
     @Test
     public void testDefaultIfEmpty() {
-        Observable<Integer> source = Observable.from(1, 2, 3);
+        Observable<Integer> source = Observable.just(1, 2, 3);
         Observable<Integer> observable = source.defaultIfEmpty(10);
 
         @SuppressWarnings("unchecked")

File: rxjava-core/src/test/java/rx/internal/operators/OperatorDematerializeTest.java
Patch:
@@ -35,7 +35,7 @@ public class OperatorDematerializeTest {
     @Test
     @SuppressWarnings("unchecked")
     public void testDematerialize1() {
-        Observable<Notification<Integer>> notifications = Observable.from(1, 2).materialize();
+        Observable<Notification<Integer>> notifications = Observable.just(1, 2).materialize();
         Observable<Integer> dematerialize = notifications.dematerialize();
 
         Observer<Integer> observer = mock(Observer.class);

File: rxjava-core/src/test/java/rx/internal/operators/OperatorFilterTest.java
Patch:
@@ -36,7 +36,7 @@ public class OperatorFilterTest {
 
     @Test
     public void testFilter() {
-        Observable<String> w = Observable.from("one", "two", "three");
+        Observable<String> w = Observable.just("one", "two", "three");
         Observable<String> observable = w.filter(new Func1<String, Boolean>() {
 
             @Override
@@ -60,7 +60,7 @@ public Boolean call(String t1) {
      */
     @Test(timeout = 500)
     public void testWithBackpressure() throws InterruptedException {
-        Observable<String> w = Observable.from("one", "two", "three");
+        Observable<String> w = Observable.just("one", "two", "three");
         Observable<String> o = w.filter(new Func1<String, Boolean>() {
 
             @Override

File: rxjava-core/src/test/java/rx/internal/operators/OperatorMergeMaxConcurrentTest.java
Patch:
@@ -48,9 +48,9 @@ public void before() {
     public void testWhenMaxConcurrentIsOne() {
         for (int i = 0; i < 100; i++) {
             List<Observable<String>> os = new ArrayList<Observable<String>>();
-            os.add(Observable.from("one", "two", "three", "four", "five").subscribeOn(Schedulers.newThread()));
-            os.add(Observable.from("one", "two", "three", "four", "five").subscribeOn(Schedulers.newThread()));
-            os.add(Observable.from("one", "two", "three", "four", "five").subscribeOn(Schedulers.newThread()));
+            os.add(Observable.just("one", "two", "three", "four", "five").subscribeOn(Schedulers.newThread()));
+            os.add(Observable.just("one", "two", "three", "four", "five").subscribeOn(Schedulers.newThread()));
+            os.add(Observable.just("one", "two", "three", "four", "five").subscribeOn(Schedulers.newThread()));
 
             List<String> expected = Arrays.asList("one", "two", "three", "four", "five", "one", "two", "three", "four", "five", "one", "two", "three", "four", "five");
             Iterator<String> iter = Observable.merge(os, 1).toBlocking().toIterable().iterator();

File: rxjava-core/src/test/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java
Patch:
@@ -38,7 +38,7 @@ public void testResumeNext() {
         // Trigger failure on second element
         TestObservable f = new TestObservable(s, "one", "fail", "two", "three");
         Observable<String> w = Observable.create(f);
-        Observable<String> resume = Observable.from("twoResume", "threeResume");
+        Observable<String> resume = Observable.just("twoResume", "threeResume");
         Observable<String> observable = w.onErrorResumeNext(resume);
 
         @SuppressWarnings("unchecked")
@@ -64,7 +64,7 @@ public void testResumeNext() {
     public void testMapResumeAsyncNext() {
         Subscription sr = mock(Subscription.class);
         // Trigger multiple failures
-        Observable<String> w = Observable.from("one", "fail", "two", "three", "fail");
+        Observable<String> w = Observable.just("one", "fail", "two", "three", "fail");
         // Resume Observable is async
         TestObservable f = new TestObservable(sr, "twoResume", "threeResume");
         Observable<String> resume = Observable.create(f);

File: rxjava-core/src/test/java/rx/internal/operators/OperatorParallelMergeTest.java
Patch:
@@ -39,7 +39,7 @@ public void testParallelMerge() {
         PublishSubject<String> p3 = PublishSubject.<String> create();
         PublishSubject<String> p4 = PublishSubject.<String> create();
 
-        Observable<Observable<String>> fourStreams = Observable.<Observable<String>> from(p1, p2, p3, p4);
+        Observable<Observable<String>> fourStreams = Observable.<Observable<String>> just(p1, p2, p3, p4);
 
         Observable<Observable<String>> twoStreams = Observable.parallelMerge(fourStreams, 2);
         Observable<Observable<String>> threeStreams = Observable.parallelMerge(fourStreams, 3);

File: rxjava-core/src/test/java/rx/internal/operators/OperatorParallelTest.java
Patch:
@@ -93,7 +93,7 @@ public Observable<String> call(Observable<Integer> o) {
 
                             @Override
                             public Observable<String> call(Integer t) {
-                                return Observable.from(String.valueOf(t)).delay(100, TimeUnit.MILLISECONDS);
+                                return Observable.just(String.valueOf(t)).delay(100, TimeUnit.MILLISECONDS);
                             }
 
                         });

File: rxjava-core/src/test/java/rx/internal/operators/OperatorReplayTest.java
Patch:
@@ -422,7 +422,7 @@ public void testWindowedReplayError() {
     @Test
     public void testSynchronousDisconnect() {
         final AtomicInteger effectCounter = new AtomicInteger();
-        Observable<Integer> source = Observable.from(1, 2, 3, 4)
+        Observable<Integer> source = Observable.just(1, 2, 3, 4)
         .doOnNext(new Action1<Integer>() {
             @Override
             public void call(Integer v) {

File: rxjava-core/src/test/java/rx/internal/operators/OperatorScanTest.java
Patch:
@@ -43,7 +43,7 @@ public void testScanIntegersWithInitialValue() {
         @SuppressWarnings("unchecked")
         Observer<String> observer = mock(Observer.class);
 
-        Observable<Integer> observable = Observable.from(1, 2, 3);
+        Observable<Integer> observable = Observable.just(1, 2, 3);
 
         Observable<String> m = observable.scan("", new Func2<String, Integer, String>() {
 
@@ -70,7 +70,7 @@ public void testScanIntegersWithoutInitialValue() {
         @SuppressWarnings("unchecked")
         Observer<Integer> observer = mock(Observer.class);
 
-        Observable<Integer> observable = Observable.from(1, 2, 3);
+        Observable<Integer> observable = Observable.just(1, 2, 3);
 
         Observable<Integer> m = observable.scan(new Func2<Integer, Integer, Integer>() {
 
@@ -97,7 +97,7 @@ public void testScanIntegersWithoutInitialValueAndOnlyOneValue() {
         @SuppressWarnings("unchecked")
         Observer<Integer> observer = mock(Observer.class);
 
-        Observable<Integer> observable = Observable.from(1);
+        Observable<Integer> observable = Observable.just(1);
 
         Observable<Integer> m = observable.scan(new Func2<Integer, Integer, Integer>() {
 

File: rxjava-core/src/test/java/rx/internal/operators/OperatorSkipLastTest.java
Patch:
@@ -77,7 +77,7 @@ public void testSkipLast2() {
 
     @Test
     public void testSkipLastWithZeroCount() {
-        Observable<String> w = Observable.from("one", "two");
+        Observable<String> w = Observable.just("one", "two");
         Observable<String> observable = w.skipLast(0);
 
         @SuppressWarnings("unchecked")
@@ -116,7 +116,7 @@ public void testSkipLastWithBackpressure() {
 
     @Test(expected = IndexOutOfBoundsException.class)
     public void testSkipLastWithNegativeCount() {
-        Observable.from("one").skipLast(-1);
+        Observable.just("one").skipLast(-1);
     }
 
 }

File: rxjava-core/src/test/java/rx/internal/operators/OperatorSubscribeOnTest.java
Patch:
@@ -223,7 +223,7 @@ public void onNext(Integer t) {
     @Test
     public void testSetProducerSynchronousRequest() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
-        Observable.from(1, 2, 3).lift(new Operator<Integer, Integer>() {
+        Observable.just(1, 2, 3).lift(new Operator<Integer, Integer>() {
 
             @Override
             public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {

File: rxjava-core/src/test/java/rx/internal/operators/OperatorTakeLastTimedTest.java
Patch:
@@ -37,7 +37,7 @@ public class OperatorTakeLastTimedTest {
 
     @Test(expected = IndexOutOfBoundsException.class)
     public void testTakeLastTimedWithNegativeCount() {
-        Observable.from("one").takeLast(-1, 1, TimeUnit.SECONDS);
+        Observable.just("one").takeLast(-1, 1, TimeUnit.SECONDS);
     }
 
     @Test

File: rxjava-core/src/test/java/rx/internal/operators/OperatorTakeWhileTest.java
Patch:
@@ -38,7 +38,7 @@ public class OperatorTakeWhileTest {
 
     @Test
     public void testTakeWhile1() {
-        Observable<Integer> w = Observable.from(1, 2, 3);
+        Observable<Integer> w = Observable.just(1, 2, 3);
         Observable<Integer> take = w.takeWhile(new Func1<Integer, Boolean>() {
             @Override
             public Boolean call(Integer input) {
@@ -88,7 +88,7 @@ public Boolean call(Integer input) {
 
     @Test
     public void testTakeWhile2() {
-        Observable<String> w = Observable.from("one", "two", "three");
+        Observable<String> w = Observable.just("one", "two", "three");
         Observable<String> take = w.takeWhileWithIndex(new Func2<String, Integer, Boolean>() {
             @Override
             public Boolean call(String input, Integer index) {

File: rxjava-core/src/test/java/rx/internal/operators/OperatorTimeoutTests.java
Patch:
@@ -135,7 +135,7 @@ public void shouldErrorIfUnderlyingErrors() {
 
     @Test
     public void shouldSwitchToOtherIfOnNextNotWithinTimeout() {
-        Observable<String> other = Observable.from("a", "b", "c");
+        Observable<String> other = Observable.just("a", "b", "c");
         Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
 
         @SuppressWarnings("unchecked")
@@ -158,7 +158,7 @@ public void shouldSwitchToOtherIfOnNextNotWithinTimeout() {
 
     @Test
     public void shouldSwitchToOtherIfOnErrorNotWithinTimeout() {
-        Observable<String> other = Observable.from("a", "b", "c");
+        Observable<String> other = Observable.just("a", "b", "c");
         Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
 
         @SuppressWarnings("unchecked")
@@ -181,7 +181,7 @@ public void shouldSwitchToOtherIfOnErrorNotWithinTimeout() {
 
     @Test
     public void shouldSwitchToOtherIfOnCompletedNotWithinTimeout() {
-        Observable<String> other = Observable.from("a", "b", "c");
+        Observable<String> other = Observable.just("a", "b", "c");
         Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
 
         @SuppressWarnings("unchecked")

File: rxjava-core/src/test/java/rx/internal/operators/OperatorTimeoutWithSelectorTest.java
Patch:
@@ -400,7 +400,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
             @Override
             public void run() {
                 PublishSubject<Integer> source = PublishSubject.create();
-                source.timeout(timeoutFunc, Observable.from(3)).subscribe(ts);
+                source.timeout(timeoutFunc, Observable.just(3)).subscribe(ts);
                 source.onNext(1); // start timeout
                 try {
                     if(!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {

File: rxjava-core/src/test/java/rx/internal/operators/OperatorToObservableSortedListTest.java
Patch:
@@ -36,7 +36,7 @@ public class OperatorToObservableSortedListTest {
 
     @Test
     public void testSortedList() {
-        Observable<Integer> w = Observable.from(1, 3, 2, 5, 4);
+        Observable<Integer> w = Observable.just(1, 3, 2, 5, 4);
         Observable<List<Integer>> observable = w.lift(new OperatorToObservableSortedList<Integer>());
 
         @SuppressWarnings("unchecked")
@@ -49,7 +49,7 @@ public void testSortedList() {
 
     @Test
     public void testSortedListWithCustomFunction() {
-        Observable<Integer> w = Observable.from(1, 3, 2, 5, 4);
+        Observable<Integer> w = Observable.just(1, 3, 2, 5, 4);
         Observable<List<Integer>> observable = w.lift(new OperatorToObservableSortedList<Integer>(new Func2<Integer, Integer, Integer>() {
 
             @Override
@@ -69,7 +69,7 @@ public Integer call(Integer t1, Integer t2) {
 
     @Test
     public void testWithFollowingFirst() {
-        Observable<Integer> o = Observable.from(1, 3, 2, 5, 4);
+        Observable<Integer> o = Observable.just(1, 3, 2, 5, 4);
         assertEquals(Arrays.asList(1, 2, 3, 4, 5), o.toSortedList().toBlocking().first());
     }
 }

File: rxjava-core/src/test/java/rx/internal/operators/OperatorWindowTest.java
Patch:
@@ -74,7 +74,7 @@ public void call(List<T> xs) {
 
     @Test
     public void testNonOverlappingWindows() {
-        Observable<String> subject = Observable.from("one", "two", "three", "four", "five");
+        Observable<String> subject = Observable.just("one", "two", "three", "four", "five");
         Observable<Observable<String>> windowed = subject.window(3);
 
         List<List<String>> windows = toLists(windowed);
@@ -86,7 +86,7 @@ public void testNonOverlappingWindows() {
 
     @Test
     public void testSkipAndCountGaplessWindows() {
-        Observable<String> subject = Observable.from("one", "two", "three", "four", "five");
+        Observable<String> subject = Observable.just("one", "two", "three", "four", "five");
         Observable<Observable<String>> windowed = subject.window(3, 3);
 
         List<List<String>> windows = toLists(windowed);
@@ -114,7 +114,7 @@ public void testOverlappingWindows() {
 
     @Test
     public void testSkipAndCountWindowsWithGaps() {
-        Observable<String> subject = Observable.from("one", "two", "three", "four", "five");
+        Observable<String> subject = Observable.just("one", "two", "three", "four", "five");
         Observable<Observable<String>> windowed = subject.window(2, 3);
 
         List<List<String>> windows = toLists(windowed);

File: rxjava-core/src/test/java/rx/internal/operators/OperatorZipIterableTest.java
Patch:
@@ -369,7 +369,7 @@ public String call(Integer t1) {
     }
 
     @Test public void testTake2() {
-        Observable<Integer> o = Observable.from(1, 2, 3, 4, 5);
+        Observable<Integer> o = Observable.just(1, 2, 3, 4, 5);
         Iterable<String> it = Arrays.asList("a", "b", "c", "d", "e");
         
         SquareStr squareStr = new SquareStr();

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java
Patch:
@@ -346,7 +346,7 @@ public final void testSubscribeWithScheduler() throws InterruptedException {
 
         final AtomicInteger count = new AtomicInteger();
 
-        Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
+        Observable<Integer> o1 = Observable.<Integer> just(1, 2, 3, 4, 5);
 
         o1.subscribe(new Action1<Integer>() {
 

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -385,7 +385,7 @@ public void run() {
     public final void testObserveOn() throws InterruptedException {
         final Scheduler scheduler = getScheduler();
 
-        Observable<String> o = Observable.from("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten");
+        Observable<String> o = Observable.just("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten");
 
         ConcurrentObserverValidator<String> observer = new ConcurrentObserverValidator<String>();
 
@@ -405,7 +405,7 @@ public final void testObserveOn() throws InterruptedException {
     public final void testSubscribeOnNestedConcurrency() throws InterruptedException {
         final Scheduler scheduler = getScheduler();
 
-        Observable<String> o = Observable.from("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten")
+        Observable<String> o = Observable.just("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten")
                 .mergeMap(new Func1<String, Observable<String>>() {
 
                     @Override

File: rxjava-core/src/test/java/rx/schedulers/CachedThreadSchedulerTest.java
Patch:
@@ -37,8 +37,8 @@ protected Scheduler getScheduler() {
     @Test
     public final void testIOScheduler() {
 
-        Observable<Integer> o1 = Observable.from(1, 2, 3, 4, 5);
-        Observable<Integer> o2 = Observable.from(6, 7, 8, 9, 10);
+        Observable<Integer> o1 = Observable.just(1, 2, 3, 4, 5);
+        Observable<Integer> o2 = Observable.just(6, 7, 8, 9, 10);
         Observable<String> o = Observable.merge(o1, o2).map(new Func1<Integer, String>() {
 
             @Override

File: rxjava-core/src/test/java/rx/schedulers/TrampolineSchedulerTest.java
Patch:
@@ -42,8 +42,8 @@ public final void testMergeWithCurrentThreadScheduler1() {
 
         final String currentThreadName = Thread.currentThread().getName();
 
-        Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
-        Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
+        Observable<Integer> o1 = Observable.<Integer> just(1, 2, 3, 4, 5);
+        Observable<Integer> o2 = Observable.<Integer> just(6, 7, 8, 9, 10);
         Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.trampoline()).map(new Func1<Integer, String>() {
 
             @Override

File: rxjava-core/src/test/java/rx/subjects/BehaviorSubjectTest.java
Patch:
@@ -262,7 +262,7 @@ public void testUnsubscriptionCase() {
 
                     @Override
                     public Observable<String> call(String t1) {
-                        return Observable.from(t1 + ", " + t1);
+                        return Observable.just(t1 + ", " + t1);
                     }
                 })
                 .subscribe(new Observer<String>() {

File: rxjava-core/src/test/java/rx/subjects/PublishSubjectTest.java
Patch:
@@ -320,7 +320,7 @@ public void testUnsubscriptionCase() {
 
                     @Override
                     public Observable<String> call(String t1) {
-                        return Observable.from(t1 + ", " + t1);
+                        return Observable.just(t1 + ", " + t1);
                     }
                 })
                 .subscribe(new Observer<String>() {

File: rxjava-core/src/test/java/rx/subjects/ReplaySubjectTest.java
Patch:
@@ -381,7 +381,7 @@ public void testUnsubscriptionCase() {
 
                     @Override
                     public Observable<String> call(String t1) {
-                        return Observable.from(t1 + ", " + t1);
+                        return Observable.just(t1 + ", " + t1);
                     }
                 })
                 .subscribe(new Observer<String>() {

File: rxjava-core/src/test/java/rx/util/AssertObservableTest.java
Patch:
@@ -23,7 +23,7 @@ public class AssertObservableTest {
 
     @Test
     public void testPassNotNull() {
-        AssertObservable.assertObservableEqualsBlocking("foo", Observable.from(1, 2), Observable.from(1, 2));
+        AssertObservable.assertObservableEqualsBlocking("foo", Observable.just(1, 2), Observable.just(1, 2));
     }
 
     @Test
@@ -33,11 +33,11 @@ public void testPassNull() {
 
     @Test(expected = AssertionError.class)
     public void testFailNotNull() {
-        AssertObservable.assertObservableEqualsBlocking("foo", Observable.from(1, 2), Observable.from(1));
+        AssertObservable.assertObservableEqualsBlocking("foo", Observable.just(1, 2), Observable.just(1));
     }
 
     @Test(expected = AssertionError.class)
     public void testFailNull() {
-        AssertObservable.assertObservableEqualsBlocking("foo", Observable.from(1, 2), null);
+        AssertObservable.assertObservableEqualsBlocking("foo", Observable.just(1, 2), null);
     }
 }

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -204,7 +204,7 @@ public void call(Subscriber<? super R> o) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>
      * @since 0.20
      */
-    public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> transformer) {
+    public <R> Observable<R> compose(Transformer<? super T, R> transformer) {
         return transformer.call(this);
     }
     
@@ -213,7 +213,7 @@ public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> t
      * @warn more complete description needed
      * @since 0.20
      */
-    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {
+    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<R>> {
         // cover for generics insanity
     }
     

File: rxjava-core/src/test/java/rx/ObservableTests.java
Patch:
@@ -1108,7 +1108,7 @@ public void testCompose() {
         Observable.from(1, 2, 3).compose(new Transformer<Integer, String>() {
 
             @Override
-            public Observable<? extends String> call(Observable<? extends Integer> t1) {
+            public Observable<String> call(Observable<? extends Integer> t1) {
                 return t1.map(new Func1<Integer, String>() {
                     
                     @Override

File: rxjava-core/src/test/java/rx/ObservableTests.java
Patch:
@@ -1108,7 +1108,7 @@ public void testCompose() {
         Observable.from(1, 2, 3).compose(new Transformer<Integer, String>() {
 
             @Override
-            public Observable<? extends String> call(Observable<? extends Integer> t1) {
+            public Observable<String> call(Observable<? extends Integer> t1) {
                 return t1.map(new Func1<Integer, String>() {
                     
                     @Override

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -204,7 +204,7 @@ public void call(Subscriber<? super R> o) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>
      * @since 0.20
      */
-    public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> transformer) {
+    public <R> Observable<R> compose(Transformer<? super T, R> transformer) {
         return transformer.call(this);
     }
     
@@ -213,7 +213,7 @@ public <R> Observable<? extends R> compose(Transformer<? super T, ? extends R> t
      * @warn more complete description needed
      * @since 0.20
      */
-    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<? extends R>> {
+    public static interface Transformer<T, R> extends Func1<Observable<? extends T>, Observable<R>> {
         // cover for generics insanity
     }
     

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -1027,7 +1027,7 @@ public final static <T> Observable<T> concat(Observable<? extends T> t1, Observa
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#defer">RxJava wiki: defer</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229160.aspx">MSDN: Observable.Defer</a>
      */
-    public final static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {
+    public final static <T> Observable<T> defer(Func0<Observable<T>> observableFactory) {
         return create(new OnSubscribeDefer<T>(observableFactory));
     }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -1027,7 +1027,7 @@ public final static <T> Observable<T> concat(Observable<? extends T> t1, Observa
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#defer">RxJava wiki: defer</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229160.aspx">MSDN: Observable.Defer</a>
      */
-    public final static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {
+    public final static <T> Observable<T> defer(Func0<Observable<T>> observableFactory) {
         return create(new OnSubscribeDefer<T>(observableFactory));
     }
 

File: rxjava-core/src/main/java/rx/plugins/RxJavaDefaultSchedulers.java
Patch:
@@ -23,6 +23,7 @@
  * See {@link RxJavaPlugins} or the RxJava GitHub Wiki for information on configuring plugins:
  * <a href="https://github.com/Netflix/RxJava/wiki/Plugins">https://github.com/Netflix/RxJava/wiki/Plugins</a>.
  */
+@Deprecated
 public abstract class RxJavaDefaultSchedulers {
 
     /**

File: rxjava-core/src/main/java/rx/plugins/RxJavaDefaultSchedulersDefault.java
Patch:
@@ -22,6 +22,7 @@
  * 
  * @ExcludeFromJavadoc
  */
+@Deprecated
 public class RxJavaDefaultSchedulersDefault extends RxJavaDefaultSchedulers {
 
     private static RxJavaDefaultSchedulersDefault INSTANCE = new RxJavaDefaultSchedulersDefault();

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java
Patch:
@@ -60,6 +60,9 @@ public void onNext(T value) {
                 } else {
                     this.value = value;
                     isNonEmpty = true;
+                    // Issue: https://github.com/Netflix/RxJava/pull/1527
+                    // Because we cache a value and don't emit now, we need to request another one.
+                    request(1);
                 }
             }
 

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorBroadcastRegister.java
Patch:
@@ -24,8 +24,8 @@
 import rx.Observable;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.android.subscriptions.AndroidSubscriptions;
 import rx.functions.Action0;
+import rx.subscriptions.Subscriptions;
 
 public class OperatorBroadcastRegister implements Observable.OnSubscribe<Intent> {
 
@@ -50,7 +50,7 @@ public void onReceive(Context context, Intent intent) {
             }
         };
 
-        final Subscription subscription = AndroidSubscriptions.unsubscribeInUiThread(new Action0() {
+        final Subscription subscription = Subscriptions.create(new Action0() {
             @Override
             public void call() {
                 context.unregisterReceiver(broadcastReceiver);

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorLocalBroadcastRegister.java
Patch:
@@ -26,6 +26,7 @@
 import rx.Subscription;
 import rx.android.subscriptions.AndroidSubscriptions;
 import rx.functions.Action0;
+import rx.subscriptions.Subscriptions;
 
 public class OperatorLocalBroadcastRegister implements Observable.OnSubscribe<Intent> {
 
@@ -47,7 +48,7 @@ public void onReceive(Context context, Intent intent) {
             }
         };
 
-        final Subscription subscription = AndroidSubscriptions.unsubscribeInUiThread(new Action0() {
+        final Subscription subscription = Subscriptions.create(new Action0() {
             @Override
             public void call() {
                 localBroadcastManager.unregisterReceiver(broadcastReceiver);

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorLocalBroadcastRegisterTest.java
Patch:
@@ -42,7 +42,6 @@
 public class OperatorLocalBroadcastRegisterTest {
 
     @Test
-    @SuppressWarnings("unchecked")
     public void testLocalBroadcast() {
         String action = "TEST_ACTION";
         IntentFilter intentFilter = new IntentFilter(action);
@@ -64,6 +63,7 @@ public void testLocalBroadcast() {
         inOrder.verify(observer, times(1)).onNext(intent);
 
         subscription.unsubscribe();
+        localBroadcastManager.sendBroadcast(intent);
         inOrder.verify(observer, never()).onNext(any(Intent.class));
 
         inOrder.verify(observer, never()).onError(any(Throwable.class));

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java
Patch:
@@ -55,7 +55,7 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
-                // ignore
+                notifications.offer(Notification.<T>createOnError(e));
             }
 
             @Override

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java
Patch:
@@ -55,7 +55,7 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
-                // ignore
+                notifications.offer(Notification.<T>createOnError(e));
             }
 
             @Override

File: rxjava-core/src/main/java/rx/exceptions/CompositeException.java
Patch:
@@ -45,7 +45,7 @@ public CompositeException(String messagePrefix, Collection<Throwable> errors) {
             _exceptions.add(e);
         }
         this.exceptions = Collections.unmodifiableList(_exceptions);
-        this.message = count + " exceptions occurred. See them in causal chain below.";
+        this.message = messagePrefix + " " + count + " exceptions occurred. See them in causal chain below.";
         this.cause = _cause;
     }
 

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -66,7 +66,7 @@ public <T> OnSubscribe<T> onCreate(OnSubscribe<T> f) {
      * @return {@link OnSubscribe}<{@code T}> function that can be modified, decorated, replaced or just
      *         returned as a pass-thru
      */
-    public <T> OnSubscribe<T> onSubscribeStart(Observable<? extends T> observableInsance, final OnSubscribe<T> onSubscribe) {
+    public <T> OnSubscribe<T> onSubscribeStart(Observable<? extends T> observableInstance, final OnSubscribe<T> onSubscribe) {
         // pass-thru by default
         return onSubscribe;
     }

File: rxjava-core/src/test/java/rx/internal/operators/OperatorRetryTest.java
Patch:
@@ -100,6 +100,7 @@ public Observable<Long> call(Tuple t) {
             }
         }).subscribe(ts);
         ts.awaitTerminalEvent();
+        ts.assertNoErrors();
 
         InOrder inOrder = inOrder(consumer);
         inOrder.verify(consumer, never()).onError(any(Throwable.class));

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java
Patch:
@@ -90,6 +90,7 @@ public T next() {
 
             private Notification<? extends T> take() {
                 try {
+                    // TODO remove this timeout and logging before final release of 0.20
                     Notification<? extends T> n = notifications.poll(10000, TimeUnit.MILLISECONDS);
                     if(n == null) {
                         System.err.println("Timed out waiting for value. File a bug at github.com/Netflix/RxJava");

File: rxjava-core/src/main/java/rx/internal/operators/OperatorDistinct.java
Patch:
@@ -44,6 +44,8 @@ public void onNext(T t) {
                 U key = keySelector.call(t);
                 if (keyMemory.add(key)) {
                     child.onNext(t);
+                } else {
+                    request(1);
                 }
             }
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorDistinctUntilChanged.java
Patch:
@@ -45,6 +45,8 @@ public void onNext(T t) {
                 if (hasPrevious) {
                     if (!(currentKey == key || (key != null && key.equals(currentKey)))) {
                         child.onNext(t);
+                    } else {
+                        request(1);
                     }
                 } else {
                     hasPrevious = true;

File: rxjava-core/src/main/java/rx/internal/operators/OperatorElementAt.java
Patch:
@@ -55,6 +55,8 @@ public void onNext(T value) {
                 if (currentIndex == index) {
                     subscriber.onNext(value);
                     subscriber.onCompleted();
+                } else {
+                    request(1);
                 }
                 currentIndex++;
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkipLast.java
Patch:
@@ -67,6 +67,8 @@ public void onNext(T value) {
                 }
                 if (deque.size() == count) {
                     subscriber.onNext(on.getValue(deque.removeFirst()));
+                } else {
+                    request(1);
                 }
                 deque.offerLast(on.next(value));
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkipUntil.java
Patch:
@@ -71,6 +71,8 @@ public void onCompleted() {
             public void onNext(T t) {
                 if (gate.get()) {
                     s.onNext(t);
+                } else {
+                    request(1);
                 }
             }
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkipWhile.java
Patch:
@@ -43,6 +43,8 @@ public void onNext(T t) {
                     if (!predicate.call(t, index++)) {
                         skipping = false;
                         child.onNext(t);
+                    } else {
+                        request(1);
                     }
                 }
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorDistinct.java
Patch:
@@ -44,6 +44,8 @@ public void onNext(T t) {
                 U key = keySelector.call(t);
                 if (keyMemory.add(key)) {
                     child.onNext(t);
+                } else {
+                    request(1);
                 }
             }
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorDistinctUntilChanged.java
Patch:
@@ -45,6 +45,8 @@ public void onNext(T t) {
                 if (hasPrevious) {
                     if (!(currentKey == key || (key != null && key.equals(currentKey)))) {
                         child.onNext(t);
+                    } else {
+                        request(1);
                     }
                 } else {
                     hasPrevious = true;

File: rxjava-core/src/main/java/rx/internal/operators/OperatorElementAt.java
Patch:
@@ -55,6 +55,8 @@ public void onNext(T value) {
                 if (currentIndex == index) {
                     subscriber.onNext(value);
                     subscriber.onCompleted();
+                } else {
+                    request(1);
                 }
                 currentIndex++;
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkipLast.java
Patch:
@@ -67,6 +67,8 @@ public void onNext(T value) {
                 }
                 if (deque.size() == count) {
                     subscriber.onNext(on.getValue(deque.removeFirst()));
+                } else {
+                    request(1);
                 }
                 deque.offerLast(on.next(value));
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkipUntil.java
Patch:
@@ -71,6 +71,8 @@ public void onCompleted() {
             public void onNext(T t) {
                 if (gate.get()) {
                     s.onNext(t);
+                } else {
+                    request(1);
                 }
             }
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkipWhile.java
Patch:
@@ -43,6 +43,8 @@ public void onNext(T t) {
                     if (!predicate.call(t, index++)) {
                         skipping = false;
                         child.onNext(t);
+                    } else {
+                        request(1);
                     }
                 }
             }

File: rxjava-core/src/main/java/rx/observers/SerializedObserver.java
Patch:
@@ -107,7 +107,6 @@ public void onError(final Throwable e) {
             if (terminated) {
                 return;
             }
-            terminated = true;
             if (emitting) {
                 if (queue == null) {
                     queue = new FastList();
@@ -121,6 +120,9 @@ public void onError(final Throwable e) {
         }
         drainQueue(list);
         actual.onError(e);
+        synchronized(this) {
+            emitting = false;
+        }
     }
 
     @Override

File: rxjava-core/src/main/java/rx/observers/SerializedObserver.java
Patch:
@@ -107,7 +107,6 @@ public void onError(final Throwable e) {
             if (terminated) {
                 return;
             }
-            terminated = true;
             if (emitting) {
                 if (queue == null) {
                     queue = new FastList();
@@ -121,6 +120,9 @@ public void onError(final Throwable e) {
         }
         drainQueue(list);
         actual.onError(e);
+        synchronized(this) {
+            emitting = false;
+        }
     }
 
     @Override

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
Patch:
@@ -70,7 +70,9 @@ public void request(long n) {
                     }
                     o.onNext(it.next());
                 }
-                o.onCompleted();
+                if (!o.isUnsubscribed()) {
+                    o.onCompleted();
+                }
             } else if(n > 0) {
                 // backpressure is requested
                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java
Patch:
@@ -64,7 +64,9 @@ public void request(long n) {
                     }
                     o.onNext((int) i);
                 }
-                o.onCompleted();
+                if (!o.isUnsubscribed()) {
+                    o.onCompleted();
+                }
             } else if (n > 0) {
                 // backpressure is requested
                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
Patch:
@@ -70,7 +70,9 @@ public void request(long n) {
                     }
                     o.onNext(it.next());
                 }
-                o.onCompleted();
+                if (!o.isUnsubscribed()) {
+                    o.onCompleted();
+                }
             } else if(n > 0) {
                 // backpressure is requested
                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java
Patch:
@@ -64,7 +64,9 @@ public void request(long n) {
                     }
                     o.onNext((int) i);
                 }
-                o.onCompleted();
+                if (!o.isUnsubscribed()) {
+                    o.onCompleted();
+                }
             } else if (n > 0) {
                 // backpressure is requested
                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);

File: rxjava-core/src/main/java/rx/internal/operators/OperatorDoOnEach.java
Patch:
@@ -47,24 +47,24 @@ public void onCompleted() {
                     onError(e);
                     return;
                 }
-                observer.onCompleted();
                 // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer
                 done = true;
+                observer.onCompleted();
             }
 
             @Override
             public void onError(Throwable e) {
                 if (done) {
                     return;
                 }
+                done = true;
                 try {
                     doOnEachObserver.onError(e);
                 } catch (Throwable e2) {
                     observer.onError(e2);
                     return;
                 }
                 observer.onError(e);
-                done = true;
             }
 
             @Override

File: rxjava-core/src/main/java/rx/Subscriber.java
Patch:
@@ -126,9 +126,9 @@ public final void setProducer(Producer producer) {
         if (setProducer) {
             op.setProducer(p);
         } else {
-            // we execute the request with whatever has been requested (or -1)
+            // we execute the request with whatever has been requested (or Long.MAX_VALUE)
             if (toRequest == Long.MIN_VALUE) {
-                p.request(-1);
+                p.request(Long.MAX_VALUE);
             } else {
                 p.request(toRequest);
             }

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
Patch:
@@ -62,7 +62,7 @@ private IterableProducer(Subscriber<? super T> o, Iterator<? extends T> it) {
 
         @Override
         public void request(long n) {
-            if (n < 0) {
+            if (n == Long.MAX_VALUE) {
                 // fast-path without backpressure
                 while (it.hasNext()) {
                     if (o.isUnsubscribed()) {
@@ -71,7 +71,7 @@ public void request(long n) {
                     o.onNext(it.next());
                 }
                 o.onCompleted();
-            } else {
+            } else if(n > 0) {
                 // backpressure is requested
                 long _c = REQUESTED_UPDATER.getAndAdd(this, n);
                 if (_c == 0) {

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeRange.java
Patch:
@@ -56,7 +56,7 @@ private RangeProducer(Subscriber<? super Integer> o, int start, int end) {
 
         @Override
         public void request(long n) {
-            if (n < 0) {
+            if (n == Long.MAX_VALUE) {
                 // fast-path without backpressure
                 for (long i = index; i <= end; i++) {
                     if (o.isUnsubscribed()) {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -391,8 +391,8 @@ public MergeProducer(MergeSubscriber<T> ms) {
 
         @Override
         public void request(long n) {
-            if (n < 0) {
-                requested = -1;
+            if (n == Long.MAX_VALUE) {
+                requested = Long.MAX_VALUE;
             } else {
                 REQUESTED.getAndAdd(this, n);
                 ms.drainQueuesIfNeeded();

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java
Patch:
@@ -52,7 +52,7 @@ public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {
             @Override
             public void onStart() {
                 // we do this to break the chain of the child subscriber being passed through
-                request(-1);
+                request(Long.MAX_VALUE);
             }
 
             @Override
@@ -109,8 +109,8 @@ void startEmitting() {
         @Override
         public void request(long n) {
             long _c = 0;
-            if (n < 0) {
-                requested = -1;
+            if (n == Long.MAX_VALUE) {
+                requested = Long.MAX_VALUE;
             } else {
                 _c = REQUESTED_UPDATER.getAndAdd(this, n);
             }

File: rxjava-core/src/test/java/rx/SubscriberTest.java
Patch:
@@ -64,7 +64,7 @@ public void request(long n) {
             }
 
         });
-        assertEquals(-1, r.get());
+        assertEquals(Long.MAX_VALUE, r.get());
     }
 
     @Test
@@ -154,8 +154,8 @@ public void request(long n) {
             }
 
         });
-        // this will be -1 because it is decoupled and nothing requsted on the Operator subscriber
-        assertEquals(-1, r.get());
+        // this will be Long.MAX_VALUE because it is decoupled and nothing requsted on the Operator subscriber
+        assertEquals(Long.MAX_VALUE, r.get());
     }
 
     @Test

File: rxjava-core/src/test/java/rx/internal/operators/OnSubscribeFromIterableTest.java
Patch:
@@ -143,7 +143,7 @@ public void testNoBackpressure() {
         OnSubscribeFromIterable<Integer> o = new OnSubscribeFromIterable<Integer>(Arrays.asList(1, 2, 3, 4, 5));
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
         ts.assertReceivedOnNext(Collections.<Integer> emptyList());
-        ts.request(-1); // infinite
+        ts.request(Long.MAX_VALUE); // infinite
         o.call(ts);
         ts.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5));
         ts.assertTerminalEvent();

File: rxjava-core/src/test/java/rx/internal/operators/OnSubscribeRangeTest.java
Patch:
@@ -126,7 +126,7 @@ public void testNoBackpressure() {
         OnSubscribeRange o = new OnSubscribeRange(1, list.size());
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
         ts.assertReceivedOnNext(Collections.<Integer> emptyList());
-        ts.request(-1); // infinite
+        ts.request(Long.MAX_VALUE); // infinite
         o.call(ts);
         ts.assertReceivedOnNext(list);
         ts.assertTerminalEvent();

File: rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java
Patch:
@@ -86,6 +86,7 @@ public void unsubscribe() {
         }
         // we will only get here once
         unsubscribeFromAll(subscriptions);
+        subscriptions = null;
     }
 
     private static void unsubscribeFromAll(Collection<Subscription> subscriptions) {

File: rxjava-core/src/main/java/rx/internal/util/SubscriptionList.java
Patch:
@@ -86,6 +86,7 @@ public void unsubscribe() {
         }
         // we will only get here once
         unsubscribeFromAll(subscriptions);
+        subscriptions = null;
     }
 
     private static void unsubscribeFromAll(Collection<Subscription> subscriptions) {

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java
Patch:
@@ -25,7 +25,7 @@
  * Returns an Iterable that always returns the item most recently emitted by an Observable, or a
  * seed value if no item has yet been emitted.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.mostRecent.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.mostRecent.png" alt="">
  */
 public final class BlockingOperatorMostRecent {
 

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorNext.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * Returns an Iterable that blocks until the Observable emits another item, then returns that item.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.next.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.next.png" alt="">
  */
 public final class BlockingOperatorNext {
 

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java
Patch:
@@ -30,7 +30,7 @@
 /**
  * Returns a Future representing the single value emitted by an Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.toFuture.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.toFuture.png" alt="">
  * <p>
  * The toFuture operation throws an exception if the Observable emits more than one item. If the
  * Observable may emit more than item, use <code>toList().toFuture()</code>.

File: rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorToIterator.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Returns an Iterator that iterates over all items emitted by a specified Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.toIterator.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.toIterator.png" alt="">
  * <p>
  * 
  * @see <a href="https://github.com/Netflix/RxJava/issues/50">Issue #50</a>

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCache.java
Patch:
@@ -28,12 +28,12 @@
  * This method has similar behavior to {@link Observable#replay()} except that this auto-subscribes
  * to the source Observable rather than returning a connectable Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/cache.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/cache.png" alt="">
  * <p>
  * This is useful with an Observable that you want to cache responses when you can't control the
  * subscribe/unsubscribe behavior of all the Observers.
  * <p>
- * NOTE: You sacrifice the ability to unsubscribe from the origin when you use this operator, so be
+ * <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use this operator, so be
  * careful not to use this operator on Observables that emit infinite or very large numbers of
  * items, as this will use up memory.
  * 
@@ -69,4 +69,4 @@ public void call(Subscriber<? super T> s) {
         }
         cache.unsafeSubscribe(s);
     }
-}
\ No newline at end of file
+}

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java
Patch:
@@ -32,7 +32,7 @@
  * the source Observables emits an item, by combining the latest emissions from each source
  * Observable with a specified function.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/combineLatest.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/combineLatest.png" alt="">
  * 
  * @param <T> the common basetype of the source values
  * @param <R> the result type of the combinator function

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeDefer.java
Patch:
@@ -24,7 +24,7 @@
  * Do not create the Observable until an Observer subscribes; create a fresh Observable on each
  * subscription.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/defer.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/defer.png" alt="">
  * <p>
  * Pass defer an Observable factory function (a function that generates Observables), and defer will
  * return an Observable that will call this function to generate its Observable sequence afresh

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Converts an {@code Iterable} sequence into an {@code Observable}.
  * <p>
- * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/toObservable.png" />
+ * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/toObservable.png" alt="" />
  * <p>
  * You can convert any object that supports the Iterable interface into an Observable that emits each item in
  * the object, with the {@code toObservable} operation.

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Converts a {@code Future} into an {@code Observable}.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/from.Future.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/from.Future.png" alt="">
  * <p>
  * You can convert any object that supports the {@code Future} interface into an {@code Observable} that emits
  * the return value of the {@code get} method of that object, by using this operator.

File: rxjava-core/src/main/java/rx/internal/operators/OperatorAll.java
Patch:
@@ -23,7 +23,7 @@
  * Returns an Observable that emits a Boolean that indicates whether all items emitted by an
  * Observable satisfy a condition.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/all.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/all.png" alt="">
  */
 public final class OperatorAll<T> implements Operator<Boolean, T> {
     private final Func1<? super T, Boolean> predicate;

File: rxjava-core/src/main/java/rx/internal/operators/OperatorConcat.java
Patch:
@@ -26,10 +26,10 @@
 import rx.subscriptions.Subscriptions;
 
 /**
- * Returns an Observable that emits the items emitted by two or more Observables, one after the
- * other.
+ * Returns an Observable that emits the items emitted by two or more Observables, one after the other.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/concat.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/concat.png" alt="">
+ *
  * @param <T> the source and result value type
  */
 public final class OperatorConcat<T> implements Operator<T, Observable<? extends T>> {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorDematerialize.java
Patch:
@@ -23,10 +23,9 @@
  * Reverses the effect of {@link OperatorMaterialize} by transforming the Notification objects
  * emitted by a source Observable into the items or notifications they represent.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/dematerialize.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/dematerialize.png" alt="">
  * <p>
- * See <a href="http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx">here</a> for the
- * Microsoft Rx equivalent.
+ * See <a href="http://msdn.microsoft.com/en-us/library/hh229047.aspx">here</a> for the Microsoft Rx equivalent.
  * 
  * @param <T> the wrapped value type
  */

File: rxjava-core/src/main/java/rx/internal/operators/OperatorFilter.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Filters an Observable by discarding any items it emits that do not meet some test.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/filter.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/filter.png" alt="">
  */
 public final class OperatorFilter<T> implements Operator<T, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -32,7 +32,7 @@
  * Groups the items emitted by an Observable according to a specified criterion, and emits these
  * grouped items as Observables, one Observable per group.
  * <p>
- * <img width="640" height="360" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png">
+ * <img width="640" height="360" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png" alt="">
  *
  * @param <K> the key type
  * @param <T> the source and group value type

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMap.java
Patch:
@@ -24,7 +24,7 @@
  * Applies a function of your choosing to every item emitted by an {@code Observable}, and emits the results of
  * this transformation as a new {@code Observable}.
  * <p>
- * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/map.png">
+ * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/map.png" alt="">
  */
 public final class OperatorMap<T, R> implements Operator<R, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -31,9 +31,10 @@
 /**
  * Flattens a list of {@link Observable}s into one {@code Observable}, without any transformation.
  * <p>
- * <img width="640" height="380" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
+ * <img width="640" height="380" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/merge.png" alt="">
  * <p>
- * You can combine the items emitted by multiple {@code Observable}s so that they act like a single {@code Observable}, by using the merge operation.
+ * You can combine the items emitted by multiple {@code Observable}s so that they act like a single
+ * {@code Observable}, by using the merge operation.
  * 
  * @param <T>
  *            the type of the items emitted by both the source and merged {@code Observable}s

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMergeMaxConcurrent.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Flattens a list of Observables into one Observable sequence, without any transformation.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/merge.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/merge.png" alt="">
  * <p>
  * You can combine the items emitted by multiple Observables so that they act like a single
  * Observable, by using the merge operation.

File: rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java
Patch:
@@ -31,9 +31,9 @@
 import rx.schedulers.TrampolineScheduler;
 
 /**
- * Delivers events on the specified Scheduler asynchronously via an unbounded buffer.
+ * Delivers events on the specified {@code Scheduler} asynchronously via an unbounded buffer.
  * 
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/observeOn.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/observeOn.png" alt="">
  * 
  * @param <T>
  *            the transmitted value type
@@ -228,4 +228,4 @@ public void call() {
         }
 
     }
-}
\ No newline at end of file
+}

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorReturn.java
Patch:
@@ -26,7 +26,7 @@
  * Instruct an Observable to emit a particular item to its Observer's <code>onNext</code> method
  * rather than invoking <code>onError</code> if it encounters an error.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/onErrorReturn.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/onErrorReturn.png" alt="">
  * <p>
  * By default, when an Observable encounters an error that prevents it from emitting the expected
  * item to its Observer, the Observable invokes its Observer's <code>onError</code> method, and then

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnExceptionResumeNextViaObservable.java
Patch:
@@ -27,7 +27,7 @@
  * This differs from {@link Observable#onErrorResumeNext} in that this one does not handle 
  * {@link java.lang.Throwable} or {@link java.lang.Error} but lets those continue through.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/onErrorResumeNext.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/onErrorResumeNext.png" alt="">
  * <p>
  * By default, when an Observable encounters an error that prevents it from emitting the expected
  * item to its Observer, the Observable invokes its Observer's <code>onError</code> method, and

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSampleWithTime.java
Patch:
@@ -28,7 +28,7 @@
  * Returns an Observable that emits the results of sampling the items emitted by the source
  * Observable at a specified time interval.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/sample.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/sample.png" alt="">
  * 
  * @param <T> the value type
  */

File: rxjava-core/src/main/java/rx/internal/operators/OperatorScan.java
Patch:
@@ -26,11 +26,11 @@
  * so on until all items have been emitted by the source Observable, emitting the result of each of these
  * iterations.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/scan.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/scan.png" alt="">
  * <p>
  * This sort of function is sometimes called an accumulator.
  * <p>
- * Note that when you pass a seed to <code>scan()</code> the resulting Observable will emit that seed as its
+ * Note that when you pass a seed to {@code scan} the resulting Observable will emit that seed as its
  * first emitted item.
  */
 public final class OperatorScan<R, T> implements Operator<R, T> {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSkip.java
Patch:
@@ -23,10 +23,10 @@
  * Returns an Observable that skips the first <code>num</code> items emitted by the source
  * Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/skip.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/skip.png" alt="">
  * <p>
  * You can ignore the first <code>num</code> items emitted by an Observable and attend only to
- * those items that come after, by modifying the Observable with the skip operation.
+ * those items that come after, by modifying the Observable with the {@code skip} operator.
  */
 public final class OperatorSkip<T> implements Observable.Operator<T, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSubscribeOn.java
Patch:
@@ -24,9 +24,9 @@
 import rx.functions.Action0;
 
 /**
- * Subscribes Observers on the specified Scheduler.
+ * Subscribes Observers on the specified {@code Scheduler}.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/subscribeOn.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/subscribeOn.png" alt="">
  */
 public class OperatorSubscribeOn<T> implements Operator<T, Observable<T>> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSwitch.java
Patch:
@@ -27,8 +27,7 @@
  * Transforms an Observable that emits Observables into a single Observable that
  * emits the items emitted by the most recently published of those Observables.
  * <p>
- * <img width="640" src=
- * "https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png" alt="">
  * 
  * @param <T> the value type
  */

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTake.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * An {@code Observable} that emits the first {@code num} items emitted by the source {@code Observable}.
  * <p>
- * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/take.png" />
+ * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/take.png" alt="" />
  * <p>
  * You can choose to pay attention only to the first {@code num} items emitted by an {@code Observable} by using
  * the {@code take} operator. This operator returns an {@code Observable} that will invoke a subscriber's

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLast.java
Patch:
@@ -24,10 +24,9 @@
 import rx.Subscriber;
 
 /**
- * Returns an Observable that emits the last <code>count</code> items emitted by the source
- * Observable.
+ * Returns an Observable that emits the last <code>count</code> items emitted by the source Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/last.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/last.png" alt="">
  */
 public final class OperatorTakeLast<T> implements Operator<T, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java
Patch:
@@ -25,10 +25,9 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * Returns an Observable that emits the last <code>count</code> items emitted by the source
- * Observable.
+ * Returns an Observable that emits the last <code>count</code> items emitted by the source Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/last.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/last.png" alt="">
  */
 public final class OperatorTakeLastTimed<T> implements Operator<T, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTakeUntil.java
Patch:
@@ -23,7 +23,7 @@
  * Returns an Observable that emits the items from the source Observable until another Observable
  * emits an item.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeUntil.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeUntil.png" alt="">
  */
 public final class OperatorTakeUntil<T, E> implements Operator<T, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTakeWhile.java
Patch:
@@ -24,7 +24,7 @@
  * Returns an Observable that emits items emitted by the source Observable as long as a specified
  * condition is true.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeWhile.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeWhile.png" alt="">
  */
 public final class OperatorTakeWhile<T> implements Operator<T, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTimestamp.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Wraps each item emitted by a source {@code Observable} in a {@link Timestamped} object.
  * <p>
- * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.png">
+ * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.png" alt="">
  */
 public final class OperatorTimestamp<T> implements Operator<Timestamped<T>, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorToObservableList.java
Patch:
@@ -26,7 +26,7 @@
  * Returns an {@code Observable} that emits a single item, a list composed of all the items emitted by the
  * source {@code Observable}.
  * <p>
- * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/toList.png">
+ * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/toList.png" alt="">
  * <p>
  * Normally, an {@code Observable} that returns multiple items will do so by invoking its subscriber's
  * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the

File: rxjava-core/src/main/java/rx/internal/operators/OperatorToObservableSortedList.java
Patch:
@@ -29,7 +29,7 @@
  * (each item emitted by the {@code Observable} must implement {@link Comparable} with respect to all other
  * items in the sequence, or you must pass in a sort function).
  * <p>
- * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/toSortedList.png">
+ * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/toSortedList.png" alt="">
  * 
  * @param <T>
  *          the type of the items emitted by the source and the resulting {@code Observable}s

File: rxjava-core/src/main/java/rx/internal/operators/OperatorZip.java
Patch:
@@ -39,7 +39,7 @@
  * Returns an Observable that emits the results of a function applied to sets of items emitted, in
  * sequence, by two or more other Observables.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/zip.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/zip.png" alt="">
  * <p>
  * The zip operation applies this function in strict sequence, so the first item emitted by the new
  * Observable will be the result of the function applied to the first item emitted by each zipped

File: rxjava-core/src/main/java/rx/observables/ConnectableObservable.java
Patch:
@@ -27,7 +27,7 @@
  * can wait for all intended {@link Subscriber}s to {@link Observable#subscribe} to the {@code Observable}
  * before the {@code Observable} begins emitting items.
  * <p>
- * <img width="640" height="510" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/publishConnect.png">
+ * <img width="640" height="510" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/publishConnect.png" alt="">
  * 
  * @see <a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators">RxJava Wiki:
  *      Connectable Observable Operators</a>

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -24,7 +24,7 @@
  * Subject that publishes only the last item observed to each {@link Observer} that has subscribed, when the
  * source {@code Observable} completes.
  * <p>
- * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.AsyncSubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.AsyncSubject.png" alt="">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -25,7 +25,7 @@
  * Subject that emits the most recent item it has observed and all subsequent observed items to each subscribed
  * {@link Observer}.
  * <p>
- * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.BehaviorSubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.BehaviorSubject.png" alt="">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -24,7 +24,7 @@
  * Subject that, once an {@link Observer} has subscribed, emits all subsequently observed items to the
  * subscriber.
  * <p>
- * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.PublishSubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.PublishSubject.png" alt="">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * Subject that buffers all items it observes and replays them to any {@link Observer} that subscribes.
  * <p>
- * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.ReplaySubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.ReplaySubject.png" alt="">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/Subscriber.java
Patch:
@@ -108,9 +108,10 @@ protected Producer onSetProducer(Producer producer) {
 
     public final void setProducer(Producer producer) {
         producer = onSetProducer(producer);
-        int toRequest = requested;
+        int toRequest;
         boolean setProducer = false;
         synchronized (this) {
+            toRequest = requested;
             p = producer;
             if (op != null) {
                 // middle operator ... we pass thru unless a request has been made

File: rxjava-core/src/main/java/rx/Subscriber.java
Patch:
@@ -108,9 +108,10 @@ protected Producer onSetProducer(Producer producer) {
 
     public final void setProducer(Producer producer) {
         producer = onSetProducer(producer);
-        int toRequest = requested;
+        int toRequest;
         boolean setProducer = false;
         synchronized (this) {
+            toRequest = requested;
             p = producer;
             if (op != null) {
                 // middle operator ... we pass thru unless a request has been made

File: rxjava-core/src/test/java/rx/internal/operators/OperatorMergeTest.java
Patch:
@@ -669,7 +669,7 @@ public void onNext(Integer t) {
                 if (t < 100)
                     try {
                         // force a slow consumer
-                        Thread.sleep(2);
+                        Thread.sleep(1);
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -535,7 +535,9 @@ private void emit(T t, boolean complete) {
                             emitted++;
                         }
                     } else {
-                        if (producer.requested > 0) {
+                        // this needs to check q.count() as draining above may not have drained the full queue
+                        // perf tests show this to be okay, though different queue implementations could perform poorly with this
+                        if (producer.requested > 0 && q.count() == 0) {
                             if (complete) {
                                 parentSubscriber.completeInner(this);
                             } else {

File: rxjava-core/src/main/java/rx/exceptions/OnErrorThrowable.java
Patch:
@@ -116,7 +116,7 @@ public static class OnNextValue extends RuntimeException {
          *         the item that the Observable was trying to emit at the time of the exception
          */
         public OnNextValue(Object value) {
-            super("OnError while emitting onNext value: " + value);
+            super("OnError while emitting onNext.");
             this.value = value;
         }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -7261,7 +7261,7 @@ public final Observable<List<T>> takeLastBuffer(long time, TimeUnit unit, Schedu
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#takeuntil">RxJava Wiki: takeUntil()</a>
      */
     public final <E> Observable<T> takeUntil(Observable<? extends E> other) {
-        return OperatorTakeUntil.takeUntil(this, other);
+        return lift(new OperatorTakeUntil<T, E>(other));
     }
 
     /**

File: rxjava-core/src/main/java/rx/internal/operators/OnSubscribeDelay.java
Patch:
@@ -55,7 +55,7 @@ public Observable<T> call(T x) {
                 worker.schedule(e, delay, unit);
                 return Observable.create(e);
             }
-        })).subscribe(child);
+        })).unsafeSubscribe(child);
     }
     
     /**

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.observers.SerializedSubscriber;
 import rx.subscriptions.CompositeSubscription;
 
@@ -111,6 +112,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable e) {
+            Exceptions.throwIfFatal(e);
             if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {
                 parent.onError(e);
             }

File: rxjava-core/src/main/java/rx/observers/SerializedObserver.java
Patch:
@@ -16,6 +16,7 @@
 package rx.observers;
 
 import rx.Observer;
+import rx.exceptions.Exceptions;
 
 /**
  * Enforces single-threaded, serialized, ordered execution of {@link #onNext}, {@link #onCompleted}, and
@@ -100,6 +101,7 @@ public void onCompleted() {
 
     @Override
     public void onError(final Throwable e) {
+        Exceptions.throwIfFatal(e);
         FastList list;
         synchronized (this) {
             if (terminated) {

File: rxjava-core/src/main/java/rx/observers/Observers.java
Patch:
@@ -21,7 +21,7 @@
 import rx.functions.Action1;
 
 /**
- * @warn javadoc class description missing
+ * Helper methods and utilities for creating and working with {@link Observer} objects.
  */
 public class Observers {
 

File: rxjava-core/src/main/java/rx/observers/Subscribers.java
Patch:
@@ -22,7 +22,7 @@
 import rx.functions.Action1;
 
 /**
- * @warn javadoc class description missing
+ * Helper methods and utilities for creating and working with {@link Subscriber} objects.
  */
 public final class Subscribers {
     private Subscribers() {

File: rxjava-core/src/main/java/rx/subjects/Subject.java
Patch:
@@ -19,7 +19,7 @@
 import rx.Observer;
 
 /**
- * @warn javadoc class description missing
+ * Represents an object that is both an Observable and an Observer.
  */
 public abstract class Subject<T, R> extends Observable<R> implements Observer<T> {
     protected Subject(OnSubscribe<R> onSubscribe) {

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java
Patch:
@@ -37,7 +37,7 @@ public static <T, C> DebugNotification<T> createSubscribe(Observer<? super T> o,
             o = ds.getActual();
         }
         if (sourceFunc instanceof DebugHook.DebugOnSubscribe) {
-            sourceFunc = (OnSubscribe<T>) ((SafeSubscriber<T>) sourceFunc).getActual();
+            sourceFunc = ((DebugHook.DebugOnSubscribe) sourceFunc).getActual();
         }
         return new DebugNotification<T>(o, from, Kind.Subscribe, null, null, to, source, sourceFunc);
     }

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java
Patch:
@@ -37,7 +37,7 @@ public static <T, C> DebugNotification<T> createSubscribe(Observer<? super T> o,
             o = ds.getActual();
         }
         if (sourceFunc instanceof DebugHook.DebugOnSubscribe) {
-            sourceFunc = (OnSubscribe<T>) ((SafeSubscriber<T>) sourceFunc).getActual();
+            sourceFunc = ((DebugHook.DebugOnSubscribe) sourceFunc).getActual();
         }
         return new DebugNotification<T>(o, from, Kind.Subscribe, null, null, to, source, sourceFunc);
     }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.observers.SerializedSubscriber;
 import rx.subscriptions.CompositeSubscription;
 
@@ -111,6 +112,7 @@ public void onNext(T t) {
 
         @Override
         public void onError(Throwable e) {
+            Exceptions.throwIfFatal(e);
             if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {
                 parent.onError(e);
             }

File: rxjava-core/src/main/java/rx/observers/SerializedObserver.java
Patch:
@@ -16,6 +16,7 @@
 package rx.observers;
 
 import rx.Observer;
+import rx.exceptions.Exceptions;
 
 /**
  * Enforces single-threaded, serialized, ordered execution of {@link #onNext}, {@link #onCompleted}, and
@@ -100,6 +101,7 @@ public void onCompleted() {
 
     @Override
     public void onError(final Throwable e) {
+        Exceptions.throwIfFatal(e);
         FastList list;
         synchronized (this) {
             if (terminated) {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java
Patch:
@@ -138,7 +138,7 @@ private void pollQueue() {
                     }
                     on.accept(observer, v);
                 }
-                if (COUNTER_UPDATER.addAndGet(this, -vs.size) == 0) {
+                if (COUNTER_UPDATER.addAndGet(this, -vs.size) <= 0) {
                     break;
                 }
             } while (true);

File: rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java
Patch:
@@ -138,7 +138,7 @@ private void pollQueue() {
                     }
                     on.accept(observer, v);
                 }
-                if (COUNTER_UPDATER.addAndGet(this, -vs.size) == 0) {
+                if (COUNTER_UPDATER.addAndGet(this, -vs.size) <= 0) {
                     break;
                 }
             } while (true);

File: rxjava-core/src/main/java/rx/internal/operators/OperatorSingle.java
Patch:
@@ -56,6 +56,7 @@ public void onNext(T value) {
                 if (isNonEmpty) {
                     hasTooManyElements = true;
                     subscriber.onError(new IllegalArgumentException("Sequence contains too many elements"));
+                    unsubscribe();
                 } else {
                     this.value = value;
                     isNonEmpty = true;

File: rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java
Patch:
@@ -32,7 +32,8 @@
  * Groups the items emitted by an Observable according to a specified criterion, and emits these
  * grouped items as Observables, one Observable per group.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-Observers/groupBy.png">
+ * <img width="640" height="360" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png">
+ *
  * @param <K> the key type
  * @param <T> the source and group value type
  */

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMap.java
Patch:
@@ -24,7 +24,7 @@
  * Applies a function of your choosing to every item emitted by an Observable, and returns this
  * transformation as a new Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-Observers/map.png">
+ * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/map.png">
  */
 public final class OperatorMap<T, R> implements Operator<R, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Flattens a list of Observables into one Observable sequence, without any transformation.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-Observers/merge.png">
+ * <img width="640" height="380" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
  * <p>
  * You can combine the items emitted by multiple Observables so that they act like a single
  * Observable, by using the merge operation.

File: rxjava-core/src/main/java/rx/internal/operators/OperatorTimestamp.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Wraps each item emitted by a source Observable in a {@link Timestamped} object.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-Observers/timestamp.png">
+ * <img width="640" height="310" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.png">
  */
 public final class OperatorTimestamp<T> implements Operator<Timestamped<T>, T> {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMaterialize.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Notification;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Turns all of the notifications from an Observable into <code>onNext</code> emissions, and marks
@@ -42,6 +43,7 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                 child.onNext(Notification.<T> createOnError(e));
                 child.onCompleted();
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMergeDelayError.java
Patch:
@@ -125,10 +125,12 @@ public void onError(Throwable e) {
         public void onCompleted() {
             complete();
         }
+
         void error(Throwable e) {
             exceptions.add(e);
             complete();
         }
+
         void complete() {
             if (WIP_UPDATER.decrementAndGet(this) == 0) {
                 if (exceptions.isEmpty()) {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorFlatMap.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Subscriber;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func1;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Allows inserting onNext events into a stream when onError events are received
@@ -46,6 +47,7 @@ public void onCompleted() {
             @Override
             public void onError(Throwable e) {
                 try {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     Observable<? extends T> resume = resumeFunction.call(OnErrorThrowable.from(e));
                     resume.unsafeSubscribe(new Subscriber<T>() {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaFunction.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.functions.Func1;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to pass control to another Observable (the return value of a function)
@@ -59,6 +60,7 @@ public void onCompleted() {
             @Override
             public void onError(Throwable e) {
                 try {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     Observable<? extends T> resume = resumeFunction.call(e);
                     resume.unsafeSubscribe(child);
                 } catch (Throwable e2) {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservable.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to pass control to another Observable rather than invoking
@@ -58,6 +59,7 @@ public void onNext(T t) {
 
             @Override
             public void onError(Throwable e) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                 unsubscribe();
                 resumeSequence.unsafeSubscribe(child);
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorReturn.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.functions.Func1;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to emit a particular item to its Observer's <code>onNext</code> method
@@ -59,6 +60,7 @@ public void onNext(T t) {
             @Override
             public void onError(Throwable e) {
                 try {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     T result = resultFunction.call(e);
                     
                     child.onNext(result);

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnExceptionResumeNextViaObservable.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to pass control to another Observable rather than invoking
@@ -63,6 +64,7 @@ public void onNext(T t) {
             @Override
             public void onError(Throwable e) {
                 if (e instanceof Exception) {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     unsubscribe();
                     resumeSequence.unsafeSubscribe(child);
                 } else {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMergeDelayError.java
Patch:
@@ -22,7 +22,6 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.observers.SerializedSubscriber;
-import rx.plugins.RxJavaPlugins;
 import rx.subscriptions.CompositeSubscription;
 
 /**
@@ -128,7 +127,6 @@ public void onCompleted() {
         }
 
         void error(Throwable e) {
-            RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
             exceptions.add(e);
             complete();
         }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorMaterialize.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Notification;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Turns all of the notifications from an Observable into <code>onNext</code> emissions, and marks
@@ -42,6 +43,7 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                 child.onNext(Notification.<T> createOnError(e));
                 child.onCompleted();
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorFlatMap.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Subscriber;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func1;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Allows inserting onNext events into a stream when onError events are received
@@ -46,6 +47,7 @@ public void onCompleted() {
             @Override
             public void onError(Throwable e) {
                 try {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     Observable<? extends T> resume = resumeFunction.call(OnErrorThrowable.from(e));
                     resume.unsafeSubscribe(new Subscriber<T>() {
 

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaFunction.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.functions.Func1;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to pass control to another Observable (the return value of a function)
@@ -59,6 +60,7 @@ public void onCompleted() {
             @Override
             public void onError(Throwable e) {
                 try {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     Observable<? extends T> resume = resumeFunction.call(e);
                     resume.unsafeSubscribe(child);
                 } catch (Throwable e2) {

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaObservable.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to pass control to another Observable rather than invoking
@@ -58,6 +59,7 @@ public void onNext(T t) {
 
             @Override
             public void onError(Throwable e) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                 unsubscribe();
                 resumeSequence.unsafeSubscribe(child);
             }

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnErrorReturn.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.functions.Func1;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to emit a particular item to its Observer's <code>onNext</code> method
@@ -59,6 +60,7 @@ public void onNext(T t) {
             @Override
             public void onError(Throwable e) {
                 try {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     T result = resultFunction.call(e);
                     
                     child.onNext(result);

File: rxjava-core/src/main/java/rx/internal/operators/OperatorOnExceptionResumeNextViaObservable.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.plugins.RxJavaPlugins;
 
 /**
  * Instruct an Observable to pass control to another Observable rather than invoking
@@ -63,6 +64,7 @@ public void onNext(T t) {
             @Override
             public void onError(Throwable e) {
                 if (e instanceof Exception) {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
                     unsubscribe();
                     resumeSequence.unsafeSubscribe(child);
                 } else {

File: rxjava-core/src/main/java/rx/schedulers/Schedulers.java
Patch:
@@ -127,7 +127,7 @@ public static TestScheduler test() {
      *          the executor to wrap
      * @return the new Scheduler wrapping the Executor
      */
-    public static Scheduler newExecutor(Executor executor) {
+    public static Scheduler from(Executor executor) {
         return new ExecutorScheduler(executor);
     }
 }

File: rxjava-core/src/test/java/rx/schedulers/ExecutorSchedulerTest.java
Patch:
@@ -22,7 +22,7 @@ public class ExecutorSchedulerTest extends AbstractSchedulerConcurrencyTests {
 
     @Override
     protected Scheduler getScheduler() {
-        return Schedulers.newExecutor(Executors.newFixedThreadPool(2, new NewThreadScheduler.RxThreadFactory("TestCustomPool-")));
+        return Schedulers.from(Executors.newFixedThreadPool(2, new NewThreadScheduler.RxThreadFactory("TestCustomPool-")));
     }
     
 }

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -4053,7 +4053,7 @@ public final void forEach(final Action1<? super T> onNext, final Action1<Throwab
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#wiki-groupby-and-groupbyuntil">RxJava Wiki: groupBy</a>
      */
     public final <K> Observable<GroupedObservable<K, T>> groupBy(final Func1<? super T, ? extends K> keySelector) {
-        return lift(new OnSubscribeGroupBy<K, T>(keySelector));
+        return lift(new OperatorGroupBy<K, T>(keySelector));
     }
 
     /**
@@ -4106,7 +4106,7 @@ public final <TKey, TDuration> Observable<GroupedObservable<TKey, T>> groupByUnt
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229433.aspx">MSDN: Observable.GroupByUntil</a>
      */
     public final <TKey, TValue, TDuration> Observable<GroupedObservable<TKey, TValue>> groupByUntil(Func1<? super T, ? extends TKey> keySelector, Func1<? super T, ? extends TValue> valueSelector, Func1<? super GroupedObservable<TKey, TValue>, ? extends Observable<? extends TDuration>> durationSelector) {
-        return lift(new OnSubscribeGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));
+        return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -37,11 +37,11 @@
  * @param <K> the key type
  * @param <T> the source and group value type
  */
-public final class OnSubscribeGroupBy<K, T> implements Operator<GroupedObservable<K, T>, T> {
+public final class OperatorGroupBy<K, T> implements Operator<GroupedObservable<K, T>, T> {
     
     final Func1<? super T, ? extends K> keySelector;
     
-    public OnSubscribeGroupBy(final Func1<? super T, ? extends K> keySelector) {
+    public OperatorGroupBy(final Func1<? super T, ? extends K> keySelector) {
         this.keySelector = keySelector;
     }
     

File: rxjava-core/src/main/java/rx/operators/OperatorGroupByUntil.java
Patch:
@@ -44,12 +44,12 @@
  * @param <R> the value type of the groups
  * @param <D> the type of the duration
  */
-public class OnSubscribeGroupByUntil<T, K, R, D> implements Operator<GroupedObservable<K, R>, T> {
+public class OperatorGroupByUntil<T, K, R, D> implements Operator<GroupedObservable<K, R>, T> {
     final Func1<? super T, ? extends K> keySelector;
     final Func1<? super T, ? extends R> valueSelector;
     final Func1<? super GroupedObservable<K, R>, ? extends Observable<? extends D>> durationSelector;
 
-    public OnSubscribeGroupByUntil(
+    public OperatorGroupByUntil(
             Func1<? super T, ? extends K> keySelector,
             Func1<? super T, ? extends R> valueSelector,
             Func1<? super GroupedObservable<K, R>, ? extends Observable<? extends D>> durationSelector) {

File: rxjava-core/src/main/java/rx/operators/OperatorParallel.java
Patch:
@@ -41,7 +41,7 @@ public OperatorParallel(Func1<Observable<T>, Observable<R>> f, Scheduler schedul
     public Subscriber<? super T> call(Subscriber<? super R> op) {
 
         Func1<Subscriber<? super GroupedObservable<Long, T>>, Subscriber<? super T>> groupBy =
-                new OnSubscribeGroupBy<Long, T>(new Func1<T, Long>() {
+                new OperatorGroupBy<Long, T>(new Func1<T, Long>() {
 
                     long i = 0;
 

File: rxjava-core/src/test/java/rx/operators/OperatorGroupByUntilTest.java
Patch:
@@ -45,7 +45,7 @@
 import rx.functions.Functions;
 import rx.observables.GroupedObservable;
 
-public class OnSubscribeGroupByUntilTest {
+public class OperatorGroupByUntilTest {
     @Mock
     Observer<Object> observer;
 

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -26,7 +26,7 @@
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.observables.GroupedObservable;
-import rx.subscriptions.CompositeSubscription;
+import rx.subscriptions.ChainedSubscription;
 import rx.subscriptions.Subscriptions;
 
 /**
@@ -55,7 +55,7 @@ static final class GroupBySubscriber<K, T> extends Subscriber<T> {
         public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Subscriber<? super GroupedObservable<K, T>> childObserver) {
             // a new CompositeSubscription to decouple the subscription as the inner subscriptions need a separate lifecycle
             // and will unsubscribe on this parent if they are all unsubscribed
-            super(new CompositeSubscription());
+            super(new ChainedSubscription());
             this.keySelector = keySelector;
             this.childObserver = childObserver;
         }

File: rxjava-core/src/main/java/rx/operators/OperatorTake.java
Patch:
@@ -17,7 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
-import rx.subscriptions.CompositeSubscription;
+import rx.subscriptions.ChainedSubscription;
 
 /**
  * Returns an Observable that emits the first <code>num</code> items emitted by the source
@@ -40,7 +40,7 @@ public OperatorTake(int limit) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super T> child) {
-        final CompositeSubscription parent = new CompositeSubscription();
+        final ChainedSubscription parent = new ChainedSubscription();
         if (limit == 0) {
             child.onCompleted();
             parent.unsubscribe();

File: rxjava-core/src/main/java/rx/operators/OperatorUnsubscribeOn.java
Patch:
@@ -19,7 +19,7 @@
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Action0;
-import rx.subscriptions.CompositeSubscription;
+import rx.subscriptions.ChainedSubscription;
 import rx.subscriptions.Subscriptions;
 
 /**
@@ -36,7 +36,7 @@ public OperatorUnsubscribeOn(Scheduler scheduler) {
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {
-        final CompositeSubscription parentSubscription = new CompositeSubscription();
+        final ChainedSubscription parentSubscription = new ChainedSubscription();
         subscriber.add(Subscriptions.create(new Action0() {
 
             @Override

File: rxjava-core/src/main/java/rx/operators/BlockingOperatorNext.java
Patch:
@@ -178,7 +178,7 @@ public Notification<? extends T> takeNext() throws InterruptedException {
             return buf.take();
         }
         void setWaiting(int value) {
-            WAITING_UPDATER.lazySet(this, value);
+            waiting = value;
         }
     }
 }

File: rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java
Patch:
@@ -70,7 +70,7 @@ boolean casFirst(int expected, int next) {
             return FIRST_UPDATER.compareAndSet(this, expected, next);
         }
         void setObserverRef(Observer<? super T> o) {
-            OBSERVER_UPDATER.lazySet(this, o);
+            observerRef = o;
         }
         boolean casObserverRef(Observer<? super T> expected, Observer<? super T> next) {
             return OBSERVER_UPDATER.compareAndSet(this, expected, next);

File: rxjava-core/src/main/java/rx/operators/OperatorMerge.java
Patch:
@@ -57,7 +57,7 @@ public MergeSubscriber(Subscriber<T> actual, CompositeSubscription childrenSubsc
             super(actual);
             this.actual = actual;
             this.childrenSubscriptions = childrenSubscriptions;
-            WIP_UPDATER.lazySet(this, 1);
+            this.wip = 1;
         }
 
         @Override

File: rxjava-core/src/main/java/rx/operators/OperatorMergeDelayError.java
Patch:
@@ -67,7 +67,7 @@ public MergeDelayErrorSubscriber(Subscriber<? super T> s, CompositeSubscription
             super(s);
             this.s = s;
             this.csub = csub;
-            WIP_UPDATER.lazySet(this, 1);
+            this.wip = 1;
         }
         
         @Override

File: rxjava-core/src/main/java/rx/operators/OperatorMergeMapPair.java
Patch:
@@ -79,7 +79,7 @@ public SourceSubscriber(Subscriber<R> s, CompositeSubscription csub,
             this.csub = csub;
             this.collectionSelector = collectionSelector;
             this.resultSelector = resultSelector;
-            WIP_UPDATER.lazySet(this, 1);
+            this.wip = 1;
         }
         
         @Override

File: rxjava-core/src/main/java/rx/operators/OperatorMergeMapTransform.java
Patch:
@@ -71,7 +71,7 @@ public SourceSubscriber(Subscriber<R> s, CompositeSubscription csub, Func1<? sup
             this.onNext = onNext;
             this.onError = onError;
             this.onCompleted = onCompleted;
-            WIP_UPDATER.lazySet(this, 1);
+            this.wip = 1;
         }
         
         @Override

File: rxjava-core/src/main/java/rx/operators/OperatorMergeMaxConcurrent.java
Patch:
@@ -72,7 +72,7 @@ public SourceSubscriber(int maxConcurrency, Subscriber<T> s, CompositeSubscripti
             this.csub = csub;
             this.guard = new Object();
             this.queue = new LinkedList<Observable<? extends T>>();
-            WIP_UPDATER.lazySet(this, 1);
+            this.wip = 1;
         }
         
         @Override

File: rxjava-core/src/main/java/rx/operators/OperatorSampleWithTime.java
Patch:
@@ -72,7 +72,7 @@ public SamplerSubscriber(Subscriber<? super T> subscriber) {
         }
         @Override
         public void onNext(T t) {
-            VALUE_UPDATER.lazySet(this, t);
+            value = t;
         }
 
         @Override

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -74,7 +74,7 @@ public void call() {
     }    
     /** Set the latest NotificationLite value. */
     void set(Object value) {
-        LATEST_UPDATER.lazySet(this, value);
+        latest = value;
     }
     /** @return Retrieve the latest NotificationLite value */
     Object get() {

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import rx.Subscription;
@@ -103,11 +102,11 @@ State clear() {
     public CompositeSubscription() {
         // this creates only a store-store barrier which is generally faster when
         // CompositeSubscriptions are created in a tight loop.
-        STATE_UPDATER.lazySet(this, CLEAR_STATE);
+        state = CLEAR_STATE;
     }
 
     public CompositeSubscription(final Subscription... subscriptions) {
-        STATE_UPDATER.lazySet(this, new State(false, subscriptions));
+        state = new State(false, subscriptions);
     }
 
     @Override

File: rxjava-core/src/main/java/rx/subscriptions/Subscriptions.java
Patch:
@@ -53,7 +53,7 @@ private static final class ActionSubscription implements Subscription {
         static final AtomicReferenceFieldUpdater<ActionSubscription, Action0> ACTUAL_UPDATER
                 = AtomicReferenceFieldUpdater.newUpdater(ActionSubscription.class, Action0.class, "actual");
         public ActionSubscription(Action0 action) {
-            ACTUAL_UPDATER.lazySet(this, action != null ? action : Actions.empty());
+            this.actual = action != null ? action : Actions.empty();
         }
         @Override
         public boolean isUnsubscribed() {

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -453,8 +453,8 @@ public void onCompleted() {
 
         @Override
         public void onError(Throwable e) {
-            completed.countDown();
             error.set(e);
+            completed.countDown();
         }
 
         @Override

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -453,8 +453,8 @@ public void onCompleted() {
 
         @Override
         public void onError(Throwable e) {
-            completed.countDown();
             error.set(e);
+            completed.countDown();
         }
 
         @Override

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -1084,10 +1084,8 @@ public final static <T> Observable<T> from(Iterable<? extends T> iterable, Sched
      * @return an Observable that emits the item
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-from">RxJava Wiki: from()</a>
      */
-    // suppress unchecked because we are using varargs inside the method
-    @SuppressWarnings("unchecked")
     public final static <T> Observable<T> from(T t1) {
-        return from(Arrays.asList(t1));
+        return just(t1);
     }
 
     /**

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -35,7 +35,7 @@
  * An extension of {@link Observable} that provides blocking operators.
  * <p>
  * You construct a <code>BlockingObservable</code> from an
- * <code>Observable</code> with {@link #from(Observable)} or {@link Observable#toBlockingObservable()} <p>
+ * <code>Observable</code> with {@link #from(Observable)} or {@link Observable#toBlocking()} <p>
  * The documentation for this interface makes use of a form of marble diagram
  * that has been modified to illustrate blocking operators. The following legend
  * explains these marble diagrams:

File: rxjava-core/src/perf/java/rx/archive/schedulers/TestRecursionMemoryUsage.java
Patch:
@@ -66,6 +66,6 @@ public void call() {
                     }
                 });
             }
-        }).toBlockingObservable().last();
+        }).toBlocking().last();
     }
 }

File: rxjava-core/src/test/java/rx/GroupByTests.java
Patch:
@@ -38,7 +38,7 @@ public String call(Event event) {
                     }
 
                 }).take(1)
-                .toBlockingObservable().forEach(new Action1<GroupedObservable<String, Event>>() {
+                .toBlocking().forEach(new Action1<GroupedObservable<String, Event>>() {
 
                     @Override
                     public void call(GroupedObservable<String, Event> g) {
@@ -79,7 +79,7 @@ public String call(Event event) {
 
                 })
                 .take(20)
-                .toBlockingObservable().forEach(new Action1<String>() {
+                .toBlocking().forEach(new Action1<String>() {
 
                     @Override
                     public void call(String v) {

File: rxjava-core/src/test/java/rx/ObservableDoOnTest.java
Patch:
@@ -39,7 +39,7 @@ public void testDoOnEach() {
             public void call(String v) {
                 r.set(v);
             }
-        }).toBlockingObservable().single();
+        }).toBlocking().single();
 
         assertEquals("one", output);
         assertEquals("one", r.get());
@@ -56,7 +56,7 @@ Observable.<String> error(new RuntimeException("an error")).doOnError(new Action
                 public void call(Throwable v) {
                     r.set(v);
                 }
-            }).toBlockingObservable().single();
+            }).toBlocking().single();
             fail("expected exception, not a return value");
         } catch (Throwable e) {
             t = e;
@@ -75,7 +75,7 @@ public void testDoOnCompleted() {
             public void call() {
                 r.set(true);
             }
-        }).toBlockingObservable().single();
+        }).toBlocking().single();
 
         assertEquals("one", output);
         assertTrue(r.get());

File: rxjava-core/src/test/java/rx/ObservableWindowTests.java
Patch:
@@ -37,7 +37,7 @@ public void testWindow() {
             public Observable<List<Integer>> call(Observable<Integer> xs) {
                 return xs.toList();
             }
-        })).toBlockingObservable().forEach(new Action1<List<Integer>>() {
+        })).toBlocking().forEach(new Action1<List<Integer>>() {
 
             @Override
             public void call(List<Integer> xs) {

File: rxjava-core/src/test/java/rx/ReduceTests.java
Patch:
@@ -34,7 +34,7 @@ public void reduceInts() {
             public Integer call(Integer t1, Integer t2) {
                 return t1 + t2;
             }
-        }).toBlockingObservable().single();
+        }).toBlocking().single();
 
         assertEquals(6, value);
     }

File: rxjava-core/src/test/java/rx/ScanTests.java
Patch:
@@ -40,7 +40,7 @@ public Map<String, String> call(Map<String, String> accum, Event perInstanceEven
 
                 })
                 .take(10)
-                .toBlockingObservable().forEach(new Action1<Map<String, String>>() {
+                .toBlocking().forEach(new Action1<Map<String, String>>() {
 
                     @Override
                     public void call(Map<String, String> v) {

File: rxjava-core/src/test/java/rx/StartWithTests.java
Patch:
@@ -26,7 +26,7 @@ public class StartWithTests {
 
     @Test
     public void startWith1() {
-        List<String> values = Observable.from("one", "two").startWith("zero").toList().toBlockingObservable().single();
+        List<String> values = Observable.from("one", "two").startWith("zero").toList().toBlocking().single();
 
         assertEquals("zero", values.get(0));
         assertEquals("two", values.get(2));
@@ -37,7 +37,7 @@ public void startWithIterable() {
         List<String> li = new ArrayList<String>();
         li.add("alpha");
         li.add("beta");
-        List<String> values = Observable.from("one", "two").startWith(li).toList().toBlockingObservable().single();
+        List<String> values = Observable.from("one", "two").startWith(li).toList().toBlocking().single();
 
         assertEquals("alpha", values.get(0));
         assertEquals("beta", values.get(1));
@@ -50,7 +50,7 @@ public void startWithObservable() {
         List<String> li = new ArrayList<String>();
         li.add("alpha");
         li.add("beta");
-        List<String> values = Observable.from("one", "two").startWith(Observable.from(li)).toList().toBlockingObservable().single();
+        List<String> values = Observable.from("one", "two").startWith(Observable.from(li)).toList().toBlocking().single();
 
         assertEquals("alpha", values.get(0));
         assertEquals("beta", values.get(1));

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorMostRecentTest.java
Patch:
@@ -79,7 +79,7 @@ public void testMostRecentWithException() {
     @Test(timeout = 1000)
     public void testSingleSourceManyIterators() {
         TestScheduler scheduler = new TestScheduler();
-        BlockingObservable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10).toBlockingObservable();
+        BlockingObservable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10).toBlocking();
 
         Iterable<Long> iter = source.mostRecent(-1L);
 

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorNextTest.java
Patch:
@@ -295,7 +295,7 @@ public void run() {
     @Test /* (timeout = 8000) */
     public void testSingleSourceManyIterators() throws InterruptedException {
         PublishSubject<Long> ps = PublishSubject.create();
-        BlockingObservable<Long> source = ps.take(10).toBlockingObservable();
+        BlockingObservable<Long> source = ps.take(10).toBlocking();
 
         Iterable<Long> iter = source.next();
 

File: rxjava-core/src/test/java/rx/operators/OperatorMaterializeTest.java
Patch:
@@ -89,8 +89,8 @@ public void testMultipleSubscribes() throws InterruptedException, ExecutionExcep
 
         Observable<Notification<String>> m = Observable.create(o).materialize();
 
-        assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());
-        assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());
+        assertEquals(3, m.toList().toBlocking().toFuture().get().size());
+        assertEquals(3, m.toList().toBlocking().toFuture().get().size());
     }
 
     private static class TestObserver extends Subscriber<Notification<String>> {

File: rxjava-core/src/test/java/rx/operators/OperatorMergeTest.java
Patch:
@@ -159,7 +159,7 @@ public void run() {
         });
 
         final AtomicInteger count = new AtomicInteger();
-        Observable.merge(source).take(6).toBlockingObservable().forEach(new Action1<Long>() {
+        Observable.merge(source).take(6).toBlocking().forEach(new Action1<Long>() {
 
             @Override
             public void call(Long v) {

File: rxjava-core/src/test/java/rx/operators/OperatorObserveOnTest.java
Patch:
@@ -235,7 +235,7 @@ public Integer call(Integer t1) {
             }
 
         }).observeOn(Schedulers.newThread())
-                .toBlockingObservable().forEach(new Action1<Integer>() {
+                .toBlocking().forEach(new Action1<Integer>() {
 
                     @Override
                     public void call(Integer t1) {
@@ -262,7 +262,7 @@ public Integer call(Integer t1) {
             }
 
         }).observeOn(Schedulers.computation())
-                .toBlockingObservable().forEach(new Action1<Integer>() {
+                .toBlocking().forEach(new Action1<Integer>() {
 
                     @Override
                     public void call(Integer t1) {
@@ -302,7 +302,7 @@ public Integer call(Integer t1) {
             }
 
         }).observeOn(Schedulers.computation())
-                .toBlockingObservable().forEach(new Action1<Integer>() {
+                .toBlocking().forEach(new Action1<Integer>() {
 
                     @Override
                     public void call(Integer t1) {

File: rxjava-core/src/test/java/rx/operators/OperatorParallelTest.java
Patch:
@@ -60,7 +60,7 @@ public Integer[] call(Integer t) {
                         });
                     }
                 })
-                .toBlockingObservable().forEach(new Action1<Integer[]>() {
+                .toBlocking().forEach(new Action1<Integer[]>() {
 
                     @Override
                     public void call(Integer[] v) {
@@ -94,7 +94,7 @@ public Observable<String> call(Integer t) {
 
                         });
                     }
-                }).toBlockingObservable().forEach(new Action1<String>() {
+                }).toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String v) {

File: rxjava-core/src/test/java/rx/operators/OperatorTakeTest.java
Patch:
@@ -83,7 +83,7 @@ public void testTakeWithError() {
             public Integer call(Integer t1) {
                 throw new IllegalArgumentException("some error");
             }
-        }).toBlockingObservable().single();
+        }).toBlocking().single();
     }
 
     @Test
@@ -237,7 +237,7 @@ public void call(Subscriber<? super Integer> s) {
                 }
             }
 
-        }).take(100).take(1).toBlockingObservable().forEach(new Action1<Integer>() {
+        }).take(100).take(1).toBlocking().forEach(new Action1<Integer>() {
 
             @Override
             public void call(Integer t1) {

File: rxjava-core/src/test/java/rx/operators/OperatorTakeWhileTest.java
Patch:
@@ -121,7 +121,7 @@ public void call(Subscriber<? super String> observer) {
             public Boolean call(String s) {
                 return false;
             }
-        }).toBlockingObservable().lastOrDefault("");
+        }).toBlocking().lastOrDefault("");
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperatorUsingTest.java
Patch:
@@ -152,7 +152,7 @@ public Observable<Integer> call(Subscription subscription) {
             }
         };
 
-        Observable.using(resourceFactory, observableFactory).toBlockingObservable().last();
+        Observable.using(resourceFactory, observableFactory).toBlocking().last();
     }
 
     @Test
@@ -173,7 +173,7 @@ public Observable<Integer> call(Subscription subscription) {
         };
 
         try {
-            Observable.using(resourceFactory, observableFactory).toBlockingObservable().last();
+            Observable.using(resourceFactory, observableFactory).toBlocking().last();
             fail("Should throw a TestException when the observableFactory throws it");
         } catch (TestException e) {
             // Make sure that unsubscribe is called so that users can close
@@ -205,7 +205,7 @@ public void call(Subscriber<? super Integer> t1) {
         };
 
         try {
-            Observable.using(resourceFactory, observableFactory).toBlockingObservable().last();
+            Observable.using(resourceFactory, observableFactory).toBlocking().last();
             fail("Should throw a TestException when the observableFactory throws it");
         } catch (TestException e) {
             // Make sure that unsubscribe is called so that users can close

File: rxjava-core/src/test/java/rx/operators/OperatorWindowTest.java
Patch:
@@ -62,7 +62,7 @@ public Observable<List<T>> call(Observable<T> xs) {
                 return xs.toList();
             }
         }))
-                .toBlockingObservable()
+                .toBlocking()
                 .forEach(new Action1<List<T>>() {
                     @Override
                     public void call(List<T> xs) {

File: rxjava-core/src/test/java/rx/operators/OperatorZipTest.java
Patch:
@@ -1036,7 +1036,7 @@ public Object call(final Object... args) {
             }
         });
 
-        o.toBlockingObservable().last();
+        o.toBlocking().last();
     }
 
     Observable<Integer> OBSERVABLE_OF_5_INTEGERS = OBSERVABLE_OF_5_INTEGERS(new AtomicInteger());

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -130,7 +130,7 @@ public String call(String s) {
 
         });
 
-        List<String> strings = m.toList().toBlockingObservable().last();
+        List<String> strings = m.toList().toBlocking().last();
 
         assertEquals(4, strings.size());
         // because flatMap does a merge there is no guarantee of order
@@ -333,7 +333,7 @@ public void call() {
         });
 
         final AtomicInteger lastValue = new AtomicInteger();
-        obs.toBlockingObservable().forEach(new Action1<Integer>() {
+        obs.toBlocking().forEach(new Action1<Integer>() {
 
             @Override
             public void call(Integer v) {

File: rxjava-core/src/test/java/rx/schedulers/ComputationSchedulerTests.java
Patch:
@@ -102,7 +102,7 @@ public String call(Integer t) {
             }
         });
 
-        o.subscribeOn(Schedulers.computation()).toBlockingObservable().forEach(new Action1<String>() {
+        o.subscribeOn(Schedulers.computation()).toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String t) {
@@ -129,7 +129,7 @@ public String call(Integer t) {
             }
         });
 
-        o.toBlockingObservable().forEach(new Action1<String>() {
+        o.toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String t) {

File: rxjava-core/src/test/java/rx/schedulers/ImmediateSchedulerTest.java
Patch:
@@ -68,7 +68,7 @@ public String call(Integer t) {
             }
         });
 
-        o.toBlockingObservable().forEach(new Action1<String>() {
+        o.toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String t) {
@@ -93,7 +93,7 @@ public String call(Integer t) {
             }
         });
 
-        o.toBlockingObservable().forEach(new Action1<String>() {
+        o.toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String t) {

File: rxjava-core/src/test/java/rx/schedulers/NewThreadSchedulerTest.java
Patch:
@@ -49,7 +49,7 @@ public String call(Integer t) {
             }
         });
 
-        o.subscribeOn(Schedulers.io()).toBlockingObservable().forEach(new Action1<String>() {
+        o.subscribeOn(Schedulers.io()).toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String t) {

File: rxjava-core/src/test/java/rx/schedulers/TrampolineSchedulerTest.java
Patch:
@@ -47,7 +47,7 @@ public String call(Integer t) {
             }
         });
 
-        o.toBlockingObservable().forEach(new Action1<String>() {
+        o.toBlocking().forEach(new Action1<String>() {
 
             @Override
             public void call(String t) {

File: rxjava-core/src/test/java/rx/subjects/AsyncSubjectTest.java
Patch:
@@ -274,7 +274,7 @@ public SubjectObserverThread(AsyncSubject<String> subject) {
         public void run() {
             try {
                 // a timeout exception will happen if we don't get a terminal state 
-                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlockingObservable().single();
+                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlocking().single();
                 value.set(v);
             } catch (Exception e) {
                 e.printStackTrace();

File: rxjava-core/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java
Patch:
@@ -71,7 +71,7 @@ public void call(Subscriber<? super Long> o) {
         });
         source.start();
 
-        long v = replay.toBlockingObservable().last();
+        long v = replay.toBlocking().last();
         assertEquals(10000, v);
 
         // it's been played through once so now it will all be replays
@@ -198,7 +198,7 @@ public void call(Subscriber<? super Long> o) {
 
                 @Override
                 public void run() {
-                    List<Long> values = replay.toList().toBlockingObservable().last();
+                    List<Long> values = replay.toList().toBlocking().last();
                     listOfListsOfValues.add(values);
                     System.out.println("Finished thread: " + count);
                 }
@@ -330,7 +330,7 @@ public SubjectObserverThread(ReplaySubject<String> subject) {
         public void run() {
             try {
                 // a timeout exception will happen if we don't get a terminal state 
-                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlockingObservable().single();
+                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlocking().single();
                 value.set(v);
             } catch (Exception e) {
                 e.printStackTrace();

File: rxjava-core/src/test/java/rx/util/AssertObservable.java
Patch:
@@ -48,7 +48,7 @@ public static <T> void assertObservableEqualsBlocking(Observable<T> expected, Ob
      *            Observable with actual values
      */
     public static <T> void assertObservableEqualsBlocking(String message, Observable<T> expected, Observable<T> actual) {
-        assertObservableEquals(expected, actual).toBlockingObservable().lastOrDefault(null);
+        assertObservableEquals(expected, actual).toBlocking().lastOrDefault(null);
     }
 
     /**

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java
Patch:
@@ -371,7 +371,7 @@ public void call(Integer t) {
         final CountDownLatch latch = new CountDownLatch(5);
         final CountDownLatch first = new CountDownLatch(1);
 
-        o1.subscribe(new Action1<Integer>() {
+        o1.subscribeOn(scheduler).subscribe(new Action1<Integer>() {
 
             @Override
             public void call(Integer t) {
@@ -388,7 +388,7 @@ public void call(Integer t) {
                 count.incrementAndGet();
                 latch.countDown();
             }
-        }, scheduler);
+        });
 
         // assert we are async
         assertEquals(0, count.get());

File: rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java
Patch:
@@ -429,7 +429,6 @@ public void call(String s) {
         assertEquals(37, sentEventCounter.get());
     }
 
-    @Ignore // ignore until https://github.com/Netflix/RxJava/issues/1011 is fixed
     @Test
     public void testStaggeredCompletion() throws InterruptedException {
         final AtomicInteger eventCounter = new AtomicInteger();

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -48,7 +48,7 @@ public abstract class Scheduler {
      * <p>
      * Work on a {@link Scheduler.Worker} is guaranteed to be sequential.
      * 
-     * @return Inner representing a serial queue of actions to be executed
+     * @return Worker representing a serial queue of actions to be executed
      */
     public abstract Worker createWorker();
 

File: rxjava-contrib/rxjava-swing/src/main/java/rx/schedulers/SwingScheduler.java
Patch:
@@ -64,7 +64,7 @@ public boolean isUnsubscribed() {
 
         @Override
         public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {
-            long delay = unit.toMillis(delayTime);
+            long delay = Math.max(0, unit.toMillis(delayTime));
             assertThatTheDelayIsValidForTheSwingTimer(delay);
             final BooleanSubscription s = BooleanSubscription.create();
             class ExecuteOnceAction implements ActionListener {

File: rxjava-contrib/rxjava-swing/src/test/java/rx/schedulers/SwingSchedulerTest.java
Patch:
@@ -51,10 +51,8 @@ public void testInvalidDelayValues() {
         final Worker inner = scheduler.createWorker();
         final Action0 action = mock(Action0.class);
 
-        exception.expect(IllegalArgumentException.class);
         inner.schedulePeriodically(action, -1L, 100L, TimeUnit.SECONDS);
 
-        exception.expect(IllegalArgumentException.class);
         inner.schedulePeriodically(action, 100L, -1L, TimeUnit.SECONDS);
 
         exception.expect(IllegalArgumentException.class);

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -260,7 +260,9 @@ public void onError(Throwable e) {
         public void onNext(T v) {
             this.actual.onNext(v);
         }
-
+        Observer<? super T> getActual() {
+            return actual;
+        }
     }
 
 }
\ No newline at end of file

File: language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyOnSubscribeFuncWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -167,7 +167,7 @@ public String getName() {
             }
 
             @Override
-            public Class getReturnType() {
+            public Class<?> getReturnType() {
                 return m.getReturnType();
             }
 
@@ -177,6 +177,7 @@ public CachedClass getDeclaringClass() {
             }
 
             @Override
+            @SuppressWarnings("unchecked")
             public Object invoke(Object object, final Object[] arguments) {
                 return Observable.create(new GroovyCreateWrapper((Closure) arguments[0]));
             }

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyPropertiesModuleFactory.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/AndroidSchedulers.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java
Patch:
@@ -27,7 +27,7 @@
 public class ViewObservable {
 
     public static <T extends View> Observable<T> clicks(final T view, final boolean emitInitialValue) {
-        return Observable.create(new OperatorViewClick(view, emitInitialValue));
+        return Observable.create(new OperatorViewClick<T>(view, emitInitialValue));
     }
 
     public static Observable<String> input(final EditText input, final boolean emitInitialValue) {

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/AndroidSchedulers.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorObserveFromAndroidComponent.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/observables/AndroidObservableTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorObserveFromAndroidComponentTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/schedulers/HandlerThreadSchedulerTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttpResponse.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ExpandableByteBuffer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/Statement.java
Patch:
@@ -26,7 +26,7 @@
  * Imperative statements expressed as Observable operators.
  */
 public final class Statement {
-	private Statement() { throw new IllegalStateException("No instances!"); }
+    private Statement() { throw new IllegalStateException("No instances!"); }
     /**
      * Return a particular one of several possible Observables based on a case
      * selector.
@@ -94,7 +94,7 @@ public static <K, R> Observable<R> switchCase(Func0<? extends K> caseSelector,
      * @param mapOfCases
      *            a map that maps a case key to an Observable
      * @param defaultCase
-     *            the default Observable if the {@code mapOfCases} doesn't contain a value for the key returned by the {@case caseSelector}
+     *            the default Observable if the {@code mapOfCases} doesn't contain a value for the key returned by the {@code caseSelector}
      * @return a particular Observable chosen by key from the map of
      *         Observables, or the default case if no Observable matches the key
      */

File: rxjava-contrib/rxjava-joins/src/main/java/rx/joins/Pattern1.java
Patch:
@@ -38,7 +38,7 @@ public Observable<T1> first() {
      * 
      * @param selector
      *            the function that will be invoked for elements in the source sequences.
-     * @return
+     * @return the plan for the matching
      * @throws NullPointerException
      *             if selector is null
      */

File: rxjava-contrib/rxjava-joins/src/main/java/rx/joins/operators/OperatorJoinPatterns.java
Patch:
@@ -121,7 +121,7 @@ public void call(ActivePlan0 activePlan) {
                         }));
                     }
                 } catch (Throwable t) {
-                	Observable.<R> error(t).unsafeSubscribe(t1);
+                    Observable.<R> error(t).unsafeSubscribe(t1);
                     return;
                 }
                 CompositeSubscription group = new CompositeSubscription();

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageDouble.java
Patch:
@@ -35,7 +35,7 @@ public OperatorAverageDouble(Func1<? super T, Double> valueExtractor) {
 
     @Override
     public Subscriber<? super T> call(Subscriber<? super Double> child) {
-    	return new AverageObserver(child);
+        return new AverageObserver(child);
     }
 
     /** Computes the average. */
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Double> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageFloat.java
Patch:
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Float> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageInteger.java
Patch:
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Integer> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageLong.java
Patch:
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Long> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorMinMax.java
Patch:
@@ -27,7 +27,7 @@
  * Returns the minimum element in an observable sequence.
  */
 public final class OperatorMinMax {
-	private OperatorMinMax() { throw new IllegalStateException("No instances!"); }
+    private OperatorMinMax() { throw new IllegalStateException("No instances!"); }
 
     public static <T extends Comparable<? super T>> Observable<T> min(
             Observable<T> source) {

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorSum.java
Patch:
@@ -26,7 +26,7 @@
  *      Observable.Sum</a>
  */
 public final class OperatorSum {
-	private OperatorSum() { throw new IllegalStateException("No instances!"); }
+    private OperatorSum() { throw new IllegalStateException("No instances!"); }
 
     public static Observable<Integer> sumIntegers(Observable<Integer> source) {
         return source.reduce(0, ACCUM_INT);

File: rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperatorAverageTest.java
Patch:
@@ -358,6 +358,6 @@ public Double call(String t1) {
     }
     
     static class CustomException extends RuntimeException {
-		private static final long serialVersionUID = 6873927510089089979L;
+        private static final long serialVersionUID = 6873927510089089979L;
     }
 }

File: rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperatorSumTest.java
Patch:
@@ -354,6 +354,6 @@ public Double call(String t1) {
     }
 
     static class CustomException extends RuntimeException {
-		private static final long serialVersionUID = 8825937249852675778L;
+        private static final long serialVersionUID = 8825937249852675778L;
     }
 }

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java
Patch:
@@ -82,7 +82,7 @@ public static <T> Observable<T> from(ReceivePort<T> channel, Scheduler scheduler
      * @param <T>     the type of messages that can be sent to the channel and the type of items to be
      *                received by the Observer
      * @param channel the target {@link SendPort}
-     * @return
+     * @return the observer
      */
     public static <T> Observer<T> to(final SendPort<T> channel) {
         return new Observer<T>() {
@@ -116,7 +116,7 @@ public void onError(Throwable e) {
      * <p>
      * @param <T>        the type of messages emitted by the observable and received on the channel.
      * @param bufferSize the channel's buffer size
-     * @param policy     the channel's {@link Channels.OverflowPolicy OverflowPolicy}
+     * @param policy     the channel's {@link Channels.OverflowPolicy}
      * @param o          the observable
      * @return A new channel with the given buffer size and overflow policy that will receive all events emitted by the observable.
      */

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java
Patch:
@@ -73,7 +73,7 @@ public Subscription schedule(final Action0 action) {
             }
 
             final AtomicReference<Subscription> sf = new AtomicReference<Subscription>();
-            final Subscription s = Subscriptions.from(new Fiber(fiberScheduler, new SuspendableRunnable() {
+            final Subscription s = Subscriptions.from(new Fiber<Void>(fiberScheduler, new SuspendableRunnable() {
 
                 @Override
                 public void run() throws SuspendExecution {
@@ -109,7 +109,7 @@ public void call() {
         public Subscription schedule(final Action0 action, final long delayTime, final TimeUnit unit) {
             final AtomicReference<Subscription> sf = new AtomicReference<Subscription>();
 
-            final Subscription s = Subscriptions.from(new Fiber(fiberScheduler, new SuspendableRunnable() {
+            final Subscription s = Subscriptions.from(new Fiber<Void>(fiberScheduler, new SuspendableRunnable() {
 
                 @Override
                 public void run() throws InterruptedException, SuspendExecution  {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/schedulers/SwingScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/subscriptions/SwingSubscriptions.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/SwingTestHelper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/test/java/rx/schedulers/SwingSchedulerTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/functions/Actions.java
Patch:
@@ -30,6 +30,7 @@ public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> EmptyAction<T0, T1,
         return (EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>) EMPTY_ACTION;
     }
 
+    @SuppressWarnings("rawtypes")
     private static final EmptyAction EMPTY_ACTION = new EmptyAction();
 
     private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> implements

File: rxjava-core/src/main/java/rx/functions/Functions.java
Patch:
@@ -364,6 +364,7 @@ public static <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, R> NullFunction<T0, T1, T
         return (NullFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, R>) NULL_FUNCTION;
     }
 
+    @SuppressWarnings("rawtypes")
     private static final NullFunction NULL_FUNCTION = new NullFunction();
 
     private static final class NullFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, R> implements

File: rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java
Patch:
@@ -110,7 +110,6 @@ public void onError(Throwable e) {
     }
 
     @Override
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     public void onNext(T t) {
         state.observerRef.get().onNext(t);
     }

File: rxjava-core/src/main/java/rx/operators/OperatorBufferWithSingleObservable.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Observer;
@@ -81,7 +82,7 @@ public Subscriber<? super T> call(final Subscriber<? super List<T>> child) {
             child.onError(t);
             return Subscribers.empty();
         }
-        final BufferingSubscriber<T> bsub = new BufferingSubscriber<T>(new SerializedSubscriber<List<T>>(child));
+        final BufferingSubscriber bsub = new BufferingSubscriber(new SerializedSubscriber<List<T>>(child));
 
         Subscriber<TClosing> closingSubscriber = new Subscriber<TClosing>() {
 
@@ -109,7 +110,7 @@ public void onCompleted() {
         return bsub;
     }
     
-    final class BufferingSubscriber<T> extends Subscriber<T> {
+    final class BufferingSubscriber extends Subscriber<T> {
         final Subscriber<? super List<T>> child;
         /** Guarded by this. */
         List<T> chunk;

File: rxjava-core/src/main/java/rx/operators/OperatorBufferWithStartEndObservable.java
Patch:
@@ -32,7 +32,7 @@
  * values from the specified {@link Observable} source and stores them in the currently active chunks.
  * Initially there are no chunks active.
  * <p>
- * Chunks can be created by pushing a {@link rx.util.TOpening} value to the "bufferOpenings"
+ * Chunks can be created by pushing a {@code TOpening} value to the "bufferOpenings"
  * {@link Observable}. This creates a new buffer which will then start recording values which are produced
  * by the "source" {@link Observable}. Additionally the "bufferClosingSelector" will be used to construct an
  * {@link Observable} which can produce values. When it does so it will close this (and only this) newly
@@ -52,7 +52,7 @@ public final class OperatorBufferWithStartEndObservable<T, TOpening, TClosing> i
 
     /**
      * @param bufferOpenings
-     *            an {@link Observable} which when it produces a {@link rx.util.TOpening} value will create a
+     *            an {@link Observable} which when it produces a {@code TOpening} value will create a
      *            new buffer which instantly starts recording the "source" {@link Observable}
      * @param bufferClosingSelector
      *            a {@link Func1} object which produces {@link Observable}s. These {@link Observable}s determine

File: rxjava-core/src/main/java/rx/operators/OperatorMulticast.java
Patch:
@@ -15,7 +15,6 @@
  */
 package rx.operators;
 
-import java.util.BitSet;
 import rx.Observable;
 import rx.Subscriber;
 import rx.Subscription;

File: rxjava-core/src/main/java/rx/operators/OperatorOnErrorResumeNextViaObservable.java
Patch:
@@ -18,7 +18,6 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
-import rx.subscriptions.SerialSubscription;
 
 /**
  * Instruct an Observable to pass control to another Observable rather than invoking

File: rxjava-core/src/main/java/rx/operators/OperatorReplay.java
Patch:
@@ -276,7 +276,7 @@ public interface VirtualList<T> {
         /**
          * Returns the current content as a list.
          * 
-         * @return
+         * @return the {@link java.util.List} representation of this virtual list
          */
         List<T> toList();
     }

File: rxjava-core/src/main/java/rx/operators/OperatorSwitch.java
Patch:
@@ -42,7 +42,6 @@ public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super
         
         return new Subscriber<Observable<? extends T>>(child) {
             final Object guard = new Object();
-            final Subscriber<?> self = this;
             final NotificationLite<?> nl = NotificationLite.instance();
             /** Guarded by guard. */
             int index;

File: rxjava-core/src/main/java/rx/operators/OperatorZip.java
Patch:
@@ -134,7 +134,7 @@ public void onNext(Observable[] observables) {
         };
     }
 
-    static final NotificationLite on = NotificationLite.instance();
+    static final NotificationLite<Object> on = NotificationLite.instance();
     private static class Zip<R> {
         @SuppressWarnings("rawtypes")
         final Observable[] os;
@@ -199,6 +199,8 @@ void tick() {
                             // independently subscribed
                             childSubscription.unsubscribe();
                             return;
+                        default:
+                            // shouldn't get here
                         }
                     }
                     if (allHaveValues) {

File: rxjava-core/src/main/java/rx/schedulers/ImmediateScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/schedulers/Schedulers.java
Patch:
@@ -103,7 +103,7 @@ public static Scheduler computation() {
      * <p>
      * Do not perform computational work on this scheduler. Use {@link #computation()} instead.
      * 
-     * @return {@link ExecutorScheduler} for IO-bound work
+     * @return {@link Scheduler} for IO-bound work
      */
     public static Scheduler io() {
         return INSTANCE.ioScheduler;

File: rxjava-core/src/main/java/rx/schedulers/SleepingAction.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -19,9 +19,7 @@
 import java.util.Collection;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 
-import rx.Notification;
 import rx.Observer;
 import rx.functions.Action0;
 import rx.functions.Action1;

File: rxjava-core/src/test/java/rx/StartWithTests.java
Patch:
@@ -45,7 +45,7 @@ public void startWithIterable() {
         assertEquals("two", values.get(3));
     }
 
-	@Test
+    @Test
     public void startWithObservable() {
         List<String> li = new ArrayList<String>();
         li.add("alpha");

File: rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java
Patch:
@@ -21,7 +21,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -63,7 +62,6 @@ private Observer<String> serializedObserver(Observer<String> o) {
 
     @Test
     public void testSingleThreadedBasic() {
-        Subscription s = mock(Subscription.class);
         TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable("one", "two", "three");
         Observable<String> w = Observable.create(onSubscribe);
 
@@ -251,7 +249,6 @@ public void runConcurrencyTest() {
             }
 
             waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10);
-            @SuppressWarnings("unused")
             int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior
             assertEquals(173500, numNextEvents);
             // System.out.println("Number of events executed: " + numNextEvents);

File: rxjava-core/src/test/java/rx/operators/OperatorSkipWhileTest.java
Patch:
@@ -31,7 +31,7 @@
 import rx.functions.Func1;
 import rx.functions.Func2;
 
-public class OperationSkipWhileTest {
+public class OperatorSkipWhileTest {
 
     @SuppressWarnings("unchecked")
     Observer<Integer> w = mock(Observer.class);

File: rxjava-core/src/test/java/rx/operators/OperatorTakeWhileTest.java
Patch:
@@ -181,7 +181,7 @@ public Boolean call(String s, Integer index) {
         verify(s, times(1)).unsubscribe();
     }
 
-    private static class TestObservable implements Observable.OnSubscribeFunc<String> {
+    private static class TestObservable implements Observable.OnSubscribe<String> {
 
         final Subscription s;
         final String[] values;
@@ -193,8 +193,9 @@ public TestObservable(Subscription s, String... values) {
         }
 
         @Override
-        public Subscription onSubscribe(final Observer<? super String> observer) {
+        public void call(final Subscriber<? super String> observer) {
             System.out.println("TestObservable subscribed to ...");
+            observer.add(s);
             t = new Thread(new Runnable() {
 
                 @Override
@@ -215,7 +216,6 @@ public void run() {
             System.out.println("starting TestObservable thread");
             t.start();
             System.out.println("done starting TestObservable thread");
-            return s;
         }
     }
 }

File: rxjava-core/src/test/java/rx/operators/OperatorToMapTest.java
Patch:
@@ -162,6 +162,9 @@ public void testToMapWithFactory() {
             @Override
             public Map<Integer, String> call() {
                 return new LinkedHashMap<Integer, String>() {
+                    /** */
+                    private static final long serialVersionUID = -3296811238780863394L;
+
                     @Override
                     protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
                         return size() > 3;

File: rxjava-core/src/test/java/rx/operators/OperatorToMultimapTest.java
Patch:
@@ -106,6 +106,9 @@ public void testToMultimapWithMapFactory() {
             @Override
             public Map<Integer, Collection<String>> call() {
                 return new LinkedHashMap<Integer, Collection<String>>() {
+                    /** */
+                    private static final long serialVersionUID = -2084477070717362859L;
+
                     @Override
                     protected boolean removeEldestEntry(Map.Entry<Integer, Collection<String>> eldest) {
                         return size() > 2;

File: rxjava-core/src/test/java/rx/operators/OperatorZipCompletionTest.java
Patch:
@@ -33,7 +33,7 @@
  * the resulting Observable is finite.
  * 
  */
-public class OperationZipTestCompletion {
+public class OperatorZipCompletionTest {
     Func2<String, String, String> concat2Strings;
 
     PublishSubject<String> s1;

File: rxjava-core/src/test/java/rx/plugins/RxJavaPluginsTest.java
Patch:
@@ -68,7 +68,6 @@ public void testErrorHandlerViaProperty() {
     // inside test so it is stripped from Javadocs
     public static class RxJavaErrorHandlerTestImpl extends RxJavaErrorHandler {
 
-        @SuppressWarnings("unused")
         private volatile Throwable e;
         private volatile int count = 0;
 

File: rxjava-core/src/test/java/rx/schedulers/ComputationSchedulerTests.java
Patch:
@@ -91,8 +91,6 @@ public void call() {
 
     @Test
     public final void testComputationThreadPool1() {
-        final Scheduler scheduler = getScheduler();
-
         Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
         Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
         Observable<String> o = Observable.<Integer> merge(o1, o2).map(new Func1<Integer, String>() {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -884,7 +884,7 @@ public final static <T> Observable<T> concat(Observable<? extends T> t1, Observa
      *         Observable factory function
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-defer">RxJava Wiki: defer()</a>
      */
-    public final static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {
+    public final static <T> Observable<T> defer(Func0<Observable<? extends T>> observableFactory) {
         return create(new OperatorDefer<T>(observableFactory));
     }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -884,7 +884,7 @@ public final static <T> Observable<T> concat(Observable<? extends T> t1, Observa
      *         Observable factory function
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-defer">RxJava Wiki: defer()</a>
      */
-    public final static <T> Observable<T> defer(Func0<? extends Observable<? extends T>> observableFactory) {
+    public final static <T> Observable<T> defer(Func0<Observable<? extends T>> observableFactory) {
         return create(new OperatorDefer<T>(observableFactory));
     }
 

File: language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyOnSubscribeFuncWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -167,7 +167,7 @@ public String getName() {
             }
 
             @Override
-            public Class getReturnType() {
+            public Class<?> getReturnType() {
                 return m.getReturnType();
             }
 
@@ -177,6 +177,7 @@ public CachedClass getDeclaringClass() {
             }
 
             @Override
+            @SuppressWarnings("unchecked")
             public Object invoke(Object object, final Object[] arguments) {
                 return Observable.create(new GroovyCreateWrapper((Closure) arguments[0]));
             }

File: language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyPropertiesModuleFactory.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/AndroidSchedulers.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java
Patch:
@@ -27,7 +27,7 @@
 public class ViewObservable {
 
     public static <T extends View> Observable<T> clicks(final T view, final boolean emitInitialValue) {
-        return Observable.create(new OperatorViewClick(view, emitInitialValue));
+        return Observable.create(new OperatorViewClick<T>(view, emitInitialValue));
     }
 
     public static Observable<String> input(final EditText input, final boolean emitInitialValue) {

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/AndroidSchedulers.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorObserveFromAndroidComponent.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/observables/AndroidObservableTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperatorObserveFromAndroidComponentTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/schedulers/HandlerThreadSchedulerTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttpResponse.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ExpandableByteBuffer.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/Statement.java
Patch:
@@ -26,7 +26,7 @@
  * Imperative statements expressed as Observable operators.
  */
 public final class Statement {
-	private Statement() { throw new IllegalStateException("No instances!"); }
+    private Statement() { throw new IllegalStateException("No instances!"); }
     /**
      * Return a particular one of several possible Observables based on a case
      * selector.
@@ -94,7 +94,7 @@ public static <K, R> Observable<R> switchCase(Func0<? extends K> caseSelector,
      * @param mapOfCases
      *            a map that maps a case key to an Observable
      * @param defaultCase
-     *            the default Observable if the {@code mapOfCases} doesn't contain a value for the key returned by the {@case caseSelector}
+     *            the default Observable if the {@code mapOfCases} doesn't contain a value for the key returned by the {@code caseSelector}
      * @return a particular Observable chosen by key from the map of
      *         Observables, or the default case if no Observable matches the key
      */

File: rxjava-contrib/rxjava-joins/src/main/java/rx/joins/Pattern1.java
Patch:
@@ -38,7 +38,7 @@ public Observable<T1> first() {
      * 
      * @param selector
      *            the function that will be invoked for elements in the source sequences.
-     * @return
+     * @return the plan for the matching
      * @throws NullPointerException
      *             if selector is null
      */

File: rxjava-contrib/rxjava-joins/src/main/java/rx/joins/operators/OperatorJoinPatterns.java
Patch:
@@ -121,7 +121,7 @@ public void call(ActivePlan0 activePlan) {
                         }));
                     }
                 } catch (Throwable t) {
-                	Observable.<R> error(t).unsafeSubscribe(t1);
+                    Observable.<R> error(t).unsafeSubscribe(t1);
                     return;
                 }
                 CompositeSubscription group = new CompositeSubscription();

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageDouble.java
Patch:
@@ -35,7 +35,7 @@ public OperatorAverageDouble(Func1<? super T, Double> valueExtractor) {
 
     @Override
     public Subscriber<? super T> call(Subscriber<? super Double> child) {
-    	return new AverageObserver(child);
+        return new AverageObserver(child);
     }
 
     /** Computes the average. */
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Double> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageFloat.java
Patch:
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Float> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageInteger.java
Patch:
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Integer> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageLong.java
Patch:
@@ -45,7 +45,7 @@ private final class AverageObserver extends Subscriber<T> {
         int count;
 
         public AverageObserver(Subscriber<? super Long> subscriber) {
-        	super(subscriber);
+            super(subscriber);
             this.child = subscriber;
         }
 

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorMinMax.java
Patch:
@@ -27,7 +27,7 @@
  * Returns the minimum element in an observable sequence.
  */
 public final class OperatorMinMax {
-	private OperatorMinMax() { throw new IllegalStateException("No instances!"); }
+    private OperatorMinMax() { throw new IllegalStateException("No instances!"); }
 
     public static <T extends Comparable<? super T>> Observable<T> min(
             Observable<T> source) {

File: rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorSum.java
Patch:
@@ -26,7 +26,7 @@
  *      Observable.Sum</a>
  */
 public final class OperatorSum {
-	private OperatorSum() { throw new IllegalStateException("No instances!"); }
+    private OperatorSum() { throw new IllegalStateException("No instances!"); }
 
     public static Observable<Integer> sumIntegers(Observable<Integer> source) {
         return source.reduce(0, ACCUM_INT);

File: rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperatorAverageTest.java
Patch:
@@ -358,6 +358,6 @@ public Double call(String t1) {
     }
     
     static class CustomException extends RuntimeException {
-		private static final long serialVersionUID = 6873927510089089979L;
+        private static final long serialVersionUID = 6873927510089089979L;
     }
 }

File: rxjava-contrib/rxjava-math/src/test/java/rx/math/operators/OperatorSumTest.java
Patch:
@@ -354,6 +354,6 @@ public Double call(String t1) {
     }
 
     static class CustomException extends RuntimeException {
-		private static final long serialVersionUID = 8825937249852675778L;
+        private static final long serialVersionUID = 8825937249852675778L;
     }
 }

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java
Patch:
@@ -82,7 +82,7 @@ public static <T> Observable<T> from(ReceivePort<T> channel, Scheduler scheduler
      * @param <T>     the type of messages that can be sent to the channel and the type of items to be
      *                received by the Observer
      * @param channel the target {@link SendPort}
-     * @return
+     * @return the observer
      */
     public static <T> Observer<T> to(final SendPort<T> channel) {
         return new Observer<T>() {
@@ -116,7 +116,7 @@ public void onError(Throwable e) {
      * <p>
      * @param <T>        the type of messages emitted by the observable and received on the channel.
      * @param bufferSize the channel's buffer size
-     * @param policy     the channel's {@link Channels.OverflowPolicy OverflowPolicy}
+     * @param policy     the channel's {@link Channels.OverflowPolicy}
      * @param o          the observable
      * @return A new channel with the given buffer size and overflow policy that will receive all events emitted by the observable.
      */

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java
Patch:
@@ -73,7 +73,7 @@ public Subscription schedule(final Action0 action) {
             }
 
             final AtomicReference<Subscription> sf = new AtomicReference<Subscription>();
-            final Subscription s = Subscriptions.from(new Fiber(fiberScheduler, new SuspendableRunnable() {
+            final Subscription s = Subscriptions.from(new Fiber<Void>(fiberScheduler, new SuspendableRunnable() {
 
                 @Override
                 public void run() throws SuspendExecution {
@@ -109,7 +109,7 @@ public void call() {
         public Subscription schedule(final Action0 action, final long delayTime, final TimeUnit unit) {
             final AtomicReference<Subscription> sf = new AtomicReference<Subscription>();
 
-            final Subscription s = Subscriptions.from(new Fiber(fiberScheduler, new SuspendableRunnable() {
+            final Subscription s = Subscriptions.from(new Fiber<Void>(fiberScheduler, new SuspendableRunnable() {
 
                 @Override
                 public void run() throws InterruptedException, SuspendExecution  {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/schedulers/SwingScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/subscriptions/SwingSubscriptions.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/SwingTestHelper.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-contrib/rxjava-swing/src/test/java/rx/schedulers/SwingSchedulerTest.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/functions/Actions.java
Patch:
@@ -30,6 +30,7 @@ public static final <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> EmptyAction<T0, T1,
         return (EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>) EMPTY_ACTION;
     }
 
+    @SuppressWarnings("rawtypes")
     private static final EmptyAction EMPTY_ACTION = new EmptyAction();
 
     private static final class EmptyAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> implements

File: rxjava-core/src/main/java/rx/functions/Functions.java
Patch:
@@ -364,6 +364,7 @@ public static <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, R> NullFunction<T0, T1, T
         return (NullFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, R>) NULL_FUNCTION;
     }
 
+    @SuppressWarnings("rawtypes")
     private static final NullFunction NULL_FUNCTION = new NullFunction();
 
     private static final class NullFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, R> implements

File: rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java
Patch:
@@ -110,7 +110,6 @@ public void onError(Throwable e) {
     }
 
     @Override
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     public void onNext(T t) {
         state.observerRef.get().onNext(t);
     }

File: rxjava-core/src/main/java/rx/operators/OperatorBufferWithSingleObservable.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Observer;
@@ -81,7 +82,7 @@ public Subscriber<? super T> call(final Subscriber<? super List<T>> child) {
             child.onError(t);
             return Subscribers.empty();
         }
-        final BufferingSubscriber<T> bsub = new BufferingSubscriber<T>(new SerializedSubscriber<List<T>>(child));
+        final BufferingSubscriber bsub = new BufferingSubscriber(new SerializedSubscriber<List<T>>(child));
 
         Subscriber<TClosing> closingSubscriber = new Subscriber<TClosing>() {
 
@@ -109,7 +110,7 @@ public void onCompleted() {
         return bsub;
     }
     
-    final class BufferingSubscriber<T> extends Subscriber<T> {
+    final class BufferingSubscriber extends Subscriber<T> {
         final Subscriber<? super List<T>> child;
         /** Guarded by this. */
         List<T> chunk;

File: rxjava-core/src/main/java/rx/operators/OperatorBufferWithStartEndObservable.java
Patch:
@@ -32,7 +32,7 @@
  * values from the specified {@link Observable} source and stores them in the currently active chunks.
  * Initially there are no chunks active.
  * <p>
- * Chunks can be created by pushing a {@link rx.util.TOpening} value to the "bufferOpenings"
+ * Chunks can be created by pushing a {@code TOpening} value to the "bufferOpenings"
  * {@link Observable}. This creates a new buffer which will then start recording values which are produced
  * by the "source" {@link Observable}. Additionally the "bufferClosingSelector" will be used to construct an
  * {@link Observable} which can produce values. When it does so it will close this (and only this) newly
@@ -52,7 +52,7 @@ public final class OperatorBufferWithStartEndObservable<T, TOpening, TClosing> i
 
     /**
      * @param bufferOpenings
-     *            an {@link Observable} which when it produces a {@link rx.util.TOpening} value will create a
+     *            an {@link Observable} which when it produces a {@code TOpening} value will create a
      *            new buffer which instantly starts recording the "source" {@link Observable}
      * @param bufferClosingSelector
      *            a {@link Func1} object which produces {@link Observable}s. These {@link Observable}s determine

File: rxjava-core/src/main/java/rx/operators/OperatorMulticast.java
Patch:
@@ -15,7 +15,6 @@
  */
 package rx.operators;
 
-import java.util.BitSet;
 import rx.Observable;
 import rx.Subscriber;
 import rx.Subscription;

File: rxjava-core/src/main/java/rx/operators/OperatorOnErrorResumeNextViaObservable.java
Patch:
@@ -18,7 +18,6 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Subscriber;
-import rx.subscriptions.SerialSubscription;
 
 /**
  * Instruct an Observable to pass control to another Observable rather than invoking

File: rxjava-core/src/main/java/rx/operators/OperatorReplay.java
Patch:
@@ -276,7 +276,7 @@ public interface VirtualList<T> {
         /**
          * Returns the current content as a list.
          * 
-         * @return
+         * @return the {@link java.util.List} representation of this virtual list
          */
         List<T> toList();
     }

File: rxjava-core/src/main/java/rx/operators/OperatorSwitch.java
Patch:
@@ -42,7 +42,6 @@ public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super
         
         return new Subscriber<Observable<? extends T>>(child) {
             final Object guard = new Object();
-            final Subscriber<?> self = this;
             final NotificationLite<?> nl = NotificationLite.instance();
             /** Guarded by guard. */
             int index;

File: rxjava-core/src/main/java/rx/operators/OperatorZip.java
Patch:
@@ -134,7 +134,7 @@ public void onNext(Observable[] observables) {
         };
     }
 
-    static final NotificationLite on = NotificationLite.instance();
+    static final NotificationLite<Object> on = NotificationLite.instance();
     private static class Zip<R> {
         @SuppressWarnings("rawtypes")
         final Observable[] os;
@@ -199,6 +199,8 @@ void tick() {
                             // independently subscribed
                             childSubscription.unsubscribe();
                             return;
+                        default:
+                            // shouldn't get here
                         }
                     }
                     if (allHaveValues) {

File: rxjava-core/src/main/java/rx/schedulers/ImmediateScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/schedulers/Schedulers.java
Patch:
@@ -103,7 +103,7 @@ public static Scheduler computation() {
      * <p>
      * Do not perform computational work on this scheduler. Use {@link #computation()} instead.
      * 
-     * @return {@link ExecutorScheduler} for IO-bound work
+     * @return {@link Scheduler} for IO-bound work
      */
     public static Scheduler io() {
         return INSTANCE.ioScheduler;

File: rxjava-core/src/main/java/rx/schedulers/SleepingAction.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 Netflix, Inc.
+ * Copyright 2014 Netflix, Inc.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -19,9 +19,7 @@
 import java.util.Collection;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 
-import rx.Notification;
 import rx.Observer;
 import rx.functions.Action0;
 import rx.functions.Action1;

File: rxjava-core/src/test/java/rx/StartWithTests.java
Patch:
@@ -45,7 +45,7 @@ public void startWithIterable() {
         assertEquals("two", values.get(3));
     }
 
-	@Test
+    @Test
     public void startWithObservable() {
         List<String> li = new ArrayList<String>();
         li.add("alpha");

File: rxjava-core/src/test/java/rx/observers/SerializedObserverTest.java
Patch:
@@ -21,7 +21,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -63,7 +62,6 @@ private Observer<String> serializedObserver(Observer<String> o) {
 
     @Test
     public void testSingleThreadedBasic() {
-        Subscription s = mock(Subscription.class);
         TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable("one", "two", "three");
         Observable<String> w = Observable.create(onSubscribe);
 
@@ -251,7 +249,6 @@ public void runConcurrencyTest() {
             }
 
             waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10);
-            @SuppressWarnings("unused")
             int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior
             assertEquals(173500, numNextEvents);
             // System.out.println("Number of events executed: " + numNextEvents);

File: rxjava-core/src/test/java/rx/operators/OperatorSkipWhileTest.java
Patch:
@@ -31,7 +31,7 @@
 import rx.functions.Func1;
 import rx.functions.Func2;
 
-public class OperationSkipWhileTest {
+public class OperatorSkipWhileTest {
 
     @SuppressWarnings("unchecked")
     Observer<Integer> w = mock(Observer.class);

File: rxjava-core/src/test/java/rx/operators/OperatorTakeWhileTest.java
Patch:
@@ -181,7 +181,7 @@ public Boolean call(String s, Integer index) {
         verify(s, times(1)).unsubscribe();
     }
 
-    private static class TestObservable implements Observable.OnSubscribeFunc<String> {
+    private static class TestObservable implements Observable.OnSubscribe<String> {
 
         final Subscription s;
         final String[] values;
@@ -193,8 +193,9 @@ public TestObservable(Subscription s, String... values) {
         }
 
         @Override
-        public Subscription onSubscribe(final Observer<? super String> observer) {
+        public void call(final Subscriber<? super String> observer) {
             System.out.println("TestObservable subscribed to ...");
+            observer.add(s);
             t = new Thread(new Runnable() {
 
                 @Override
@@ -215,7 +216,6 @@ public void run() {
             System.out.println("starting TestObservable thread");
             t.start();
             System.out.println("done starting TestObservable thread");
-            return s;
         }
     }
 }

File: rxjava-core/src/test/java/rx/operators/OperatorToMapTest.java
Patch:
@@ -162,6 +162,9 @@ public void testToMapWithFactory() {
             @Override
             public Map<Integer, String> call() {
                 return new LinkedHashMap<Integer, String>() {
+                    /** */
+                    private static final long serialVersionUID = -3296811238780863394L;
+
                     @Override
                     protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
                         return size() > 3;

File: rxjava-core/src/test/java/rx/operators/OperatorToMultimapTest.java
Patch:
@@ -106,6 +106,9 @@ public void testToMultimapWithMapFactory() {
             @Override
             public Map<Integer, Collection<String>> call() {
                 return new LinkedHashMap<Integer, Collection<String>>() {
+                    /** */
+                    private static final long serialVersionUID = -2084477070717362859L;
+
                     @Override
                     protected boolean removeEldestEntry(Map.Entry<Integer, Collection<String>> eldest) {
                         return size() > 2;

File: rxjava-core/src/test/java/rx/operators/OperatorZipCompletionTest.java
Patch:
@@ -33,7 +33,7 @@
  * the resulting Observable is finite.
  * 
  */
-public class OperationZipTestCompletion {
+public class OperatorZipCompletionTest {
     Func2<String, String, String> concat2Strings;
 
     PublishSubject<String> s1;

File: rxjava-core/src/test/java/rx/plugins/RxJavaPluginsTest.java
Patch:
@@ -68,7 +68,6 @@ public void testErrorHandlerViaProperty() {
     // inside test so it is stripped from Javadocs
     public static class RxJavaErrorHandlerTestImpl extends RxJavaErrorHandler {
 
-        @SuppressWarnings("unused")
         private volatile Throwable e;
         private volatile int count = 0;
 

File: rxjava-core/src/test/java/rx/schedulers/ComputationSchedulerTests.java
Patch:
@@ -91,8 +91,6 @@ public void call() {
 
     @Test
     public final void testComputationThreadPool1() {
-        final Scheduler scheduler = getScheduler();
-
         Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
         Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
         Observable<String> o = Observable.<Integer> merge(o1, o2).map(new Func1<Integer, String>() {

File: rxjava-core/src/main/java/rx/operators/OperatorSampleWithTime.java
Patch:
@@ -80,6 +80,7 @@ public void onError(Throwable e) {
         @Override
         public void onCompleted() {
             subscriber.onCompleted();
+            unsubscribe();
         }
 
         @Override

File: rxjava-core/src/main/java/rx/operators/OperatorSampleWithTime.java
Patch:
@@ -80,6 +80,7 @@ public void onError(Throwable e) {
         @Override
         public void onCompleted() {
             subscriber.onCompleted();
+            unsubscribe();
         }
 
         @Override

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -49,7 +49,6 @@
 import rx.operators.OnSubscribeFromIterable;
 import rx.operators.OnSubscribeRange;
 import rx.operators.OperationDelay;
-import rx.operators.OperationOnErrorReturn;
 import rx.operators.OperationOnExceptionResumeNextViaObservable;
 import rx.operators.OperationParallelMerge;
 import rx.operators.OperationSequenceEqual;
@@ -103,6 +102,7 @@
 import rx.operators.OperatorOnErrorFlatMap;
 import rx.operators.OperatorOnErrorResumeNextViaFunction;
 import rx.operators.OperatorOnErrorResumeNextViaObservable;
+import rx.operators.OperatorOnErrorReturn;
 import rx.operators.OperatorParallel;
 import rx.operators.OperatorPivot;
 import rx.operators.OperatorRepeat;
@@ -4539,7 +4539,7 @@ public final Observable<T> onErrorResumeNext(final Observable<? extends T> resum
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-onerrorreturn">RxJava Wiki: onErrorReturn()</a>
      */
     public final Observable<T> onErrorReturn(Func1<Throwable, ? extends T> resumeFunction) {
-        return create(OperationOnErrorReturn.onErrorReturn(this, resumeFunction));
+        return lift(new OperatorOnErrorReturn<T>(resumeFunction));
     }
 
     /**

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -49,7 +49,6 @@
 import rx.operators.OnSubscribeFromIterable;
 import rx.operators.OnSubscribeRange;
 import rx.operators.OperationDelay;
-import rx.operators.OperationOnErrorResumeNextViaObservable;
 import rx.operators.OperationOnErrorReturn;
 import rx.operators.OperationOnExceptionResumeNextViaObservable;
 import rx.operators.OperationParallelMerge;
@@ -103,6 +102,7 @@
 import rx.operators.OperatorObserveOn;
 import rx.operators.OperatorOnErrorFlatMap;
 import rx.operators.OperatorOnErrorResumeNextViaFunction;
+import rx.operators.OperatorOnErrorResumeNextViaObservable;
 import rx.operators.OperatorParallel;
 import rx.operators.OperatorPivot;
 import rx.operators.OperatorRepeat;
@@ -4515,7 +4515,7 @@ public final Observable<T> onErrorResumeNext(final Func1<Throwable, ? extends Ob
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-onerrorresumenext">RxJava Wiki: onErrorResumeNext()</a>
      */
     public final Observable<T> onErrorResumeNext(final Observable<? extends T> resumeSequence) {
-        return create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(this, resumeSequence));
+        return lift(new OperatorOnErrorResumeNextViaObservable<T>(resumeSequence));
     }
 
     /**

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -58,7 +58,6 @@
 import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperationMulticast;
 import rx.operators.OperationOnErrorResumeNextViaObservable;
-import rx.operators.OperationOnErrorReturn;
 import rx.operators.OperationOnExceptionResumeNextViaObservable;
 import rx.operators.OperationParallelMerge;
 import rx.operators.OperationReplay;
@@ -108,6 +107,7 @@
 import rx.operators.OperatorObserveOn;
 import rx.operators.OperatorOnErrorFlatMap;
 import rx.operators.OperatorOnErrorResumeNextViaFunction;
+import rx.operators.OperatorOnErrorReturn;
 import rx.operators.OperatorParallel;
 import rx.operators.OperatorPivot;
 import rx.operators.OperatorRepeat;
@@ -4547,7 +4547,7 @@ public final Observable<T> onErrorResumeNext(final Observable<? extends T> resum
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-onerrorreturn">RxJava Wiki: onErrorReturn()</a>
      */
     public final Observable<T> onErrorReturn(Func1<Throwable, ? extends T> resumeFunction) {
-        return create(OperationOnErrorReturn.onErrorReturn(this, resumeFunction));
+        return lift(new OperatorOnErrorReturn<T>(resumeFunction));
     }
 
     /**

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -57,7 +57,6 @@
 import rx.operators.OperationMergeDelayError;
 import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperationMulticast;
-import rx.operators.OperationOnErrorResumeNextViaObservable;
 import rx.operators.OperationOnErrorReturn;
 import rx.operators.OperationOnExceptionResumeNextViaObservable;
 import rx.operators.OperationParallelMerge;
@@ -108,6 +107,7 @@
 import rx.operators.OperatorObserveOn;
 import rx.operators.OperatorOnErrorFlatMap;
 import rx.operators.OperatorOnErrorResumeNextViaFunction;
+import rx.operators.OperatorOnErrorResumeNextViaObservable;
 import rx.operators.OperatorParallel;
 import rx.operators.OperatorPivot;
 import rx.operators.OperatorRepeat;
@@ -4523,7 +4523,7 @@ public final Observable<T> onErrorResumeNext(final Func1<Throwable, ? extends Ob
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-onerrorresumenext">RxJava Wiki: onErrorResumeNext()</a>
      */
     public final Observable<T> onErrorResumeNext(final Observable<? extends T> resumeSequence) {
-        return create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(this, resumeSequence));
+        return lift(new OperatorOnErrorResumeNextViaObservable<T>(resumeSequence));
     }
 
     /**

File: rxjava-core/src/test/java/rx/operators/OperatorMergeDelayErrorTest.java
Patch:
@@ -457,10 +457,10 @@ public void testMergeSourceWhichDoesntPropagateExceptionBack() {
             public void call(Subscriber<? super Integer> t1) {
                 try {
                     t1.onNext(0);
-                    t1.onNext(1);
                 } catch (Throwable swallow) {
                     
                 }
+                t1.onNext(1);
                 t1.onCompleted();
             }
         });

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -49,7 +49,6 @@
 import rx.operators.OnSubscribeFromIterable;
 import rx.operators.OnSubscribeRange;
 import rx.operators.OperationDebounce;
-import rx.operators.OperationDefaultIfEmpty;
 import rx.operators.OperationDefer;
 import rx.operators.OperationDelay;
 import rx.operators.OperationDematerialize;
@@ -98,6 +97,7 @@
 import rx.operators.OperatorCast;
 import rx.operators.OperatorCombineLatest;
 import rx.operators.OperatorConcat;
+import rx.operators.OperatorDefaultIfEmpty;
 import rx.operators.OperatorDoOnEach;
 import rx.operators.OperatorElementAt;
 import rx.operators.OperatorFilter;
@@ -3469,7 +3469,7 @@ public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler sched
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229624.aspx">MSDN: Observable.DefaultIfEmpty</a>
      */
     public final Observable<T> defaultIfEmpty(T defaultValue) {
-        return create(OperationDefaultIfEmpty.defaultIfEmpty(this, defaultValue));
+        return lift(new OperatorDefaultIfEmpty<T>(defaultValue));
     }
 
     /**

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -52,7 +52,6 @@
 import rx.operators.OperationCombineLatest;
 import rx.operators.OperationConcat;
 import rx.operators.OperationDebounce;
-import rx.operators.OperationDefaultIfEmpty;
 import rx.operators.OperationDefer;
 import rx.operators.OperationDelay;
 import rx.operators.OperationDematerialize;
@@ -95,6 +94,7 @@
 import rx.operators.OperatorAsObservable;
 import rx.operators.OperatorCache;
 import rx.operators.OperatorCast;
+import rx.operators.OperatorDefaultIfEmpty;
 import rx.operators.OperatorDoOnEach;
 import rx.operators.OperatorElementAt;
 import rx.operators.OperatorFilter;
@@ -3450,7 +3450,7 @@ public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler sched
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229624.aspx">MSDN: Observable.DefaultIfEmpty</a>
      */
     public final Observable<T> defaultIfEmpty(T defaultValue) {
-        return create(OperationDefaultIfEmpty.defaultIfEmpty(this, defaultValue));
+        return lift(new OperatorDefaultIfEmpty<T>(defaultValue));
     }
 
     /**

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java
Patch:
@@ -43,11 +43,11 @@ public HandlerThreadScheduler(Handler handler) {
     }
 
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new InnerHandlerThreadScheduler(handler);
     }
     
-    private static class InnerHandlerThreadScheduler extends Inner {
+    private static class InnerHandlerThreadScheduler extends Worker {
 
         private final Handler handler;
         private BooleanSubscription innerSubscription = new BooleanSubscription();

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/subscriptions/AndroidSubscriptions.java
Patch:
@@ -15,7 +15,7 @@
  */
 package rx.android.subscriptions;
 
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscription;
 import rx.android.schedulers.AndroidSchedulers;
 import rx.functions.Action0;
@@ -42,7 +42,7 @@ public void call() {
                 if (Looper.getMainLooper() == Looper.myLooper()) {
                     unsubscribe.call();
                 } else {
-                    final Inner inner = AndroidSchedulers.mainThread().createInner();
+                    final Worker inner = AndroidSchedulers.mainThread().createWorker();
                     inner.schedule(new Action0() {
                         @Override
                         public void call() {

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/schedulers/HandlerThreadSchedulerTest.java
Patch:
@@ -29,7 +29,7 @@
 import org.robolectric.annotation.Config;
 
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.functions.Action0;
 import rx.functions.Action1;
 import android.os.Handler;
@@ -45,7 +45,7 @@ public void shouldScheduleImmediateActionOnHandlerThread() {
         final Action0 action = mock(Action0.class);
 
         Scheduler scheduler = new HandlerThreadScheduler(handler);
-        Inner inner = scheduler.createInner();
+        Worker inner = scheduler.createWorker();
         inner.schedule(action);
 
         // verify that we post to the given Handler
@@ -64,7 +64,7 @@ public void shouldScheduleDelayedActionOnHandlerThread() {
         final Action0 action = mock(Action0.class);
 
         Scheduler scheduler = new HandlerThreadScheduler(handler);
-        Inner inner = scheduler.createInner();
+        Worker inner = scheduler.createWorker();
         inner.schedule(action, 1L, TimeUnit.SECONDS);
 
         // verify that we post to the given Handler

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java
Patch:
@@ -54,12 +54,12 @@ private NewFiberScheduler() {
     }
     
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new EventLoopScheduler();
     }
 
 
-    private class EventLoopScheduler extends Scheduler.Inner implements Subscription {
+    private class EventLoopScheduler extends Scheduler.Worker implements Subscription {
         private final CompositeSubscription innerSubscription = new CompositeSubscription();
 
         private EventLoopScheduler() {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/schedulers/SwingScheduler.java
Patch:
@@ -44,11 +44,11 @@ public static SwingScheduler getInstance() {
     }
 
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new InnerSwingScheduler();
     }
 
-    private static class InnerSwingScheduler extends Inner {
+    private static class InnerSwingScheduler extends Worker {
 
         private final CompositeSubscription innerSubscription = new CompositeSubscription();
 

File: rxjava-contrib/rxjava-swing/src/main/java/rx/subscriptions/SwingSubscriptions.java
Patch:
@@ -17,7 +17,7 @@
 
 import javax.swing.SwingUtilities;
 
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.schedulers.SwingScheduler;
@@ -41,7 +41,7 @@ public void call() {
                 if (SwingUtilities.isEventDispatchThread()) {
                     unsubscribe.call();
                 } else {
-                    final Inner inner = SwingScheduler.getInstance().createInner();
+                    final Worker inner = SwingScheduler.getInstance().createWorker();
                     inner.schedule(new Action0() {
                         @Override
                         public void call() {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/SwingTestHelper.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.functions.Action0;
 import rx.schedulers.SwingScheduler;
 
@@ -35,7 +35,7 @@ public static SwingTestHelper create() {
     }
 
     public SwingTestHelper runInEventDispatchThread(final Action0 action) {
-        Inner inner = SwingScheduler.getInstance().createInner();
+        Worker inner = SwingScheduler.getInstance().createWorker();
         inner.schedule(new Action0() {
 
             @Override

File: rxjava-core/src/main/java/rx/operators/OperationDebounce.java
Patch:
@@ -104,7 +104,7 @@ private static class DebounceObserver<T> extends Subscriber<T> {
         private final Observer<? super T> observer;
         private final long timeout;
         private final TimeUnit unit;
-        private final Scheduler.Inner scheduler;
+        private final Scheduler.Worker scheduler;
 
         private final AtomicReference<Subscription> lastScheduledNotification = new AtomicReference<Subscription>();
 
@@ -114,7 +114,7 @@ public DebounceObserver(Observer<? super T> observer, long timeout, TimeUnit uni
             this.observer = new SerializedObserver<T>(observer);
             this.timeout = timeout;
             this.unit = unit;
-            this.scheduler = scheduler.createInner();
+            this.scheduler = scheduler.createWorker();
         }
 
         @Override

File: rxjava-core/src/main/java/rx/operators/OperationDelay.java
Patch:
@@ -61,13 +61,13 @@ public static <T> OnSubscribeFunc<T> delaySubscription(Observable<? extends T> s
     /** Subscribe function which schedules the actual subscription to source on a scheduler at a later time. */
     private static final class DelaySubscribeFunc<T> implements OnSubscribeFunc<T> {
         final Observable<? extends T> source;
-        final Scheduler.Inner scheduler;
+        final Scheduler.Worker scheduler;
         final long time;
         final TimeUnit unit;
 
         public DelaySubscribeFunc(Observable<? extends T> source, long time, TimeUnit unit, Scheduler scheduler) {
             this.source = source;
-            this.scheduler = scheduler.createInner();
+            this.scheduler = scheduler.createWorker();
             this.time = time;
             this.unit = unit;
         }

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -20,7 +20,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.schedulers.Schedulers;
@@ -66,7 +66,7 @@ private Interval(long period, TimeUnit unit, Scheduler scheduler) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Long> observer) {
-            Inner inner = scheduler.createInner();
+            Worker inner = scheduler.createWorker();
             inner.schedulePeriodically(new Action0() {
                 @Override
                 public void call() {

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -22,7 +22,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action0;
@@ -60,7 +60,7 @@ public SkipTimed(Observable<? extends T> source, long time, TimeUnit unit, Sched
 
         @Override
         public Subscription onSubscribe(Observer<? super T> t1) {
-            Inner inner = scheduler.createInner();
+            Worker inner = scheduler.createWorker();
             CompositeSubscription csub = new CompositeSubscription(inner);
             final SourceObserver<T> so = new SourceObserver<T>(t1, csub);
             csub.add(so);

File: rxjava-core/src/main/java/rx/operators/OperationTakeTimed.java
Patch:
@@ -22,7 +22,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action0;
@@ -191,7 +191,7 @@ public TakeTimed(Observable<? extends T> source, long time, TimeUnit unit, Sched
 
         @Override
         public Subscription onSubscribe(Observer<? super T> t1) {
-            Inner inner = scheduler.createInner();
+            Worker inner = scheduler.createWorker();
             CompositeSubscription csub = new CompositeSubscription(inner);
             final SourceObserver<T> so = new SourceObserver<T>(t1, csub);
             csub.add(so);

File: rxjava-core/src/main/java/rx/operators/OperationTimer.java
Patch:
@@ -20,7 +20,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscription;
 import rx.functions.Action0;
 
@@ -50,7 +50,7 @@ public TimerOnce(long dueTime, TimeUnit unit, Scheduler scheduler) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Long> t1) {
-            return scheduler.createInner().schedule(new Action0() {
+            return scheduler.createWorker().schedule(new Action0() {
                 @Override
                 public void call() {
                     t1.onNext(0L);
@@ -79,7 +79,7 @@ public TimerPeriodically(long initialDelay, long period, TimeUnit unit, Schedule
 
         @Override
         public Subscription onSubscribe(final Observer<? super Long> t1) {
-            Inner inner = scheduler.createInner();
+            Worker inner = scheduler.createWorker();
             inner.schedulePeriodically(new Action0() {
                 long count;
 

File: rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java
Patch:
@@ -58,15 +58,15 @@ public Subscriber<? super T> call(Subscriber<? super T> child) {
     private static class ObserveOnSubscriber<T> extends Subscriber<T> {
         private final NotificationLite<T> on = NotificationLite.instance();
         final Subscriber<? super T> observer;
-        private final Scheduler.Inner recursiveScheduler;
+        private final Scheduler.Worker recursiveScheduler;
 
         private final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
         final AtomicLong counter = new AtomicLong(0);
 
         public ObserveOnSubscriber(Scheduler scheduler, Subscriber<? super T> subscriber) {
             super(subscriber);
             this.observer = subscriber;
-            this.recursiveScheduler = scheduler.createInner();
+            this.recursiveScheduler = scheduler.createWorker();
             subscriber.add(recursiveScheduler);
         }
 

File: rxjava-core/src/main/java/rx/operators/OperatorRepeat.java
Patch:
@@ -19,7 +19,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscriber;
 import rx.functions.Action0;
 import rx.observers.Subscribers;
@@ -71,7 +71,7 @@ public void onError(Throwable e) {
             @Override
             public void onNext(final Observable<T> t) {
                 // will only be invoked once since we're nested
-                final Inner inner = scheduler.createInner();
+                final Worker inner = scheduler.createWorker();
                 // cleanup on unsubscribe
                 add(inner);
                 inner.schedule(new Action0() {

File: rxjava-core/src/main/java/rx/operators/OperatorRetry.java
Patch:
@@ -59,7 +59,7 @@ public OperatorRetry() {
 
     @Override
     public Subscriber<? super Observable<T>> call(final Subscriber<? super T> child) {
-        final Scheduler.Inner inner = scheduler.createInner();
+        final Scheduler.Worker inner = scheduler.createWorker();
         child.add(inner);
         
         final SerialSubscription serialSubscription = new SerialSubscription();

File: rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java
Patch:
@@ -18,7 +18,7 @@
 import rx.Observable;
 import rx.Observable.Operator;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscriber;
 import rx.functions.Action0;
 
@@ -37,7 +37,7 @@ public OperatorSubscribeOn(Scheduler scheduler) {
 
     @Override
     public Subscriber<? super Observable<T>> call(final Subscriber<? super T> subscriber) {
-        final Inner inner = scheduler.createInner();
+        final Worker inner = scheduler.createWorker();
         subscriber.add(inner);
         return new Subscriber<Observable<T>>(subscriber) {
 

File: rxjava-core/src/main/java/rx/operators/OperatorTimeout.java
Patch:
@@ -35,7 +35,7 @@ public OperatorTimeout(final long timeout, final TimeUnit timeUnit, Observable<?
         super(new FirstTimeoutStub<T>() {
 
             @Override
-            public Subscription call(final TimeoutSubscriber<T> timeoutSubscriber, final Long seqId, Scheduler.Inner inner) {
+            public Subscription call(final TimeoutSubscriber<T> timeoutSubscriber, final Long seqId, Scheduler.Worker inner) {
                 return inner.schedule(new Action0() {
                     @Override
                     public void call() {
@@ -46,7 +46,7 @@ public void call() {
         }, new TimeoutStub<T>() {
 
             @Override
-            public Subscription call(final TimeoutSubscriber<T> timeoutSubscriber, final Long seqId, T value, Scheduler.Inner inner) {
+            public Subscription call(final TimeoutSubscriber<T> timeoutSubscriber, final Long seqId, T value, Scheduler.Worker inner) {
                 return inner.schedule(new Action0() {
                     @Override
                     public void call() {

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutWithSelector.java
Patch:
@@ -43,7 +43,7 @@ public OperatorTimeoutWithSelector(
             @Override
             public Subscription call(
                     final TimeoutSubscriber<T> timeoutSubscriber,
-                    final Long seqId, Scheduler.Inner inner) {
+                    final Long seqId, Scheduler.Worker inner) {
                 if (firstTimeoutSelector != null) {
                     Observable<U> o = null;
                     try {
@@ -80,7 +80,7 @@ public void onNext(U t) {
             @Override
             public Subscription call(
                     final TimeoutSubscriber<T> timeoutSubscriber,
-                    final Long seqId, T value, Scheduler.Inner inner) {
+                    final Long seqId, T value, Scheduler.Worker inner) {
                 Observable<V> o = null;
                 try {
                     o = timeoutSelector.call(value);

File: rxjava-core/src/main/java/rx/operators/OperatorUnsubscribeOn.java
Patch:
@@ -41,7 +41,7 @@ public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {
 
             @Override
             public void call() {
-                final Scheduler.Inner inner = scheduler.createInner();
+                final Scheduler.Worker inner = scheduler.createWorker();
                 inner.schedule(new Action0() {
 
                     @Override

File: rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java
Patch:
@@ -48,11 +48,11 @@ public EventLoopScheduler getEventLoop() {
     }
 
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new EventLoop();
     }
 
-    private static class EventLoop extends Scheduler.Inner {
+    private static class EventLoop extends Scheduler.Worker {
         private final CompositeSubscription innerSubscription = new CompositeSubscription();
         private final EventLoopScheduler pooledEventLoop;
         private final OnActionComplete onComplete;

File: rxjava-core/src/main/java/rx/schedulers/ImmediateScheduler.java
Patch:
@@ -37,11 +37,11 @@ public final class ImmediateScheduler extends Scheduler {
     }
 
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new InnerImmediateScheduler();
     }
 
-    private class InnerImmediateScheduler extends Scheduler.Inner implements Subscription {
+    private class InnerImmediateScheduler extends Scheduler.Worker implements Subscription {
 
         final BooleanSubscription innerSubscription = new BooleanSubscription();
 

File: rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java
Patch:
@@ -55,11 +55,11 @@ private NewThreadScheduler() {
     }
 
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new EventLoopScheduler(THREAD_FACTORY);
     }
 
-    /* package */static class EventLoopScheduler extends Scheduler.Inner implements Subscription {
+    /* package */static class EventLoopScheduler extends Scheduler.Worker implements Subscription {
         private final CompositeSubscription innerSubscription = new CompositeSubscription();
         private final ExecutorService executor;
 

File: rxjava-core/src/main/java/rx/schedulers/SleepingAction.java
Patch:
@@ -20,10 +20,10 @@
 
 /* package */class SleepingAction implements Action0 {
     private final Action0 underlying;
-    private final Scheduler.Inner innerScheduler;
+    private final Scheduler.Worker innerScheduler;
     private final long execTime;
 
-    public SleepingAction(Action0 underlying, Scheduler.Inner scheduler, long execTime) {
+    public SleepingAction(Action0 underlying, Scheduler.Worker scheduler, long execTime) {
         this.underlying = underlying;
         this.innerScheduler = scheduler;
         this.execTime = execTime;

File: rxjava-core/src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -36,7 +36,7 @@ public class TrampolineScheduler extends Scheduler {
     }
 
     @Override
-    public Inner createInner() {
+    public Worker createWorker() {
         return new InnerCurrentThreadScheduler();
     }
 
@@ -47,7 +47,7 @@ public Inner createInner() {
 
     private final AtomicInteger counter = new AtomicInteger(0);
 
-    private class InnerCurrentThreadScheduler extends Scheduler.Inner implements Subscription {
+    private class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {
 
         private final BooleanSubscription innerSubscription = new BooleanSubscription();
 

File: rxjava-core/src/main/java/rx/subjects/TestSubject.java
Patch:
@@ -90,13 +90,13 @@ public void call(SubjectObserver<? super T> o) {
 
     private final SubjectSubscriptionManager<T> subscriptionManager;
     private final AtomicReference<Notification<T>> lastNotification;
-    private final Scheduler.Inner innerScheduler;
+    private final Scheduler.Worker innerScheduler;
 
     protected TestSubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification, TestScheduler scheduler) {
         super(onSubscribe);
         this.subscriptionManager = subscriptionManager;
         this.lastNotification = lastNotification;
-        this.innerScheduler = scheduler.createInner();
+        this.innerScheduler = scheduler.createWorker();
     }
 
     @Override

File: rxjava-core/src/perf/java/rx/archive/schedulers/TestRecursionMemoryUsage.java
Patch:
@@ -18,7 +18,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.Scheduler;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.Subscriber;
 import rx.functions.Action0;
 import rx.schedulers.Schedulers;
@@ -42,7 +42,7 @@ protected static void testScheduler(final Scheduler scheduler) {
 
             @Override
             public void call(final Subscriber<? super Long> o) {
-                final Inner inner = scheduler.createInner();
+                final Worker inner = scheduler.createWorker();
                 o.add(inner);
                 inner.schedule(new Action0() {
 

File: rxjava-core/src/test/java/rx/EventStream.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Map;
 
 import rx.Observable.OnSubscribe;
-import rx.Scheduler.Inner;
+import rx.Scheduler.Worker;
 import rx.functions.Action0;
 import rx.schedulers.Schedulers;
 
@@ -34,7 +34,7 @@ public static Observable<Event> getEventStream(final String type, final int numI
 
             @Override
             public void call(final Subscriber<? super Event> subscriber) {
-                Inner inner = Schedulers.newThread().createInner();
+                Worker inner = Schedulers.newThread().createWorker();
                 subscriber.add(inner);
                 // run on a background thread inside the OnSubscribeFunc so unsubscribe works
                 inner.schedule(new Action0() {

File: rxjava-core/src/test/java/rx/operators/OperationBufferTest.java
Patch:
@@ -50,14 +50,14 @@ public class OperationBufferTest {
 
     private Observer<List<String>> observer;
     private TestScheduler scheduler;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
 
     @Before
     @SuppressWarnings("unchecked")
     public void before() {
         observer = Mockito.mock(Observer.class);
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperationDebounceTest.java
Patch:
@@ -43,14 +43,14 @@ public class OperationDebounceTest {
 
     private TestScheduler scheduler;
     private Observer<String> observer;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
 
     @Before
     @SuppressWarnings("unchecked")
     public void before() {
         scheduler = new TestScheduler();
         observer = mock(Observer.class);
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperationSampleTest.java
Patch:
@@ -39,7 +39,7 @@
 
 public class OperationSampleTest {
     private TestScheduler scheduler;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
     private Observer<Long> observer;
     private Observer<Object> observer2;
 
@@ -48,7 +48,7 @@ public class OperationSampleTest {
     // due to mocking
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
         observer = mock(Observer.class);
         observer2 = mock(Observer.class);
     }

File: rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java
Patch:
@@ -40,14 +40,14 @@
 public class OperationSwitchTest {
 
     private TestScheduler scheduler;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
     private Observer<String> observer;
 
     @Before
     @SuppressWarnings("unchecked")
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
         observer = mock(Observer.class);
     }
 

File: rxjava-core/src/test/java/rx/operators/OperationThrottleFirstTest.java
Patch:
@@ -37,14 +37,14 @@
 public class OperationThrottleFirstTest {
 
     private TestScheduler scheduler;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
     private Observer<String> observer;
 
     @Before
     @SuppressWarnings("unchecked")
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
         observer = mock(Observer.class);
     }
 

File: rxjava-core/src/test/java/rx/operators/OperationWindowTest.java
Patch:
@@ -46,12 +46,12 @@
 public class OperationWindowTest {
 
     private TestScheduler scheduler;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
 
     @Before
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
     }
 
     private static <T> List<List<T>> toLists(Observable<Observable<T>> observables) {

File: rxjava-core/src/test/java/rx/operators/OperatorAmbTest.java
Patch:
@@ -39,12 +39,12 @@
 public class OperatorAmbTest {
 
     private TestScheduler scheduler;
-    private Scheduler.Inner innerScheduler;
+    private Scheduler.Worker innerScheduler;
 
     @Before
     public void setUp() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.createInner();
+        innerScheduler = scheduler.createWorker();
     }
 
     private Observable<String> createObservable(final String[] values,

File: rxjava-core/src/test/java/rx/operators/OperatorUnsubscribeOnTest.java
Patch:
@@ -138,13 +138,13 @@ public Thread getThread() throws InterruptedException {
 
     public static class UIEventLoopScheduler extends Scheduler {
 
-        private final Scheduler.Inner eventLoop;
+        private final Scheduler.Worker eventLoop;
         private final Subscription s;
         private volatile Thread t;
 
         public UIEventLoopScheduler() {
 
-            eventLoop = Schedulers.newThread().createInner();
+            eventLoop = Schedulers.newThread().createWorker();
             s = eventLoop;
 
             /*
@@ -168,7 +168,7 @@ public void call() {
         }
         
         @Override
-        public Inner createInner() {
+        public Worker createWorker() {
             return eventLoop;
         }
 

File: rxjava-core/src/test/java/rx/schedulers/ComputationSchedulerTests.java
Patch:
@@ -45,7 +45,7 @@ public void testThreadSafetyWhenSchedulerIsHoppingBetweenThreads() {
         final CountDownLatch latch = new CountDownLatch(1);
         final HashMap<String, Integer> map = new HashMap<String, Integer>();
 
-        final Scheduler.Inner inner = Schedulers.computation().createInner();
+        final Scheduler.Worker inner = Schedulers.computation().createWorker();
 
         inner.schedule(new Action0() {
 

File: rxjava-core/src/test/java/rx/schedulers/TestSchedulerTest.java
Patch:
@@ -42,7 +42,7 @@ public final void testPeriodicScheduling() {
         final Func1<Long, Void> calledOp = mock(Func1.class);
 
         final TestScheduler scheduler = new TestScheduler();
-        final Scheduler.Inner inner = scheduler.createInner();
+        final Scheduler.Worker inner = scheduler.createWorker();
         
         inner.schedulePeriodically(new Action0() {
             @Override
@@ -80,7 +80,7 @@ public void call() {
     @Test
     public final void testImmediateUnsubscribes() {
         TestScheduler s = new TestScheduler();
-        final Scheduler.Inner inner = s.createInner();
+        final Scheduler.Worker inner = s.createWorker();
         final AtomicInteger counter = new AtomicInteger(0);
         
         inner.schedule(new Action0() {

File: rxjava-core/src/test/java/rx/test/OperatorTester.java
Patch:
@@ -52,8 +52,8 @@ public ForwardingScheduler(Scheduler underlying) {
         }
 
         @Override
-        public Inner createInner() {
-            return underlying.createInner();
+        public Worker createWorker() {
+            return underlying.createWorker();
         }
 
     }

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -72,7 +72,7 @@ State remove(Subscription s) {
             for (Subscription _s : subscriptions) {
                 if (!_s.equals(s)) {
                     // was not in this composite
-                    if (idx == subscriptions.length) {
+                    if (idx == newSubscriptions.length) {
                         return this;
                     }
                     newSubscriptions[idx] = _s;

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -72,7 +72,7 @@ State remove(Subscription s) {
             for (Subscription _s : subscriptions) {
                 if (!_s.equals(s)) {
                     // was not in this composite
-                    if (idx == subscriptions.length) {
+                    if (idx == newSubscriptions.length) {
                         return this;
                     }
                     newSubscriptions[idx] = _s;

File: rxjava-core/src/main/java/rx/operators/BlockingOperatorLatest.java
Patch:
@@ -85,7 +85,7 @@ public boolean hasNext() {
                         notify.acquire();
                     } catch (InterruptedException ex) {
                         Thread.currentThread().interrupt();
-                        iNotif = new Notification<T>(ex);
+                        iNotif = Notification.createOnError(ex);
                         throw Exceptions.propagate(ex);
                     }
 

File: rxjava-core/src/main/java/rx/operators/OperationSkipUntil.java
Patch:
@@ -66,8 +66,8 @@ public ResultManager init() {
             cancel.add(toSource);
             cancel.add(toOther);
 
-            toSource.setSubscription(source.unsafeSubscribe(Subscribers.from(this)));
-            toOther.setSubscription(other.unsafeSubscribe(new OtherObserver(toOther)));
+            toSource.set(source.unsafeSubscribe(Subscribers.from(this)));
+            toOther.set(other.unsafeSubscribe(new OtherObserver(toOther)));
 
             return this;
         }

File: rxjava-core/src/main/java/rx/operators/OperationSwitch.java
Patch:
@@ -144,7 +144,7 @@ public void onCompleted() {
 
             }));
 
-            this.child.setSubscription(sub);
+            this.child.set(sub);
         }
 
         @Override

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -57,7 +57,7 @@ public final class AsyncSubject<T> extends Subject<T, T> {
 
     public static <T> AsyncSubject<T> create() {
         final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();
-        final AtomicReference<Notification<T>> lastNotification = new AtomicReference<Notification<T>>(new Notification<T>());
+        final AtomicReference<Notification<T>> lastNotification = new AtomicReference<Notification<T>>(Notification.<T>createOnCompleted());
 
         OnSubscribe<T> onSubscribe = subscriptionManager.getOnSubscribeFunc(
                 /**

File: rxjava-core/src/test/java/rx/ObservableTests.java
Patch:
@@ -193,7 +193,7 @@ public void testTakeFirstWithPredicateOfNoneMatchingThePredicate() {
     @Test
     public void testTakeFirstOfSome() {
         Observable<Integer> observable = Observable.from(1, 2, 3);
-        observable.takeFirst().subscribe(w);
+        observable.take(1).subscribe(w);
         verify(w, times(1)).onNext(anyInt());
         verify(w).onNext(1);
         verify(w, times(1)).onCompleted();
@@ -203,7 +203,7 @@ public void testTakeFirstOfSome() {
     @Test
     public void testTakeFirstOfNone() {
         Observable<Integer> observable = Observable.empty();
-        observable.takeFirst().subscribe(w);
+        observable.take(1).subscribe(w);
         verify(w, never()).onNext(anyInt());
         verify(w, times(1)).onCompleted();
         verify(w, never()).onError(any(Throwable.class));

File: rxjava-core/src/test/java/rx/operators/OperationGroupJoinTest.java
Patch:
@@ -177,7 +177,7 @@ public PPF call(Person t1, Observable<PersonFruit> t2) {
                 new Subscriber<PPF>() {
                     @Override
                     public void onNext(final PPF ppf) {
-                        ppf.fruits.where(new Func1<PersonFruit, Boolean>() {
+                        ppf.fruits.filter(new Func1<PersonFruit, Boolean>() {
                             @Override
                             public Boolean call(PersonFruit t1) {
                                 return ppf.person.id == t1.personId;

File: rxjava-core/src/test/java/rx/util/AssertObservable.java
Patch:
@@ -137,7 +137,7 @@ public Notification<String> call(Notification<String> a, Notification<String> b)
             }
         };
 
-        Observable<Void> outcomeObservable = Observable.zip(expected.materialize(), actual.materialize(), zipFunction).aggregate(accumulator).map(new Func1<Notification<String>, Notification<Void>>() {
+        Observable<Void> outcomeObservable = Observable.zip(expected.materialize(), actual.materialize(), zipFunction).reduce(accumulator).map(new Func1<Notification<String>, Notification<Void>>() {
             @Override
             public Notification<Void> call(Notification<String> outcome) {
                 if (outcome.isOnError()) {

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/OnSubscribeFromChannel.java
Patch:
@@ -15,10 +15,10 @@
  */
 package rx.quasar;
 
-import co.paralleluniverse.fibers.Suspendable;
-import co.paralleluniverse.strands.channels.ReceivePort;
 import rx.Observable.OnSubscribe;
 import rx.Subscriber;
+import co.paralleluniverse.fibers.Suspendable;
+import co.paralleluniverse.strands.channels.ReceivePort;
 
 /**
  * Converts a {@link ReceivePort} into an Observable that emits each message received on the channel.

File: rxjava-contrib/rxjava-quasar/src/test/java/rx/quasar/NewFiberSchedulerTest.java
Patch:
@@ -15,9 +15,6 @@
  */
 package rx.quasar;
 
-import org.junit.Rule;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
 import rx.Scheduler;
 import rx.schedulers.AbstractSchedulerConcurrencyTests;
 

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -16,6 +16,7 @@
 package rx.observables;
 
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutBase.java
Patch:
@@ -24,7 +24,6 @@
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.functions.Func2;
 import rx.functions.Func3;
 import rx.functions.Func4;
 import rx.observers.SerializedSubscriber;

File: rxjava-core/src/perf/java/rx/archive/composition/RangeMapTakeOnNextPerf.java
Patch:
@@ -3,8 +3,8 @@
 import rx.Observable;
 import rx.archive.perf.AbstractPerformanceTester;
 import rx.archive.perf.IntegerSumObserver;
-import rx.util.functions.Action0;
-import rx.util.functions.Func1;
+import rx.functions.Action0;
+import rx.functions.Func1;
 
 public class RangeMapTakeOnNextPerf extends AbstractPerformanceTester {
 

File: rxjava-core/src/test/java/rx/operators/OperatorUnsubscribeOnTest.java
Patch:
@@ -6,7 +6,6 @@
 
 import java.util.Arrays;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Test;

File: rxjava-core/src/test/java/rx/schedulers/TestSchedulerTest.java
Patch:
@@ -30,7 +30,6 @@
 import org.mockito.Mockito;
 
 import rx.Scheduler;
-import rx.Subscription;
 import rx.functions.Action0;
 import rx.functions.Func1;
 

File: rxjava-core/src/test/java/rx/subjects/BehaviorSubjectTest.java
Patch:
@@ -29,7 +29,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
-import rx.util.functions.Func1;
+import rx.functions.Func1;
 
 public class BehaviorSubjectTest {
 

File: rxjava-core/src/test/java/rx/subjects/PublishSubjectTest.java
Patch:
@@ -314,7 +314,7 @@ public void testUnsubscriptionCase() {
             String v = "" + i;
             System.out.printf("Turn: %d%n", i);
             src.first()
-                .flatMap(new rx.util.functions.Func1<String, Observable<String>>() {
+                .flatMap(new Func1<String, Observable<String>>() {
 
                     @Override
                     public Observable<String> call(String t1) {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -5079,9 +5079,7 @@ public final Observable<T> onExceptionResumeNext(final Observable<? extends T> r
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-parallel">RxJava Wiki: parallel()</a>
      */
     public final <R> Observable<R> parallel(Func1<Observable<T>, Observable<R>> f) {
-        // TODO move this back to Schedulers.computation() again once that is properly using eventloops
-        // see https://github.com/Netflix/RxJava/issues/713 for why this was changed
-        return lift(new OperatorParallel<T, R>(f, Schedulers.newThread()));
+        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));
     }
 
     /**

File: rxjava-contrib/rxjava-joins/src/main/java/rx/joins/operators/OperationJoinPatterns.java
Patch:
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations under
  * the License.
  */
-package rx.operators;
+package rx.joins.operators;
 
 import java.util.ArrayList;
 import java.util.Arrays;

File: rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationDeferFutureTest.java
Patch:
@@ -58,7 +58,7 @@ public Observable<Integer> call() throws Exception {
                 }
             };
             
-            Observable<Integer> result = Async.deferFuture(func, Schedulers.threadPoolForComputation());
+            Observable<Integer> result = Async.deferFuture(func, Schedulers.computation());
 
             final Observer<Integer> observer = mock(Observer.class);
 

File: rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationStartFutureTest.java
Patch:
@@ -104,7 +104,7 @@ public Integer call() throws Exception {
                 }
             };
 
-            Observable<Integer> result = Async.startFuture(func, Schedulers.threadPoolForComputation());
+            Observable<Integer> result = Async.startFuture(func, Schedulers.computation());
 
             final Observer<Integer> observer = mock(Observer.class);
 

File: rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java
Patch:
@@ -442,7 +442,7 @@ public void testWhileDoZeroTimes() {
 
     @Test
     public void testWhileDoManyTimes() {
-        Observable<Integer> source1 = Observable.from(1, 2, 3).subscribeOn(Schedulers.currentThread());
+        Observable<Integer> source1 = Observable.from(1, 2, 3).subscribeOn(Schedulers.trampoline());
 
         List<Integer> expected = new ArrayList<Integer>(numRecursion * 3);
         for (int i = 0; i < numRecursion; i++) {

File: rxjava-core/src/main/java/rx/operators/OperationBuffer.java
Patch:
@@ -197,7 +197,7 @@ public Subscription onSubscribe(final Observer<? super List<T>> observer) {
      *         the {@link Func1} object representing the specified buffer operation
      */
     public static <T> OnSubscribeFunc<List<T>> buffer(Observable<T> source, long timespan, TimeUnit unit) {
-        return buffer(source, timespan, unit, Schedulers.threadPoolForComputation());
+        return buffer(source, timespan, unit, Schedulers.computation());
     }
 
     /**
@@ -259,7 +259,7 @@ public Subscription onSubscribe(final Observer<? super List<T>> observer) {
      *         the {@link Func1} object representing the specified buffer operation
      */
     public static <T> OnSubscribeFunc<List<T>> buffer(Observable<T> source, long timespan, TimeUnit unit, int count) {
-        return buffer(source, timespan, unit, count, Schedulers.threadPoolForComputation());
+        return buffer(source, timespan, unit, count, Schedulers.computation());
     }
 
     /**
@@ -325,7 +325,7 @@ public Subscription onSubscribe(final Observer<? super List<T>> observer) {
      *         the {@link Func1} object representing the specified buffer operation
      */
     public static <T> OnSubscribeFunc<List<T>> buffer(Observable<T> source, long timespan, long timeshift, TimeUnit unit) {
-        return buffer(source, timespan, timeshift, unit, Schedulers.threadPoolForComputation());
+        return buffer(source, timespan, timeshift, unit, Schedulers.computation());
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperationWindow.java
Patch:
@@ -195,7 +195,7 @@ public Subscription onSubscribe(final Observer<? super Observable<T>> observer)
      *         the {@link rx.functions.Func1} object representing the specified window operation
      */
     public static <T> OnSubscribeFunc<Observable<T>> window(Observable<? extends T> source, long timespan, TimeUnit unit) {
-        return window(source, timespan, unit, Schedulers.threadPoolForComputation());
+        return window(source, timespan, unit, Schedulers.computation());
     }
 
     /**
@@ -255,7 +255,7 @@ public Subscription onSubscribe(final Observer<? super Observable<T>> observer)
      *         the {@link rx.functions.Func1} object representing the specified window operation
      */
     public static <T> OnSubscribeFunc<Observable<T>> window(Observable<? extends T> source, long timespan, TimeUnit unit, int count) {
-        return window(source, timespan, unit, count, Schedulers.threadPoolForComputation());
+        return window(source, timespan, unit, count, Schedulers.computation());
     }
 
     /**
@@ -318,7 +318,7 @@ public Subscription onSubscribe(final Observer<? super Observable<T>> observer)
      *         the {@link rx.functions.Func1} object representing the specified window operation
      */
     public static <T> OnSubscribeFunc<Observable<T>> window(Observable<? extends T> source, long timespan, long timeshift, TimeUnit unit) {
-        return window(source, timespan, timeshift, unit, Schedulers.threadPoolForComputation());
+        return window(source, timespan, timeshift, unit, Schedulers.computation());
     }
 
     /**

File: rxjava-core/src/main/java/rx/schedulers/GenericScheduledExecutorService.java
Patch:
@@ -40,7 +40,7 @@
 
     private GenericScheduledExecutorService() {
         int count = Runtime.getRuntime().availableProcessors();
-        if (count > 8) {
+        if (count > 4) {
             count = count / 2;
         }
         // we don't need more than 8 to handle just scheduling and doing no work

File: rxjava-core/src/test/java/rx/operators/OperationWindowTest.java
Patch:
@@ -99,7 +99,7 @@ public void testSkipAndCountGaplessWindows() {
 
     @Test
     public void testOverlappingWindows() {
-        Observable<String> subject = Observable.from(new String[] { "zero", "one", "two", "three", "four", "five" }, Schedulers.currentThread());
+        Observable<String> subject = Observable.from(new String[] { "zero", "one", "two", "three", "four", "five" }, Schedulers.trampoline());
         Observable<Observable<String>> windowed = Observable.create(window(subject, 3, 1));
 
         List<List<String>> windows = toLists(windowed);

File: rxjava-core/src/test/java/rx/schedulers/ImmediateSchedulerTest.java
Patch:
@@ -28,7 +28,7 @@ public class ImmediateSchedulerTest extends AbstractSchedulerTests {
 
     @Override
     protected Scheduler getScheduler() {
-        return ImmediateScheduler.getInstance();
+        return Schedulers.immediate();
     }
 
     @Override

File: rxjava-core/src/test/java/rx/schedulers/TrampolineSchedulerTest.java
Patch:
@@ -28,7 +28,7 @@ public class TrampolineSchedulerTest extends AbstractSchedulerTests {
 
     @Override
     protected Scheduler getScheduler() {
-        return TrampolineScheduler.getInstance();
+        return Schedulers.trampoline();
     }
 
     @Test
@@ -38,7 +38,7 @@ public final void testMergeWithCurrentThreadScheduler1() {
 
         Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
         Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
-        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.currentThread()).map(new Func1<Integer, String>() {
+        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.trampoline()).map(new Func1<Integer, String>() {
 
             @Override
             public String call(Integer t) {

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -128,7 +128,7 @@ public long now() {
      * 
      * @return the scheduler's available degree of parallelism
      */
-    public int degreeOfParallelism() {
+    public int parallelism() {
         return Runtime.getRuntime().availableProcessors();
     }
 

File: rxjava-core/src/main/java/rx/operators/OperatorParallel.java
Patch:
@@ -34,7 +34,7 @@ public final class OperatorParallel<T, R> implements Operator<R, T> {
     public OperatorParallel(Func1<Observable<T>, Observable<R>> f, Scheduler scheduler) {
         this.scheduler = scheduler;
         this.f = f;
-        this.degreeOfParallelism = scheduler.degreeOfParallelism();
+        this.degreeOfParallelism = scheduler.parallelism();
     }
 
     @Override

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java
Patch:
@@ -43,7 +43,7 @@ public HandlerThreadScheduler(Handler handler) {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new InnerHandlerThreadScheduler(handler);
     }
     

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/subscriptions/AndroidSubscriptions.java
Patch:
@@ -42,7 +42,7 @@ public void call() {
                 if (Looper.getMainLooper() == Looper.myLooper()) {
                     unsubscribe.call();
                 } else {
-                    final Inner inner = AndroidSchedulers.mainThread().inner();
+                    final Inner inner = AndroidSchedulers.mainThread().createInner();
                     inner.schedule(new Action0() {
                         @Override
                         public void call() {

File: rxjava-contrib/rxjava-android/src/test/java/rx/android/schedulers/HandlerThreadSchedulerTest.java
Patch:
@@ -45,7 +45,7 @@ public void shouldScheduleImmediateActionOnHandlerThread() {
         final Action0 action = mock(Action0.class);
 
         Scheduler scheduler = new HandlerThreadScheduler(handler);
-        Inner inner = scheduler.inner();
+        Inner inner = scheduler.createInner();
         inner.schedule(action);
 
         // verify that we post to the given Handler
@@ -64,7 +64,7 @@ public void shouldScheduleDelayedActionOnHandlerThread() {
         final Action0 action = mock(Action0.class);
 
         Scheduler scheduler = new HandlerThreadScheduler(handler);
-        Inner inner = scheduler.inner();
+        Inner inner = scheduler.createInner();
         inner.schedule(action, 1L, TimeUnit.SECONDS);
 
         // verify that we post to the given Handler

File: rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java
Patch:
@@ -29,7 +29,6 @@
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.functions.Action0;
-import rx.functions.Action1;
 
 /**
  * Schedules work on a new fiber.
@@ -56,7 +55,7 @@ private NewFiberScheduler() {
     }
     
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new EventLoopScheduler();
     }
 

File: rxjava-contrib/rxjava-swing/src/main/java/rx/schedulers/SwingScheduler.java
Patch:
@@ -44,7 +44,7 @@ public static SwingScheduler getInstance() {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new InnerSwingScheduler();
     }
 

File: rxjava-contrib/rxjava-swing/src/main/java/rx/subscriptions/SwingSubscriptions.java
Patch:
@@ -41,7 +41,7 @@ public void call() {
                 if (SwingUtilities.isEventDispatchThread()) {
                     unsubscribe.call();
                 } else {
-                    final Inner inner = SwingScheduler.getInstance().inner();
+                    final Inner inner = SwingScheduler.getInstance().createInner();
                     inner.schedule(new Action0() {
                         @Override
                         public void call() {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/SwingTestHelper.java
Patch:
@@ -35,7 +35,7 @@ public static SwingTestHelper create() {
     }
 
     public SwingTestHelper runInEventDispatchThread(final Action0 action) {
-        Inner inner = SwingScheduler.getInstance().inner();
+        Inner inner = SwingScheduler.getInstance().createInner();
         inner.schedule(new Action0() {
 
             @Override

File: rxjava-contrib/rxjava-swing/src/test/java/rx/schedulers/SwingSchedulerTest.java
Patch:
@@ -48,7 +48,7 @@ public final class SwingSchedulerTest {
     @Test
     public void testInvalidDelayValues() {
         final SwingScheduler scheduler = new SwingScheduler();
-        final Inner inner = scheduler.inner();
+        final Inner inner = scheduler.createInner();
         final Action0 action = mock(Action0.class);
 
         exception.expect(IllegalArgumentException.class);
@@ -67,7 +67,7 @@ public void testInvalidDelayValues() {
     @Test
     public void testPeriodicScheduling() throws Exception {
         final SwingScheduler scheduler = new SwingScheduler();
-        final Inner inner = scheduler.inner();
+        final Inner inner = scheduler.createInner();
 
         final CountDownLatch latch = new CountDownLatch(4);
 
@@ -98,7 +98,7 @@ public void call() {
     @Test
     public void testNestedActions() throws Exception {
         final SwingScheduler scheduler = new SwingScheduler();
-        final Inner inner = scheduler.inner();
+        final Inner inner = scheduler.createInner();
 
         final Action0 firstStepStart = mock(Action0.class);
         final Action0 firstStepEnd = mock(Action0.class);

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -48,7 +48,7 @@ public abstract class Scheduler {
      * 
      * @return Inner representing a serial queue of actions to be executed
      */
-    public abstract Inner inner();
+    public abstract Inner createInner();
 
     /**
      * Sequential Scheduler for executing actions on a single thread or event loop.

File: rxjava-core/src/main/java/rx/operators/OperationDebounce.java
Patch:
@@ -114,7 +114,7 @@ public DebounceObserver(Observer<? super T> observer, long timeout, TimeUnit uni
             this.observer = new SerializedObserver<T>(observer);
             this.timeout = timeout;
             this.unit = unit;
-            this.scheduler = scheduler.inner();
+            this.scheduler = scheduler.createInner();
         }
 
         @Override

File: rxjava-core/src/main/java/rx/operators/OperationDelay.java
Patch:
@@ -67,7 +67,7 @@ private static final class DelaySubscribeFunc<T> implements OnSubscribeFunc<T> {
 
         public DelaySubscribeFunc(Observable<? extends T> source, long time, TimeUnit unit, Scheduler scheduler) {
             this.source = source;
-            this.scheduler = scheduler.inner();
+            this.scheduler = scheduler.createInner();
             this.time = time;
             this.unit = unit;
         }

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -66,7 +66,7 @@ private Interval(long period, TimeUnit unit, Scheduler scheduler) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Long> observer) {
-            Inner inner = scheduler.inner();
+            Inner inner = scheduler.createInner();
             inner.schedulePeriodically(new Action0() {
                 @Override
                 public void call() {

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -60,7 +60,7 @@ public SkipTimed(Observable<? extends T> source, long time, TimeUnit unit, Sched
 
         @Override
         public Subscription onSubscribe(Observer<? super T> t1) {
-            Inner inner = scheduler.inner();
+            Inner inner = scheduler.createInner();
             CompositeSubscription csub = new CompositeSubscription(inner);
             final SourceObserver<T> so = new SourceObserver<T>(t1, csub);
             csub.add(so);

File: rxjava-core/src/main/java/rx/operators/OperationTakeTimed.java
Patch:
@@ -191,7 +191,7 @@ public TakeTimed(Observable<? extends T> source, long time, TimeUnit unit, Sched
 
         @Override
         public Subscription onSubscribe(Observer<? super T> t1) {
-            Inner inner = scheduler.inner();
+            Inner inner = scheduler.createInner();
             CompositeSubscription csub = new CompositeSubscription(inner);
             final SourceObserver<T> so = new SourceObserver<T>(t1, csub);
             csub.add(so);

File: rxjava-core/src/main/java/rx/operators/OperationTimer.java
Patch:
@@ -50,7 +50,7 @@ public TimerOnce(long dueTime, TimeUnit unit, Scheduler scheduler) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Long> t1) {
-            return scheduler.inner().schedule(new Action0() {
+            return scheduler.createInner().schedule(new Action0() {
                 @Override
                 public void call() {
                     t1.onNext(0L);
@@ -79,7 +79,7 @@ public TimerPeriodically(long initialDelay, long period, TimeUnit unit, Schedule
 
         @Override
         public Subscription onSubscribe(final Observer<? super Long> t1) {
-            Inner inner = scheduler.inner();
+            Inner inner = scheduler.createInner();
             inner.schedulePeriodically(new Action0() {
                 long count;
 

File: rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java
Patch:
@@ -66,7 +66,7 @@ private static class ObserveOnSubscriber<T> extends Subscriber<T> {
         public ObserveOnSubscriber(Scheduler scheduler, Subscriber<? super T> subscriber) {
             super(subscriber);
             this.observer = subscriber;
-            this.recursiveScheduler = scheduler.inner();
+            this.recursiveScheduler = scheduler.createInner();
             subscriber.add(recursiveScheduler);
         }
 

File: rxjava-core/src/main/java/rx/operators/OperatorRepeat.java
Patch:
@@ -71,7 +71,7 @@ public void onError(Throwable e) {
             @Override
             public void onNext(final Observable<T> t) {
                 // will only be invoked once since we're nested
-                final Inner inner = scheduler.inner();
+                final Inner inner = scheduler.createInner();
                 // cleanup on unsubscribe
                 add(inner);
                 inner.schedule(new Action0() {

File: rxjava-core/src/main/java/rx/operators/OperatorRetry.java
Patch:
@@ -59,7 +59,7 @@ public OperatorRetry() {
 
     @Override
     public Subscriber<? super Observable<T>> call(final Subscriber<? super T> child) {
-        final Scheduler.Inner inner = scheduler.inner();
+        final Scheduler.Inner inner = scheduler.createInner();
         child.add(inner);
         
         final SerialSubscription serialSubscription = new SerialSubscription();

File: rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java
Patch:
@@ -37,7 +37,7 @@ public OperatorSubscribeOn(Scheduler scheduler) {
 
     @Override
     public Subscriber<? super Observable<T>> call(final Subscriber<? super T> subscriber) {
-        final Inner inner = scheduler.inner();
+        final Inner inner = scheduler.createInner();
         subscriber.add(inner);
         return new Subscriber<Observable<T>>(subscriber) {
 

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutBase.java
Patch:
@@ -64,7 +64,7 @@ class OperatorTimeoutBase<T> implements Operator<T, T> {
 
     @Override
     public Subscriber<? super T> call(Subscriber<? super T> subscriber) {
-        Scheduler.Inner inner = scheduler.inner();
+        Scheduler.Inner inner = scheduler.createInner();
         subscriber.add(inner);
         final SerialSubscription serial = new SerialSubscription();
         subscriber.add(serial);

File: rxjava-core/src/main/java/rx/operators/OperatorUnsubscribeOn.java
Patch:
@@ -41,7 +41,7 @@ public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {
 
             @Override
             public void call() {
-                final Scheduler.Inner inner = scheduler.inner();
+                final Scheduler.Inner inner = scheduler.createInner();
                 inner.schedule(new Action0() {
 
                     @Override

File: rxjava-core/src/main/java/rx/schedulers/ExecutorScheduler.java
Patch:
@@ -54,7 +54,7 @@ public ExecutorScheduler(ScheduledExecutorService executor) {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new InnerExecutorScheduler();
     }
 

File: rxjava-core/src/main/java/rx/schedulers/ImmediateScheduler.java
Patch:
@@ -46,7 +46,7 @@ public static ImmediateScheduler getInstance() {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new InnerImmediateScheduler();
     }
 
@@ -57,7 +57,7 @@ private class InnerImmediateScheduler extends Scheduler.Inner implements Subscri
         @Override
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             // since we are executing immediately on this thread we must cause this thread to sleep
-            long execTime = now() + unit.toMillis(delayTime);
+            long execTime = ImmediateScheduler.this.now() + unit.toMillis(delayTime);
 
             return schedule(new SleepingAction(action, this, execTime));
         }

File: rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java
Patch:
@@ -64,7 +64,7 @@ private NewThreadScheduler() {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new EventLoopScheduler();
     }
 

File: rxjava-core/src/main/java/rx/schedulers/TestScheduler.java
Patch:
@@ -99,7 +99,7 @@ private void triggerActions(long targetTimeInNanos) {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new InnerTestScheduler();
     }
 

File: rxjava-core/src/main/java/rx/schedulers/TrampolineScheduler.java
Patch:
@@ -45,7 +45,7 @@ public static TrampolineScheduler getInstance() {
     }
 
     @Override
-    public Inner inner() {
+    public Inner createInner() {
         return new InnerCurrentThreadScheduler();
     }
 

File: rxjava-core/src/main/java/rx/subjects/TestSubject.java
Patch:
@@ -96,7 +96,7 @@ protected TestSubject(OnSubscribe<T> onSubscribe, SubjectSubscriptionManager<T>
         super(onSubscribe);
         this.subscriptionManager = subscriptionManager;
         this.lastNotification = lastNotification;
-        this.innerScheduler = scheduler.inner();
+        this.innerScheduler = scheduler.createInner();
     }
 
     @Override

File: rxjava-core/src/perf/java/rx/archive/schedulers/TestRecursionMemoryUsage.java
Patch:
@@ -48,7 +48,7 @@ protected static void usingFunc2(final Scheduler scheduler) {
 
             @Override
             public void call(final Subscriber<? super Long> o) {
-                final Inner inner = scheduler.inner();
+                final Inner inner = scheduler.createInner();
                 o.add(inner);
                 inner.schedule(new Action0() {
                     long i = 0;
@@ -81,7 +81,7 @@ protected static void usingAction0(final Scheduler scheduler) {
 
             @Override
             public void call(final Subscriber<? super Long> o) {
-                final Inner inner = scheduler.inner();
+                final Inner inner = scheduler.createInner();
                 o.add(inner);
                 inner.schedule(new Action0() {
 

File: rxjava-core/src/test/java/rx/EventStream.java
Patch:
@@ -34,7 +34,7 @@ public static Observable<Event> getEventStream(final String type, final int numI
 
             @Override
             public void call(final Subscriber<? super Event> subscriber) {
-                Inner inner = Schedulers.newThread().inner();
+                Inner inner = Schedulers.newThread().createInner();
                 subscriber.add(inner);
                 // run on a background thread inside the OnSubscribeFunc so unsubscribe works
                 inner.schedule(new Action0() {

File: rxjava-core/src/test/java/rx/operators/OperationBufferTest.java
Patch:
@@ -57,7 +57,7 @@ public class OperationBufferTest {
     public void before() {
         observer = Mockito.mock(Observer.class);
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperationDebounceTest.java
Patch:
@@ -50,7 +50,7 @@ public class OperationDebounceTest {
     public void before() {
         scheduler = new TestScheduler();
         observer = mock(Observer.class);
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperationSampleTest.java
Patch:
@@ -48,7 +48,7 @@ public class OperationSampleTest {
     // due to mocking
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
         observer = mock(Observer.class);
         observer2 = mock(Observer.class);
     }

File: rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java
Patch:
@@ -47,7 +47,7 @@ public class OperationSwitchTest {
     @SuppressWarnings("unchecked")
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
         observer = mock(Observer.class);
     }
 

File: rxjava-core/src/test/java/rx/operators/OperationThrottleFirstTest.java
Patch:
@@ -44,7 +44,7 @@ public class OperationThrottleFirstTest {
     @SuppressWarnings("unchecked")
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
         observer = mock(Observer.class);
     }
 

File: rxjava-core/src/test/java/rx/operators/OperationWindowTest.java
Patch:
@@ -51,7 +51,7 @@ public class OperationWindowTest {
     @Before
     public void before() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
     }
 
     private static <T> List<List<T>> toLists(Observable<Observable<T>> observables) {

File: rxjava-core/src/test/java/rx/operators/OperatorAmbTest.java
Patch:
@@ -44,7 +44,7 @@ public class OperatorAmbTest {
     @Before
     public void setUp() {
         scheduler = new TestScheduler();
-        innerScheduler = scheduler.inner();
+        innerScheduler = scheduler.createInner();
     }
 
     private Observable<String> createObservable(final String[] values,

File: rxjava-core/src/test/java/rx/operators/OperatorMergeTest.java
Patch:
@@ -485,7 +485,7 @@ public void testConcurrency() {
 
             @Override
             public void call(final Subscriber<? super Integer> s) {
-                Inner inner = Schedulers.newThread().inner();
+                Inner inner = Schedulers.newThread().createInner();
                 s.add(inner);
                 inner.schedule(new Action0() {
 
@@ -521,7 +521,7 @@ public void testConcurrencyWithSleeping() {
 
             @Override
             public void call(final Subscriber<? super Integer> s) {
-                Inner inner = Schedulers.newThread().inner();
+                Inner inner = Schedulers.newThread().createInner();
                 s.add(inner);
                 inner.schedule(new Action0() {
 
@@ -562,7 +562,7 @@ public void testConcurrencyWithBrokenOnCompleteContract() {
 
             @Override
             public void call(final Subscriber<? super Integer> s) {
-                Inner inner = Schedulers.newThread().inner();
+                Inner inner = Schedulers.newThread().createInner();
                 s.add(inner);
                 inner.schedule(new Action0() {
 

File: rxjava-core/src/test/java/rx/operators/OperatorSubscribeOnTest.java
Patch:
@@ -94,8 +94,8 @@ public SlowScheduler(Scheduler actual, long delay, TimeUnit unit) {
         }
 
         @Override
-        public Inner inner() {
-            return new SlowInner(actual.inner());
+        public Inner createInner() {
+            return new SlowInner(actual.createInner());
         }
 
         private class SlowInner extends Inner {

File: rxjava-core/src/test/java/rx/operators/OperatorUnsubscribeOnTest.java
Patch:
@@ -145,7 +145,7 @@ public static class UIEventLoopScheduler extends Scheduler {
 
         public UIEventLoopScheduler() {
 
-            eventLoop = Schedulers.newThread().inner();
+            eventLoop = Schedulers.newThread().createInner();
             s = eventLoop;
 
             /*
@@ -169,7 +169,7 @@ public void call() {
         }
         
         @Override
-        public Inner inner() {
+        public Inner createInner() {
             return eventLoop;
         }
 

File: rxjava-core/src/test/java/rx/schedulers/ExecutorSchedulerTests.java
Patch:
@@ -45,7 +45,7 @@ public void testThreadSafetyWhenSchedulerIsHoppingBetweenThreads() {
         final CountDownLatch latch = new CountDownLatch(1);
         final HashMap<String, Integer> map = new HashMap<String, Integer>();
         
-        final Scheduler.Inner inner = Schedulers.computation().inner();
+        final Scheduler.Inner inner = Schedulers.computation().createInner();
         
         inner.schedule(new Action0() {
 

File: rxjava-core/src/test/java/rx/schedulers/TestSchedulerTest.java
Patch:
@@ -43,7 +43,7 @@ public final void testPeriodicScheduling() {
         final Func1<Long, Void> calledOp = mock(Func1.class);
 
         final TestScheduler scheduler = new TestScheduler();
-        final Scheduler.Inner inner = scheduler.inner();
+        final Scheduler.Inner inner = scheduler.createInner();
         
         inner.schedulePeriodically(new Action0() {
             @Override
@@ -81,7 +81,7 @@ public void call() {
     @Test
     public final void testImmediateUnsubscribes() {
         TestScheduler s = new TestScheduler();
-        final Scheduler.Inner inner = s.inner();
+        final Scheduler.Inner inner = s.createInner();
         final AtomicInteger counter = new AtomicInteger(0);
         
         inner.schedule(new Action0() {

File: rxjava-core/src/test/java/rx/test/OperatorTester.java
Patch:
@@ -52,8 +52,8 @@ public ForwardingScheduler(Scheduler underlying) {
         }
 
         @Override
-        public Inner inner() {
-            return underlying.inner();
+        public Inner createInner() {
+            return underlying.createInner();
         }
 
     }

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java
Patch:
@@ -26,7 +26,7 @@
 
 public class ViewObservable {
 
-    public static Observable<View> clicks(final View view, final boolean emitInitialValue) {
+    public static <T extends View> Observable<T> clicks(final T view, final boolean emitInitialValue) {
         return Observable.create(new OperatorViewClick(view, emitInitialValue));
     }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -56,7 +56,6 @@
 import rx.operators.OperationAsObservable;
 import rx.operators.OperationAverage;
 import rx.operators.OperationBuffer;
-import rx.operators.OperationCache;
 import rx.operators.OperationCombineLatest;
 import rx.operators.OperationConcat;
 import rx.operators.OperationDebounce;
@@ -105,6 +104,7 @@
 import rx.operators.OperationUsing;
 import rx.operators.OperationWindow;
 import rx.operators.OperatorAmb;
+import rx.operators.OperatorCache;
 import rx.operators.OperatorCast;
 import rx.operators.OperatorDoOnEach;
 import rx.operators.OperatorFilter;
@@ -3864,7 +3864,7 @@ public final <B> Observable<List<T>> buffer(Observable<B> boundary, int initialC
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-cache">RxJava Wiki: cache()</a>
      */
     public final Observable<T> cache() {
-        return create(OperationCache.cache(this));
+        return create(new OperatorCache<T>(this));
     }
 
     /**

File: rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java
Patch:
@@ -14,7 +14,7 @@
 import rx.observables.ConnectableObservable;
 import rx.subscriptions.Subscriptions;
 
-import static rx.android.schedulers.AndroidSchedulers.mainThread;
+import static rx.android.observables.AndroidObservable.bindFragment;
 
 /**
  * Problem:
@@ -52,7 +52,7 @@ public ListeningFragment() {
         public void onCreate(Bundle savedInstanceState) {
             super.onCreate(savedInstanceState);
 
-            strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();
+            strings = SampleObservables.numberStrings(1, 50, 250).publish();
             strings.connect(); // trigger the sequence
         }
 
@@ -74,7 +74,7 @@ public void onViewCreated(final View view, Bundle savedInstanceState) {
             final TextView textView = (TextView) view.findViewById(android.R.id.text1);
 
             // re-connect to sequence
-            subscription = strings.subscribe(new Subscriber<String>() {
+            subscription = bindFragment(this, strings).subscribe(new Subscriber<String>() {
 
                 @Override
                 public void onCompleted() {

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java
Patch:
@@ -26,7 +26,7 @@
 
 public class ViewObservable {
 
-    public static Observable<View> clicks(final View view, final boolean emitInitialValue) {
+    public static <T extends View> Observable<T> clicks(final T view, final boolean emitInitialValue) {
         return Observable.create(new OperatorViewClick(view, emitInitialValue));
     }
 

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -94,7 +94,7 @@ public void call() {
                         }));
                         if (subscription.isUnsubscribed()) {
                             addedObserver = false;
-                            break;
+                            return;
                         }
                         // on subscribe add it to the map of outbound observers to notify
                         newState = current.addObserver(subscription, observer);

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -94,7 +94,7 @@ public void call() {
                         }));
                         if (subscription.isUnsubscribed()) {
                             addedObserver = false;
-                            break;
+                            return;
                         }
                         // on subscribe add it to the map of outbound observers to notify
                         newState = current.addObserver(subscription, observer);

File: rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java
Patch:
@@ -14,7 +14,7 @@
 import rx.observables.ConnectableObservable;
 import rx.subscriptions.Subscriptions;
 
-import static rx.android.schedulers.AndroidSchedulers.mainThread;
+import static rx.android.observables.AndroidObservable.bindFragment;
 
 /**
  * Problem:
@@ -52,7 +52,7 @@ public ListeningFragment() {
         public void onCreate(Bundle savedInstanceState) {
             super.onCreate(savedInstanceState);
 
-            strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();
+            strings = SampleObservables.numberStrings(1, 50, 250).publish();
             strings.connect(); // trigger the sequence
         }
 
@@ -74,7 +74,7 @@ public void onViewCreated(final View view, Bundle savedInstanceState) {
             final TextView textView = (TextView) view.findViewById(android.R.id.text1);
 
             // re-connect to sequence
-            subscription = strings.subscribe(new Subscriber<String>() {
+            subscription = bindFragment(this, strings).subscribe(new Subscriber<String>() {
 
                 @Override
                 public void onCompleted() {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -74,7 +74,7 @@
 import rx.operators.OperationInterval;
 import rx.operators.OperationJoin;
 import rx.operators.OperationJoinPatterns;
-import rx.operators.OperationMaterialize;
+import rx.operators.OperatorMaterialize;
 import rx.operators.OperationMergeDelayError;
 import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperationMinMax;
@@ -4915,7 +4915,7 @@ public final <R> Observable<R> mapMany(Func1<? super T, ? extends Observable<R>>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229453.aspx">MSDN: Observable.materialize</a>
      */
     public final Observable<Notification<T>> materialize() {
-        return create(OperationMaterialize.materialize(this));
+        return lift(new OperatorMaterialize<T>());
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/BlockingOperatorLatest.java
Patch:
@@ -30,9 +30,9 @@
  * If the source works faster than the iterator, values may be skipped, but
  * not the onError or onCompleted events.
  */
-public final class OperationLatest {
+public final class BlockingOperatorLatest {
     /** Utility class. */
-    private OperationLatest() {
+    private BlockingOperatorLatest() {
         throw new IllegalStateException("No instances!");
     }
 
@@ -41,7 +41,7 @@ public static <T> Iterable<T> latest(final Observable<? extends T> source) {
             @Override
             public Iterator<T> iterator() {
                 LatestObserverIterator<T> lio = new LatestObserverIterator<T>();
-                source.materialize().unsafeSubscribe(lio);
+                source.materialize().subscribe(lio);
                 return lio;
             }
         };

File: rxjava-core/src/main/java/rx/operators/BlockingOperatorNext.java
Patch:
@@ -31,7 +31,7 @@
  * <p>
  * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/B.next.png">
  */
-public final class OperationNext {
+public final class BlockingOperatorNext {
 
     public static <T> Iterable<T> next(final Observable<? extends T> items) {
         return new Iterable<T>() {
@@ -40,7 +40,7 @@ public Iterator<T> iterator() {
                 NextObserver<T> nextObserver = new NextObserver<T>();
                 final NextIterator<T> nextIterator = new NextIterator<T>(nextObserver);
 
-                items.materialize().unsafeSubscribe(nextObserver);
+                items.materialize().subscribe(nextObserver);
 
                 return nextIterator;
             }

File: rxjava-core/src/main/java/rx/operators/BlockingOperatorToFuture.java
Patch:
@@ -35,7 +35,7 @@
  * The toFuture operation throws an exception if the Observable emits more than one item. If the
  * Observable may emit more than item, use <code>toList().toFuture()</code>.
  */
-public class OperationToFuture {
+public class BlockingOperatorToFuture {
 
     /**
      * Returns a Future that expects a single item from the observable.
@@ -52,7 +52,7 @@ public static <T> Future<T> toFuture(Observable<? extends T> that) {
         final AtomicReference<T> value = new AtomicReference<T>();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
 
-        final Subscription s = that.unsafeSubscribe(new Subscriber<T>() {
+        final Subscription s = that.subscribe(new Subscriber<T>() {
 
             @Override
             public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/BlockingOperatorToIterator.java
Patch:
@@ -33,7 +33,7 @@
  * 
  * @see <a href="https://github.com/Netflix/RxJava/issues/50">Issue #50</a>
  */
-public class OperationToIterator {
+public class BlockingOperatorToIterator {
 
     /**
      * Returns an iterator that iterates all values of the observable.
@@ -45,7 +45,8 @@ public class OperationToIterator {
     public static <T> Iterator<T> toIterator(Observable<? extends T> source) {
         final BlockingQueue<Notification<? extends T>> notifications = new LinkedBlockingQueue<Notification<? extends T>>();
 
-        source.materialize().unsafeSubscribe(new Subscriber<Notification<? extends T>>() {
+        // using subscribe instead of unsafeSubscribe since this is a BlockingObservable "final subscribe"
+        source.materialize().subscribe(new Subscriber<Notification<? extends T>>() {
             @Override
             public void onCompleted() {
                 // ignore

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -23,7 +23,7 @@
 import rx.Subscription;
 
 /**
- * Reverses the effect of {@link OperationMaterialize} by transforming the Notification objects
+ * Reverses the effect of {@link OperatorMaterialize} by transforming the Notification objects
  * emitted by a source Observable into the items or notifications they represent.
  * <p>
  * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/dematerialize.png">

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorLatestTest.java
Patch:
@@ -28,7 +28,7 @@
 import rx.schedulers.TestScheduler;
 import rx.subjects.PublishSubject;
 
-public class OperationLatestTest {
+public class BlockingOperatorLatestTest {
     @Test(timeout = 1000)
     public void testSimple() {
         TestScheduler scheduler = new TestScheduler();

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorMostRecentTest.java
Patch:
@@ -16,7 +16,7 @@
 package rx.operators;
 
 import static org.junit.Assert.*;
-import static rx.operators.OperationMostRecent.*;
+import static rx.operators.BlockingOperatorMostRecent.*;
 
 import java.util.Iterator;
 import java.util.concurrent.TimeUnit;
@@ -30,7 +30,7 @@
 import rx.subjects.PublishSubject;
 import rx.subjects.Subject;
 
-public class OperationMostRecentTest {
+public class BlockingOperatorMostRecentTest {
 
     @Test
     public void testMostRecent() {

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorNextTest.java
Patch:
@@ -16,7 +16,7 @@
 package rx.operators;
 
 import static org.junit.Assert.*;
-import static rx.operators.OperationNext.*;
+import static rx.operators.BlockingOperatorNext.*;
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;
@@ -37,7 +37,7 @@
 import rx.subjects.Subject;
 import rx.subscriptions.Subscriptions;
 
-public class OperationNextTest {
+public class BlockingOperatorNextTest {
 
     private void fireOnNextInNewThread(final Subject<String, String> o, final String value) {
         new Thread() {
@@ -304,7 +304,7 @@ public void testSingleSourceManyIterators() throws InterruptedException {
         Iterable<Long> iter = source.next();
 
         for (int j = 0; j < 3; j++) {
-            OperationNext.NextIterator<Long> it = (OperationNext.NextIterator<Long>)iter.iterator();
+            BlockingOperatorNext.NextIterator<Long> it = (BlockingOperatorNext.NextIterator<Long>)iter.iterator();
 
             for (long i = 0; i < 9; i++) {
                 // hasNext has to set the waiting to true, otherwise, all onNext will be skipped

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorToFutureTest.java
Patch:
@@ -18,7 +18,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static rx.operators.OperationToFuture.toFuture;
+import static rx.operators.BlockingOperatorToFuture.toFuture;
 
 import java.util.List;
 import java.util.concurrent.CancellationException;
@@ -35,7 +35,7 @@
 import rx.Subscription;
 import rx.subscriptions.Subscriptions;
 
-public class OperationToFutureTest {
+public class BlockingOperatorToFutureTest {
 
     @Test
     public void testToFuture() throws InterruptedException, ExecutionException {

File: rxjava-core/src/test/java/rx/operators/BlockingOperatorToIteratorTest.java
Patch:
@@ -16,7 +16,7 @@
 package rx.operators;
 
 import static org.junit.Assert.*;
-import static rx.operators.OperationToIterator.*;
+import static rx.operators.BlockingOperatorToIterator.*;
 
 import java.util.Iterator;
 
@@ -28,7 +28,7 @@
 import rx.Subscription;
 import rx.subscriptions.Subscriptions;
 
-public class OperationToIteratorTest {
+public class BlockingOperatorToIteratorTest {
 
     @Test
     public void testToIterator() {

File: rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.Matchers;
 
@@ -431,6 +432,7 @@ public void call(String s) {
         assertEquals(37, sentEventCounter.get());
     }
 
+    @Ignore // ignore until https://github.com/Netflix/RxJava/issues/1011 is fixed
     @Test
     public void testStaggeredCompletion() throws InterruptedException {
         final AtomicInteger eventCounter = new AtomicInteger();

File: rxjava-core/src/main/java/rx/joins/JoinObserver1.java
Patch:
@@ -61,7 +61,7 @@ public void addActivePlan(ActivePlan0 activePlan) {
     public void subscribe(Object gate) {
         if (subscribed.compareAndSet(false, true)) {
             this.gate = gate;
-            source.materialize().subscribe(this);
+            source.materialize().unsafeSubscribe(this);
         } else {
             throw new IllegalStateException("Can only be subscribed to once.");
         }

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -72,7 +72,7 @@ public static <T> BlockingObservable<T> from(final Observable<? extends T> o) {
      * "Guideline 6.4: Protect calls to user code from within an operator"
      */
     private Subscription protectivelyWrapAndSubscribe(Subscriber<? super T> observer) {
-        return o.subscribe(new SafeSubscriber<T>(observer));
+        return o.unsafeSubscribe(new SafeSubscriber<T>(observer));
     }
 
     /**

File: rxjava-core/src/main/java/rx/observables/GroupedObservable.java
Patch:
@@ -37,7 +37,7 @@ public static <K, T> GroupedObservable<K, T> from(K key, final Observable<T> o)
 
             @Override
             public void call(Subscriber<? super T> s) {
-                o.subscribe(s);
+                o.unsafeSubscribe(s);
             }
         });
     }

File: rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java
Patch:
@@ -91,7 +91,7 @@ public void onNext(T t) {
      * It will then immediately swap itself out for the actual (after a single notification), but since this is now
      * being done on the same producer thread no further buffering will occur.
      */
-    private static class PassThruObserver<T> implements Observer<T> {
+    private static class PassThruObserver<T> extends Subscriber<T> {
 
         private final Observer<? super T> actual;
         // this assumes single threaded synchronous notifications (the Rx contract for a single Observer)
@@ -133,7 +133,7 @@ private void drainIfNeededAndSwitchToActual() {
 
     }
 
-    private static class BufferedObserver<T> implements Observer<T> {
+    private static class BufferedObserver<T> extends Subscriber<T> {
         private final ConcurrentLinkedQueue<Object> buffer = new ConcurrentLinkedQueue<Object>();
 
         @Override

File: rxjava-core/src/main/java/rx/operators/NotificationLite.java
Patch:
@@ -1,6 +1,5 @@
 package rx.operators;
 
-import java.io.ObjectStreamException;
 import java.io.Serializable;
 
 import rx.Notification;

File: rxjava-core/src/main/java/rx/operators/OperationAny.java
Patch:
@@ -15,13 +15,14 @@
  */
 package rx.operators;
 
-import static rx.functions.Functions.*;
+import static rx.functions.Functions.alwaysTrue;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Func1;
 
@@ -81,7 +82,7 @@ private Any(Observable<? extends T> source, Func1<? super T, Boolean> predicate,
         @Override
         public Subscription onSubscribe(final Observer<? super Boolean> observer) {
             final SafeObservableSubscription subscription = new SafeObservableSubscription();
-            return subscription.wrap(source.subscribe(new Observer<T>() {
+            return subscription.wrap(source.unsafeSubscribe(new Subscriber<T>() {
 
                 private final AtomicBoolean hasEmitted = new AtomicBoolean(false);
 

File: rxjava-core/src/main/java/rx/operators/OperationAsObservable.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.Subscribers;
 
 /**
  * Hides the identity of another observable.
@@ -34,7 +35,7 @@ public OperationAsObservable(Observable<? extends T> source) {
     }
 
     @Override
-    public Subscription onSubscribe(Observer<? super T> t1) {
-        return source.subscribe(t1);
+    public Subscription onSubscribe(final Observer<? super T> t1) {
+        return source.unsafeSubscribe(Subscribers.from(t1));
     }
 }

File: rxjava-core/src/main/java/rx/operators/OperationCache.java
Patch:
@@ -21,6 +21,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.Subscribers;
 import rx.subjects.ReplaySubject;
 
 /**
@@ -48,15 +49,15 @@ public static <T> OnSubscribeFunc<T> cache(final Observable<? extends T> source)
             public Subscription onSubscribe(Observer<? super T> observer) {
                 if (subscribed.compareAndSet(false, true)) {
                     // subscribe to the source once
-                    source.subscribe(cache);
+                    source.unsafeSubscribe(Subscribers.from(cache));
                     /*
                      * Note that we will never unsubscribe from 'source' as we want to receive and cache all of its values.
                      * 
                      * This means this should never be used on an infinite or very large sequence, similar to toList().
                      */
                 }
 
-                return cache.subscribe(observer);
+                return cache.unsafeSubscribe(Subscribers.from(observer));
             }
 
         };

File: rxjava-core/src/main/java/rx/operators/OperationDefaultIfEmpty.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 
 /**
@@ -56,7 +57,7 @@ private DefaultIfEmpty(Observable<? extends T> source, T defaultValue) {
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
             final SafeObservableSubscription subscription = new SafeObservableSubscription();
-            return subscription.wrap(source.subscribe(new Observer<T>() {
+            return subscription.wrap(source.unsafeSubscribe(new Subscriber<T>() {
 
                 private volatile boolean hasEmitted = false;
 

File: rxjava-core/src/main/java/rx/operators/OperationDefer.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observer;
 import rx.Subscription;
 import rx.functions.Func0;
+import rx.observers.Subscribers;
 
 /**
  * Do not create the Observable until an Observer subscribes; create a fresh Observable on each
@@ -39,7 +40,7 @@ public static <T> OnSubscribeFunc<T> defer(final Func0<? extends Observable<? ex
             @Override
             public Subscription onSubscribe(Observer<? super T> observer) {
                 Observable<? extends T> obs = observableFactory.call();
-                return obs.subscribe(observer);
+                return obs.unsafeSubscribe(Subscribers.from(observer));
             }
         };
 

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 
 /**
@@ -54,7 +55,7 @@ public DematerializeObservable(Observable<? extends Notification<? extends T>> s
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            return sequence.subscribe(new Observer<Notification<? extends T>>() {
+            return sequence.unsafeSubscribe(new Subscriber<Notification<? extends T>>() {
                 @Override
                 public void onCompleted() {
                     observer.onCompleted();

File: rxjava-core/src/main/java/rx/operators/OperationDistinct.java
Patch:
@@ -24,6 +24,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.functions.Func1;
@@ -97,7 +98,7 @@ private Distinct(Observable<? extends T> source, Func1<? super T, ? extends U> k
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            final Subscription sourceSub = source.subscribe(new Observer<T>() {
+            final Subscription sourceSub = source.unsafeSubscribe(new Subscriber<T>() {
                 private final Set<U> emittedKeys = new HashSet<U>();
 
                 @Override
@@ -142,7 +143,7 @@ private DistinctWithComparator(Observable<? extends T> source, Func1<? super T,
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            final Subscription sourceSub = source.subscribe(new Observer<T>() {
+            final Subscription sourceSub = source.unsafeSubscribe(new Subscriber<T>() {
 
                 // due to the totally arbitrary equality comparator, we can't use anything more efficient than lists here 
                 private final List<U> emittedKeys = new ArrayList<U>();

File: rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.functions.Func1;
@@ -108,7 +109,7 @@ private DistinctUntilChanged(Observable<? extends T> source, Func1<? super T, ?
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            final Subscription sourceSub = source.subscribe(new Observer<T>() {
+            final Subscription sourceSub = source.unsafeSubscribe(new Subscriber<T>() {
                 private U lastEmittedKey;
                 private boolean hasEmitted;
 

File: rxjava-core/src/main/java/rx/operators/OperationFinally.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action0;
 
@@ -68,10 +69,10 @@ private static class Finally<T> implements OnSubscribeFunc<T> {
         }
 
         public Subscription onSubscribe(Observer<? super T> observer) {
-            return sequence.subscribe(new FinallyObserver(observer));
+            return sequence.unsafeSubscribe(new FinallyObserver(observer));
         }
 
-        private class FinallyObserver implements Observer<T> {
+        private class FinallyObserver extends Subscriber<T> {
             private final Observer<? super T> observer;
 
             FinallyObserver(Observer<? super T> observer) {

File: rxjava-core/src/main/java/rx/operators/OperationJoinPatterns.java
Patch:
@@ -32,6 +32,7 @@
 import rx.joins.Pattern1;
 import rx.joins.Pattern2;
 import rx.joins.Plan0;
+import rx.observers.Subscribers;
 import rx.subscriptions.CompositeSubscription;
 
 /**
@@ -121,7 +122,7 @@ public void call(ActivePlan0 activePlan) {
                         }));
                     }
                 } catch (Throwable t) {
-                    return Observable.<R> error(t).subscribe(t1);
+                    return Observable.<R> error(t).unsafeSubscribe(Subscribers.from(t1));
                 }
                 CompositeSubscription group = new CompositeSubscription();
                 for (JoinObserver jo : externalSubscriptions.values()) {

File: rxjava-core/src/main/java/rx/operators/OperationLatest.java
Patch:
@@ -22,7 +22,7 @@
 
 import rx.Notification;
 import rx.Observable;
-import rx.Observer;
+import rx.Subscriber;
 import rx.exceptions.Exceptions;
 
 /**
@@ -41,14 +41,14 @@ public static <T> Iterable<T> latest(final Observable<? extends T> source) {
             @Override
             public Iterator<T> iterator() {
                 LatestObserverIterator<T> lio = new LatestObserverIterator<T>();
-                source.materialize().subscribe(lio);
+                source.materialize().unsafeSubscribe(lio);
                 return lio;
             }
         };
     }
 
     /** Observer of source, iterator for output. */
-    static final class LatestObserverIterator<T> implements Observer<Notification<? extends T>>, Iterator<T> {
+    static final class LatestObserverIterator<T> extends Subscriber<Notification<? extends T>> implements Iterator<T> {
         final Semaphore notify = new Semaphore(0);
         // observer's notification
         final AtomicReference<Notification<? extends T>> reference = new AtomicReference<Notification<? extends T>>();

File: rxjava-core/src/main/java/rx/operators/OperationMaterialize.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 
 /**
@@ -54,7 +55,7 @@ public MaterializeObservable(Observable<? extends T> sequence) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Notification<T>> observer) {
-            return sequence.subscribe(new Observer<T>() {
+            return sequence.unsafeSubscribe(new Subscriber<T>() {
 
                 @Override
                 public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperationMostRecent.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import rx.Observable;
-import rx.Observer;
+import rx.Subscriber;
 import rx.exceptions.Exceptions;
 
 /**
@@ -39,7 +39,7 @@ public Iterator<T> iterator() {
                 MostRecentObserver<T> mostRecentObserver = new MostRecentObserver<T>(initialValue);
                 final MostRecentIterator<T> nextIterator = new MostRecentIterator<T>(mostRecentObserver);
 
-                source.subscribe(mostRecentObserver);
+                source.unsafeSubscribe(mostRecentObserver);
 
                 return nextIterator;
             }
@@ -74,7 +74,7 @@ public void remove() {
         }
     }
 
-    private static class MostRecentObserver<T> implements Observer<T> {
+    private static class MostRecentObserver<T> extends Subscriber<T> {
         private final AtomicBoolean completed = new AtomicBoolean(false);
         private final AtomicReference<T> value;
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();

File: rxjava-core/src/main/java/rx/operators/OperationMulticast.java
Patch:
@@ -45,7 +45,7 @@ public MulticastConnectableObservable(Observable<? extends T> source, final Subj
             super(new OnSubscribe<R>() {
                 @Override
                 public void call(Subscriber<? super R> observer) {
-                    subject.subscribe(observer);
+                    subject.unsafeSubscribe(observer);
                 }
             });
             this.source = source;
@@ -55,7 +55,7 @@ public void call(Subscriber<? super R> observer) {
         public Subscription connect() {
             synchronized (lock) {
                 if (subscription == null) {
-                    subscription = source.subscribe(new Observer<T>() {
+                    subscription = source.unsafeSubscribe(new Subscriber<T>() {
                         @Override
                         public void onCompleted() {
                             subject.onCompleted();
@@ -138,7 +138,7 @@ public Subscription onSubscribe(Observer<? super TResult> t1) {
 
             CompositeSubscription csub = new CompositeSubscription();
 
-            csub.add(observable.subscribe(new SafeObserver<TResult>(
+            csub.add(observable.unsafeSubscribe(new SafeObserver<TResult>(
                     new SafeObservableSubscription(csub), t1)));
             csub.add(connectable.connect());
 

File: rxjava-core/src/main/java/rx/operators/OperationNext.java
Patch:
@@ -23,7 +23,7 @@
 
 import rx.Notification;
 import rx.Observable;
-import rx.Observer;
+import rx.Subscriber;
 import rx.exceptions.Exceptions;
 
 /**
@@ -40,7 +40,7 @@ public Iterator<T> iterator() {
                 NextObserver<T> nextObserver = new NextObserver<T>();
                 final NextIterator<T> nextIterator = new NextIterator<T>(nextObserver);
 
-                items.materialize().subscribe(nextObserver);
+                items.materialize().unsafeSubscribe(nextObserver);
 
                 return nextIterator;
             }
@@ -133,7 +133,7 @@ public void remove() {
         }
     }
 
-    private static class NextObserver<T> implements Observer<Notification<? extends T>> {
+    private static class NextObserver<T> extends Subscriber<Notification<? extends T>> {
         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);
         private final AtomicBoolean waiting = new AtomicBoolean(false);
 

File: rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java
Patch:
@@ -21,6 +21,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.exceptions.CompositeException;
 import rx.functions.Action0;
@@ -66,7 +67,7 @@ public Subscription onSubscribe(final Observer<? super T> observer) {
             final AtomicReference<SafeObservableSubscription> subscriptionRef = new AtomicReference<SafeObservableSubscription>(subscription);
 
             // subscribe to the original Observable and remember the subscription
-            subscription.wrap(originalSequence.subscribe(new Observer<T>() {
+            subscription.wrap(originalSequence.unsafeSubscribe(new Subscriber<T>() {
                 public void onNext(T value) {
                     // forward the successful calls
                     observer.onNext(value);

File: rxjava-core/src/main/java/rx/operators/OperationRefCount.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.observables.ConnectableObservable;
+import rx.observers.Subscribers;
 import rx.subscriptions.Subscriptions;
 
 /**
@@ -43,7 +44,7 @@ public RefCount(ConnectableObservable<T> innerConnectableObservable) {
 
         @Override
         public Subscription onSubscribe(Observer<? super T> observer) {
-            final Subscription subscription = innerConnectableObservable.subscribe(observer);
+            final Subscription subscription = innerConnectableObservable.unsafeSubscribe(Subscribers.from(observer));
             synchronized (gate) {
                 if (count++ == 0) {
                     connection = innerConnectableObservable.connect();

File: rxjava-core/src/main/java/rx/operators/OperationReplay.java
Patch:
@@ -35,6 +35,7 @@
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.functions.Functions;
+import rx.observers.Subscribers;
 import rx.schedulers.Timestamped;
 import rx.subjects.Subject;
 import rx.subscriptions.Subscriptions;
@@ -151,7 +152,7 @@ public static <T> OnSubscribeFunc<T> subscriberOf(final Observable<T> target) {
         return new OnSubscribeFunc<T>() {
             @Override
             public Subscription onSubscribe(Observer<? super T> t1) {
-                return target.subscribe(t1);
+                return target.unsafeSubscribe(Subscribers.from(t1));
             }
         };
     }

File: rxjava-core/src/main/java/rx/operators/OperationSequenceEqual.java
Patch:
@@ -15,7 +15,9 @@
  */
 package rx.operators;
 
-import static rx.Observable.*;
+import static rx.Observable.concat;
+import static rx.Observable.from;
+import static rx.Observable.zip;
 import rx.Notification;
 import rx.Observable;
 import rx.functions.Func1;

File: rxjava-core/src/main/java/rx/operators/OperationSingle.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 
 /**
@@ -45,7 +46,7 @@ private static <T> OnSubscribeFunc<T> single(
             @Override
             public Subscription onSubscribe(final Observer<? super T> observer) {
                 final SafeObservableSubscription subscription = new SafeObservableSubscription();
-                subscription.wrap(source.subscribe(new Observer<T>() {
+                subscription.wrap(source.unsafeSubscribe(new Subscriber<T>() {
 
                     private T value;
                     private boolean isEmpty = true;

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -17,13 +17,13 @@
 
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Scheduler;
 import rx.Scheduler.Inner;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action1;
 import rx.subscriptions.CompositeSubscription;
@@ -67,7 +67,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
             CompositeSubscription csub = new CompositeSubscription(timer, data);
 
             final SourceObserver<T> so = new SourceObserver<T>(t1, csub);
-            data.wrap(source.subscribe(so));
+            data.wrap(source.unsafeSubscribe(so));
             if (!data.isUnsubscribed()) {
                 timer.wrap(scheduler.schedule(so, time, unit));
             }
@@ -81,7 +81,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
          * @param <T>
          *            the observed value type
          */
-        private static final class SourceObserver<T> implements Observer<T>, Action1<Inner> {
+        private static final class SourceObserver<T> extends Subscriber<T> implements Action1<Inner> {
             final AtomicBoolean gate;
             final Observer<? super T> observer;
             final Subscription cancel;

File: rxjava-core/src/main/java/rx/operators/OperationTakeUntil.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Func1;
 
@@ -89,7 +90,7 @@ private SourceObservable(Observable<? extends T> sequence) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Notification<T>> notificationObserver) {
-            return sequence.subscribe(new Observer<T>() {
+            return sequence.unsafeSubscribe(new Subscriber<T>() {
                 @Override
                 public void onCompleted() {
                     notificationObserver.onNext(Notification.<T> halt());
@@ -117,7 +118,7 @@ private OtherObservable(Observable<? extends E> sequence) {
 
         @Override
         public Subscription onSubscribe(final Observer<? super Notification<T>> notificationObserver) {
-            return sequence.subscribe(new Observer<E>() {
+            return sequence.unsafeSubscribe(new Subscriber<E>() {
                 @Override
                 public void onCompleted() {
                     notificationObserver.onNext(Notification.<T> halt());

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -20,6 +20,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Func1;
 import rx.functions.Func2;
@@ -96,10 +97,10 @@ private TakeWhile(Observable<? extends T> items, Func2<? super T, ? super Intege
 
         @Override
         public Subscription onSubscribe(Observer<? super T> observer) {
-            return subscription.wrap(items.subscribe(new ItemObserver(observer)));
+            return subscription.wrap(items.unsafeSubscribe(new ItemObserver(observer)));
         }
 
-        private class ItemObserver implements Observer<T> {
+        private class ItemObserver extends Subscriber<T> {
             private final Observer<? super T> observer;
 
             private final AtomicInteger counter = new AtomicInteger();

File: rxjava-core/src/main/java/rx/operators/OperationThrottleFirst.java
Patch:
@@ -24,6 +24,7 @@
 import rx.Scheduler;
 import rx.Subscription;
 import rx.functions.Func1;
+import rx.observers.Subscribers;
 import rx.schedulers.Schedulers;
 
 /**
@@ -80,7 +81,7 @@ public Boolean call(T value) {
                         }
                     }
 
-                }).subscribe(observer);
+                }).unsafeSubscribe(Subscribers.from(observer));
             }
         };
     }

File: rxjava-core/src/main/java/rx/operators/OperationTimeInterval.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Scheduler;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.schedulers.Schedulers;
 import rx.schedulers.TimeInterval;
@@ -39,13 +40,13 @@ public static <T> OnSubscribeFunc<TimeInterval<T>> timeInterval(
             @Override
             public Subscription onSubscribe(
                     Observer<? super TimeInterval<T>> observer) {
-                return source.subscribe(new TimeIntervalObserver<T>(observer,
+                return source.unsafeSubscribe(new TimeIntervalObserver<T>(observer,
                         scheduler));
             }
         };
     }
 
-    private static class TimeIntervalObserver<T> implements Observer<T> {
+    private static class TimeIntervalObserver<T> extends Subscriber<T> {
 
         private final Observer<? super TimeInterval<T>> observer;
         /**

File: rxjava-core/src/main/java/rx/operators/OperationToFuture.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import rx.Observable;
-import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 
 /**
@@ -52,7 +52,7 @@ public static <T> Future<T> toFuture(Observable<? extends T> that) {
         final AtomicReference<T> value = new AtomicReference<T>();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
 
-        final Subscription s = that.subscribe(new Observer<T>() {
+        final Subscription s = that.unsafeSubscribe(new Subscriber<T>() {
 
             @Override
             public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperationToIterator.java
Patch:
@@ -22,7 +22,7 @@
 
 import rx.Notification;
 import rx.Observable;
-import rx.Observer;
+import rx.Subscriber;
 import rx.exceptions.Exceptions;
 
 /**
@@ -45,7 +45,7 @@ public class OperationToIterator {
     public static <T> Iterator<T> toIterator(Observable<? extends T> source) {
         final BlockingQueue<Notification<? extends T>> notifications = new LinkedBlockingQueue<Notification<? extends T>>();
 
-        source.materialize().subscribe(new Observer<Notification<? extends T>>() {
+        source.materialize().unsafeSubscribe(new Subscriber<Notification<? extends T>>() {
             @Override
             public void onCompleted() {
                 // ignore

File: rxjava-core/src/main/java/rx/operators/OperationToMap.java
Patch:
@@ -22,6 +22,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Func0;
 import rx.functions.Func1;
@@ -116,15 +117,15 @@ public Subscription onSubscribe(Observer<? super Map<K, V>> t1) {
                 t1.onError(t);
                 return Subscriptions.empty();
             }
-            return source.subscribe(new ToMapObserver<K, V, T>(
+            return source.unsafeSubscribe(new ToMapObserver<K, V, T>(
                     t1, keySelector, valueSelector, map));
         }
 
         /**
          * Observer that collects the source values of T into
          * a map.
          */
-        public static class ToMapObserver<K, V, T> implements Observer<T> {
+        public static class ToMapObserver<K, V, T> extends Subscriber<T> {
             /** The map. */
             Map<K, V> map;
             /** Key extractor. */

File: rxjava-core/src/main/java/rx/operators/OperationToMultimap.java
Patch:
@@ -24,6 +24,7 @@
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Func0;
 import rx.functions.Func1;
@@ -155,15 +156,15 @@ public Subscription onSubscribe(Observer<? super Map<K, Collection<V>>> t1) {
                 t1.onError(t);
                 return Subscriptions.empty();
             }
-            return source.subscribe(new ToMultimapObserver<T, K, V>(
+            return source.unsafeSubscribe(new ToMultimapObserver<T, K, V>(
                     t1, keySelector, valueSelector, map, collectionFactory
                     ));
         }
 
         /**
          * Observer that collects the source values of Ts into a multimap.
          */
-        public static class ToMultimapObserver<T, K, V> implements Observer<T> {
+        public static class ToMultimapObserver<T, K, V> extends Subscriber<T> {
             private final Func1<? super T, ? extends K> keySelector;
             private final Func1<? super T, ? extends V> valueSelector;
             private final Func1<? super K, ? extends Collection<V>> collectionFactory;

File: rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java
Patch:
@@ -32,7 +32,7 @@
  * return value of the get() method of that object, by using the from operation.
  * <p>
  * This is blocking so the Subscription returned when calling
- * <code>Observable.subscribe(Observer)</code> does nothing.
+ * <code>Observable.unsafeSubscribe(Observer)</code> does nothing.
  */
 public class OperationToObservableFuture {
     /* package accessible for unit tests */static class ToObservableFuture<T> implements OnSubscribeFunc<T> {

File: rxjava-core/src/main/java/rx/operators/OperationUsing.java
Patch:
@@ -21,6 +21,7 @@
 import rx.Subscription;
 import rx.functions.Func0;
 import rx.functions.Func1;
+import rx.observers.Subscribers;
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.Subscriptions;
 
@@ -46,12 +47,12 @@ public Subscription onSubscribe(Observer<? super T> observer) {
                     // Use SafeObserver to guarantee resourceSubscription will
                     // be unsubscribed.
                     return subscription.wrap(new CompositeSubscription(
-                            observable.subscribe(new SafeObserver<T>(
+                            observable.unsafeSubscribe(new SafeObserver<T>(
                                     subscription, observer)),
                             resourceSubscription));
                 } catch (Throwable e) {
                     resourceSubscription.unsubscribe();
-                    return Observable.<T> error(e).subscribe(observer);
+                    return Observable.<T> error(e).unsafeSubscribe(Subscribers.from(observer));
                 }
             }
         };

File: rxjava-core/src/main/java/rx/operators/OperatorAmb.java
Patch:
@@ -186,7 +186,7 @@ public void call(Subscriber<? super T> subscriber) {
             }
             AmbSubscriber<T> ambSubscriber = new AmbSubscriber<T>(subscriber, index, choice);
             subscriber.add(ambSubscriber);
-            source.subscribe(ambSubscriber);
+            source.unsafeSubscribe(ambSubscriber);
             index++;
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperatorCast.java
Patch:
@@ -17,7 +17,6 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
-import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 
 /**

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -108,7 +108,7 @@ public void call() {
                                     }
 
                                 }));
-                                _gps.subscribe(new Subscriber<T>(o) {
+                                _gps.unsafeSubscribe(new Subscriber<T>(o) {
 
                                     @Override
                                     public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperatorMerge.java
Patch:
@@ -63,7 +63,7 @@ public void onNext(Observable<? extends T> innerObservable) {
                 runningCount.incrementAndGet();
                 Subscriber<T> i = new InnerObserver();
                 childrenSubscriptions.add(i);
-                innerObservable.subscribe(i);
+                innerObservable.unsafeSubscribe(i);
             }
 
             final class InnerObserver extends Subscriber<T> {

File: rxjava-core/src/main/java/rx/operators/OperatorOnErrorFlatMap.java
Patch:
@@ -47,7 +47,7 @@ public void onCompleted() {
             public void onError(Throwable e) {
                 try {
                     Observable<? extends T> resume = resumeFunction.call(OnErrorThrowable.from(e));
-                    resume.subscribe(new Subscriber<T>() {
+                    resume.unsafeSubscribe(new Subscriber<T>() {
 
                         @Override
                         public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperatorOnErrorResumeNextViaFunction.java
Patch:
@@ -60,7 +60,7 @@ public void onCompleted() {
             public void onError(Throwable e) {
                 try {
                     Observable<? extends T> resume = resumeFunction.call(e);
-                    resume.subscribe(child);
+                    resume.unsafeSubscribe(child);
                 } catch (Throwable e2) {
                     child.onError(e2);
                 }

File: rxjava-core/src/main/java/rx/operators/OperatorRepeat.java
Patch:
@@ -77,7 +77,7 @@ public void onNext(final Observable<T> t) {
                     @Override
                     public void call(final Inner inner) {
                         executionCount++;
-                        t.subscribe(new Subscriber<T>(child) {
+                        t.unsafeSubscribe(new Subscriber<T>(child) {
 
                             @Override
                             public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperatorRetry.java
Patch:
@@ -77,7 +77,7 @@ public void onNext(final Observable<T> o) {
                     public void call(final Inner inner) {
                         final Action1<Inner> _self = this;
                         attempts.incrementAndGet();
-                        o.subscribe(new Subscriber<T>(s) {
+                        o.unsafeSubscribe(new Subscriber<T>(s) {
 
                             @Override
                             public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java
Patch:
@@ -55,7 +55,7 @@ public void onNext(final Observable<T> o) {
 
                     @Override
                     public void call(final Inner inner) {
-                        o.subscribe(subscriber);
+                        o.unsafeSubscribe(subscriber);
                     }
                 }));
             }

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutBase.java
Patch:
@@ -155,7 +155,8 @@ public void onTimeout(long seqId) {
                 if (other == null) {
                     serializedSubscriber.onError(new TimeoutException());
                 } else {
-                    serial.set(other.subscribe(serializedSubscriber));
+                    other.unsafeSubscribe(serializedSubscriber);
+                    serial.set(serializedSubscriber);
                 }
             }
         }

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutWithSelector.java
Patch:
@@ -51,7 +51,7 @@ public Subscription call(
                         timeoutSubscriber.onError(t);
                         return Subscriptions.empty();
                     }
-                    return o.subscribe(new Subscriber<U>() {
+                    return o.unsafeSubscribe(new Subscriber<U>() {
 
                         @Override
                         public void onCompleted() {
@@ -87,7 +87,7 @@ public Subscription call(
                     timeoutSubscriber.onError(t);
                     return Subscriptions.empty();
                 }
-                return o.subscribe(new Subscriber<V>() {
+                return o.unsafeSubscribe(new Subscriber<V>() {
 
                     @Override
                     public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperatorZip.java
Patch:
@@ -162,7 +162,7 @@ public Zip(Observable[] os, final Subscriber<? super R> observer, FuncN<? extend
         @SuppressWarnings("unchecked")
         public void zip() {
             for (int i = 0; i < os.length; i++) {
-                os[i].subscribe((InnerObserver) observers[i]);
+                os[i].unsafeSubscribe((InnerObserver) observers[i]);
             }
         }
 

File: rxjava-core/src/main/java/rx/operators/SafeObserver.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import rx.Observer;
+import rx.Subscriber;
 import rx.Subscription;
 import rx.exceptions.CompositeException;
 import rx.exceptions.OnErrorNotImplementedException;
@@ -61,7 +62,7 @@
  * @deprecated replaced by SafeSubscriber
  */
 @Deprecated
-public class SafeObserver<T> implements Observer<T> {
+public class SafeObserver<T> extends Subscriber<T> {
 
     private final Observer<? super T> actual;
     private final AtomicBoolean isFinished = new AtomicBoolean(false);

File: rxjava-core/src/test/java/rx/plugins/RxJavaPluginsTest.java
Patch:
@@ -72,6 +72,7 @@ public static class RxJavaErrorHandlerTestImpl extends RxJavaErrorHandler {
 
         @Override
         public void handleError(Throwable e) {
+            e.printStackTrace();
             this.e = e;
             count++;
         }
@@ -138,6 +139,7 @@ public void testOnErrorWhenNotImplemented() {
         RuntimeException re = new RuntimeException("test onError");
         try {
             Observable.error(re).subscribe();
+            fail("should fail");
         } catch (Throwable e) {
             // ignore as we expect it to throw
         }

File: rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java
Patch:
@@ -361,14 +361,14 @@ public void runConcurrencyTest() {
 
             // 12000 + 5000 + 75000 + 13500 + 22000 + 15000 + 7500 + 23500 = 173500
 
-            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4));
+            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4, f5, f6, f7, f8));
             try {
                 Thread.sleep(1);
             } catch (InterruptedException e) {
                 // ignore
             }
 
-            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10);
+            waitOnThreads(f10);
             @SuppressWarnings("unused")
             int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior
             assertEquals(173500, numNextEvents);

File: rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java
Patch:
@@ -361,14 +361,14 @@ public void runConcurrencyTest() {
 
             // 12000 + 5000 + 75000 + 13500 + 22000 + 15000 + 7500 + 23500 = 173500
 
-            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4));
+            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencyObserverEvent.onCompleted, f1, f2, f3, f4, f5, f6, f7, f8));
             try {
                 Thread.sleep(1);
             } catch (InterruptedException e) {
                 // ignore
             }
 
-            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10);
+            waitOnThreads(f10);
             @SuppressWarnings("unused")
             int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior
             assertEquals(173500, numNextEvents);

File: rxjava-core/src/main/java/rx/observers/SerializedSubscriber.java
Patch:
@@ -20,6 +20,7 @@ public class SerializedSubscriber<T> extends Subscriber<T> {
     private final Observer<T> s;
 
     public SerializedSubscriber(Subscriber<? super T> s) {
+        super(s);
         this.s = new SerializedObserver<T>(s);
     }
 

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutBase.java
Patch:
@@ -93,6 +93,7 @@ private TimeoutSubscriber(
                 SerializedSubscriber<T> serializedSubscriber,
                 TimeoutStub<T> timeoutStub, SerialSubscription serial,
                 Observable<? extends T> other) {
+            super(serializedSubscriber);
             this.serializedSubscriber = serializedSubscriber;
             this.timeoutStub = timeoutStub;
             this.serial = serial;

File: rxjava-core/src/test/java/rx/observers/TestSubscriberTest.java
Patch:
@@ -66,7 +66,8 @@ public void testAssertNotMatchValue() {
         oi.subscribe(o);
 
         thrown.expect(AssertionError.class);
-        thrown.expectMessage("Value at index: 1 expected to be [3] but was: [2]");
+        thrown.expectMessage("Value at index: 1 expected to be [3] (Integer) but was: [2] (Integer)");
+
 
         o.assertReceivedOnNext(Arrays.asList(1, 3));
         assertEquals(2, o.getOnNextEvents().size());

File: rxjava-core/src/main/java/rx/subjects/TestSubject.java
Patch:
@@ -83,7 +83,7 @@ public void call(SubjectObserver<? super T> o) {
                          */
                         lastNotification.get().accept(o);
                     }
-                });
+                }, null);
 
         return new TestSubject<T>(onSubscribe, subscriptionManager, lastNotification, scheduler);
     }
@@ -179,4 +179,4 @@ public void call(Inner t1) {
 
         }, timeInMilliseconds, TimeUnit.MILLISECONDS);
     }
-}
\ No newline at end of file
+}

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -56,7 +56,6 @@
 import rx.operators.OperationAsObservable;
 import rx.operators.OperationAverage;
 import rx.operators.OperationBuffer;
-import rx.operators.OperationCache;
 import rx.operators.OperationCombineLatest;
 import rx.operators.OperationConcat;
 import rx.operators.OperationDebounce;
@@ -105,6 +104,7 @@
 import rx.operators.OperationUsing;
 import rx.operators.OperationWindow;
 import rx.operators.OperatorAmb;
+import rx.operators.OperatorCache;
 import rx.operators.OperatorCast;
 import rx.operators.OperatorDoOnEach;
 import rx.operators.OperatorFilter;
@@ -3863,7 +3863,7 @@ public final <B> Observable<List<T>> buffer(Observable<B> boundary, int initialC
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-cache">RxJava Wiki: cache()</a>
      */
     public final Observable<T> cache() {
-        return create(OperationCache.cache(this));
+        return create(new OperatorCache<T>(this));
     }
 
     /**

File: rxjava-core/src/test/java/rx/operators/OperatorFirstTest.java
Patch:
@@ -30,7 +30,7 @@
 import rx.Observer;
 import rx.functions.Func1;
 
-public class OperationFirstOrDefaultTest {
+public class OperatorFirstTest {
 
     @Mock
     Observer<String> w;

File: rxjava-core/src/test/java/rx/operators/OperatorLastTest.java
Patch:
@@ -30,7 +30,7 @@
 import rx.Observer;
 import rx.functions.Func1;
 
-public class OperationLastTest {
+public class OperatorLastTest {
 
     @Test
     public void testLastWithElements() {

File: rxjava-core/src/main/java/rx/operators/OperatorSubscribeOnBounded.java
Patch:
@@ -88,14 +88,13 @@ public void onNext(final Observable<T> o) {
                 if (checkNeedBuffer(o)) {
                     // use buffering (possibly blocking) for a possibly synchronous subscribe
                     final BufferUntilSubscriber<T> bus = new BufferUntilSubscriber<T>(bufferSize, subscriber);
-                    o.subscribe(bus);
                     subscriber.add(scheduler.schedule(new Action1<Inner>() {
                         @Override
                         public void call(final Inner inner) {
                             bus.enterPassthroughMode();
                         }
                     }));
-                    return;
+                    o.subscribe(bus);
                 } else {
                     // no buffering (async subscribe)
                     subscriber.add(scheduler.schedule(new Action1<Inner>() {

File: rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java
Patch:
@@ -247,7 +247,9 @@ public void testFromReader() {
 
     @Test
     public void testByLine() {
-        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", "\nasdf\n", "zx", "cv"))).toList().toBlockingObservable().single();
+        String newLine = System.getProperty("line.separator");
+        
+        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", newLine + "asdf" + newLine, "zx", "cv"))).toList().toBlockingObservable().single();
 
         assertEquals(Arrays.asList(new Line(0, "qwer"), new Line(1, "asdf"), new Line(2, "zxcv")), lines);
     }

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -82,7 +82,7 @@ public void call(SubjectObserver<? super T> o) {
                         // to send onCompleted if the last value is an onNext
                         emitValueToObserver(lastNotification.get(), o);
                     }
-                });
+                }, null);
 
         return new AsyncSubject<T>(onSubscribe, subscriptionManager, lastNotification);
     }

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -128,7 +128,7 @@ public void call(SubjectObserver<? super T> o) {
                          */
                         lastNotification.get().accept(o);
                     }
-                });
+                }, null);
 
         return new BehaviorSubject<T>(onSubscribe, subscriptionManager, lastNotification);
     }

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -79,7 +79,7 @@ public void call(SubjectObserver<? super T> o) {
                          */
                         lastNotification.get().accept(o);
                     }
-                });
+                }, null);
 
         return new PublishSubject<T>(onSubscribe, subscriptionManager, lastNotification);
     }

File: rxjava-contrib/rxjava-string/src/test/java/rx/observables/StringObservableTest.java
Patch:
@@ -247,7 +247,9 @@ public void testFromReader() {
 
     @Test
     public void testByLine() {
-        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", "\nasdf\n", "zx", "cv"))).toList().toBlockingObservable().single();
+        String newLine = System.getProperty("line.separator");
+        
+        List<Line> lines = StringObservable.byLine(Observable.from(Arrays.asList("qwer", newLine + "asdf" + newLine, "zx", "cv"))).toList().toBlockingObservable().single();
 
         assertEquals(Arrays.asList(new Line(0, "qwer"), new Line(1, "asdf"), new Line(2, "zxcv")), lines);
     }

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -82,7 +82,7 @@ public void call(SubjectObserver<? super T> o) {
                         // to send onCompleted if the last value is an onNext
                         emitValueToObserver(lastNotification.get(), o);
                     }
-                });
+                }, null);
 
         return new AsyncSubject<T>(onSubscribe, subscriptionManager, lastNotification);
     }

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -128,7 +128,7 @@ public void call(SubjectObserver<? super T> o) {
                          */
                         lastNotification.get().accept(o);
                     }
-                });
+                }, null);
 
         return new BehaviorSubject<T>(onSubscribe, subscriptionManager, lastNotification);
     }

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -79,7 +79,7 @@ public void call(SubjectObserver<? super T> o) {
                          */
                         lastNotification.get().accept(o);
                     }
-                });
+                }, null);
 
         return new PublishSubject<T>(onSubscribe, subscriptionManager, lastNotification);
     }

File: rxjava-core/src/main/java/rx/observers/SynchronizedSubscriber.java
Patch:
@@ -42,7 +42,7 @@ public SynchronizedSubscriber(Subscriber<? super T> subscriber, Object lock) {
     /**
      * Used when synchronizing an Subscriber without access to the subscription.
      * 
-     * @param Observer
+     * @param subscriber
      */
     public SynchronizedSubscriber(Subscriber<? super T> subscriber) {
         this(subscriber, new Object());

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -4101,7 +4101,7 @@ public final <U, V> Observable<T> delay(
      * <p>
      * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.o.png">
      * <p>
-     * <em>Note:</code> the resulting Observable will immediately propagate any {@code onError} notification
+     * <em>Note:</em> the resulting Observable will immediately propagate any {@code onError} notification
      * from the source Observable.
      * 
      * @param <U>

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java
Patch:
@@ -35,7 +35,7 @@ public static <T, C> DebugNotification<T> createSubscribe(Observer<? super T> o,
             o = ds.getActual();
         }
         if (sourceFunc instanceof DebugHook.DebugOnSubscribe) {
-            sourceFunc = ((DebugHook<C>.DebugOnSubscribe<T>) sourceFunc).getActual();
+            sourceFunc = (OnSubscribe<T>) ((SafeSubscriber) sourceFunc).getActual();
         }
         return new DebugNotification<T>(o, from, Kind.Subscribe, null, null, to, source, sourceFunc);
     }

File: rxjava-contrib/rxjava-debug/src/test/java/rx/debug/DebugHookTest.java
Patch:
@@ -13,6 +13,7 @@
 import org.hamcrest.Description;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.InOrder;
 
@@ -85,6 +86,7 @@ public void assertValidState() {
     }
 
     @SuppressWarnings("unchecked")
+    @Ignore
     @Test
     public void testSimple() {
         TestDebugNotificationListener listener = new TestDebugNotificationListener();
@@ -107,6 +109,7 @@ public void testSimple() {
     }
 
     @SuppressWarnings("unchecked")
+    @Ignore
     @Test
     public void testOneOp() {
         TestDebugNotificationListener listener = new TestDebugNotificationListener();

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -5985,7 +5985,7 @@ public final ConnectableObservable<T> replay(Scheduler scheduler) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-retry">RxJava Wiki: retry()</a>
      */
     public final Observable<T> retry() {
-        return create(OperationRetry.retry(this));
+        return nest().lift(new OperatorRetry<T>());
     }
 
     /**
@@ -6009,7 +6009,7 @@ public final Observable<T> retry() {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-retry">RxJava Wiki: retry()</a>
      */
     public final Observable<T> retry(int retryCount) {
-        return create(OperationRetry.retry(this, retryCount));
+        return nest().lift(new OperatorRetry<T>(retryCount));
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperatorMap.java
Patch:
@@ -61,3 +61,4 @@ public void onNext(T t) {
     }
 
 }
+

File: rxjava-core/src/main/java/rx/operators/OnSubscribeFromIterable.java
Patch:
@@ -42,6 +42,9 @@ public void call(Subscriber<? super T> o) {
             }
             o.onNext(i);
         }
+        if (o.isUnsubscribed()) {
+            return;
+        }
         o.onCompleted();
     }
 

File: rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragment.java
Patch:
@@ -36,7 +36,7 @@ public RetainedFragment() {
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        strings = SampleObservables.numberStrings2().cache();
+        strings = SampleObservables.numberStrings().cache();
     }
 
     @Override

File: rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java
Patch:
@@ -59,6 +59,7 @@ private AndroidObservable() {}
      * @return a new observable sequence that will emit notifications on the main UI thread
      */
     public static <T> Observable<T> fromActivity(Activity activity, Observable<T> sourceObservable) {
+        Assertions.assertUiThread();
         return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);
     }
 
@@ -87,6 +88,7 @@ public static <T> Observable<T> fromActivity(Activity activity, Observable<T> so
      * @return a new observable sequence that will emit notifications on the main UI thread
      */
     public static <T> Observable<T> fromFragment(Object fragment, Observable<T> sourceObservable) {
+        Assertions.assertUiThread();
         if (USES_SUPPORT_FRAGMENTS && fragment instanceof android.support.v4.app.Fragment) {
             return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);
         } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && fragment instanceof Fragment) {

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorCompoundButtonInput.java
Patch:
@@ -23,7 +23,7 @@
 import rx.Observable;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.android.observables.ViewObservable;
+import rx.android.observables.Assertions;
 import rx.android.subscriptions.AndroidSubscriptions;
 import rx.functions.Action0;
 import android.view.View;
@@ -40,7 +40,7 @@ public OperatorCompoundButtonInput(final CompoundButton button, final boolean em
 
     @Override
     public void call(final Subscriber<? super Boolean> observer) {
-        ViewObservable.assertUiThread();
+        Assertions.assertUiThread();
         final CompositeOnCheckedChangeListener composite = CachedListeners.getFromViewOrCreate(button);
 
         final CompoundButton.OnCheckedChangeListener listener = new CompoundButton.OnCheckedChangeListener() {

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorEditTextInput.java
Patch:
@@ -18,7 +18,7 @@
 import rx.Observable;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.android.observables.ViewObservable;
+import rx.android.observables.Assertions;
 import rx.android.subscriptions.AndroidSubscriptions;
 import rx.functions.Action0;
 import android.text.Editable;
@@ -36,7 +36,7 @@ public OperatorEditTextInput(final EditText input, final boolean emitInitialValu
 
     @Override
     public void call(final Subscriber<? super String> observer) {
-        ViewObservable.assertUiThread();
+        Assertions.assertUiThread();
         final TextWatcher watcher = new SimpleTextWatcher() {
             @Override
             public void afterTextChanged(final Editable editable) {

File: rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorViewClick.java
Patch:
@@ -23,7 +23,7 @@
 import rx.Observable;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.android.observables.ViewObservable;
+import rx.android.observables.Assertions;
 import rx.android.subscriptions.AndroidSubscriptions;
 import rx.functions.Action0;
 import android.view.View;
@@ -39,7 +39,7 @@ public OperatorViewClick(final View view, final boolean emitInitialValue) {
 
     @Override
     public void call(final Subscriber<? super View> observer) {
-        ViewObservable.assertUiThread();
+        Assertions.assertUiThread();
         final CompositeOnClickListener composite = CachedListeners.getFromViewOrCreate(view);
 
         final View.OnClickListener listener = new View.OnClickListener() {

File: rxjava-core/src/main/java/rx/operators/OperatorSubscribeOnBounded.java
Patch:
@@ -88,14 +88,13 @@ public void onNext(final Observable<T> o) {
                 if (checkNeedBuffer(o)) {
                     // use buffering (possibly blocking) for a possibly synchronous subscribe
                     final BufferUntilSubscriber<T> bus = new BufferUntilSubscriber<T>(bufferSize, subscriber);
-                    o.subscribe(bus);
                     subscriber.add(scheduler.schedule(new Action1<Inner>() {
                         @Override
                         public void call(final Inner inner) {
                             bus.enterPassthroughMode();
                         }
                     }));
-                    return;
+                    o.subscribe(bus);
                 } else {
                     // no buffering (async subscribe)
                     subscriber.add(scheduler.schedule(new Action1<Inner>() {

File: rxjava-core/src/main/java/rx/schedulers/Schedulers.java
Patch:
@@ -88,7 +88,7 @@ public Scheduler call() {
      * @return {@link ImmediateScheduler} instance
      */
     public static Scheduler immediate() {
-        return ImmediateScheduler.getInstance();
+        return ImmediateScheduler.instance();
     }
 
     /**
@@ -99,7 +99,7 @@ public static Scheduler immediate() {
      */
     @Deprecated
     public static Scheduler currentThread() {
-        return TrampolineScheduler.getInstance();
+        return TrampolineScheduler.instance();
     }
 
     /**
@@ -108,7 +108,7 @@ public static Scheduler currentThread() {
      * @return {@link TrampolineScheduler} instance
      */
     public static Scheduler trampoline() {
-        return TrampolineScheduler.getInstance();
+        return TrampolineScheduler.instance();
     }
 
     /**

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -93,7 +93,9 @@ protected HttpResponse buildResult(HttpContext context) throws Exception {
 
     @Override
     protected void releaseResources() {
-        consumer._releaseResources();
+        if (consumer != null) {
+            consumer._releaseResources();
+        }
     }
 
 }

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -93,7 +93,9 @@ protected HttpResponse buildResult(HttpContext context) throws Exception {
 
     @Override
     protected void releaseResources() {
-        consumer._releaseResources();
+        if (consumer != null) {
+            consumer._releaseResources();
+        }
     }
 
 }

File: rxjava-core/src/main/java/rx/operators/OperatorDoOnEach.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 
 /**
  * Converts the elements of an observable sequence to the specified type.
@@ -59,7 +60,7 @@ public void onNext(T value) {
                 try {
                     doOnEachObserver.onNext(value);
                 } catch (Throwable e) {
-                    onError(e);
+                    onError(OnErrorThrowable.addValueAsLastCause(e, value));
                     return;
                 }
                 observer.onNext(value);

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -23,6 +23,7 @@
 import rx.Observable.OnSubscribe;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.observables.GroupedObservable;
@@ -130,7 +131,7 @@ public void onNext(T t) {
                     // we have the correct group so send value to it
                     gps.onNext(t);
                 } catch (Throwable e) {
-                    onError(e);
+                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorMap.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func1;
 
 /**
@@ -52,7 +53,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(transformer.call(t));
                 } catch (Throwable e) {
-                    onError(e);
+                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorScan.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func2;
 
 /**
@@ -96,8 +97,7 @@ public void onNext(T value) {
                     try {
                         this.value = accumulator.call(this.value, value);
                     } catch (Throwable e) {
-                        observer.onError(e);
-                        observer.unsubscribe();
+                        observer.onError(OnErrorThrowable.addValueAsLastCause(e, value));
                     }
                 }
                 observer.onNext(this.value);

File: rxjava-core/src/main/java/rx/operators/OperatorCast.java
Patch:
@@ -50,7 +50,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(castClass.cast(t));
                 } catch (Throwable e) {
-                    onError(OnErrorThrowable.decorate(e, t));
+                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }
         };

File: rxjava-core/src/main/java/rx/operators/OperatorDoOnEach.java
Patch:
@@ -60,7 +60,7 @@ public void onNext(T value) {
                 try {
                     doOnEachObserver.onNext(value);
                 } catch (Throwable e) {
-                    onError(OnErrorThrowable.decorate(e, value));
+                    onError(OnErrorThrowable.addValueAsLastCause(e, value));
                     return;
                 }
                 observer.onNext(value);

File: rxjava-core/src/main/java/rx/operators/OperatorFilter.java
Patch:
@@ -54,7 +54,7 @@ public void onNext(T t) {
                         child.onNext(t);
                     }
                 } catch (Throwable e) {
-                    child.onError(OnErrorThrowable.decorate(e, t));
+                    child.onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -131,7 +131,7 @@ public void onNext(T t) {
                     // we have the correct group so send value to it
                     gps.onNext(t);
                 } catch (Throwable e) {
-                    onError(OnErrorThrowable.decorate(e, t));
+                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorMap.java
Patch:
@@ -53,7 +53,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(transformer.call(t));
                 } catch (Throwable e) {
-                    onError(OnErrorThrowable.decorate(e, t));
+                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorScan.java
Patch:
@@ -97,7 +97,7 @@ public void onNext(T value) {
                     try {
                         this.value = accumulator.call(this.value, value);
                     } catch (Throwable e) {
-                        observer.onError(OnErrorThrowable.decorate(e, value));
+                        observer.onError(OnErrorThrowable.addValueAsLastCause(e, value));
                     }
                 }
                 observer.onNext(this.value);

File: rxjava-core/src/main/java/rx/operators/OperatorZip.java
Patch:
@@ -194,7 +194,7 @@ void tick() {
                             // all have something so emit
                             observer.onNext(zipFunction.call(vs));
                         } catch (Throwable e) {
-                            observer.onError(OnErrorThrowable.decorate(e, vs));
+                            observer.onError(OnErrorThrowable.addValueAsLastCause(e, vs));
                             return;
                         }
                         // now remove them

File: rxjava-core/src/main/java/rx/operators/OperatorCast.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.exceptions.OnErrorThrowable;
 
 /**
@@ -49,7 +50,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(castClass.cast(t));
                 } catch (Throwable e) {
-                    onError(new OnErrorThrowable(e, t));
+                    onError(OnErrorThrowable.decorate(e, t));
                 }
             }
         };

File: rxjava-core/src/main/java/rx/operators/OperatorDoOnEach.java
Patch:
@@ -60,7 +60,7 @@ public void onNext(T value) {
                 try {
                     doOnEachObserver.onNext(value);
                 } catch (Throwable e) {
-                    onError(new OnErrorThrowable(e, value));
+                    onError(OnErrorThrowable.decorate(e, value));
                     return;
                 }
                 observer.onNext(value);

File: rxjava-core/src/main/java/rx/operators/OperatorFilter.java
Patch:
@@ -54,7 +54,7 @@ public void onNext(T t) {
                         child.onNext(t);
                     }
                 } catch (Throwable e) {
-                    child.onError(new OnErrorThrowable(e, t));
+                    child.onError(OnErrorThrowable.decorate(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -131,7 +131,7 @@ public void onNext(T t) {
                     // we have the correct group so send value to it
                     gps.onNext(t);
                 } catch (Throwable e) {
-                    onError(new OnErrorThrowable(e, t));
+                    onError(OnErrorThrowable.decorate(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorMap.java
Patch:
@@ -53,7 +53,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(transformer.call(t));
                 } catch (Throwable e) {
-                    onError(new OnErrorThrowable(e, t));
+                    onError(OnErrorThrowable.decorate(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorScan.java
Patch:
@@ -97,7 +97,7 @@ public void onNext(T value) {
                     try {
                         this.value = accumulator.call(this.value, value);
                     } catch (Throwable e) {
-                        observer.onError(new OnErrorThrowable(e, value));
+                        observer.onError(OnErrorThrowable.decorate(e, value));
                     }
                 }
                 observer.onNext(this.value);

File: rxjava-core/src/main/java/rx/operators/OperatorZip.java
Patch:
@@ -194,7 +194,7 @@ void tick() {
                             // all have something so emit
                             observer.onNext(zipFunction.call(vs));
                         } catch (Throwable e) {
-                            observer.onError(new OnErrorThrowable(e, vs));
+                            observer.onError(OnErrorThrowable.decorate(e, vs));
                             return;
                         }
                         // now remove them

File: rxjava-core/src/main/java/rx/operators/OperatorDoOnEach.java
Patch:
@@ -18,6 +18,7 @@
 import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 
 /**
  * Converts the elements of an observable sequence to the specified type.
@@ -59,7 +60,7 @@ public void onNext(T value) {
                 try {
                     doOnEachObserver.onNext(value);
                 } catch (Throwable e) {
-                    onError(e);
+                    onError(new OnErrorThrowable(e, value));
                     return;
                 }
                 observer.onNext(value);

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -23,6 +23,7 @@
 import rx.Observable.OnSubscribe;
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.observables.GroupedObservable;
@@ -130,7 +131,7 @@ public void onNext(T t) {
                     // we have the correct group so send value to it
                     gps.onNext(t);
                 } catch (Throwable e) {
-                    onError(e);
+                    onError(new OnErrorThrowable(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorMap.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func1;
 
 /**
@@ -52,7 +53,7 @@ public void onNext(T t) {
                 try {
                     o.onNext(transformer.call(t));
                 } catch (Throwable e) {
-                    onError(e);
+                    onError(new OnErrorThrowable(e, t));
                 }
             }
 

File: rxjava-core/src/main/java/rx/operators/OperatorScan.java
Patch:
@@ -17,6 +17,7 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func2;
 
 /**
@@ -96,8 +97,7 @@ public void onNext(T value) {
                     try {
                         this.value = accumulator.call(this.value, value);
                     } catch (Throwable e) {
-                        observer.onError(e);
-                        observer.unsubscribe();
+                        observer.onError(new OnErrorThrowable(e, value));
                     }
                 }
                 observer.onNext(this.value);

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -79,7 +79,7 @@
 import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperationMinMax;
 import rx.operators.OperationMulticast;
-import rx.operators.OperationOnErrorResumeNextViaFunction;
+import rx.operators.OperatorOnErrorResumeNextViaFunction;
 import rx.operators.OperationOnErrorResumeNextViaObservable;
 import rx.operators.OperationOnErrorReturn;
 import rx.operators.OperationOnExceptionResumeNextViaObservable;
@@ -5209,7 +5209,7 @@ public final Boolean call(T t) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#wiki-onerrorresumenext">RxJava Wiki: onErrorResumeNext()</a>
      */
     public final Observable<T> onErrorResumeNext(final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction) {
-        return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));
+        return create(OperatorOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));
     }
 
     /**

File: rxjava-core/src/test/java/rx/operators/OperatorOnErrorResumeNextViaFunctionTest.java
Patch:
@@ -18,7 +18,7 @@
 import static org.junit.Assert.*;
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
-import static rx.operators.OperationOnErrorResumeNextViaFunction.*;
+import static rx.operators.OperatorOnErrorResumeNextViaFunction.*;
 
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -31,7 +31,7 @@
 import rx.functions.Func1;
 import rx.subscriptions.Subscriptions;
 
-public class OperationOnErrorResumeNextViaFunctionTest {
+public class OperatorOnErrorResumeNextViaFunctionTest {
 
     @Test
     public void testResumeNextWithSynchronousExecution() {

File: rxjava-contrib/rxjava-debug/src/test/java/rx/debug/DebugHookTest.java
Patch:
@@ -63,7 +63,7 @@ public void onError(Throwable e) {
             public void onNext(Integer t) {
             }
         });
-        verify(events, times(6)).call(subscribe());
+        verify(events, atLeast(3)).call(subscribe());
         verify(events, times(4)).call(onNext(1));
         // one less because it originates from the inner observable sent to merge
         verify(events, times(3)).call(onNext(2));

File: rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java
Patch:
@@ -700,7 +700,7 @@ public void call() {
 
                             });
                 } else {
-                    return group.nest().lift(new OperatorSubscribeOn<Integer>(Schedulers.newThread(), 1)).delay(400, TimeUnit.MILLISECONDS).map(new Func1<Integer, String>() {
+                    return group.nest().lift(new OperatorSubscribeOnBounded<Integer>(Schedulers.newThread(), 1)).delay(400, TimeUnit.MILLISECONDS).map(new Func1<Integer, String>() {
 
                         @Override
                         public String call(Integer t1) {
@@ -826,7 +826,7 @@ public Integer call(Integer t) {
 
             @Override
             public Observable<String> call(final GroupedObservable<Integer, Integer> group) {
-                return group.nest().lift(new OperatorSubscribeOn<Integer>(Schedulers.newThread(), 0)).map(new Func1<Integer, String>() {
+                return group.nest().lift(new OperatorSubscribeOnBounded<Integer>(Schedulers.newThread(), 0)).map(new Func1<Integer, String>() {
 
                     @Override
                     public String call(Integer t1) {

File: rxjava-core/src/test/java/rx/subscriptions/CompositeSubscriptionTest.java
Patch:
@@ -238,7 +238,7 @@ public void testClear() {
         s.clear();
 
         assertTrue(s1.isUnsubscribed());
-        assertTrue(s1.isUnsubscribed());
+        assertTrue(s2.isUnsubscribed());
         assertFalse(s.isUnsubscribed());
 
         BooleanSubscription s3 = new BooleanSubscription();

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugHook.java
Patch:
@@ -63,7 +63,7 @@ public void call(Subscriber<? super T> o) {
     }
 
     @Override
-    public <T, R> Operator<R, T> onLift(final Operator<R, T> bind) {
+    public <T, R> Operator<? extends R, ? super T> onLift(final Operator<? extends R, ? super T> bind) {
         return new Operator<R, T>() {
             @Override
             public Subscriber<? super T> call(final Subscriber<? super R> o) {
@@ -78,7 +78,7 @@ public <T> Subscription onAdd(Subscriber<T> subscriber, Subscription s) {
     }
 
     @SuppressWarnings("unchecked")
-    private <R> Subscriber<? super R> wrapOutbound(Operator<R, ?> bind, Subscriber<? super R> o) {
+    private <R> Subscriber<? super R> wrapOutbound(Operator<? extends R, ?> bind, Subscriber<? super R> o) {
         if (o instanceof DebugSubscriber) {
             if (bind != null)
                 ((DebugSubscriber<R>) o).setFrom(bind);
@@ -88,7 +88,7 @@ private <R> Subscriber<? super R> wrapOutbound(Operator<R, ?> bind, Subscriber<?
     }
 
     @SuppressWarnings("unchecked")
-    private <T> Subscriber<? super T> wrapInbound(Operator<?, T> bind, Subscriber<? super T> o) {
+    private <T> Subscriber<? super T> wrapInbound(Operator<?, ? super T> bind, Subscriber<? super T> o) {
         if (o instanceof DebugSubscriber) {
             if (bind != null)
                 ((DebugSubscriber<T>) o).setTo(bind);

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -97,7 +97,7 @@ public <T> OnSubscribe<T> onCreate(OnSubscribe<T> f) {
         return f;
     }
 
-    public <T, R> Operator<R, T> onLift(final Operator<R, T> bind) {
+    public <T, R> Operator<? extends R, ? super T> onLift(final Operator<? extends R, ? super T> bind) {
         return bind;
     }
 

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugHook.java
Patch:
@@ -63,7 +63,7 @@ public void call(Subscriber<? super T> o) {
     }
 
     @Override
-    public <T, R> Operator<R, T> onLift(final Operator<R, T> bind) {
+    public <T, R> Operator<? extends R, ? super T> onLift(final Operator<? extends R, ? super T> bind) {
         return new Operator<R, T>() {
             @Override
             public Subscriber<? super T> call(final Subscriber<? super R> o) {
@@ -78,7 +78,7 @@ public <T> Subscription onAdd(Subscriber<T> subscriber, Subscription s) {
     }
 
     @SuppressWarnings("unchecked")
-    private <R> Subscriber<? super R> wrapOutbound(Operator<R, ?> bind, Subscriber<? super R> o) {
+    private <R> Subscriber<? super R> wrapOutbound(Operator<? extends R, ?> bind, Subscriber<? super R> o) {
         if (o instanceof DebugSubscriber) {
             if (bind != null)
                 ((DebugSubscriber<R>) o).setFrom(bind);
@@ -88,7 +88,7 @@ private <R> Subscriber<? super R> wrapOutbound(Operator<R, ?> bind, Subscriber<?
     }
 
     @SuppressWarnings("unchecked")
-    private <T> Subscriber<? super T> wrapInbound(Operator<?, T> bind, Subscriber<? super T> o) {
+    private <T> Subscriber<? super T> wrapInbound(Operator<?, ? super T> bind, Subscriber<? super T> o) {
         if (o instanceof DebugSubscriber) {
             if (bind != null)
                 ((DebugSubscriber<T>) o).setTo(bind);

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -97,7 +97,7 @@ public <T> OnSubscribe<T> onCreate(OnSubscribe<T> f) {
         return f;
     }
 
-    public <T, R> Operator<R, T> onLift(final Operator<R, T> bind) {
+    public <T, R> Operator<? extends R, ? super T> onLift(final Operator<? extends R, ? super T> bind) {
         return bind;
     }
 

File: rxjava-contrib/rxjava-debug/src/main/java/rx/operators/DebugSubscriber.java
Patch:
@@ -1,5 +1,6 @@
 package rx.operators;
 
+import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
 import rx.plugins.DebugNotification;

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugHook.java
Patch:
@@ -2,10 +2,10 @@
 
 import rx.Observable;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.Subscription;
 import rx.operators.DebugSubscriber;
-import rx.operators.Operator;
 import rx.util.functions.Action1;
 import rx.util.functions.Actions;
 import rx.util.functions.Func1;

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java
Patch:
@@ -2,11 +2,10 @@
 
 import rx.Notification;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Operator;
 import rx.Observer;
 import rx.observers.SafeSubscriber;
 import rx.operators.DebugSubscriber;
-import rx.operators.Operator;
-import rx.plugins.DebugNotification.Kind;
 
 public class DebugNotification<T> {
     public static enum Kind {

File: rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/NotificationEvent.java
Patch:
@@ -2,10 +2,10 @@
 
 import rx.Notification;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Operator;
 import rx.Observer;
 import rx.observers.SafeSubscriber;
 import rx.operators.DebugSubscriber;
-import rx.operators.Operator;
 
 public class NotificationEvent<T> {
     public static enum Kind {

File: rxjava-contrib/rxjava-string/src/main/java/rx/observables/StringObservable.java
Patch:
@@ -31,8 +31,8 @@
 
 import rx.Observable;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Operator;
 import rx.Subscriber;
-import rx.operators.Operator;
 import rx.util.functions.Func1;
 import rx.util.functions.Func2;
 

File: rxjava-core/src/main/java/rx/joins/JoinObserver1.java
Patch:
@@ -25,7 +25,6 @@
 import rx.Observable;
 import rx.Subscriber;
 import rx.observers.SafeSubscriber;
-import rx.operators.SafeObservableSubscription;
 import rx.util.functions.Action1;
 
 /**

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -29,7 +29,6 @@
 import rx.operators.OperationNext;
 import rx.operators.OperationToFuture;
 import rx.operators.OperationToIterator;
-import rx.operators.SafeObservableSubscription;
 import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 

File: rxjava-core/src/main/java/rx/observers/Observers.java
Patch:
@@ -1,7 +1,6 @@
 package rx.observers;
 
 import rx.Observer;
-import rx.Subscriber;
 import rx.util.OnErrorNotImplementedException;
 import rx.util.functions.Action0;
 import rx.util.functions.Action1;

File: rxjava-core/src/main/java/rx/observers/TestObserver.java
Patch:
@@ -16,7 +16,6 @@
 package rx.observers;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 

File: rxjava-core/src/main/java/rx/operators/ChunkedOperation.java
Patch:
@@ -29,7 +29,6 @@
 import rx.Scheduler;
 import rx.Scheduler.Inner;
 import rx.Subscription;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
 import rx.util.functions.Func1;

File: rxjava-core/src/main/java/rx/operators/OperationDebounce.java
Patch:
@@ -28,7 +28,6 @@
 import rx.schedulers.Schedulers;
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.SerialSubscription;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 

File: rxjava-core/src/main/java/rx/operators/OperationDelay.java
Patch:
@@ -27,7 +27,6 @@
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.SerialSubscription;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
 import rx.util.functions.Func1;

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -27,9 +27,7 @@
 import rx.observers.SynchronizedObserver;
 import rx.subscriptions.BooleanSubscription;
 import rx.subscriptions.CompositeSubscription;
-import rx.subscriptions.Subscriptions;
 import rx.util.CompositeException;
-import rx.util.functions.Action0;
 
 /**
  * This behaves like {@link OperatorMerge} except that if any of the merged Observables notify of

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -26,7 +26,6 @@
 import rx.Scheduler.Inner;
 import rx.Subscription;
 import rx.subscriptions.CompositeSubscription;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 
 /**

File: rxjava-core/src/main/java/rx/operators/OperationTakeTimed.java
Patch:
@@ -26,7 +26,6 @@
 import rx.Subscription;
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 
 /**

File: rxjava-core/src/main/java/rx/operators/OperationTimer.java
Patch:
@@ -22,7 +22,6 @@
 import rx.Scheduler;
 import rx.Scheduler.Inner;
 import rx.Subscription;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 
 /**

File: rxjava-core/src/main/java/rx/operators/OperatorCast.java
Patch:
@@ -15,6 +15,7 @@
  */
 package rx.operators;
 
+import rx.Observable.Operator;
 import rx.Subscriber;
 
 

File: rxjava-core/src/main/java/rx/operators/OperatorDoOnEach.java
Patch:
@@ -15,6 +15,7 @@
  */
 package rx.operators;
 
+import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
 

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import rx.Observable.OnSubscribe;
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.observables.GroupedObservable;
 import rx.subjects.PublishSubject;

File: rxjava-core/src/main/java/rx/operators/OperatorMap.java
Patch:
@@ -15,6 +15,7 @@
  */
 package rx.operators;
 
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.util.functions.Func1;
 

File: rxjava-core/src/main/java/rx/operators/OperatorMerge.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import rx.Observable;
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.observers.SynchronizedSubscriber;
 

File: rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicLong;
 
+import rx.Observable.Operator;
 import rx.Scheduler;
 import rx.Scheduler.Inner;
 import rx.Subscriber;

File: rxjava-core/src/main/java/rx/operators/OperatorParallel.java
Patch:
@@ -16,6 +16,7 @@
 package rx.operators;
 
 import rx.Observable;
+import rx.Observable.Operator;
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.observables.GroupedObservable;

File: rxjava-core/src/main/java/rx/operators/OperatorRepeat.java
Patch:
@@ -17,6 +17,7 @@
 package rx.operators;
 
 import rx.Observable;
+import rx.Observable.Operator;
 import rx.Scheduler;
 import rx.Scheduler.Inner;
 import rx.Subscriber;

File: rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java
Patch:
@@ -16,6 +16,7 @@
 package rx.operators;
 
 import rx.Observable;
+import rx.Observable.Operator;
 import rx.Scheduler;
 import rx.Scheduler.Inner;
 import rx.Subscriber;

File: rxjava-core/src/main/java/rx/operators/OperatorTake.java
Patch:
@@ -15,6 +15,7 @@
  */
 package rx.operators;
 
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.subscriptions.CompositeSubscription;
 

File: rxjava-core/src/main/java/rx/operators/OperatorTimeoutBase.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import rx.Observable;
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.Subscription;
 import rx.observers.SynchronizedSubscriber;

File: rxjava-core/src/main/java/rx/operators/OperatorTimestamp.java
Patch:
@@ -15,6 +15,7 @@
  */
 package rx.operators;
 
+import rx.Observable.Operator;
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.util.Timestamped;

File: rxjava-core/src/main/java/rx/operators/OperatorToObservableList.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import rx.Observable.Operator;
 import rx.Subscriber;
 
 /**

File: rxjava-core/src/main/java/rx/operators/OperatorToObservableSortedList.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.Comparator;
 import java.util.List;
 
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.util.functions.Func2;
 

File: rxjava-core/src/main/java/rx/operators/OperatorZip.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import rx.Observable;
+import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
 import rx.subscriptions.CompositeSubscription;

File: rxjava-core/src/main/java/rx/operators/OperatorZipIterable.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.Iterator;
 
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.observers.Subscribers;
 import rx.util.functions.Func2;

File: rxjava-core/src/main/java/rx/operators/SafeObserver.java
Patch:
@@ -20,6 +20,7 @@
 
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SynchronizedObserver;
 import rx.plugins.RxJavaPlugins;
 import rx.subscriptions.Subscriptions;
 import rx.util.CompositeException;

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -18,9 +18,9 @@
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.Observable.OnSubscribeFunc;
+import rx.Observable.Operator;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.operators.Operator;
 import rx.util.functions.Func1;
 
 /**

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -20,10 +20,10 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
+import rx.Observable.OnSubscribe;
 import rx.Observer;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.Observable.OnSubscribe;
 import rx.operators.SafeObservableSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Action0;

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -16,7 +16,6 @@
 package rx.subscriptions;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 

File: rxjava-core/src/perf/java/rx/operators/ObservableBenchmark.java
Patch:
@@ -11,6 +11,7 @@
 
 import rx.Observable;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Operator;
 import rx.Observer;
 import rx.Subscriber;
 import rx.util.functions.Func1;

File: rxjava-core/src/test/java/rx/observers/SynchronizedObserverTest.java
Patch:
@@ -36,8 +36,6 @@
 import rx.Observer;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.operators.SafeObservableSubscription;
-import rx.operators.SafeObserver;
 
 public class SynchronizedObserverTest {
 

File: rxjava-core/src/test/java/rx/operators/OperationBufferTest.java
Patch:
@@ -38,7 +38,6 @@
 import rx.schedulers.TestScheduler;
 import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
 import rx.util.functions.Func1;

File: rxjava-core/src/test/java/rx/operators/OperationDebounceTest.java
Patch:
@@ -31,7 +31,6 @@
 import rx.schedulers.TestScheduler;
 import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 

File: rxjava-core/src/test/java/rx/operators/OperationSampleTest.java
Patch:
@@ -31,7 +31,6 @@
 import rx.schedulers.TestScheduler;
 import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 
 public class OperationSampleTest {

File: rxjava-core/src/test/java/rx/operators/OperationSwitchTest.java
Patch:
@@ -30,7 +30,6 @@
 import rx.Subscription;
 import rx.schedulers.TestScheduler;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 
 public class OperationSwitchTest {

File: rxjava-core/src/test/java/rx/operators/OperationWindowTest.java
Patch:
@@ -35,7 +35,6 @@
 import rx.schedulers.TestScheduler;
 import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
-import rx.util.functions.Action0;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
 import rx.util.functions.Func1;

File: rxjava-core/src/test/java/rx/operators/OperatorTakeTest.java
Patch:
@@ -16,6 +16,7 @@
 package rx.operators;
 
 import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
 import java.util.Arrays;

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -20,7 +20,6 @@
 import static org.mockito.Mockito.*;
 
 import java.util.Arrays;
-import java.util.Date;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -39,7 +38,6 @@
 import rx.Scheduler.Inner;
 import rx.Subscriber;
 import rx.Subscription;
-import rx.subscriptions.BooleanSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Action0;
 import rx.util.functions.Action1;

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.http.nio.client.HttpAsyncClient;
 import org.apache.http.nio.client.methods.HttpAsyncMethods;
 import org.apache.http.nio.protocol.HttpAsyncRequestProducer;
-import org.apache.http.protocol.Http.HttpContext;
+import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.BasicHttpContext;
 
 import rx.Observable;

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -61,6 +61,7 @@
 import rx.operators.OperationJoinPatterns;
 import rx.operators.OperationMaterialize;
 import rx.operators.OperationMergeDelayError;
+import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperationMinMax;
 import rx.operators.OperationMulticast;
 import rx.operators.OperationOnErrorResumeNextViaFunction;
@@ -93,13 +94,13 @@
 import rx.operators.OperationToObservableFuture;
 import rx.operators.OperationUsing;
 import rx.operators.OperationWindow;
+import rx.operators.Operator;
 import rx.operators.OperatorCast;
 import rx.operators.OperatorDoOnEach;
 import rx.operators.OperatorFilter;
 import rx.operators.OperatorGroupBy;
 import rx.operators.OperatorMap;
 import rx.operators.OperatorMerge;
-import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperatorObserveOn;
 import rx.operators.OperatorParallel;
 import rx.operators.OperatorRepeat;
@@ -254,10 +255,9 @@ public static interface OnSubscribeFunc<T> extends Function {
      */
     public <R> Observable<R> lift(final Func1<Subscriber<? super R>, Subscriber<? super T>> bind) {
         return new Observable<R>(new OnSubscribe<R>() {
-
             @Override
             public void call(Subscriber<? super R> o) {
-                subscribe(bind.call(o));
+                subscribe(hook.onLift((Operator<R, T>) bind).call(o));
             }
         });
     }

File: rxjava-core/src/main/java/rx/observers/SafeSubscriber.java
Patch:
@@ -164,4 +164,7 @@ protected void _onError(Throwable e) {
         }
     }
 
+    public Subscriber<? super T> getActual() {
+        return actual;
+    }
 }

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -61,6 +61,7 @@
 import rx.operators.OperationJoinPatterns;
 import rx.operators.OperationMaterialize;
 import rx.operators.OperationMergeDelayError;
+import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperationMinMax;
 import rx.operators.OperationMulticast;
 import rx.operators.OperationOnErrorResumeNextViaFunction;
@@ -93,13 +94,13 @@
 import rx.operators.OperationToObservableFuture;
 import rx.operators.OperationUsing;
 import rx.operators.OperationWindow;
+import rx.operators.Operator;
 import rx.operators.OperatorCast;
 import rx.operators.OperatorDoOnEach;
 import rx.operators.OperatorFilter;
 import rx.operators.OperatorGroupBy;
 import rx.operators.OperatorMap;
 import rx.operators.OperatorMerge;
-import rx.operators.OperationMergeMaxConcurrent;
 import rx.operators.OperatorObserveOn;
 import rx.operators.OperatorParallel;
 import rx.operators.OperatorRepeat;
@@ -254,10 +255,9 @@ public static interface OnSubscribeFunc<T> extends Function {
      */
     public <R> Observable<R> lift(final Func1<Subscriber<? super R>, Subscriber<? super T>> bind) {
         return new Observable<R>(new OnSubscribe<R>() {
-
             @Override
             public void call(Subscriber<? super R> o) {
-                subscribe(bind.call(o));
+                subscribe(hook.onLift((Operator<R, T>) bind).call(o));
             }
         });
     }

File: rxjava-core/src/main/java/rx/observers/SafeSubscriber.java
Patch:
@@ -164,4 +164,7 @@ protected void _onError(Throwable e) {
         }
     }
 
+    public Subscriber<? super T> getActual() {
+        return actual;
+    }
 }

File: rxjava-core/src/test/java/rx/operators/OperationTimeoutTest.java
Patch:
@@ -16,7 +16,6 @@
 package rx.operators;
 
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;

File: rxjava-core/src/main/java/rx/operators/OperatorRepeat.java
Patch:
@@ -63,7 +63,8 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
-                child.onError(e);
+                // we should never receive this but if we do we pass it on
+                child.onError(new IllegalStateException("Error received on nested Observable.", e));
             }
 
             @Override

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -20,7 +20,6 @@
 
 import rx.Notification;
 import rx.Observer;
-import rx.Subscriber;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
 
@@ -100,7 +99,7 @@ public void onCompleted() {
 
             @Override
             public void call(Collection<SubjectObserver<? super T>> observers) {
-                lastNotification.set(new Notification<T>());
+                lastNotification.set(Notification.<T> createOnCompleted());
                 for (Observer<? super T> o : observers) {
                     o.onCompleted();
                 }
@@ -114,7 +113,7 @@ public void onError(final Throwable e) {
 
             @Override
             public void call(Collection<SubjectObserver<? super T>> observers) {
-                lastNotification.set(new Notification<T>(e));
+                lastNotification.set(Notification.<T>createOnError(e));
                 for (Observer<? super T> o : observers) {
                     o.onError(e);
                 }

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -119,7 +119,7 @@ public void onCompleted() {
 
             @Override
             public void call(Collection<SubjectObserver<? super T>> observers) {
-                state.history.complete(new Notification<T>());
+                state.history.complete(Notification.<T>createOnCompleted());
                 for (SubjectObserver<? super T> o : observers) {
                     if (caughtUp(o)) {
                         o.onCompleted();
@@ -135,7 +135,7 @@ public void onError(final Throwable e) {
 
             @Override
             public void call(Collection<SubjectObserver<? super T>> observers) {
-                state.history.complete(new Notification<T>(e));
+                state.history.complete(Notification.<T>createOnError(e));
                 for (SubjectObserver<? super T> o : observers) {
                     if (caughtUp(o)) {
                         o.onError(e);

File: rxjava-core/src/main/java/rx/operators/OperatorRepeat.java
Patch:
@@ -63,7 +63,8 @@ public void onCompleted() {
 
             @Override
             public void onError(Throwable e) {
-                child.onError(e);
+                // we should never receive this but if we do we pass it on
+                child.onError(new IllegalStateException("Error received on nested Observable.", e));
             }
 
             @Override

File: rxjava-core/src/main/java/rx/operators/OnSubscribeFromIterable.java
Patch:
@@ -26,11 +26,11 @@
  * You can convert any object that supports the Iterable interface into an Observable that emits
  * each item in the object, with the toObservable operation.
  */
-public final class OperatorFromIterable<T> implements OnSubscribe<T> {
+public final class OnSubscribeFromIterable<T> implements OnSubscribe<T> {
 
     final Iterable<? extends T> is;
 
-    public OperatorFromIterable(Iterable<? extends T> iterable) {
+    public OnSubscribeFromIterable(Iterable<? extends T> iterable) {
         this.is = iterable;
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -151,9 +151,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
              * <p>
              * Bug report: https://github.com/Netflix/RxJava/issues/614
              */
-            SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);
-            completeSubscription.add(subscription);
-            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, subscription);
+            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver);
 
             /**
              * Subscribe to the parent Observable to get to the children Observables

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -5296,7 +5296,9 @@ public final Observable<T> onExceptionResumeNext(final Observable<? extends T> r
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-parallel">RxJava Wiki: parallel()</a>
      */
     public final <R> Observable<R> parallel(Func1<Observable<T>, Observable<R>> f) {
-        return lift(new OperatorParallel<T, R>(f, Schedulers.computation()));
+        // TODO move this back to Schedulers.computation() again once that is properly using eventloops
+        // see https://github.com/Netflix/RxJava/issues/713 for why this was changed
+        return lift(new OperatorParallel<T, R>(f, Schedulers.newThread()));
     }
 
     /**

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -118,6 +118,7 @@
 import rx.subjects.ReplaySubject;
 import rx.subjects.Subject;
 import rx.subscriptions.Subscriptions;
+import rx.util.Exceptions;
 import rx.util.OnErrorNotImplementedException;
 import rx.util.Range;
 import rx.util.TimeInterval;
@@ -6964,10 +6965,9 @@ public void call() {
                 }
 
             });
-        } catch (OnErrorNotImplementedException e) {
-            // special handling when onError is not implemented ... we just rethrow
-            throw e;
         } catch (Throwable e) {
+            // special handling for certain Throwable/Error/Exception types
+            Exceptions.throwIfFatal(e);
             // if an unhandled error occurs executing the onSubscribe we will propagate it
             try {
                 observer.onError(hook.onSubscribeError(this, e));

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -151,9 +151,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
              * <p>
              * Bug report: https://github.com/Netflix/RxJava/issues/614
              */
-            SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);
-            completeSubscription.add(subscription);
-            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, subscription);
+            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver);
 
             /**
              * Subscribe to the parent Observable to get to the children Observables

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -118,6 +118,7 @@
 import rx.subjects.ReplaySubject;
 import rx.subjects.Subject;
 import rx.subscriptions.Subscriptions;
+import rx.util.Exceptions;
 import rx.util.OnErrorNotImplementedException;
 import rx.util.Range;
 import rx.util.TimeInterval;
@@ -6964,10 +6965,9 @@ public void call() {
                 }
 
             });
-        } catch (OnErrorNotImplementedException e) {
-            // special handling when onError is not implemented ... we just rethrow
-            throw e;
         } catch (Throwable e) {
+            // special handling for certain Throwable/Error/Exception types
+            Exceptions.throwIfFatal(e);
             // if an unhandled error occurs executing the onSubscribe we will propagate it
             try {
                 observer.onError(hook.onSubscribeError(this, e));

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -151,9 +151,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
              * <p>
              * Bug report: https://github.com/Netflix/RxJava/issues/614
              */
-            SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);
-            completeSubscription.add(subscription);
-            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, subscription);
+            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver);
 
             /**
              * Subscribe to the parent Observable to get to the children Observables

File: rxjava-core/src/main/java/rx/observers/SafeSubscriber.java
Patch:
@@ -157,4 +157,7 @@ protected void _onError(Throwable e) {
         }
     }
 
+    public Subscriber<? super T> getActual() {
+        return actual;
+    }
 }

File: rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java
Patch:
@@ -84,7 +84,7 @@ public void unsubscribe() {
                 public void call(Inner inner) {
                     underlying.unsubscribe();
                     // tear down this subscription as well now that we're done
-                    inner.unsubscribe();
+//                    inner.unsubscribe();
                 }
             });
         }

File: rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java
Patch:
@@ -84,7 +84,7 @@ public void unsubscribe() {
                 public void call(Inner inner) {
                     underlying.unsubscribe();
                     // tear down this subscription as well now that we're done
-                    inner.unsubscribe();
+//                    inner.unsubscribe();
                 }
             });
         }

File: rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java
Patch:
@@ -403,7 +403,6 @@ public Boolean call() {
 
     @Test
     public void testDoWhileManyTimes() {
-        fail("deadlocking");
         Observable<Integer> source1 = Observable.from(1, 2, 3).subscribeOn(Schedulers.currentThread());
 
         List<Integer> expected = new ArrayList<Integer>(numRecursion * 3);

File: rxjava-core/src/main/java/rx/observers/SafeObserver.java
Patch:
@@ -148,7 +148,7 @@ protected void _onError(Throwable e) {
                 throw new RuntimeException("Error occurred when trying to propagate error to Observer.onError", new CompositeException(Arrays.asList(e, e2)));
             }
         }
-        // if we did not throw about we will unsubscribe here, if onError failed then unsubscribe happens in the catch
+        // if we did not throw above we will unsubscribe here, if onError failed then unsubscribe happens in the catch
         try {
             unsubscribe();
         } catch (RuntimeException unsubscribeException) {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -213,7 +213,7 @@ public final static <T> Observable<T> create(final OnSubscribeFunc<T> f) {
             @Override
             public void call(Observer<? super T> observer) {
                 Subscription s = f.onSubscribe(observer);
-                if (s != null) {
+                if (s != null && s != observer) {
                     observer.add(s);
                 }
             }

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -54,7 +54,7 @@ public DematerializeObservable(Observable<? extends Notification<? extends T>> s
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            return sequence.subscribe(new Observer<Notification<? extends T>>() {
+            return sequence.subscribe(new Observer<Notification<? extends T>>(observer) {
                 @Override
                 public void onCompleted() {
                 }

File: rxjava-core/src/main/java/rx/operators/OperationDoOnEach.java
Patch:
@@ -40,7 +40,7 @@ public DoOnEachObservable(Observable<? extends T> sequence, Observer<? super T>
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            return sequence.subscribe(new Observer<T>() {
+            return sequence.subscribe(new Observer<T>(observer) {
                 @Override
                 public void onCompleted() {
                     try {

File: rxjava-core/src/main/java/rx/operators/OperationRepeat.java
Patch:
@@ -47,7 +47,7 @@ public Subscription onSubscribe(final Observer<? super T> observer) {
         compositeSubscription.add(scheduler.schedule(new Action1<Action0>() {
             @Override
             public void call(final Action0 self) {
-                innerSubscription.set(source.subscribe(new Observer<T>() {
+                innerSubscription.set(source.subscribe(new Observer<T>(observer) {
 
                     @Override
                     public void onCompleted() {

File: rxjava-core/src/main/java/rx/operators/OperationRetry.java
Patch:
@@ -93,7 +93,7 @@ public void onError(Throwable e) {
                             if ((retryCount == INFINITE_RETRY || attempts.get() <= retryCount) && !subscription.isUnsubscribed()) {
                                 // retry again
                                 // add the new subscription and schedule a retry recursively
-                                rescursiveSubscription.setSubscription(scheduler.schedule(rescursiveSubscription, attemptSubscription(observer)));
+                                rescursiveSubscription.set(scheduler.schedule(rescursiveSubscription, attemptSubscription(observer)));
                             } else {
                                 // give up and pass the failure
                                 observer.onError(e);

File: rxjava-core/src/main/java/rx/operators/OperationScan.java
Patch:
@@ -81,7 +81,7 @@ private AccuWithoutInitialValue(Observable<? extends T> sequence, Func2<T, T, T>
 
         @Override
         public Subscription onSubscribe(final Observer<? super T> observer) {
-            return sequence.subscribe(new Observer<T>() {
+            return sequence.subscribe(new Observer<T>(observer) {
 
                 // has to be synchronized so that the initial value is always sent only once.
                 @Override
@@ -132,6 +132,7 @@ private static class AccumulatingObserver<T, R> extends Observer<T> {
         private R acc;
 
         private AccumulatingObserver(Observer<? super R> observer, R initialValue, Func2<R, ? super T, R> accumulator) {
+            super(observer);
             this.observer = observer;
             this.accumulatorFunction = accumulator;
 

File: rxjava-core/src/main/java/rx/operators/OperationZip.java
Patch:
@@ -150,7 +150,7 @@ public Subscription onSubscribe(final Observer<? super U> observer) {
 
             final List<ItemObserver<T>> all = new ArrayList<ItemObserver<T>>();
 
-            Observer<List<T>> o2 = new Observer<List<T>>() {
+            Observer<List<T>> o2 = new Observer<List<T>>(observer) {
                 boolean done;
                 @Override
                 public void onCompleted() {

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerEventStream.java
Patch:
@@ -85,7 +85,7 @@ protected void onResponseReceived(HttpResponse response) throws HttpException, I
 
             @Override
             public Subscription onSubscribe(Observer<? super byte[]> observer) {
-                parentSubscription.add(contentSubject.subscribe(observer));
+                parentSubscription.add(contentSubject.toObservable().subscribe(observer));
                 return parentSubscription;
             }
         });

File: rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/operators/LatchedObserver.java
Patch:
@@ -28,7 +28,7 @@
  * a terminal state has been reached.
  * @param <T> the observed value type
  */
-abstract class LatchedObserver<T> implements Observer<T> {
+abstract class LatchedObserver<T> extends Observer<T> {
     /** The CountDownLatch to count-down on a terminal state. */
     protected final CountDownLatch latch;
     /** Contains the error. */

File: rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationStartFutureTest.java
Patch:
@@ -39,7 +39,7 @@ static class CustomException extends RuntimeException {}
      * on terminal conditions.
      * @param <T> 
      */
-    static class MockHelper<T> implements Observer<T> {
+    static class MockHelper<T> extends Observer<T> {
         final Observer<? super T> observer;
         final CountDownLatch latch;
 

File: rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/operators/OperationConditionals.java
Patch:
@@ -243,7 +243,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
         }
 
         /** Observe the source. */
-        final class SourceObserver implements Observer<T> {
+        final class SourceObserver extends Observer<T> {
             final SerialSubscription cancel;
             final Observer<? super T> observer;
 
@@ -273,7 +273,7 @@ public void onCompleted() {
                     return;
                 }
                 if (next) {
-                    cancel.setSubscription(source.subscribe(this));
+                    cancel.set(source.subscribe(this));
                 } else {
                     observer.onCompleted();
                     cancel.unsubscribe();

File: rxjava-core/src/main/java/rx/Observer.java
Patch:
@@ -16,9 +16,6 @@
 package rx;
 
 import rx.subscriptions.CompositeSubscription;
-import rx.util.OnErrorNotImplementedException;
-import rx.util.functions.Action0;
-import rx.util.functions.Action1;
 
 /**
  * Provides a mechanism for receiving push-based notifications.
@@ -36,6 +33,9 @@ public abstract class Observer<T> implements Subscription {
     private final CompositeSubscription cs;
 
     protected Observer(CompositeSubscription cs) {
+        if (cs == null) {
+            throw new IllegalArgumentException("The CompositeException can not be null");
+        }
         this.cs = cs;
     }
 

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -23,13 +23,13 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SafeObserver;
 import rx.operators.OperationLatest;
 import rx.operators.OperationMostRecent;
 import rx.operators.OperationNext;
 import rx.operators.OperationToFuture;
 import rx.operators.OperationToIterator;
 import rx.operators.SafeObservableSubscription;
-import rx.operators.SafeObserver;
 import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 

File: rxjava-core/src/main/java/rx/observables/ConnectableObservable.java
Patch:
@@ -17,10 +17,8 @@
 
 import rx.Observable;
 import rx.Observer;
-import rx.Operator;
 import rx.Subscription;
 import rx.operators.OperationRefCount;
-import rx.util.functions.Action1;
 
 /**
  * A ConnectableObservable resembles an ordinary {@link Observable}, except that it does not begin
@@ -39,7 +37,7 @@
 
 public abstract class ConnectableObservable<T> extends Observable<T> {
 
-    protected ConnectableObservable(Action1<Operator<? super T>> onSubscribe) {
+    protected ConnectableObservable(OnSubscribe<T> onSubscribe) {
         super(onSubscribe);
     }
 

File: rxjava-core/src/main/java/rx/observables/GroupedObservable.java
Patch:
@@ -16,8 +16,6 @@
 package rx.observables;
 
 import rx.Observable;
-import rx.Operator;
-import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 
 /**
@@ -33,7 +31,7 @@
 public class GroupedObservable<K, T> extends Observable<T> {
     private final K key;
 
-    public GroupedObservable(K key, Action1<Operator<? super T>> onSubscribe) {
+    public GroupedObservable(K key, OnSubscribe<T> onSubscribe) {
         super(onSubscribe);
         this.key = key;
     }

File: rxjava-core/src/main/java/rx/observers/SafeObserver.java
Patch:
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package rx.operators;
+package rx.observers;
 
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import rx.Observer;
 import rx.Subscription;
+import rx.operators.SafeObservableSubscription;
 import rx.plugins.RxJavaPlugins;
 import rx.subscriptions.Subscriptions;
 import rx.util.CompositeException;
@@ -57,7 +58,7 @@
  * 
  * @param <T>
  */
-public class SafeObserver<T> implements Observer<T> {
+public class SafeObserver<T> extends Observer<T> {
 
     private final Observer<? super T> actual;
     private final AtomicBoolean isFinished = new AtomicBoolean(false);

File: rxjava-core/src/main/java/rx/observers/SynchronizedObserver.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package rx.operators;
+package rx.observers;
 
 import rx.Observer;
+import rx.operators.SafeObservableSubscription;
 
 /**
  * A thread-safe Observer for transitioning states in operators.
@@ -29,7 +30,7 @@
  * 
  * @param <T>
  */
-public final class SynchronizedObserver<T> implements Observer<T> {
+public final class SynchronizedObserver<T> extends Observer<T> {
 
     /**
      * Intrinsic synchronized locking with double-check short-circuiting was chosen after testing several other implementations.

File: rxjava-core/src/main/java/rx/operators/ChunkedOperation.java
Patch:
@@ -394,7 +394,7 @@ public void pushValue(T value) {
      *            The type of object all internal {@link rx.operators.ChunkedOperation.Chunk} objects record.
      *            <C> The type of object being tracked by the {@link Chunk}
      */
-    protected static class ChunkObserver<T, C> implements Observer<T> {
+    protected static class ChunkObserver<T, C> extends Observer<T> {
 
         private final Chunks<T, C> chunks;
         private final Observer<? super C> observer;

File: rxjava-core/src/main/java/rx/operators/OperationAll.java
Patch:
@@ -52,7 +52,7 @@ public Subscription onSubscribe(final Observer<? super Boolean> observer) {
 
         }
 
-        private class AllObserver implements Observer<T> {
+        private class AllObserver extends Observer<T> {
             private final Observer<? super Boolean> underlying;
 
             private final AtomicBoolean status = new AtomicBoolean(true);

File: rxjava-core/src/main/java/rx/operators/OperationAmb.java
Patch:
@@ -136,7 +136,7 @@ public Subscription onSubscribe(final Observer<? super T> observer) {
         };
     }
 
-    private static class AmbObserver<T> implements Observer<T> {
+    private static class AmbObserver<T> extends Observer<T> {
 
         private static final int NONE = -1;
 

File: rxjava-core/src/main/java/rx/operators/OperationBuffer.java
Patch:
@@ -444,7 +444,7 @@ public Subscription onSubscribe(Observer<? super List<T>> t1) {
         /**
          * Observes the source.
          */
-        private static final class SourceObserver<T> implements Observer<T> {
+        private static final class SourceObserver<T> extends Observer<T> {
             final Observer<? super List<T>> observer;
             /** The buffer, if null, that indicates a terminal state. */
             List<T> buffer;
@@ -514,7 +514,7 @@ void emitAndComplete() {
         /**
          * Observes the boundary.
          */
-        private static final class BoundaryObserver<T> implements Observer<T> {
+        private static final class BoundaryObserver<T> extends Observer<T> {
             final SourceObserver so;
 
             public BoundaryObserver(SourceObserver so) {

File: rxjava-core/src/main/java/rx/operators/OperationCache.java
Patch:
@@ -56,7 +56,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
                      */
                 }
 
-                return cache.subscribe(observer);
+                return cache.toObservable().subscribe(observer);
             }
 
         };

File: rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java
Patch:
@@ -275,7 +275,7 @@ public void completed(int index) {
         /**
          * Observes a specific source and communicates with the collector.
          */
-        final class SourceObserver implements Observer<T> {
+        final class SourceObserver extends Observer<T> {
             final SafeObservableSubscription self;
             final Collector collector;
             final int index;

File: rxjava-core/src/main/java/rx/operators/OperationDelay.java
Patch:
@@ -146,7 +146,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
         }
 
         /** Subscribe delay observer. */
-        private static final class SubscribeDelay<T, U, V> implements Observer<U> {
+        private static final class SubscribeDelay<T, U, V> extends Observer<U> {
             final Observable<? extends T> source;
             final SourceObserver<T, V> so;
             final CompositeSubscription csub;
@@ -186,7 +186,7 @@ public void onCompleted() {
         }
 
         /** The source observer. */
-        private static final class SourceObserver<T, U> implements Observer<T> {
+        private static final class SourceObserver<T, U> extends Observer<T> {
             final Observer<? super T> observer;
             final Func1<? super T, ? extends Observable<U>> itemDelay;
             final CompositeSubscription csub;
@@ -274,7 +274,7 @@ boolean checkDone() {
         /**
          * Delay observer.
          */
-        private static final class DelayObserver<T, U> implements Observer<U> {
+        private static final class DelayObserver<T, U> extends Observer<U> {
             final T value;
             final SourceObserver<T, U> parent;
             final Subscription token;

File: rxjava-core/src/main/java/rx/operators/OperationDoOnEach.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SafeObserver;
 
 /**
  * Converts the elements of an observable sequence to the specified type.

File: rxjava-core/src/main/java/rx/operators/OperationFinally.java
Patch:
@@ -71,7 +71,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
             return sequence.subscribe(new FinallyObserver(observer));
         }
 
-        private class FinallyObserver implements Observer<T> {
+        private class FinallyObserver extends Observer<T> {
             private final Observer<? super T> observer;
 
             FinallyObserver(Observer<? super T> observer) {

File: rxjava-core/src/main/java/rx/operators/OperationLatest.java
Patch:
@@ -48,7 +48,7 @@ public Iterator<T> iterator() {
     }
 
     /** Observer of source, iterator for output. */
-    static final class LatestObserverIterator<T> implements Observer<Notification<? extends T>>, Iterator<T> {
+    static final class LatestObserverIterator<T> extends Observer<Notification<? extends T>> implements Iterator<T> {
         final Semaphore notify = new Semaphore(0);
         // observer's notification
         final AtomicReference<Notification<? extends T>> reference = new AtomicReference<Notification<? extends T>>();

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -24,6 +24,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SynchronizedObserver;
 import rx.subscriptions.CompositeSubscription;
 import rx.util.CompositeException;
 
@@ -207,7 +208,7 @@ public boolean stop() {
          * 
          * @param <T>
          */
-        private class ParentObserver implements Observer<Observable<? extends T>> {
+        private class ParentObserver extends Observer<Observable<? extends T>> {
             private final Observer<? super T> actualObserver;
 
             public ParentObserver(Observer<? super T> actualObserver) {
@@ -273,7 +274,7 @@ public void onNext(Observable<? extends T> childObservable) {
          * Subscribe to each child Observable<T> and forward their sequence of data to the actualObserver
          * 
          */
-        private class ChildObserver implements Observer<T> {
+        private class ChildObserver extends Observer<T> {
 
             private final Observer<? super T> actualObserver;
             private volatile boolean finished = false;

File: rxjava-core/src/main/java/rx/operators/OperationMostRecent.java
Patch:
@@ -74,7 +74,7 @@ public void remove() {
         }
     }
 
-    private static class MostRecentObserver<T> implements Observer<T> {
+    private static class MostRecentObserver<T> extends Observer<T> {
         private final AtomicBoolean completed = new AtomicBoolean(false);
         private final AtomicReference<T> value;
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();

File: rxjava-core/src/main/java/rx/operators/OperationNext.java
Patch:
@@ -126,7 +126,7 @@ public void remove() {
         }
     }
 
-    private static class NextObserver<T> implements Observer<Notification<? extends T>> {
+    private static class NextObserver<T> extends Observer<Notification<? extends T>> {
         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);
         private final AtomicBoolean waiting = new AtomicBoolean(false);
 

File: rxjava-core/src/main/java/rx/operators/OperationSample.java
Patch:
@@ -137,7 +137,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
         }
 
         /** Observe source values. */
-        class ResultManager implements Observer<T> {
+        class ResultManager extends Observer<T> {
             final Observer<? super T> observer;
             final CompositeSubscription cancel;
             T value;
@@ -189,7 +189,7 @@ public void onCompleted() {
             }
 
             /** Take the latest value, but only once. */
-            class Sampler implements Observer<U> {
+            class Sampler extends Observer<U> {
                 @Override
                 public void onNext(U args) {
                     synchronized (guard) {

File: rxjava-core/src/main/java/rx/operators/OperationScan.java
Patch:
@@ -125,7 +125,7 @@ public Subscription onSubscribe(final Observer<? super R> observer) {
         }
     }
 
-    private static class AccumulatingObserver<T, R> implements Observer<T> {
+    private static class AccumulatingObserver<T, R> extends Observer<T> {
         private final Observer<? super R> observer;
         private final Func2<R, ? super T, R> accumulatorFunction;
 

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -82,7 +82,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
         /**
          * Used to subscribe to the 'items' Observable sequence and forward to the actualObserver up to 'num' count.
          */
-        private class ItemObserver implements Observer<T> {
+        private class ItemObserver extends Observer<T> {
 
             private AtomicInteger counter = new AtomicInteger();
             private final Observer<? super T> observer;
@@ -155,7 +155,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
          * @param <T>
          *            the observed value type
          */
-        private static final class SourceObserver<T> implements Observer<T>, Action0 {
+        private static final class SourceObserver<T> extends Observer<T> implements Action0 {
             final AtomicBoolean gate;
             final Observer<? super T> observer;
             final Subscription cancel;

File: rxjava-core/src/main/java/rx/operators/OperationSkipLast.java
Patch:
@@ -153,7 +153,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
         }
 
         /** Observes the source. */
-        private static final class SourceObserver<T> implements Observer<T> {
+        private static final class SourceObserver<T> extends Observer<T> {
             final Observer<? super T> observer;
             final long timeInMillis;
             final Scheduler scheduler;

File: rxjava-core/src/main/java/rx/operators/OperationSkipWhile.java
Patch:
@@ -58,7 +58,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
             return source.subscribe(new SkipWhileObserver(observer));
         }
 
-        private class SkipWhileObserver implements Observer<T> {
+        private class SkipWhileObserver extends Observer<T> {
             private final Observer<? super T> observer;
 
             public SkipWhileObserver(Observer<? super T> observer) {

File: rxjava-core/src/main/java/rx/operators/OperationSwitch.java
Patch:
@@ -70,7 +70,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
         }
     }
 
-    private static class SwitchObserver<T> implements Observer<Observable<? extends T>> {
+    private static class SwitchObserver<T> extends Observer<Observable<? extends T>> {
 
         private final Object gate;
         private final Observer<? super T> observer;

File: rxjava-core/src/main/java/rx/operators/OperationSynchronize.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SynchronizedObserver;
 
 /**
  * Wraps an Observable in another Observable that ensures that the resulting Observable is

File: rxjava-core/src/main/java/rx/operators/OperationTakeLast.java
Patch:
@@ -64,7 +64,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
             return subscription.wrap(items.subscribe(new ItemObserver(observer)));
         }
 
-        private class ItemObserver implements Observer<T> {
+        private class ItemObserver extends Observer<T> {
 
             /**
              * Store the last count elements until now.
@@ -162,7 +162,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
     }
 
     /** Observes source values and keeps the most recent items. */
-    static final class TakeLastTimedObserver<T> implements Observer<T> {
+    static final class TakeLastTimedObserver<T> extends Observer<T> {
         final Observer<? super T> observer;
         final Subscription cancel;
         final long ageMillis;

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -21,6 +21,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SafeObserver;
 import rx.util.functions.Func1;
 import rx.util.functions.Func2;
 
@@ -99,7 +100,7 @@ public Subscription onSubscribe(Observer<? super T> observer) {
             return subscription.wrap(items.subscribe(new ItemObserver(observer)));
         }
 
-        private class ItemObserver implements Observer<T> {
+        private class ItemObserver extends Observer<T> {
             private final Observer<? super T> observer;
 
             private final AtomicInteger counter = new AtomicInteger();

File: rxjava-core/src/main/java/rx/operators/OperationTimeInterval.java
Patch:
@@ -45,7 +45,7 @@ public Subscription onSubscribe(
         };
     }
 
-    private static class TimeIntervalObserver<T> implements Observer<T> {
+    private static class TimeIntervalObserver<T> extends Observer<T> {
 
         private final Observer<? super TimeInterval<T>> observer;
         /**

File: rxjava-core/src/main/java/rx/operators/OperationTimeout.java
Patch:
@@ -197,7 +197,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
         }
 
         /** Observe the source. */
-        private static final class SourceObserver<T, V> implements Observer<T>, TimeoutCallback {
+        private static final class SourceObserver<T, V> extends Observer<T> implements TimeoutCallback {
             final Observer<? super T> observer;
             final Func1<? super T, ? extends Observable<V>> valueTimeout;
             final Observable<? extends T> other;
@@ -292,7 +292,7 @@ private interface TimeoutCallback {
         }
 
         /** Observe the timeout. */
-        private static final class TimeoutObserver<V> implements Observer<V> {
+        private static final class TimeoutObserver<V> extends Observer<V> {
             final TimeoutCallback parent;
 
             public TimeoutObserver(TimeoutCallback parent) {

File: rxjava-core/src/main/java/rx/operators/OperationToMap.java
Patch:
@@ -124,7 +124,7 @@ public Subscription onSubscribe(Observer<? super Map<K, V>> t1) {
          * Observer that collects the source values of T into
          * a map.
          */
-        public static class ToMapObserver<K, V, T> implements Observer<T> {
+        public static class ToMapObserver<K, V, T> extends Observer<T> {
             /** The map. */
             Map<K, V> map;
             /** Key extractor. */

File: rxjava-core/src/main/java/rx/operators/OperationToMultimap.java
Patch:
@@ -163,7 +163,7 @@ public Subscription onSubscribe(Observer<? super Map<K, Collection<V>>> t1) {
         /**
          * Observer that collects the source values of Ts into a multimap.
          */
-        public static class ToMultimapObserver<T, K, V> implements Observer<T> {
+        public static class ToMultimapObserver<T, K, V> extends Observer<T> {
             private final Func1<? super T, ? extends K> keySelector;
             private final Func1<? super T, ? extends V> valueSelector;
             private final Func1<? super K, ? extends Collection<V>> collectionFactory;

File: rxjava-core/src/main/java/rx/operators/OperationUsing.java
Patch:
@@ -19,6 +19,7 @@
 import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
+import rx.observers.SafeObserver;
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func0;

File: rxjava-core/src/main/java/rx/operators/OperatorTakeTimed.java
Patch:
@@ -31,7 +31,7 @@
  * Returns an Observable that emits the first <code>num</code> items emitted by the source
  * Observable.
  * <p>
- * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/take.png">
+ * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-Observers/take.png">
  * <p>
  * You can choose to pay attention only to the first <code>num</code> items emitted by an
  * Observable by using the take operation. This operation returns an Observable that will invoke a
@@ -109,7 +109,7 @@ public void onNext(T args)
             return subscription.wrap(items.subscribe(new ItemObserver(observer)));
         }
 
-        private class ItemObserver implements Observer<T> {
+        private class ItemObserver extends Observer<T> {
             private final Observer<? super T> observer;
 
             private final AtomicInteger counter = new AtomicInteger();
@@ -210,7 +210,7 @@ public Subscription onSubscribe(Observer<? super T> t1) {
          * @param <T>
          *            the observed value type
          */
-        private static final class SourceObserver<T> implements Observer<T>, Action0 {
+        private static final class SourceObserver<T> extends Observer<T> implements Action0 {
             final Observer<? super T> observer;
             final Subscription cancel;
             final AtomicInteger state = new AtomicInteger();

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -20,8 +20,8 @@
 
 import rx.Notification;
 import rx.Observable;
-import rx.Observer;
 import rx.Observable.OnSubscribe;
+import rx.Observer;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
 
@@ -54,7 +54,7 @@
  * 
  * @param <T>
  */
-public final class AsyncSubject<T> extends Subject<T> {
+public final class AsyncSubject<T> extends Subject<T, T> {
 
     public static <T> AsyncSubject<T> create() {
         final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -20,11 +20,10 @@
 
 import rx.Notification;
 import rx.Observable;
-import rx.Observer;
 import rx.Observable.OnSubscribe;
+import rx.Observer;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
-import rx.util.functions.Action2;
 
 /**
  * Subject that publishes the most recent and all subsequent events to each subscribed {@link Observer}.
@@ -67,7 +66,7 @@
  * 
  * @param <T>
  */
-public final class BehaviorSubject<T> extends Subject<T> {
+public final class BehaviorSubject<T> extends Subject<T, T> {
 
     /**
      * Creates a {@link BehaviorSubject} which publishes the last and all subsequent events to each {@link Observer} that subscribes to it.

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -20,11 +20,10 @@
 
 import rx.Notification;
 import rx.Observable;
-import rx.Observer;
 import rx.Observable.OnSubscribe;
+import rx.Observer;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
-import rx.util.functions.Action2;
 
 /**
  * Subject that, once and {@link Observer} has subscribed, publishes all subsequent events to the subscriber.
@@ -49,7 +48,7 @@
  * 
  * @param <T>
  */
-public final class PublishSubject<T> extends Subject<T> {
+public final class PublishSubject<T> extends Subject<T, T> {
 
     public static <T> PublishSubject<T> create() {
         final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -51,7 +51,7 @@
  * 
  * @param <T>
  */
-public final class ReplaySubject<T> extends Subject<T> {
+public final class ReplaySubject<T> extends Subject<T, T> {
     public static <T> ReplaySubject<T> create() {
         return create(16);
     }

File: rxjava-core/src/main/java/rx/subjects/Subject.java
Patch:
@@ -18,8 +18,8 @@
 import rx.Observable;
 import rx.Observer;
 
-public abstract class Subject<T> extends Observer<T> {
+public abstract class Subject<T, R> extends Observer<T> {
 
-    public abstract Observable<T> toObservable();
+    public abstract Observable<R> toObservable();
 
 }

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -20,9 +20,9 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
+import rx.Observable.OnSubscribe;
 import rx.Observer;
 import rx.Subscription;
-import rx.Observable.OnSubscribe;
 import rx.operators.SafeObservableSubscription;
 import rx.util.functions.Action1;
 

File: rxjava-core/src/perf/java/rx/ObservableCreatePerformance.java
Patch:
@@ -1,9 +1,9 @@
 package rx;
 
+import rx.Observable.OnSubscribe;
 import rx.perf.AbstractPerformanceTester;
 import rx.perf.LongSumObserver;
 import rx.util.functions.Action0;
-import rx.util.functions.Action1;
 
 public class ObservableCreatePerformance extends AbstractPerformanceTester {
 
@@ -57,10 +57,10 @@ public void call() {
      */
     public long timeCreateAndSubscribe() {
 
-        Observable<Long> s = Observable.create(new Action1<Operator<? super Long>>() {
+        Observable<Long> s = Observable.create(new OnSubscribe<Long>() {
 
             @Override
-            public void call(Operator<? super Long> o) {
+            public void call(Observer<? super Long> o) {
                 o.onNext(1L);
                 o.onCompleted();
             }

File: rxjava-core/src/perf/java/rx/perf/IntegerSumObserver.java
Patch:
@@ -2,7 +2,7 @@
 
 import rx.Observer;
 
-public class IntegerSumObserver implements Observer<Integer> {
+public class IntegerSumObserver extends Observer<Integer> {
 
     public int sum = 0;
 

File: rxjava-core/src/perf/java/rx/perf/LongSumObserver.java
Patch:
@@ -2,7 +2,7 @@
 
 import rx.Observer;
 
-public class LongSumObserver implements Observer<Long> {
+public class LongSumObserver extends Observer<Long> {
 
     public long sum = 0;
 

File: rxjava-core/src/perf/java/rx/performance/PerformanceTest.java
Patch:
@@ -226,7 +226,7 @@ public Integer call(Integer t1) {
 
     }
 
-    private static final class TestObserver implements Observer<Integer> {
+    private static final class TestObserver extends Observer<Integer> {
         private final AtomicInteger onNextSum;
         private final AtomicLong aggregateTime;
         private final long start;
@@ -256,7 +256,7 @@ public void onCompleted() {
         }
     }
 
-    private static final class TestStringObserver implements Observer<String> {
+    private static final class TestStringObserver extends Observer<String> {
         private final AtomicInteger onNextSum;
         private final long start;
 

File: rxjava-core/src/perf/java/rx/schedulers/SchedulerPerformanceTests.java
Patch:
@@ -152,7 +152,7 @@ public long arrayResponse(Scheduler scheduler) {
         return o.sum;
     }
 
-    private static class LongObserver implements Observer<Long> {
+    private static class LongObserver extends Observer<Long> {
 
         long sum = 0;
 

File: rxjava-core/src/perf/java/rx/subjects/SubjectPerformanceTests.java
Patch:
@@ -127,15 +127,15 @@ public long baseline() {
     public long unboundedReplaySubject() {
         ReplaySubject<Long> s = ReplaySubject.create();
         LongObserver o = new LongObserver();
-        s.subscribe(o);
+        s.toObservable().subscribe(o);
         for (long l = 0; l < REPETITIONS; l++) {
             s.onNext(l);
         }
         s.onCompleted();
         return o.sum;
     }
 
-    private static class LongObserver implements Observer<Long> {
+    private static class LongObserver extends Observer<Long> {
 
         long sum = 0;
 

File: rxjava-core/src/test/java/rx/ThrottleFirstTests.java
Patch:
@@ -33,7 +33,7 @@ public void testThrottle() {
         Observer<Integer> observer = mock(Observer.class);
         TestScheduler s = new TestScheduler();
         PublishSubject<Integer> o = PublishSubject.create();
-        o.throttleFirst(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
+        o.toObservable().throttleFirst(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
 
         // send events with simulated time increments
         s.advanceTimeTo(0, TimeUnit.MILLISECONDS);

File: rxjava-core/src/test/java/rx/ThrottleLastTests.java
Patch:
@@ -33,7 +33,7 @@ public void testThrottle() {
         Observer<Integer> observer = mock(Observer.class);
         TestScheduler s = new TestScheduler();
         PublishSubject<Integer> o = PublishSubject.create();
-        o.throttleLast(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
+        o.toObservable().throttleLast(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
 
         // send events with simulated time increments
         s.advanceTimeTo(0, TimeUnit.MILLISECONDS);

File: rxjava-core/src/test/java/rx/ThrottleWithTimeoutTests.java
Patch:
@@ -33,7 +33,7 @@ public void testThrottle() {
         Observer<Integer> observer = mock(Observer.class);
         TestScheduler s = new TestScheduler();
         PublishSubject<Integer> o = PublishSubject.create();
-        o.throttleWithTimeout(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
+        o.toObservable().throttleWithTimeout(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
 
         // send events with simulated time increments
         s.advanceTimeTo(0, TimeUnit.MILLISECONDS);

File: rxjava-core/src/test/java/rx/observers/SafeObserverTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package rx.operators;
+package rx.observers;
 
 import static org.junit.Assert.*;
 
@@ -22,6 +22,7 @@
 import org.junit.Test;
 
 import rx.Observer;
+import rx.operators.SafeObservableSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.CompositeException;
 import rx.util.OnErrorNotImplementedException;

File: rxjava-core/src/test/java/rx/operators/OperationJoinsTest.java
Patch:
@@ -365,9 +365,9 @@ public void whenComplicated() {
         PublishSubject<Integer> zs = PublishSubject.create();
 
         Observable<Integer> m = Observable.when(
-                xs.and(ys).then(add2),
-                xs.and(zs).then(mul2),
-                ys.and(zs).then(sub2)
+                xs.toObservable().and(ys.toObservable()).then(add2),
+                xs.toObservable().and(zs.toObservable()).then(mul2),
+                ys.toObservable().and(zs.toObservable()).then(sub2)
                 );
         m.subscribe(observer);
 

File: rxjava-core/src/test/java/rx/operators/OperationLatestTest.java
Patch:
@@ -143,7 +143,7 @@ public void testNextThrows() {
     @Test(timeout = 1000)
     public void testFasterSource() {
         PublishSubject<Integer> source = PublishSubject.create();
-        BlockingObservable<Integer> blocker = source.toBlockingObservable();
+        BlockingObservable<Integer> blocker = source.toObservable().toBlockingObservable();
 
         Iterable<Integer> iter = blocker.latest();
         Iterator<Integer> it = iter.iterator();

File: rxjava-core/src/test/java/rx/operators/OperationMaterializeTest.java
Patch:
@@ -93,7 +93,7 @@ public void testMultipleSubscribes() throws InterruptedException, ExecutionExcep
         assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());
     }
 
-    private static class TestObserver implements Observer<Notification<String>> {
+    private static class TestObserver extends Observer<Notification<String>> {
 
         boolean onCompleted = false;
         boolean onError = false;

File: rxjava-core/src/test/java/rx/operators/OperationMergeDelayErrorTest.java
Patch:
@@ -493,7 +493,7 @@ public void unsubscribe() {
         }
     }
 
-    private static class CaptureObserver implements Observer<String> {
+    private static class CaptureObserver extends Observer<String> {
         volatile Throwable e;
 
         @Override

File: rxjava-core/src/test/java/rx/operators/OperationMulticastTest.java
Patch:
@@ -31,7 +31,7 @@ public class OperationMulticastTest {
     public void testMulticast() {
         Subject<String, String> source = PublishSubject.create();
 
-        ConnectableObservable<String> multicasted = OperationMulticast.multicast(source,
+        ConnectableObservable<String> multicasted = OperationMulticast.multicast(source.toObservable(),
                 PublishSubject.<String> create());
 
         @SuppressWarnings("unchecked")
@@ -59,7 +59,7 @@ public void testMulticast() {
     public void testMulticastConnectTwice() {
         Subject<String, String> source = PublishSubject.create();
 
-        ConnectableObservable<String> multicasted = OperationMulticast.multicast(source,
+        ConnectableObservable<String> multicasted = OperationMulticast.multicast(source.toObservable(),
                 PublishSubject.<String> create());
 
         @SuppressWarnings("unchecked")
@@ -84,7 +84,7 @@ public void testMulticastConnectTwice() {
     public void testMulticastDisconnect() {
         Subject<String, String> source = PublishSubject.create();
 
-        ConnectableObservable<String> multicasted = OperationMulticast.multicast(source,
+        ConnectableObservable<String> multicasted = OperationMulticast.multicast(source.toObservable(),
                 PublishSubject.<String> create());
 
         @SuppressWarnings("unchecked")

File: rxjava-core/src/test/java/rx/operators/OperationParallelMergeTest.java
Patch:
@@ -38,7 +38,7 @@ public void testParallelMerge() {
         PublishSubject<String> p3 = PublishSubject.<String> create();
         PublishSubject<String> p4 = PublishSubject.<String> create();
 
-        Observable<Observable<String>> fourStreams = Observable.<Observable<String>> from(p1, p2, p3, p4);
+        Observable<Observable<String>> fourStreams = Observable.<Observable<String>> from(p1.toObservable(), p2.toObservable(), p3.toObservable(), p4.toObservable());
 
         Observable<Observable<String>> twoStreams = OperationParallelMerge.parallelMerge(fourStreams, 2);
         Observable<Observable<String>> threeStreams = OperationParallelMerge.parallelMerge(fourStreams, 3);

File: rxjava-core/src/test/java/rx/operators/OperationSkipLastTest.java
Patch:
@@ -123,7 +123,7 @@ public void testSkipLastTimed() {
 
         PublishSubject<Integer> source = PublishSubject.create();
 
-        Observable<Integer> result = source.skipLast(1, TimeUnit.SECONDS, scheduler);
+        Observable<Integer> result = source.toObservable().skipLast(1, TimeUnit.SECONDS, scheduler);
 
         Observer<Object> o = mock(Observer.class);
 
@@ -161,7 +161,7 @@ public void testSkipLastTimedErrorBeforeTime() {
 
         PublishSubject<Integer> source = PublishSubject.create();
 
-        Observable<Integer> result = source.skipLast(1, TimeUnit.SECONDS, scheduler);
+        Observable<Integer> result = source.toObservable().skipLast(1, TimeUnit.SECONDS, scheduler);
 
         Observer<Object> o = mock(Observer.class);
 
@@ -186,7 +186,7 @@ public void testSkipLastTimedCompleteBeforeTime() {
 
         PublishSubject<Integer> source = PublishSubject.create();
 
-        Observable<Integer> result = source.skipLast(1, TimeUnit.SECONDS, scheduler);
+        Observable<Integer> result = source.toObservable().skipLast(1, TimeUnit.SECONDS, scheduler);
 
         Observer<Object> o = mock(Observer.class);
 

File: rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java
Patch:
@@ -56,7 +56,7 @@ public Boolean call(Integer input) {
     @Test
     public void testTakeWhileOnSubject1() {
         Subject<Integer, Integer> s = PublishSubject.create();
-        Observable<Integer> take = Observable.create(takeWhile(s, new Func1<Integer, Boolean>() {
+        Observable<Integer> take = Observable.create(takeWhile(s.toObservable(), new Func1<Integer, Boolean>() {
             @Override
             public Boolean call(Integer input) {
                 return input < 3;

File: rxjava-core/src/test/java/rx/operators/OperationTimeIntervalTest.java
Patch:
@@ -47,7 +47,7 @@ public void setUp() {
         MockitoAnnotations.initMocks(this);
         testScheduler = new TestScheduler();
         subject = PublishSubject.create();
-        observable = subject.timeInterval(testScheduler);
+        observable = subject.toObservable().timeInterval(testScheduler);
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperationZipTestCompletion.java
Patch:
@@ -53,7 +53,7 @@ public String call(String t1, String t2) {
 
         s1 = PublishSubject.create();
         s2 = PublishSubject.create();
-        zipped = Observable.zip(s1, s2, concat2Strings);
+        zipped = Observable.zip(s1.toObservable(), s2.toObservable(), concat2Strings);
 
         observer = mock(Observer.class);
         inOrder = inOrder(observer);

File: rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java
Patch:
@@ -30,8 +30,8 @@
 import org.junit.Test;
 
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.Observer;
-import rx.Operator;
 import rx.Subscription;
 import rx.observables.GroupedObservable;
 import rx.schedulers.Schedulers;
@@ -581,10 +581,10 @@ Observable<Event> ASYNC_INFINITE_OBSERVABLE_OF_EVENT(final int numGroups, final
     };
 
     Observable<Event> SYNC_INFINITE_OBSERVABLE_OF_EVENT(final int numGroups, final AtomicInteger subscribeCounter, final AtomicInteger sentEventCounter) {
-        return Observable.create(new Action1<Operator<? super Event>>() {
+        return Observable.create(new OnSubscribe<Event>() {
 
             @Override
-            public void call(final Operator<? super Event> op) {
+            public void call(final Observer<? super Event> op) {
                 subscribeCounter.incrementAndGet();
                 int i = 0;
                 while (!op.isUnsubscribed()) {

File: rxjava-core/src/test/java/rx/operators/OperatorMergeTest.java
Patch:
@@ -18,7 +18,6 @@
 import static org.junit.Assert.*;
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
-import static rx.operators.OperatorMerge.*;
 
 import java.util.ArrayList;
 import java.util.Arrays;

File: rxjava-core/src/test/java/rx/operators/OperatorTakeTest.java
Patch:
@@ -27,8 +27,8 @@
 import org.mockito.InOrder;
 
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.Observer;
-import rx.Operator;
 import rx.Subscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Action1;
@@ -242,10 +242,10 @@ public void run() {
         }
     }
 
-    private static Observable<Long> INFINITE_OBSERVABLE = Observable.create(new Action1<Operator<? super Long>>() {
+    private static Observable<Long> INFINITE_OBSERVABLE = Observable.create(new OnSubscribe<Long>() {
 
         @Override
-        public void call(Operator<? super Long> op) {
+        public void call(Observer<? super Long> op) {
             long l = 1;
             while (!op.isUnsubscribed()) {
                 op.onNext(l++);

File: rxjava-core/src/test/java/rx/operators/OperatorTimestampTest.java
Patch:
@@ -46,7 +46,7 @@ public void timestampWithScheduler() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishSubject<Integer> source = PublishSubject.create();
-        Observable<Timestamped<Integer>> m = source.timestamp(scheduler);
+        Observable<Timestamped<Integer>> m = source.toObservable().timestamp(scheduler);
         m.subscribe(observer);
 
         source.onNext(1);
@@ -70,7 +70,7 @@ public void timestampWithScheduler2() {
         TestScheduler scheduler = new TestScheduler();
 
         PublishSubject<Integer> source = PublishSubject.create();
-        Observable<Timestamped<Integer>> m = source.timestamp(scheduler);
+        Observable<Timestamped<Integer>> m = source.toObservable().timestamp(scheduler);
         m.subscribe(observer);
 
         source.onNext(1);

File: rxjava-core/src/test/java/rx/operators/OperatorToObservableListTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
-import static rx.operators.OperatorToObservableList.*;
 
 import java.util.Arrays;
 import java.util.List;

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java
Patch:
@@ -561,7 +561,7 @@ public Subscription onSubscribe(final Observer<? super String> observer) {
      * 
      * @param <T>
      */
-    private static class ConcurrentObserverValidator<T> implements Observer<T> {
+    private static class ConcurrentObserverValidator<T> extends Observer<T> {
 
         final AtomicInteger concurrentCounter = new AtomicInteger();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();

File: rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java
Patch:
@@ -51,7 +51,7 @@ public Integer call(String s) {
     @Test
     public void testGroupBy() {
         Observable<String> source = Observable.from("one", "two", "three", "four", "five", "six");
-        Observable<GroupedObservable<Integer, String>> grouped = source.bind(new OperatorGroupBy<Integer, String>(length));
+        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));
 
         Map<Integer, Collection<String>> map = toMap(grouped);
 
@@ -64,7 +64,7 @@ public void testGroupBy() {
     @Test
     public void testEmpty() {
         Observable<String> source = Observable.empty();
-        Observable<GroupedObservable<Integer, String>> grouped = source.bind(new OperatorGroupBy<Integer, String>(length));
+        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));
 
         Map<Integer, Collection<String>> map = toMap(grouped);
 
@@ -77,7 +77,7 @@ public void testError() {
         Observable<String> errorSource = Observable.error(new RuntimeException("forced failure"));
         Observable<String> source = Observable.concat(sourceStrings, errorSource);
 
-        Observable<GroupedObservable<Integer, String>> grouped = source.bind(new OperatorGroupBy<Integer, String>(length));
+        Observable<GroupedObservable<Integer, String>> grouped = source.lift(new OperatorGroupBy<Integer, String>(length));
 
         final AtomicInteger groupCounter = new AtomicInteger();
         final AtomicInteger eventCounter = new AtomicInteger();

File: rxjava-core/src/test/java/rx/operators/OperatorMapTest.java
Patch:
@@ -61,7 +61,7 @@ public void testMap() {
         Map<String, String> m2 = getMap("Two");
         Observable<Map<String, String>> observable = Observable.from(m1, m2);
 
-        Observable<String> m = observable.bind(new OperatorMap<Map<String, String>, String>(new Func1<Map<String, String>, String>() {
+        Observable<String> m = observable.lift(new OperatorMap<Map<String, String>, String>(new Func1<Map<String, String>, String>() {
 
             @Override
             public String call(Map<String, String> map) {
@@ -159,7 +159,7 @@ public String call(Map<String, String> map) {
     @Test
     public void testMapWithError() {
         Observable<String> w = Observable.from("one", "fail", "two", "three", "fail");
-        Observable<String> m = w.bind(new OperatorMap<String, String>(new Func1<String, String>() {
+        Observable<String> m = w.lift(new OperatorMap<String, String>(new Func1<String, String>() {
             @Override
             public String call(String s) {
                 if ("fail".equals(s)) {

File: rxjava-core/src/test/java/rx/operators/OperatorToObservableListTest.java
Patch:
@@ -33,7 +33,7 @@ public class OperatorToObservableListTest {
     @Test
     public void testList() {
         Observable<String> w = Observable.from(Arrays.asList("one", "two", "three"));
-        Observable<List<String>> observable = w.bind(new OperatorToObservableList<String>());
+        Observable<List<String>> observable = w.lift(new OperatorToObservableList<String>());
 
         @SuppressWarnings("unchecked")
         Observer<List<String>> aObserver = mock(Observer.class);
@@ -59,7 +59,7 @@ public void testListViaObservable() {
     @Test
     public void testListMultipleObservers() {
         Observable<String> w = Observable.from(Arrays.asList("one", "two", "three"));
-        Observable<List<String>> observable = w.bind(new OperatorToObservableList<String>());
+        Observable<List<String>> observable = w.lift(new OperatorToObservableList<String>());
 
         @SuppressWarnings("unchecked")
         Observer<List<String>> o1 = mock(Observer.class);
@@ -83,7 +83,7 @@ public void testListMultipleObservers() {
     @Test
     public void testListWithNullValue() {
         Observable<String> w = Observable.from(Arrays.asList("one", null, "three"));
-        Observable<List<String>> observable = w.bind(new OperatorToObservableList<String>());
+        Observable<List<String>> observable = w.lift(new OperatorToObservableList<String>());
 
         @SuppressWarnings("unchecked")
         Observer<List<String>> aObserver = mock(Observer.class);

File: rxjava-core/src/test/java/rx/operators/OperatorToObservableSortedListTest.java
Patch:
@@ -33,7 +33,7 @@ public class OperatorToObservableSortedListTest {
     @Test
     public void testSortedList() {
         Observable<Integer> w = Observable.from(1, 3, 2, 5, 4);
-        Observable<List<Integer>> observable = w.bind(new OperatorToObservableSortedList<Integer>());
+        Observable<List<Integer>> observable = w.lift(new OperatorToObservableSortedList<Integer>());
 
         @SuppressWarnings("unchecked")
         Observer<List<Integer>> aObserver = mock(Observer.class);
@@ -46,7 +46,7 @@ public void testSortedList() {
     @Test
     public void testSortedListWithCustomFunction() {
         Observable<Integer> w = Observable.from(1, 3, 2, 5, 4);
-        Observable<List<Integer>> observable = w.bind(new OperatorToObservableSortedList<Integer>(new Func2<Integer, Integer, Integer>() {
+        Observable<List<Integer>> observable = w.lift(new OperatorToObservableSortedList<Integer>(new Func2<Integer, Integer, Integer>() {
 
             @Override
             public Integer call(Integer t1, Integer t2) {

File: rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java
Patch:
@@ -59,7 +59,7 @@ public void onCompleted() {
                 }
 
                 if (completionCounter.get() == 0) {
-                    // special case if no children are running (such as an empty sequence)
+                    // special case if no children are running (such as an empty sequence, or just getting the groups and not subscribing)
                     childOperator.onCompleted();
                 }
             }
@@ -88,6 +88,8 @@ public void onNext(T t) {
 
                             @Override
                             public void call(final Operator<? super T> o) {
+                                // number of children we have running
+                                completionCounter.incrementAndGet();
                                 o.add(Subscriptions.create(new Action0() {
 
                                     @Override
@@ -119,8 +121,6 @@ public void onNext(T t) {
 
                         });
                         groups.put(key, gps);
-                        // number of children we have running
-                        completionCounter.incrementAndGet();
                         childOperator.onNext(go);
                     }
                     // we have the correct group so send value to it

File: rxjava-core/src/main/java/rx/observables/ConnectableObservable.java
Patch:
@@ -17,9 +17,10 @@
 
 import rx.Observable;
 import rx.Observer;
+import rx.Operator;
 import rx.Subscription;
 import rx.operators.OperationRefCount;
-import rx.util.functions.Action2;
+import rx.util.functions.Action1;
 
 /**
  * A ConnectableObservable resembles an ordinary {@link Observable}, except that it does not begin
@@ -38,7 +39,7 @@
 
 public abstract class ConnectableObservable<T> extends Observable<T> {
 
-    protected ConnectableObservable(Action2<Observer<? super T>, OperatorSubscription> onSubscribe) {
+    protected ConnectableObservable(Action1<Operator<? super T>> onSubscribe) {
         super(onSubscribe);
     }
 

File: rxjava-core/src/main/java/rx/observables/GroupedObservable.java
Patch:
@@ -16,8 +16,8 @@
 package rx.observables;
 
 import rx.Observable;
-import rx.Observer;
-import rx.util.functions.Action2;
+import rx.Operator;
+import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 
 /**
@@ -33,7 +33,7 @@
 public class GroupedObservable<K, T> extends Observable<T> {
     private final K key;
 
-    public GroupedObservable(K key, Action2<Observer<? super T>, OperatorSubscription> onSubscribe) {
+    public GroupedObservable(K key, Action1<Operator<? super T>> onSubscribe) {
         super(onSubscribe);
         this.key = key;
     }

File: rxjava-core/src/main/java/rx/operators/OperatorTakeTimed.java
Patch:
@@ -40,6 +40,8 @@
  */
 public final class OperatorTakeTimed {
 
+    //TODO this has not been migrated to use bind yet
+    
     /**
      * Returns a specified number of contiguous values from the start of an observable sequence.
      * 

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -17,10 +17,10 @@
 
 import rx.Observable;
 import rx.Observable.OnSubscribeFunc;
-import rx.Observable.OperatorSubscription;
 import rx.Observer;
+import rx.Operator;
 import rx.Subscription;
-import rx.util.functions.Action2;
+import rx.util.functions.Action1;
 import rx.util.functions.Func1;
 
 /**
@@ -55,7 +55,7 @@ public <T> OnSubscribeFunc<T> onSubscribeStart(Observable<? extends T> observabl
         return onSubscribe;
     }
     
-    public <T> Action2<Observer<? super T>, OperatorSubscription> onSubscribeStart(Observable<? extends T> observableInstance, final Action2<Observer<? super T>, OperatorSubscription> onSubscribe) {
+    public <T> Action1<Operator<? super T>> onSubscribeStart(Observable<? extends T> observableInstance, final Action1<Operator<? super T>> onSubscribe) {
         // pass-thru by default
         return onSubscribe;
     }

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -20,9 +20,9 @@
 
 import rx.Notification;
 import rx.Observer;
+import rx.Operator;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
-import rx.util.functions.Action2;
 
 /**
  * Subject that publishes only the last event to each {@link Observer} that has subscribed when the
@@ -59,7 +59,7 @@ public static <T> AsyncSubject<T> create() {
         final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();
         final AtomicReference<Notification<T>> lastNotification = new AtomicReference<Notification<T>>(new Notification<T>());
 
-        Action2<Observer<? super T>, OperatorSubscription> onSubscribe = subscriptionManager.getOnSubscribeFunc(
+        Action1<Operator<? super T>> onSubscribe = subscriptionManager.getOnSubscribeFunc(
                 /**
                  * This function executes at beginning of subscription.
                  * 
@@ -98,7 +98,7 @@ protected static <T> void emitValueToObserver(Notification<T> n, Observer<? supe
     private final SubjectSubscriptionManager<T> subscriptionManager;
     final AtomicReference<Notification<T>> lastNotification;
 
-    protected AsyncSubject(Action2<Observer<? super T>, OperatorSubscription> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {
+    protected AsyncSubject(Action1<Operator<? super T>> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {
         super(onSubscribe);
         this.subscriptionManager = subscriptionManager;
         this.lastNotification = lastNotification;

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -20,6 +20,7 @@
 
 import rx.Notification;
 import rx.Observer;
+import rx.Operator;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
 import rx.util.functions.Action2;
@@ -91,7 +92,7 @@ public static <T> BehaviorSubject<T> create(T defaultValue) {
         // set a default value so subscriptions will immediately receive this until a new notification is received
         final AtomicReference<Notification<T>> lastNotification = new AtomicReference<Notification<T>>(new Notification<T>(defaultValue));
 
-        Action2<Observer<? super T>, OperatorSubscription> onSubscribe = subscriptionManager.getOnSubscribeFunc(
+        Action1<Operator<? super T>> onSubscribe = subscriptionManager.getOnSubscribeFunc(
                 /**
                  * This function executes at beginning of subscription.
                  * 
@@ -133,7 +134,7 @@ public void call(SubjectObserver<? super T> o) {
     private final SubjectSubscriptionManager<T> subscriptionManager;
     final AtomicReference<Notification<T>> lastNotification;
 
-    protected BehaviorSubject(Action2<Observer<? super T>, OperatorSubscription> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {
+    protected BehaviorSubject(Action1<Operator<? super T>> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {
         super(onSubscribe);
         this.subscriptionManager = subscriptionManager;
         this.lastNotification = lastNotification;

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -20,6 +20,7 @@
 
 import rx.Notification;
 import rx.Observer;
+import rx.Operator;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
 import rx.util.functions.Action2;
@@ -54,7 +55,7 @@ public static <T> PublishSubject<T> create() {
         // set a default value so subscriptions will immediately receive this until a new notification is received
         final AtomicReference<Notification<T>> lastNotification = new AtomicReference<Notification<T>>();
 
-        Action2<Observer<? super T>, OperatorSubscription> onSubscribe = subscriptionManager.getOnSubscribeFunc(
+        Action1<Operator<? super T>> onSubscribe = subscriptionManager.getOnSubscribeFunc(
                 /**
                  * This function executes at beginning of subscription.
                  * 
@@ -88,7 +89,7 @@ public void call(SubjectObserver<? super T> o) {
     private final SubjectSubscriptionManager<T> subscriptionManager;
     final AtomicReference<Notification<T>> lastNotification;
 
-    protected PublishSubject(Action2<Observer<? super T>, OperatorSubscription> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {
+    protected PublishSubject(Action1<Operator<? super T>> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, AtomicReference<Notification<T>> lastNotification) {
         super(onSubscribe);
         this.subscriptionManager = subscriptionManager;
         this.lastNotification = lastNotification;

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -23,6 +23,7 @@
 
 import rx.Notification;
 import rx.Observer;
+import rx.Operator;
 import rx.subjects.SubjectSubscriptionManager.SubjectObserver;
 import rx.util.functions.Action1;
 import rx.util.functions.Action2;
@@ -59,7 +60,7 @@ public static <T> ReplaySubject<T> create(int initialCapacity) {
         final SubjectSubscriptionManager<T> subscriptionManager = new SubjectSubscriptionManager<T>();
         final ReplayState<T> state = new ReplayState<T>(initialCapacity);
 
-        Action2<Observer<? super T>, OperatorSubscription> onSubscribe = subscriptionManager.getOnSubscribeFunc(
+        Action1<Operator<? super T>> onSubscribe = subscriptionManager.getOnSubscribeFunc(
                 /**
                  * This function executes at beginning of subscription.
                  * We want to replay history with the subscribing thread
@@ -108,7 +109,7 @@ public ReplayState(int initialCapacity) {
     private final SubjectSubscriptionManager<T> subscriptionManager;
     private final ReplayState<T> state;
 
-    protected ReplaySubject(Action2<Observer<? super T>, OperatorSubscription> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, ReplayState<T> state) {
+    protected ReplaySubject(Action1<Operator<? super T>> onSubscribe, SubjectSubscriptionManager<T> subscriptionManager, ReplayState<T> state) {
         super(onSubscribe);
         this.subscriptionManager = subscriptionManager;
         this.state = state;

File: rxjava-core/src/main/java/rx/subjects/Subject.java
Patch:
@@ -17,10 +17,11 @@
 
 import rx.Observable;
 import rx.Observer;
-import rx.util.functions.Action2;
+import rx.Operator;
+import rx.util.functions.Action1;
 
 public abstract class Subject<T, R> extends Observable<R> implements Observer<T> {
-    protected Subject(Action2<Observer<? super R>, OperatorSubscription> onSubscribe) {
+    protected Subject(Action1<Operator<? super R>> onSubscribe) {
         super(onSubscribe);
     }
 }

File: rxjava-core/src/main/java/rx/plugins/RxJavaErrorHandler.java
Patch:
@@ -30,6 +30,8 @@ public abstract class RxJavaErrorHandler {
 
     /**
      * Receives all Exceptions from an {@link Observable} passed to {@link Observer#onError(Throwable)}.
+     * <p>
+     * This should NEVER throw an Exception. Make sure to try/catch(Throwable) all code inside this method implementation.
      * 
      * @param e
      *            Exception

File: rxjava-core/src/main/java/rx/plugins/RxJavaErrorHandler.java
Patch:
@@ -30,6 +30,8 @@ public abstract class RxJavaErrorHandler {
 
     /**
      * Receives all Exceptions from an {@link Observable} passed to {@link Observer#onError(Throwable)}.
+     * <p>
+     * This should NEVER throw an Exception. Make sure to try/catch(Throwable) all code inside this method implementation.
      * 
      * @param e
      *            Exception

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -165,7 +165,7 @@ public Subscription call(final Scheduler scheduler, final Func2 parentAction) {
                     @Override
                     public void call() {
                         if (!parentSubscription.isUnsubscribed()) {
-                            childSubscription.setSubscription(scheduler.schedule(parentAction, parentAction));
+                            childSubscription.set(scheduler.schedule(parentAction, parentAction));
                         }
                     }
 

File: rxjava-core/src/main/java/rx/operators/OperationObserveOn.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 
 import rx.Notification;
 import rx.Observable;
@@ -71,7 +72,7 @@ private class Observation {
             final CompositeSubscription compositeSubscription = new CompositeSubscription();
             final MultipleAssignmentSubscription recursiveSubscription = new MultipleAssignmentSubscription();
             final ConcurrentLinkedQueue<Notification<? extends T>> queue = new ConcurrentLinkedQueue<Notification<? extends T>>();
-            final AtomicInteger counter = new AtomicInteger(0);
+            final AtomicLong counter = new AtomicLong(0);
             private volatile Scheduler recursiveScheduler;
 
             public Observation(Observer<? super T> observer) {
@@ -108,7 +109,7 @@ public Subscription call(Scheduler innerScheduler, T state) {
                 }
 
                 void processQueue() {
-                    recursiveSubscription.setSubscription(recursiveScheduler.schedule(new Action1<Action0>() {
+                    recursiveSubscription.set(recursiveScheduler.schedule(new Action1<Action0>() {
                         @Override
                         public void call(Action0 self) {
                             Notification<? extends T> not = queue.poll();

File: rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerConcurrencyTests.java
Patch:
@@ -163,7 +163,7 @@ public Subscription call(Scheduler innerScheduler, Long i) {
         assertEquals(10, counter.get());
     }
 
-    @Test(timeout = 8000)
+    @Test(timeout = 20000)
     public void recursionUsingFunc2() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         getScheduler().schedule(1L, new Func2<Scheduler, Long, Subscription>() {
@@ -185,7 +185,7 @@ public Subscription call(Scheduler innerScheduler, Long i) {
         latch.await();
     }
 
-    @Test(timeout = 8000)
+    @Test(timeout = 20000)
     public void recursionUsingAction0() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         getScheduler().schedule(new Action1<Action0>() {

File: rxjava-core/src/test/java/rx/schedulers/TestRecursionMemoryUsage.java
Patch:
@@ -20,8 +20,8 @@ public static void main(String args[]) {
         usingFunc2(Schedulers.newThread());
         usingAction0(Schedulers.newThread());
 
-//        usingFunc2(Schedulers.currentThread());
-//        usingAction0(Schedulers.currentThread());
+        usingFunc2(Schedulers.currentThread());
+        usingAction0(Schedulers.currentThread());
 
         usingFunc2(Schedulers.threadPoolForComputation());
         usingAction0(Schedulers.threadPoolForComputation());

File: rxjava-core/src/test/java/rx/schedulers/TestRecursionMemoryUsage.java
Patch:
@@ -19,12 +19,12 @@ public class TestRecursionMemoryUsage {
     public static void main(String args[]) {
         usingFunc2(Schedulers.newThread());
         usingAction0(Schedulers.newThread());
-//
+
 //        usingFunc2(Schedulers.currentThread());
 //        usingAction0(Schedulers.currentThread());
 
-//        usingFunc2(Schedulers.threadPoolForComputation());
-//        usingAction0(Schedulers.threadPoolForComputation());
+        usingFunc2(Schedulers.threadPoolForComputation());
+        usingAction0(Schedulers.threadPoolForComputation());
     }
 
     protected static void usingFunc2(final Scheduler scheduler) {

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -165,7 +165,7 @@ public Subscription call(final Scheduler scheduler, final Func2 parentAction) {
                     @Override
                     public void call() {
                         if (!parentSubscription.isUnsubscribed()) {
-                            childSubscription.setSubscription(scheduler.schedule(parentAction, parentAction));
+                            childSubscription.set(scheduler.schedule(parentAction, parentAction));
                         }
                     }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -6793,7 +6793,7 @@ public void onNext(T args) { }
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnNext()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnNext(final Action1<T> onNext) {
+    public Observable<T> doOnNext(final Action1<? super T> onNext) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() { }
@@ -6822,7 +6822,7 @@ public void onNext(T args) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229307.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<Notification<T>> onNotification) {
+    public Observable<T> doOnEach(final Action1<Notification<? super T>> onNotification) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -6793,7 +6793,7 @@ public void onNext(T args) { }
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnNext()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnNext(final Action1<T> onNext) {
+    public Observable<T> doOnNext(final Action1<? super T> onNext) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() { }
@@ -6822,7 +6822,7 @@ public void onNext(T args) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229307.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<Notification<T>> onNotification) {
+    public Observable<T> doOnEach(final Action1<Notification<? super T>> onNotification) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -27,7 +27,7 @@
  * Subject that publishes only the last event to each {@link Observer} that has subscribed when the
  * sequence completes.
  * <p>
- * <img src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.AsyncSubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.AsyncSubject.png">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Subject that publishes the most recent and all subsequent events to each subscribed {@link Observer}.
  * <p>
- * <img src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.BehaviorSubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.BehaviorSubject.png">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Subject that, once and {@link Observer} has subscribed, publishes all subsequent events to the subscriber.
  * <p>
- * <img src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.PublishSubject.png">
+ * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.PublishSubject.png">
  * <p>
  * Example usage:
  * <p>

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -65,6 +65,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
                         try {
                             current.terminationLatch.await();
                         } catch (InterruptedException e) {
+                            Thread.currentThread().interrupt();
                             throw new RuntimeException("Interrupted waiting for termination.", e);
                         }
                         break;

File: rxjava-core/src/main/java/rx/subjects/SubjectSubscriptionManager.java
Patch:
@@ -65,6 +65,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
                         try {
                             current.terminationLatch.await();
                         } catch (InterruptedException e) {
+                            Thread.currentThread().interrupt();
                             throw new RuntimeException("Interrupted waiting for termination.", e);
                         }
                         break;

File: rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java
Patch:
@@ -52,7 +52,9 @@ private EventLoopScheduler() {
 
                 @Override
                 public Thread newThread(Runnable r) {
-                    return new Thread(r, "RxNewThreadScheduler-" + count.incrementAndGet());
+                    Thread t = new Thread(r, "RxNewThreadScheduler-" + count.incrementAndGet());
+                    t.setDaemon(true);
+                    return t;
                 }
             });
         }

File: rxjava-core/src/test/java/rx/operators/OperationLatestTest.java
Patch:
@@ -104,7 +104,7 @@ public void testSimpleJustNext() {
             Assert.assertEquals(Long.valueOf(i), it.next());
         }
     }
-    @Test(timeout = 1000, expected = RuntimeException.class)
+    @Test(/*timeout = 1000, */expected = RuntimeException.class)
     public void testHasNextThrows() {
         TestScheduler scheduler = new TestScheduler();
         

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -168,7 +168,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
             /**
              * Subscribe to the parent Observable to get to the children Observables
              */
-            completeSubscription.add(sequences.subscribe(new ParentObserver(actualObserver)));
+            completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));
 
             /* return our subscription to allow unsubscribing */
             return completeSubscription;

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -168,7 +168,7 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {
             /**
              * Subscribe to the parent Observable to get to the children Observables
              */
-            completeSubscription.add(sequences.subscribe(new ParentObserver(actualObserver)));
+            completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));
 
             /* return our subscription to allow unsubscribing */
             return completeSubscription;

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -164,6 +164,9 @@ public void onError(Throwable e)
     public void onNext(T args)
     {
         synchronized (subscriptions) {
+            if (isDone) {
+                return;
+            }
             history.add(args);
             for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {
                 observer.onNext(args);

File: rxjava-core/src/main/java/rx/subjects/ReplaySubject.java
Patch:
@@ -164,6 +164,9 @@ public void onError(Throwable e)
     public void onNext(T args)
     {
         synchronized (subscriptions) {
+            if (isDone) {
+                return;
+            }
             history.add(args);
             for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {
                 observer.onNext(args);

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -2315,6 +2315,9 @@ public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> firs
         return sequenceEqual(first, second, new Func2<T, T, Boolean>() {
             @Override
             public Boolean call(T first, T second) {
+                if(first == null) {
+                    return second == null;
+                }
                 return first.equals(second);
             }
         });

File: rxjava-core/src/test/java/rx/SchedulersTest.java
Patch:
@@ -460,7 +460,7 @@ public void run() {
         }
 
         if (observer.error.get() == null) {
-            fail("We expected error messages due to concurrency");
+            fail("We expected error messages due to schedulers");
         }
     }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -5518,7 +5518,7 @@ public Observable<T> doOnEach(Observer<? super T> observer) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<T> onNext) {
+    public Observable<T> doOnEach(final Action1<? super T> onNext) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {}
@@ -5609,7 +5609,7 @@ public void onNext(T args) { }
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229539.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError) {
+    public Observable<T> doOnEach(final Action1<? super T> onNext, final Action1<Throwable> onError) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {}
@@ -5644,7 +5644,7 @@ public void onNext(T args) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229830.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {
+    public Observable<T> doOnEach(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -5518,7 +5518,7 @@ public Observable<T> doOnEach(Observer<? super T> observer) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<T> onNext) {
+    public Observable<T> doOnEach(final Action1<? super T> onNext) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {}
@@ -5609,7 +5609,7 @@ public void onNext(T args) { }
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229539.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError) {
+    public Observable<T> doOnEach(final Action1<? super T> onNext, final Action1<Throwable> onError) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {}
@@ -5644,7 +5644,7 @@ public void onNext(T args) {
      * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229830.aspx">MSDN: Observable.Do</a>
      */
-    public Observable<T> doOnEach(final Action1<T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {
+    public Observable<T> doOnEach(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {
         Observer<T> observer = new Observer<T>() {
             @Override
             public void onCompleted() {

File: language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java
Patch:
@@ -19,7 +19,7 @@
 import rx.lang.scala.examples.Movie;
 import rx.lang.scala.examples.MovieLib;
 import rx.util.functions.Action1;
-import static rx.lang.scala.ImplicitFunctionConversions.toScalaObservable;
+import static rx.lang.scala.JavaConversions.toScalaObservable;
 
 public class MovieLibUsage {
 

File: rxjava-core/src/test/java/rx/operators/OperationSkipUntilTest.java
Patch:
@@ -89,7 +89,7 @@ public void otherEmpty() {
         
         verify(observer, never()).onError(any(Throwable.class));
         verify(observer, never()).onNext(any());
-        verify(observer, times(1)).onCompleted();
+        verify(observer, never()).onCompleted();
     }
     @Test
     public void otherFiresAndCompletes() {

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -78,7 +78,6 @@ public void call() {
                 @Override
                 public void call() {
                     wrapped.unsubscribe();
-                    observer.onCompleted();
                 }
             });
         }

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -78,7 +78,6 @@ public void call() {
                 @Override
                 public void call() {
                     wrapped.unsubscribe();
-                    observer.onCompleted();
                 }
             });
         }

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -3596,14 +3596,16 @@ public static Observable<Double> sumDoubles(Observable<Double> source) {
 
     /**
      * Returns an Observable that computes the average of all elements in the source Observable.
-     * For an empty source, it causes an ArithmeticException.
+     * For an empty source, it causes an IllegalArgumentException.
      * <p>
      * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/average.png">
      * 
      * @param source
      *            Source observable to compute the average of.
      * @return an Observable emitting the averageof all the elements of the source Observable
      *         as its single item.
+     * @throws IllegalArgumentException
+     *             if Observable sequence is empty.
      * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.average%28v=vs.103%29.aspx">MSDN: Observable.Average</a>
      */
     public static Observable<Integer> average(Observable<Integer> source) {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -3593,14 +3593,16 @@ public static Observable<Double> sumDoubles(Observable<Double> source) {
 
     /**
      * Returns an Observable that computes the average of all elements in the source Observable.
-     * For an empty source, it causes an ArithmeticException.
+     * For an empty source, it causes an IllegalArgumentException.
      * <p>
      * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/average.png">
      * 
      * @param source
      *            Source observable to compute the average of.
      * @return an Observable emitting the averageof all the elements of the source Observable
      *         as its single item.
+     * @throws IllegalArgumentException
+     *             if Observable sequence is empty.
      * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.average%28v=vs.103%29.aspx">MSDN: Observable.Average</a>
      */
     public static Observable<Integer> average(Observable<Integer> source) {

File: rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java
Patch:
@@ -119,7 +119,7 @@ public Subscription onSubscribe(Observer<? super String> observer) {
             public Boolean call(String s) {
                 return false;
             }
-        })).toBlockingObservable().last();
+        })).toBlockingObservable().lastOrDefault("");
     }
 
     @Test

File: rxjava-core/src/test/java/rx/operators/OperationTakeWhileTest.java
Patch:
@@ -119,7 +119,7 @@ public Subscription onSubscribe(Observer<? super String> observer) {
             public Boolean call(String s) {
                 return false;
             }
-        })).toBlockingObservable().last();
+        })).toBlockingObservable().lastOrDefault("");
     }
 
     @Test

File: rxjava-core/src/test/java/rx/observables/BlockingObservableTest.java
Patch:
@@ -49,11 +49,10 @@ public void testLast() {
         assertEquals("three", obs.last());
     }
 
-    @Test
+    @Test(expected = IllegalArgumentException.class)
     public void testLastEmptyObservable() {
         BlockingObservable<Object> obs = BlockingObservable.from(Observable.empty());
-
-        assertNull(obs.last());
+        obs.last();
     }
 
     @Test

File: rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java
Patch:
@@ -361,8 +361,8 @@ public void testSchedulingWithDueTime() throws InterruptedException {
             @Override
             public Subscription call(Scheduler scheduler, String state) {
                 System.out.println("doing work");
-                latch.countDown();
                 counter.incrementAndGet();
+                latch.countDown();
                 if (latch.getCount() == 0) {
                     return Subscriptions.empty();
                 } else {

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java
Patch:
@@ -143,7 +143,7 @@ public Subscription onSubscribe(final Observer<? super ObservableHttpResponse> o
                 final CompositeSubscription parentSubscription = new CompositeSubscription();
 
                 // return a Subscription that wraps the Future so it can be cancelled
-                parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),
+                parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),
                         new FutureCallback<HttpResponse>() {
 
                             @Override

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -52,7 +52,9 @@ public ResponseConsumerDelegate(final Observer<? super ObservableHttpResponse> o
     @Override
     protected void onResponseReceived(HttpResponse response) throws HttpException, IOException {
         // when we receive the response with headers we evaluate what type of consumer we want
-        if (response.getFirstHeader("Content-Type").getValue().equals("text/event-stream")) {
+        if (response.getFirstHeader("Content-Type").getValue().contains("text/event-stream")) {
+            // use 'contains' instead of equals since Content-Type can contain additional information
+            // such as charset ... see here: http://www.w3.org/International/O-HTTP-charset
             consumer = new ResponseConsumerEventStream(observer, subscription);
         } else {
             consumer = new ResponseConsumerBasic(observer, subscription);

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java
Patch:
@@ -143,7 +143,7 @@ public Subscription onSubscribe(final Observer<? super ObservableHttpResponse> o
                 final CompositeSubscription parentSubscription = new CompositeSubscription();
 
                 // return a Subscription that wraps the Future so it can be cancelled
-                parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),
+                parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),
                         new FutureCallback<HttpResponse>() {
 
                             @Override

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -52,7 +52,9 @@ public ResponseConsumerDelegate(final Observer<? super ObservableHttpResponse> o
     @Override
     protected void onResponseReceived(HttpResponse response) throws HttpException, IOException {
         // when we receive the response with headers we evaluate what type of consumer we want
-        if (response.getFirstHeader("Content-Type").getValue().equals("text/event-stream")) {
+        if (response.getFirstHeader("Content-Type").getValue().contains("text/event-stream")) {
+            // use 'contains' instead of equals since Content-Type can contain additional information
+            // such as charset ... see here: http://www.w3.org/International/O-HTTP-charset
             consumer = new ResponseConsumerEventStream(observer, subscription);
         } else {
             consumer = new ResponseConsumerBasic(observer, subscription);

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java
Patch:
@@ -143,7 +143,7 @@ public Subscription onSubscribe(final Observer<? super ObservableHttpResponse> o
                 final CompositeSubscription parentSubscription = new CompositeSubscription();
 
                 // return a Subscription that wraps the Future so it can be cancelled
-                parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),
+                parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),
                         new FutureCallback<HttpResponse>() {
 
                             @Override

File: rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java
Patch:
@@ -52,7 +52,9 @@ public ResponseConsumerDelegate(final Observer<? super ObservableHttpResponse> o
     @Override
     protected void onResponseReceived(HttpResponse response) throws HttpException, IOException {
         // when we receive the response with headers we evaluate what type of consumer we want
-        if (response.getFirstHeader("Content-Type").getValue().equals("text/event-stream")) {
+        if (response.getFirstHeader("Content-Type").getValue().contains("text/event-stream")) {
+            // use 'contains' instead of equals since Content-Type can contain additional information
+            // such as charset ... see here: http://www.w3.org/International/O-HTTP-charset
             consumer = new ResponseConsumerEventStream(observer, subscription);
         } else {
             consumer = new ResponseConsumerBasic(observer, subscription);

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -46,7 +46,7 @@ public final class OperationInterval {
      * Creates an event each time interval.
      */
     public static OnSubscribeFunc<Long> interval(long interval, TimeUnit unit) {
-        return interval(interval, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));
+        return interval(interval, unit, Schedulers.threadPoolForComputation());
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperationSample.java
Patch:
@@ -49,7 +49,7 @@ public final class OperationSample {
      * Samples the observable sequence at each interval.
      */
     public static <T> OnSubscribeFunc<T> sample(final Observable<? extends T> source, long period, TimeUnit unit) {
-        return new Sample<T>(source, period, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));
+        return new Sample<T>(source, period, unit, Schedulers.threadPoolForComputation());
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -46,7 +46,7 @@ public final class OperationInterval {
      * Creates an event each time interval.
      */
     public static OnSubscribeFunc<Long> interval(long interval, TimeUnit unit) {
-        return interval(interval, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));
+        return interval(interval, unit, Schedulers.threadPoolForComputation());
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperationSample.java
Patch:
@@ -49,7 +49,7 @@ public final class OperationSample {
      * Samples the observable sequence at each interval.
      */
     public static <T> OnSubscribeFunc<T> sample(final Observable<? extends T> source, long period, TimeUnit unit) {
-        return new Sample<T>(source, period, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));
+        return new Sample<T>(source, period, unit, Schedulers.threadPoolForComputation());
     }
 
     /**

File: rxjava-core/src/main/java/rx/operators/ChunkedOperation.java
Patch:
@@ -61,7 +61,8 @@ protected interface ChunkCreator {
      * 
      * @param <T>
      *            The type of objects which this {@link Chunk} can hold.
-     *            <C> The type of object being tracked by the {@link Chunk}
+     * @param <C> 
+     *            The type of object being tracked by the {@link Chunk}
      */
     protected abstract static class Chunk<T, C> {
         protected final List<T> contents = new ArrayList<T>();
@@ -78,7 +79,7 @@ public void pushValue(T value) {
 
         /**
          * @return
-         *         The mutable underlying {@link C} which contains all the
+         *         The mutable underlying {@code C} which contains all the
          *         recorded values in this {@link Chunk} object.
          */
         abstract public C getContents();

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -287,7 +287,6 @@ public void testEmpty() {
         public void testError() {
             Observable<String> sourceStrings = Observable.from("one", "two", "three", "four", "five", "six");
             Observable<String> errorSource = Observable.error(new RuntimeException("forced failure"));
-            @SuppressWarnings("unchecked")
             Observable<String> source = Observable.concat(sourceStrings, errorSource);
 
             Observable<GroupedObservable<Integer, String>> grouped = Observable.create(groupBy(source, length));

File: rxjava-core/src/main/java/rx/operators/OperationRetry.java
Patch:
@@ -198,6 +198,6 @@ public Subscription onSubscribe(Observer<? super String> o) {
                 }
                 return Subscriptions.empty();
             }
-        };
+        }
     }
 }

File: rxjava-core/src/test/java/rx/performance/PerformanceTest.java
Patch:
@@ -122,7 +122,6 @@ public static void main(String[] args) {
         System.out.println("nonCompositionalTestWithArrayOfFunctionsTotalTime: " + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
     }
 
-    @SuppressWarnings("unchecked")
     public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
         System.out.println("runCompositionTestWithMultipleOperations");
 

File: rxjava-core/src/main/java/rx/operators/ChunkedOperation.java
Patch:
@@ -61,7 +61,8 @@ protected interface ChunkCreator {
      * 
      * @param <T>
      *            The type of objects which this {@link Chunk} can hold.
-     *            <C> The type of object being tracked by the {@link Chunk}
+     * @param <C> 
+     *            The type of object being tracked by the {@link Chunk}
      */
     protected abstract static class Chunk<T, C> {
         protected final List<T> contents = new ArrayList<T>();
@@ -78,7 +79,7 @@ public void pushValue(T value) {
 
         /**
          * @return
-         *         The mutable underlying {@link C} which contains all the
+         *         The mutable underlying {@code C} which contains all the
          *         recorded values in this {@link Chunk} object.
          */
         abstract public C getContents();

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -3193,7 +3193,7 @@ public Observable<T> aggregate(Func2<T, T, T> accumulator) {
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>
      * @see <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>
      */
-    public <R> Observable<R> reduce(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator) {
+    public <R> Observable<R> reduce(R initialValue, Func2<R, ? super T, R> accumulator) {
         return create(OperationScan.scan(this, initialValue, accumulator)).takeLast(1);
     }
 
@@ -3204,7 +3204,7 @@ public <R> Observable<R> reduce(R initialValue, Func2<? super R, ? super T, ? ex
      * 
      * @see #reduce(Object, Func2)
      */
-    public <R> Observable<R> aggregate(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator) {
+    public <R> Observable<R> aggregate(R initialValue, Func2<R, ? super T, R> accumulator) {
         return reduce(initialValue, accumulator);
     }
 
@@ -3288,7 +3288,7 @@ public Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {
      * @return an Observable that emits the results of each call to the accumulator function
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a>
      */
-    public <R> Observable<R> scan(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator) {
+    public <R> Observable<R> scan(R initialValue, Func2<R, ? super T, R> accumulator) {
         return create(OperationScan.scan(this, initialValue, accumulator));
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationZip.java
Patch:
@@ -147,7 +147,7 @@ public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> OnSubscribeFunc<R> zip(Obs
         return a;
     }
 
-    public static <R> OnSubscribeFunc<R> zip(Collection<? extends Observable<?>> ws, FuncN<? extends R> zipFunction) {
+    public static <R> OnSubscribeFunc<R> zip(Iterable<? extends Observable<?>> ws, FuncN<? extends R> zipFunction) {
         Aggregator<R> a = new Aggregator<R>(zipFunction);
         for (Observable<?> w : ws) {
             ZipObserver<R, Object> zipObserver = new ZipObserver<R, Object>(a, w);

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -3021,7 +3021,7 @@ public Observable<T> onErrorReturn(Func1<Throwable, ? extends T> resumeFunction)
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>
      * @see <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>
      */
-    public Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator) {
+    public Observable<T> reduce(Func2<T, T, T> accumulator) {
         return create(OperationScan.scan(this, accumulator)).takeLast(1);
     }
 
@@ -3166,7 +3166,7 @@ public ConnectableObservable<T> publish() {
      * 
      * @see #reduce(Func2)
      */
-    public Observable<T> aggregate(Func2<? super T, ? super T, ? extends T> accumulator) {
+    public Observable<T> aggregate(Func2<T, T, T> accumulator) {
         return reduce(accumulator);
     }
 
@@ -3227,7 +3227,7 @@ public <R> Observable<R> aggregate(R initialValue, Func2<? super R, ? super T, ?
      * @return an Observable that emits the results of each call to the accumulator function
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a>
      */
-    public Observable<T> scan(Func2<? super T, ? super T, ? extends T> accumulator) {
+    public Observable<T> scan(Func2<T, T, T> accumulator) {
         return create(OperationScan.scan(this, accumulator));
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationScan.java
Patch:
@@ -70,7 +70,7 @@ public static <T, R> OnSubscribeFunc<R> scan(Observable<? extends T> sequence, R
      * @return An observable sequence whose elements are the result of accumulating the output from the list of Observables.
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx">Observable.Scan(TSource) Method (IObservable(TSource), Func(TSource, TSource, TSource))</a>
      */
-    public static <T> OnSubscribeFunc<T> scan(Observable<? extends T> sequence, Func2<? super T, ? super T, ? extends T> accumulator) {
+    public static <T> OnSubscribeFunc<T> scan(Observable<? extends T> sequence, Func2<T, T, T> accumulator) {
         return new AccuWithoutInitialValue<T>(sequence, accumulator);
     }
 

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -387,7 +387,7 @@ public void testLast() {
 
         @Test
         public void testLastEmptyObservable() {
-            BlockingObservable<Object> obs = BlockingObservable.from(Observable.from());
+            BlockingObservable<Object> obs = BlockingObservable.from(Observable.empty());
 
             assertNull(obs.last());
         }
@@ -412,7 +412,7 @@ public void testLastOrDefault1() {
 
         @Test
         public void testLastOrDefault2() {
-            BlockingObservable<Object> observable = BlockingObservable.from(Observable.from());
+            BlockingObservable<Object> observable = BlockingObservable.from(Observable.empty());
             assertEquals("default", observable.lastOrDefault("default"));
         }
 
@@ -460,7 +460,7 @@ public void testSingle() {
 
         @Test
         public void testSingleDefault() {
-            BlockingObservable<Object> observable = BlockingObservable.from(Observable.from());
+            BlockingObservable<Object> observable = BlockingObservable.from(Observable.empty());
             assertEquals("default", observable.singleOrDefault("default"));
         }
 

File: rxjava-core/src/main/java/rx/operators/OperationConcat.java
Patch:
@@ -60,7 +60,7 @@ public static <T> OnSubscribeFunc<T> concat(final Observable<? extends T>... seq
         return concat(Observable.from(sequences));
     }
 
-    public static <T> OnSubscribeFunc<T> concat(final List<? extends Observable<? extends T>> sequences) {
+    public static <T> OnSubscribeFunc<T> concat(final Iterable<? extends Observable<? extends T>> sequences) {
         return concat(Observable.from(sequences));
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -275,7 +275,7 @@ public void testGroupBy() {
 
         @Test
         public void testEmpty() {
-            Observable<String> source = Observable.from();
+            Observable<String> source = Observable.empty();
             Observable<GroupedObservable<Integer, String>> grouped = Observable.create(groupBy(source, length));
 
             Map<Integer, Collection<String>> map = toMap(grouped);

File: rxjava-core/src/main/java/rx/operators/OperationMerge.java
Patch:
@@ -70,7 +70,7 @@ public static <T> OnSubscribeFunc<T> merge(final Observable<? extends T>... sequ
         return merge(Arrays.asList(sequences));
     }
 
-    public static <T> OnSubscribeFunc<T> merge(final List<? extends Observable<? extends T>> sequences) {
+    public static <T> OnSubscribeFunc<T> merge(final Iterable<? extends Observable<? extends T>> sequences) {
         return merge(Observable.create(new OnSubscribeFunc<Observable<? extends T>>() {
 
             private volatile boolean unsubscribed = false;

File: rxjava-core/src/main/java/rx/operators/OperationTakeLast.java
Patch:
@@ -100,7 +100,7 @@ public static class UnitTest {
 
         @Test
         public void testTakeLastEmpty() {
-            Observable<String> w = Observable.from();
+            Observable<String> w = Observable.empty();
             Observable<String> take = Observable.create(takeLast(w, 2));
 
             @SuppressWarnings("unchecked")

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -1199,7 +1199,7 @@ public static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? e
      *         the {@code source} Observables, one after the other
      * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat(v=vs.103).aspx">MSDN: Observable.Concat Method</a>
      */
-    public static <T> Observable<T> concat(Observable<Observable<T>> observables) {
+    public static <T> Observable<T> concat(Observable<? extends Observable<? extends T>> observables) {
         return create(OperationConcat.concat(observables));
     }
     

File: rxjava-core/src/main/java/rx/operators/OperationMerge.java
Patch:
@@ -70,7 +70,7 @@ public static <T> OnSubscribeFunc<T> merge(final Observable<? extends T>... sequ
         return merge(Arrays.asList(sequences));
     }
 
-    public static <T> OnSubscribeFunc<T> merge(final List<? extends Observable<? extends T>> sequences) {
+    public static <T> OnSubscribeFunc<T> merge(final Iterable<? extends Observable<? extends T>> sequences) {
         return merge(Observable.create(new OnSubscribeFunc<Observable<? extends T>>() {
 
             private volatile boolean unsubscribed = false;

File: rxjava-core/src/main/java/rx/operators/OperationConcat.java
Patch:
@@ -60,7 +60,7 @@ public static <T> OnSubscribeFunc<T> concat(final Observable<? extends T>... seq
         return concat(Observable.from(sequences));
     }
 
-    public static <T> OnSubscribeFunc<T> concat(final List<? extends Observable<? extends T>> sequences) {
+    public static <T> OnSubscribeFunc<T> concat(final Iterable<? extends Observable<? extends T>> sequences) {
         return concat(Observable.from(sequences));
     }
 

File: rxjava-core/src/main/java/rx/observables/BlockingObservable.java
Patch:
@@ -387,7 +387,7 @@ public void testLast() {
 
         @Test
         public void testLastEmptyObservable() {
-            BlockingObservable<Object> obs = BlockingObservable.from(Observable.from());
+            BlockingObservable<Object> obs = BlockingObservable.from(Observable.empty());
 
             assertNull(obs.last());
         }
@@ -412,7 +412,7 @@ public void testLastOrDefault1() {
 
         @Test
         public void testLastOrDefault2() {
-            BlockingObservable<Object> observable = BlockingObservable.from(Observable.from());
+            BlockingObservable<Object> observable = BlockingObservable.from(Observable.empty());
             assertEquals("default", observable.lastOrDefault("default"));
         }
 
@@ -460,7 +460,7 @@ public void testSingle() {
 
         @Test
         public void testSingleDefault() {
-            BlockingObservable<Object> observable = BlockingObservable.from(Observable.from());
+            BlockingObservable<Object> observable = BlockingObservable.from(Observable.empty());
             assertEquals("default", observable.singleOrDefault("default"));
         }
 

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -275,7 +275,7 @@ public void testGroupBy() {
 
         @Test
         public void testEmpty() {
-            Observable<String> source = Observable.from();
+            Observable<String> source = Observable.empty();
             Observable<GroupedObservable<Integer, String>> grouped = Observable.create(groupBy(source, length));
 
             Map<Integer, Collection<String>> map = toMap(grouped);

File: rxjava-core/src/main/java/rx/operators/OperationTakeLast.java
Patch:
@@ -100,7 +100,7 @@ public static class UnitTest {
 
         @Test
         public void testTakeLastEmpty() {
-            Observable<String> w = Observable.from();
+            Observable<String> w = Observable.empty();
             Observable<String> take = Observable.create(takeLast(w, 2));
 
             @SuppressWarnings("unchecked")

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -548,8 +548,8 @@ public void onNext(String outputMessage) {
             // sentEvents will go until 'eventCounter' hits 20 and then unsubscribes
             // which means it will also send (but ignore) the 19/20 events for the other group
             // It will not however send all 100 events.
-            assertEquals(39, sentEventCounter.get(), 2);
-            // gave it a delta of 2 so the threading/unsubscription race has wiggle 
+            assertEquals(39, sentEventCounter.get(), 10);
+            // gave it a delta of 10 to account for the threading/unsubscription race condition which can vary depending on a machines performance, thread-scheduler, etc
         }
 
         private static class Event {

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -548,8 +548,8 @@ public void onNext(String outputMessage) {
             // sentEvents will go until 'eventCounter' hits 20 and then unsubscribes
             // which means it will also send (but ignore) the 19/20 events for the other group
             // It will not however send all 100 events.
-            assertEquals(39, sentEventCounter.get(), 2);
-            // gave it a delta of 2 so the threading/unsubscription race has wiggle 
+            assertEquals(39, sentEventCounter.get(), 10);
+            // gave it a delta of 10 to account for the threading/unsubscription race condition which can vary depending on a machines performance, thread-scheduler, etc
         }
 
         private static class Event {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -574,7 +574,7 @@ public static Observable<Integer> range(int start, int count) {
      * @return an Observable whose {@link Observer}s trigger an invocation of the given Observable
      *         factory function
      */
-    public static <T> Observable<T> defer(Func0<Observable<T>> observableFactory) {
+    public static <T> Observable<T> defer(Func0<? extends Observable<T>> observableFactory) {
         return create(OperationDefer.defer(observableFactory));
     }
 
@@ -1074,7 +1074,7 @@ public static <R, T0, T1, T2, T3> Observable<R> combineLatest(Observable<T0> w0,
      *         An {@link Observable} which produces connected non-overlapping buffers, which are emitted
      *         when the current {@link Observable} created with the {@link Func0} argument produces a {@link BufferClosing} object.
      */
-    public Observable<List<T>> buffer(Func0<Observable<BufferClosing>> bufferClosingSelector) {
+    public Observable<List<T>> buffer(Func0<? extends Observable<BufferClosing>> bufferClosingSelector) {
         return create(OperationBuffer.buffer(this, bufferClosingSelector));
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationBuffer.java
Patch:
@@ -69,7 +69,7 @@ public final class OperationBuffer {
      * @return
      *            the {@link Func1} object representing the specified buffer operation.
      */
-    public static <T> Func1<Observer<List<T>>, Subscription> buffer(final Observable<T> source, final Func0<Observable<BufferClosing>> bufferClosingSelector) {
+    public static <T> Func1<Observer<List<T>>, Subscription> buffer(final Observable<T> source, final Func0<? extends Observable<BufferClosing>> bufferClosingSelector) {
         return new Func1<Observer<List<T>>, Subscription>() {
             @Override
             public Subscription call(final Observer<List<T>> observer) {
@@ -444,10 +444,10 @@ public void stop() {
     private static class ObservableBasedSingleBufferCreator<T> implements BufferCreator<T> {
 
         private final SafeObservableSubscription subscription = new SafeObservableSubscription();
-        private final Func0<Observable<BufferClosing>> bufferClosingSelector;
+        private final Func0<? extends Observable<BufferClosing>> bufferClosingSelector;
         private final NonOverlappingBuffers<T> buffers;
 
-        public ObservableBasedSingleBufferCreator(NonOverlappingBuffers<T> buffers, Func0<Observable<BufferClosing>> bufferClosingSelector) {
+        public ObservableBasedSingleBufferCreator(NonOverlappingBuffers<T> buffers, Func0<? extends Observable<BufferClosing>> bufferClosingSelector) {
             this.buffers = buffers;
             this.bufferClosingSelector = bufferClosingSelector;
 

File: rxjava-core/src/main/java/rx/operators/OperationDefer.java
Patch:
@@ -37,7 +37,7 @@
  */
 public final class OperationDefer {
 
-    public static <T> Func1<Observer<T>, Subscription> defer(final Func0<Observable<T>> observableFactory) {
+    public static <T> Func1<Observer<T>, Subscription> defer(final Func0<? extends Observable<T>> observableFactory) {
 
         return new Func1<Observer<T>, Subscription>() {
             @Override

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -132,6 +132,7 @@ public static class UnitTest {
         public void testNeverCompleted() {
         	AsyncSubject<String> subject = AsyncSubject.create();
 
+            @SuppressWarnings("unchecked")
             Observer<String> aObserver = mock(Observer.class);
             subject.subscribe(aObserver);
 
@@ -153,6 +154,7 @@ private void assertNeverCompletedObserver(Observer<String> aObserver)
         public void testCompleted() {
         	AsyncSubject<String> subject = AsyncSubject.create();
 
+            @SuppressWarnings("unchecked")
             Observer<String> aObserver = mock(Observer.class);
             subject.subscribe(aObserver);
 
@@ -175,6 +177,7 @@ private void assertCompletedObserver(Observer<String> aObserver)
         public void testError() {
         	AsyncSubject<String> subject = AsyncSubject.create();
 
+            @SuppressWarnings("unchecked")
             Observer<String> aObserver = mock(Observer.class);
             subject.subscribe(aObserver);
 

File: rxjava-core/src/main/java/rx/subjects/UnsubscribeTester.java
Patch:
@@ -54,7 +54,7 @@ public UnsubscribeTester() {
      * @param <T>
      *            The type of object passed by the Observable
      */
-    public static <T, O extends Observable<T>> void test(Func0<O> provider, Action1<? super O> generateOnCompleted, Action1<? super O> generateOnError, Action1<? super O> generateOnNext)
+    public static <T, O extends Observable<T>> void test(Func0<? extends O> provider, Action1<? super O> generateOnCompleted, Action1<? super O> generateOnError, Action1<? super O> generateOnNext)
     {
         if (generateOnCompleted != null) {
             O observable = provider.call();

File: rxjava-core/src/main/java/rx/util/functions/Action.java
Patch:
@@ -20,6 +20,6 @@
  * <p>
  * Marker interface to allow instanceof checks.
  */
-public interface Action extends Function {
+public interface Action extends Function<Void> {
 
 }

File: rxjava-core/src/main/java/rx/util/functions/Action0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action0 extends Function, Action {
+public interface Action0 extends Action {
     public void call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Action1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action1<T1> extends Function, Action {
+public interface Action1<T1> extends Action {
     public void call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Action2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action2<T1, T2> extends Function, Action {
+public interface Action2<T1, T2> extends Action {
     public void call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Action3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action3<T1, T2, T3> extends Function, Action {
+public interface Action3<T1, T2, T3> extends Action {
     public void call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func0<R> extends Function {
+public interface Func0<R> extends Function<R> {
     public R call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func1<T1, R> extends Function {
+public interface Func1<T1, R> extends Function<R> {
     public R call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func2<T1, T2, R> extends Function {
+public interface Func2<T1, T2, R> extends Function<R> {
     public R call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func3<T1, T2, T3, R> extends Function {
+public interface Func3<T1, T2, T3, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func4.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func4<T1, T2, T3, T4, R> extends Function {
+public interface Func4<T1, T2, T3, T4, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func5.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func5<T1, T2, T3, T4, T5, R> extends Function {
+public interface Func5<T1, T2, T3, T4, T5, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func6.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func6<T1, T2, T3, T4, T5, T6, R> extends Function {
+public interface Func6<T1, T2, T3, T4, T5, T6, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func7.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func7<T1, T2, T3, T4, T5, T6, T7, R> extends Function {
+public interface Func7<T1, T2, T3, T4, T5, T6, T7, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func8.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends Function {
+public interface Func8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Func9.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends Function {
+public interface Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends Function<R> {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/FuncN.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface FuncN<R> extends Function {
+public interface FuncN<R> extends Function<R> {
     public R call(Object... args);
 }

File: rxjava-core/src/main/java/rx/util/functions/Function.java
Patch:
@@ -20,6 +20,6 @@
  * <p>
  * Marker interface to allow instanceof checks.
  */
-public interface Function {
+public interface Function<T> {
 
 }

File: rxjava-core/src/main/java/rx/util/functions/Action.java
Patch:
@@ -5,6 +5,6 @@
  * <p>
  * Marker interface to allow instanceof checks.
  */
-public interface Action {
+public interface Action extends Function {
 
 }

File: rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java
Patch:
@@ -26,7 +26,6 @@
 import javax.swing.AbstractButton;
 
 import rx.Observable;
-import static rx.Observable.filter;
 import rx.swing.sources.AbstractButtonSource;
 import rx.swing.sources.ComponentEventSource;
 import rx.swing.sources.KeyEventSource;
@@ -68,7 +67,7 @@ public static Observable<KeyEvent> fromKeyEvents(Component component) {
      * @return Observable of key events.
      */
     public static Observable<KeyEvent> fromKeyEvents(Component component, final Set<Integer> keyCodes) {
-        return filter(fromKeyEvents(component), new Func1<KeyEvent, Boolean>() {
+        return fromKeyEvents(component).filter(new Func1<KeyEvent, Boolean>() {
             @Override
             public Boolean call(KeyEvent event) {
                 return keyCodes.contains(event.getKeyCode());

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java
Patch:
@@ -85,7 +85,7 @@ public void call() {
      * @see SwingObservable.fromKeyEvents(Component, Set)
      */
     public static Observable<Set<Integer>> currentlyPressedKeysOf(Component component) {
-        return Observable.<KeyEvent, Set<Integer>>scan(fromKeyEventsOf(component), new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {
+        return fromKeyEventsOf(component).<Set<Integer>>scan(new HashSet<Integer>(), new Func2<Set<Integer>, KeyEvent, Set<Integer>>() {
             @Override
             public Set<Integer> call(Set<Integer> pressedKeys, KeyEvent event) {
                 Set<Integer> afterEvent = new HashSet<Integer>(pressedKeys);

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -92,7 +92,7 @@ public static class UnitTest {
         @SuppressWarnings("unchecked")
         public void testDematerialize1() {
             Observable<Notification<Integer>> notifications = Observable.from(1, 2).materialize();
-            Observable<Integer> dematerialize = Observable.dematerialize(notifications);
+            Observable<Integer> dematerialize = notifications.dematerialize();
 
             Observer<Integer> aObserver = mock(Observer.class);
             dematerialize.subscribe(aObserver);

File: rxjava-core/src/main/java/rx/operators/OperationToIterator.java
Patch:
@@ -49,10 +49,10 @@ public class OperationToIterator {
      *            the type of source.
      * @return the iterator that could be used to iterate over the elements of the observable.
      */
-    public static <T> Iterator<T> toIterator(Observable<T> that) {
+    public static <T> Iterator<T> toIterator(Observable<T> source) {
         final BlockingQueue<Notification<T>> notifications = new LinkedBlockingQueue<Notification<T>>();
 
-        Observable.materialize(that).subscribe(new Observer<Notification<T>>() {
+        source.materialize().subscribe(new Observer<Notification<T>>() {
             @Override
             public void onCompleted() {
                 // ignore

File: rxjava-core/src/main/java/rx/util/functions/Action0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action0 extends Function {
+public interface Action0 extends Function, Action {
     public void call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Action1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action1<T1> extends Function {
+public interface Action1<T1> extends Function, Action {
     public void call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Action2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action2<T1, T2> extends Function {
+public interface Action2<T1, T2> extends Function, Action {
     public void call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Action3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util.functions;
 
-public interface Action3<T1, T2, T3> extends Function {
+public interface Action3<T1, T2, T3> extends Function, Action {
     public void call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/functions/Function.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * All Func and Action interfaces extend from this.
  * <p>
- * Marker interface to allow isntanceof checks.
+ * Marker interface to allow instanceof checks.
  */
 public interface Function {
 

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -92,7 +92,7 @@ public static class UnitTest {
         @SuppressWarnings("unchecked")
         public void testDematerialize1() {
             Observable<Notification<Integer>> notifications = Observable.from(1, 2).materialize();
-            Observable<Integer> dematerialize = Observable.dematerialize(notifications);
+            Observable<Integer> dematerialize = notifications.dematerialize();
 
             Observer<Integer> aObserver = mock(Observer.class);
             dematerialize.subscribe(aObserver);

File: rxjava-core/src/main/java/rx/operators/OperationToIterator.java
Patch:
@@ -49,10 +49,10 @@ public class OperationToIterator {
      *            the type of source.
      * @return the iterator that could be used to iterate over the elements of the observable.
      */
-    public static <T> Iterator<T> toIterator(Observable<T> that) {
+    public static <T> Iterator<T> toIterator(Observable<T> source) {
         final BlockingQueue<Notification<T>> notifications = new LinkedBlockingQueue<Notification<T>>();
 
-        Observable.materialize(that).subscribe(new Observer<Notification<T>>() {
+        source.materialize().subscribe(new Observer<Notification<T>>() {
             @Override
             public void onCompleted() {
                 // ignore

File: rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java
Patch:
@@ -15,8 +15,6 @@
  */
 package rx.observables;
 
-import static rx.Observable.filter;
-
 import java.awt.Component;
 import java.awt.Dimension;
 import java.awt.event.ActionEvent;

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java
Patch:
@@ -69,7 +69,7 @@ public void testObservingActionEvents() {
             @SuppressWarnings("unchecked")
             Action1<ActionEvent> action = mock(Action1.class);
             @SuppressWarnings("unchecked")
-            Action1<Exception> error = mock(Action1.class);
+            Action1<Throwable> error = mock(Action1.class);
             Action0 complete = mock(Action0.class);
             
             final ActionEvent event = new ActionEvent(this, 1, "command");
@@ -85,7 +85,7 @@ void testAction() {
             Subscription sub = fromActionOf(button).subscribe(action, error, complete);
             
             verify(action, never()).call(Matchers.<ActionEvent>any());
-            verify(error, never()).call(Matchers.<Exception>any());
+            verify(error, never()).call(Matchers.<Throwable>any());
             verify(complete, never()).call();
             
             button.testAction();
@@ -97,7 +97,7 @@ void testAction() {
             sub.unsubscribe();
             button.testAction();
             verify(action, times(2)).call(Matchers.<ActionEvent>any());
-            verify(error, never()).call(Matchers.<Exception>any());
+            verify(error, never()).call(Matchers.<Throwable>any());
             verify(complete, never()).call();
         }
     }

File: rxjava-core/src/main/java/rx/Observer.java
Patch:
@@ -42,7 +42,7 @@ public interface Observer<T> {
      *
      * @param e
      */
-    public void onError(Exception e);
+    public void onError(Throwable e);
 
     /**
      * Provides the Observer with new data.

File: rxjava-core/src/main/java/rx/operators/OperationAll.java
Patch:
@@ -61,7 +61,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 underlying.onError(e);
             }
 
@@ -139,7 +139,7 @@ public Boolean call(String s) {
         @Test
         @SuppressWarnings("unchecked")
         public void testError() {
-            Exception error = new Exception();
+            Throwable error = new Throwable();
             Observable<String> obs = Observable.error(error);
 
             Observer<Boolean> observer = mock(Observer.class);

File: rxjava-core/src/main/java/rx/operators/OperationDefer.java
Patch:
@@ -52,7 +52,7 @@ public Subscription call(Observer<T> observer) {
     public static class UnitTest {
         @Test
         @SuppressWarnings("unchecked")
-        public void testDefer() throws Exception {
+        public void testDefer() throws Throwable {
 
             Func0<Observable<String>> factory = mock(Func0.class);
 

File: rxjava-core/src/main/java/rx/operators/OperationFilter.java
Patch:
@@ -55,14 +55,14 @@ public void onNext(T value) {
                         if (predicate.call(value)) {
                             observer.onNext(value);
                         }
-                    } catch (Exception ex) {
+                    } catch (Throwable ex) {
                         observer.onError(ex);
                         // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable
                         subscription.unsubscribe();
                     }
                 }
 
-                public void onError(Exception ex) {
+                public void onError(Throwable ex) {
                     observer.onError(ex);
                 }
 
@@ -93,7 +93,7 @@ public Boolean call(String t1) {
             verify(aObserver, Mockito.never()).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, Mockito.never()).onNext("three");
-            verify(aObserver, Mockito.never()).onError(any(Exception.class));
+            verify(aObserver, Mockito.never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperationFinally.java
Patch:
@@ -91,7 +91,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 try {
                     observer.onError(e);
                 } finally {

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -106,7 +106,7 @@ public void testInterval() {
             
             verify(observer, never()).onNext(0L);
             verify(observer, never()).onCompleted();
-            verify(observer, never()).onError(any(Exception.class));
+            verify(observer, never()).onError(any(Throwable.class));
             
             scheduler.advanceTimeTo(2, TimeUnit.SECONDS);
 
@@ -115,13 +115,13 @@ public void testInterval() {
             inOrder.verify(observer, times(1)).onNext(1L);
             inOrder.verify(observer, never()).onNext(2L);
             verify(observer, never()).onCompleted();
-            verify(observer, never()).onError(any(Exception.class));
+            verify(observer, never()).onError(any(Throwable.class));
             
             sub.unsubscribe();
             scheduler.advanceTimeTo(4, TimeUnit.SECONDS);
             verify(observer, never()).onNext(2L);
             verify(observer, times(1)).onCompleted();
-            verify(observer, never()).onError(any(Exception.class));
+            verify(observer, never()).onError(any(Throwable.class));
         }
     }
 }

File: rxjava-core/src/main/java/rx/operators/OperationMulticast.java
Patch:
@@ -60,7 +60,7 @@ public void onCompleted() {
                         }
 
                         @Override
-                        public void onError(Exception e) {
+                        public void onError(Throwable e) {
                             subject.onError(e);
                         }
 
@@ -185,7 +185,7 @@ public void onCompleted() {
                 }
 
                 @Override
-                public void onError(Exception e) {
+                public void onError(Throwable e) {
                     // Do nothing
                 }
 
@@ -204,7 +204,7 @@ public void onCompleted() {
                         }
 
                         @Override
-                        public void onError(Exception e) {
+                        public void onError(Throwable e) {
                             // Do nothing
                         }
 

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -97,7 +97,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 observer.onError(e);
             }
 
@@ -126,7 +126,7 @@ public void testSkip1() {
             verify(aObserver, never()).onNext("one");
             verify(aObserver, never()).onNext("two");
             verify(aObserver, times(1)).onNext("three");
-            verify(aObserver, never()).onError(any(Exception.class));
+            verify(aObserver, never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
 
@@ -141,7 +141,7 @@ public void testSkip2() {
             verify(aObserver, never()).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, times(1)).onNext("three");
-            verify(aObserver, never()).onError(any(Exception.class));
+            verify(aObserver, never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
 

File: rxjava-core/src/main/java/rx/operators/OperationToFuture.java
Patch:
@@ -41,7 +41,7 @@ public static <T> Future<T> toFuture(Observable<T> that) {
 
         final CountDownLatch finished = new CountDownLatch(1);
         final AtomicReference<T> value = new AtomicReference<T>();
-        final AtomicReference<Exception> error = new AtomicReference<Exception>();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
 
         final Subscription s = that.subscribe(new Observer<T>() {
 
@@ -51,7 +51,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 error.compareAndSet(null, e);
                 finished.countDown();
             }
@@ -161,7 +161,7 @@ public Subscription call(Observer<String> observer) {
         try {
             f.get();
             fail("expected exception");
-        } catch (Exception e) {
+        } catch (Throwable e) {
             assertEquals(TestException.class, e.getCause().getClass());
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperationToIterator.java
Patch:
@@ -59,7 +59,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 // ignore
             }
 
@@ -86,7 +86,7 @@ public T next() {
                     buf = take();
                 }
                 if (buf.isOnError()) {
-                    throw Exceptions.propagate(buf.getException());
+                    throw Exceptions.propagate(buf.getThrowable());
                 }
 
                 T result = buf.getValue();

File: rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java
Patch:
@@ -50,7 +50,7 @@ public Subscription call(Observer<T> observer) {
                     observer.onNext(value);
                 }
                 observer.onCompleted();
-            } catch (Exception e) {
+            } catch (Throwable e) {
                 observer.onError(e);
             }
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java
Patch:
@@ -72,7 +72,7 @@ public void testIterable() {
             verify(aObserver, times(1)).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, times(1)).onNext("three");
-            verify(aObserver, Mockito.never()).onError(any(Exception.class));
+            verify(aObserver, Mockito.never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperationWhere.java
Patch:
@@ -58,7 +58,7 @@ public Boolean call(String t1) {
             verify(aObserver, Mockito.never()).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, Mockito.never()).onNext("three");
-            verify(aObserver, Mockito.never()).onError(any(Exception.class));
+            verify(aObserver, Mockito.never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
     }

File: rxjava-core/src/main/java/rx/operators/ScheduledObserver.java
Patch:
@@ -41,7 +41,7 @@ public void onCompleted() {
     }
 
     @Override
-    public void onError(final Exception e) {
+    public void onError(final Throwable e) {
         enqueue(new Notification<T>(e));
     }
 
@@ -73,7 +73,7 @@ public void call() {
                     underlying.onNext(not.getValue());
                     break;
                 case OnError:
-                    underlying.onError(not.getException());
+                    underlying.onError(not.getThrowable());
                     break;
                 case OnCompleted:
                     underlying.onCompleted();

File: rxjava-core/src/main/java/rx/subjects/UnsubscribeTester.java
Patch:
@@ -96,7 +96,7 @@ public void onCompleted()
             }
 
             @Override
-            public void onError(Exception e)
+            public void onError(Throwable e)
             {
                 test.gotEvent("onError");
             }
@@ -122,7 +122,7 @@ public void onCompleted()
             }
 
             @Override
-            public void onError(Exception e)
+            public void onError(Throwable e)
             {
                 test.doUnsubscribe("onError");
             }
@@ -148,7 +148,7 @@ public void onCompleted()
             }
 
             @Override
-            public void onError(Exception e)
+            public void onError(Throwable e)
             {
                 test.gotEvent("onError");
             }

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -69,13 +69,13 @@ public synchronized void add(Subscription s) {
     @Override
     public synchronized void unsubscribe() {
         if (unsubscribed.compareAndSet(false, true)) {
-            Collection<Exception> es = null;
+            Collection<Throwable> es = null;
             for (Subscription s : subscriptions) {
                 try {
                     s.unsubscribe();
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     if (es == null) {
-                        es = new ArrayList<Exception>();
+                        es = new ArrayList<Throwable>();
                     }
                     es.add(e);
                 }

File: rxjava-core/src/main/java/rx/util/OnErrorNotImplementedException.java
Patch:
@@ -3,7 +3,7 @@
 import rx.Observer;
 
 /**
- * Used for re-throwing {@link Observer#onError(Exception)} when an implementation doesn't exist.
+ * Used for re-throwing {@link Observer#onError(Throwable)} when an implementation doesn't exist.
  * 
  * https://github.com/Netflix/RxJava/issues/198
  * 

File: rxjava-core/src/main/java/rx/util/functions/Functions.java
Patch:
@@ -52,7 +52,7 @@ private static boolean loadLanguageAdaptor(String name) {
         } catch (ClassNotFoundException e) {
             System.err.println("RxJava => Could not find function language adaptor: " + name + " with path: " + className);
             return false;
-        } catch (Exception e) {
+        } catch (Throwable e) {
             System.err.println("RxJava => Failed trying to initialize function language adaptor: " + className);
             e.printStackTrace();
             return false;

File: rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java
Patch:
@@ -330,7 +330,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 System.out.println("Error");
             }
 
@@ -491,7 +491,7 @@ public Subscription call(final Observer<String> observer) {
     private static class ConcurrentObserverValidator<T> implements Observer<T> {
 
         final AtomicInteger concurrentCounter = new AtomicInteger();
-        final AtomicReference<Exception> error = new AtomicReference<Exception>();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
         final CountDownLatch completed = new CountDownLatch(1);
 
         @Override
@@ -500,7 +500,7 @@ public void onCompleted() {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onError(Throwable e) {
             completed.countDown();
             error.set(e);
         }

File: rxjava-core/src/test/java/rx/performance/PerformanceTest.java
Patch:
@@ -231,7 +231,7 @@ public void onNext(Integer i) {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onError(Throwable e) {
             e.printStackTrace();
         }
 
@@ -260,7 +260,7 @@ public void onNext(String i) {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onError(Throwable e) {
             e.printStackTrace();
         }
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -4895,7 +4895,7 @@ public Subscription call(final Observer<String> observer) {
                         @Override
                         public void run() {
                             try {
-                                observer.onError(new RuntimeException("failure"));
+                                observer.onError(new Error("failure"));
                             } catch (Throwable e) {
                                 // without an onError handler it has to just throw on whatever thread invokes it
                                 exception.set(e);

File: rxjava-core/src/main/java/rx/Observer.java
Patch:
@@ -42,7 +42,7 @@ public interface Observer<T> {
      *
      * @param e
      */
-    public void onError(Exception e);
+    public void onError(Throwable e);
 
     /**
      * Provides the Observer with new data.

File: rxjava-core/src/main/java/rx/operators/OperationAll.java
Patch:
@@ -61,7 +61,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 underlying.onError(e);
             }
 
@@ -139,7 +139,7 @@ public Boolean call(String s) {
         @Test
         @SuppressWarnings("unchecked")
         public void testError() {
-            Exception error = new Exception();
+            Throwable error = new Throwable();
             Observable<String> obs = Observable.error(error);
 
             Observer<Boolean> observer = mock(Observer.class);

File: rxjava-core/src/main/java/rx/operators/OperationDefer.java
Patch:
@@ -52,7 +52,7 @@ public Subscription call(Observer<T> observer) {
     public static class UnitTest {
         @Test
         @SuppressWarnings("unchecked")
-        public void testDefer() throws Exception {
+        public void testDefer() throws Throwable {
 
             Func0<Observable<String>> factory = mock(Func0.class);
 

File: rxjava-core/src/main/java/rx/operators/OperationFilter.java
Patch:
@@ -55,14 +55,14 @@ public void onNext(T value) {
                         if (predicate.call(value)) {
                             observer.onNext(value);
                         }
-                    } catch (Exception ex) {
+                    } catch (Throwable ex) {
                         observer.onError(ex);
                         // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable
                         subscription.unsubscribe();
                     }
                 }
 
-                public void onError(Exception ex) {
+                public void onError(Throwable ex) {
                     observer.onError(ex);
                 }
 
@@ -93,7 +93,7 @@ public Boolean call(String t1) {
             verify(aObserver, Mockito.never()).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, Mockito.never()).onNext("three");
-            verify(aObserver, Mockito.never()).onError(any(Exception.class));
+            verify(aObserver, Mockito.never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperationFinally.java
Patch:
@@ -91,7 +91,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 try {
                     observer.onError(e);
                 } finally {

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -106,7 +106,7 @@ public void testInterval() {
             
             verify(observer, never()).onNext(0L);
             verify(observer, never()).onCompleted();
-            verify(observer, never()).onError(any(Exception.class));
+            verify(observer, never()).onError(any(Throwable.class));
             
             scheduler.advanceTimeTo(2, TimeUnit.SECONDS);
 
@@ -115,13 +115,13 @@ public void testInterval() {
             inOrder.verify(observer, times(1)).onNext(1L);
             inOrder.verify(observer, never()).onNext(2L);
             verify(observer, never()).onCompleted();
-            verify(observer, never()).onError(any(Exception.class));
+            verify(observer, never()).onError(any(Throwable.class));
             
             sub.unsubscribe();
             scheduler.advanceTimeTo(4, TimeUnit.SECONDS);
             verify(observer, never()).onNext(2L);
             verify(observer, times(1)).onCompleted();
-            verify(observer, never()).onError(any(Exception.class));
+            verify(observer, never()).onError(any(Throwable.class));
         }
     }
 }

File: rxjava-core/src/main/java/rx/operators/OperationMulticast.java
Patch:
@@ -60,7 +60,7 @@ public void onCompleted() {
                         }
 
                         @Override
-                        public void onError(Exception e) {
+                        public void onError(Throwable e) {
                             subject.onError(e);
                         }
 
@@ -185,7 +185,7 @@ public void onCompleted() {
                 }
 
                 @Override
-                public void onError(Exception e) {
+                public void onError(Throwable e) {
                     // Do nothing
                 }
 
@@ -204,7 +204,7 @@ public void onCompleted() {
                         }
 
                         @Override
-                        public void onError(Exception e) {
+                        public void onError(Throwable e) {
                             // Do nothing
                         }
 

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -97,7 +97,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 observer.onError(e);
             }
 
@@ -126,7 +126,7 @@ public void testSkip1() {
             verify(aObserver, never()).onNext("one");
             verify(aObserver, never()).onNext("two");
             verify(aObserver, times(1)).onNext("three");
-            verify(aObserver, never()).onError(any(Exception.class));
+            verify(aObserver, never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
 
@@ -141,7 +141,7 @@ public void testSkip2() {
             verify(aObserver, never()).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, times(1)).onNext("three");
-            verify(aObserver, never()).onError(any(Exception.class));
+            verify(aObserver, never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
 

File: rxjava-core/src/main/java/rx/operators/OperationToFuture.java
Patch:
@@ -41,7 +41,7 @@ public static <T> Future<T> toFuture(Observable<T> that) {
 
         final CountDownLatch finished = new CountDownLatch(1);
         final AtomicReference<T> value = new AtomicReference<T>();
-        final AtomicReference<Exception> error = new AtomicReference<Exception>();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
 
         final Subscription s = that.subscribe(new Observer<T>() {
 
@@ -51,7 +51,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 error.compareAndSet(null, e);
                 finished.countDown();
             }
@@ -161,7 +161,7 @@ public Subscription call(Observer<String> observer) {
         try {
             f.get();
             fail("expected exception");
-        } catch (Exception e) {
+        } catch (Throwable e) {
             assertEquals(TestException.class, e.getCause().getClass());
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperationToIterator.java
Patch:
@@ -59,7 +59,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 // ignore
             }
 
@@ -86,7 +86,7 @@ public T next() {
                     buf = take();
                 }
                 if (buf.isOnError()) {
-                    throw Exceptions.propagate(buf.getException());
+                    throw Exceptions.propagate(buf.getThrowable());
                 }
 
                 T result = buf.getValue();

File: rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java
Patch:
@@ -50,7 +50,7 @@ public Subscription call(Observer<T> observer) {
                     observer.onNext(value);
                 }
                 observer.onCompleted();
-            } catch (Exception e) {
+            } catch (Throwable e) {
                 observer.onError(e);
             }
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java
Patch:
@@ -72,7 +72,7 @@ public void testIterable() {
             verify(aObserver, times(1)).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, times(1)).onNext("three");
-            verify(aObserver, Mockito.never()).onError(any(Exception.class));
+            verify(aObserver, Mockito.never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
     }

File: rxjava-core/src/main/java/rx/operators/OperationWhere.java
Patch:
@@ -58,7 +58,7 @@ public Boolean call(String t1) {
             verify(aObserver, Mockito.never()).onNext("one");
             verify(aObserver, times(1)).onNext("two");
             verify(aObserver, Mockito.never()).onNext("three");
-            verify(aObserver, Mockito.never()).onError(any(Exception.class));
+            verify(aObserver, Mockito.never()).onError(any(Throwable.class));
             verify(aObserver, times(1)).onCompleted();
         }
     }

File: rxjava-core/src/main/java/rx/operators/ScheduledObserver.java
Patch:
@@ -41,7 +41,7 @@ public void onCompleted() {
     }
 
     @Override
-    public void onError(final Exception e) {
+    public void onError(final Throwable e) {
         enqueue(new Notification<T>(e));
     }
 
@@ -73,7 +73,7 @@ public void call() {
                     underlying.onNext(not.getValue());
                     break;
                 case OnError:
-                    underlying.onError(not.getException());
+                    underlying.onError(not.getThrowable());
                     break;
                 case OnCompleted:
                     underlying.onCompleted();

File: rxjava-core/src/main/java/rx/subjects/UnsubscribeTester.java
Patch:
@@ -96,7 +96,7 @@ public void onCompleted()
             }
 
             @Override
-            public void onError(Exception e)
+            public void onError(Throwable e)
             {
                 test.gotEvent("onError");
             }
@@ -122,7 +122,7 @@ public void onCompleted()
             }
 
             @Override
-            public void onError(Exception e)
+            public void onError(Throwable e)
             {
                 test.doUnsubscribe("onError");
             }
@@ -148,7 +148,7 @@ public void onCompleted()
             }
 
             @Override
-            public void onError(Exception e)
+            public void onError(Throwable e)
             {
                 test.gotEvent("onError");
             }

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -69,13 +69,13 @@ public synchronized void add(Subscription s) {
     @Override
     public synchronized void unsubscribe() {
         if (unsubscribed.compareAndSet(false, true)) {
-            Collection<Exception> es = null;
+            Collection<Throwable> es = null;
             for (Subscription s : subscriptions) {
                 try {
                     s.unsubscribe();
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     if (es == null) {
-                        es = new ArrayList<Exception>();
+                        es = new ArrayList<Throwable>();
                     }
                     es.add(e);
                 }

File: rxjava-core/src/main/java/rx/util/OnErrorNotImplementedException.java
Patch:
@@ -3,7 +3,7 @@
 import rx.Observer;
 
 /**
- * Used for re-throwing {@link Observer#onError(Exception)} when an implementation doesn't exist.
+ * Used for re-throwing {@link Observer#onError(Throwable)} when an implementation doesn't exist.
  * 
  * https://github.com/Netflix/RxJava/issues/198
  * 

File: rxjava-core/src/main/java/rx/util/functions/Functions.java
Patch:
@@ -52,7 +52,7 @@ private static boolean loadLanguageAdaptor(String name) {
         } catch (ClassNotFoundException e) {
             System.err.println("RxJava => Could not find function language adaptor: " + name + " with path: " + className);
             return false;
-        } catch (Exception e) {
+        } catch (Throwable e) {
             System.err.println("RxJava => Failed trying to initialize function language adaptor: " + className);
             e.printStackTrace();
             return false;

File: rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java
Patch:
@@ -330,7 +330,7 @@ public void onCompleted() {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onError(Throwable e) {
                 System.out.println("Error");
             }
 
@@ -491,7 +491,7 @@ public Subscription call(final Observer<String> observer) {
     private static class ConcurrentObserverValidator<T> implements Observer<T> {
 
         final AtomicInteger concurrentCounter = new AtomicInteger();
-        final AtomicReference<Exception> error = new AtomicReference<Exception>();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
         final CountDownLatch completed = new CountDownLatch(1);
 
         @Override
@@ -500,7 +500,7 @@ public void onCompleted() {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onError(Throwable e) {
             completed.countDown();
             error.set(e);
         }

File: rxjava-core/src/test/java/rx/performance/PerformanceTest.java
Patch:
@@ -231,7 +231,7 @@ public void onNext(Integer i) {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onError(Throwable e) {
             e.printStackTrace();
         }
 
@@ -260,7 +260,7 @@ public void onNext(String i) {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onError(Throwable e) {
             e.printStackTrace();
         }
 

File: rxjava-core/src/main/java/rx/concurrency/DiscardableAction.java
Patch:
@@ -19,7 +19,7 @@
 
 import rx.Scheduler;
 import rx.Subscription;
-import rx.operators.AtomicObservableSubscription;
+import rx.operators.SafeObservableSubscription;
 import rx.util.functions.Func1;
 import rx.util.functions.Func2;
 
@@ -30,7 +30,7 @@
     private final Func2<Scheduler, T, Subscription> underlying;
     private final T state;
 
-    private final AtomicObservableSubscription wrapper = new AtomicObservableSubscription();
+    private final SafeObservableSubscription wrapper = new SafeObservableSubscription();
     private final AtomicBoolean ready = new AtomicBoolean(true);
 
     public DiscardableAction(T state, Func2<Scheduler, T, Subscription> underlying) {

File: rxjava-core/src/main/java/rx/concurrency/NewThreadScheduler.java
Patch:
@@ -20,7 +20,7 @@
 
 import rx.Scheduler;
 import rx.Subscription;
-import rx.operators.AtomicObservableSubscription;
+import rx.operators.SafeObservableSubscription;
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func2;
@@ -37,7 +37,7 @@ public static NewThreadScheduler getInstance() {
 
     @Override
     public <T> Subscription schedule(final T state, final Func2<Scheduler, T, Subscription> action) {
-        final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        final SafeObservableSubscription subscription = new SafeObservableSubscription();
         final Scheduler _scheduler = this;
 
         Thread t = new Thread(new Runnable() {

File: rxjava-core/src/main/java/rx/operators/OperationAll.java
Patch:
@@ -28,7 +28,7 @@ private static class AllObservable<T> implements Func1<Observer<Boolean>, Subscr
         private final Observable<T> sequence;
         private final Func1<T, Boolean> predicate;
 
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
 
         private AllObservable(Observable<T> sequence, Func1<T, Boolean> predicate) {

File: rxjava-core/src/main/java/rx/operators/OperationBuffer.java
Patch:
@@ -443,7 +443,7 @@ public void stop() {
      */
     private static class ObservableBasedSingleBufferCreator<T> implements BufferCreator<T> {
 
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
         private final Func0<Observable<BufferClosing>> bufferClosingSelector;
         private final NonOverlappingBuffers<T> buffers;
 
@@ -487,7 +487,7 @@ public void stop() {
      */
     private static class ObservableBasedMultiBufferCreator<T> implements BufferCreator<T> {
 
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
         public ObservableBasedMultiBufferCreator(final OverlappingBuffers<T> buffers, Observable<BufferOpening> bufferOpenings, final Func1<BufferOpening, Observable<BufferClosing>> bufferClosingSelector) {
             subscription.wrap(bufferOpenings.subscribe(new Action1<BufferOpening>() {
@@ -525,7 +525,7 @@ public void stop() {
      */
     private static class TimeBasedBufferCreator<T> implements BufferCreator<T> {
 
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
         public TimeBasedBufferCreator(final NonOverlappingBuffers<T> buffers, long time, TimeUnit unit, Scheduler scheduler) {
             this.subscription.wrap(scheduler.schedulePeriodically(new Action0() {

File: rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java
Patch:
@@ -237,7 +237,7 @@ public Subscription call(Observer<? super R> observer) {
                 throw new IllegalStateException("Only one Observer can subscribe to this Observable.");
             }
             
-            AtomicObservableSubscription subscription = new AtomicObservableSubscription(new Subscription() {
+            SafeObservableSubscription subscription = new SafeObservableSubscription(new Subscription() {
                 @Override
                 public void unsubscribe() {
                     stop();

File: rxjava-core/src/main/java/rx/operators/OperationFilter.java
Patch:
@@ -48,7 +48,7 @@ public Filter(Observable<T> that, Func1<T, Boolean> predicate) {
         }
 
         public Subscription call(final Observer<T> observer) {
-            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+            final SafeObservableSubscription subscription = new SafeObservableSubscription();
             return subscription.wrap(that.subscribe(new Observer<T>() {
                 public void onNext(T value) {
                     try {

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -71,7 +71,7 @@ private static class GroupBy<K, V> implements Func1<Observer<GroupedObservable<K
 
         private final Observable<KeyValue<K, V>> source;
         private final ConcurrentHashMap<K, GroupedSubject<K, V>> groupedObservables = new ConcurrentHashMap<K, GroupedSubject<K, V>>();
-        private final AtomicObservableSubscription actualParentSubscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription actualParentSubscription = new SafeObservableSubscription();
         private final AtomicInteger numGroupSubscriptions = new AtomicInteger();
         private final AtomicBoolean unsubscribeRequested = new AtomicBoolean(false);
 
@@ -178,7 +178,7 @@ static <K, T> GroupedSubject<K, T> create(final K key, final GroupBy<K, T> paren
 
             return new GroupedSubject<K, T>(key, new Func1<Observer<T>, Subscription>() {
 
-                private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+                private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
                 @Override
                 public Subscription call(Observer<T> observer) {

File: rxjava-core/src/main/java/rx/operators/OperationMerge.java
Patch:
@@ -133,7 +133,7 @@ public Subscription call(Observer<T> actualObserver) {
              * <p>
              * Bug report: https://github.com/Netflix/RxJava/issues/200
              */
-            AtomicObservableSubscription subscription = new AtomicObservableSubscription(ourSubscription);
+            SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);
             SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, subscription);
 
             /**

File: rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java
Patch:
@@ -64,10 +64,10 @@ public OnErrorReturn(Observable<T> originalSequence, Func1<Exception, T> resumeF
         }
 
         public Subscription call(final Observer<T> observer) {
-            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+            final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
             // AtomicReference since we'll be accessing/modifying this across threads so we can switch it if needed
-            final AtomicReference<AtomicObservableSubscription> subscriptionRef = new AtomicReference<AtomicObservableSubscription>(subscription);
+            final AtomicReference<SafeObservableSubscription> subscriptionRef = new AtomicReference<SafeObservableSubscription>(subscription);
 
             // subscribe to the original Observable and remember the subscription
             subscription.wrap(originalSequence.subscribe(new Observer<T>() {
@@ -81,7 +81,7 @@ public void onNext(T value) {
                  */
                 public void onError(Exception ex) {
                     /* remember what the current subscription is so we can determine if someone unsubscribes concurrently */
-                    AtomicObservableSubscription currentSubscription = subscriptionRef.get();
+                    SafeObservableSubscription currentSubscription = subscriptionRef.get();
                     // check that we have not been unsubscribed before we can process the error
                     if (currentSubscription != null) {
                         try {

File: rxjava-core/src/main/java/rx/operators/OperationSwitch.java
Patch:
@@ -69,7 +69,7 @@ public Switch(Observable<Observable<T>> sequences) {
 
         @Override
         public Subscription call(Observer<T> observer) {
-            AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+            SafeObservableSubscription subscription = new SafeObservableSubscription();
             subscription.wrap(sequences.subscribe(new SwitchObserver<T>(observer, subscription)));
             return subscription;
         }
@@ -78,10 +78,10 @@ public Subscription call(Observer<T> observer) {
     private static class SwitchObserver<T> implements Observer<Observable<T>> {
 
         private final Observer<T> observer;
-        private final AtomicObservableSubscription parent;
+        private final SafeObservableSubscription parent;
         private final AtomicReference<Subscription> subsequence = new AtomicReference<Subscription>();
 
-        public SwitchObserver(Observer<T> observer, AtomicObservableSubscription parent) {
+        public SwitchObserver(Observer<T> observer, SafeObservableSubscription parent) {
             this.observer = observer;
             this.parent = parent;
         }

File: rxjava-core/src/main/java/rx/operators/OperationSynchronize.java
Patch:
@@ -71,7 +71,7 @@ public Synchronize(Observable<T> innerObservable) {
         private SynchronizedObserver<T> atomicObserver;
 
         public Subscription call(Observer<T> observer) {
-            AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+            SafeObservableSubscription subscription = new SafeObservableSubscription();
             atomicObserver = new SynchronizedObserver<T>(observer, subscription);
             return subscription.wrap(innerObservable.subscribe(atomicObserver));
         }

File: rxjava-core/src/main/java/rx/operators/OperationTake.java
Patch:
@@ -77,7 +77,7 @@ public Subscription call(Observer<T> observer) {
     private static class Take<T> implements Func1<Observer<T>, Subscription> {
         private final Observable<T> items;
         private final int num;
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
         private Take(Observable<T> items, int num) {
             this.items = items;

File: rxjava-core/src/main/java/rx/operators/OperationTakeLast.java
Patch:
@@ -51,7 +51,7 @@ public Subscription call(Observer<T> observer) {
     private static class TakeLast<T> implements Func1<Observer<T>, Subscription> {
         private final int count;
         private final Observable<T> items;
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
         TakeLast(final Observable<T> items, final int count) {
             this.count = count;

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -95,7 +95,7 @@ public Boolean call(T input, Integer index) {
     private static class TakeWhile<T> implements Func1<Observer<T>, Subscription> {
         private final Observable<T> items;
         private final Func2<T, Integer, Boolean> predicate;
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
         private TakeWhile(Observable<T> items, Func2<T, Integer, Boolean> predicate) {
             this.items = items;
@@ -116,7 +116,7 @@ public ItemObserver(Observer<T> observer) {
                 // Using AtomicObserver because the unsubscribe, onCompleted, onError and error handling behavior
                 // needs "isFinished" logic to not send duplicated events
                 // The 'testTakeWhile1' and 'testTakeWhile2' tests fail without this.
-                this.observer = new AtomicObserver<T>(subscription, observer);
+                this.observer = new SafeObserver<T>(subscription, observer);
             }
 
             @Override

File: rxjava-core/src/main/java/rx/operators/OperationZip.java
Patch:
@@ -94,7 +94,7 @@ public static <R> Func1<Observer<R>, Subscription> zip(Collection<Observable<?>>
     private static class ZipObserver<R, T> implements Observer<T> {
         final Observable<T> w;
         final Aggregator<R> a;
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+        private final SafeObservableSubscription subscription = new SafeObservableSubscription();
         private final AtomicBoolean subscribed = new AtomicBoolean(false);
 
         public ZipObserver(Aggregator<R> a, Observable<T> w) {
@@ -246,7 +246,7 @@ void next(ZipObserver<T, ?> w, Object arg) {
         @Override
         public Subscription call(Observer<T> observer) {
             if (started.compareAndSet(false, true)) {
-                AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+                SafeObservableSubscription subscription = new SafeObservableSubscription();
                 this.observer = new SynchronizedObserver<T>(observer, subscription);
                 /* start the Observers */
                 for (ZipObserver<T, ?> rw : observers) {

File: rxjava-core/src/main/java/rx/operators/SafeObserver.java
Patch:
@@ -40,13 +40,13 @@
  * 
  * @param <T>
  */
-public class AtomicObserver<T> implements Observer<T> {
+public class SafeObserver<T> implements Observer<T> {
 
     private final Observer<T> actual;
     private final AtomicBoolean isFinished = new AtomicBoolean(false);
-    private final AtomicObservableSubscription subscription;
+    private final SafeObservableSubscription subscription;
 
-    public AtomicObserver(AtomicObservableSubscription subscription, Observer<T> actual) {
+    public SafeObserver(SafeObservableSubscription subscription, Observer<T> actual) {
         this.subscription = subscription;
         this.actual = actual;
     }

File: rxjava-core/src/main/java/rx/subjects/AsyncSubject.java
Patch:
@@ -26,7 +26,7 @@
 
 import rx.Observer;
 import rx.Subscription;
-import rx.operators.AtomicObservableSubscription;
+import rx.operators.SafeObservableSubscription;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
 import rx.util.functions.Func1;
@@ -73,7 +73,7 @@ public static <T> AsyncSubject<T> create() {
         Func1<Observer<T>, Subscription> onSubscribe = new Func1<Observer<T>, Subscription>() {
             @Override
             public Subscription call(Observer<T> observer) {
-                final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+                final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
                 subscription.wrap(new Subscription() {
                     @Override

File: rxjava-core/src/main/java/rx/subjects/BehaviorSubject.java
Patch:
@@ -26,7 +26,7 @@
 
 import rx.Observer;
 import rx.Subscription;
-import rx.operators.AtomicObservableSubscription;
+import rx.operators.SafeObservableSubscription;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
 import rx.util.functions.Func1;
@@ -77,7 +77,7 @@ public static <T> BehaviorSubject<T> createWithDefaultValue(T defaultValue) {
         Func1<Observer<T>, Subscription> onSubscribe = new Func1<Observer<T>, Subscription>() {
             @Override
             public Subscription call(Observer<T> observer) {
-                final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+                final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
                 subscription.wrap(new Subscription() {
                     @Override

File: rxjava-core/src/main/java/rx/subjects/PublishSubject.java
Patch:
@@ -37,7 +37,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
-import rx.operators.AtomicObservableSubscription;
+import rx.operators.SafeObservableSubscription;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Action1;
 import rx.util.functions.Func0;
@@ -77,7 +77,7 @@ public Subscription call(Observer<T> observer) {
                 Subscription s = checkTerminalState(observer);
                 if(s != null) return s;
 
-                final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
+                final SafeObservableSubscription subscription = new SafeObservableSubscription();
 
                 subscription.wrap(new Subscription() {
                     @Override

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -162,10 +162,10 @@ public void testEmpty() {
 
         private static <K, V> Map<K, List<V>> toMap(Observable<GroupedObservable<K, V>> observable) {
             Map<K, List<V>> result = new HashMap<K, List<V>>();
-            for (GroupedObservable<K, V> g : observable.toIterable()) {
+            for (GroupedObservable<K, V> g : observable.toBlockingObservable().toIterable()) {
                 K key = g.getKey();
 
-                for (V value : g.toIterable()) {
+                for (V value : g.toBlockingObservable().toIterable()) {
                     List<V> values = result.get(key);
                     if (values == null) {
                         values = new ArrayList<V>();

File: rxjava-core/src/main/java/rx/operators/OperationTake.java
Patch:
@@ -189,7 +189,7 @@ public Subscription call(Observer<String> observer)
                     return Subscriptions.empty();
                 }
             });
-            Observable.create(assertTrustedObservable(take(source, 1))).last();
+            Observable.create(assertTrustedObservable(take(source, 1))).toBlockingObservable().last();
         }
 
         @Test
@@ -213,7 +213,7 @@ public void unsubscribe()
                     };
                 }
             });
-            Observable.create(assertTrustedObservable(take(source, 0))).lastOrDefault("ok");
+            Observable.create(assertTrustedObservable(take(source, 0))).toBlockingObservable().lastOrDefault("ok");
             assertTrue("source subscribed", subscribed.get());
             assertTrue("source unsubscribed", unSubscribed.get());
         }

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -246,7 +246,7 @@ public Boolean call(String s)
                 {
                     return false;
                 }
-            })).last();
+            })).toBlockingObservable().last();
         }
 
         @Test

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/AbstractButtonSource.java
Patch:
@@ -39,7 +39,7 @@
 public enum AbstractButtonSource { ; // no instances
 
     /**
-     * @see SwingObservable.fromButtonAction
+     * @see rx.observables.SwingObservable#fromButtonAction
      */
     public static Observable<ActionEvent> fromActionOf(final AbstractButton button) {
         return Observable.create(new Func1<Observer<ActionEvent>, Subscription>() {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java
Patch:
@@ -33,7 +33,7 @@
 public enum ComponentEventSource { ; // no instances
 
     /**
-     * @see SwingObservable.fromComponentEvents
+     * @see rx.observables.SwingObservable#fromComponentEvents
      */
     public static Observable<ComponentEvent> fromComponentEventsOf(final Component component) {
         return Observable.create(new Func1<Observer<ComponentEvent>, Subscription>() {
@@ -73,7 +73,7 @@ public void call() {
     }
     
     /**
-     * @see SwingObservable.fromResizing
+     * @see SwingObservable#fromResizing
      */
     public static Observable<Dimension> fromResizing(final Component component) {
         return fromComponentEventsOf(component).filter(RESIZED).map(new Func1<ComponentEvent, Dimension>() {

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/KeyEventSource.java
Patch:
@@ -47,7 +47,7 @@
 public enum KeyEventSource { ; // no instances
 
     /**
-     * @see SwingObservable.fromKeyEvents(Component)
+     * @see rx.observables.SwingObservable#fromKeyEvents(Component)
      */
     public static Observable<KeyEvent> fromKeyEventsOf(final Component component) {
         return Observable.create(new Func1<Observer<KeyEvent>, Subscription>() {
@@ -82,7 +82,7 @@ public void call() {
     }
 
     /**
-     * @see SwingObservable.fromKeyEvents(Component, Set)
+     * @see rx.observables.SwingObservable#fromPressedKeys(Component)
      */
     public static Observable<Set<Integer>> currentlyPressedKeysOf(Component component) {
         class CollectKeys implements Func2<Set<Integer>, KeyEvent, Set<Integer>>{

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java
Patch:
@@ -30,7 +30,7 @@
 public enum MouseEventSource { ; // no instances
 
     /**
-     * @see SwingObservable.fromMouseEvents
+     * @see rx.observables.SwingObservable#fromMouseEvents
      */
     public static Observable<MouseEvent> fromMouseEventsOf(final Component component) {
         return Observable.create(new Func1<Observer<MouseEvent>, Subscription>() {
@@ -75,7 +75,7 @@ public void call() {
     }
     
     /**
-     * @see SwingObservable.fromMouseMotionEvents
+     * @see rx.observables.SwingObservable#fromMouseMotionEvents
      */
     public static Observable<MouseEvent> fromMouseMotionEventsOf(final Component component) {
         return Observable.create(new Func1<Observer<MouseEvent>, Subscription>() {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -2745,7 +2745,7 @@ public R call(T0 t0, T1 t1, T2 t2, T3 t3) {
      *          The first source observable.
      * @param w1 
      *          The second source observable.
-     * @param combineLatestFunction 
+     * @param combineFunction 
      *          The aggregation function used to combine the source observable values.
      * @return A function from an observer to a subscription. This can be used to create an observable from.
      */

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java
Patch:
@@ -103,6 +103,5 @@ private Predicate(int id) {
         public Boolean call(ComponentEvent event) {
             return event.getID() == id;
         }
-        
     }
 }

File: rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/ComponentEventSource.java
Patch:
@@ -87,7 +87,7 @@ public Dimension call(ComponentEvent event) {
     /**
      * Predicates that help with filtering observables for specific component events. 
      */
-    public enum Predicate implements Func1<ComponentEvent, Boolean> { 
+    public enum Predicate implements rx.util.functions.Func1<java.awt.event.ComponentEvent, Boolean> { 
         RESIZED(ComponentEvent.COMPONENT_RESIZED),
         HIDDEN(ComponentEvent.COMPONENT_HIDDEN),
         MOVED(ComponentEvent.COMPONENT_MOVED),

File: rxjava-core/src/main/java/rx/Notification.java
Patch:
@@ -96,9 +96,9 @@ public boolean hasException() {
     }
 
     /**
-     * The kind of notification: OnNext, OnError, OnCompleted
+     * Retrieves the kind of the notification: OnNext, OnError, OnCompleted
      * 
-     * @return
+     * @return the kind of the notification: OnNext, OnError, OnCompleted
      */
     public Kind getKind() {
         return kind;

File: rxjava-core/src/main/java/rx/concurrency/SleepingAction.java
Patch:
@@ -15,8 +15,6 @@
  */
 package rx.concurrency;
 
-import java.util.concurrent.TimeUnit;
-
 import rx.Scheduler;
 import rx.Subscription;
 import rx.util.functions.Func2;

File: rxjava-core/src/main/java/rx/observables/GroupedObservable.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * An {@link Observable} that has been grouped by a key whose value can be obtained using {@link #getKey()} <p>
  * 
- * @see {@link Observable#groupBy(Observable, Func1)}
+ * @see Observable#groupBy(Observable, Func1)
  * 
  * @param <K>
  * @param <T>

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
- * See http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx for the Microsoft Rx equivalent.
+ * See <a href="http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx">here</a> for the Microsoft Rx equivalent.
  */
 public final class OperationDematerialize {
 
@@ -38,7 +38,7 @@ public final class OperationDematerialize {
      * @param sequence
      *            An observable sequence containing explicit notification values which have to be turned into implicit notifications.
      * @return An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
-     * @see http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx">Observable.Dematerialize(TSource) Method </a>
      */
     public static <T> Func1<Observer<T>, Subscription> dematerialize(final Observable<Notification<T>> sequence) {
         return new DematerializeObservable<T>(sequence);

File: rxjava-core/src/main/java/rx/operators/OperationMaterialize.java
Patch:
@@ -33,17 +33,17 @@
  * <p>
  * In other words, converts a sequence of OnNext, OnError and OnCompleted events into a sequence of ObservableNotifications containing the OnNext, OnError and OnCompleted values.
  * <p>
- * See http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx for the Microsoft Rx equivalent.
+ * See <a href="http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx">here</a> for the Microsoft Rx equivalent.
  */
 public final class OperationMaterialize {
 
     /**
      * Materializes the implicit notifications of an observable sequence as explicit notification values.
      * 
-     * @param source
+     * @param sequence
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of materializing the notifications of the given sequence.
-     * @see http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx">Observable.Materialize(TSource) Method </a>
      */
     public static <T> Func1<Observer<Notification<T>>, Subscription> materialize(final Observable<T> sequence) {
         return new MaterializeObservable<T>(sequence);

File: rxjava-core/src/main/java/rx/operators/OperationMerge.java
Patch:
@@ -44,10 +44,10 @@ public final class OperationMerge {
     /**
      * Flattens the observable sequences from the list of Observables into one observable sequence without any transformation.
      * 
-     * @param source
+     * @param o
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of flattening the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">Observable.Merge(TSource) Method (IObservable(TSource)[])</a>
      */
     public static <T> Func1<Observer<T>, Subscription> merge(final Observable<Observable<T>> o) {
         // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -51,10 +51,10 @@ public final class OperationMergeDelayError {
      * onError or onComplete so as to allow all successful
      * onNext calls to be received.
      * 
-     * @param source
+     * @param sequences
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of flattening the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">Observable.Merge(TSource) Method (IObservable(TSource)[])</a>
      */
     public static <T> Func1<Observer<T>, Subscription> mergeDelayError(final Observable<Observable<T>> sequences) {
         // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/operators/OperationScan.java
Patch:
@@ -41,7 +41,7 @@ public final class OperationScan {
      *            An accumulator function to be invoked on each element from the sequence.
      * 
      * @return An observable sequence whose elements are the result of accumulating the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh212007%28v=vs.103%29.aspx">Observable.Scan(TSource, TAccumulate) Method (IObservable(TSource), TAccumulate, Func(TAccumulate, TSource, TAccumulate))</a>
      */
     public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence, T initialValue, Func2<T, T, T> accumulator) {
         return new Accumulator<T>(sequence, initialValue, accumulator);
@@ -56,7 +56,7 @@ public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence,
      *            An accumulator function to be invoked on each element from the sequence.
      * 
      * @return An observable sequence whose elements are the result of accumulating the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx">Observable.Scan(TSource) Method (IObservable(TSource), Func(TSource, TSource, TSource))</a>
      */
     public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence, Func2<T, T, T> accumulator) {
         return new Accumulator<T>(sequence, null, accumulator);

File: rxjava-core/src/main/java/rx/operators/OperationSynchronize.java
Patch:
@@ -52,7 +52,7 @@ public final class OperationSynchronize<T> {
      * 
      * @param observable
      * @param <T>
-     * @return
+     * @return the wrapped synchronized observable sequence
      */
     public static <T> Func1<Observer<T>, Subscription> synchronize(Observable<T> observable) {
         return new Synchronize<T>(observable);

File: rxjava-core/src/main/java/rx/operators/OperationTake.java
Patch:
@@ -42,7 +42,7 @@ public final class OperationTake {
      * 
      * @param items
      * @param num
-     * @return
+     * @return the specified number of contiguous values from the start of the given observable sequence
      */
     public static <T> Func1<Observer<T>, Subscription> take(final Observable<T> items, final int num) {
         // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -40,12 +40,12 @@
 public final class OperationTakeWhile {
 
     /**
-     * Returns a specified number of contiguous values from the start of an observable sequence.
+     * Returns values from an observable sequence as long as a specified condition is true, and then skips the remaining values.
      * 
      * @param items
      * @param predicate
      *            a function to test each source element for a condition
-     * @return
+     * @return sequence of observable values from the start as long as the predicate is true
      */
     public static <T> Func1<Observer<T>, Subscription> takeWhile(final Observable<T> items, final Func1<T, Boolean> predicate) {
         return takeWhileWithIndex(items, OperationTakeWhile.<T> skipIndex(predicate));
@@ -57,7 +57,7 @@ public static <T> Func1<Observer<T>, Subscription> takeWhile(final Observable<T>
      * @param items
      * @param predicate
      *            a function to test each element for a condition; the second parameter of the function represents the index of the source element; otherwise, false.
-     * @return
+     * @return sequence of observable values from the start as long as the predicate is true
      */
     public static <T> Func1<Observer<T>, Subscription> takeWhileWithIndex(final Observable<T> items, final Func2<T, Integer, Boolean> predicate) {
         // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/operators/OperationToObservableList.java
Patch:
@@ -104,6 +104,7 @@ public void testListMultipleObservers() {
             Observer<List<String>> o1 = mock(Observer.class);
             observable.subscribe(o1);
 
+            @SuppressWarnings("unchecked")
             Observer<List<String>> o2 = mock(Observer.class);
             observable.subscribe(o2);
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableSortedList.java
Patch:
@@ -47,7 +47,7 @@ public final class OperationToObservableSortedList<T> {
      * @param sequence
      * @throws ClassCastException
      *             if T objects do not implement Comparable
-     * @return
+     * @return an observable containing the sorted list
      */
     public static <T> Func1<Observer<List<T>>, Subscription> toSortedList(Observable<T> sequence) {
         return new ToObservableSortedList<T>(sequence);
@@ -58,7 +58,7 @@ public static <T> Func1<Observer<List<T>>, Subscription> toSortedList(Observable
      * 
      * @param sequence
      * @param sortFunction
-     * @return
+     * @return an observable containing the sorted list
      */
     public static <T> Func1<Observer<List<T>>, Subscription> toSortedList(Observable<T> sequence, Func2<T, T, Integer> sortFunction) {
         return new ToObservableSortedList<T>(sequence, sortFunction);

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -44,8 +44,8 @@ public abstract class RxJavaObservableExecutionHook {
      * @param observableInstance
      *            The executing {@link Observable} instance.
      * @param onSubscribe
-     *            original {@link Func1}<{@link Observer}{@code<T>}, {@link Subscription}> to be executed
-     * @return {@link Func1}<{@link Observer}{@code<T>}, {@link Subscription}> function that can be modified, decorated, replaced or just returned as a pass-thru.
+     *            original {@link Func1}<{@link Observer}{@code <T>}, {@link Subscription}> to be executed
+     * @return {@link Func1}<{@link Observer}{@code <T>}, {@link Subscription}> function that can be modified, decorated, replaced or just returned as a pass-thru.
      */
     public <T> Func1<Observer<T>, Subscription> onSubscribeStart(Observable<T> observableInstance, Func1<Observer<T>, Subscription> onSubscribe) {
         // pass-thru by default
@@ -72,7 +72,7 @@ public <T> Subscription onSubscribeReturn(Observable<T> observableInstance, Subs
      * Invoked after failed execution of {@link Observable#subscribe(Observer)} with thrown Exception.
      * <p>
      * This is NOT errors emitted via {@link Observer#onError(Exception)} but exceptions thrown when attempting
-     * to subscribe to a {@link Func1}<{@link Observer}{@code<T>}, {@link Subscription}>.
+     * to subscribe to a {@link Func1}<{@link Observer}{@code <T>}, {@link Subscription}>.
      * 
      * @param observableInstance
      *            The executing {@link Observable} instance.

File: rxjava-core/src/main/java/rx/subscriptions/BooleanSubscription.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Subscription that can be checked for status such as in a loop inside an {@link Observable} to exit the loop if unsubscribed.
  * 
- * @see Rx.Net equivalent BooleanDisposable at http://msdn.microsoft.com/en-us/library/system.reactive.disposables.booleandisposable(v=vs.103).aspx
+ * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.disposables.booleandisposable(v=vs.103).aspx">Rx.Net equivalent BooleanDisposable</a>
  */
 public class BooleanSubscription implements Subscription {
 

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Subscription that represents a group of Subscriptions that are unsubscribed together.
  * 
- * @see Rx.Net equivalent CompositeDisposable at http://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx
+ * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx">Rx.Net equivalent CompositeDisposable</a>
  */
 public class CompositeSubscription implements Subscription {
 

File: rxjava-core/src/main/java/rx/concurrency/SleepingAction.java
Patch:
@@ -15,8 +15,6 @@
  */
 package rx.concurrency;
 
-import java.util.concurrent.TimeUnit;
-
 import rx.Scheduler;
 import rx.Subscription;
 import rx.util.functions.Func2;

File: rxjava-core/src/main/java/rx/operators/OperationToObservableList.java
Patch:
@@ -104,6 +104,7 @@ public void testListMultipleObservers() {
             Observer<List<String>> o1 = mock(Observer.class);
             observable.subscribe(o1);
 
+            @SuppressWarnings("unchecked")
             Observer<List<String>> o2 = mock(Observer.class);
             observable.subscribe(o2);
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -562,8 +562,8 @@ public void onNext(T args) {
      * <p>
      * This is similar to {@link #subscribe(Observer)} but blocks. Because it blocks it does not need the {@link Observer#onCompleted()} or {@link Observer#onError(Exception)} methods.
      * 
-     * @param onNext
-     *            {@link Action1}
+     * @param o
+     *            onNext {@link Action1 action}
      * @throws RuntimeException
      *             if error occurs
      */

File: rxjava-core/src/main/java/rx/operators/OperationMaterialize.java
Patch:
@@ -40,7 +40,7 @@ public final class OperationMaterialize {
     /**
      * Materializes the implicit notifications of an observable sequence as explicit notification values.
      * 
-     * @param source
+     * @param sequence
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of materializing the notifications of the given sequence.
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx">Observable.Materialize(TSource) Method </a>

File: rxjava-core/src/main/java/rx/operators/OperationMerge.java
Patch:
@@ -44,7 +44,7 @@ public final class OperationMerge {
     /**
      * Flattens the observable sequences from the list of Observables into one observable sequence without any transformation.
      * 
-     * @param source
+     * @param o
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of flattening the output from the list of Observables.
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">Observable.Merge(TSource) Method (IObservable(TSource)[])</a>

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -51,7 +51,7 @@ public final class OperationMergeDelayError {
      * onError or onComplete so as to allow all successful
      * onNext calls to be received.
      * 
-     * @param source
+     * @param sequences
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of flattening the output from the list of Observables.
      * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">Observable.Merge(TSource) Method (IObservable(TSource)[])</a>

File: rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java
Patch:
@@ -44,8 +44,8 @@ public abstract class RxJavaObservableExecutionHook {
      * @param observableInstance
      *            The executing {@link Observable} instance.
      * @param onSubscribe
-     *            original {@link Func1}<{@link Observer}{@code<T>}, {@link Subscription}> to be executed
-     * @return {@link Func1}<{@link Observer}{@code<T>}, {@link Subscription}> function that can be modified, decorated, replaced or just returned as a pass-thru.
+     *            original {@link Func1}<{@link Observer}{@code <T>}, {@link Subscription}> to be executed
+     * @return {@link Func1}<{@link Observer}{@code <T>}, {@link Subscription}> function that can be modified, decorated, replaced or just returned as a pass-thru.
      */
     public <T> Func1<Observer<T>, Subscription> onSubscribeStart(Observable<T> observableInstance, Func1<Observer<T>, Subscription> onSubscribe) {
         // pass-thru by default
@@ -72,7 +72,7 @@ public <T> Subscription onSubscribeReturn(Observable<T> observableInstance, Subs
      * Invoked after failed execution of {@link Observable#subscribe(Observer)} with thrown Exception.
      * <p>
      * This is NOT errors emitted via {@link Observer#onError(Exception)} but exceptions thrown when attempting
-     * to subscribe to a {@link Func1}<{@link Observer}{@code<T>}, {@link Subscription}>.
+     * to subscribe to a {@link Func1}<{@link Observer}{@code <T>}, {@link Subscription}>.
      * 
      * @param observableInstance
      *            The executing {@link Observable} instance.

File: rxjava-core/src/main/java/rx/observables/GroupedObservable.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * An {@link Observable} that has been grouped by a key whose value can be obtained using {@link #getKey()} <p>
  * 
- * @see {@link Observable#groupBy(Observable, Func1)}
+ * @see Observable#groupBy(Observable, Func1)
  * 
  * @param <K>
  * @param <T>

File: rxjava-core/src/main/java/rx/operators/OperationDematerialize.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
- * See http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx for the Microsoft Rx equivalent.
+ * See <a href="http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx">here</a> for the Microsoft Rx equivalent.
  */
 public final class OperationDematerialize {
 
@@ -38,7 +38,7 @@ public final class OperationDematerialize {
      * @param sequence
      *            An observable sequence containing explicit notification values which have to be turned into implicit notifications.
      * @return An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
-     * @see http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229047(v=vs.103).aspx">Observable.Dematerialize(TSource) Method </a>
      */
     public static <T> Func1<Observer<T>, Subscription> dematerialize(final Observable<Notification<T>> sequence) {
         return new DematerializeObservable<T>(sequence);

File: rxjava-core/src/main/java/rx/operators/OperationMaterialize.java
Patch:
@@ -33,7 +33,7 @@
  * <p>
  * In other words, converts a sequence of OnNext, OnError and OnCompleted events into a sequence of ObservableNotifications containing the OnNext, OnError and OnCompleted values.
  * <p>
- * See http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx for the Microsoft Rx equivalent.
+ * See <a href="http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx">here</a> for the Microsoft Rx equivalent.
  */
 public final class OperationMaterialize {
 
@@ -43,7 +43,7 @@ public final class OperationMaterialize {
      * @param source
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of materializing the notifications of the given sequence.
-     * @see http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx">Observable.Materialize(TSource) Method </a>
      */
     public static <T> Func1<Observer<Notification<T>>, Subscription> materialize(final Observable<T> sequence) {
         return new MaterializeObservable<T>(sequence);

File: rxjava-core/src/main/java/rx/operators/OperationMerge.java
Patch:
@@ -47,7 +47,7 @@ public final class OperationMerge {
      * @param source
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of flattening the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">Observable.Merge(TSource) Method (IObservable(TSource)[])</a>
      */
     public static <T> Func1<Observer<T>, Subscription> merge(final Observable<Observable<T>> o) {
         // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java
Patch:
@@ -54,7 +54,7 @@ public final class OperationMergeDelayError {
      * @param source
      *            An observable sequence of elements to project.
      * @return An observable sequence whose elements are the result of flattening the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">Observable.Merge(TSource) Method (IObservable(TSource)[])</a>
      */
     public static <T> Func1<Observer<T>, Subscription> mergeDelayError(final Observable<Observable<T>> sequences) {
         // wrap in a Func so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/operators/OperationScan.java
Patch:
@@ -41,7 +41,7 @@ public final class OperationScan {
      *            An accumulator function to be invoked on each element from the sequence.
      * 
      * @return An observable sequence whose elements are the result of accumulating the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh212007%28v=vs.103%29.aspx">Observable.Scan(TSource, TAccumulate) Method (IObservable(TSource), TAccumulate, Func(TAccumulate, TSource, TAccumulate))</a>
      */
     public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence, T initialValue, Func2<T, T, T> accumulator) {
         return new Accumulator<T>(sequence, initialValue, accumulator);
@@ -56,7 +56,7 @@ public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence,
      *            An accumulator function to be invoked on each element from the sequence.
      * 
      * @return An observable sequence whose elements are the result of accumulating the output from the list of Observables.
-     * @see http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh211665(v=vs.103).aspx">Observable.Scan(TSource) Method (IObservable(TSource), Func(TSource, TSource, TSource))</a>
      */
     public static <T> Func1<Observer<T>, Subscription> scan(Observable<T> sequence, Func2<T, T, T> accumulator) {
         return new Accumulator<T>(sequence, null, accumulator);

File: rxjava-core/src/main/java/rx/operators/OperationSkip.java
Patch:
@@ -29,8 +29,6 @@
 
 /**
  * Skips a specified number of contiguous values from the start of a Observable sequence and then returns the remaining values.
- * 
- * @param <T>
  */
 public final class OperationSkip {
 
@@ -41,7 +39,7 @@ public final class OperationSkip {
      * @param num
      * @return
      * 
-     * @see http://msdn.microsoft.com/en-us/library/hh229847(v=vs.103).aspx
+     * @see <a href="http://msdn.microsoft.com/en-us/library/hh229847(v=vs.103).aspx">Observable.Skip(TSource) Method</a>
      */
     public static <T> Func1<Observer<T>, Subscription> skip(final Observable<T> items, final int num) {
         // wrap in a Observable so that if a chain is built up, then asynchronously subscribed to twice we will have 2 instances of Take<T> rather than 1 handing both, which is not thread-safe.

File: rxjava-core/src/main/java/rx/subscriptions/BooleanSubscription.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Subscription that can be checked for status such as in a loop inside an {@link Observable} to exit the loop if unsubscribed.
  * 
- * @see Rx.Net equivalent BooleanDisposable at http://msdn.microsoft.com/en-us/library/system.reactive.disposables.booleandisposable(v=vs.103).aspx
+ * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.disposables.booleandisposable(v=vs.103).aspx">Rx.Net equivalent BooleanDisposable</a>
  */
 public class BooleanSubscription implements Subscription {
 

File: rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Subscription that represents a group of Subscriptions that are unsubscribed together.
  * 
- * @see Rx.Net equivalent CompositeDisposable at http://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx
+ * @see <a href="http://msdn.microsoft.com/en-us/library/system.reactive.disposables.compositedisposable(v=vs.103).aspx">Rx.Net equivalent CompositeDisposable</a>
  */
 public class CompositeSubscription implements Subscription {
 

File: rxjava-core/src/main/java/rx/operators/OperationFilter.java
Patch:
@@ -37,14 +37,14 @@ private static class Filter<T> implements Func1<Observer<T>, Subscription> {
 
         private final Observable<T> that;
         private final Func1<T, Boolean> predicate;
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
 
         public Filter(Observable<T> that, Func1<T, Boolean> predicate) {
             this.that = that;
             this.predicate = predicate;
         }
 
         public Subscription call(final Observer<T> observer) {
+            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
             return subscription.wrap(that.subscribe(new Observer<T>() {
                 public void onNext(T value) {
                     try {

File: rxjava-core/src/main/java/rx/operators/OperationFilter.java
Patch:
@@ -37,14 +37,14 @@ private static class Filter<T> implements Func1<Observer<T>, Subscription> {
 
         private final Observable<T> that;
         private final Func1<T, Boolean> predicate;
-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
 
         public Filter(Observable<T> that, Func1<T, Boolean> predicate) {
             this.that = that;
             this.predicate = predicate;
         }
 
         public Subscription call(final Observer<T> observer) {
+            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();
             return subscription.wrap(that.subscribe(new Observer<T>() {
                 public void onNext(T value) {
                     try {

File: rxjava-core/src/main/java/rx/Scheduler.java
Patch:
@@ -19,13 +19,15 @@
 import static org.mockito.Mockito.*;
 
 import java.util.Date;
+import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mockito;
 
+import rx.concurrency.Schedulers;
 import rx.concurrency.TestScheduler;
 import rx.subscriptions.Subscriptions;
 import rx.util.functions.Action0;

File: rxjava-core/src/main/java/rx/concurrency/TestScheduler.java
Patch:
@@ -54,11 +54,12 @@ public int compare(TimedAction<?> action1, TimedAction<?> action2) {
         }
     }
 
+    // Storing time in nanoseconds internally.
     private long time;
 
     @Override
     public long now() {
-        return time;
+        return TimeUnit.NANOSECONDS.toMillis(time);
     }
 
     public void advanceTimeBy(long delayTime, TimeUnit unit) {
@@ -96,7 +97,7 @@ public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> acti
 
     @Override
     public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit) {
-        queue.add(new TimedAction<T>(this, now() + unit.toNanos(delayTime), action, state));
+        queue.add(new TimedAction<T>(this, time + unit.toNanos(delayTime), action, state));
         return Subscriptions.empty();
     }
 }

File: rxjava-core/src/main/java/rx/concurrency/TestScheduler.java
Patch:
@@ -79,6 +79,7 @@ private void triggerActions(long targetTimeInNanos) {
         while (!queue.isEmpty()) {
             TimedAction<?> current = queue.peek();
             if (current.time > targetTimeInNanos) {
+                time = targetTimeInNanos;
                 break;
             }
             time = current.time;

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -27,6 +27,7 @@
 import rx.Observer;
 import rx.Subscription;
 import rx.subjects.PublishSubject;
+import rx.subjects.Subject;
 import rx.subscriptions.Subscriptions;
 import rx.util.AtomicObservableSubscription;
 import rx.util.AtomicObserver;
@@ -174,9 +175,8 @@ public Boolean call(Integer input)
 
         @Test
         public void testTakeWhileOnSubject1() {
-            PublishSubject<Integer> s = PublishSubject.create();
-            Observable<Integer> w = (Observable<Integer>) s;
-            Observable<Integer> take = Observable.create(takeWhile(w, new Func1<Integer, Boolean>()
+            Subject<Integer, Integer> s = PublishSubject.create();
+            Observable<Integer> take = Observable.create(takeWhile(s, new Func1<Integer, Boolean>()
             {
                 @Override
                 public Boolean call(Integer input)

File: rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java
Patch:
@@ -26,7 +26,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
-import rx.subjects.DefaultSubject;
+import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
 import rx.util.AtomicObservableSubscription;
 import rx.util.AtomicObserver;
@@ -174,7 +174,7 @@ public Boolean call(Integer input)
 
         @Test
         public void testTakeWhileOnSubject1() {
-            DefaultSubject<Integer> s = DefaultSubject.create();
+            PublishSubject<Integer> s = PublishSubject.create();
             Observable<Integer> w = (Observable<Integer>) s;
             Observable<Integer> take = Observable.create(takeWhile(w, new Func1<Integer, Boolean>()
             {

File: rxjava-core/src/main/java/rx/operators/OperationObserveOn.java
Patch:
@@ -60,7 +60,7 @@ public static class UnitTest {
         @SuppressWarnings("unchecked")
         public void testObserveOn() {
 
-            Scheduler scheduler = spy(Tester.UnitTest.forwardingScheduler(Schedulers.immediate()));
+            Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));
 
             Observer<Integer> observer = mock(Observer.class);
             Observable.create(observeOn(Observable.toObservable(1, 2, 3), scheduler)).subscribe(observer);

File: rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java
Patch:
@@ -81,7 +81,7 @@ public static class UnitTest {
         public void testSubscribeOn() {
             Observable<Integer> w = Observable.toObservable(1, 2, 3);
 
-            Scheduler scheduler = spy(Tester.UnitTest.forwardingScheduler(Schedulers.immediate()));
+            Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));
 
             Observer<Integer> observer = mock(Observer.class);
             Subscription subscription = Observable.create(subscribeOn(w, scheduler)).subscribe(observer);

File: rxjava-core/src/main/java/rx/operators/OperationTake.java
Patch:
@@ -18,7 +18,7 @@
 import static org.junit.Assert.*;
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
-import static rx.operators.Tester.UnitTest.*;
+import static rx.operators.OperatorTester.UnitTest.*;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;

File: rxjava-core/src/main/java/rx/concurrency/ImmediateScheduler.java
Patch:
@@ -48,7 +48,9 @@ public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> acti
     @Override
     public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long dueTime, TimeUnit unit) {
         // since we are executing immediately on this thread we must cause this thread to sleep
-        return schedule(state, new SleepingAction<T>(action, this, dueTime, unit));
+        long execTime = now() + unit.toMillis(dueTime);
+
+        return schedule(state, new SleepingAction<T>(action, this, execTime));
     }
 
     public static class UnitTest {

File: rxjava-core/src/main/java/rx/operators/OperationGroupBy.java
Patch:
@@ -33,7 +33,7 @@
 import rx.util.functions.Func1;
 import rx.util.functions.Functions;
 
-public final class OperatorGroupBy {
+public final class OperationGroupBy {
 
     public static <K, T, R> Func1<Observer<GroupedObservable<K, R>>, Subscription> groupBy(Observable<T> source, final Func1<T, K> keySelector, final Func1<T, R> elementSelector) {
 

File: rxjava-core/src/main/java/rx/operators/OperationTakeUntil.java
Patch:
@@ -24,7 +24,7 @@
 import rx.Subscription;
 import rx.util.functions.Func1;
 
-public class OperatorTakeUntil {
+public class OperationTakeUntil {
 
     /**
      * Returns the values from the source observable sequence until the other observable sequence produces a value.

File: rxjava-core/src/main/java/rx/operators/OperationToIterator.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * @see https://github.com/Netflix/RxJava/issues/50
  */
-public class OperatorToIterator {
+public class OperationToIterator {
 
     /**
      * Returns an iterator that iterates all values of the observable.

File: rxjava-core/src/main/java/rx/operators/ScheduledObserver.java
Patch:
@@ -64,8 +64,6 @@ private void processQueue() {
         scheduler.schedule(new Action0() {
             @Override
             public void call() {
-                int count = counter.decrementAndGet();
-
                 Notification<T> not = queue.poll();
 
                 switch (not.getKind()) {
@@ -83,6 +81,7 @@ public void call() {
 
                 }
 
+                int count = counter.decrementAndGet();
                 if (count > 0) {
                     scheduler.schedule(this);
                 }

File: rxjava-core/src/main/java/rx/operators/OperationInterval.java
Patch:
@@ -18,6 +18,7 @@
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
+import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -45,7 +46,7 @@ public final class OperationInterval {
      * Creates an event each time interval.
      */
     public static Func1<Observer<Long>, Subscription> interval(long interval, TimeUnit unit) {
-        return new Interval(interval, unit, Schedulers.currentThread());
+        return new Interval(interval, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));
     }
 
     /**

File: rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java
Patch:
@@ -115,7 +115,7 @@ public void testMergeWithImmediateScheduler1() {
         Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
         Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
         @SuppressWarnings("unchecked")
-        Observable<String> o = Observable.<Integer> merge(Schedulers.immediate(), o1, o2).map(new Func1<Integer, String>() {
+        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.immediate()).map(new Func1<Integer, String>() {
 
             @Override
             public String call(Integer t) {
@@ -141,7 +141,7 @@ public void testMergeWithCurrentThreadScheduler1() {
         Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
         Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
         @SuppressWarnings("unchecked")
-        Observable<String> o = Observable.<Integer> merge(Schedulers.currentThread(), o1, o2).map(new Func1<Integer, String>() {
+        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.currentThread()).map(new Func1<Integer, String>() {
 
             @Override
             public String call(Integer t) {
@@ -167,7 +167,7 @@ public void testMergeWithScheduler1() {
         Observable<Integer> o1 = Observable.<Integer> from(1, 2, 3, 4, 5);
         Observable<Integer> o2 = Observable.<Integer> from(6, 7, 8, 9, 10);
         @SuppressWarnings("unchecked")
-        Observable<String> o = Observable.<Integer> merge(Schedulers.threadPoolForComputation(), o1, o2).map(new Func1<Integer, String>() {
+        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.threadPoolForComputation()).map(new Func1<Integer, String>() {
 
             @Override
             public String call(Integer t) {

File: rxjava-core/src/main/java/rx/operators/OperationTake.java
Patch:
@@ -18,7 +18,7 @@
 import static org.junit.Assert.*;
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
-import static rx.operators.AbstractOperation.UnitTest.*;
+import static rx.operators.Tester.UnitTest.*;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -281,6 +281,7 @@ public void run() {
             }
 
         }
+
     }
 
 }

File: rxjava-core/src/main/java/rx/operators/OperationTake.java
Patch:
@@ -18,7 +18,7 @@
 import static org.junit.Assert.*;
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
-import static rx.operators.AbstractOperation.UnitTest.*;
+import static rx.operators.Tester.UnitTest.*;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -281,6 +281,7 @@ public void run() {
             }
 
         }
+
     }
 
 }

File: rxjava-core/src/main/java/rx/util/AtomicObservableSubscription.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import rx.Subscription;
 
 /**
@@ -32,7 +30,6 @@
  * <li>handle both synchronous and asynchronous subscribe() execution flows</li>
  * </ul>
  */
-@ThreadSafe
 public final class AtomicObservableSubscription implements Subscription {
 
     private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();

File: rxjava-core/src/main/java/rx/util/SynchronizedObserver.java
Patch:
@@ -26,8 +26,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -50,7 +48,6 @@
  * 
  * @param <T>
  */
-@ThreadSafe
 public final class SynchronizedObserver<T> implements Observer<T> {
 
     /**

File: rxjava-core/src/main/java/rx/util/AtomicObservableSubscription.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import rx.Subscription;
 
 /**
@@ -32,7 +30,6 @@
  * <li>handle both synchronous and asynchronous subscribe() execution flows</li>
  * </ul>
  */
-@ThreadSafe
 public final class AtomicObservableSubscription implements Subscription {
 
     private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();

File: rxjava-core/src/main/java/rx/util/SynchronizedObserver.java
Patch:
@@ -26,8 +26,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -50,7 +48,6 @@
  * 
  * @param <T>
  */
-@ThreadSafe
 public final class SynchronizedObserver<T> implements Observer<T> {
 
     /**

File: rxjava-core/src/main/java/rx/util/AtomicObservableSubscription.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import rx.Subscription;
 
 /**
@@ -32,7 +30,6 @@
  * <li>handle both synchronous and asynchronous subscribe() execution flows</li>
  * </ul>
  */
-@ThreadSafe
 public final class AtomicObservableSubscription implements Subscription {
 
     private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();

File: rxjava-core/src/main/java/rx/util/SynchronizedObserver.java
Patch:
@@ -26,8 +26,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -50,7 +48,6 @@
  * 
  * @param <T>
  */
-@ThreadSafe
 public final class SynchronizedObserver<T> implements Observer<T> {
 
     /**

File: rxjava-core/src/main/java/rx/util/AtomicObservableSubscription.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import rx.Subscription;
 
 /**
@@ -32,7 +30,6 @@
  * <li>handle both synchronous and asynchronous subscribe() execution flows</li>
  * </ul>
  */
-@ThreadSafe
 public final class AtomicObservableSubscription implements Subscription {
 
     private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();

File: rxjava-core/src/main/java/rx/util/SynchronizedObserver.java
Patch:
@@ -26,8 +26,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -50,7 +48,6 @@
  * 
  * @param <T>
  */
-@ThreadSafe
 public final class SynchronizedObserver<T> implements Observer<T> {
 
     /**

File: rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java
Patch:
@@ -94,7 +94,7 @@ public void onError(Exception e) {
         }
 
         @Override
-        public void onNext(Object args) {
+        public void onNext(T args) {
             a.next(this, args);
         }
     }
@@ -185,7 +185,7 @@ synchronized void error(CombineObserver<R, ?> w, Exception e) {
          * @param w
          * @param arg
          */
-        void next(CombineObserver<R, ?> w, Object arg) {
+        <T> void next(CombineObserver<R, T> w, T arg) {
             if (Observer == null) {
                 throw new RuntimeException("This shouldn't be running if a Observer isn't registered");
             }
@@ -485,7 +485,7 @@ public void testAggregateMultipleTypes() {
 
             /* mock the Observable Observers that are 'pushing' data for us */
             CombineObserver<String, String> r1 = mock(CombineObserver.class);
-            CombineObserver<String, Integer> r2 = mock(CombineObserver.class);
+            CombineObserver<String, String> r2 = mock(CombineObserver.class);
 
             /* pretend we're starting up */
             a.addObserver(r1);

File: rxjava-core/src/main/java/rx/operators/OperationToObservableList.java
Patch:
@@ -40,7 +40,6 @@ public static <T> Func1<Observer<List<T>>, Subscription> toObservableList(Observ
     private static class ToObservableList<T> implements Func1<Observer<List<T>>, Subscription> {
 
         private final Observable<T> that;
-        final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();
 
         public ToObservableList(Observable<T> that) {
             this.that = that;
@@ -49,6 +48,7 @@ public ToObservableList(Observable<T> that) {
         public Subscription call(final Observer<List<T>> observer) {
 
             return that.subscribe(new Observer<T>() {
+                final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();
                 public void onNext(T value) {
                     // onNext can be concurrently executed so list must be thread-safe
                     list.add(value);

File: language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java
Patch:
@@ -84,7 +84,7 @@ public void testFilterViaGroovy() {
 
         @Test
         public void testLast() {
-            String script = "mockApiCall.getObservable().last().subscribe(lambda{|result| a.received(result)})";
+            String script = "mockApiCall.getObservable().takeLast(1).subscribe(lambda{|result| a.received(result)})";
             runGroovyScript(script);
             verify(assertion, times(1)).received("hello_1");
         }

File: language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java
Patch:
@@ -84,7 +84,7 @@ public void testFilterViaGroovy() {
 
         @Test
         public void testLast() {
-            String script = "mockApiCall.getObservable().last().subscribe(lambda{|result| a.received(result)})";
+            String script = "mockApiCall.getObservable().takeLast(1).subscribe(lambda{|result| a.received(result)})";
             runGroovyScript(script);
             verify(assertion, times(1)).received("hello_1");
         }

File: rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java
Patch:
@@ -32,6 +32,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func1;
 import rx.util.functions.Func2;
 import rx.util.functions.Func3;
@@ -798,7 +799,7 @@ private static class TestObservable extends Observable<String> {
             public Subscription subscribe(Observer<String> Observer) {
                 // just store the variable where it can be accessed so we can manually trigger it
                 this.Observer = Observer;
-                return Observable.noOpSubscription();
+                return Subscriptions.empty();
             }
 
         }

File: rxjava-core/src/main/java/rx/operators/OperationNext.java
Patch:
@@ -36,6 +36,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.Exceptions;
 import rx.util.functions.Func1;
 
@@ -333,7 +334,7 @@ public void run() {
                             }
                         }
                     }).start();
-                    return Observable.noOpSubscription();
+                    return Subscriptions.empty();
                 }
 
             });

File: rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java
Patch:
@@ -28,6 +28,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.AtomicObservableSubscription;
 import rx.util.CompositeException;
 import rx.util.functions.Func1;
@@ -114,7 +115,7 @@ public void testResumeNextWithSynchronousExecution() {
                 public Subscription call(Observer<String> observer) {
                     observer.onNext("one");
                     observer.onError(new Exception("injected failure"));
-                    return Observable.noOpSubscription();
+                    return Subscriptions.empty();
                 }
             });
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java
Patch:
@@ -7,9 +7,9 @@
 
 import org.junit.Test;
 
-import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func1;
 
 public class OperationToObservableFuture {
@@ -45,7 +45,7 @@ public Subscription call(Observer<T> observer) {
 
             // the get() has already completed so there is no point in
             // giving the user a way to cancel.
-            return Observable.noOpSubscription();
+            return Subscriptions.empty();
         }
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java
Patch:
@@ -26,6 +26,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func1;
 
 /**
@@ -53,7 +54,7 @@ public Subscription call(Observer<T> observer) {
             }
             observer.onCompleted();
 
-            return Observable.noOpSubscription();
+            return Subscriptions.empty();
         }
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationZip.java
Patch:
@@ -32,6 +32,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.AtomicObservableSubscription;
 import rx.util.SynchronizedObserver;
 import rx.util.functions.Func1;
@@ -805,7 +806,7 @@ private static class TestObservable extends Observable<String> {
             public Subscription subscribe(Observer<String> Observer) {
                 // just store the variable where it can be accessed so we can manually trigger it
                 this.Observer = Observer;
-                return Observable.noOpSubscription();
+                return Subscriptions.empty();
             }
 
         }

File: rxjava-core/src/main/java/rx/operators/OperatorToIterator.java
Patch:
@@ -12,6 +12,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.Exceptions;
 import rx.util.functions.Func1;
 
@@ -116,7 +117,7 @@ public void testToIteratorWithException() {
             public Subscription call(Observer<String> observer) {
                 observer.onNext("one");
                 observer.onError(new TestException());
-                return Observable.noOpSubscription();
+                return Subscriptions.empty();
             }
         });
 

File: rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java
Patch:
@@ -32,6 +32,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func1;
 import rx.util.functions.Func2;
 import rx.util.functions.Func3;
@@ -798,7 +799,7 @@ private static class TestObservable extends Observable<String> {
             public Subscription subscribe(Observer<String> Observer) {
                 // just store the variable where it can be accessed so we can manually trigger it
                 this.Observer = Observer;
-                return Observable.noOpSubscription();
+                return Subscriptions.empty();
             }
 
         }

File: rxjava-core/src/main/java/rx/operators/OperationNext.java
Patch:
@@ -36,6 +36,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.Exceptions;
 import rx.util.functions.Func1;
 
@@ -333,7 +334,7 @@ public void run() {
                             }
                         }
                     }).start();
-                    return Observable.noOpSubscription();
+                    return Subscriptions.empty();
                 }
 
             });

File: rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java
Patch:
@@ -28,6 +28,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.AtomicObservableSubscription;
 import rx.util.CompositeException;
 import rx.util.functions.Func1;
@@ -114,7 +115,7 @@ public void testResumeNextWithSynchronousExecution() {
                 public Subscription call(Observer<String> observer) {
                     observer.onNext("one");
                     observer.onError(new Exception("injected failure"));
-                    return Observable.noOpSubscription();
+                    return Subscriptions.empty();
                 }
             });
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java
Patch:
@@ -7,9 +7,9 @@
 
 import org.junit.Test;
 
-import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func1;
 
 public class OperationToObservableFuture {
@@ -45,7 +45,7 @@ public Subscription call(Observer<T> observer) {
 
             // the get() has already completed so there is no point in
             // giving the user a way to cancel.
-            return Observable.noOpSubscription();
+            return Subscriptions.empty();
         }
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationToObservableIterable.java
Patch:
@@ -26,6 +26,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.functions.Func1;
 
 /**
@@ -53,7 +54,7 @@ public Subscription call(Observer<T> observer) {
             }
             observer.onCompleted();
 
-            return Observable.noOpSubscription();
+            return Subscriptions.empty();
         }
     }
 

File: rxjava-core/src/main/java/rx/operators/OperationZip.java
Patch:
@@ -32,6 +32,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.AtomicObservableSubscription;
 import rx.util.SynchronizedObserver;
 import rx.util.functions.Func1;
@@ -805,7 +806,7 @@ private static class TestObservable extends Observable<String> {
             public Subscription subscribe(Observer<String> Observer) {
                 // just store the variable where it can be accessed so we can manually trigger it
                 this.Observer = Observer;
-                return Observable.noOpSubscription();
+                return Subscriptions.empty();
             }
 
         }

File: rxjava-core/src/main/java/rx/operators/OperatorToIterator.java
Patch:
@@ -12,6 +12,7 @@
 import rx.Observable;
 import rx.Observer;
 import rx.Subscription;
+import rx.subscriptions.Subscriptions;
 import rx.util.Exceptions;
 import rx.util.functions.Func1;
 
@@ -116,7 +117,7 @@ public void testToIteratorWithException() {
             public Subscription call(Observer<String> observer) {
                 observer.onNext("one");
                 observer.onError(new TestException());
-                return Observable.noOpSubscription();
+                return Subscriptions.empty();
             }
         });
 

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -2171,7 +2171,7 @@ public Boolean call(T first, T second) {
      *            type of sequence
      * @return sequence of booleans, true if two sequences are equal by comparing the elements pairwise; otherwise, false.
      */
-    private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Func2<T, T, Boolean> equality) {
+    public static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Func2<T, T, Boolean> equality) {
         return zip(first, second, equality);
     }
 
@@ -2188,7 +2188,7 @@ private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observ
      *            type of sequence
      * @return sequence of booleans, true if two sequences are equal by comparing the elements pairwise; otherwise, false.
      */
-    private static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Object equality) {
+    public static <T> Observable<Boolean> sequenceEqual(Observable<T> first, Observable<T> second, Object equality) {
         return zip(first, second, equality);
     }
 

File: rxjava-core/src/main/java/rx/util/functions/Functions.java
Patch:
@@ -26,7 +26,7 @@
  * <p>
  * Language support is provided via implementations of {@link FunctionLanguageAdaptor}.
  * <p>
- * This class will dynamically look for known language adaptors on the classpath at startup or new ones can be registered using {@link #registerLanguageAdaptor(Class, FunctionLanguageAdaptor)}.
+ * This class will dynamically look for known language adaptors on the classpath at startup or new ones can be registered using {@link #registerLanguageAdaptor(Class[], FunctionLanguageAdaptor)}.
  */
 public class Functions {
 
@@ -81,7 +81,6 @@ public static Collection<FunctionLanguageAdaptor> getRegisteredLanguageAdaptors(
      * Utility method for determining the type of closure/function and executing it.
      * 
      * @param function
-     * @param args
      */
     @SuppressWarnings({ "rawtypes" })
     public static FuncN from(final Object function) {

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -46,6 +46,7 @@
 import rx.operators.OperationSkip;
 import rx.operators.OperationSynchronize;
 import rx.operators.OperationTake;
+import rx.operators.OperationTakeLast;
 import rx.operators.OperationToObservableFuture;
 import rx.operators.OperationToObservableIterable;
 import rx.operators.OperationToObservableList;

File: rxjava-core/src/main/java/rx/Notification.java
Patch:
@@ -149,7 +149,7 @@ public boolean equals(Object obj) {
             return true;
         if (obj.getClass() != getClass())
             return false;
-        Notification notification = (Notification) obj;
+        Notification<?> notification = (Notification<?>) obj;
         if (notification.getKind() != getKind())
             return false;
         if (hasValue() && !getValue().equals(notification.getValue()))

File: rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java
Patch:
@@ -64,7 +64,7 @@ public void testSuccess() throws Exception {
             Future<Object> future = mock(Future.class);
             Object value = new Object();
             when(future.get()).thenReturn(value);
-            ToObservableFuture ob = new ToObservableFuture(future);
+            ToObservableFuture<Object> ob = new ToObservableFuture<Object>(future);
             Observer<Object> o = mock(Observer.class);
 
             Subscription sub = ob.call(o);
@@ -81,7 +81,7 @@ public void testFailure() throws Exception {
             Future<Object> future = mock(Future.class);
             RuntimeException e = new RuntimeException();
             when(future.get()).thenThrow(e);
-            ToObservableFuture ob = new ToObservableFuture(future);
+            ToObservableFuture<Object> ob = new ToObservableFuture<Object>(future);
             Observer<Object> o = mock(Observer.class);
 
             Subscription sub = ob.call(o);

File: rxjava-core/src/main/java/rx/Subscription.java
Patch:
@@ -18,9 +18,9 @@
 public interface Subscription {
 
     /**
-     * Stop receiving notifications on the observer that was registered when this IDisposable was received.
+     * Stop receiving notifications on the {@link Observer} that was registered when this Subscription was received.
      * <p>
-     * This allows unregistering a Observer before it has finished receiving all events (ie. before onCompleted is called).
+     * This allows unregistering an {@link Observer} before it has finished receiving all events (ie. before onCompleted is called).
      */
     public void unsubscribe();
 

File: rxjava-core/src/main/java/rx/Subscription.java
Patch:
@@ -18,9 +18,9 @@
 public interface Subscription {
 
     /**
-     * Stop receiving notifications on the observer that was registered when this IDisposable was received.
+     * Stop receiving notifications on the {@link Observer} that was registered when this Subscription was received.
      * <p>
-     * This allows unregistering a Observer before it has finished receiving all events (ie. before onCompleted is called).
+     * This allows unregistering an {@link Observer} before it has finished receiving all events (ie. before onCompleted is called).
      */
     public void unsubscribe();
 

File: language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java
Patch:
@@ -100,7 +100,7 @@ public void before() {
 
         @Test
         public void testTake() {
-            runClojureScript("(-> (rx.observables.Observable/toObservable [\"one\" \"two\" \"three\"]) (.take 2) (.subscribe (fn [arg] (println arg))))");
+            runClojureScript("(-> (rx.Observable/toObservable [\"one\" \"two\" \"three\"]) (.take 2) (.subscribe (fn [arg] (println arg))))");
         }
 
         // commented out for now as I can't figure out how to set the var 'a' with the 'assertion' instance when running the code from java 

File: language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java
Patch:
@@ -164,7 +164,7 @@ private void runGroovyScript(String script) {
 
             StringBuilder b = new StringBuilder();
             // force JRuby to always use subscribe(Object)
-            b.append("import \"rx.observables.Observable\"").append("\n");
+            b.append("import \"rx.Observable\"").append("\n");
             b.append("class Observable").append("\n");
             b.append("  java_alias :subscribe, :subscribe, [java.lang.Object]").append("\n");
             b.append("end").append("\n");

File: rxjava-core/src/main/java/rx/Observable.java
Patch:
@@ -913,7 +913,7 @@ public void unsubscribe() {
      * @return
      */
     public static Subscription createSubscription(final Object unsubscribe) {
-        final FuncN f = Functions.from(unsubscribe);
+        final FuncN<?> f = Functions.from(unsubscribe);
         return new Subscription() {
 
             @Override

File: rxjava-core/src/main/java/rx/observables/operations/OperationCombineLatest.java
Patch:
@@ -103,7 +103,7 @@ public void onNext(Object args) {
      * 
      * @param <R>
      */
-    private static class Aggregator<R> implements Func1<Observer<R>, Subscription> {
+    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {
 
         private final FuncN<R> combineLatestFunction;
         private Observer<R> Observer;

File: rxjava-core/src/main/java/rx/observables/operations/OperationLast.java
Patch:
@@ -40,7 +40,7 @@ public static <T> Func1<Observer<T>, Subscription> last(Observable<T> observable
         return new Last<T>(observable);
     }
 
-    private static class Last<T> implements Func1<Observer<T>, Subscription> {
+    private static class Last<T> implements OperatorSubscribeFunction<T> {
 
         private final AtomicReference<T> lastValue = new AtomicReference<T>();
         private final Observable<T> that;

File: rxjava-core/src/main/java/rx/observables/operations/OperationMap.java
Patch:
@@ -79,7 +79,7 @@ public static <T, R> Func1<Observer<R>, Subscription> mapMany(Observable<T> sequ
      * @param <R>
      *            the type of the output sequence.
      */
-    private static class MapObservable<T, R> implements Func1<Observer<R>, Subscription> {
+    private static class MapObservable<T, R> implements OperatorSubscribeFunction<R> {
         public MapObservable(Observable<T> sequence, Func1<T, R> func) {
             this.sequence = sequence;
             this.func = func;

File: rxjava-core/src/main/java/rx/observables/operations/OperationMaterialize.java
Patch:
@@ -49,7 +49,7 @@ public static <T> Func1<Observer<Notification<T>>, Subscription> materialize(fin
         return new MaterializeObservable<T>(sequence);
     }
 
-    private static class MaterializeObservable<T> implements Func1<Observer<Notification<T>>, Subscription> {
+    private static class MaterializeObservable<T> implements OperatorSubscribeFunction<Notification<T>> {
 
         private final Observable<T> sequence;
 

File: rxjava-core/src/main/java/rx/observables/operations/OperationOnErrorResumeNextViaFunction.java
Patch:
@@ -38,7 +38,7 @@ public static <T> Func1<Observer<T>, Subscription> onErrorResumeNextViaFunction(
         return new OnErrorResumeNextViaFunction<T>(originalSequence, resumeFunction);
     }
 
-    private static class OnErrorResumeNextViaFunction<T> implements Func1<Observer<T>, Subscription> {
+    private static class OnErrorResumeNextViaFunction<T> implements OperatorSubscribeFunction<T> {
 
         private final Func1<Exception, Observable<T>> resumeFunction;
         private final Observable<T> originalSequence;

File: rxjava-core/src/main/java/rx/observables/operations/OperationOnErrorResumeNextViaObservable.java
Patch:
@@ -36,7 +36,7 @@ public static <T> Func1<Observer<T>, Subscription> onErrorResumeNextViaObservabl
         return new OnErrorResumeNextViaObservable<T>(originalSequence, resumeSequence);
     }
 
-    private static class OnErrorResumeNextViaObservable<T> implements Func1<Observer<T>, Subscription> {
+    private static class OnErrorResumeNextViaObservable<T> implements OperatorSubscribeFunction<T> {
 
         private final Observable<T> resumeSequence;
         private final Observable<T> originalSequence;

File: rxjava-core/src/main/java/rx/observables/operations/OperationOnErrorReturn.java
Patch:
@@ -41,7 +41,7 @@ public static <T> Func1<Observer<T>, Subscription> onErrorReturn(Observable<T> o
         return new OnErrorReturn<T>(originalSequence, resumeFunction);
     }
 
-    private static class OnErrorReturn<T> implements Func1<Observer<T>, Subscription> {
+    private static class OnErrorReturn<T> implements OperatorSubscribeFunction<T> {
         private final Func1<Exception, T> resumeFunction;
         private final Observable<T> originalSequence;
 

File: rxjava-core/src/main/java/rx/observables/operations/OperationSkip.java
Patch:
@@ -62,7 +62,7 @@ public Subscription call(Observer<T> observer) {
      * 
      * @param <T>
      */
-    private static class Skip<T> implements Func1<Observer<T>, Subscription> {
+    private static class Skip<T> implements OperatorSubscribeFunction<T> {
         private final int num;
         private final Observable<T> items;
 

File: rxjava-core/src/main/java/rx/observables/operations/OperationSynchronize.java
Patch:
@@ -58,7 +58,7 @@ public static <T> Func1<Observer<T>, Subscription> synchronize(Observable<T> obs
         return new Synchronize<T>(observable);
     }
 
-    private static class Synchronize<T> implements Func1<Observer<T>, Subscription> {
+    private static class Synchronize<T> implements OperatorSubscribeFunction<T> {
 
         public Synchronize(Observable<T> innerObservable) {
             this.innerObservable = innerObservable;

File: rxjava-core/src/main/java/rx/observables/operations/OperationToObservableIterable.java
Patch:
@@ -40,7 +40,7 @@ public static <T> Func1<Observer<T>, Subscription> toObservableIterable(Iterable
         return new ToObservableIterable<T>(list);
     }
 
-    private static class ToObservableIterable<T> implements Func1<Observer<T>, Subscription> {
+    private static class ToObservableIterable<T> implements OperatorSubscribeFunction<T> {
         public ToObservableIterable(Iterable<T> list) {
             this.iterable = list;
         }

File: rxjava-core/src/main/java/rx/observables/operations/OperationToObservableList.java
Patch:
@@ -37,7 +37,7 @@ public static <T> Func1<Observer<List<T>>, Subscription> toObservableList(Observ
         return new ToObservableList<T>(that);
     }
 
-    private static class ToObservableList<T> implements Func1<Observer<List<T>>, Subscription> {
+    private static class ToObservableList<T> implements OperatorSubscribeFunction<List<T>> {
 
         private final Observable<T> that;
         final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();

File: rxjava-core/src/main/java/rx/observables/operations/OperationToObservableSortedList.java
Patch:
@@ -64,7 +64,7 @@ public static <T> Func1<Observer<List<T>>, Subscription> toSortedList(Observable
         return new ToObservableSortedList<T>(sequence, sortFunction);
     }
 
-    private static class ToObservableSortedList<T> implements Func1<Observer<List<T>>, Subscription> {
+    private static class ToObservableSortedList<T> implements OperatorSubscribeFunction<List<T>> {
 
         private final Observable<T> that;
         private final ConcurrentLinkedQueue<T> list = new ConcurrentLinkedQueue<T>();

File: rxjava-core/src/main/java/rx/observables/operations/OperationZip.java
Patch:
@@ -112,7 +112,7 @@ public void onNext(T args) {
      * @param <R>
      */
     @ThreadSafe
-    private static class Aggregator<R> implements Func1<Observer<R>, Subscription> {
+    private static class Aggregator<R> implements OperatorSubscribeFunction<R> {
 
         private volatile AtomicObserverSingleThreaded<R> observer;
         private final FuncN<R> zipFunction;

File: rxjava-core/src/main/java/rx/observables/operations/AtomicObserver.java
Patch:
@@ -47,7 +47,7 @@
 /* package */final class AtomicObserver<T> implements Observer<T> {
 
     /** Allow changing between forcing single or allowing multi-threaded execution of onNext */
-    private static boolean allowMultiThreaded = true;
+    private static boolean allowMultiThreaded = false;
     static {
         String v = System.getProperty("rx.onNext.multithreaded.enabled");
         if (v != null) {

File: rxjava-core/src/main/java/rx/util/Action0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action0 {
+public interface Action0 extends Function {
     public void call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Action1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action1<T1> {
+public interface Action1<T1> extends Function {
     public void call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Action2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action2<T1, T2> {
+public interface Action2<T1, T2> extends Function {
     public void call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Action3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action3<T1, T2, T3> {
+public interface Action3<T1, T2, T3> extends Function {
     public void call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func0<R> {
+public interface Func0<R> extends Function {
     public R call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func1<T1, R> {
+public interface Func1<T1, R> extends Function {
     public R call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func2<T1, T2, R> {
+public interface Func2<T1, T2, R> extends Function {
     public R call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func3<T1, T2, T3, R> {
+public interface Func3<T1, T2, T3, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func4.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func4<T1, T2, T3, T4, R> {
+public interface Func4<T1, T2, T3, T4, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func5.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func5<T1, T2, T3, T4, T5, R> {
+public interface Func5<T1, T2, T3, T4, T5, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func6.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func6<T1, T2, T3, T4, T5, T6, R> {
+public interface Func6<T1, T2, T3, T4, T5, T6, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func7.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func7<T1, T2, T3, T4, T5, T6, T7, R> {
+public interface Func7<T1, T2, T3, T4, T5, T6, T7, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func8.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
+public interface Func8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func9.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
+public interface Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/FuncN.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface FuncN<R> {
+public interface FuncN<R> extends Function {
     public R call(Object... args);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/observables/operations/AtomicObserver.java
Patch:
@@ -47,7 +47,7 @@
 /* package */final class AtomicObserver<T> implements Observer<T> {
 
     /** Allow changing between forcing single or allowing multi-threaded execution of onNext */
-    private static boolean allowMultiThreaded = true;
+    private static boolean allowMultiThreaded = false;
     static {
         String v = System.getProperty("rx.onNext.multithreaded.enabled");
         if (v != null) {

File: rxjava-core/src/main/java/rx/util/Action0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action0 {
+public interface Action0 extends Function {
     public void call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Action1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action1<T1> {
+public interface Action1<T1> extends Function {
     public void call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Action2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action2<T1, T2> {
+public interface Action2<T1, T2> extends Function {
     public void call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Action3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Action3<T1, T2, T3> {
+public interface Action3<T1, T2, T3> extends Function {
     public void call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func0.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func0<R> {
+public interface Func0<R> extends Function {
     public R call();
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func1.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func1<T1, R> {
+public interface Func1<T1, R> extends Function {
     public R call(T1 t1);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func2.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func2<T1, T2, R> {
+public interface Func2<T1, T2, R> extends Function {
     public R call(T1 t1, T2 t2);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func3.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func3<T1, T2, T3, R> {
+public interface Func3<T1, T2, T3, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func4.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func4<T1, T2, T3, T4, R> {
+public interface Func4<T1, T2, T3, T4, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func5.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func5<T1, T2, T3, T4, T5, R> {
+public interface Func5<T1, T2, T3, T4, T5, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func6.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func6<T1, T2, T3, T4, T5, T6, R> {
+public interface Func6<T1, T2, T3, T4, T5, T6, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func7.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func7<T1, T2, T3, T4, T5, T6, T7, R> {
+public interface Func7<T1, T2, T3, T4, T5, T6, T7, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func8.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
+public interface Func8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/Func9.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
+public interface Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends Function {
     public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
 }
\ No newline at end of file

File: rxjava-core/src/main/java/rx/util/FuncN.java
Patch:
@@ -15,6 +15,6 @@
  */
 package rx.util;
 
-public interface FuncN<R> {
+public interface FuncN<R> extends Function {
     public R call(Object... args);
 }
\ No newline at end of file

