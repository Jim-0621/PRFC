File: zh-hant/codes/java/chapter_graph/graph_bfs.java
Patch:
@@ -15,7 +15,7 @@ public class graph_bfs {
     static List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {
         // 頂點走訪序列
         List<Vertex> res = new ArrayList<>();
-        // 雜湊表，用於記錄已被訪問過的頂點
+        // 雜湊集合，用於記錄已被訪問過的頂點
         Set<Vertex> visited = new HashSet<>();
         visited.add(startVet);
         // 佇列用於實現 BFS

File: zh-hant/codes/java/chapter_graph/graph_dfs.java
Patch:
@@ -28,7 +28,7 @@ static void dfs(GraphAdjList graph, Set<Vertex> visited, List<Vertex> res, Verte
     static List<Vertex> graphDFS(GraphAdjList graph, Vertex startVet) {
         // 頂點走訪序列
         List<Vertex> res = new ArrayList<>();
-        // 雜湊表，用於記錄已被訪問過的頂點
+        // 雜湊集合，用於記錄已被訪問過的頂點
         Set<Vertex> visited = new HashSet<>();
         dfs(graph, visited, res, startVet);
         return res;

File: zh-hant/codes/java/chapter_sorting/radix_sort.java
Patch:
@@ -50,12 +50,13 @@ static void radixSort(int[] nums) {
             if (num > m)
                 m = num;
         // 按照從低位到高位的順序走訪
-        for (int exp = 1; exp <= m; exp *= 10)
+        for (int exp = 1; exp <= m; exp *= 10) {
             // 對陣列元素的第 k 位執行計數排序
             // k = 1 -> exp = 1
             // k = 2 -> exp = 10
             // 即 exp = 10^(k-1)
             countingSortDigit(nums, exp);
+        }
     }
 
     public static void main(String[] args) {

File: codes/java/chapter_sorting/insertion_sort.java
Patch:
@@ -11,10 +11,10 @@
 public class insertion_sort {
     /* 插入排序 */
     static void insertionSort(int[] nums) {
-        // 外循环：已排序元素数量为 1, 2, ..., n
+        // 外循环：已排序区间为 [0, i-1]
         for (int i = 1; i < nums.length; i++) {
             int base = nums[i], j = i - 1;
-            // 内循环：将 base 插入到已排序部分的正确位置
+            // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置
             while (j >= 0 && nums[j] > base) {
                 nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位
                 j--;

File: codes/java/chapter_array_and_linkedlist/array.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: array.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_array_and_linkedlist;

File: codes/java/chapter_array_and_linkedlist/linked_list.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: linked_list.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_array_and_linkedlist;

File: codes/java/chapter_array_and_linkedlist/list.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: list.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_array_and_linkedlist;

File: codes/java/chapter_array_and_linkedlist/my_list.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: my_list.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_array_and_linkedlist;

File: codes/java/chapter_backtracking/n_queens.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: n_queens.java
  * Created Time: 2023-05-04
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/permutations_i.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: permutations_i.java
  * Created Time: 2023-04-24
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/permutations_ii.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: permutations_ii.java
  * Created Time: 2023-04-24
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/preorder_traversal_i_compact.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: preorder_traversal_i_compact.java
  * Created Time: 2023-04-16
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/preorder_traversal_ii_compact.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: preorder_traversal_ii_compact.java
  * Created Time: 2023-04-16
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/preorder_traversal_iii_compact.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: preorder_traversal_iii_compact.java
  * Created Time: 2023-04-16
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/preorder_traversal_iii_template.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: preorder_traversal_iii_template.java
  * Created Time: 2023-04-16
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/subset_sum_i.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: subset_sum_i.java
  * Created Time: 2023-06-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/subset_sum_i_naive.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: subset_sum_i_naive.java
  * Created Time: 2023-06-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_backtracking/subset_sum_ii.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: subset_sum_ii.java
  * Created Time: 2023-06-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_backtracking;

File: codes/java/chapter_computational_complexity/iteration.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: iteration.java
  * Created Time: 2023-08-24
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_computational_complexity;

File: codes/java/chapter_computational_complexity/recursion.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: recursion.java
  * Created Time: 2023-08-24
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_computational_complexity;

File: codes/java/chapter_computational_complexity/space_complexity.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: space_complexity.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_computational_complexity;

File: codes/java/chapter_computational_complexity/time_complexity.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: time_complexity.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_computational_complexity;

File: codes/java/chapter_computational_complexity/worst_best_time_complexity.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: worst_best_time_complexity.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_computational_complexity;

File: codes/java/chapter_divide_and_conquer/build_tree.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: build_tree.java
  * Created Time: 2023-07-17
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_divide_and_conquer;

File: codes/java/chapter_divide_and_conquer/hanota.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: hanota.java
  * Created Time: 2023-07-17
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_divide_and_conquer;

File: codes/java/chapter_dynamic_programming/climbing_stairs_backtrack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: climbing_stairs_backtrack.java
  * Created Time: 2023-06-30
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: climbing_stairs_constraint_dp.java
  * Created Time: 2023-07-01
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/climbing_stairs_dfs.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: climbing_stairs_dfs.java
  * Created Time: 2023-06-30
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/climbing_stairs_dfs_mem.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: climbing_stairs_dfs_mem.java
  * Created Time: 2023-06-30
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/climbing_stairs_dp.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: climbing_stairs_dp.java
  * Created Time: 2023-06-30
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/coin_change.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: coin_change.java
  * Created Time: 2023-07-11
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/coin_change_ii.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: coin_change_ii.java
  * Created Time: 2023-07-11
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/edit_distance.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: edit_distance.java
  * Created Time: 2023-07-13
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/knapsack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: knapsack.java
  * Created Time: 2023-07-10
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/min_cost_climbing_stairs_dp.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: min_cost_climbing_stairs_dp.java
  * Created Time: 2023-06-30
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/min_path_sum.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: min_path_sum.java
  * Created Time: 2023-07-10
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_dynamic_programming/unbounded_knapsack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: unbounded_knapsack.java
  * Created Time: 2023-07-11
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_dynamic_programming;

File: codes/java/chapter_graph/graph_adjacency_list.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: graph_adjacency_list.java
  * Created Time: 2023-01-26
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_graph;

File: codes/java/chapter_graph/graph_adjacency_matrix.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: graph_adjacency_matrix.java
  * Created Time: 2023-01-26
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_graph;

File: codes/java/chapter_graph/graph_bfs.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: graph_bfs.java
  * Created Time: 2023-02-12
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_graph;

File: codes/java/chapter_graph/graph_dfs.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: graph_dfs.java
  * Created Time: 2023-02-12
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_graph;

File: codes/java/chapter_greedy/coin_change_greedy.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: coin_change_greedy.java
  * Created Time: 2023-07-20
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_greedy;

File: codes/java/chapter_greedy/fractional_knapsack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: fractional_knapsack.java
  * Created Time: 2023-07-20
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_greedy;

File: codes/java/chapter_greedy/max_capacity.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: max_capacity.java
  * Created Time: 2023-07-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_greedy;

File: codes/java/chapter_greedy/max_product_cutting.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: max_product_cutting.java
  * Created Time: 2023-07-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_greedy;

File: codes/java/chapter_hashing/array_hash_map.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: array_hash_map.java
  * Created Time: 2022-12-04
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_hashing;

File: codes/java/chapter_hashing/built_in_hash.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: built_in_hash.java
  * Created Time: 2023-06-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_hashing;

File: codes/java/chapter_hashing/hash_map.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: hash_map.java
  * Created Time: 2022-12-04
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_hashing;

File: codes/java/chapter_hashing/hash_map_chaining.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: hash_map_chaining.java
  * Created Time: 2023-06-13
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_hashing;

File: codes/java/chapter_hashing/hash_map_open_addressing.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: hash_map_open_addressing.java
  * Created Time: 2023-06-13
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_hashing;

File: codes/java/chapter_hashing/simple_hash.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: simple_hash.java
  * Created Time: 2023-06-21
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_hashing;

File: codes/java/chapter_heap/heap.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: heap.java
  * Created Time: 2023-01-07
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_heap;

File: codes/java/chapter_heap/my_heap.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: my_heap.java
  * Created Time: 2023-01-07
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_heap;

File: codes/java/chapter_heap/top_k.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: top_k.java
  * Created Time: 2023-06-12
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_heap;

File: codes/java/chapter_searching/binary_search.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_search.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_searching;

File: codes/java/chapter_searching/binary_search_edge.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_search_edge.java
  * Created Time: 2023-08-04
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_searching;

File: codes/java/chapter_searching/binary_search_insertion.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_search_insertion.java
  * Created Time: 2023-08-04
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_searching;

File: codes/java/chapter_searching/hashing_search.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: hashing_search.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_searching;

File: codes/java/chapter_searching/linear_search.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: linear_search.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_searching;

File: codes/java/chapter_searching/two_sum.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: two_sum.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_searching;

File: codes/java/chapter_sorting/bubble_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: bubble_sort.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/bucket_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: bucket_sort.java
  * Created Time: 2023-03-17
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/counting_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: counting_sort.java
  * Created Time: 2023-03-17
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/heap_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: heap_sort.java
  * Created Time: 2023-05-26
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/insertion_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: insertion_sort.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/merge_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: merge_sort.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/quick_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: quick_sort.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/radix_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: radix_sort.java
  * Created Time: 2023-01-17
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_sorting/selection_sort.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: selection_sort.java
  * Created Time: 2023-05-23
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_sorting;

File: codes/java/chapter_stack_and_queue/array_deque.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: array_deque.java
  * Created Time: 2023-02-16
- * Author: Krahets (krahets@163.com), FangYuan33 (374072213@qq.com)
+ * Author: krahets (krahets@163.com), FangYuan33 (374072213@qq.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/array_queue.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: array_queue.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/array_stack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: array_stack.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/deque.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: deque.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/linkedlist_deque.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: linkedlist_deque.java
  * Created Time: 2023-01-20
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/linkedlist_queue.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: linkedlist_queue.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/linkedlist_stack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: linkedlist_stack.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/queue.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: queue.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_stack_and_queue/stack.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: stack.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_stack_and_queue;

File: codes/java/chapter_tree/array_binary_tree.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: array_binary_tree.java
  * Created Time: 2023-07-19
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_tree;

File: codes/java/chapter_tree/avl_tree.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: avl_tree.java
  * Created Time: 2022-12-10
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_tree;

File: codes/java/chapter_tree/binary_search_tree.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_search_tree.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_tree;

File: codes/java/chapter_tree/binary_tree.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_tree.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_tree;

File: codes/java/chapter_tree/binary_tree_bfs.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_tree_bfs.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_tree;

File: codes/java/chapter_tree/binary_tree_dfs.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: binary_tree_dfs.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package chapter_tree;

File: codes/java/utils/ListNode.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: ListNode.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package utils;

File: codes/java/utils/PrintUtil.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: PrintUtil.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package utils;

File: codes/java/utils/TreeNode.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: TreeNode.java
  * Created Time: 2022-11-25
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package utils;

File: codes/java/utils/Vertex.java
Patch:
@@ -1,7 +1,7 @@
 /**
  * File: Vertex.java
  * Created Time: 2023-02-15
- * Author: Krahets (krahets@163.com)
+ * Author: krahets (krahets@163.com)
  */
 
 package utils;

File: codes/java/chapter_backtracking/n_queens.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.*;
 
 public class n_queens {
-    /* 回溯算法：N 皇后 */
+    /* 回溯算法：n 皇后 */
     public static void backtrack(int row, int n, List<List<String>> state, List<List<List<String>>> res,
             boolean[] cols, boolean[] diags1, boolean[] diags2) {
         // 当放置完所有行时，记录解
@@ -40,7 +40,7 @@ public static void backtrack(int row, int n, List<List<String>> state, List<List
         }
     }
 
-    /* 求解 N 皇后 */
+    /* 求解 n 皇后 */
     public static List<List<List<String>>> nQueens(int n) {
         // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位
         List<List<String>> state = new ArrayList<>();

File: codes/java/chapter_array_and_linkedlist/my_list.java
Patch:
@@ -76,7 +76,7 @@ public int remove(int index) {
         if (index < 0 || index >= size)
             throw new IndexOutOfBoundsException("索引越界");
         int num = arr[index];
-        // 将索引 index 之后的元素都向前移动一位
+        // 将将索引 index 之后的元素都向前移动一位
         for (int j = index; j < size - 1; j++) {
             arr[j] = arr[j + 1];
         }

File: codes/java/chapter_tree/array_binary_tree.java
Patch:
@@ -18,7 +18,7 @@ public ArrayBinaryTree(List<Integer> arr) {
         tree = new ArrayList<>(arr);
     }
 
-    /* 节点数量 */
+    /* 列表容量 */
     public int size() {
         return tree.size();
     }

File: codes/java/chapter_tree/array_binary_tree.java
Patch:
@@ -63,15 +63,15 @@ private void dfs(Integer i, String order, List<Integer> res) {
         if (val(i) == null)
             return;
         // 前序遍历
-        if (order == "pre")
+        if ("pre".equals(order))
             res.add(val(i));
         dfs(left(i), order, res);
         // 中序遍历
-        if (order == "in")
+        if ("in".equals(order))
             res.add(val(i));
         dfs(right(i), order, res);
         // 后序遍历
-        if (order == "post")
+        if ("post".equals(order))
             res.add(val(i));
     }
 

File: codes/java/chapter_array_and_linkedlist/array.java
Patch:
@@ -54,11 +54,11 @@ static void traverse(int[] nums) {
         int count = 0;
         // 通过索引遍历数组
         for (int i = 0; i < nums.length; i++) {
-            count++;
+            count += nums[i];
         }
-        // 直接遍历数组
+        // 直接遍历数组元素
         for (int num : nums) {
-            count++;
+            count += num;
         }
     }
 

File: codes/java/chapter_dynamic_programming/climbing_stairs_backtrack.java
Patch:
@@ -18,7 +18,7 @@ public static void backtrack(List<Integer> choices, int state, int n, List<Integ
         for (Integer choice : choices) {
             // 剪枝：不允许越过第 n 阶
             if (state + choice > n)
-                break;
+                continue;
             // 尝试：做出选择，更新状态
             backtrack(choices, state + choice, n, res);
             // 回退

File: codes/java/chapter_dynamic_programming/coin_change.java
Patch:
@@ -23,7 +23,7 @@ static int coinChangeDP(int[] coins, int amt) {
         for (int i = 1; i <= n; i++) {
             for (int a = 1; a <= amt; a++) {
                 if (coins[i - 1] > a) {
-                    // 若超过背包容量，则不选硬币 i
+                    // 若超过目标金额，则不选硬币 i
                     dp[i][a] = dp[i - 1][a];
                 } else {
                     // 不选和选硬币 i 这两种方案的较小值
@@ -46,7 +46,7 @@ static int coinChangeDPComp(int[] coins, int amt) {
         for (int i = 1; i <= n; i++) {
             for (int a = 1; a <= amt; a++) {
                 if (coins[i - 1] > a) {
-                    // 若超过背包容量，则不选硬币 i
+                    // 若超过目标金额，则不选硬币 i
                     dp[a] = dp[a];
                 } else {
                     // 不选和选硬币 i 这两种方案的较小值

File: codes/java/chapter_dynamic_programming/coin_change_ii.java
Patch:
@@ -20,7 +20,7 @@ static int coinChangeIIDP(int[] coins, int amt) {
         for (int i = 1; i <= n; i++) {
             for (int a = 1; a <= amt; a++) {
                 if (coins[i - 1] > a) {
-                    // 若超过背包容量，则不选硬币 i
+                    // 若超过目标金额，则不选硬币 i
                     dp[i][a] = dp[i - 1][a];
                 } else {
                     // 不选和选硬币 i 这两种方案之和
@@ -41,7 +41,7 @@ static int coinChangeIIDPComp(int[] coins, int amt) {
         for (int i = 1; i <= n; i++) {
             for (int a = 1; a <= amt; a++) {
                 if (coins[i - 1] > a) {
-                    // 若超过背包容量，则不选硬币 i
+                    // 若超过目标金额，则不选硬币 i
                     dp[a] = dp[a];
                 } else {
                     // 不选和选硬币 i 这两种方案之和

File: codes/java/utils/PrintUtil.java
Patch:
@@ -58,7 +58,7 @@ public static void printTree(TreeNode root) {
     }
 
     /* Print a binary tree */
-    public static void printTree(TreeNode root, Trunk prev, boolean isLeft) {
+    public static void printTree(TreeNode root, Trunk prev, boolean isRight) {
         if (root == null) {
             return;
         }
@@ -70,7 +70,7 @@ public static void printTree(TreeNode root, Trunk prev, boolean isLeft) {
 
         if (prev == null) {
             trunk.str = "———";
-        } else if (isLeft) {
+        } else if (isRight) {
             trunk.str = "/———";
             prev_str = "   |";
         } else {

File: codes/java/chapter_backtracking/permutations_i.java
Patch:
@@ -19,7 +19,7 @@ public static void backtrack(List<Integer> state, int[] choices, boolean[] selec
         // 遍历所有选择
         for (int i = 0; i < choices.length; i++) {
             int choice = choices[i];
-            // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素
+            // 剪枝：不允许重复选择元素
             if (!selected[i]) {
                 // 尝试：做出选择，更新状态
                 selected[i] = true;

File: codes/java/chapter_computational_complexity/time_complexity.java
Patch:
@@ -107,8 +107,7 @@ static int logRecur(float n) {
     static int linearLogRecur(float n) {
         if (n <= 1)
             return 1;
-        int count = linearLogRecur(n / 2) +
-                linearLogRecur(n / 2);
+        int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
         for (int i = 0; i < n; i++) {
             count++;
         }

File: codes/java/chapter_hashing/hash_map_chaining.java
Patch:
@@ -21,7 +21,7 @@ class HashMapChaining {
     public HashMapChaining() {
         size = 0;
         capacity = 4;
-        loadThres = 2 / 3.0;
+        loadThres = 2.0 / 3.0;
         extendRatio = 2;
         buckets = new ArrayList<>(capacity);
         for (int i = 0; i < capacity; i++) {

File: codes/java/chapter_hashing/hash_map_open_addressing.java
Patch:
@@ -10,7 +10,7 @@
 class HashMapOpenAddressing {
     private int size; // 键值对数量
     private int capacity = 4; // 哈希表容量
-    private final double loadThres = 2.0 / 3; // 触发扩容的负载因子阈值
+    private final double loadThres = 2.0 / 3.0; // 触发扩容的负载因子阈值
     private final int extendRatio = 2; // 扩容倍数
     private Pair[] buckets; // 桶数组
     private final Pair TOMBSTONE = new Pair(-1, "-1"); // 删除标记

File: codes/java/chapter_stack_and_queue/linkedlist_queue.java
Patch:
@@ -55,7 +55,7 @@ public int pop() {
 
     /* 访问队首元素 */
     public int peek() {
-        if (size() == 0)
+        if (isEmpty())
             throw new IndexOutOfBoundsException();
         return front.val;
     }

File: codes/java/chapter_stack_and_queue/linkedlist_stack.java
Patch:
@@ -46,7 +46,7 @@ public int pop() {
 
     /* 访问栈顶元素 */
     public int peek() {
-        if (size() == 0)
+        if (isEmpty())
             throw new IndexOutOfBoundsException();
         return stackPeek.val;
     }

File: codes/java/chapter_backtracking/preorder_traversal_iii_compact.java
Patch:
@@ -24,8 +24,6 @@ static void preOrder(TreeNode root) {
         if (root.val == 7) {
             // 记录解
             res.add(new ArrayList<>(path));
-            path.remove(path.size() - 1);
-            return;
         }
         preOrder(root.left);
         preOrder(root.right);

File: codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java
Patch:
@@ -10,7 +10,7 @@ public class climbing_stairs_constraint_dp {
     /* 带约束爬楼梯：动态规划 */
     static int climbingStairsConstraintDP(int n) {
         if (n == 1 || n == 2) {
-            return n;
+            return 1;
         }
         // 初始化 dp 表，用于存储子问题的解
         int[][] dp = new int[n + 1][3];

File: codes/java/chapter_dynamic_programming/climbing_stairs_dp.java
Patch:
@@ -23,7 +23,7 @@ public static int climbingStairsDP(int n) {
         return dp[n];
     }
 
-    /* 爬楼梯：状态压缩后的动态规划 */
+    /* 爬楼梯：空间优化后的动态规划 */
     public static int climbingStairsDPComp(int n) {
         if (n == 1 || n == 2)
             return n;

File: codes/java/chapter_dynamic_programming/coin_change.java
Patch:
@@ -34,7 +34,7 @@ static int coinChangeDP(int[] coins, int amt) {
         return dp[n][amt] != MAX ? dp[n][amt] : -1;
     }
 
-    /* 零钱兑换：状态压缩后的动态规划 */
+    /* 零钱兑换：空间优化后的动态规划 */
     static int coinChangeDPComp(int[] coins, int amt) {
         int n = coins.length;
         int MAX = amt + 1;
@@ -65,7 +65,7 @@ public static void main(String[] args) {
         int res = coinChangeDP(coins, amt);
         System.out.println("凑到目标金额所需的最少硬币数量为 " + res);
 
-        // 状态压缩后的动态规划
+        // 空间优化后的动态规划
         res = coinChangeDPComp(coins, amt);
         System.out.println("凑到目标金额所需的最少硬币数量为 " + res);
     }

File: codes/java/chapter_dynamic_programming/coin_change_ii.java
Patch:
@@ -31,7 +31,7 @@ static int coinChangeIIDP(int[] coins, int amt) {
         return dp[n][amt];
     }
 
-    /* 零钱兑换 II：状态压缩后的动态规划 */
+    /* 零钱兑换 II：空间优化后的动态规划 */
     static int coinChangeIIDPComp(int[] coins, int amt) {
         int n = coins.length;
         // 初始化 dp 表
@@ -60,7 +60,7 @@ public static void main(String[] args) {
         int res = coinChangeIIDP(coins, amt);
         System.out.println("凑出目标金额的硬币组合数量为 " + res);
 
-        // 状态压缩后的动态规划
+        // 空间优化后的动态规划
         res = coinChangeIIDPComp(coins, amt);
         System.out.println("凑出目标金额的硬币组合数量为 " + res);
     }

File: codes/java/chapter_dynamic_programming/edit_distance.java
Patch:
@@ -83,7 +83,7 @@ static int editDistanceDP(String s, String t) {
         return dp[n][m];
     }
 
-    /* 编辑距离：状态压缩后的动态规划 */
+    /* 编辑距离：空间优化后的动态规划 */
     static int editDistanceDPComp(String s, String t) {
         int n = s.length(), m = t.length();
         int[] dp = new int[m + 1];
@@ -132,7 +132,7 @@ public static void main(String[] args) {
         res = editDistanceDP(s, t);
         System.out.println("将 " + s + " 更改为 " + t + " 最少需要编辑 " + res + " 步");
 
-        // 状态压缩后的动态规划
+        // 空间优化后的动态规划
         res = editDistanceDPComp(s, t);
         System.out.println("将 " + s + " 更改为 " + t + " 最少需要编辑 " + res + " 步");
     }

File: codes/java/chapter_dynamic_programming/knapsack.java
Patch:
@@ -69,7 +69,7 @@ static int knapsackDP(int[] wgt, int[] val, int cap) {
         return dp[n][cap];
     }
 
-    /* 0-1 背包：状态压缩后的动态规划 */
+    /* 0-1 背包：空间优化后的动态规划 */
     static int knapsackDPComp(int[] wgt, int[] val, int cap) {
         int n = wgt.length;
         // 初始化 dp 表
@@ -109,7 +109,7 @@ public static void main(String[] args) {
         res = knapsackDP(wgt, val, cap);
         System.out.println("不超过背包容量的最大物品价值为 " + res);
 
-        // 状态压缩后的动态规划
+        // 空间优化后的动态规划
         res = knapsackDPComp(wgt, val, cap);
         System.out.println("不超过背包容量的最大物品价值为 " + res);
     }

File: codes/java/chapter_dynamic_programming/min_cost_climbing_stairs_dp.java
Patch:
@@ -26,7 +26,7 @@ public static int minCostClimbingStairsDP(int[] cost) {
         return dp[n];
     }
 
-    /* 爬楼梯最小代价：状态压缩后的动态规划 */
+    /* 爬楼梯最小代价：空间优化后的动态规划 */
     public static int minCostClimbingStairsDPComp(int[] cost) {
         int n = cost.length - 1;
         if (n == 1 || n == 2)

File: codes/java/chapter_dynamic_programming/min_path_sum.java
Patch:
@@ -71,7 +71,7 @@ static int minPathSumDP(int[][] grid) {
         return dp[n - 1][m - 1];
     }
 
-    /* 最小路径和：状态压缩后的动态规划 */
+    /* 最小路径和：空间优化后的动态规划 */
     static int minPathSumDPComp(int[][] grid) {
         int n = grid.length, m = grid[0].length;
         // 初始化 dp 表
@@ -118,7 +118,7 @@ public static void main(String[] args) {
         res = minPathSumDP(grid);
         System.out.println("从左上角到右下角的做小路径和为 " + res);
 
-        // 状态压缩后的动态规划
+        // 空间优化后的动态规划
         res = minPathSumDPComp(grid);
         System.out.println("从左上角到右下角的做小路径和为 " + res);
     }

File: codes/java/chapter_dynamic_programming/unbounded_knapsack.java
Patch:
@@ -27,7 +27,7 @@ static int unboundedKnapsackDP(int[] wgt, int[] val, int cap) {
         return dp[n][cap];
     }
 
-    /* 完全背包：状态压缩后的动态规划 */
+    /* 完全背包：空间优化后的动态规划 */
     static int unboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {
         int n = wgt.length;
         // 初始化 dp 表
@@ -56,7 +56,7 @@ public static void main(String[] args) {
         int res = unboundedKnapsackDP(wgt, val, cap);
         System.out.println("不超过背包容量的最大物品价值为 " + res);
 
-        // 状态压缩后的动态规划
+        // 空间优化后的动态规划
         res = unboundedKnapsackDPComp(wgt, val, cap);
         System.out.println("不超过背包容量的最大物品价值为 " + res);
     }

File: codes/java/chapter_greedy/coin_change_greedy.java
Patch:
@@ -17,7 +17,7 @@ static int coinChangeGreedy(int[] coins, int amt) {
         // 循环进行贪心选择，直到无剩余金额
         while (amt > 0) {
             // 找到小于且最接近剩余金额的硬币
-            while (coins[i] > amt) {
+            while (i > 0 && coins[i] > amt) {
                 i--;
             }
             // 选择 coins[i]

File: codes/java/chapter_heap/top_k.java
Patch:
@@ -15,14 +15,14 @@ static Queue<Integer> topKHeap(int[] nums, int k) {
         Queue<Integer> heap = new PriorityQueue<Integer>();
         // 将数组的前 k 个元素入堆
         for (int i = 0; i < k; i++) {
-            heap.add(nums[i]);
+            heap.offer(nums[i]);
         }
         // 从第 k+1 个元素开始，保持堆的长度为 k
         for (int i = k; i < nums.length; i++) {
             // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆
             if (nums[i] > heap.peek()) {
                 heap.poll();
-                heap.add(nums[i]);
+                heap.offer(nums[i]);
             }
         }
         return heap;

File: codes/java/chapter_backtracking/preorder_traversal_iii_compact.java
Patch:
@@ -24,6 +24,7 @@ static void preOrder(TreeNode root) {
         if (root.val == 7) {
             // 记录解
             res.add(new ArrayList<>(path));
+            path.remove(path.size() - 1);
             return;
         }
         preOrder(root.left);
@@ -42,7 +43,7 @@ public static void main(String[] args) {
         res = new ArrayList<>();
         preOrder(root);
 
-        System.out.println("\n输出所有根节点到节点 7 的路径，且路径中不包含值为 3 的节点");
+        System.out.println("\n输出所有根节点到节点 7 的路径，路径中不包含值为 3 的节点，仅包含一个值为 7 的节点");
         for (List<TreeNode> path : res) {
             List<Integer> vals = new ArrayList<>();
             for (TreeNode node : path) {

File: codes/java/chapter_tree/binary_tree_bfs.java
Patch:
@@ -13,7 +13,8 @@ public class binary_tree_bfs {
     /* 层序遍历 */
     static List<Integer> levelOrder(TreeNode root) {
         // 初始化队列，加入根节点
-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
+        Queue<TreeNode> queue = new LinkedList<>();
+        queue.add(root);
         // 初始化一个列表，用于保存遍历序列
         List<Integer> list = new ArrayList<>();
         while (!queue.isEmpty()) {

File: codes/java/utils/TreeNode.java
Patch:
@@ -26,7 +26,8 @@ public static TreeNode listToTree(List<Integer> list) {
             return null;
 
         TreeNode root = new TreeNode(list.get(0));
-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
+        Queue<TreeNode> queue = new LinkedList<>();
+        queue.add(root);
         int i = 0;
         while (!queue.isEmpty()) {
             TreeNode node = queue.poll();
@@ -51,7 +52,7 @@ public static List<Integer> treeToList(TreeNode root) {
         List<Integer> list = new ArrayList<>();
         if (root == null)
             return list;
-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};
         while (!queue.isEmpty()) {
             TreeNode node = queue.poll();
             if (node != null) {

File: codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java
Patch:
@@ -12,7 +12,7 @@ static int climbingStairsConstraintDP(int n) {
         if (n == 1 || n == 2) {
             return n;
         }
-        // 初始化 dp 列表，用于存储子问题的解
+        // 初始化 dp 表，用于存储子问题的解
         int[][] dp = new int[n + 1][3];
         // 初始状态：预设最小子问题的解
         dp[1][1] = 1;

File: codes/java/chapter_dynamic_programming/climbing_stairs_dp.java
Patch:
@@ -11,7 +11,7 @@ public class climbing_stairs_dp {
     public static int climbingStairsDP(int n) {
         if (n == 1 || n == 2)
             return n;
-        // 初始化 dp 列表，用于存储子问题的解
+        // 初始化 dp 表，用于存储子问题的解
         int[] dp = new int[n + 1];
         // 初始状态：预设最小子问题的解
         dp[1] = 1;

File: codes/java/chapter_dynamic_programming/min_cost_climbing_stairs_dp.java
Patch:
@@ -14,7 +14,7 @@ public static int minCostClimbingStairsDP(int[] cost) {
         int n = cost.length - 1;
         if (n == 1 || n == 2)
             return cost[n];
-        // 初始化 dp 列表，用于存储子问题的解
+        // 初始化 dp 表，用于存储子问题的解
         int[] dp = new int[n + 1];
         // 初始状态：预设最小子问题的解
         dp[1] = cost[1];

File: codes/java/chapter_array_and_linkedlist/my_list.java
Patch:
@@ -88,7 +88,7 @@ public int remove(int index) {
 
     /* 列表扩容 */
     public void extendCapacity() {
-        // 新建一个长度为 size 的数组，并将原数组拷贝到新数组
+        // 新建一个长度为原数组 extendRatio 倍的新数组，并将原数组拷贝到新数组
         nums = Arrays.copyOf(nums, capacity() * extendRatio);
         // 更新列表容量
         capacity = nums.length;

File: codes/java/chapter_searching/binary_search.java
Patch:
@@ -45,7 +45,7 @@ else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中
 
     public static void main(String[] args) {
         int target = 6;
-        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 67, 70, 92 };
+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };
 
         /* 二分查找（双闭区间） */
         int index = binarySearch(nums, target);

File: codes/java/chapter_tree/binary_search_tree.java
Patch:
@@ -74,7 +74,7 @@ public void insert(int num) {
             else
                 cur = cur.left;
         }
-        // 插入节点 val
+        // 插入节点
         TreeNode node = new TreeNode(num);
         if (pre.val < num)
             pre.right = node;

File: codes/java/chapter_sorting/bucket_sort.java
Patch:
@@ -20,7 +20,7 @@ static void bucketSort(float[] nums) {
         // 1. 将数组元素分配到各个桶中
         for (float num : nums) {
             // 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]
-            int i = (int) num * k;
+            int i = (int) (num * k);
             // 将 num 添加进桶 i
             buckets.get(i).add(num);
         }

File: codes/java/chapter_hashing/array_hash_map.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: hash_map.java
+ * File: array_hash_map.java
  * Created Time: 2022-12-04
  * Author: Krahets (krahets@163.com)
  */

File: codes/java/chapter_sorting/counting_sort.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: coutning_sort.java
+ * File: counting_sort.java
  * Created Time: 2023-03-17
  * Author: Krahets (krahets@163.com)
  */

File: codes/java/chapter_backtracking/preorder_traversal_i_compact.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: preorder_find_nodes.java
+ * File: preorder_traversal_i_compact.java
  * Created Time: 2023-04-16
  * Author: Krahets (krahets@163.com)
  */
@@ -9,10 +9,10 @@
 import include.*;
 import java.util.*;
 
-public class preorder_find_nodes {
+public class preorder_traversal_i_compact {
     static List<TreeNode> res;
 
-    /* 前序遍历 */
+    /* 前序遍历：例题一 */
     static void preOrder(TreeNode root) {
         if (root == null) {
             return;

File: codes/java/chapter_backtracking/preorder_traversal_ii_compact.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: preorder_find_paths.java
+ * File: preorder_traversal_ii_compact.java
  * Created Time: 2023-04-16
  * Author: Krahets (krahets@163.com)
  */
@@ -9,11 +9,11 @@
 import include.*;
 import java.util.*;
 
-public class preorder_find_paths {
+public class preorder_traversal_ii_compact {
     static List<TreeNode> path;
     static List<List<TreeNode>> res;
 
-    /* 前序遍历 */
+    /* 前序遍历：例题二 */
     static void preOrder(TreeNode root) {
         if (root == null) {
             return;

File: codes/java/chapter_backtracking/preorder_traversal_iii_compact.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: preorder_find_constrained_paths.java
+ * File: preorder_traversal_iii_compact.java
  * Created Time: 2023-04-16
  * Author: Krahets (krahets@163.com)
  */
@@ -9,11 +9,11 @@
 import include.*;
 import java.util.*;
 
-public class preorder_find_constrained_paths {
+public class preorder_traversal_iii_compact {
     static List<TreeNode> path;
     static List<List<TreeNode>> res;
 
-    /* 前序遍历 */
+    /* 前序遍历：例题三 */
     static void preOrder(TreeNode root) {
         // 剪枝
         if (root == null || root.val == 3) {

File: codes/java/chapter_backtracking/preorder_traversal_iii_template.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: backtrack_find_constrained_paths.java
+ * File: preorder_traversal_iii_template.java
  * Created Time: 2023-04-16
  * Author: Krahets (krahets@163.com)
  */
@@ -9,7 +9,7 @@
 import include.*;
 import java.util.*;
 
-public class backtrack_find_constrained_paths {
+public class preorder_traversal_iii_template {
     /* 判断当前状态是否为解 */
     static boolean isSolution(List<TreeNode> state) {
         return !state.isEmpty() && state.get(state.size() - 1).val == 7;
@@ -35,7 +35,7 @@ static void undoChoice(List<TreeNode> state, TreeNode choice) {
         state.remove(state.size() - 1);
     }
 
-    /* 回溯算法 */
+    /* 回溯算法：例题三 */
     static void backtrack(List<TreeNode> state, List<TreeNode> choices, List<List<TreeNode>> res) {
         // 检查是否为解
         if (isSolution(state)) {

File: codes/java/chapter_backtracking/preorder_find_nodes.java
Patch:
@@ -15,15 +15,12 @@ static void preOrder(TreeNode root) {
         if (root == null) {
             return;
         }
-        // 尝试
         if (root.val == 7) {
             // 记录解
             res.add(root);
         }
         preOrder(root.left);
         preOrder(root.right);
-        // 回退
-        return;
     }
 
     public static void main(String[] args) {

File: codes/java/chapter_sorting/radix_sort.java
Patch:
@@ -16,7 +16,7 @@ static int digit(int num, int exp) {
     }
 
     /* 计数排序（根据 nums 第 k 位排序） */
-    static void countSort(int[] nums, int exp) {
+    static void countingSort(int[] nums, int exp) {
         // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶
         int[] bucket = new int[10];
         int n = nums.length;
@@ -55,7 +55,7 @@ static void radixSort(int[] nums) {
             // k = 2 -> exp = 10
             // k = 3 -> exp = 100
             // 即 exp = 10^(k-1)
-            countSort(nums, exp);
+            countingSort(nums, exp);
     }
 
     public static void main(String[] args) {

File: codes/java/chapter_stack_and_queue/array_deque.java
Patch:
@@ -116,7 +116,7 @@ public int[] toArray() {
 public class array_deque {
     public static void main(String[] args) {
         /* 初始化双向队列 */
-        LinkedListDeque deque = new LinkedListDeque();
+        ArrayDeque deque = new ArrayDeque(10);
         deque.pushLast(3);
         deque.pushLast(2);
         deque.pushLast(5);

File: codes/java/chapter_graph/graph_dfs.java
Patch:
@@ -43,7 +43,7 @@ public static void main(String[] args) {
         System.out.println("\n初始化后，图为");
         graph.print();
 
-        /* 深度优先遍历 BFS */
+        /* 深度优先遍历 DFS */
         List<Vertex> res = graphDFS(graph, v[0]);
         System.out.println("\n深度优先遍历（DFS）顶点序列为");
         System.out.println(Vertex.vetsToVals(res));

File: codes/java/chapter_graph/graph_adjacency_list.java
Patch:
@@ -11,7 +11,7 @@
 
 /* 基于邻接表实现的无向图类 */
 class GraphAdjList {
-    // 邻接表，key: 顶点，value：该顶点的所有邻接结点
+    // 邻接表，key: 顶点，value：该顶点的所有邻接顶点
     Map<Vertex, List<Vertex>> adjList;
 
     /* 构造方法 */

File: codes/java/chapter_sorting/quick_sort.java
Patch:
@@ -56,7 +56,7 @@ static void swap(int[] nums, int i, int j) {
 
     /* 选取三个元素的中位数 */
     static int medianThree(int[] nums, int left, int mid, int right) {
-        // 使用了异或操作来简化代码
+        // 此处使用异或运算来简化代码
         // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1
         if ((nums[left] < nums[mid]) ^ (nums[left] < nums[right]))
             return left;

File: codes/java/chapter_sorting/bubble_sort.java
Patch:
@@ -51,6 +51,6 @@ public static void main(String[] args) {
 
         int[] nums1 = { 4, 1, 3, 1, 5, 2 };
         bubbleSortWithFlag(nums1);
-        System.out.println("冒泡排序完成后 nums1 = " + Arrays.toString(nums));
+        System.out.println("冒泡排序完成后 nums1 = " + Arrays.toString(nums1));
     }
 }

File: codes/java/chapter_graph/graph_adjacency_matrix.java
Patch:
@@ -100,7 +100,7 @@ public static void main(String[] args) {
         /* 初始化无向图 */
         // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引
         int[] vertices = { 1, 3, 2, 5, 4 };
-        int[][] edges = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };
+        int[][] edges = { { 0, 1 }, { 0, 3 }, { 1, 2 }, { 2, 3 }, { 2, 4 }, { 3, 4 } };
         GraphAdjMat graph = new GraphAdjMat(vertices, edges);
         System.out.println("\n初始化后，图为");
         graph.print();

File: codes/java/chapter_array_and_linkedlist/my_list.java
Patch:
@@ -15,7 +15,7 @@ class MyList {
     private int size = 0;         // 列表长度（即当前元素数量）
     private int extendRatio = 2;  // 每次列表扩容的倍数
 
-    /* 构造函数 */
+    /* 构造方法 */
     public MyList() {
         nums = new int[capacity];
     }

File: codes/java/chapter_graph/graph_adjacency_list.java
Patch:
@@ -21,7 +21,7 @@ class GraphAdjList {
     // 请注意，vertices 和 adjList 中存储的都是 Vertex 对象
     Map<Vertex, Set<Vertex>> adjList; // 邻接表（使用哈希表实现）
 
-    /* 构造函数 */
+    /* 构造方法 */
     public GraphAdjList(Vertex[][] edges) {
         this.adjList = new HashMap<>();
         // 添加所有顶点和边

File: codes/java/chapter_graph/graph_adjacency_matrix.java
Patch:
@@ -14,7 +14,7 @@ class GraphAdjMat {
     List<Integer> vertices;     // 顶点列表，元素代表“顶点值”，索引代表“顶点索引”
     List<List<Integer>> adjMat; // 邻接矩阵，行列索引对应“顶点索引”
 
-    /* 构造函数 */
+    /* 构造方法 */
     public GraphAdjMat(int[] vertices, int[][] edges) {
         this.vertices = new ArrayList<>();
         this.adjMat = new ArrayList<>();

File: codes/java/chapter_heap/my_heap.java
Patch:
@@ -14,7 +14,7 @@ class MaxHeap {
     // 使用列表而非数组，这样无需考虑扩容问题
     private List<Integer> maxHeap;
 
-    /* 构造函数，根据输入列表建堆 */
+    /* 构造方法，根据输入列表建堆 */
     public MaxHeap(List<Integer> nums) {
         // 将列表元素原封不动添加进堆
         maxHeap = new ArrayList<>(nums);

File: codes/java/chapter_tree/avl_tree.java
Patch:
@@ -96,7 +96,7 @@ public TreeNode insert(int val) {
         return root;
     }
 
-    /* 递归插入结点（辅助函数） */
+    /* 递归插入结点（辅助方法） */
     private TreeNode insertHelper(TreeNode node, int val) {
         if (node == null) return new TreeNode(val);
         /* 1. 查找插入位置，并插入结点 */
@@ -119,7 +119,7 @@ public TreeNode remove(int val) {
         return root;
     }
 
-    /* 递归删除结点（辅助函数） */
+    /* 递归删除结点（辅助方法） */
     private TreeNode removeHelper(TreeNode node, int val) {
         if (node == null) return null;
         /* 1. 查找结点，并删除之 */

File: codes/java/chapter_graph/graph_adjacency_list.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * File: graph_adjacency_matrix.java
+ * File: graph_adjacency_list.java
  * Created Time: 2023-01-26
  * Author: Krahets (krahets@163.com)
  */

File: codes/java/chapter_graph/graph_adjacency_matrix.java
Patch:
@@ -100,7 +100,7 @@ public static void main(String[] args) {
         /* 初始化无向图 */
         // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引
         int[] vertices = { 1, 3, 2, 5, 4 };
-        int[][] edges = { { 0, 1 }, { 0, 2 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };
+        int[][] edges = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };
         GraphAdjMat graph = new GraphAdjMat(vertices, edges);
         System.out.println("\n初始化后，图为");
         graph.print();

File: codes/java/chapter_computational_complexity/space_complexity.java
Patch:
@@ -74,6 +74,7 @@ static void quadratic(int n) {
     /* 平方阶（递归实现） */
     static int quadraticRecur(int n) {
         if (n <= 0) return 0;
+        // 数组 nums 长度为 n, n-1, ..., 2, 1
         int[] nums = new int[n];
         System.out.println("递归 n = " + n + " 中的 nums 长度 = " + nums.length);
         return quadraticRecur(n - 1);

File: codes/java/chapter_sorting/quick_sort.java
Patch:
@@ -123,7 +123,7 @@ static int partition(int[] nums, int left, int right) {
     }
 
     /* 快速排序（尾递归优化） */
-    static void quickSort(int[] nums, int left, int right) {
+    public static void quickSort(int[] nums, int left, int right) {
         // 子数组长度为 1 时终止
         while (left < right) {
             // 哨兵划分操作

File: codes/java/chapter_tree/binary_tree_bfs.java
Patch:
@@ -18,7 +18,7 @@ static List<Integer> hierOrder(TreeNode root) {
         List<Integer> list = new ArrayList<>();
         while (!queue.isEmpty()) {
             TreeNode node = queue.poll();  // 队列出队
-            list.add(node.val);            // 保存结点
+            list.add(node.val);            // 保存结点值
             if (node.left != null)
                 queue.offer(node.left);    // 左子结点入队
             if (node.right != null)

File: codes/java/chapter_stack_and_queue/linkedlist_deque.java
Patch:
@@ -144,7 +144,7 @@ public static void main(String[] args) {
         deque.pushLast(3);
         deque.pushLast(2);
         deque.pushLast(5);
-        System.out.print("双点队列 deque = ");
+        System.out.print("双向队列 deque = ");
         deque.print();
 
         /* 访问元素 */

File: codes/java/chapter_tree/binary_tree_bfs.java
Patch:
@@ -13,7 +13,7 @@ public class binary_tree_bfs {
     /* 层序遍历 */
     static List<Integer> hierOrder(TreeNode root) {
         // 初始化队列，加入根结点
-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};
         // 初始化一个列表，用于保存遍历序列
         List<Integer> list = new ArrayList<>();
         while (!queue.isEmpty()) {

File: codes/java/include/TreeNode.java
Patch:
@@ -32,7 +32,7 @@ public static TreeNode listToTree(List<Integer> list) {
             return null;
         
         TreeNode root = new TreeNode(list.get(0));
-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};
         int i = 0;
         while(!queue.isEmpty()) {
             TreeNode node = queue.poll();
@@ -58,7 +58,7 @@ public static TreeNode listToTree(List<Integer> list) {
     public static List<Integer> treeToList(TreeNode root) {
         List<Integer> list = new ArrayList<>();
         if(root == null) return list;
-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};
         while(!queue.isEmpty()) {
             TreeNode node = queue.poll();
             if(node != null) {

File: codes/java/chapter_tree/binary_tree_dfs.java
Patch:
@@ -43,7 +43,7 @@ static void postOrder(TreeNode root) {
     public static void main(String[] args) {
         /* 初始化二叉树 */
         // 这里借助了一个从数组直接生成二叉树的函数
-        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, null, 3, 4, 5 });
+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
         System.out.println("\n初始化二叉树\n");
         PrintUtil.printTree(root);
 

File: codes/java/chapter_sorting/merge_sort.java
Patch:
@@ -25,13 +25,13 @@ static void merge(int[] nums, int left, int mid, int right) {
         int i = leftStart, j = rightStart;                
         // 通过覆盖原数组 nums 来合并左子数组和右子数组
         for (int k = left; k <= right; k++) {
-            // 若 “左子数组已全部合并完”，则选取右子数组元素，并且 j++
+            // 若“左子数组已全部合并完”，则选取右子数组元素，并且 j++
             if (i > leftEnd)
                 nums[k] = tmp[j++];
-            // 否则，若 “右子数组已全部合并完” 或 “左子数组元素 < 右子数组元素”，则选取左子数组元素，并且 i++
+            // 否则，若“右子数组已全部合并完”或“左子数组元素 < 右子数组元素”，则选取左子数组元素，并且 i++
             else if (j > rightEnd || tmp[i] <= tmp[j])
                 nums[k] = tmp[i++];
-            // 否则，若 “左子数组元素 > 右子数组元素”，则选取右子数组元素，并且 j++
+            // 否则，若“左子数组元素 > 右子数组元素”，则选取右子数组元素，并且 j++
             else
                 nums[k] = tmp[j++];
         }

File: codes/java/chapter_array_and_linkedlist/array.java
Patch:
@@ -35,7 +35,7 @@ static int[] extend(int[] nums, int enlarge) {
     /* 在数组的索引 index 处插入元素 num */
     static void insert(int[] nums, int num, int index) {
         // 把索引 index 以及之后的所有元素向后移动一位
-        for (int i = nums.length - 1; i >= index; i--) {
+        for (int i = nums.length - 1; i > index; i--) {
             nums[i] = nums[i - 1];
         }
         // 将 num 赋给 index 处元素

File: codes/java/chapter_stack_and_queue/linkedlist_queue.java
Patch:
@@ -57,7 +57,7 @@ public int poll() {
     /* 访问队首元素 */
     public int peek() {
         if (size() == 0)
-            throw new IndexOutOfBoundsException();
+            throw new EmptyStackException();
         return front.val;
     }
 

File: codes/java/chapter_stack_and_queue/linkedlist_stack.java
Patch:
@@ -47,7 +47,7 @@ public int pop() {
     /* 访问栈顶元素 */
     public int peek() {
         if (size() == 0)
-            throw new IndexOutOfBoundsException();
+            throw new EmptyStackException();
         return stackPeek.val;
     }
 

File: codes/java/include/TreeNode.java
Patch:
@@ -26,6 +26,9 @@ public TreeNode(int x) {
      * @return
      */
     public static TreeNode arrToTree(Integer[] arr) {
+        if (arr.length == 0)
+            return null;
+        
         TreeNode root = new TreeNode(arr[0]);
         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
         int i = 1;

File: codes/java/chapter_computational_complexity/leetcode_two_sum.java
Patch:
@@ -48,10 +48,10 @@ public static void main(String[] args) {
         // 方法一
         SolutionBruteForce slt1 = new SolutionBruteForce();
         int[] res = slt1.twoSum(nums, target);
-        System.out.println(Arrays.toString(res));
+        System.out.println("方法一 res = " + Arrays.toString(res));
         // 方法二
         SolutionHashMap slt2 = new SolutionHashMap();
         res = slt2.twoSum(nums, target);
-        System.out.println(Arrays.toString(res));
+        System.out.println("方法二 res = " + Arrays.toString(res));
     }
 }

