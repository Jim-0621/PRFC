File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -4775,7 +4775,7 @@ public void testBufferUnderflowPacketSizeDependency(SSLEngineTestParam param) th
 
             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
             fail();
-        } catch (SSLHandshakeException expected) {
+        } catch (SSLException expected) {
             // Expected
         } finally {
             cleanupClientSslEngine(clientEngine);

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -23,8 +23,8 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.lang.ref.WeakReference;
 import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Collections;
@@ -415,6 +415,8 @@ private static final class DefaultResourceLeak<T>
 
             assert referent != null;
 
+            this.allLeaks = allLeaks;
+
             // Store the hash of the tracked object to later assert it in the close(...) method.
             // It's important that we not store a reference to the referent as this would disallow it from
             // be collected via the WeakReference.
@@ -423,7 +425,6 @@ private static final class DefaultResourceLeak<T>
             // Create a new Record so we always have the creation stacktrace included.
             headUpdater.set(this, initialHint == null ?
                     new TraceRecord(TraceRecord.BOTTOM) : new TraceRecord(TraceRecord.BOTTOM, initialHint));
-            this.allLeaks = allLeaks;
         }
 
         @Override

File: handler/src/test/java/io/netty/handler/pcap/PcapWriteHandlerTest.java
Patch:
@@ -555,7 +555,6 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
             assertTrue(clientChannelFuture.isSuccess());
 
             InetSocketAddress clientAddress = (InetSocketAddress) clientChannelFuture.channel().localAddress();
-            System.err.println(clientAddress);
 
             assertTrue(serverLatch.await(5, TimeUnit.SECONDS));
             assertTrue(clientLatch.await(5, TimeUnit.SECONDS));

File: buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java
Patch:
@@ -109,7 +109,7 @@ enum MagazineCaching {
      * This means the maximum amount of memory that we can have allocated-but-not-in-use is
      * 5 * {@link NettyRuntime#availableProcessors()} * {@link #MAX_CHUNK_SIZE} bytes.
      */
-    private static final int CENTRAL_QUEUE_CAPACITY = Math.min(2, SystemPropertyUtil.getInt(
+    private static final int CENTRAL_QUEUE_CAPACITY = Math.max(2, SystemPropertyUtil.getInt(
             "io.netty.allocator.centralQueueCapacity", NettyRuntime.availableProcessors()));
 
     /**

File: handler/src/main/java/io/netty/handler/pcap/TCPPacket.java
Patch:
@@ -36,13 +36,13 @@ private TCPPacket() {
      * @param srcPort Source Port
      * @param dstPort Destination Port
      */
-    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort,
+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, long segmentNumber, long ackNumber, int srcPort,
                             int dstPort, TCPFlag... tcpFlags) {
 
         byteBuf.writeShort(srcPort);     // Source Port
         byteBuf.writeShort(dstPort);     // Destination Port
-        byteBuf.writeInt(segmentNumber); // Segment Number
-        byteBuf.writeInt(ackNumber);     // Acknowledgment Number
+        byteBuf.writeInt((int) segmentNumber); // Segment Number
+        byteBuf.writeInt((int) ackNumber);     // Acknowledgment Number
         byteBuf.writeShort(OFFSET | TCPFlag.getFlag(tcpFlags)); // Flags
         byteBuf.writeShort(65535);       // Window Size
         byteBuf.writeShort(0x0001);      // Checksum

File: buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java
Patch:
@@ -109,8 +109,8 @@ enum MagazineCaching {
      * This means the maximum amount of memory that we can have allocated-but-not-in-use is
      * 5 * {@link NettyRuntime#availableProcessors()} * {@link #MAX_CHUNK_SIZE} bytes.
      */
-    private static final int CENTRAL_QUEUE_CAPACITY = SystemPropertyUtil.getInt(
-            "io.netty.allocator.centralQueueCapacity", NettyRuntime.availableProcessors());
+    private static final int CENTRAL_QUEUE_CAPACITY = Math.min(2, SystemPropertyUtil.getInt(
+            "io.netty.allocator.centralQueueCapacity", NettyRuntime.availableProcessors()));
 
     /**
      * The capacity if the magazine local buffer queue. This queue just pools the outer ByteBuf instance and not

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -454,7 +454,7 @@ private void protocolViolation(ChannelHandlerContext ctx, ByteBuf in, CorruptedW
 
     private static int toFrameLength(long l) {
         if (l > Integer.MAX_VALUE) {
-            throw new TooLongFrameException("Length:" + l);
+            throw new TooLongFrameException("frame length exceeds " + Integer.MAX_VALUE + ": " + l);
         } else {
             return (int) l;
         }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -363,7 +363,8 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
             if (content.readableBytes() > maxContentLength - spdyDataFrame.content().readableBytes()) {
                 removeMessage(streamId);
                 throw new TooLongFrameException(
-                        "HTTP content length exceeded " + maxContentLength + " bytes.");
+                        "HTTP content length exceeded " + maxContentLength + " bytes: "
+                                + spdyDataFrame.content().readableBytes());
             }
 
             ByteBuf spdyDataFrameData = spdyDataFrame.content();

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -99,8 +99,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
                 variableHeader = decodeVariableHeader(ctx, buffer, mqttFixedHeader);
                 if (bytesRemainingBeforeVariableHeader > maxBytesInMessage) {
                     buffer.skipBytes(actualReadableBytes());
-                    throw new TooLongFrameException(
-                            "too large message: " + bytesRemainingBeforeVariableHeader + " bytes");
+                    throw new TooLongFrameException("message length exceeds " + maxBytesInMessage + ": "
+                            + bytesRemainingBeforeVariableHeader);
                 }
                 checkpoint(DecoderState.READ_PAYLOAD);
                 // fall through

File: codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.mqtt.MqttReasonCodes.PubAck;
 import io.netty.util.Attribute;
 import io.netty.util.CharsetUtil;
@@ -1100,9 +1101,7 @@ private static void validateDecoderExceptionTooLargeMessage(MqttMessage message)
         assertNull(message.payload());
         assertTrue(message.decoderResult().isFailure());
         Throwable cause = message.decoderResult().cause();
-        assertThat(cause, instanceOf(DecoderException.class));
-
-        assertTrue(cause.getMessage().contains("too large message:"));
+        assertThat(cause, instanceOf(TooLongFrameException.class));
     }
 
     private static void validatePubReplyVariableHeader(

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java
Patch:
@@ -18,7 +18,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.buffer.ByteBufUtil;
 
 /**
  * See <a href="https://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#publish">MQTTV3.1/publish</a>
@@ -44,7 +43,7 @@ public ByteBuf payload() {
 
     @Override
     public ByteBuf content() {
-        return ByteBufUtil.ensureAccessible((ByteBuf) super.payload());
+        return (ByteBuf) super.payload();
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValidationUtil.java
Patch:
@@ -128,8 +128,8 @@ private static int verifyValidHeaderValueAsciiString(AsciiString value) {
         if (b < 0x21 || b == 0x7F) {
             return 0;
         }
-        int length = value.length();
-        for (int i = start + 1; i < length; i++) {
+        int end = start + value.length();
+        for (int i = start + 1; i < end; i++) {
             b = array[i] & 0xFF;
             if (b < 0x20 && b != 0x09 || b == 0x7F) {
                 return i - start;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -91,7 +91,7 @@ public SpdyFrameDecoder(SpdyVersion spdyVersion, SpdyFrameDecoderDelegate delega
      * Creates a new instance with the specified parameters.
      */
     public SpdyFrameDecoder(SpdyVersion spdyVersion, SpdyFrameDecoderDelegate delegate, int maxChunkSize) {
-        this.spdyVersion = ObjectUtil.checkNotNull(spdyVersion, "spdyVersion").getVersion();
+        this.spdyVersion = ObjectUtil.checkNotNull(spdyVersion, "spdyVersion").version();
         this.delegate = ObjectUtil.checkNotNull(delegate, "delegate");
         this.maxChunkSize = ObjectUtil.checkPositive(maxChunkSize, "maxChunkSize");
         state = State.READ_COMMON_HEADER;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -35,7 +35,7 @@ public class SpdyFrameEncoder {
      * Creates a new instance with the specified {@code spdyVersion}.
      */
     public SpdyFrameEncoder(SpdyVersion spdyVersion) {
-        version = ObjectUtil.checkNotNull(spdyVersion, "spdyVersion").getVersion();
+        version = ObjectUtil.checkNotNull(spdyVersion, "spdyVersion").version();
     }
 
     protected void writeControlFrameHeader(ByteBuf buffer, int type, byte flags, int length) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
Patch:
@@ -30,7 +30,7 @@ public class SpdyHeaderBlockRawEncoder extends SpdyHeaderBlockEncoder {
     private final int version;
 
     public SpdyHeaderBlockRawEncoder(SpdyVersion version) {
-        this.version = ObjectUtil.checkNotNull(version, "version").getVersion();
+        this.version = ObjectUtil.checkNotNull(version, "version").version();
     }
 
     private static void setLengthField(ByteBuf buffer, int writerIndex, int length) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -131,7 +131,7 @@ protected SpdyHttpDecoder(SpdyVersion version, int maxContentLength, Map<Integer
      */
     protected SpdyHttpDecoder(SpdyVersion version, int maxContentLength, Map<Integer,
             FullHttpMessage> messageMap, HttpHeadersFactory headersFactory, HttpHeadersFactory trailersFactory) {
-        spdyVersion = ObjectUtil.checkNotNull(version, "version").getVersion();
+        spdyVersion = ObjectUtil.checkNotNull(version, "version").version();
         this.maxContentLength = checkPositive(maxContentLength, "maxContentLength");
         this.messageMap = messageMap;
         this.headersFactory = headersFactory;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -70,7 +70,7 @@ public class SpdySessionHandler extends ChannelDuplexHandler {
      *                handle the client endpoint of the connection.
      */
     public SpdySessionHandler(SpdyVersion version, boolean server) {
-        this.minorVersion = ObjectUtil.checkNotNull(version, "version").getMinorVersion();
+        this.minorVersion = ObjectUtil.checkNotNull(version, "version").minorVersion();
         this.server = server;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyVersion.java
Patch:
@@ -26,11 +26,11 @@ public enum SpdyVersion {
         this.minorVersion = minorVersion;
     }
 
-    public int getVersion() {
+    public int version() {
         return version;
     }
 
-    public int getMinorVersion() {
+    public int minorVersion() {
         return minorVersion;
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
Patch:
@@ -147,7 +147,7 @@ private static void encodeDataFrameHeader(ByteBuf buffer, int streamId, byte fla
     }
 
     private static void encodeControlFrameHeader(ByteBuf buffer, short type, byte flags, int length) {
-        buffer.writeShort(0x8000 | SpdyVersion.SPDY_3_1.getVersion());
+        buffer.writeShort(0x8000 | SpdyVersion.SPDY_3_1.version());
         buffer.writeShort(type);
         buffer.writeByte(flags);
         buffer.writeMedium(length);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -88,7 +88,7 @@
  * {@link Http2ChannelDuplexHandler#newStream()}, and then writing a {@link Http2HeadersFrame} object with the stream
  * attached.
  *
- * <pre>
+ * <pre> {@code
  *     final Http2Stream2 stream = handler.newStream();
  *     ctx.write(headersFrame.stream(stream)).addListener(new ChannelFutureListener() {
  *
@@ -109,6 +109,7 @@
  *             }
  *         }
  *     }
+ *     }
  * </pre>
  *
  * <p>If a new stream cannot be created due to stream id exhaustion of the endpoint, the {@link ChannelPromise} of the

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -154,7 +154,7 @@ public final class OpenSsl {
             boolean useKeyManagerFactory = false;
             boolean tlsv13Supported = false;
             String[] namedGroups = DEFAULT_NAMED_GROUPS;
-            Set<String> defaultConvertedNamedGroups = new HashSet<String>(namedGroups.length);
+            Set<String> defaultConvertedNamedGroups = new LinkedHashSet<String>(namedGroups.length);
             for (int i = 0; i < namedGroups.length; i++) {
                 defaultConvertedNamedGroups.add(GroupsConverter.toOpenSsl(namedGroups[i]));
             }

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -283,8 +283,8 @@ public final class OpenSsl {
                             } catch (Throwable ignore) {
                                 logger.debug("Failed to get useKeyManagerFactory system property.");
                             }
-                        } catch (Error ignore) {
-                            logger.debug("KeyManagerFactory not supported.");
+                        } catch (Exception e) {
+                            logger.debug("KeyManagerFactory not supported", e);
                         } finally {
                             privateKey.release();
                         }

File: microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmarkBase.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 import org.junit.jupiter.api.Test;
 import org.openjdk.jmh.annotations.Measurement;
@@ -38,8 +39,8 @@
 /**
  * Base class for all JMH benchmarks.
  */
-@Warmup(iterations = AbstractMicrobenchmarkBase.DEFAULT_WARMUP_ITERATIONS)
-@Measurement(iterations = AbstractMicrobenchmarkBase.DEFAULT_MEASURE_ITERATIONS)
+@Warmup(iterations = AbstractMicrobenchmarkBase.DEFAULT_WARMUP_ITERATIONS, time = 1, timeUnit = TimeUnit.SECONDS)
+@Measurement(iterations = AbstractMicrobenchmarkBase.DEFAULT_MEASURE_ITERATIONS, time = 1, timeUnit = TimeUnit.SECONDS)
 @State(Scope.Thread)
 public abstract class AbstractMicrobenchmarkBase {
     protected static final int DEFAULT_WARMUP_ITERATIONS = 10;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -104,7 +104,7 @@ public DefaultHttp2ConnectionDecoder(Http2Connection connection,
                                          Http2PromisedRequestVerifier requestVerifier,
                                          boolean autoAckSettings,
                                          boolean autoAckPing) {
-        this(connection, encoder, frameReader, requestVerifier, autoAckSettings, true, true);
+        this(connection, encoder, frameReader, requestVerifier, autoAckSettings, autoAckPing, true);
     }
 
     /**

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1488,7 +1488,7 @@ private int unwrap(ChannelHandlerContext ctx, ByteBuf packet, int length) throws
                 if (handshakeStatus == HandshakeStatus.FINISHED || handshakeStatus == HandshakeStatus.NOT_HANDSHAKING) {
                     wrapLater |= (decodeOut.isReadable() ?
                             setHandshakeSuccessUnwrapMarkReentry() : setHandshakeSuccess()) ||
-                            handshakeStatus == HandshakeStatus.FINISHED;
+                            handshakeStatus == HandshakeStatus.FINISHED || !pendingUnencryptedWrites.isEmpty();
                 }
 
                 // Dispatch decoded data after we have notified of handshake success. If this method has been invoked

File: resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.AddressedEnvelope;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
 import io.netty.handler.codec.dns.DatagramDnsQuery;
 import io.netty.handler.codec.dns.DnsQuery;
 import io.netty.handler.codec.dns.DnsQuestion;
@@ -30,15 +31,15 @@
 
 final class DatagramDnsQueryContext extends DnsQueryContext {
 
-    DatagramDnsQueryContext(Channel channel, Future<? extends Channel> channelReadyFuture,
+    DatagramDnsQueryContext(Channel channel,
                             InetSocketAddress nameServerAddr,
                             DnsQueryContextManager queryContextManager,
                             int maxPayLoadSize, boolean recursionDesired,
                             long queryTimeoutMillis,
                             DnsQuestion question, DnsRecord[] additionals,
                             Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise,
                             Bootstrap socketBootstrap, boolean retryWithTcpOnTimeout) {
-        super(channel, channelReadyFuture, nameServerAddr, queryContextManager, maxPayLoadSize, recursionDesired,
+        super(channel, nameServerAddr, queryContextManager, maxPayLoadSize, recursionDesired,
                 queryTimeoutMillis, question, additionals, promise, socketBootstrap, retryWithTcpOnTimeout);
     }
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.channel.AddressedEnvelope;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
 import io.netty.handler.codec.dns.DefaultDnsQuery;
 import io.netty.handler.codec.dns.DnsQuery;
 import io.netty.handler.codec.dns.DnsQuestion;
@@ -29,14 +30,14 @@
 
 final class TcpDnsQueryContext extends DnsQueryContext {
 
-    TcpDnsQueryContext(Channel channel, Future<? extends Channel> channelReadyFuture,
+    TcpDnsQueryContext(Channel channel,
                        InetSocketAddress nameServerAddr,
                        DnsQueryContextManager queryContextManager,
                        int maxPayLoadSize, boolean recursionDesired,
                        long queryTimeoutMillis,
                        DnsQuestion question, DnsRecord[] additionals,
                        Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {
-        super(channel, channelReadyFuture, nameServerAddr, queryContextManager, maxPayLoadSize, recursionDesired,
+        super(channel, nameServerAddr, queryContextManager, maxPayLoadSize, recursionDesired,
                 // No retry via TCP.
                 queryTimeoutMillis, question, additionals, promise, null, false);
     }

File: handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspServerCertificateValidator.java
Patch:
@@ -122,7 +122,7 @@ public OcspServerCertificateValidator(boolean closeAndThrowIfNotValid, boolean v
     protected static DnsNameResolver createDefaultResolver(final IoTransport ioTransport) {
         return new DnsNameResolverBuilder()
                 .eventLoop(ioTransport.eventLoop())
-                .channelFactory(ioTransport.datagramChannel())
+                .datagramChannelFactory(ioTransport.datagramChannel())
                 .socketChannelFactory(ioTransport.socketChannel())
                 .build();
     }

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java
Patch:
@@ -44,7 +44,7 @@ public void testUseConfiguredEventLoop() throws InterruptedException {
         final EventLoop loop = group.next();
         DefaultEventLoopGroup defaultEventLoopGroup = new DefaultEventLoopGroup(1);
         DnsNameResolverBuilder builder = new DnsNameResolverBuilder()
-                .eventLoop(loop).channelType(NioDatagramChannel.class);
+                .eventLoop(loop).datagramChannelType(NioDatagramChannel.class);
         DnsAddressResolverGroup resolverGroup = new DnsAddressResolverGroup(builder);
         try {
             final Promise<?> promise = loop.newPromise();
@@ -77,7 +77,7 @@ public void testSharedDNSCacheAcrossEventLoops() throws InterruptedException, Ex
         NioEventLoopGroup group = new NioEventLoopGroup(1);
         final EventLoop loop = group.next();
         DnsNameResolverBuilder builder = new DnsNameResolverBuilder()
-                .eventLoop(loop).channelType(NioDatagramChannel.class);
+                .eventLoop(loop).datagramChannelType(NioDatagramChannel.class);
         DnsAddressResolverGroup resolverGroup = new DnsAddressResolverGroup(builder);
         DefaultEventLoopGroup defaultEventLoopGroup = new DefaultEventLoopGroup(2);
         EventLoop eventLoop1 = defaultEventLoopGroup.next();

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverBuilderTest.java
Patch:
@@ -40,7 +40,7 @@ class DnsNameResolverBuilderTest {
 
     @BeforeEach
     void setUp() {
-        builder = new DnsNameResolverBuilder(GROUP.next()).channelType(NioDatagramChannel.class);
+        builder = new DnsNameResolverBuilder(GROUP.next()).datagramChannelType(NioDatagramChannel.class);
     }
 
     @AfterEach

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java
Patch:
@@ -59,7 +59,7 @@ public void testSubnetQuery() throws Exception {
 
     private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {
         return new DnsNameResolverBuilder(group.next())
-                .channelType(NioDatagramChannel.class)
+                .datagramChannelType(NioDatagramChannel.class)
                 .nameServerProvider(
                         new SingletonDnsServerAddressStreamProvider(SocketUtils.socketAddress("8.8.8.8", 53)))
                 .maxQueriesPerResolve(1)

File: resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
Patch:
@@ -45,7 +45,7 @@ public class SearchDomainTest {
 
     private DnsNameResolverBuilder newResolver() {
         return new DnsNameResolverBuilder(group.next())
-            .channelType(NioDatagramChannel.class)
+            .datagramChannelType(NioDatagramChannel.class)
             .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress()))
             .maxQueriesPerResolve(1)
             .optResourceEnabled(false)

File: transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java
Patch:
@@ -413,7 +413,7 @@ public void testUnixResolverDnsServerAddressStreamProvider_ParseEtcResolverSearc
         NioEventLoopGroup group = new NioEventLoopGroup();
         try {
             DnsNameResolverBuilder builder = new DnsNameResolverBuilder(group.next())
-                    .channelFactory(NioDatagramChannel::new);
+                    .datagramChannelFactory(NioDatagramChannel::new);
             doTestParseResolverFilesAllowsBlockingCalls(builder::build);
         } finally {
             group.shutdownGracefully();

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -29,6 +29,7 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -43,6 +44,7 @@
 public final class DnsNameResolverBuilder {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsNameResolverBuilder.class);
+    static final SocketAddress DEFAULT_LOCAL_ADDRESS = new InetSocketAddress(0);
 
     volatile EventLoop eventLoop;
     private ChannelFactory<? extends DatagramChannel> channelFactory;
@@ -52,7 +54,7 @@ public final class DnsNameResolverBuilder {
     private DnsCache resolveCache;
     private DnsCnameCache cnameCache;
     private AuthoritativeDnsServerCache authoritativeDnsServerCache;
-    private SocketAddress localAddress;
+    private SocketAddress localAddress = DEFAULT_LOCAL_ADDRESS;
     private Integer minTtl;
     private Integer maxTtl;
     private Integer negativeTtl;

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieDecoder.java
Patch:
@@ -45,7 +45,7 @@ public final class ServerCookieDecoder extends CookieDecoder {
     private static final String RFC2965_PORT = "$Port";
 
     /**
-     * Strict encoder that validates that name and value chars are in the valid scope
+     * Strict decoder that validates that name and value chars are in the valid scope
      * defined in RFC6265
      */
     public static final ServerCookieDecoder STRICT = new ServerCookieDecoder(true);

File: transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
Patch:
@@ -362,6 +362,7 @@ public void testAsyncResolutionFailure() throws Exception {
         // Should fail with the UnknownHostException.
         assertThat(connectFuture.await(10000), is(true));
         assertThat(connectFuture.cause(), is(instanceOf(UnknownHostException.class)));
+        connectFuture.channel().closeFuture().await(10000);
         assertThat(connectFuture.channel().isOpen(), is(false));
     }
 
@@ -394,6 +395,7 @@ protected AddressResolver<SocketAddress> newResolver(EventExecutor executor) {
         assertThat(connectFuture.await(10000), is(true));
         assertThat(connectFuture.cause(), instanceOf(IllegalStateException.class));
         assertThat(connectFuture.cause().getCause(), instanceOf(TestException.class));
+        connectFuture.channel().closeFuture().await(10000);
         assertThat(connectFuture.channel().isOpen(), is(false));
     }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientSessionCache.java
Patch:
@@ -99,7 +99,7 @@ boolean setSession(long ssl, OpenSslSession session, String host, int port) {
                     if (toBeRemoved == null) {
                         toBeRemoved = new ArrayList<NativeSslSession>(2);
                     }
-                    toBeRemoved.add(nativeSslSession);
+                    toBeRemoved.add(sslSession);
                 }
             }
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -484,7 +484,6 @@ private static int decodeMessageId(ByteBuf buffer) {
      *
      * @param buffer the buffer to decode from
      * @param messageType  type of the message being decoded
-     * @param bytesRemainingInVariablePart bytes remaining
      * @param variableHeader variable header of the same message
      * @return the payload
      */
@@ -515,7 +514,7 @@ private Object decodePayload(
 
             default:
                 // unknown payload , no byte consumed
-                return new Result<Object>(null, 0);
+                return null;
         }
     }
 

File: handler/src/test/java/io/netty/handler/ssl/CloseNotifyTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.ssl.util.CachedSelfSignedCertificate;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import org.junit.jupiter.api.Timeout;
@@ -146,7 +147,7 @@ private static boolean jdkTls13(SslProvider provider, String protocol) {
     private static EmbeddedChannel initChannel(SslProvider provider, String protocol, final boolean useClientMode,
             final BlockingQueue<Object> eventQueue) throws Exception {
 
-        SelfSignedCertificate ssc = new SelfSignedCertificate();
+        SelfSignedCertificate ssc = CachedSelfSignedCertificate.getCachedCertificate();
         final SslContext sslContext = (useClientMode
                 ? SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE)
                 : SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()))

File: handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;
 import io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelector;
 import io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelectorFactory;
+import io.netty.handler.ssl.util.CachedSelfSignedCertificate;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import java.security.Provider;
@@ -224,7 +225,7 @@ public void testTlsExtensionNoCompatibleProtocolsClientHandshakeFailure(JdkSSLEn
                 assertTrue(clientException instanceof SSLHandshakeException);
             } else {
                 // ALPN
-                SelfSignedCertificate ssc = new SelfSignedCertificate();
+                SelfSignedCertificate ssc = CachedSelfSignedCertificate.getCachedCertificate();
                 JdkApplicationProtocolNegotiator clientApn = new JdkAlpnApplicationProtocolNegotiator(true, true,
                     PREFERRED_APPLICATION_LEVEL_PROTOCOL);
                 JdkApplicationProtocolNegotiator serverApn = new JdkAlpnApplicationProtocolNegotiator(

File: handler/src/test/java/io/netty/handler/ssl/RenegotiateTest.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
+import io.netty.handler.ssl.util.CachedSelfSignedCertificate;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.util.ReferenceCountUtil;
@@ -45,7 +46,7 @@ public abstract class RenegotiateTest {
     public void testRenegotiateServer() throws Throwable {
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
         final CountDownLatch latch = new CountDownLatch(2);
-        SelfSignedCertificate cert = new SelfSignedCertificate();
+        SelfSignedCertificate cert = CachedSelfSignedCertificate.getCachedCertificate();
         EventLoopGroup group = new LocalEventLoopGroup();
         try {
             final SslContext context = SslContextBuilder.forServer(cert.key(), cert.cert())

File: handler/src/test/java/io/netty/handler/ssl/SniClientJava8TestUtil.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
+import io.netty.handler.ssl.util.CachedSelfSignedCertificate;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.handler.ssl.util.SimpleTrustManagerFactory;
@@ -81,7 +82,7 @@ private SniClientJava8TestUtil() { }
     static void testSniClient(SslProvider sslClientProvider, SslProvider sslServerProvider, final boolean match)
             throws Exception {
         final String sniHost = "sni.netty.io";
-        SelfSignedCertificate cert = new SelfSignedCertificate();
+        SelfSignedCertificate cert = CachedSelfSignedCertificate.getCachedCertificate();
         LocalAddress address = new LocalAddress("test");
         EventLoopGroup group = new DefaultEventLoopGroup(1);
         SslContext sslServerContext = null;
@@ -164,8 +165,6 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
             ReferenceCountUtil.release(sslServerContext);
             ReferenceCountUtil.release(sslClientContext);
 
-            cert.delete();
-
             group.shutdownGracefully();
         }
     }

File: handler/src/test/java/io/netty/handler/ssl/SniClientTest.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
+import io.netty.handler.ssl.util.CachedSelfSignedCertificate;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.util.Mapping;
@@ -99,7 +100,7 @@ public void testSniClient(SslProvider sslServerProvider, SslProvider sslClientPr
         String sniHostName = "sni.netty.io";
         LocalAddress address = new LocalAddress("SniClientTest");
         EventLoopGroup group = new DefaultEventLoopGroup(1);
-        SelfSignedCertificate cert = new SelfSignedCertificate();
+        SelfSignedCertificate cert = CachedSelfSignedCertificate.getCachedCertificate();
         SslContext sslServerContext = null;
         SslContext sslClientContext = null;
 
@@ -171,8 +172,6 @@ public SslContext map(String input) {
             ReferenceCountUtil.release(sslServerContext);
             ReferenceCountUtil.release(sslClientContext);
 
-            cert.delete();
-
             group.shutdownGracefully();
         }
     }

File: handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.util.CachedSelfSignedCertificate;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.handler.ssl.util.SimpleTrustManagerFactory;
@@ -117,7 +118,7 @@ public void testCorrectAlert(SslProvider serverProvider, final SslProvider clien
         // no need to run it if there is no openssl is available at all.
         OpenSsl.ensureAvailability();
 
-        SelfSignedCertificate ssc = new SelfSignedCertificate();
+        SelfSignedCertificate ssc = CachedSelfSignedCertificate.getCachedCertificate();
 
         SslContextBuilder sslServerCtxBuilder = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                 .sslProvider(serverProvider)

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.AsciiString;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.ObjectUtil;
 
 import java.net.SocketAddress;
@@ -160,6 +161,8 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         }
 
         if (upgradeRequested) {
+            // Release message before failing the promise.
+            ReferenceCountUtil.release(msg);
             promise.setFailure(new IllegalStateException(
                     "Attempting to write HTTP request with upgrade in progress"));
             return;

File: buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
Patch:
@@ -349,13 +349,13 @@ public void testAllocateSmallOffset() {
     }
 
     @Test
-    @Timeout(value = 4000, unit = MILLISECONDS)
+    @Timeout(value = 10, threadMode = Timeout.ThreadMode.SEPARATE_THREAD)
     public void testThreadCacheDestroyedByThreadCleaner() throws InterruptedException {
         testThreadCacheDestroyed(false);
     }
 
     @Test
-    @Timeout(value = 4000, unit = MILLISECONDS)
+    @Timeout(value = 10, threadMode = Timeout.ThreadMode.SEPARATE_THREAD)
     public void testThreadCacheDestroyedAfterExitRun() throws InterruptedException {
         testThreadCacheDestroyed(true);
     }

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -325,7 +325,7 @@ DefaultHandle<T> claim() {
             if (batch.isEmpty()) {
                 handles.drain(this, chunkSize);
             }
-            DefaultHandle<T> handle = batch.pollFirst();
+            DefaultHandle<T> handle = batch.pollLast();
             if (null != handle) {
                 handle.toClaimed();
             }

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -199,7 +199,7 @@ private MemoryRegionCache<?> cache(PoolArena<?> area, int sizeIdx, SizeClass siz
     }
 
     /**
-     *  Should be called if the Thread that uses this cache is about to exist to release resources out of the cache
+     *  Should be called if the Thread that uses this cache is about to exit to release resources out of the cache
      */
     void free(boolean finalizer) {
         // As free() may be called either by the finalizer or by FastThreadLocal.onRemoval(...) we need to ensure

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.PrematureChannelClosureException;
 import io.netty.util.CharsetUtil;
+import io.netty.util.ReferenceCountUtil;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
@@ -1144,6 +1145,7 @@ private static void testInvalidHeaders0(ByteBuf responseBuffer) {
         HttpResponse response = channel.readInbound();
         assertThat(response.decoderResult().cause(), instanceOf(IllegalArgumentException.class));
         assertTrue(response.decoderResult().isFailure());
+        ReferenceCountUtil.release(response);
         assertFalse(channel.finish());
     }
 }

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -621,7 +621,7 @@ static final class HeapArena extends PoolArena<byte[]> {
 
         HeapArena(PooledByteBufAllocator parent, SizeClasses sizeClass) {
             super(parent, sizeClass);
-            lastDestroyedChunk = new AtomicReference<>();
+            lastDestroyedChunk = new AtomicReference<PoolChunk<byte[]>>();
         }
 
         private static byte[] newByteArray(int size) {

File: buffer/src/main/java/io/netty/buffer/PoolChunkList.java
Patch:
@@ -28,7 +28,7 @@
 import java.nio.ByteBuffer;
 
 final class PoolChunkList<T> implements PoolChunkListMetric {
-    private static final Iterator<PoolChunkMetric> EMPTY_METRICS = Collections.emptyIterator();
+    private static final Iterator<PoolChunkMetric> EMPTY_METRICS = Collections.<PoolChunkMetric>emptyList().iterator();
     private final PoolArena<T> arena;
     private final PoolChunkList<T> nextList;
     private final int minUsage;

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java
Patch:
@@ -154,12 +154,12 @@ public void shouldReuseChunks() throws Exception {
         }
         assumeThat(threadMXBean).isInstanceOf(cls);
         Method getThreadAllocatedBytes = cls.getDeclaredMethod("getThreadAllocatedBytes", long.class);
-        long allocBefore = (long) getThreadAllocatedBytes.invoke(threadMXBean, Thread.currentThread().getId());
+        long allocBefore = (Long) getThreadAllocatedBytes.invoke(threadMXBean, Thread.currentThread().getId());
         assumeTrue(allocBefore != -1);
         for (int i = 0; i < 100; ++i) {
             allocator.heapBuffer(bufSize, bufSize).release();
         }
-        long allocAfter = (long) getThreadAllocatedBytes.invoke(threadMXBean, Thread.currentThread().getId());
+        long allocAfter = (Long) getThreadAllocatedBytes.invoke(threadMXBean, Thread.currentThread().getId());
         assumeTrue(allocAfter != -1);
         assertThat(allocAfter - allocBefore)
                 .as("allocated MB: %.3f", (allocAfter - allocBefore) / 1024.0 / 1024.0)

File: buffer/src/main/java/io/netty/buffer/PoolChunkList.java
Patch:
@@ -28,7 +28,7 @@
 import java.nio.ByteBuffer;
 
 final class PoolChunkList<T> implements PoolChunkListMetric {
-    private static final Iterator<PoolChunkMetric> EMPTY_METRICS = Collections.<PoolChunkMetric>emptyList().iterator();
+    private static final Iterator<PoolChunkMetric> EMPTY_METRICS = Collections.emptyIterator();
     private final PoolArena<T> arena;
     private final PoolChunkList<T> nextList;
     private final int minUsage;

File: buffer/src/main/java/io/netty/buffer/AdaptiveByteBufAllocator.java
Patch:
@@ -111,7 +111,7 @@ private HeapChunkAllocator(ByteBufAllocator allocator) {
         }
 
         @Override
-        public ByteBuf allocate(int initialCapacity, int maxCapacity) {
+        public AbstractByteBuf allocate(int initialCapacity, int maxCapacity) {
             return PlatformDependent.hasUnsafe() ?
                     new UnpooledUnsafeHeapByteBuf(allocator, initialCapacity, maxCapacity) :
                     new UnpooledHeapByteBuf(allocator, initialCapacity, maxCapacity);
@@ -126,7 +126,7 @@ private DirectChunkAllocator(ByteBufAllocator allocator) {
         }
 
         @Override
-        public ByteBuf allocate(int initialCapacity, int maxCapacity) {
+        public AbstractByteBuf allocate(int initialCapacity, int maxCapacity) {
             return PlatformDependent.hasUnsafe() ?
                     UnsafeByteBufUtil.newUnsafeDirectByteBuf(allocator, initialCapacity, maxCapacity) :
                     new UnpooledDirectByteBuf(allocator, initialCapacity, maxCapacity);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexTransportTest.java
Patch:
@@ -620,7 +620,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                                         (SslHandshakeCompletionEvent) evt;
                                 if (handshakeCompletionEvent.isSuccess()) {
                                     Http2StreamChannelBootstrap h2Bootstrap =
-                                            new Http2StreamChannelBootstrap(clientChannel);
+                                            new Http2StreamChannelBootstrap(ctx.channel());
                                     h2Bootstrap.handler(new ChannelInboundHandlerAdapter() {
                                         @Override
                                         public void channelRead(ChannelHandlerContext ctx, Object msg) {

File: example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
Patch:
@@ -82,7 +82,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
     private boolean isSsl(ByteBuf buf) {
         if (detectSsl) {
-            return SslHandler.isEncrypted(buf);
+            return SslHandler.isEncrypted(buf, false);
         }
         return false;
     }

File: handler/src/main/java/io/netty/handler/ssl/OptionalSslHandler.java
Patch:
@@ -44,7 +44,7 @@ protected void decode(ChannelHandlerContext context, ByteBuf in, List<Object> ou
         if (in.readableBytes() < SslUtils.SSL_RECORD_HEADER_LENGTH) {
             return;
         }
-        if (SslHandler.isEncrypted(in)) {
+        if (SslHandler.isEncrypted(in, false)) {
             handleSsl(context);
         } else {
             handleNonSsl(context);

File: handler/src/main/java/io/netty/handler/ssl/SslClientHelloHandler.java
Patch:
@@ -79,7 +79,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         case SslUtils.SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:
                             // fall-through
                         case SslUtils.SSL_CONTENT_TYPE_ALERT:
-                            final int len = SslUtils.getEncryptedPacketLength(in, readerIndex);
+                            final int len = SslUtils.getEncryptedPacketLength(in, readerIndex, true);
 
                             // Not an SSL/TLS packet
                             if (len == SslUtils.NOT_ENCRYPTED) {

File: handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspHttpHandler.java
Patch:
@@ -34,8 +34,8 @@ final class OcspHttpHandler extends SimpleChannelInboundHandler<FullHttpResponse
     private static final InternalLogger LOGGER = InternalLoggerFactory.getInstance(OcspHttpHandler.class);
     private final Promise<OCSPResp> responseFuture;
 
-    public static final String OCSP_REQUEST_TYPE = "application/ocsp-request";
-    public static final String OCSP_RESPONSE_TYPE = "application/ocsp-response";
+    static final String OCSP_REQUEST_TYPE = "application/ocsp-request";
+    static final String OCSP_RESPONSE_TYPE = "application/ocsp-response";
 
     /**
      * Create new {@link OcspHttpHandler} instance

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -197,7 +197,8 @@ public HttpRequestDecoder(HttpDecoderConfig config) {
     @Override
     protected HttpMessage createMessage(String[] initialLine) throws Exception {
         return new DefaultHttpRequest(
-                HttpVersion.valueOf(initialLine[2]),
+                // Do strict version checking
+                HttpVersion.valueOf(initialLine[2], true),
                 HttpMethod.valueOf(initialLine[0]), initialLine[1], headersFactory);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -191,7 +191,8 @@ public HttpResponseDecoder(HttpDecoderConfig config) {
     @Override
     protected HttpMessage createMessage(String[] initialLine) {
         return new DefaultHttpResponse(
-                HttpVersion.valueOf(initialLine[0]),
+                // Do strict version checking
+                HttpVersion.valueOf(initialLine[0], true),
                 HttpResponseStatus.valueOf(Integer.parseInt(initialLine[1]), initialLine[2]), headersFactory);
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -682,12 +682,12 @@ public void testChunkSizeOverflow2() {
     public void testHeaderValueWithInvalidSuffix(String suffix) {
         testInvalidHeaders0("GET / HTTP/1.1\r\nHost: whatever\r\nTest-Key: test-value" + suffix + "\r\n\r\n");
     }
-  
+
     @Test
     public void testLeadingWhitespaceInFirstHeaderName() {
         testInvalidHeaders0("POST / HTTP/1.1\r\n\tContent-Length: 1\r\n\r\nX");
     }
-  
+
    @Test
     public void testNulInInitialLine() {
         testInvalidHeaders0("GET / HTTP/1.1\r\u0000\nHost: whatever\r\n\r\n");

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -995,7 +995,7 @@ private static String langAsciiString(final byte[] asciiContent, int start, int
     private void splitHeader(byte[] line, int start, int length) {
         final int end = start + length;
         int nameEnd;
-        final int nameStart = findNonWhitespace(line, start, end);
+        final int nameStart = start;
         // hoist this load out of the loop, because it won't change!
         final boolean isDecodingRequest = isDecodingRequest();
         for (nameEnd = nameStart; nameEnd < end; nameEnd ++) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -1113,7 +1113,7 @@ private static int findNonWhitespace(byte[] sb, int offset, int end) {
 
     private static int findEndOfString(byte[] sb, int start, int end) {
         for (int result = end - 1; result > start; --result) {
-            if (!isWhitespace(sb[result])) {
+            if (!isOWS(sb[result])) {
                 return result + 1;
             }
         }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java
Patch:
@@ -95,8 +95,8 @@ void cache(String hostname, DnsRecord[] additionals, UnknownHostException cause)
     @Override
     void doSearchDomainQuery(String hostname, Promise<List<InetAddress>> nextPromise) {
         // Query the cache for the hostname first and only do a query if we could not find it in the cache.
-        if (!DnsNameResolver.doResolveAllCached(
-                hostname, additionals, nextPromise, resolveCache, parent.resolvedInternetProtocolFamiliesUnsafe())) {
+        if (!DnsNameResolver.doResolveAllCached(hostname, additionals, nextPromise, resolveCache,
+                parent.searchDomains(), parent.ndots(), parent.resolvedInternetProtocolFamiliesUnsafe())) {
             super.doSearchDomainQuery(hostname, nextPromise);
         }
     }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java
Patch:
@@ -575,7 +575,7 @@ public void operationComplete(final Future<List<InetAddress>> future) {
         });
         DnsCache resolveCache = resolveCache();
         if (!DnsNameResolver.doResolveAllCached(nameServerName, additionals, resolverPromise, resolveCache,
-                parent.resolvedInternetProtocolFamiliesUnsafe())) {
+                parent.searchDomains(), parent.ndots(), parent.resolvedInternetProtocolFamiliesUnsafe())) {
 
             new DnsAddressResolveContext(parent, channel, channelReadyFuture,
                     originalPromise, nameServerName, additionals, parent.newNameServerAddressStream(nameServerName),

File: resolver-dns/src/main/java/io/netty/resolver/dns/ResolvConf.java
Patch:
@@ -96,6 +96,8 @@ private static final class ResolvConfLazy {
                 resolvConf = ResolvConf.fromFile("/etc/resolv.conf");
             } catch (IOException e) {
                 resolvConf = null;
+            } catch (SecurityException ignore) {
+                resolvConf = null;
             }
             machineResolvConf = resolvConf;
         }

File: buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java
Patch:
@@ -714,6 +714,7 @@ public boolean hasArray() {
 
         @Override
         public byte[] array() {
+            ensureAccessible();
             return rootParent.array();
         }
 

File: buffer/src/test/java/io/netty/buffer/PooledAlignedBigEndianDirectByteBufTest.java
Patch:
@@ -21,13 +21,15 @@
 import java.nio.ByteOrder;
 
 import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
 
 public class PooledAlignedBigEndianDirectByteBufTest extends PooledBigEndianDirectByteBufTest {
     private static final int directMemoryCacheAlignment = 1;
     private static PooledByteBufAllocator allocator;
 
     @BeforeAll
     public static void setUpAllocator() {
+        assumeTrue(PooledByteBufAllocator.isDirectMemoryCacheAlignmentSupported());
         allocator = new PooledByteBufAllocator(
                 true,
                 PooledByteBufAllocator.defaultNumHeapArena(),

File: buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
Patch:
@@ -277,7 +277,7 @@ public void testFreePoolChunk() {
     public void testCollapse() {
         int pageSize = 8192;
         //no cache
-        ByteBufAllocator allocator = new PooledByteBufAllocator(true, 0, 1, 8192, 9, 0, 0, 0);
+        ByteBufAllocator allocator = new PooledByteBufAllocator(true, 1, 1, 8192, 9, 0, 0, 0);
 
         ByteBuf b1 = allocator.buffer(pageSize * 4);
         ByteBuf b2 = allocator.buffer(pageSize * 5);
@@ -310,7 +310,7 @@ public void testCollapse() {
     @Test
     public void testAllocateSmallOffset() {
         int pageSize = 8192;
-        ByteBufAllocator allocator = new PooledByteBufAllocator(true, 0, 1, 8192, 9, 0, 0, 0);
+        ByteBufAllocator allocator = new PooledByteBufAllocator(true, 1, 1, 8192, 9, 0, 0, 0);
 
         int size = pageSize * 5;
 

File: codec/src/test/java/io/netty/handler/codec/compression/LengthAwareLzfIntegrationTest.java
Patch:
@@ -23,6 +23,6 @@ public class LengthAwareLzfIntegrationTest extends LzfIntegrationTest {
 
     @Override
     protected EmbeddedChannel createEncoder() {
-        return new EmbeddedChannel(new LzfEncoder(false, MAX_CHUNK_LEN, 2 * 1024 * 1024));
+        return new EmbeddedChannel(new LzfEncoder(MAX_CHUNK_LEN, 2 * 1024 * 1024));
     }
 }

File: codec/src/test/java/io/netty/handler/codec/compression/LzfDecoderTest.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.internal.PlatformDependent;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.function.Executable;
 
@@ -68,6 +69,6 @@ public void execute() {
 
     @Override
     protected byte[] compress(byte[] data) throws Exception {
-        return LZFEncoder.encode(data);
+        return PlatformDependent.hasUnsafe() ? LZFEncoder.encode(data) : LZFEncoder.safeEncode(data);
     }
 }

File: buffer/src/main/java/io/netty/buffer/PooledSlicedByteBuf.java
Patch:
@@ -115,12 +115,12 @@ public ByteBuf retainedSlice(int index, int length) {
 
     @Override
     public ByteBuf duplicate() {
-        return duplicate0().setIndex(idx(readerIndex()), idx(writerIndex()));
+        return slice(0, capacity()).setIndex(readerIndex(), writerIndex());
     }
 
     @Override
     public ByteBuf retainedDuplicate() {
-        return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));
+        return retainedSlice(0, capacity()).setIndex(readerIndex(), writerIndex());
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
Patch:
@@ -595,7 +595,7 @@ public ByteBuf slice(int index, int length) {
 
         @Override
         public ByteBuf duplicate() {
-            return new ReadOnlyDuplicatedByteBuf(this);
+            return slice(0, capacity()).setIndex(readerIndex(), writerIndex());
         }
 
         @Override

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
Patch:
@@ -295,7 +295,7 @@ public ByteBuf copy(int index, int length) {
 
     @Override
     public ByteBuf slice(int index, int length) {
-        return Unpooled.unmodifiableBuffer(unwrap().slice(index, length));
+        return new ReadOnlyByteBuf(unwrap().slice(index, length));
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java
Patch:
@@ -61,7 +61,7 @@ protected long _getLong(int index) {
     }
 
     @Override
-    public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
+    protected ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length, boolean internal) {
         checkIndex(index, length);
         ObjectUtil.checkNotNull(dst, "dst");
         if (dstIndex < 0 || dstIndex > dst.capacity() - length) {
@@ -79,7 +79,7 @@ public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
     }
 
     @Override
-    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
+    protected ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length, boolean internal) {
         checkIndex(index, length);
         ObjectUtil.checkNotNull(dst, "dst");
         if (dstIndex < 0 || dstIndex > dst.length - length) {

File: codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.util.ResourceLeakDetectorFactory;
 import io.netty.util.ResourceLeakTracker;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -32,7 +31,6 @@
 /**
  * A skeletal implementation of {@link DnsMessage}.
  */
-@UnstableApi
 public abstract class AbstractDnsMessage extends AbstractReferenceCounted implements DnsMessage {
 
     private static final ResourceLeakDetector<DnsMessage> leakDetector =

File: codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsOptPseudoRrRecord.java
Patch:
@@ -16,15 +16,13 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * An <a href="https://tools.ietf.org/html/rfc6891#section-6.1">OPT RR</a> record.
  *
  * This is used for <a href="https://tools.ietf.org/html/rfc6891#section-6.1.3">
  *     Extension Mechanisms for DNS (EDNS(0))</a>.
  */
-@UnstableApi
 public abstract class AbstractDnsOptPseudoRrRecord extends AbstractDnsRecord implements DnsOptPseudoRecord {
 
     protected AbstractDnsOptPseudoRrRecord(int maxPayloadSize, int extendedRcode, int version) {

File: codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.IDN;
 
@@ -27,7 +26,6 @@
 /**
  * A skeletal implementation of {@link DnsRecord}.
  */
-@UnstableApi
 public abstract class AbstractDnsRecord implements DnsRecord {
 
     private final String name;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java
Patch:
@@ -16,15 +16,13 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.channel.AddressedEnvelope;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 
 /**
  * A {@link DnsQuery} implementation for UDP/IP.
  */
-@UnstableApi
 public class DatagramDnsQuery extends DefaultDnsQuery
         implements AddressedEnvelope<DatagramDnsQuery, InetSocketAddress> {
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.MessageToMessageDecoder;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -28,7 +27,6 @@
 /**
  * Decodes a {@link DatagramPacket} into a {@link DatagramDnsQuery}.
  */
-@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsQueryDecoder extends MessageToMessageDecoder<DatagramPacket> {
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.MessageToMessageEncoder;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -30,7 +29,6 @@
  * Encodes a {@link DatagramDnsQuery} (or an {@link AddressedEnvelope} of {@link DnsQuery}} into a
  * {@link DatagramPacket}.
  */
-@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsQueryEncoder extends MessageToMessageEncoder<AddressedEnvelope<DnsQuery, InetSocketAddress>> {
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java
Patch:
@@ -16,15 +16,13 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.channel.AddressedEnvelope;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 
 /**
  * A {@link DnsResponse} implementation for UDP/IP.
  */
-@UnstableApi
 public class DatagramDnsResponse extends DefaultDnsResponse
         implements AddressedEnvelope<DatagramDnsResponse, InetSocketAddress> {
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java
Patch:
@@ -20,15 +20,13 @@
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.MessageToMessageDecoder;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
 
 /**
  * Decodes a {@link DatagramPacket} into a {@link DatagramDnsResponse}.
  */
-@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsResponseDecoder extends MessageToMessageDecoder<DatagramPacket> {
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseEncoder.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.MessageToMessageEncoder;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -32,7 +31,6 @@
  * Encodes a {@link DatagramDnsResponse} (or an {@link AddressedEnvelope} of {@link DnsResponse}} into a
  * {@link DatagramPacket}.
  */
-@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsResponseEncoder
     extends MessageToMessageEncoder<AddressedEnvelope<DnsResponse, InetSocketAddress>> {

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsOptEcsRecord.java
Patch:
@@ -16,15 +16,13 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.channel.socket.InternetProtocolFamily;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetAddress;
 import java.util.Arrays;
 
 /**
  * Default {@link DnsOptEcsRecord} implementation.
  */
-@UnstableApi
 public final class DefaultDnsOptEcsRecord extends AbstractDnsOptPseudoRrRecord implements DnsOptEcsRecord {
     private final int srcPrefixLength;
     private final byte[] address;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsPtrRecord.java
Patch:
@@ -18,9 +18,7 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
-@UnstableApi
 public class DefaultDnsPtrRecord extends AbstractDnsRecord implements DnsPtrRecord {
 
     private final String hostname;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * The default {@link DnsQuery} implementation.
  */
-@UnstableApi
 public class DefaultDnsQuery extends AbstractDnsMessage implements DnsQuery {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java
Patch:
@@ -16,12 +16,10 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link DnsQuestion} implementation.
  */
-@UnstableApi
 public class DefaultDnsQuestion extends AbstractDnsRecord implements DnsQuestion {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java
Patch:
@@ -17,14 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@code DnsRawRecord} implementation.
  */
-@UnstableApi
 public class DefaultDnsRawRecord extends AbstractDnsRecord implements DnsRawRecord {
 
     private final ByteBuf content;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
Patch:
@@ -16,14 +16,12 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link DnsRecordDecoder} implementation.
  *
  * @see DefaultDnsRecordEncoder
  */
-@UnstableApi
 public class DefaultDnsRecordDecoder implements DnsRecordDecoder {
 
     static final String ROOT = ".";

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
Patch:
@@ -18,14 +18,12 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link DnsRecordEncoder} implementation.
  *
  * @see DefaultDnsRecordDecoder
  */
-@UnstableApi
 public class DefaultDnsRecordEncoder implements DnsRecordEncoder {
     private static final int PREFIX_MASK = Byte.SIZE - 1;
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link DnsResponse} implementation.
  */
-@UnstableApi
 public class DefaultDnsResponse extends AbstractDnsMessage implements DnsResponse {
 
     private boolean authoritativeAnswer;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
Patch:
@@ -16,12 +16,10 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.ReferenceCounted;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The superclass which contains core information concerning a {@link DnsQuery} and a {@link DnsResponse}.
  */
-@UnstableApi
 public interface DnsMessage extends ReferenceCounted {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The DNS {@code OpCode} as defined in <a href="https://tools.ietf.org/html/rfc2929">RFC2929</a>.
  */
-@UnstableApi
 public class DnsOpCode implements Comparable<DnsOpCode> {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOptEcsRecord.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 import java.net.InetAddress;
 
 /**
  * An ECS record as defined in <a href="https://tools.ietf.org/html/rfc7871#section-6">Client Subnet in DNS Queries</a>.
  */
-@UnstableApi
 public interface DnsOptEcsRecord extends DnsOptPseudoRecord {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOptPseudoRecord.java
Patch:
@@ -15,15 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * An <a href="https://tools.ietf.org/html/rfc6891#section-6.1">OPT RR</a> record.
  * <p>
  * This is used for <a href="https://tools.ietf.org/html/rfc6891#section-6.1.3">Extension
  * Mechanisms for DNS (EDNS(0))</a>.
  */
-@UnstableApi
 public interface DnsOptPseudoRecord extends DnsRecord {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsPtrRecord.java
Patch:
@@ -15,9 +15,6 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
-@UnstableApi
 public interface DnsPtrRecord extends DnsRecord {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A DNS query message.
  */
-@UnstableApi
 public interface DnsQuery extends DnsMessage {
     @Override
     DnsQuery setId(int id);

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A DNS question.
  */
-@UnstableApi
 public interface DnsQuestion extends DnsRecord {
     /**
      * An unused property. This method will always return {@code 0}.

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java
Patch:
@@ -17,12 +17,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * A generic {@link DnsRecord} that contains an undecoded {@code RDATA}.
  */
-@UnstableApi
 public interface DnsRawRecord extends DnsRecord, ByteBufHolder {
     @Override
     DnsRawRecord copy();

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A DNS resource record.
  */
-@UnstableApi
 public interface DnsRecord {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
Patch:
@@ -16,14 +16,12 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Decodes a DNS record into its object representation.
  *
  * @see DatagramDnsResponseDecoder
  */
-@UnstableApi
 public interface DnsRecordDecoder {
 
     DnsRecordDecoder DEFAULT = new DefaultDnsRecordDecoder();

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java
Patch:
@@ -16,14 +16,12 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Encodes a {@link DnsRecord} into binary representation.
  *
  * @see DatagramDnsQueryEncoder
  */
-@UnstableApi
 public interface DnsRecordEncoder {
 
     DnsRecordEncoder DEFAULT = new DefaultDnsRecordEncoder();

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java
Patch:
@@ -16,15 +16,13 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.collection.IntObjectHashMap;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * Represents a DNS record type.
  */
-@UnstableApi
 public class DnsRecordType implements Comparable<DnsRecordType> {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A DNS response message.
  */
-@UnstableApi
 public interface DnsResponse extends DnsMessage {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The DNS {@code RCODE}, as defined in <a href="https://tools.ietf.org/html/rfc2929">RFC2929</a>.
  */
-@UnstableApi
 public class DnsResponseCode implements Comparable<DnsResponseCode> {
 
     /**

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Represents a section of a {@link DnsMessage}.
  */
-@UnstableApi
 public enum DnsSection {
     /**
      * The section that contains {@link DnsQuestion}s.

File: codec-dns/src/main/java/io/netty/handler/codec/dns/TcpDnsQueryDecoder.java
Patch:
@@ -19,9 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
-@UnstableApi
 public final class TcpDnsQueryDecoder extends LengthFieldBasedFrameDecoder {
     private final DnsRecordDecoder decoder;
 

File: codec-dns/src/main/java/io/netty/handler/codec/dns/TcpDnsQueryEncoder.java
Patch:
@@ -19,10 +19,8 @@
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToByteEncoder;
-import io.netty.util.internal.UnstableApi;
 
 @ChannelHandler.Sharable
-@UnstableApi
 public final class TcpDnsQueryEncoder extends MessageToByteEncoder<DnsQuery> {
 
     private final DnsQueryEncoder encoder;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/TcpDnsResponseDecoder.java
Patch:
@@ -18,11 +18,9 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.SocketAddress;
 
-@UnstableApi
 public final class TcpDnsResponseDecoder extends LengthFieldBasedFrameDecoder {
 
     private final DnsResponseDecoder<SocketAddress> responseDecoder;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/TcpDnsResponseEncoder.java
Patch:
@@ -20,11 +20,9 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageEncoder;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
-@UnstableApi
 @ChannelHandler.Sharable
 public final class TcpDnsResponseEncoder extends MessageToMessageEncoder<DnsResponse> {
     private final DnsRecordEncoder encoder;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
Patch:
@@ -17,7 +17,4 @@
 /**
  * DNS codec.
  */
-@UnstableApi
 package io.netty.handler.codec.dns;
-
-import io.netty.util.internal.UnstableApi;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValidationUtil.java
Patch:
@@ -16,14 +16,12 @@
 package io.netty.handler.codec.http;
 
 import io.netty.util.AsciiString;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.AsciiString.contentEqualsIgnoreCase;
 
 /**
  * Functions used to perform various validations of HTTP header names and values.
  */
-@UnstableApi
 public final class HttpHeaderValidationUtil {
     private HttpHeaderValidationUtil() {
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -28,7 +28,6 @@
 import io.netty.util.CharsetUtil;
 import io.netty.util.NetUtil;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.StringUtil.COMMA;
 import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
@@ -564,7 +563,6 @@ public static String formatHostnameForHttp(InetSocketAddress addr) {
      * @return the normalized content length from the headers or {@code -1} if the fields were empty.
      * @throws IllegalArgumentException if the content-length fields are not valid
      */
-    @UnstableApi
     public static long normalizeAndGetContentLength(
             List<? extends CharSequence> contentLengthFields, boolean isHttp10OrEarlier,
             boolean allowDuplicateContentLengths) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java
Patch:
@@ -32,7 +32,6 @@
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -119,7 +118,6 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
      * <strong>IMPORTANT:</strong>
      * It already call {@code super.channelRead(ctx, request)} before returning.
      */
-    @UnstableApi
     protected void onHttpRequestChannelRead(ChannelHandlerContext ctx, HttpRequest request) throws Exception {
         List<WebSocketServerExtension> validExtensionsList = null;
 
@@ -201,7 +199,6 @@ public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise pr
      * <strong>IMPORTANT:</strong>
      * It already call {@code super.write(ctx, response, promise)} before returning.
      */
-    @UnstableApi
     protected void onHttpResponseWrite(ChannelHandlerContext ctx, HttpResponse response, ChannelPromise promise)
             throws Exception {
         List<WebSocketServerExtension> validExtensionsList = validExtensions.poll();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -18,7 +18,6 @@
 
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_RESERVED_STREAMS;
@@ -71,7 +70,6 @@
  * @param <T> The type of handler created by this builder.
  * @param <B> The concrete type of this builder.
  */
-@UnstableApi
 public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2ConnectionHandler,
                                                             B extends AbstractHttp2ConnectionHandlerBuilder<T, B>> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Abstract implementation of {@link Http2StreamFrame}.
  */
-@UnstableApi
 public abstract class AbstractHttp2StreamFrame implements Http2StreamFrame {
 
     private Http2FrameStream stream;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractInboundHttp2ToHttpAdapterBuilder.java
Patch:
@@ -15,14 +15,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.TooLongFrameException;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * A skeletal builder implementation of {@link InboundHttp2ToHttpAdapter} and its subtypes.
  */
-@UnstableApi
 public abstract class AbstractInboundHttp2ToHttpAdapterBuilder<
         T extends InboundHttp2ToHttpAdapter, B extends AbstractInboundHttp2ToHttpAdapterBuilder<T, B>> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CharSequenceMap.java
Patch:
@@ -18,15 +18,13 @@
 import io.netty.handler.codec.DefaultHeaders;
 import io.netty.handler.codec.UnsupportedValueConverter;
 import io.netty.handler.codec.ValueConverter;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;
 import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;
 
 /**
  * Internal use only!
  */
-@UnstableApi
 public final class CharSequenceMap<V> extends DefaultHeaders<CharSequence, V, CharSequenceMap<V>> {
     public CharSequenceMap() {
         this(true);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandler.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.http.HttpServerCodec;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -37,7 +36,6 @@
  * And will update pipeline once it detect the connection is starting HTTP/2 by
  * prior knowledge or not.
  */
-@UnstableApi
 public final class CleartextHttp2ServerUpgradeHandler extends ByteToMessageDecoder {
     private static final ByteBuf CONNECTION_PREFACE = unreleasableBuffer(connectionPrefaceBuf()).asReadOnly();
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
Patch:
@@ -37,7 +37,6 @@
 import io.netty.handler.codec.compression.SnappyOptions;
 import io.netty.util.concurrent.PromiseCombiner;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -57,7 +56,6 @@
  * A decorating HTTP2 encoder that will compress data frames according to the {@code content-encoding} header for each
  * stream. The compression provided by this class will be applied to the data for the entire stream.
  */
-@UnstableApi
 public class CompressorHttp2ConnectionEncoder extends DecoratingHttp2ConnectionEncoder {
     // We cannot remove this because it'll be breaking change
     public static final int DEFAULT_COMPRESSION_LEVEL = 6;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java
Patch:
@@ -18,14 +18,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
 /**
  * Decorator around another {@link Http2ConnectionDecoder} instance.
  */
-@UnstableApi
 public class DecoratingHttp2ConnectionDecoder implements Http2ConnectionDecoder {
     private final Http2ConnectionDecoder delegate;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionEncoder.java
Patch:
@@ -14,14 +14,11 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * A decorator around another {@link Http2ConnectionEncoder} instance.
  */
-@UnstableApi
 public class DecoratingHttp2ConnectionEncoder extends DecoratingHttp2FrameWriter implements Http2ConnectionEncoder,
         Http2SettingsReceivedConsumer {
     private final Http2ConnectionEncoder delegate;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java
Patch:
@@ -18,14 +18,12 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * Decorator around another {@link Http2FrameWriter} instance.
  */
-@UnstableApi
 public class DecoratingHttp2FrameWriter implements Http2FrameWriter {
     private final Http2FrameWriter delegate;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -26,7 +26,6 @@
 import io.netty.util.concurrent.Promise;
 import io.netty.util.concurrent.PromiseNotifier;
 import io.netty.util.internal.EmptyArrays;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -61,7 +60,6 @@
 /**
  * Simple implementation of {@link Http2Connection}.
  */
-@UnstableApi
 public class DefaultHttp2Connection implements Http2Connection {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2Connection.class);
     // Fields accessed by inner classes

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.handler.codec.http.HttpStatusClass;
 import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http2.Http2Connection.Endpoint;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -51,7 +50,6 @@
  * This interface enforces inbound flow control functionality through
  * {@link Http2LocalFlowController}
  */
-@UnstableApi
 public class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);
     private Http2FrameListener internalFrameListener = new PrefaceFrameListener();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.channel.CoalescingBufferQueue;
 import io.netty.handler.codec.http.HttpStatusClass;
 import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
@@ -39,7 +38,6 @@
 /**
  * Default implementation of {@link Http2ConnectionEncoder}.
  */
-@UnstableApi
 public class DefaultHttp2ConnectionEncoder implements Http2ConnectionEncoder, Http2SettingsReceivedConsumer {
     private final Http2FrameWriter frameWriter;
     private final Http2Connection connection;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java
Patch:
@@ -19,15 +19,13 @@
 import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.verifyPadding;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link Http2DataFrame} implementation.
  */
-@UnstableApi
 public final class DefaultHttp2DataFrame extends AbstractHttp2StreamFrame implements Http2DataFrame {
     private final ByteBuf content;
     private final boolean endStream;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http2.Http2FrameReader.Configuration;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_FRAME_SIZE;
@@ -51,7 +50,6 @@
 /**
  * A {@link Http2FrameReader} that supports all frame types defined by the HTTP/2 specification.
  */
-@UnstableApi
 public class DefaultHttp2FrameReader implements Http2FrameReader, Http2FrameSizePolicy, Configuration {
     private final Http2HeadersDecoder headersDecoder;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -25,7 +25,6 @@
 import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.buffer.Unpooled.directBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
@@ -71,7 +70,6 @@
 /**
  * A {@link Http2FrameWriter} that supports all frame types defined by the HTTP/2 specification.
  */
-@UnstableApi
 public class DefaultHttp2FrameWriter implements Http2FrameWriter, Http2FrameSizePolicy, Configuration {
     private static final String STREAM_ID = "Stream ID";
     private static final String STREAM_DEPENDENCY = "Stream Dependency";

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java
Patch:
@@ -21,12 +21,10 @@
 import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link Http2GoAwayFrame} implementation.
  */
-@UnstableApi
 public final class DefaultHttp2GoAwayFrame extends DefaultByteBufHolder implements Http2GoAwayFrame {
 
     private final long errorCode;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.util.AsciiString;
 import io.netty.util.ByteProcessor;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
@@ -30,7 +29,6 @@
 import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;
 import static io.netty.util.AsciiString.isUpperCase;
 
-@UnstableApi
 public class DefaultHttp2Headers
         extends DefaultHeaders<CharSequence, CharSequence, Http2Headers> implements Http2Headers {
     private static final ByteProcessor HTTP2_NAME_VALIDATOR_PROCESSOR = new ByteProcessor() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -17,14 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2Error.COMPRESSION_ERROR;
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 
-@UnstableApi
 public class DefaultHttp2HeadersDecoder implements Http2HeadersDecoder, Http2HeadersDecoder.Configuration {
     private static final float HEADERS_COUNT_WEIGHT_NEW = 1 / 5f;
     private static final float HEADERS_COUNT_WEIGHT_HISTORICAL = 1 - HEADERS_COUNT_WEIGHT_NEW;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
Patch:
@@ -19,13 +19,11 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2Error.COMPRESSION_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
-@UnstableApi
 public class DefaultHttp2HeadersEncoder implements
     Http2HeadersEncoder, Http2HeadersEncoder.Configuration, Closeable {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersFrame.java
Patch:
@@ -16,15 +16,13 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.verifyPadding;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link Http2HeadersFrame} implementation.
  */
-@UnstableApi
 public final class DefaultHttp2HeadersFrame extends AbstractHttp2StreamFrame implements Http2HeadersFrame {
     private final Http2Headers headers;
     private final boolean endStream;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -32,15 +32,13 @@
 import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
 import io.netty.handler.codec.http2.Http2Exception.StreamException;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Basic implementation of {@link Http2LocalFlowController}.
  * <p>
  * This class is <strong>NOT</strong> thread safe. The assumption is all methods must be invoked from a single thread.
  * Typically this thread is the event loop thread for the {@link ChannelHandlerContext} managed by this class.
  */
-@UnstableApi
 public class DefaultHttp2LocalFlowController implements Http2LocalFlowController {
     /**
      * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PingFrame.java
Patch:
@@ -17,12 +17,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link Http2PingFrame} implementation.
  */
-@UnstableApi
 public class DefaultHttp2PingFrame implements Http2PingFrame {
 
     private final long content;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Default implementation of {@linkplain Http2PriorityFrame}
  */
-@UnstableApi
 public final class DefaultHttp2PriorityFrame extends AbstractHttp2StreamFrame implements Http2PriorityFrame {
 
     private final int streamDependency;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Default implementation of {@link Http2PushPromiseFrame}
  */
-@UnstableApi
 public final class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {
 
     private Http2FrameStream pushStreamFrame;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -15,7 +15,6 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -41,7 +40,6 @@
  * This class is <strong>NOT</strong> thread safe. The assumption is all methods must be invoked from a single thread.
  * Typically this thread is the event loop thread for the {@link ChannelHandlerContext} managed by this class.
  */
-@UnstableApi
 public class DefaultHttp2RemoteFlowController implements Http2RemoteFlowController {
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(DefaultHttp2RemoteFlowController.class);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java
Patch:
@@ -16,14 +16,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link Http2ResetFrame} implementation.
  */
-@UnstableApi
 public final class DefaultHttp2ResetFrame extends AbstractHttp2StreamFrame implements Http2ResetFrame {
 
     private final long errorCode;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2SettingsFrame.java
Patch:
@@ -18,12 +18,10 @@
 
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link Http2SettingsFrame} implementation.
  */
-@UnstableApi
 public class DefaultHttp2SettingsFrame implements Http2SettingsFrame {
 
     private final Http2Settings settings;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2UnknownFrame.java
Patch:
@@ -19,9 +19,7 @@
 import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
-@UnstableApi
 public final class DefaultHttp2UnknownFrame extends DefaultByteBufHolder implements Http2UnknownFrame {
     private final byte frameType;
     private final Http2Flags flags;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2WindowUpdateFrame.java
Patch:
@@ -16,12 +16,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link Http2WindowUpdateFrame} implementation.
  */
-@UnstableApi
 public class DefaultHttp2WindowUpdateFrame extends AbstractHttp2StreamFrame implements Http2WindowUpdateFrame {
 
     private final int windowUpdateIncrement;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.ByteToMessageDecoder;
-import io.netty.util.internal.UnstableApi;
 import io.netty.handler.codec.compression.Brotli;
 import io.netty.handler.codec.compression.BrotliDecoder;
 import io.netty.handler.codec.compression.Zstd;
@@ -47,7 +46,6 @@
  * An HTTP2 frame listener that will decompress data frames according to the {@code content-encoding} header for each
  * stream. The decompression provided by this class will be applied to the data for the entire stream.
  */
-@UnstableApi
 public class DelegatingDecompressorFrameListener extends Http2FrameListenerDecorator {
 
     private final Http2Connection connection;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/EmptyHttp2Headers.java
Patch:
@@ -16,9 +16,7 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.EmptyHeaders;
-import io.netty.util.internal.UnstableApi;
 
-@UnstableApi
 public final class EmptyHttp2Headers
         extends EmptyHeaders<CharSequence, CharSequence, Http2Headers> implements Http2Headers {
     public static final EmptyHttp2Headers INSTANCE = new EmptyHttp2Headers();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ChannelDuplexHandler.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link ChannelDuplexHandler} providing additional functionality for HTTP/2. Specifically it allows to:
@@ -32,7 +31,6 @@
  * <p>The {@link Http2FrameCodec} is required to be part of the {@link ChannelPipeline} before this handler is added,
  * or else an {@link IllegalStateException} will be thrown.
  */
-@UnstableApi
 public abstract class Http2ChannelDuplexHandler extends ChannelDuplexHandler {
 
     private volatile Http2FrameCodec frameCodec;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.handler.codec.http.HttpClientUpgradeHandler;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.collection.CharObjectMap;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -39,7 +38,6 @@
 /**
  * Client-side cleartext upgrade codec from HTTP to HTTP/2.
  */
-@UnstableApi
 public class Http2ClientUpgradeCodec implements HttpClientUpgradeHandler.UpgradeCodec {
 
     private static final List<CharSequence> UPGRADE_HEADERS = Collections.singletonList(HTTP_UPGRADE_SETTINGS_HEADER);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -25,7 +25,6 @@
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.util.AsciiString;
 import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.buffer.Unpooled.directBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
@@ -41,7 +40,6 @@
 /**
  * Constants and utility method used for encoding/decoding HTTP2 frames.
  */
-@UnstableApi
 public final class Http2CodecUtil {
     public static final int CONNECTION_STREAM_ID = 0;
     public static final int HTTP_UPGRADE_STREAM_ID = 1;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
Patch:
@@ -18,12 +18,10 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.Promise;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Manager for the state of an HTTP/2 connection with the remote end-point.
  */
-@UnstableApi
 public interface Http2Connection {
     /**
      * Listener for life-cycle events for streams in this connection.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionAdapter.java
Patch:
@@ -15,12 +15,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Provides empty implementations of all {@link Http2Connection.Listener} methods.
  */
-@UnstableApi
 public class Http2ConnectionAdapter implements Http2Connection.Listener {
     @Override
     public void onStreamAdded(Http2Stream stream) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java
Patch:
@@ -16,7 +16,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.Closeable;
 import java.util.List;
@@ -27,7 +26,6 @@
  * application-specific processing. Note that frames of an unknown type (i.e. HTTP/2 extensions)
  * will skip all protocol checks and be given directly to the listener for processing.
  */
-@UnstableApi
 public interface Http2ConnectionDecoder extends Closeable {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionEncoder.java
Patch:
@@ -18,13 +18,11 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.internal.UnstableApi;
 
 
 /**
  * Handler for outbound HTTP/2 traffic.
  */
-@UnstableApi
 public interface Http2ConnectionEncoder extends Http2FrameWriter {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -28,7 +28,6 @@
 import io.netty.handler.codec.http2.Http2Exception.StreamException;
 import io.netty.util.CharsetUtil;
 import io.netty.util.concurrent.Future;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -62,7 +61,6 @@
  * This interface enforces inbound flow control functionality through
  * {@link Http2LocalFlowController}
  */
-@UnstableApi
 public class Http2ConnectionHandler extends ByteToMessageDecoder implements Http2LifecycleManager,
                                                                             ChannelOutboundHandler {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java
Patch:
@@ -17,12 +17,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Builder which builds {@link Http2ConnectionHandler} objects.
  */
-@UnstableApi
 public final class Http2ConnectionHandlerBuilder
         extends AbstractHttp2ConnectionHandlerBuilder<Http2ConnectionHandler, Http2ConnectionHandlerBuilder> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.java
Patch:
@@ -14,14 +14,11 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Signifies that the <a href="https://tools.ietf.org/html/rfc7540#section-3.5">connection preface</a> and
  * the initial SETTINGS frame have been sent. The client sends the preface, and the server receives the preface.
  * The client shouldn't write any data until this event has been processed.
  */
-@UnstableApi
 public final class Http2ConnectionPrefaceAndSettingsFrameWrittenEvent {
     static final Http2ConnectionPrefaceAndSettingsFrameWrittenEvent INSTANCE =
             new Http2ConnectionPrefaceAndSettingsFrameWrittenEvent();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
Patch:
@@ -17,12 +17,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * HTTP/2 DATA frame.
  */
-@UnstableApi
 public interface Http2DataFrame extends Http2StreamFrame, ByteBufHolder {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java
Patch:
@@ -18,12 +18,10 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Interface that defines an object capable of producing HTTP/2 data frames.
  */
-@UnstableApi
 public interface Http2DataWriter {
     /**
      * Writes a {@code DATA} frame to the remote endpoint. This will result in one or more

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java
Patch:
@@ -15,12 +15,9 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * All error codes identified by the HTTP/2 spec.
  */
-@UnstableApi
 public enum Http2Error {
     NO_ERROR(0x0),
     PROTOCOL_ERROR(0x1),

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java
Patch:
@@ -16,13 +16,11 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * This class brings {@link Http2Connection.Listener} and {@link Http2FrameListener} together to provide
  * NOOP implementation so inheriting classes can selectively choose which methods to override.
  */
-@UnstableApi
 public class Http2EventAdapter implements Http2Connection.Listener, Http2FrameListener {
     @Override
     public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.ThrowableUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -31,7 +30,6 @@
 /**
  * Exception thrown when an HTTP/2 error was encountered.
  */
-@UnstableApi
 public class Http2Exception extends Exception {
     private static final long serialVersionUID = -6941186345430164209L;
     private final Http2Error error;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Flags.java
Patch:
@@ -15,12 +15,9 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Provides utility methods for accessing specific flags as defined by the HTTP/2 spec.
  */
-@UnstableApi
 public final class Http2Flags {
     public static final short END_STREAM = 0x1;
     public static final short END_HEADERS = 0x4;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FlowController.java
Patch:
@@ -15,12 +15,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Base interface for all HTTP/2 flow controllers.
  */
-@UnstableApi
 public interface Http2FlowController {
     /**
      * Set the {@link ChannelHandlerContext} for which to apply flow control on.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Frame.java
Patch:
@@ -15,10 +15,7 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /** An HTTP/2 frame. */
-@UnstableApi
 public interface Http2Frame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameAdapter.java
Patch:
@@ -16,12 +16,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Convenience class that provides no-op implementations for all methods of {@link Http2FrameListener}.
  */
-@UnstableApi
 public class Http2FrameAdapter implements Http2FrameListener {
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -32,7 +32,6 @@
 import io.netty.util.ReferenceCounted;
 import io.netty.util.collection.IntObjectHashMap;
 import io.netty.util.collection.IntObjectMap;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -144,7 +143,6 @@
  * Server-side HTTP to HTTP/2 upgrade is supported in conjunction with {@link Http2ServerUpgradeCodec}; the necessary
  * HTTP-to-HTTP/2 conversion is performed automatically.
  */
-@UnstableApi
 public class Http2FrameCodec extends Http2ConnectionHandler {
 
     private static final InternalLogger LOG = InternalLoggerFactory.getInstance(Http2FrameCodec.class);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodecBuilder.java
Patch:
@@ -16,14 +16,11 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * Builder for the {@link Http2FrameCodec}.
  */
-@UnstableApi
 public class Http2FrameCodecBuilder extends
         AbstractHttp2ConnectionHandlerBuilder<Http2FrameCodec, Http2FrameCodecBuilder> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
Patch:
@@ -17,12 +17,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * An listener of HTTP/2 frames.
  */
-@UnstableApi
 public interface Http2FrameListener {
     /**
      * Handles an inbound {@code DATA} frame.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java
Patch:
@@ -17,12 +17,10 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Provides a decorator around a {@link Http2FrameListener} and delegates all method calls
  */
-@UnstableApi
 public class Http2FrameListenerDecorator implements Http2FrameListener {
     protected final Http2FrameListener listener;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.logging.LogLevel;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogLevel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -30,7 +29,6 @@
 /**
  * Logs HTTP2 frames for debugging purposes.
  */
-@UnstableApi
 public class Http2FrameLogger extends ChannelHandlerAdapter {
 
     public enum Direction {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameReader.java
Patch:
@@ -17,15 +17,13 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.Closeable;
 
 /**
  * Reads HTTP/2 frames from an input {@link ByteBuf} and notifies the specified
  * {@link Http2FrameListener} when frames are complete.
  */
-@UnstableApi
 public interface Http2FrameReader extends Closeable {
     /**
      * Configuration specific to {@link Http2FrameReader}

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameSizePolicy.java
Patch:
@@ -14,9 +14,6 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
-@UnstableApi
 public interface Http2FrameSizePolicy {
     /**
      * Sets the maximum allowed frame size. Attempts to write frames longer than this maximum will fail.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStream.java
Patch:
@@ -17,12 +17,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.http2.Http2Stream.State;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * A single stream within an HTTP/2 connection. To be used with the {@link Http2FrameCodec}.
  */
-@UnstableApi
 public interface Http2FrameStream {
     /**
      * Returns the stream identifier.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStreamException.java
Patch:
@@ -16,14 +16,11 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * An HTTP/2 exception for a specific {@link Http2FrameStream}.
  */
-@UnstableApi
 public final class Http2FrameStreamException extends Exception {
 
     private static final long serialVersionUID = -4407186173493887044L;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStreamVisitor.java
Patch:
@@ -16,12 +16,9 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A visitor that allows to iterate over a collection of {@link Http2FrameStream}s.
  */
-@UnstableApi
 public interface Http2FrameStreamVisitor {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameTypes.java
Patch:
@@ -15,12 +15,9 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Registry of all standard frame types defined by the HTTP/2 specification.
  */
-@UnstableApi
 public final class Http2FrameTypes {
     public static final byte DATA = 0x0;
     public static final byte HEADERS = 0x1;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.Closeable;
 
@@ -28,7 +27,6 @@
  * this interface write to the context, but DO NOT FLUSH. To perform a flush, you must separately
  * call {@link ChannelHandlerContext#flush()}.
  */
-@UnstableApi
 public interface Http2FrameWriter extends Http2DataWriter, Closeable {
     /**
      * Configuration specific to {@link Http2FrameWriter}

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2GoAwayFrame.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * HTTP/2 GOAWAY frame.
@@ -29,7 +28,6 @@
  * <p>Graceful shutdown as described in the HTTP/2 spec can be accomplished by calling
  * {@code #setExtraStreamIds(Integer.MAX_VALUE)}.
  */
-@UnstableApi
 public interface Http2GoAwayFrame extends Http2Frame, ByteBufHolder {
     /**
      * The reason for beginning closure of the connection. Represented as an HTTP/2 error code.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
Patch:
@@ -17,15 +17,13 @@
 
 import io.netty.handler.codec.Headers;
 import io.netty.util.AsciiString;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.Iterator;
 import java.util.Map.Entry;
 
 /**
  * A collection of headers sent or received via HTTP/2.
  */
-@UnstableApi
 public interface Http2Headers extends Headers<CharSequence, CharSequence, Http2Headers> {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersDecoder.java
Patch:
@@ -16,12 +16,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Decodes HPACK-encoded headers blocks into {@link Http2Headers}.
  */
-@UnstableApi
 public interface Http2HeadersDecoder {
     /**
      * Configuration related elements for the {@link Http2HeadersDecoder} interface

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java
Patch:
@@ -16,12 +16,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Encodes {@link Http2Headers} into HPACK-encoded headers blocks.
  */
-@UnstableApi
 public interface Http2HeadersEncoder {
     /**
      * Configuration related elements for the {@link Http2HeadersEncoder} interface

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * HTTP/2 HEADERS frame.
  */
-@UnstableApi
 public interface Http2HeadersFrame extends Http2StreamFrame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java
Patch:
@@ -19,13 +19,11 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Decorator around a {@link Http2FrameReader} that logs all inbound frames before calling
  * back the listener.
  */
-@UnstableApi
 public class Http2InboundFrameLogger implements Http2FrameReader {
     private final Http2FrameReader reader;
     private final Http2FrameLogger logger;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java
Patch:
@@ -18,13 +18,11 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Manager for the life cycle of the HTTP/2 connection. Handles graceful shutdown of the channel,
  * closing only after all of the streams have closed.
  */
-@UnstableApi
 public interface Http2LifecycleManager {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java
Patch:
@@ -15,12 +15,10 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link Http2FlowController} for controlling the inbound flow of {@code DATA} frames from the remote endpoint.
  */
-@UnstableApi
 public interface Http2LocalFlowController extends Http2FlowController {
     /**
      * Sets the writer to be use for sending {@code WINDOW_UPDATE} frames. This must be called before any flow

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -27,7 +27,6 @@
 import io.netty.channel.socket.ChannelOutputShutdownEvent;
 import io.netty.handler.ssl.SslCloseCompletionEvent;
 import io.netty.util.ReferenceCounted;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
@@ -87,7 +86,6 @@
  * @deprecated use {@link Http2FrameCodecBuilder} together with {@link Http2MultiplexHandler}.
  */
 @Deprecated
-@UnstableApi
 public class Http2MultiplexCodec extends Http2FrameCodec {
 
     private final ChannelHandler inboundStreamHandler;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerAdapter;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
@@ -27,7 +26,6 @@
  * @deprecated use {@link Http2FrameCodecBuilder} together with {@link Http2MultiplexHandler}.
  */
 @Deprecated
-@UnstableApi
 public class Http2MultiplexCodecBuilder
         extends AbstractHttp2ConnectionHandlerBuilder<Http2MultiplexCodec, Http2MultiplexCodecBuilder> {
     private Http2FrameWriter frameWriter;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexHandler.java
Patch:
@@ -31,7 +31,6 @@
 import io.netty.handler.ssl.SslCloseCompletionEvent;
 import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
@@ -98,7 +97,6 @@
  * and send a {@link Http2ResetFrame} with the unwrapped {@link Http2Error} set. Another possibility is to just
  * directly write a {@link Http2ResetFrame} to the {@link Http2StreamChannel}l.
  */
-@UnstableApi
 public final class Http2MultiplexHandler extends Http2ChannelDuplexHandler {
 
     static final ChannelFutureListener CHILD_CHANNEL_REGISTRATION_LISTENER = new ChannelFutureListener() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2NoMoreStreamIdsException.java
Patch:
@@ -14,14 +14,11 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 
 /**
  * This exception is thrown when there are no more stream IDs available for the current connection
  */
-@UnstableApi
 public class Http2NoMoreStreamIdsException extends Http2Exception {
     private static final long serialVersionUID = -7756236161274851110L;
     private static final String ERROR_MESSAGE = "No more streams can be created on this connection";

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
Patch:
@@ -21,13 +21,11 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Decorator around a {@link Http2FrameWriter} that logs all outbound frames before calling the
  * writer.
  */
-@UnstableApi
 public class Http2OutboundFrameLogger implements Http2FrameWriter {
     private final Http2FrameWriter writer;
     private final Http2FrameLogger logger;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PingFrame.java
Patch:
@@ -16,12 +16,9 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * HTTP/2 PING Frame.
  */
-@UnstableApi
 public interface Http2PingFrame extends Http2Frame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * HTTP/2 Priority Frame
  */
-@UnstableApi
 public interface Http2PriorityFrame extends Http2StreamFrame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PromisedRequestVerifier.java
Patch:
@@ -15,13 +15,11 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Provides an extensibility point for users to define the validity of push requests.
  * @see <a href="https://tools.ietf.org/html/rfc7540#section-8.2">[RFC 7540], Section 8.2</a>.
  */
-@UnstableApi
 public interface Http2PromisedRequestVerifier {
     /**
      * Determine if a {@link Http2Headers} are authoritative for a particular {@link ChannelHandlerContext}.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * HTTP/2 Push Promise Frame
  */
-@UnstableApi
 public interface Http2PushPromiseFrame extends Http2StreamFrame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
Patch:
@@ -15,13 +15,11 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link Http2FlowController} for controlling the flow of outbound {@code DATA} frames to the remote
  * endpoint.
  */
-@UnstableApi
 public interface Http2RemoteFlowController extends Http2FlowController {
     /**
      * Get the {@link ChannelHandlerContext} for which to apply flow control on.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ResetFrame.java
Patch:
@@ -15,10 +15,7 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /** HTTP/2 RST_STREAM frame. */
-@UnstableApi
 public interface Http2ResetFrame extends Http2StreamFrame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java
Patch:
@@ -15,8 +15,6 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -25,7 +23,6 @@
 /**
  * Provides utilities related to security requirements specific to HTTP/2.
  */
-@UnstableApi
 public final class Http2SecurityUtil {
     /**
      * The following list is derived from <a

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler;
 import io.netty.util.CharsetUtil;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -41,7 +40,6 @@
 /**
  * Server-side codec for performing a cleartext upgrade from HTTP/1.x to HTTP/2.
  */
-@UnstableApi
 public class Http2ServerUpgradeCodec implements HttpServerUpgradeHandler.UpgradeCodec {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Http2ServerUpgradeCodec.class);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.util.collection.CharObjectHashMap;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_CONCURRENT_STREAMS;
@@ -46,7 +45,6 @@
  * the spec for the SETTINGS frame. Permits storage of arbitrary key/value pairs but provides helper
  * methods for standard settings.
  */
-@UnstableApi
 public final class Http2Settings extends CharObjectHashMap<Long> {
     /**
      * Default capacity based on the number of standard settings from the HTTP/2 spec, adjusted so that adding all of

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java
Patch:
@@ -15,12 +15,9 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A single stream within an HTTP2 connection. Streams are compared to each other by priority.
  */
-@UnstableApi
 public interface Http2Stream {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannel.java
Patch:
@@ -17,13 +17,11 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.Channel;
-import io.netty.util.internal.UnstableApi;
 
 // TODO: Should we have an extra method to "open" the stream and so Channel and take care of sending the
 //       Http2HeadersFrame under the hood ?
 // TODO: Should we extend SocketChannel and map input and output state to the stream state ?
 //
-@UnstableApi
 public interface Http2StreamChannel extends Channel {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrap.java
Patch:
@@ -28,7 +28,6 @@
 import io.netty.util.concurrent.Promise;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -37,7 +36,6 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-@UnstableApi
 public final class Http2StreamChannelBootstrap {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Http2StreamChannelBootstrap.class);
     @SuppressWarnings("unchecked")

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrame.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A frame whose meaning <em>may</em> apply to a particular stream, instead of the entire connection. It is still
  * possible for this frame type to apply to the entire connection. In such cases, the {@link #stream()} must return
  * {@code null}. If the frame applies to a stream, the {@link Http2FrameStream#id()} must be greater than zero.
  */
-@UnstableApi
 public interface Http2StreamFrame extends Http2Frame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java
Patch:
@@ -44,7 +44,6 @@
 import io.netty.handler.ssl.SslHandler;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -57,7 +56,6 @@
  * For simplicity, it converts to chunked encoding unless the entire stream
  * is a single header.
  */
-@UnstableApi
 @Sharable
 public class Http2StreamFrameToHttpObjectCodec extends MessageToMessageCodec<Http2StreamFrame, HttpObject> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamVisitor.java
Patch:
@@ -14,12 +14,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * A visitor that allows iteration over a collection of streams.
  */
-@UnstableApi
 public interface Http2StreamVisitor {
     /**
      * @return <ul>

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2UnknownFrame.java
Patch:
@@ -17,9 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.util.internal.UnstableApi;
 
-@UnstableApi
 public interface Http2UnknownFrame extends Http2StreamFrame, ByteBufHolder {
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2WindowUpdateFrame.java
Patch:
@@ -15,12 +15,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * HTTP/2 WINDOW_UPDATE frame.
  */
-@UnstableApi
 public interface Http2WindowUpdateFrame extends Http2StreamFrame {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
Patch:
@@ -35,7 +35,6 @@
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.util.AsciiString;
 import io.netty.util.internal.InternalThreadLocalMap;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.URI;
 import java.util.Iterator;
@@ -68,7 +67,6 @@
 /**
  * Provides utility methods and constants for the HTTP/2 to HTTP conversion
  */
-@UnstableApi
 public final class HttpConversionUtil {
     /**
      * The set of headers that should not be directly copied when converting headers from HTTP to HTTP/2.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -27,14 +27,12 @@
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;
 import io.netty.util.ReferenceCountUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Translates HTTP/1.x object writes into HTTP/2 frames.
  * <p>
  * See {@link InboundHttp2ToHttpAdapter} to get translation from HTTP/2 frames to HTTP/1.x objects.
  */
-@UnstableApi
 public class HttpToHttp2ConnectionHandler extends Http2ConnectionHandler {
 
     private final boolean validateHeaders;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerBuilder.java
Patch:
@@ -18,12 +18,10 @@
 
 import io.netty.handler.codec.http.HttpScheme;
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Builder which builds {@link HttpToHttp2ConnectionHandler} objects.
  */
-@UnstableApi
 public final class HttpToHttp2ConnectionHandlerBuilder extends
         AbstractHttp2ConnectionHandlerBuilder<HttpToHttp2ConnectionHandler, HttpToHttp2ConnectionHandlerBuilder> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpStatusClass;
 import io.netty.handler.codec.http.HttpUtil;
-import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
@@ -38,7 +37,6 @@
  * <p>
  * See {@link HttpToHttp2ConnectionHandler} to get translation from HTTP/1.x objects to HTTP/2 frames for writes.
  */
-@UnstableApi
 public class InboundHttp2ToHttpAdapter extends Http2EventAdapter {
     private static final ImmediateSendDetector DEFAULT_SEND_DETECTOR = new ImmediateSendDetector() {
         @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterBuilder.java
Patch:
@@ -14,12 +14,9 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Builds an {@link InboundHttp2ToHttpAdapter}.
  */
-@UnstableApi
 public final class InboundHttp2ToHttpAdapterBuilder
         extends AbstractInboundHttp2ToHttpAdapterBuilder<InboundHttp2ToHttpAdapter, InboundHttp2ToHttpAdapterBuilder> {
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java
Patch:
@@ -20,12 +20,10 @@
 import io.netty.handler.codec.http.FullHttpMessage;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpScheme;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Translates HTTP/1.x object reads into HTTP/2 frames.
  */
-@UnstableApi
 public class InboundHttpToHttp2Adapter extends ChannelInboundHandlerAdapter {
     private final Http2Connection connection;
     private final Http2FrameListener listener;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.ReferenceCountUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 import java.util.Iterator;
@@ -55,7 +54,6 @@
  * drop-in decorator of {@link DefaultHttp2ConnectionEncoder}.
  * </p>
  */
-@UnstableApi
 public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
Patch:
@@ -15,13 +15,10 @@
 
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * An object (used by remote flow control) that is responsible for distributing the bytes to be
  * written across the streams in the connection.
  */
-@UnstableApi
 public interface StreamByteDistributor {
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
Patch:
@@ -14,8 +14,6 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.util.internal.UnstableApi;
-
 import java.util.ArrayDeque;
 import java.util.Deque;
 
@@ -34,7 +32,6 @@
  * fewer streams may be written to in each call to {@link #distribute(int, Writer)}, doing this
  * should improve the goodput on each written stream.
  */
-@UnstableApi
 public final class UniformStreamByteDistributor implements StreamByteDistributor {
     private final Http2Connection.PropertyKey stateKey;
     private final Deque<State> queue = new ArrayDeque<State>(4);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.util.internal.PriorityQueue;
 import io.netty.util.internal.PriorityQueueNode;
 import io.netty.util.internal.SystemPropertyUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.Serializable;
 import java.util.ArrayList;
@@ -56,7 +55,6 @@
  * Each write operation will use the {@link #allocationQuantum(int)} to know how many more bytes should be allocated
  * relative to the next stream which wants to write. This is to balance fairness while also considering goodput.
  */
-@UnstableApi
 public final class WeightedFairQueueByteDistributor implements StreamByteDistributor {
     /**
      * The initial size of the children map is chosen to be conservative on initial memory allocations under

File: codec-http2/src/main/java/io/netty/handler/codec/http2/package-info.java
Patch:
@@ -16,7 +16,4 @@
 /**
  * Handlers for sending and receiving HTTP/2 frames.
  */
-@UnstableApi
 package io.netty.handler.codec.http2;
-
-import io.netty.util.internal.UnstableApi;

File: common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java
Patch:
@@ -15,15 +15,12 @@
  */
 package io.netty.util.concurrent;
 
-import io.netty.util.internal.UnstableApi;
-
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Default implementation which uses simple round-robin to choose next {@link EventExecutor}.
  */
-@UnstableApi
 public final class DefaultEventExecutorChooserFactory implements EventExecutorChooserFactory {
 
     public static final DefaultEventExecutorChooserFactory INSTANCE = new DefaultEventExecutorChooserFactory();

File: common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.util.concurrent;
 
 import io.netty.util.internal.InternalThreadLocalMap;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -98,15 +97,13 @@ public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {
     /**
      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link #run()} completes.
      */
-    @UnstableApi
     public boolean willCleanupFastThreadLocals() {
         return cleanupFastThreadLocals;
     }
 
     /**
      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.
      */
-    @UnstableApi
     public static boolean willCleanupFastThreadLocals(Thread thread) {
         return thread instanceof FastThreadLocalThread &&
                 ((FastThreadLocalThread) thread).willCleanupFastThreadLocals();

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.ThreadExecutorMap;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.jetbrains.annotations.Async.Schedule;
@@ -495,7 +494,6 @@ protected boolean runAllTasks(long timeoutNanos) {
     /**
      * Invoked before returning from {@link #runAllTasks()} and {@link #runAllTasks(long)}.
      */
-    @UnstableApi
     protected void afterRunningAllTasks() { }
 
     /**
@@ -516,7 +514,6 @@ protected long delayNanos(long currentTimeNanos) {
      * Returns the absolute point in time (relative to {@link #getCurrentTimeNanos()}) at which the next
      * closest scheduled task should run.
      */
-    @UnstableApi
     protected long deadlineNanos() {
         ScheduledFutureTask<?> scheduledTask = peekScheduledTask();
         if (scheduledTask == null) {

File: handler/src/main/java/io/netty/handler/ssl/SniCompletionEvent.java
Patch:
@@ -15,13 +15,10 @@
  */
 package io.netty.handler.ssl;
 
-import io.netty.util.internal.UnstableApi;
-
 /**
  * Event that is fired once we did a selection of a {@link SslContext} based on the {@code SNI hostname},
  * which may be because it was successful or there was an error.
  */
-@UnstableApi
 public final class SniCompletionEvent extends SslCompletionEvent {
     private final String hostname;
 

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -37,7 +37,6 @@
 import io.netty.channel.unix.UnixChannelUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -532,7 +531,6 @@ protected Object filterOutboundMessage(Object msg) {
                 "unsupported message type: " + StringUtil.simpleClassName(msg) + EXPECTED_TYPES);
     }
 
-    @UnstableApi
     @Override
     protected final void doShutdownOutput() throws Exception {
         socket.shutdown(false, true);

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainDatagramChannel.java
Patch:
@@ -33,15 +33,13 @@
 import io.netty.util.CharsetUtil;
 import io.netty.util.UncheckedBooleanSupplier;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 
 import static io.netty.channel.epoll.LinuxSocket.newSocketDomainDgram;
 
-@UnstableApi
 public final class EpollDomainDatagramChannel extends AbstractEpollChannel implements DomainDatagramChannel {
 
     private static final ChannelMetadata METADATA = new ChannelMetadata(true, 16);

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainDatagramChannelConfig.java
Patch:
@@ -23,15 +23,13 @@
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.unix.DomainDatagramChannelConfig;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.util.Map;
 
 import static io.netty.channel.ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION;
 import static io.netty.channel.ChannelOption.SO_SNDBUF;
 
-@UnstableApi
 public final class EpollDomainDatagramChannelConfig extends EpollChannelConfig implements DomainDatagramChannelConfig {
 
     private boolean activeOnOpen;

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainSocketChannel.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.channel.unix.DomainSocketChannel;
 import io.netty.channel.unix.FileDescriptor;
 import io.netty.channel.unix.PeerCredentials;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.net.SocketAddress;
@@ -127,7 +126,6 @@ protected Object filterOutboundMessage(Object msg) {
      * Returns the unix credentials (uid, gid, pid) of the peer
      * <a href=https://man7.org/linux/man-pages/man7/socket.7.html>SO_PEERCRED</a>
      */
-    @UnstableApi
     public PeerCredentials peerCredentials() throws IOException {
         return socket.getPeerCredentials();
     }

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueServerChannel.java
Patch:
@@ -22,12 +22,10 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoop;
 import io.netty.channel.ServerChannel;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 
-@UnstableApi
 public abstract class AbstractKQueueServerChannel extends AbstractKQueueChannel implements ServerChannel {
     private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java
Patch:
@@ -47,7 +47,6 @@
 import static io.netty.channel.internal.ChannelUtils.MAX_BYTES_PER_GATHERING_WRITE_ATTEMPTED_LOW_THRESHOLD;
 import static io.netty.channel.internal.ChannelUtils.WRITE_STATUS_SNDBUF_FULL;
 
-@UnstableApi
 public abstract class AbstractKQueueStreamChannel extends AbstractKQueueChannel implements DuplexChannel {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractKQueueStreamChannel.class);
     private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueue.java
Patch:
@@ -18,12 +18,10 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.unix.FileDescriptor;
 import io.netty.util.internal.SystemPropertyUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * If KQueue is available the JNI resources will be loaded when this class loads.
  */
-@UnstableApi
 public final class KQueue {
     private static final Throwable UNAVAILABILITY_CAUSE;
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueChannelConfig.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.unix.IntegerUnixChannelOption;
 import io.netty.channel.unix.RawUnixChannelOption;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -34,7 +33,6 @@
 import static io.netty.channel.unix.Limits.SSIZE_MAX;
 import static java.lang.Math.min;
 
-@UnstableApi
 public class KQueueChannelConfig extends DefaultChannelConfig {
     private volatile boolean transportProvidesGuess;
     private volatile long maxBytesPerGatheringWrite = SSIZE_MAX;

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueChannelOption.java
Patch:
@@ -18,9 +18,7 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.unix.UnixChannelOption;
-import io.netty.util.internal.UnstableApi;
 
-@UnstableApi
 public final class KQueueChannelOption<T> extends UnixChannelOption<T> {
     public static final ChannelOption<Integer> SO_SNDLOWAT = valueOf(KQueueChannelOption.class, "SO_SNDLOWAT");
     public static final ChannelOption<Boolean> TCP_NOPUSH = valueOf(KQueueChannelOption.class, "TCP_NOPUSH");

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java
Patch:
@@ -33,7 +33,6 @@
 import io.netty.util.UncheckedBooleanSupplier;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -46,7 +45,6 @@
 
 import static io.netty.channel.kqueue.BsdSocket.newSocketDgram;
 
-@UnstableApi
 public final class KQueueDatagramChannel extends AbstractKQueueDatagramChannel implements DatagramChannel {
     private static final String EXPECTED_TYPES =
             " (expected: " + StringUtil.simpleClassName(DatagramPacket.class) + ", " +

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannelConfig.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.DatagramChannelConfig;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -42,7 +41,6 @@
 import static io.netty.channel.ChannelOption.SO_SNDBUF;
 import static io.netty.channel.unix.UnixChannelOption.SO_REUSEPORT;
 
-@UnstableApi
 public final class KQueueDatagramChannelConfig extends KQueueChannelConfig implements DatagramChannelConfig {
     private boolean activeOnOpen;
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainDatagramChannel.java
Patch:
@@ -31,15 +31,13 @@
 import io.netty.util.CharsetUtil;
 import io.netty.util.UncheckedBooleanSupplier;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 
 import static io.netty.channel.kqueue.BsdSocket.newSocketDomainDgram;
 
-@UnstableApi
 public final class KQueueDomainDatagramChannel extends AbstractKQueueDatagramChannel implements DomainDatagramChannel {
 
     private static final String EXPECTED_TYPES =

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainDatagramChannelConfig.java
Patch:
@@ -23,15 +23,13 @@
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.unix.DomainDatagramChannelConfig;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.util.Map;
 
 import static io.netty.channel.ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION;
 import static io.netty.channel.ChannelOption.SO_SNDBUF;
 
-@UnstableApi
 public final class KQueueDomainDatagramChannelConfig
         extends KQueueChannelConfig implements DomainDatagramChannelConfig {
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainSocketChannel.java
Patch:
@@ -30,7 +30,6 @@
 
 import static io.netty.channel.kqueue.BsdSocket.newSocketDomain;
 
-@UnstableApi
 public final class KQueueDomainSocketChannel extends AbstractKQueueStreamChannel implements DomainSocketChannel {
     private final KQueueDomainSocketChannelConfig config = new KQueueDomainSocketChannelConfig(this);
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainSocketChannelConfig.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.channel.unix.DomainSocketChannelConfig;
 import io.netty.channel.unix.DomainSocketReadMode;
 import io.netty.util.internal.ObjectUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.util.Map;
@@ -34,7 +33,6 @@
 import static io.netty.channel.ChannelOption.SO_SNDBUF;
 import static io.netty.channel.unix.UnixChannelOption.DOMAIN_SOCKET_READ_MODE;
 
-@UnstableApi
 public final class KQueueDomainSocketChannelConfig extends KQueueChannelConfig
         implements DomainSocketChannelConfig, DuplexChannelConfig {
     private volatile DomainSocketReadMode mode = DomainSocketReadMode.BYTES;

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoopGroup.java
Patch:
@@ -25,12 +25,11 @@
 import io.netty.util.concurrent.EventExecutorChooserFactory;
 import io.netty.util.concurrent.RejectedExecutionHandler;
 import io.netty.util.concurrent.RejectedExecutionHandlers;
-import io.netty.util.internal.UnstableApi;
+
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
-@UnstableApi
 public final class KQueueEventLoopGroup extends MultithreadEventLoopGroup {
 
     // This does not use static by design to ensure the class can be loaded and only do the check when its actually

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerChannelConfig.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.ServerSocketChannelConfig;
 import io.netty.util.NetUtil;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.util.Map;
@@ -35,7 +34,6 @@
 import static io.netty.channel.ChannelOption.TCP_FASTOPEN;
 import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
 
-@UnstableApi
 public class KQueueServerChannelConfig extends KQueueChannelConfig implements ServerSocketChannelConfig {
     private volatile int backlog = NetUtil.SOMAXCONN;
     private volatile boolean enableTcpFastOpen;

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerDomainSocketChannel.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.Channel;
 import io.netty.channel.unix.DomainSocketAddress;
 import io.netty.channel.unix.ServerDomainSocketChannel;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -27,7 +26,6 @@
 
 import static io.netty.channel.kqueue.BsdSocket.newSocketDomain;
 
-@UnstableApi
 public final class KQueueServerDomainSocketChannel extends AbstractKQueueServerChannel
                                                   implements ServerDomainSocketChannel {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerSocketChannel.java
Patch:
@@ -18,15 +18,13 @@
 import io.netty.channel.Channel;
 import io.netty.channel.EventLoop;
 import io.netty.channel.socket.ServerSocketChannel;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 
 import static io.netty.channel.kqueue.BsdSocket.newSocketStream;
 import static io.netty.channel.unix.NativeInetAddress.address;
 
-@UnstableApi
 public final class KQueueServerSocketChannel extends AbstractKQueueServerChannel implements ServerSocketChannel {
     private final KQueueServerSocketChannelConfig config;
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerSocketChannelConfig.java
Patch:
@@ -21,16 +21,13 @@
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
-import io.netty.channel.socket.ServerSocketChannelConfig;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.util.Map;
 
 import static io.netty.channel.kqueue.KQueueChannelOption.SO_ACCEPTFILTER;
 import static io.netty.channel.unix.UnixChannelOption.SO_REUSEPORT;
 
-@UnstableApi
 public class KQueueServerSocketChannelConfig extends KQueueServerChannelConfig {
     KQueueServerSocketChannelConfig(KQueueServerSocketChannel channel) {
         super(channel);

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueSocketChannel.java
Patch:
@@ -23,13 +23,11 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.unix.IovArray;
 import io.netty.util.concurrent.GlobalEventExecutor;
-import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.concurrent.Executor;
 
-@UnstableApi
 public final class KQueueSocketChannel extends AbstractKQueueStreamChannel implements SocketChannel {
     private final KQueueSocketChannelConfig config;
 

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueSocketChannelConfig.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.SocketChannelConfig;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.util.Map;
@@ -39,7 +38,6 @@
 import static io.netty.channel.kqueue.KQueueChannelOption.SO_SNDLOWAT;
 import static io.netty.channel.kqueue.KQueueChannelOption.TCP_NOPUSH;
 
-@UnstableApi
 public final class KQueueSocketChannelConfig extends KQueueChannelConfig implements SocketChannelConfig {
     private volatile boolean allowHalfClosure;
     private volatile boolean tcpFastopen;

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/package-info.java
Patch:
@@ -17,7 +17,4 @@
 /**
  * BSD specific transport.
  */
-@UnstableApi
 package io.netty.channel.kqueue;
-
-import io.netty.util.internal.UnstableApi;

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -624,7 +623,6 @@ public void close(final ChannelPromise promise) {
          * Shutdown the output portion of the corresponding {@link Channel}.
          * For example this will clean up the {@link ChannelOutboundBuffer} and not allow any more writes.
          */
-        @UnstableApi
         public final void shutdownOutput(final ChannelPromise promise) {
             assertEventLoop();
             shutdownOutput(promise, null);
@@ -1098,7 +1096,6 @@ protected void doRegister() throws Exception {
      * Called when conditions justify shutting down the output portion of the channel. This may happen if a write
      * operation throws an exception.
      */
-    @UnstableApi
     protected void doShutdownOutput() throws Exception {
         doClose();
     }

File: transport/src/main/java/io/netty/channel/ChannelException.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.ThrowableUtil;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link RuntimeException} which is thrown when an I/O operation fails.
@@ -54,7 +53,6 @@ public ChannelException(Throwable cause) {
         super(cause);
     }
 
-    @UnstableApi
     @SuppressJava6Requirement(reason = "uses Java 7+ RuntimeException.<init>(String, Throwable, boolean, boolean)" +
             " but is guarded by version checks")
     protected ChannelException(String message, Throwable cause, boolean shared) {

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -1225,15 +1224,13 @@ protected void onUnhandledInboundUserEventTriggered(Object evt) {
     protected void onUnhandledChannelWritabilityChanged() {
     }
 
-    @UnstableApi
     protected void incrementPendingOutboundBytes(long size) {
         ChannelOutboundBuffer buffer = channel.unsafe().outboundBuffer();
         if (buffer != null) {
             buffer.incrementPendingOutboundBytes(size);
         }
     }
 
-    @UnstableApi
     protected void decrementPendingOutboundBytes(long size) {
         ChannelOutboundBuffer buffer = channel.unsafe().outboundBuffer();
         if (buffer != null) {

File: transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java
Patch:
@@ -108,7 +108,6 @@ interface Handle {
     }
 
     @SuppressWarnings("deprecation")
-    @UnstableApi
     interface ExtendedHandle extends Handle {
         /**
          * Same as {@link Handle#continueReading()} except "more data" is determined by the supplier parameter.

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -104,7 +104,6 @@ public ChannelFuture register(final Channel channel, final ChannelPromise promis
      *
      * @param task to be added.
      */
-    @UnstableApi
     public final void executeAfterEventLoopIteration(Runnable task) {
         ObjectUtil.checkNotNull(task, "task");
         if (isShutdown()) {
@@ -127,7 +126,6 @@ public final void executeAfterEventLoopIteration(Runnable task) {
      *
      * @return {@code true} if the task was removed as a result of this call.
      */
-    @UnstableApi
     final boolean removeAfterEventLoopIterationTask(Runnable task) {
         return tailTasks.remove(ObjectUtil.checkNotNull(task, "task"));
     }

File: transport/src/main/java/io/netty/channel/socket/ChannelOutputShutdownEvent.java
Patch:
@@ -17,14 +17,12 @@
 
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandler;
-import io.netty.util.internal.UnstableApi;
 
 /**
  * Special event which will be fired and passed to the
  * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)} methods once the output of
  * a {@link SocketChannel} was shutdown.
  */
-@UnstableApi
 public final class ChannelOutputShutdownEvent {
     public static final ChannelOutputShutdownEvent INSTANCE = new ChannelOutputShutdownEvent();
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioDomainSocketChannel.java
Patch:
@@ -38,7 +38,6 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SocketUtils;
 import io.netty.util.internal.SuppressJava6Requirement;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -161,8 +160,7 @@ public boolean isShutdown() {
         return isInputShutdown() && isOutputShutdown() || !isActive();
     }
 
-    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
-    @UnstableApi
+    @SuppressJava6Requirement(reason = "guarded by version check")
     @Override
     protected void doShutdownOutput() throws Exception {
         javaChannel().shutdownOutput();
@@ -268,6 +266,7 @@ private static void shutdownDone(ChannelFuture shutdownOutputFuture,
             promise.setSuccess();
         }
     }
+
     private void shutdownInput0(final ChannelPromise promise) {
         try {
             shutdownInput0();

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -35,10 +35,10 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SocketUtils;
 import io.netty.util.internal.SuppressJava6Requirement;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
@@ -161,7 +161,6 @@ public InetSocketAddress remoteAddress() {
     }
 
     @SuppressJava6Requirement(reason = "Usage guarded by java version check")
-    @UnstableApi
     @Override
     protected final void doShutdownOutput() throws Exception {
         if (PlatformDependent.javaVersion() >= 7) {

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -27,7 +27,6 @@
 import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.util.internal.SocketUtils;
-import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -133,7 +132,6 @@ public boolean isShutdown() {
         return socket.isInputShutdown() && socket.isOutputShutdown() || !isActive();
     }
 
-    @UnstableApi
     @Override
     protected final void doShutdownOutput() throws Exception {
         shutdownOutput0();

File: handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
Patch:
@@ -409,6 +409,7 @@ private static void safeClose(File keyFile, OutputStream keyOut) {
 
     private static boolean isBouncyCastleAvailable() {
         try {
+            // this class is in bcpkix, both fips and non-fips
             Class.forName("org.bouncycastle.cert.X509v3CertificateBuilder");
             return true;
         } catch (ClassNotFoundException e) {

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -770,7 +770,7 @@ public void testCloseOnHandshakeFailure() throws Exception {
                 .trustManager(new SelfSignedCertificate().cert())
                 .build();
 
-        EventLoopGroup group = new NioEventLoopGroup(1);
+        EventLoopGroup group = new DefaultEventLoopGroup(1);
         Channel sc = null;
         Channel cc = null;
         try {

File: common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java
Patch:
@@ -51,7 +51,7 @@
  * {@code ThreadLocalRandom.current().nextX(...)} (where
  * {@code X} is {@code Int}, {@code Long}, etc).
  * When all usages are of this form, it is never possible to
- * accidently share a {@code ThreadLocalRandom} across multiple threads.
+ * accidentally share a {@code ThreadLocalRandom} across multiple threads.
  *
  * <p>This class also provides additional commonly used bounded random
  * generation methods.

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -943,7 +943,7 @@ public boolean spliceIn(RecvByteBufAllocator.Handle handle) {
                         // Write was not done which means the target channel was not writable. In this case we need to
                         // disable reading until we are done with splicing to the target channel because:
                         //
-                        // - The user may want to to trigger another splice operation once the splicing was complete.
+                        // - The user may want to trigger another splice operation once the splicing was complete.
                         config().setAutoRead(false);
                     }
                 }

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java
Patch:
@@ -447,7 +447,7 @@ final void writeReady() {
          */
         void shutdownInput(boolean readEOF) {
             // We need to take special care of calling finishConnect() if readEOF is true and we not
-            // fullfilled the connectPromise yet. If we fail to do so the connectPromise will be failed
+            // fulfilled the connectPromise yet. If we fail to do so the connectPromise will be failed
             // with a ClosedChannelException as a close() will happen and so the FD is closed before we
             // have a chance to call finishConnect() later on. Calling finishConnect() here will ensure
             // we observe the correct exception in case of a connect failure.

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerChannelConfig.java
Patch:
@@ -149,7 +149,7 @@ public boolean isTcpFastOpen() {
      * Enables TCP FastOpen on the server channel. If the underlying os doesn't support TCP_FASTOPEN setting this has no
      * effect. This has to be set before doing listen on the socket otherwise this takes no effect.
      *
-     * @param enableTcpFastOpen {@code true} if TCP FastOpen should be enabled for incomming connections.
+     * @param enableTcpFastOpen {@code true} if TCP FastOpen should be enabled for incoming connections.
      *
      * @see <a href="https://tools.ietf.org/html/rfc7413#appendix-A.2">RFC 7413 Passive Open</a>
      */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -403,12 +403,14 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,
     }
 
     private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,
-                                   final ChannelPromise promise) {
+                                   ChannelPromise promise) {
 
         if (isStreamIdValid(headersFrame.stream().id())) {
             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),
                     headersFrame.isEndStream(), promise);
         } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {
+            promise = promise.unvoid();
+
             final int streamId = headersFrame.stream().id();
 
             encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspEncoder.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.util.CharsetUtil;
-import io.netty.util.internal.StringUtil;
 
 import static io.netty.handler.codec.http.HttpConstants.*;
 
@@ -61,8 +60,7 @@ protected void encodeInitialLine(final ByteBuf buf, final HttpMessage message)
             buf.writeCharSequence(response.status().reasonPhrase(), CharsetUtil.US_ASCII);
             ByteBufUtil.writeShortBE(buf, CRLF_SHORT);
         } else {
-            throw new UnsupportedMessageTypeException("Unsupported type "
-                                + StringUtil.simpleClassName(message));
+            throw new UnsupportedMessageTypeException(message, HttpRequest.class, HttpResponse.class);
         }
     }
 }

File: common/src/main/java/io/netty/util/AsciiStringUtil.java
Patch:
@@ -101,7 +101,7 @@ private static void toLowerCase(final byte[] src, final int srcOffset, final byt
         final int longCount = length >>> 3;
         int offset = 0;
         for (int i = 0; i < longCount; ++i) {
-            final long word = PlatformDependent.getLong(src, srcOffset);
+            final long word = PlatformDependent.getLong(src, srcOffset + offset);
             PlatformDependent.putLong(dst, offset, SWARUtil.toLowerCase(word));
             offset += Long.BYTES;
         }
@@ -216,7 +216,7 @@ private static void toUpperCase(final byte[] src, final int srcOffset, final byt
         final int longCount = length >>> 3;
         int offset = 0;
         for (int i = 0; i < longCount; ++i) {
-            final long word = PlatformDependent.getLong(src, srcOffset);
+            final long word = PlatformDependent.getLong(src, srcOffset + offset);
             PlatformDependent.putLong(dst, offset, SWARUtil.toUpperCase(word));
             offset += Long.BYTES;
         }

File: common/src/main/java/io/netty/util/AsciiStringUtil.java
Patch:
@@ -131,7 +131,8 @@ private static void unrolledToLowerCase(final byte[] src, int srcPos,
             offset += Short.BYTES;
         }
 
-        if ((byteCount & 1) != Byte.BYTES) {
+        // this is equivalent to byteCount >= Byte.BYTES (i.e. whether byteCount is odd)
+        if ((byteCount & Byte.BYTES) != 0) {
             PlatformDependent.putByte(dst, dstOffset + offset,
                                       toLowerCase(PlatformDependent.getByte(src, srcPos + offset)));
         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandshakeTimeoutException.java
Patch:
@@ -22,7 +22,7 @@
  */
 public final class SslHandshakeTimeoutException extends SSLHandshakeException {
 
-    SslHandshakeTimeoutException(String reason) {
+    public SslHandshakeTimeoutException(String reason) {
         super(reason);
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
Patch:
@@ -322,7 +322,8 @@ public void testChunkCorrect() throws Exception {
         DefaultHttpRequest defaultHttpRequest =
                 new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/");
 
-        HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(defaultHttpRequest);
+        HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(defaultHttpRequest,
+                140, HttpPostRequestDecoder.DEFAULT_MAX_BUFFERED_BYTES);
 
         int firstChunk = 10;
         int middleChunk = 1024;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -185,7 +185,8 @@ public HttpPostMultipartRequestDecoder(HttpDataFactory factory, HttpRequest requ
      *             errors
      */
     public HttpPostMultipartRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
-        this(factory, request, charset, HttpPostRequestDecoder.DEFAULT_MAX_FIELDS, HttpPostRequestDecoder.DEFAULT_MAX_BUFFERED_BYTES);
+        this(factory, request, charset, HttpPostRequestDecoder.DEFAULT_MAX_FIELDS,
+                HttpPostRequestDecoder.DEFAULT_MAX_BUFFERED_BYTES);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
Patch:
@@ -161,7 +161,8 @@ public HttpPostStandardRequestDecoder(HttpDataFactory factory, HttpRequest reque
      *             errors
      */
     public HttpPostStandardRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
-        this(factory, request, charset, HttpPostRequestDecoder.DEFAULT_MAX_FIELDS, HttpPostRequestDecoder.DEFAULT_MAX_BUFFERED_BYTES);
+        this(factory, request, charset, HttpPostRequestDecoder.DEFAULT_MAX_FIELDS,
+                HttpPostRequestDecoder.DEFAULT_MAX_BUFFERED_BYTES);
     }
 
     /**

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -320,7 +320,7 @@ protected void doBind(SocketAddress localAddress) throws Exception {
             if (socketAddress.getAddress().isAnyLocalAddress() &&
                     socketAddress.getAddress() instanceof Inet4Address) {
                 if (socket.family() == InternetProtocolFamily.IPv6) {
-                    localAddress = new InetSocketAddress(LinuxSocket.INET6_ANY, socketAddress.getPort());
+                    localAddress = new InetSocketAddress(Native.INET6_ANY, socketAddress.getPort());
                 }
             }
         }

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -3469,7 +3469,9 @@ public DatagramChannel newChannel() {
             if (resolver != null) {
                 resolver.close();
             }
-            serverSocket.close();
+            if (serverSocket != null) {
+                serverSocket.close();
+            }
         }
     }
 

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -4442,6 +4442,7 @@ public void testBufferUnderflowPacketSizeDependency(SSLEngineTestParam param) th
             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
 
             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
+            fail();
         } catch (SSLHandshakeException expected) {
             // Expected
         } finally {

File: handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java
Patch:
@@ -28,6 +28,7 @@
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Delegates all operations to a wrapped {@link OpenSslSession} except the methods defined by {@link ExtendedSSLSession}

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -220,7 +220,7 @@ public static int getContentLength(HttpMessage message, int defaultValue) {
      * Returns the content length of the specified web socket message. If the
      * specified message is not a web socket message, {@code -1} is returned.
      */
-    private static int getWebSocketContentLength(HttpMessage message) {
+    static int getWebSocketContentLength(HttpMessage message) {
         // WebSocket messages have constant content-lengths.
         HttpHeaders h = message.headers();
         if (message instanceof HttpRequest) {

File: common/src/main/java/io/netty/util/internal/logging/LocationAwareSlf4JLogger.java
Patch:
@@ -47,7 +47,7 @@ private void log(final int level, final String message, Throwable cause) {
     }
 
     private void log(final int level, final org.slf4j.helpers.FormattingTuple tuple) {
-        logger.log(null, FQCN, level, tuple.getMessage(), tuple.getArgArray(), tuple.getThrowable());
+        logger.log(null, FQCN, level, tuple.getMessage(), null, tuple.getThrowable());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieHeaderNames.java
Patch:
@@ -30,6 +30,8 @@ public final class CookieHeaderNames {
 
     public static final String SAMESITE = "SameSite";
 
+    public static final String PARTITIONED = "Partitioned";
+
     /**
      * Possible values for the SameSite attribute.
      * See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-05">changes to RFC6265bis</a>

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java
Patch:
@@ -129,6 +129,9 @@ public String encode(Cookie cookie) {
             if (c.sameSite() != null) {
                 add(buf, CookieHeaderNames.SAMESITE, c.sameSite().name());
             }
+            if (c.isPartitioned()) {
+                add(buf, CookieHeaderNames.PARTITIONED);
+            }
         }
 
         return stripTrailingSeparator(buf);

File: codec-http/src/test/java/io/netty/handler/codec/http/cookie/ServerCookieEncoderTest.java
Patch:
@@ -44,13 +44,14 @@ public void testEncodingSingleCookieV0() throws ParseException {
         int maxAge = 50;
 
         String result = "myCookie=myValue; Max-Age=50; Expires=(.+?); Path=/apathsomewhere;" +
-                " Domain=.adomainsomewhere; Secure; SameSite=Lax";
+                " Domain=.adomainsomewhere; Secure; SameSite=Lax; Partitioned";
         DefaultCookie cookie = new DefaultCookie("myCookie", "myValue");
         cookie.setDomain(".adomainsomewhere");
         cookie.setMaxAge(maxAge);
         cookie.setPath("/apathsomewhere");
         cookie.setSecure(true);
         cookie.setSameSite(SameSite.Lax);
+        cookie.setPartitioned(true);
 
         String encodedCookie = ServerCookieEncoder.STRICT.encode(cookie);
 

File: handler/src/main/java/io/netty/handler/ssl/util/LazyX509Certificate.java
Patch:
@@ -93,7 +93,7 @@ public Collection<List<?>> getSubjectAlternativeNames() throws CertificateParsin
 
     @Override
     public Collection<List<?>> getIssuerAlternativeNames() throws CertificateParsingException {
-        return unwrap().getSubjectAlternativeNames();
+        return unwrap().getIssuerAlternativeNames();
     }
 
     // No @Override annotation as it was only introduced in Java8.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -567,7 +567,7 @@ private ChannelFuture writeContinuationFrames(ChannelHandlerContext ctx, int str
                 ByteBuf fragment = headerBlock.readRetainedSlice(fragmentReadableBytes);
 
                 if (headerBlock.isReadable()) {
-                    ctx.write(buf.retain(), promiseAggregator.newPromise());
+                    ctx.write(buf.retainedSlice(), promiseAggregator.newPromise());
                 } else {
                     // The frame header is different for the last frame, so re-allocate and release the old buffer
                     flags = flags.endOfHeaders(true);

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java
Patch:
@@ -36,8 +36,7 @@ public final class EpollDatagramChannelConfig extends EpollChannelConfig impleme
     private volatile int maxDatagramSize;
 
     EpollDatagramChannelConfig(EpollDatagramChannel channel) {
-        super(channel);
-        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
+        super(channel, new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainDatagramChannelConfig.java
Patch:
@@ -37,8 +37,7 @@ public final class EpollDomainDatagramChannelConfig extends EpollChannelConfig i
     private boolean activeOnOpen;
 
     EpollDomainDatagramChannelConfig(EpollDomainDatagramChannel channel) {
-        super(channel);
-        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
+        super(channel, new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannelConfig.java
Patch:
@@ -47,8 +47,7 @@ public final class KQueueDatagramChannelConfig extends KQueueChannelConfig imple
     private boolean activeOnOpen;
 
     KQueueDatagramChannelConfig(KQueueDatagramChannel channel) {
-        super(channel);
-        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
+        super(channel, new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainDatagramChannelConfig.java
Patch:
@@ -38,8 +38,7 @@ public final class KQueueDomainDatagramChannelConfig
     private boolean activeOnOpen;
 
     KQueueDomainDatagramChannelConfig(KQueueDomainDatagramChannel channel) {
-        super(channel);
-        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
+        super(channel, new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/PoolChunkList.java
Patch:
@@ -97,7 +97,7 @@ void prevList(PoolChunkList<T> prevList) {
     }
 
     boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int sizeIdx, PoolThreadCache threadCache) {
-        int normCapacity = arena.sizeIdx2size(sizeIdx);
+        int normCapacity = arena.sizeClass.sizeIdx2size(sizeIdx);
         if (normCapacity > maxCapacity) {
             // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can
             // be handled by the PoolChunks that are contained in this PoolChunkList.

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -60,7 +60,8 @@ private void init0(PoolChunk<T> chunk, ByteBuffer nioBuffer,
                        long handle, int offset, int length, int maxLength, PoolThreadCache cache) {
         assert handle >= 0;
         assert chunk != null;
-        assert !PoolChunk.isSubpage(handle) || chunk.arena.size2SizeIdx(maxLength) <= chunk.arena.smallMaxSizeIdx:
+        assert !PoolChunk.isSubpage(handle) ||
+                chunk.arena.sizeClass.size2SizeIdx(maxLength) <= chunk.arena.sizeClass.smallMaxSizeIdx:
                 "Allocated small sub-page handle for a buffer size that isn't \"small.\"";
 
         chunk.incrementPinnedMemory(maxLength);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -416,7 +416,9 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers
                                 "Multiple content-length headers received");
                     }
                 }
-            } else if (validateHeaders && !headers.isEmpty()) {
+                // Use size() instead of isEmpty() for backward compatibility with grpc-java prior to 1.59.1,
+                // see https://github.com/grpc/grpc-java/issues/10665
+            } else if (validateHeaders && headers.size() > 0) {
                 // Need to check trailers don't contain pseudo headers. According to RFC 9113
                 // Trailers MUST NOT include pseudo-header fields (Section 8.3).
                 for (Iterator<Entry<CharSequence, CharSequence>> iterator =

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -41,6 +41,9 @@
 /**
  * Provides the constants for the standard HTTP header names and values and
  * commonly used utility methods that accesses an {@link HttpMessage}.
+ * <p>
+ * Concrete instances of this class are most easily obtained from its default factory:
+ * {@link DefaultHttpHeadersFactory#headersFactory()}.
  */
 public abstract class HttpHeaders implements Iterable<Map.Entry<String, String>> {
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/ReadOnlyHttpHeaders.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.Set;
 
 import static io.netty.handler.codec.CharSequenceValueConverter.INSTANCE;
-import static io.netty.handler.codec.http.DefaultHttpHeaders.HttpNameValidator;
 import static io.netty.util.AsciiString.contentEquals;
 import static io.netty.util.AsciiString.contentEqualsIgnoreCase;
 
@@ -69,7 +68,7 @@ private static IllegalArgumentException newInvalidArraySizeException() {
 
     private static void validateHeaders(CharSequence... keyValuePairs) {
         for (int i = 0; i < keyValuePairs.length; i += 2) {
-            HttpNameValidator.validateName(keyValuePairs[i]);
+            DefaultHttpHeadersFactory.headersFactory().getNameValidator().validateName(keyValuePairs[i]);
         }
     }
 

File: common/src/main/java/io/netty/util/internal/Hidden.java
Patch:
@@ -162,6 +162,9 @@ public void applyTo(BlockHound.Builder builder) {
                     "io.netty.util.NetUtil$SoMaxConnAction",
                     "run");
 
+            builder.allowBlockingCallsInside("io.netty.util.internal.ReferenceCountUpdater",
+                    "retryRelease0");
+
             builder.allowBlockingCallsInside("io.netty.util.internal.PlatformDependent", "createTempFile");
             builder.nonBlockingThreadPredicate(new Function<Predicate<Thread>, Predicate<Thread>>() {
                 @Override

File: transport/src/main/java/io/netty/channel/ChannelMetadata.java
Patch:
@@ -35,7 +35,7 @@ public final class ChannelMetadata {
      *                          again, such as UDP/IP.
      */
     public ChannelMetadata(boolean hasDisconnect) {
-        this(hasDisconnect, 1);
+        this(hasDisconnect, 16);
     }
 
     /**

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainDatagramChannel.java
Patch:
@@ -44,7 +44,7 @@
 @UnstableApi
 public final class EpollDomainDatagramChannel extends AbstractEpollChannel implements DomainDatagramChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true, 16);
 
     private static final String EXPECTED_TYPES =
             " (expected: " +

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -54,7 +54,7 @@
  * maximal performance.
  */
 public final class EpollDatagramChannel extends AbstractEpollChannel implements DatagramChannel {
-    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true, 16);
     private static final String EXPECTED_TYPES =
             " (expected: " + StringUtil.simpleClassName(DatagramPacket.class) + ", " +
             StringUtil.simpleClassName(AddressedEnvelope.class) + '<' +

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueDatagramChannel.java
Patch:
@@ -23,7 +23,7 @@
 
 abstract class AbstractKQueueDatagramChannel extends AbstractKQueueChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true, 16);
 
     AbstractKQueueDatagramChannel(Channel parent, BsdSocket fd, boolean active) {
         super(parent, fd, active);

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -65,7 +65,7 @@
 public final class NioDatagramChannel
         extends AbstractNioMessageChannel implements io.netty.channel.socket.DatagramChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true, 16);
     private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
     private static final String EXPECTED_TYPES =
             " (expected: " + StringUtil.simpleClassName(DatagramPacket.class) + ", " +

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodecBuilder.java
Patch:
@@ -196,8 +196,8 @@ public Http2FrameCodecBuilder decoderEnforceMaxConsecutiveEmptyDataFrames(int ma
 
     @Override
     public Http2FrameCodecBuilder decoderEnforceMaxRstFramesPerWindow(
-            int maxConsecutiveEmptyFrames, int secondsPerWindow) {
-        return super.decoderEnforceMaxRstFramesPerWindow(maxConsecutiveEmptyFrames, secondsPerWindow);
+            int maxRstFramesPerWindow, int secondsPerWindow) {
+        return super.decoderEnforceMaxRstFramesPerWindow(maxRstFramesPerWindow, secondsPerWindow);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -213,8 +213,8 @@ public Http2MultiplexCodecBuilder decoderEnforceMaxConsecutiveEmptyDataFrames(in
 
     @Override
     public Http2MultiplexCodecBuilder decoderEnforceMaxRstFramesPerWindow(
-            int maxConsecutiveEmptyFrames, int secondsPerWindow) {
-        return super.decoderEnforceMaxRstFramesPerWindow(maxConsecutiveEmptyFrames, secondsPerWindow);
+            int maxRstFramesPerWindow, int secondsPerWindow) {
+        return super.decoderEnforceMaxRstFramesPerWindow(maxRstFramesPerWindow, secondsPerWindow);
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -583,7 +583,7 @@ private T buildFromConnection(Http2Connection connection) {
         }
 
         DefaultHttp2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader,
-                promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame());
+            promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame(), isValidateHeaders());
         return buildFromCodec(decoder, encoder);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodecBuilder.java
Patch:
@@ -224,7 +224,7 @@ public Http2FrameCodec build() {
                 encoder = new StreamBufferingEncoder(encoder);
             }
             Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, frameReader,
-                    promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame());
+                    promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame(), isValidateHeaders());
             int maxConsecutiveEmptyDataFrames = decoderEnforceMaxConsecutiveEmptyDataFrames();
             if (maxConsecutiveEmptyDataFrames > 0) {
                 decoder = new Http2EmptyDataFrameConnectionDecoder(decoder, maxConsecutiveEmptyDataFrames);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -238,8 +238,7 @@ public Http2MultiplexCodec build() {
                 encoder = new StreamBufferingEncoder(encoder);
             }
             Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, frameReader,
-                    promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame());
-
+                    promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame(), isValidateHeaders());
             int maxConsecutiveEmptyDataFrames = decoderEnforceMaxConsecutiveEmptyDataFrames();
             if (maxConsecutiveEmptyDataFrames > 0) {
                 decoder = new Http2EmptyDataFrameConnectionDecoder(decoder, maxConsecutiveEmptyDataFrames);

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -301,8 +301,7 @@ public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectA
             heapArenas = newArenaArray(nHeapArena);
             List<PoolArenaMetric> metrics = new ArrayList<PoolArenaMetric>(heapArenas.length);
             for (int i = 0; i < heapArenas.length; i ++) {
-                PoolArena.HeapArena arena = new PoolArena.HeapArena(this,
-                        pageSize, pageShifts, chunkSize);
+                PoolArena.HeapArena arena = new PoolArena.HeapArena(this, pageSize, pageShifts, chunkSize);
                 heapArenas[i] = arena;
                 metrics.add(arena);
             }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
Patch:
@@ -84,7 +84,7 @@ public DefaultDnsCache(int minTtl, int maxTtl, int negativeTtl) {
             throw new IllegalArgumentException(
                     "minTtl: " + minTtl + ", maxTtl: " + maxTtl + " (expected: 0 <= minTtl <= maxTtl)");
         }
-        this.negativeTtl = checkPositiveOrZero(negativeTtl, "negativeTtl");
+        this.negativeTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(negativeTtl, "negativeTtl"));
     }
 
     /**

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -115,10 +115,8 @@ public abstract class ReferenceCountedOpenSslContext extends SslContext implemen
 
     static final boolean SERVER_ENABLE_SESSION_CACHE =
             SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.sessionCacheServer", true);
-    // session caching is disabled by default on the client side due a JDK bug:
-    // https://mail.openjdk.java.net/pipermail/security-dev/2021-March/024758.html
     static final boolean CLIENT_ENABLE_SESSION_CACHE =
-            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.sessionCacheClient", false);
+            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.sessionCacheClient", true);
 
     /**
      * The OpenSSL SSL_CTX object.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
Patch:
@@ -305,7 +305,7 @@ private void encodeStringLiteral(ByteBuf out, CharSequence string) {
                 AsciiString asciiString = (AsciiString) string;
                 out.writeBytes(asciiString.array(), asciiString.arrayOffset(), asciiString.length());
             } else {
-                // Only ASCII is allowed in http2 headers, so its fine to use this.
+                // Only ASCII is allowed in http2 headers, so it is fine to use this.
                 // https://tools.ietf.org/html/rfc7540#section-8.1.2
                 out.writeCharSequence(string, CharsetUtil.ISO_8859_1);
             }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackHuffmanEncoder.java
Patch:
@@ -87,7 +87,7 @@ private void encodeSlowPath(ByteBuf out, CharSequence data) {
         int n = 0;
 
         for (int i = 0; i < data.length(); i++) {
-            int b = data.charAt(i) & 0xFF;
+            int b = AsciiString.c2b(data.charAt(i)) & 0xFF;
             int code = codes[b];
             int nbits = lengths[b];
 
@@ -133,7 +133,7 @@ int getEncodedLength(CharSequence data) {
     private int getEncodedLengthSlowPath(CharSequence data) {
         long len = 0;
         for (int i = 0; i < data.length(); i++) {
-            len += lengths[data.charAt(i) & 0xFF];
+            len += lengths[AsciiString.c2b(data.charAt(i)) & 0xFF];
         }
         return (int) (len + 7 >> 3);
     }

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -775,7 +775,7 @@ public int lastIndexOf(CharSequence subString, int start) {
             return INDEX_NOT_FOUND;
         }
         final byte firstCharAsByte = c2b0(firstChar);
-        for (int i = offset + start; i >= 0; --i) {
+        for (int i = offset + start; i >= offset; --i) {
             if (value[i] == firstCharAsByte) {
                 int o1 = i, o2 = 0;
                 while (++o2 < subCount && b2c(value[++o1]) == subString.charAt(o2)) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -253,6 +253,7 @@ public DnsNameResolverBuilder negativeTtl(int negativeTtl) {
 
     /**
      * Sets the timeout of each DNS query performed by this resolver (in milliseconds).
+     * {@code 0} disables the timeout. If not set or a negative number is set, the default timeout is used.
      *
      * @param queryTimeoutMillis the query timeout
      * @return {@code this}

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java
Patch:
@@ -32,11 +32,11 @@
 @Sharable
 public class WebSocket00FrameEncoder extends MessageToMessageEncoder<WebSocketFrame> implements WebSocketFrameEncoder {
     private static final ByteBuf _0X00 = Unpooled.unreleasableBuffer(
-            Unpooled.directBuffer(1, 1).writeByte((byte) 0x00)).asReadOnly();
+            Unpooled.directBuffer(1, 1).writeByte(0x00)).asReadOnly();
     private static final ByteBuf _0XFF = Unpooled.unreleasableBuffer(
             Unpooled.directBuffer(1, 1).writeByte((byte) 0xFF)).asReadOnly();
     private static final ByteBuf _0XFF_0X00 = Unpooled.unreleasableBuffer(
-            Unpooled.directBuffer(2, 2).writeByte((byte) 0xFF).writeByte((byte) 0x00)).asReadOnly();
+            Unpooled.directBuffer(2, 2).writeByte((byte) 0xFF).writeByte(0x00)).asReadOnly();
 
     @Override
     protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object> out) throws Exception {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -397,7 +397,7 @@ private void unmask(ByteBuf frame) {
 
         int intMask = mask;
         // Avoid sign extension on widening primitive conversion
-        long longMask = (long) intMask & 0xFFFFFFFFL;
+        long longMask = intMask & 0xFFFFFFFFL;
         longMask |= longMask << 32;
 
         for (int lim = end - 7; i < lim; i += 8) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -187,7 +187,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object
                     if (srcOrder == dstOrder) {
                         // Use the optimized path only when byte orders match.
                         // Avoid sign extension on widening primitive conversion
-                        long longMask = (long) mask & 0xFFFFFFFFL;
+                        long longMask = mask & 0xFFFFFFFFL;
                         longMask |= longMask << 32;
 
                         // If the byte order of our buffers it little endian we have to bring our mask

File: example/src/main/java/io/netty/example/ocsp/OcspUtils.java
Patch:
@@ -82,7 +82,7 @@ public static URI ocspUri(X509Certificate certificate) throws IOException {
         }
 
         byte[] encoded = taggedObject.getEncoded();
-        int length = (int) encoded[1] & 0xFF;
+        int length = encoded[1] & 0xFF;
         String uri = new String(encoded, 2, length, CharsetUtil.UTF_8);
         return URI.create(uri);
     }

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollEventArray.java
Patch:
@@ -111,7 +111,7 @@ int fd(int index) {
 
     private int getInt(int index, int offset) {
         if (PlatformDependent.hasUnsafe()) {
-            long n = (long) index * (long) EPOLL_EVENT_SIZE;
+            long n = (long) index * EPOLL_EVENT_SIZE;
             return PlatformDependent.getInt(memoryAddress + n + offset);
         }
         return memory.getInt(index * EPOLL_EVENT_SIZE + offset);

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -47,7 +47,6 @@
  * <p>
  * All methods must be called by a transport implementation from an I/O thread, except the following ones:
  * <ul>
- * <li>{@link #size()} and {@link #isEmpty()}</li>
  * <li>{@link #isWritable()}</li>
  * <li>{@link #getUserDefinedWritability(int)} and {@link #setUserDefinedWritability(int, boolean)}</li>
  * </ul>

File: codec/src/test/java/io/netty/handler/codec/compression/AbstractEncoderTest.java
Patch:
@@ -87,6 +87,7 @@ protected void testCompression(final ByteBuf data) throws Exception {
         final int dataLength = data.readableBytes();
         assertTrue(channel.writeOutbound(data.retain()));
         assertTrue(channel.finish());
+        assertEquals(0, data.readableBytes());
 
         ByteBuf decompressed = readDecompressed(dataLength);
         assertEquals(data.resetReaderIndex(), decompressed);
@@ -101,12 +102,14 @@ protected void testCompressionOfBatchedFlow(final ByteBuf data) throws Exception
         while (written + length < dataLength) {
             ByteBuf in = data.retainedSlice(written, length);
             assertTrue(channel.writeOutbound(in));
+            assertEquals(0, in.readableBytes());
             written += length;
             length = rand.nextInt(100);
         }
         ByteBuf in = data.retainedSlice(written, dataLength - written);
         assertTrue(channel.writeOutbound(in));
         assertTrue(channel.finish());
+        assertEquals(0, in.readableBytes());
 
         ByteBuf decompressed = readDecompressed(dataLength);
         assertEquals(data, decompressed);

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java
Patch:
@@ -869,7 +869,7 @@ public ByteBuf slice(int index, int length) {
     @Override
     public ByteBuf retainedSlice(int index, int length) {
         checkIndex(index, length);
-        return buffer.slice(index, length);
+        return buffer.retainedSlice(index, length);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -120,7 +120,7 @@ public final ByteBuf capacity(int newCapacity) {
 
         // Reallocation required.
         chunk.decrementPinnedMemory(maxLength);
-        chunk.arena.reallocate(this, newCapacity, true);
+        chunk.arena.reallocate(this, newCapacity);
         return this;
     }
 

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -58,7 +58,7 @@
 
 abstract class AbstractEpollChannel extends AbstractChannel implements UnixChannel {
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
-    final LinuxSocket socket;
+    protected final LinuxSocket socket;
     /**
      * The future of the current connection attempt.  If not null, subsequent
      * connection attempts will fail.
@@ -110,7 +110,7 @@ static boolean isSoErrorZero(Socket fd) {
         }
     }
 
-    void setFlag(int flag) throws IOException {
+    protected void setFlag(int flag) throws IOException {
         if (!isFlagSet(flag)) {
             flags |= flag;
             modifyEvents();

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java
Patch:
@@ -34,11 +34,11 @@ protected AbstractEpollServerChannel(int fd) {
         this(new LinuxSocket(fd), false);
     }
 
-    AbstractEpollServerChannel(LinuxSocket fd) {
+    protected AbstractEpollServerChannel(LinuxSocket fd) {
         this(fd, isSoErrorZero(fd));
     }
 
-    AbstractEpollServerChannel(LinuxSocket fd, boolean active) {
+    protected AbstractEpollServerChannel(LinuxSocket fd, boolean active) {
         super(null, fd, active);
     }
 
@@ -72,7 +72,7 @@ protected Object filterOutboundMessage(Object msg) throws Exception {
         throw new UnsupportedOperationException();
     }
 
-    abstract Channel newChildChannel(int fd, byte[] remote, int offset, int len) throws Exception;
+    protected abstract Channel newChildChannel(int fd, byte[] remote, int offset, int len) throws Exception;
 
     final class EpollServerSocketUnsafe extends AbstractEpollUnsafe {
         // Will hold the remote address after accept(...) was successful.

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -96,7 +96,7 @@ protected AbstractEpollStreamChannel(int fd) {
         flags |= Native.EPOLLRDHUP;
     }
 
-    AbstractEpollStreamChannel(Channel parent, LinuxSocket fd, SocketAddress remote) {
+    protected AbstractEpollStreamChannel(Channel parent, LinuxSocket fd, SocketAddress remote) {
         super(parent, fd, remote);
         // Add EPOLLRDHUP so we are notified once the remote peer close the connection.
         flags |= Native.EPOLLRDHUP;

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/Errors.java
Patch:
@@ -122,7 +122,7 @@ int expectedErr() {
         }
     }
 
-    static boolean handleConnectErrno(String method, int err) throws IOException {
+    public static boolean handleConnectErrno(String method, int err) throws IOException {
         if (err == ERRNO_EINPROGRESS_NEGATIVE || err == ERROR_EALREADY_NEGATIVE) {
             // connect not complete yet need to wait for EPOLLOUT event.
             // EALREADY has been observed when using tcp fast open on centos8.

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1038,7 +1038,9 @@ private SSLEngineResult wrap(ByteBufAllocator alloc, SSLEngine engine, ByteBuf i
             }
 
             for (;;) {
-                ByteBuffer out0 = out.nioBuffer(out.writerIndex(), out.writableBytes());
+                // Use toByteBuffer(...) which might be able to return the internal ByteBuffer and so reduce
+                // allocations.
+                ByteBuffer out0 = toByteBuffer(out, out.writerIndex(), out.writableBytes());
                 SSLEngineResult result = engine.wrap(in0, out0);
                 in.skipBytes(result.bytesConsumed());
                 out.writerIndex(out.writerIndex() + result.bytesProduced());

File: transport/src/test/java/io/netty/channel/nio/SelectedSelectionKeySetTest.java
Patch:
@@ -102,8 +102,8 @@ public void contains() {
         SelectedSelectionKeySet set = new SelectedSelectionKeySet();
         assertTrue(set.add(mockKey));
         assertTrue(set.add(mockKey2));
-        assertFalse(set.contains(mockKey));
-        assertFalse(set.contains(mockKey2));
+        assertTrue(set.contains(mockKey));
+        assertTrue(set.contains(mockKey2));
         assertFalse(set.contains(mockKey3));
     }
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java
Patch:
@@ -30,11 +30,12 @@
 final class DatagramDnsQueryContext extends DnsQueryContext {
 
     DatagramDnsQueryContext(Channel channel, Future<? extends Channel> channelReadyFuture,
+                            InetSocketAddress nameServerAddr,
                             DnsQueryContextManager queryContextManager,
                             int maxPayLoadSize, boolean recursionDesired,
                             DnsQuestion question, DnsRecord[] additionals,
                             Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {
-        super(channel, channelReadyFuture, queryContextManager, maxPayLoadSize, recursionDesired,
+        super(channel, channelReadyFuture, nameServerAddr, queryContextManager, maxPayLoadSize, recursionDesired,
                 question, additionals, promise);
     }
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java
Patch:
@@ -30,11 +30,12 @@
 final class TcpDnsQueryContext extends DnsQueryContext {
 
     TcpDnsQueryContext(Channel channel, Future<? extends Channel> channelReadyFuture,
+                       InetSocketAddress nameServerAddr,
                        DnsQueryContextManager queryContextManager,
                        int maxPayLoadSize, boolean recursionDesired,
                        DnsQuestion question, DnsRecord[] additionals,
                        Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {
-        super(channel, channelReadyFuture, queryContextManager, maxPayLoadSize, recursionDesired,
+        super(channel, channelReadyFuture, nameServerAddr, queryContextManager, maxPayLoadSize, recursionDesired,
                 question, additionals, promise);
     }
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java
Patch:
@@ -274,6 +274,8 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
 
         // Remove the id from the manager as soon as the query completes. This may be because of success, failure or
         // cancellation
-        parent.queryContextManager.remove(nameServerAddr, id);
+        DnsQueryContext self = parent.queryContextManager.remove(nameServerAddr, id);
+
+        assert self == this : "Removed DnsQueryContext is not the correct instance";
     }
 }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socksx.v4;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.DecoderResult;
@@ -57,8 +58,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 }
 
                 final Socks4CommandStatus status = Socks4CommandStatus.valueOf(in.readByte());
-                final int dstPort = in.readUnsignedShort();
-                final String dstAddr = NetUtil.intToIpAddress(in.readInt());
+                final int dstPort = ByteBufUtil.readUnsignedShortBE(in);
+                final String dstAddr = NetUtil.intToIpAddress(ByteBufUtil.readIntBE(in));
 
                 out.add(new DefaultSocks4CommandResponse(status, dstAddr, dstPort));
                 checkpoint(State.SUCCESS);

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientEncoder.java
Patch:
@@ -42,7 +42,7 @@ private Socks4ClientEncoder() { }
     protected void encode(ChannelHandlerContext ctx, Socks4CommandRequest msg, ByteBuf out) throws Exception {
         out.writeByte(msg.version().byteValue());
         out.writeByte(msg.type().byteValue());
-        out.writeShort(msg.dstPort());
+        ByteBufUtil.writeShortBE(out, msg.dstPort());
         if (NetUtil.isValidIpV4Address(msg.dstAddr())) {
             out.writeBytes(NetUtil.createByteArrayFromIpAddressString(msg.dstAddr()));
             ByteBufUtil.writeAscii(out, msg.userId());

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socksx.v4;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.DecoderResult;
@@ -68,8 +69,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 }
 
                 type = Socks4CommandType.valueOf(in.readByte());
-                dstPort = in.readUnsignedShort();
-                dstAddr = NetUtil.intToIpAddress(in.readInt());
+                dstPort = ByteBufUtil.readUnsignedShortBE(in);
+                dstAddr = NetUtil.intToIpAddress(ByteBufUtil.readIntBE(in));
                 checkpoint(State.READ_USERID);
             }
             case READ_USERID: {

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerEncoder.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.socksx.v4;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToByteEncoder;
@@ -38,7 +39,7 @@ private Socks4ServerEncoder() { }
     protected void encode(ChannelHandlerContext ctx, Socks4CommandResponse msg, ByteBuf out) throws Exception {
         out.writeByte(0);
         out.writeByte(msg.status().byteValue());
-        out.writeShort(msg.dstPort());
+        ByteBufUtil.writeShortBE(out, msg.dstPort());
         out.writeBytes(msg.dstAddr() == null? IPv4_HOSTNAME_ZEROED
                                             : NetUtil.createByteArrayFromIpAddressString(msg.dstAddr()));
     }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressDecoder.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.socksx.v5;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.handler.codec.DecoderException;
 import io.netty.util.CharsetUtil;
 import io.netty.util.NetUtil;
@@ -36,7 +37,7 @@ public interface Socks5AddressDecoder {
         @Override
         public String decodeAddress(Socks5AddressType addrType, ByteBuf in) throws Exception {
             if (addrType == Socks5AddressType.IPv4) {
-                return NetUtil.intToIpAddress(in.readInt());
+                return NetUtil.intToIpAddress(ByteBufUtil.readIntBE(in));
             }
             if (addrType == Socks5AddressType.DOMAIN) {
                 final int length = in.readUnsignedByte();

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ClientEncoder.java
Patch:
@@ -110,6 +110,6 @@ private void encodeCommandRequest(Socks5CommandRequest msg, ByteBuf out) throws
         final Socks5AddressType dstAddrType = msg.dstAddrType();
         out.writeByte(dstAddrType.byteValue());
         addressEncoder.encodeAddress(dstAddrType, msg.dstAddr(), out);
-        out.writeShort(msg.dstPort());
+        ByteBufUtil.writeShortBE(out, msg.dstPort());
     }
 }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.socksx.v5;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.DecoderResult;
@@ -69,7 +70,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 in.skipBytes(1); // RSV
                 final Socks5AddressType dstAddrType = Socks5AddressType.valueOf(in.readByte());
                 final String dstAddr = addressDecoder.decodeAddress(dstAddrType, in);
-                final int dstPort = in.readUnsignedShort();
+                final int dstPort = ByteBufUtil.readUnsignedShortBE(in);
 
                 out.add(new DefaultSocks5CommandRequest(type, dstAddrType, dstAddr, dstPort));
                 checkpoint(State.SUCCESS);

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.socksx.v5;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.DecoderResult;
@@ -68,7 +69,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 in.skipBytes(1); // Reserved
                 final Socks5AddressType addrType = Socks5AddressType.valueOf(in.readByte());
                 final String addr = addressDecoder.decodeAddress(addrType, in);
-                final int port = in.readUnsignedShort();
+                final int port = ByteBufUtil.readUnsignedShortBE(in);
 
                 out.add(new DefaultSocks5CommandResponse(status, addrType, addr, port));
                 checkpoint(State.SUCCESS);

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ServerEncoder.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.socksx.v5;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.EncoderException;
@@ -87,6 +88,6 @@ private void encodeCommandResponse(Socks5CommandResponse msg, ByteBuf out) throw
         out.writeByte(bndAddrType.byteValue());
         addressEncoder.encodeAddress(bndAddrType, msg.bndAddr(), out);
 
-        out.writeShort(msg.bndPort());
+        ByteBufUtil.writeShortBE(out, msg.bndPort());
     }
 }

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainSocketChannel.java
Patch:
@@ -87,7 +87,7 @@ public EpollDomainSocketChannelConfig config() {
     @Override
     protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
         if (super.doConnect(remoteAddress, localAddress)) {
-            local = (DomainSocketAddress) localAddress;
+            local = localAddress != null ? (DomainSocketAddress) localAddress : socket.localDomainSocketAddress();
             remote = (DomainSocketAddress) remoteAddress;
             return true;
         }

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainSocketChannel.java
Patch:
@@ -80,7 +80,7 @@ public KQueueDomainSocketChannelConfig config() {
     @Override
     protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
         if (super.doConnect(remoteAddress, localAddress)) {
-            local = (DomainSocketAddress) localAddress;
+            local = localAddress != null ? (DomainSocketAddress) localAddress : socket.localDomainSocketAddress();
             remote = (DomainSocketAddress) remoteAddress;
             return true;
         }

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -567,15 +567,15 @@ public String toString() {
     private static void appendPoolSubPages(StringBuilder buf, PoolSubpage<?>[] subpages) {
         for (int i = 0; i < subpages.length; i ++) {
             PoolSubpage<?> head = subpages[i];
-            if (head.next == head) {
+            if (head.next == head || head.next == null) {
                 continue;
             }
 
             buf.append(StringUtil.NEWLINE)
                     .append(i)
                     .append(": ");
             PoolSubpage<?> s = head.next;
-            for (;;) {
+            while (s != null) {
                 buf.append(s);
                 s = s.next;
                 if (s == head) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -709,7 +709,7 @@ public ChannelFuture answer(InvocationOnMock invocation) throws Throwable {
     @Test
     public void canCloseStreamWithVoidPromise() throws Exception {
         handler = newHandler();
-        handler.closeStream(stream, ctx.voidPromise());
+        handler.closeStream(stream, ctx.voidPromise().setSuccess());
         verify(stream, times(1)).close();
         verifyNoMoreInteractions(stream);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -239,6 +239,7 @@ public void setContent(InputStream inputStream) throws IOException {
                 byteBuffer.position(read).flip();
                 written += localfileChannel.write(byteBuffer);
                 checkSize(written);
+                byteBuffer.clear();
                 read = inputStream.read(bytes);
             }
             localfileChannel.force(false);

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.DefaultProgressivePromise;
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.InternalThreadLocalMap;
 import io.netty.util.internal.ObjectPool;
@@ -247,7 +248,7 @@ public void progress(long amount) {
         assert p != null;
         final Class<?> promiseClass = p.getClass();
         // fast-path to save O(n) ChannelProgressivePromise's type check on OpenJDK
-        if (promiseClass == VoidChannelPromise.class) {
+        if (promiseClass == VoidChannelPromise.class || promiseClass == DefaultChannelPromise.class) {
             return;
         }
         // this is going to save from type pollution due to https://bugs.openjdk.org/browse/JDK-8180450

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -98,7 +98,7 @@ public void remoteSettings(Http2Settings settings) throws Http2Exception {
 
         Long headerTableSize = settings.headerTableSize();
         if (headerTableSize != null) {
-            outboundHeaderConfig.maxHeaderTableSize((int) min(headerTableSize, MAX_VALUE));
+            outboundHeaderConfig.maxHeaderTableSize(headerTableSize);
         }
 
         Long maxHeaderListSize = settings.maxHeaderListSize();

File: handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspServerCertificateValidator.java
Patch:
@@ -136,7 +136,7 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt
                         .getSession()
                         .getPeerCertificates();
 
-                assert certificates.length <= 2 : "There must an end-entity certificate and issuer certificate";
+                assert certificates.length >= 2 : "There must an end-entity certificate and issuer certificate";
 
                 Promise<BasicOCSPResp> ocspRespPromise = OcspClient.query((X509Certificate) certificates[0],
                         (X509Certificate) certificates[1], validateNonce, ioTransport, dnsNameResolver);

File: common/src/main/java/io/netty/util/internal/EmptyArrays.java
Patch:
@@ -37,5 +37,7 @@ public final class EmptyArrays {
     public static final X509Certificate[] EMPTY_X509_CERTIFICATES = {};
     public static final javax.security.cert.X509Certificate[] EMPTY_JAVAX_X509_CERTIFICATES = {};
 
+    public static final Throwable[] EMPTY_THROWABLES = {};
+
     private EmptyArrays() { }
 }

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -824,7 +824,7 @@ public void lazyExecute(Runnable task) {
 
     private void execute0(@Schedule Runnable task) {
         ObjectUtil.checkNotNull(task, "task");
-        execute(task, !(task instanceof LazyRunnable) && wakesUpForTask(task));
+        execute(task, wakesUpForTask(task));
     }
 
     private void lazyExecute0(@Schedule Runnable task) {
@@ -917,7 +917,7 @@ public final ThreadProperties threadProperties() {
     }
 
     /**
-     * @deprecated use {@link AbstractEventExecutor.LazyRunnable}
+     * @deprecated override {@link SingleThreadEventExecutor#wakesUpForTask} to re-create this behaviour
      */
     @Deprecated
     protected interface NonWakeupRunnable extends LazyRunnable { }

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -115,7 +115,7 @@ public final void executeAfterEventLoopIteration(Runnable task) {
             reject(task);
         }
 
-        if (!(task instanceof LazyRunnable) && wakesUpForTask(task)) {
+        if (wakesUpForTask(task)) {
             wakeup(inEventLoop());
         }
     }

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/Errors.java
Patch:
@@ -36,6 +36,7 @@
 import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.errnoEWOULDBLOCK;
 import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.errorEALREADY;
 import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.errorECONNREFUSED;
+import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.errorEHOSTUNREACH;
 import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.errorEISCONN;
 import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.errorENETUNREACH;
 import static io.netty.channel.unix.ErrorsStaticallyReferencedJniMethods.strError;
@@ -58,6 +59,7 @@ public final class Errors {
     public static final int ERROR_EISCONN_NEGATIVE = -errorEISCONN();
     public static final int ERROR_EALREADY_NEGATIVE = -errorEALREADY();
     public static final int ERROR_ENETUNREACH_NEGATIVE = -errorENETUNREACH();
+    public static final int ERROR_EHOSTUNREACH_NEGATIVE = -errorEHOSTUNREACH();
 
     /**
      * Holds the mappings for errno codes to String messages.
@@ -152,7 +154,7 @@ private static String errnoString(int err) {
     }
 
     private static IOException newConnectException0(String method, int err) {
-        if (err == ERROR_ENETUNREACH_NEGATIVE) {
+        if (err == ERROR_ENETUNREACH_NEGATIVE || err == ERROR_EHOSTUNREACH_NEGATIVE) {
             return new NoRouteToHostException();
         }
         if (err == ERROR_EISCONN_NEGATIVE) {

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/ErrorsStaticallyReferencedJniMethods.java
Patch:
@@ -42,5 +42,6 @@ private ErrorsStaticallyReferencedJniMethods() { }
     static native int errorEISCONN();
     static native int errorEALREADY();
     static native int errorENETUNREACH();
+    static native int errorEHOSTUNREACH();
     static native String strError(int err);
 }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexTest.java
Patch:
@@ -161,7 +161,7 @@ public void channelActive(ChannelHandlerContext ctx) {
                 any(ByteBuf.class), any(ChannelPromise.class));
     }
 
-    private Http2StreamChannel newInboundStream(int streamId, boolean endStream, final ChannelHandler childHandler) {
+    Http2StreamChannel newInboundStream(int streamId, boolean endStream, final ChannelHandler childHandler) {
         return newInboundStream(streamId, endStream, null, childHandler);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -208,7 +208,9 @@ final void onHttp2FrameStreamException(ChannelHandlerContext ctx, Http2FrameStre
         try {
             channel.pipeline().fireExceptionCaught(cause.getCause());
         } finally {
-            channel.unsafe().closeForcibly();
+            // Close with the correct error that causes this stream exception.
+            // See https://github.com/netty/netty/issues/13235#issuecomment-1441994672
+            channel.closeWithError(cause.error());
         }
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexHandler.java
Patch:
@@ -274,7 +274,9 @@ public void exceptionCaught(ChannelHandlerContext ctx, final Throwable cause) th
             try {
                 childChannel.pipeline().fireExceptionCaught(cause.getCause());
             } finally {
-                childChannel.unsafe().closeForcibly();
+                // Close with the correct error that causes this stream exception.
+                // See https://github.com/netty/netty/issues/13235#issuecomment-1441994672
+                childChannel.closeWithError(exception.error());
             }
             return;
         }

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -187,7 +188,8 @@ private static List<Entry<String, String>> formget(
         );
 
         // send request
-        channel.writeAndFlush(request);
+        channel.write(request);
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
 
         // Wait for the server to close the connection.
         channel.closeFuture().sync();

File: common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
Patch:
@@ -112,7 +112,8 @@ public final void setRefCnt(T instance, int refCnt) {
      * Resets the reference count to 1
      */
     public final void resetRefCnt(T instance) {
-        updater().set(instance, initialValue());
+        // no need of a volatile set, it should happen in a quiescent state
+        updater().lazySet(instance, initialValue());
     }
 
     public final T retain(T instance) {

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -107,7 +107,7 @@ static Level parseLevel(String levelStr) {
             logger.debug("-Dio.netty.noResourceLeakDetection: {}", disabled);
             logger.warn(
                     "-Dio.netty.noResourceLeakDetection is deprecated. Use '-D{}={}' instead.",
-                    PROP_LEVEL, DEFAULT_LEVEL.name().toLowerCase());
+                    PROP_LEVEL, Level.DISABLED.name().toLowerCase());
         } else {
             disabled = false;
         }

File: example/src/main/java/io/netty/example/ocsp/OcspUtils.java
Patch:
@@ -32,7 +32,7 @@
 import org.bouncycastle.asn1.ASN1ObjectIdentifier;
 import org.bouncycastle.asn1.ASN1Primitive;
 import org.bouncycastle.asn1.BERTags;
-import org.bouncycastle.asn1.DERTaggedObject;
+import org.bouncycastle.asn1.DLTaggedObject;
 import org.bouncycastle.asn1.DLSequence;
 import org.bouncycastle.asn1.x509.Extension;
 import org.bouncycastle.cert.ocsp.OCSPReq;
@@ -72,7 +72,7 @@ public static URI ocspUri(X509Certificate certificate) throws IOException {
         }
 
         DLSequence aiaSequence = (DLSequence) authorityInfoAccess;
-        DERTaggedObject taggedObject = findObject(aiaSequence, OCSP_RESPONDER_OID, DERTaggedObject.class);
+        DLTaggedObject taggedObject = findObject(aiaSequence, OCSP_RESPONDER_OID, DLTaggedObject.class);
         if (taggedObject == null) {
             return null;
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -557,6 +557,7 @@ public void testContentLengthHeaderAndChunked() {
         assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
         HttpRequest request = channel.readInbound();
         assertFalse(request.decoderResult().isFailure());
+        assertTrue(request.headers().names().contains("Transfer-Encoding"));
         assertTrue(request.headers().contains("Transfer-Encoding", "chunked", false));
         assertFalse(request.headers().contains("Content-Length"));
         LastHttpContent c = channel.readInbound();

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -94,9 +94,7 @@ public AsciiString(byte[] value, boolean copy) {
      */
     public AsciiString(byte[] value, int start, int length, boolean copy) {
         if (copy) {
-            final byte[] rangedCopy = new byte[length];
-            System.arraycopy(value, start, rangedCopy, 0, rangedCopy.length);
-            this.value = rangedCopy;
+            this.value = Arrays.copyOfRange(value, start, start + length);
             this.offset = 0;
         } else {
             if (isOutOfBounds(start, length, value.length)) {

File: handler/src/test/java/io/netty/handler/ssl/CipherSuiteConverterTest.java
Patch:
@@ -19,13 +19,15 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.sameInstance;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
 
+@Isolated
 public class CipherSuiteConverterTest {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(CipherSuiteConverterTest.class);

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -89,7 +89,7 @@
  * </pre>
  * Because the handler instance has a state variable which is dedicated to
  * one connection, you have to create a new handler instance for each new
- * channel to avoid a race condition where a unauthenticated client can get
+ * channel to avoid a race condition where an unauthenticated client can get
  * the confidential information:
  * <pre>
  * // Create a new handler instance per channel.

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -964,7 +964,7 @@ protected void doResolve(String inetHost,
         }
 
         if (!doResolveCached(hostname, additionals, promise, resolveCache)) {
-            doResolveUncached(hostname, additionals, promise, resolveCache, true);
+            doResolveUncached(hostname, additionals, promise, resolveCache, completeOncePreferredResolved);
         }
     }
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -3109,6 +3109,7 @@ public void testDropAAAAResolveFast() throws IOException {
                     .recursionDesired(false)
                     .queryTimeoutMillis(10000)
                     .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED)
+                    .completeOncePreferredResolved(true)
                     .maxQueriesPerResolve(16)
                     .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));
 

File: handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java
Patch:
@@ -141,8 +141,10 @@ public void read(ChannelHandlerContext ctx) throws Exception {
             // messages from upstream and once one arrives it need to be
             // relayed to downstream to keep the flow going.
             shouldConsume = true;
+            ctx.read();
+        } else if (config.isAutoRead()) {
+            ctx.read();
         }
-        ctx.read();
     }
 
     @Override

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java
Patch:
@@ -190,7 +190,7 @@ public void operationComplete(ChannelFuture future) {
 
     private void onQueryWriteCompletion(ChannelFuture writeFuture) {
         if (!writeFuture.isSuccess()) {
-            tryFailure("failed to send a query via " + protocol(), writeFuture.cause(), false);
+            tryFailure("failed to send a query '" + id + "' via " + protocol(), writeFuture.cause(), false);
             return;
         }
 
@@ -205,7 +205,7 @@ public void run() {
                         return;
                     }
 
-                    tryFailure("query via " + protocol() + " timed out after " +
+                    tryFailure("query '" + id + "' via " + protocol() + " timed out after " +
                             queryTimeoutMillis + " milliseconds", null, true);
                 }
             }, queryTimeoutMillis, TimeUnit.MILLISECONDS);
@@ -247,7 +247,7 @@ boolean tryFailure(String message, Throwable cause, boolean timeout) {
 
         final DnsNameResolverException e;
         if (timeout) {
-            // This was caused by an timeout so use DnsNameResolverTimeoutException to allow the user to
+            // This was caused by a timeout so use DnsNameResolverTimeoutException to allow the user to
             // handle it special (like retry the query).
             e = new DnsNameResolverTimeoutException(nameServerAddr, question(), buf.toString());
         } else {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java
Patch:
@@ -380,7 +380,7 @@ public void testInformationalResponseKeepsPairsInSync() {
         HttpContent content = ch.readInbound();
         // HTTP 102 is not allowed to have content.
         assertThat(content.content().readableBytes(), is(0));
-        assertThat(content, CoreMatchers.<HttpContent>instanceOf(LastHttpContent.class));
+        assertThat(content, instanceOf(LastHttpContent.class));
         content.release();
 
         assertTrue(ch.writeOutbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/")));
@@ -395,7 +395,7 @@ public void testInformationalResponseKeepsPairsInSync() {
         content = ch.readInbound();
         // HTTP 200 has content.
         assertThat(content.content().readableBytes(), is(8));
-        assertThat(content, CoreMatchers.<HttpContent>instanceOf(LastHttpContent.class));
+        assertThat(content, instanceOf(LastHttpContent.class));
         content.release();
 
         assertThat(ch.finish(), is(false));

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.AsciiString;
 import io.netty.util.CharsetUtil;
+import org.hamcrest.CoreMatchers;
 import org.junit.jupiter.api.Test;
 
 import java.util.ArrayList;
@@ -307,7 +308,7 @@ public void testTooLargeInitialLine() {
         assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
         HttpRequest request = channel.readInbound();
         assertTrue(request.decoderResult().isFailure());
-        assertTrue(request.decoderResult().cause() instanceof TooLongHttpLineException);
+        assertThat(request.decoderResult().cause(), instanceOf(TooLongHttpLineException.class));
         assertFalse(channel.finish());
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpServerUpgradeHandlerTest.java
Patch:
@@ -34,6 +34,7 @@
 import io.netty.util.ReferenceCountUtil;
 import org.junit.jupiter.api.Test;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -179,7 +180,7 @@ protected boolean shouldHandleUpgradeRequest(HttpRequest req) {
         assertNull(channel.pipeline().get("marker"));
 
         HttpRequest req = channel.readInbound();
-        assertFalse(req instanceof FullHttpRequest); // Should not be aggregated.
+        assertThat(req).isNotInstanceOf(FullHttpRequest.class); // Should not be aggregated.
         assertTrue(req.headers().contains(HttpHeaderNames.CONNECTION, "Upgrade", false));
         assertTrue(req.headers().contains(HttpHeaderNames.UPGRADE, "do-not-upgrade", false));
         assertTrue(channel.readInbound() instanceof LastHttpContent);

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
Patch:
@@ -40,6 +40,7 @@
 import java.util.Iterator;
 
 import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -188,7 +189,7 @@ private static void testCloseReason0(ChannelHandler... handlers) {
             // expected
         }
         ReferenceCounted closeMessage = ch.readOutbound();
-        assertThat(closeMessage, CoreMatchers.instanceOf(ByteBuf.class));
+        assertThat(closeMessage, instanceOf(ByteBuf.class));
         closeMessage.release();
         assertFalse(ch.finish());
     }

File: buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
Patch:
@@ -126,7 +126,7 @@ public void testIOBuffersAreDirectWhenUnsafeAvailableOrDirectBuffersPooled() {
 
     @Test
     public void testWithoutUseCacheForAllThreads() {
-        assertFalse(Thread.currentThread() instanceof FastThreadLocalThread);
+        assertThat(Thread.currentThread()).isNotInstanceOf(FastThreadLocalThread.class);
 
         PooledByteBufAllocator pool = new PooledByteBufAllocator(
                 /*preferDirect=*/ false,

File: buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java
Patch:
@@ -35,6 +35,7 @@
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.greaterThan;
+import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -617,7 +618,7 @@ public void testWriteUtf8Wrapped(BufferType bufferType) {
     }
 
     private static void assertWrapped(ByteBuf buf) {
-        assertTrue(buf instanceof WrappedByteBuf);
+        assertThat(buf, instanceOf(WrappedByteBuf.class));
     }
 
     @ParameterizedTest(name = PARAMETERIZED_NAME)

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
Patch:
@@ -135,7 +135,7 @@ public int statusCode() {
             return -1;
         }
 
-        return binaryData.getShort(binaryData.readerIndex());
+        return binaryData.getUnsignedShort(binaryData.readerIndex());
     }
 
     /**

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -2627,7 +2627,7 @@ public int getPeerPort() {
 
         @Override
         public int getPacketBufferSize() {
-            return maxEncryptedPacketLength();
+            return SSL.SSL_MAX_ENCRYPTED_LENGTH;
         }
 
         @Override

File: common/src/main/java/io/netty/util/internal/MacAddressUtil.java
Patch:
@@ -51,7 +51,7 @@ public static byte[] bestAvailableMac() {
 
         // Retrieve the list of available network interfaces.
         Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();
-        for (NetworkInterface iface: NetUtil.networkInterfaces()) {
+        for (NetworkInterface iface: NetUtil.NETWORK_INTERFACES) {
             // Use the interface with proper INET addresses only.
             Enumeration<InetAddress> addrs = SocketUtils.addressesFromNetworkInterface(iface);
             if (addrs.hasMoreElements()) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -164,7 +164,7 @@ public class DnsNameResolver extends InetNameResolver {
      * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.
      */
     private static boolean anyInterfaceSupportsIpV6() {
-        for (NetworkInterface iface : NetUtil.networkInterfaces()) {
+        for (NetworkInterface iface : NetUtil.NETWORK_INTERFACES) {
             Enumeration<InetAddress> addresses = iface.getInetAddresses();
             while (addresses.hasMoreElements()) {
                 InetAddress inetAddress = addresses.nextElement();

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -200,7 +200,7 @@ private InetSocketAddress newSocketAddress(NetworkInterface iface) {
     }
 
     private NetworkInterface multicastNetworkInterface() throws IOException {
-        for (NetworkInterface iface : NetUtil.networkInterfaces()) {
+        for (NetworkInterface iface : NetUtil.NETWORK_INTERFACES) {
             if (iface.isUp() && iface.supportsMulticast()) {
                 Enumeration<InetAddress> addresses = iface.getInetAddresses();
                 while (addresses.hasMoreElements()) {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.channel.socket.oio.OioDatagramChannel;
 import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.util.NetUtil;
 import io.netty.util.internal.SocketUtils;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
@@ -199,9 +200,7 @@ private InetSocketAddress newSocketAddress(NetworkInterface iface) {
     }
 
     private NetworkInterface multicastNetworkInterface() throws IOException {
-        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
-        while (interfaces.hasMoreElements()) {
-            NetworkInterface iface = interfaces.nextElement();
+        for (NetworkInterface iface : NetUtil.networkInterfaces()) {
             if (iface.isUp() && iface.supportsMulticast()) {
                 Enumeration<InetAddress> addresses = iface.getInetAddresses();
                 while (addresses.hasMoreElements()) {

File: transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
Patch:
@@ -214,7 +214,7 @@ public int getSystemReceiveBufferSize() {
     }
 
     @Override
-    public UdtChannelConfig setSystemSendBufferSize(
+    public UdtChannelConfig setSystemReceiveBufferSize(
             final int systemReceiveBufferSize) {
         this.systemReceiveBufferSize = systemReceiveBufferSize;
         return this;
@@ -233,7 +233,7 @@ public UdtChannelConfig setProtocolSendBufferSize(
     }
 
     @Override
-    public UdtChannelConfig setSystemReceiveBufferSize(
+    public UdtChannelConfig setSystemSendBufferSize(
             final int systemSendBufferSize) {
         this.systemSendBufferSize = systemSendBufferSize;
         return this;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
Patch:
@@ -94,7 +94,8 @@ public WebSocketClientProtocolHandler(WebSocketClientProtocolConfig clientConfig
             clientConfig.performMasking(),
             clientConfig.allowMaskMismatch(),
             clientConfig.forceCloseTimeoutMillis(),
-            clientConfig.absoluteUpgradeUrl()
+            clientConfig.absoluteUpgradeUrl(),
+            clientConfig.generateOriginHeader()
         );
         this.clientConfig = clientConfig;
     }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00Test.java
Patch:
@@ -23,9 +23,9 @@
 public class WebSocketClientHandshaker00Test extends WebSocketClientHandshakerTest {
     @Override
     protected WebSocketClientHandshaker newHandshaker(URI uri, String subprotocol, HttpHeaders headers,
-                                                      boolean absoluteUpgradeUrl) {
+                                                      boolean absoluteUpgradeUrl, boolean generateOriginHeader) {
         return new WebSocketClientHandshaker00(uri, WebSocketVersion.V00, subprotocol, headers,
-          1024, 10000, absoluteUpgradeUrl);
+          1024, 10000, absoluteUpgradeUrl, generateOriginHeader);
     }
 
     @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07Test.java
Patch:
@@ -31,7 +31,7 @@ public class WebSocketClientHandshaker07Test extends WebSocketClientHandshakerTe
     public void testHostHeaderPreserved() {
         URI uri = URI.create("ws://localhost:9999");
         WebSocketClientHandshaker handshaker = newHandshaker(uri, null,
-                new DefaultHttpHeaders().set(HttpHeaderNames.HOST, "test.netty.io"), false);
+                new DefaultHttpHeaders().set(HttpHeaderNames.HOST, "test.netty.io"), false, true);
 
         FullHttpRequest request = handshaker.newHandshakeRequest();
         try {
@@ -44,10 +44,10 @@ public void testHostHeaderPreserved() {
 
     @Override
     protected WebSocketClientHandshaker newHandshaker(URI uri, String subprotocol, HttpHeaders headers,
-                                                      boolean absoluteUpgradeUrl) {
+                                                      boolean absoluteUpgradeUrl, boolean generateOriginHeader) {
         return new WebSocketClientHandshaker07(uri, WebSocketVersion.V07, subprotocol, false, headers,
           1024, true, false, 10000,
-          absoluteUpgradeUrl);
+          absoluteUpgradeUrl, generateOriginHeader);
     }
 
     @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08Test.java
Patch:
@@ -22,9 +22,9 @@
 public class WebSocketClientHandshaker08Test extends WebSocketClientHandshaker07Test {
     @Override
     protected WebSocketClientHandshaker newHandshaker(URI uri, String subprotocol, HttpHeaders headers,
-                                                      boolean absoluteUpgradeUrl) {
+                                                      boolean absoluteUpgradeUrl, boolean generateOriginHeader) {
         return new WebSocketClientHandshaker08(uri, WebSocketVersion.V08, subprotocol, false, headers,
           1024, true, true, 10000,
-          absoluteUpgradeUrl);
+          absoluteUpgradeUrl, generateOriginHeader);
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13Test.java
Patch:
@@ -24,10 +24,10 @@ public class WebSocketClientHandshaker13Test extends WebSocketClientHandshaker07
 
     @Override
     protected WebSocketClientHandshaker newHandshaker(URI uri, String subprotocol, HttpHeaders headers,
-                                                      boolean absoluteUpgradeUrl) {
+                                                      boolean absoluteUpgradeUrl, boolean generateOriginHeader) {
         return new WebSocketClientHandshaker13(uri, WebSocketVersion.V13, subprotocol, false, headers,
           1024, true, true, 10000,
-          absoluteUpgradeUrl);
+          absoluteUpgradeUrl, generateOriginHeader);
     }
 
     @Override

File: common/src/main/java/io/netty/util/internal/Hidden.java
Patch:
@@ -170,7 +170,9 @@ public Predicate<Thread> apply(final Predicate<Thread> p) {
                         @Override
                         @SuppressJava6Requirement(reason = "Predicate#test")
                         public boolean test(Thread thread) {
-                            return p.test(thread) || thread instanceof FastThreadLocalThread;
+                            return p.test(thread) ||
+                                    thread instanceof FastThreadLocalThread &&
+                                            !((FastThreadLocalThread) thread).permitBlockingCalls();
                         }
                     };
                 }

File: common/src/main/java/io/netty/util/internal/ThreadExecutorMap.java
Patch:
@@ -84,7 +84,7 @@ public void run() {
      * when called from within the {@link Runnable} during execution.
      */
     public static ThreadFactory apply(final ThreadFactory threadFactory, final EventExecutor eventExecutor) {
-        ObjectUtil.checkNotNull(threadFactory, "command");
+        ObjectUtil.checkNotNull(threadFactory, "threadFactory");
         ObjectUtil.checkNotNull(eventExecutor, "eventExecutor");
         return new ThreadFactory() {
             @Override

File: codec-dns/src/test/java/io/netty/handler/codec/dns/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-dns-handlers/reflect-config.json",
-                "io.netty.handler.codec.dns");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.dns");
     }
 
 }

File: codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "haproxy-handlers/reflect-config.json",
-                "io.netty.handler.codec.haproxy");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.haproxy");
     }
 
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/NativeImageHandlerMetadataTest.java
Patch:
@@ -23,7 +23,6 @@ public class NativeImageHandlerMetadataTest {
     @Test
     public void collectAndCompareMetadata() {
         ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-http-handlers/reflect-config.json",
                 "io.netty.handler.codec.http",
                 "io.netty.handler.codec.rtsp",
                 "io.netty.handler.codec.spdy");

File: codec-http2/src/test/java/io/netty/handler/codec/http2/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-http2-handlers/reflect-config.json",
-                "io.netty.handler.codec.http2");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.http2");
     }
 
 }

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "memcache-handlers/reflect-config.json",
-                "io.netty.handler.codec.memcache");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.memcache");
     }
 
 }

File: codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-mqtt-handlers/reflect-config.json",
-                "io.netty.handler.codec.mqtt");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.mqtt");
     }
 
 }

File: codec-redis/src/test/java/io/netty/handler/codec/redis/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-redis-handlers/reflect-config.json",
-                "io.netty.handler.codec.redis");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.redis");
     }
 
 }

File: codec-smtp/src/test/java/io/netty/handler/codec/smtp/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-smtp-handlers/reflect-config.json",
-                "io.netty.handler.codec.smtp");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.smtp");
     }
 
 }

File: codec-socks/src/test/java/io/netty/handler/codec/socks/NativeImageHandlerMetadataTest.java
Patch:
@@ -23,8 +23,8 @@ public class NativeImageHandlerMetadataTest {
     @Test
     public void collectAndCompareMetadata() {
         ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-socks-handlers/reflect-config.json",
-                "io.netty.handler.codec.socks", "io.netty.handler.codec.socksx");
+                "io.netty.handler.codec.socks",
+                "io.netty.handler.codec.socksx");
     }
 
 }

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "stomp-handlers/reflect-config.json",
-                "io.netty.handler.codec.stomp");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.stomp");
     }
 
 }

File: codec-xml/src/test/java/io/netty/handler/codec/xml/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-xml-handlers/reflect-config.json",
-                "io.netty.handler.codec.xml");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.xml");
     }
 
 }

File: codec/src/test/java/io/netty/handler/codec/NativeImageHandlerMetadataTest.java
Patch:
@@ -23,9 +23,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "codec-handlers/reflect-config.json",
-                "io.netty.handler.codec");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec");
     }
 
 }

File: handler-proxy/src/test/java/io/netty/handler/proxy/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "handler-proxy-handlers/reflect-config.json",
-                "io.netty.handler.proxy");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.proxy");
     }
 
 }

File: handler/src/test/java/io/netty/handler/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "handler-handlers/reflect-config.json",
-                "io.netty.handler");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler");
     }
 
 }

File: resolver-dns/src/test/java/io/netty/resolver/dns/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "resolver-dns-handlers/reflect-config.json",
-                "io.netty.resolver.dns");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.resolver.dns");
     }
 
 }

File: transport-sctp/src/test/java/io/netty/handler/codec/sctp/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "transport-sctp-handlers/reflect-config.json",
-                "io.netty.handler.codec.sctp");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.handler.codec.sctp");
     }
 
 }

File: transport/src/test/java/io/netty/channel/NativeImageHandlerMetadataTest.java
Patch:
@@ -22,9 +22,7 @@ public class NativeImageHandlerMetadataTest {
 
     @Test
     public void collectAndCompareMetadata() {
-        ChannelHandlerMetadataUtil.generateMetadata(
-                "transport-handlers/reflect-config.json",
-                "io.netty.bootstrap", "io.netty.channel");
+        ChannelHandlerMetadataUtil.generateMetadata("io.netty.bootstrap", "io.netty.channel");
     }
 
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -111,7 +112,7 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
         }
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
-        ch2.writeInbound(ch.readOutbound());
+        ch2.writeInbound(ch.<ByteBuf>readOutbound());
         HttpResponse res = ch2.readInbound();
 
         assertEquals("ws://example.com/chat", res.headers().get(HttpHeaderNames.SEC_WEBSOCKET_LOCATION));

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v4/Socks4CommonTestUtils.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.socksx.v4;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.channel.embedded.EmbeddedChannel;
 
 final class Socks4CommonTestUtils {
@@ -33,7 +34,7 @@ public static void writeMessageIntoEmbedder(EmbeddedChannel embedder, Socks4Mess
             out = new EmbeddedChannel(Socks4ServerEncoder.INSTANCE);
         }
         out.writeOutbound(msg);
-        embedder.writeInbound(out.readOutbound());
+        embedder.writeInbound(out.<ByteBuf>readOutbound());
         out.finish();
     }
 }

File: common/src/main/java/io/netty/util/internal/Hidden.java
Patch:
@@ -162,6 +162,7 @@ public void applyTo(BlockHound.Builder builder) {
                     "io.netty.util.NetUtil$SoMaxConnAction",
                     "run");
 
+            builder.allowBlockingCallsInside("io.netty.util.internal.PlatformDependent", "createTempFile");
             builder.nonBlockingThreadPredicate(new Function<Predicate<Thread>, Predicate<Thread>>() {
                 @Override
                 public Predicate<Thread> apply(final Predicate<Thread> p) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackEncoderTest.java
Patch:
@@ -23,7 +23,6 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.function.Executable;
 
-import java.util.Arrays;
 import java.util.Random;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
@@ -224,7 +223,9 @@ private void verifyRoundTrip(Http2Headers encodedHeaders) throws Http2Exception
     }
 
     private void verifyEncodedBytes(int... expectedEncoding) {
-        byte[] actualEncoding = Arrays.copyOf(buf.array(), buf.writerIndex());
+        // We want to copy everything that was written to the buffer.
+        byte[] actualEncoding = new byte[buf.writerIndex()];
+        buf.getBytes(0, actualEncoding);
         Assertions.assertArrayEquals(toByteArray(expectedEncoding), actualEncoding);
     }
 

File: handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java
Patch:
@@ -141,8 +141,8 @@ public void read(ChannelHandlerContext ctx) throws Exception {
             // messages from upstream and once one arrives it need to be
             // relayed to downstream to keep the flow going.
             shouldConsume = true;
-            ctx.read();
         }
+        ctx.read();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -61,8 +61,8 @@ protected Map<Class<?>, String> initialValue() {
     private static final AtomicReferenceFieldUpdater<DefaultChannelPipeline, MessageSizeEstimator.Handle> ESTIMATOR =
             AtomicReferenceFieldUpdater.newUpdater(
                     DefaultChannelPipeline.class, MessageSizeEstimator.Handle.class, "estimatorHandle");
-    final AbstractChannelHandlerContext head;
-    final AbstractChannelHandlerContext tail;
+    final HeadContext head;
+    final TailContext tail;
 
     private final Channel channel;
     private final ChannelFuture succeededFuture;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java
Patch:
@@ -34,7 +34,7 @@
  *     response.headers().set(TRANSFER_ENCODING, CHUNKED);
  *     ctx.write(response);
  *
- *     HttpContentChunkedInput httpChunkWriter = new HttpChunkedInput(
+ *     HttpChunkedInput httpChunkWriter = new HttpChunkedInput(
  *         new ChunkedFile(&quot;/tmp/myfile.txt&quot;));
  *     ChannelFuture sendFileFuture = ctx.write(httpChunkWriter);
  * }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -779,7 +779,7 @@ private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
             // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
             if ((readyOps & SelectionKey.OP_WRITE) != 0) {
                 // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
-                ch.unsafe().forceFlush();
+               unsafe.forceFlush();
             }
 
             // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -422,13 +422,12 @@ private static HeaderType validate(int streamId, CharSequence name,
 
     @SuppressWarnings("deprecation") // We need to check for deprecated headers as well.
     private static boolean isConnectionHeader(CharSequence name) {
-        // These are the known standard and non-standard connection related headers:
+        // These are the known standard connection related headers:
         // - upgrade (7 chars)
         // - connection (10 chars)
         // - keep-alive (10 chars)
         // - proxy-connection (16 chars)
         // - transfer-encoding (17 chars)
-        // - upgrade-insecure-requests (25 chars)
         //
         // We scan for these based on the length, then double-check any matching name.
         int len = name.length();
@@ -449,7 +448,7 @@ private static boolean isConnectionHeader(CharSequence name) {
         if (len == 16) {
             return contentEqualsIgnoreCase(name, HttpHeaderNames.PROXY_CONNECTION);
         }
-        return len == 25 && contentEqualsIgnoreCase(name, HttpHeaderNames.UPGRADE_INSECURE_REQUESTS);
+        return false;
     }
 
     private static boolean contains(Http2Headers headers, CharSequence name) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
Patch:
@@ -167,9 +167,6 @@ public void decodingConnectionRelatedHeadersMustFailValidation() throws Exceptio
 
         // Non-standard connection related headers:
         verifyValidationFails(decoder, encode(b(":method"), b("GET"), b("proxy-connection"), b("keep-alive")));
-        verifyValidationFails(decoder, encode(b(":method"), b("GET"), b("upgrade-insecure-requests"), b("1")));
-        verifyValidationFails(decoder, encode(b(":method"), b("GET"),
-                b("content-security-policy"), b("upgrade-insecure-requests"), b("upgrade-insecure-requests"), b("1")));
 
         // Only "trailers" is allowed for the TE header:
         verifyValidationFails(decoder, encode(b(":method"), b("GET"), b("te"), b("compress")));

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -157,7 +157,7 @@ private void tcacheAllocateSmall(PoolThreadCache cache, PooledByteBuf<T> buf, fi
          * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and
          * {@link PoolChunk#free(long)} may modify the doubly linked list as well.
          */
-        final PoolSubpage<T> head = smallSubpagePools[sizeIdx];
+        final PoolSubpage<T> head = findSubpagePoolHead(sizeIdx);
         final boolean needsNormalAllocation;
         head.lock();
         try {

File: buffer/src/main/java/io/netty/buffer/PoolChunk.java
Patch:
@@ -479,12 +479,12 @@ void free(long handle, int normCapacity, ByteBuffer nioBuffer) {
 
             int sIdx = runOffset(handle);
             PoolSubpage<T> subpage = subpages[sIdx];
-            assert subpage != null && subpage.doNotDestroy;
 
             // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.
             // This is need as we may add it back and so alter the linked-list structure.
             head.lock();
             try {
+                assert subpage != null && subpage.doNotDestroy;
                 if (subpage.free(head, bitmapIdx(handle))) {
                     //the subpage is still used, do not free it
                     return;

File: common/src/main/java/io/netty/util/internal/logging/FormattingTuple.java
Patch:
@@ -47,7 +47,7 @@ public final class FormattingTuple {
     private final String message;
     private final Throwable throwable;
 
-    FormattingTuple(String message, Throwable throwable) {
+    public FormattingTuple(String message, Throwable throwable) {
         this.message = message;
         this.throwable = throwable;
     }

File: common/src/main/java/io/netty/util/internal/logging/MessageFormatter.java
Patch:
@@ -129,7 +129,7 @@ public final class MessageFormatter {
      * @param arg            The argument to be substituted in place of the formatting anchor
      * @return The formatted message
      */
-    static FormattingTuple format(String messagePattern, Object arg) {
+    public static FormattingTuple format(String messagePattern, Object arg) {
         return arrayFormat(messagePattern, new Object[]{arg});
     }
 
@@ -152,7 +152,7 @@ static FormattingTuple format(String messagePattern, Object arg) {
      *                       anchor
      * @return The formatted message
      */
-    static FormattingTuple format(final String messagePattern,
+    public static FormattingTuple format(final String messagePattern,
                                   Object argA, Object argB) {
         return arrayFormat(messagePattern, new Object[]{argA, argB});
     }
@@ -167,7 +167,7 @@ static FormattingTuple format(final String messagePattern,
      *                       anchors
      * @return The formatted message
      */
-    static FormattingTuple arrayFormat(final String messagePattern,
+    public static FormattingTuple arrayFormat(final String messagePattern,
                                        final Object[] argArray) {
         if (argArray == null || argArray.length == 0) {
             return new FormattingTuple(messagePattern, null);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -174,8 +174,9 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
                 encodeHttpMessageLastContent(ctx, m, out);
             } else if (m instanceof HttpContent) {
                 encodeHttpMessageNotLastContent(ctx, m, out);
+            } else {
+                encodeJustHttpMessage(ctx, m, out);
             }
-            encodeJustHttpMessage(ctx, m, out);
         } else {
             encodeNotHttpMessageContentTypes(ctx, msg, out);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -191,7 +191,8 @@ protected void encode(
                 ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
 
             if (upgraded) {
-                out.add(ReferenceCountUtil.retain(msg));
+                // HttpObjectEncoder overrides .write and does not release msg, so we don't need to retain it here
+                out.add(msg);
                 return;
             }
 

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -569,10 +569,10 @@ private boolean connectedRead(EpollRecvByteAllocatorHandle allocHandle, ByteBuf
             int writerIndex = byteBuf.writerIndex();
             int localReadAmount;
             if (byteBuf.hasMemoryAddress()) {
-                localReadAmount = socket.readAddress(byteBuf.memoryAddress(), writerIndex, writerIndex + writable);
+                localReadAmount = socket.recvAddress(byteBuf.memoryAddress(), writerIndex, writerIndex + writable);
             } else {
                 ByteBuffer buf = byteBuf.internalNioBuffer(writerIndex, writable);
-                localReadAmount = socket.read(buf, buf.position(), buf.limit());
+                localReadAmount = socket.recv(buf, buf.position(), buf.limit());
             }
 
             if (localReadAmount <= 0) {

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainDatagramChannel.java
Patch:
@@ -177,7 +177,7 @@ private boolean doWriteMessage(Object msg) throws Exception {
         if (data.hasMemoryAddress()) {
             long memoryAddress = data.memoryAddress();
             if (remoteAddress == null) {
-                writtenBytes = socket.writeAddress(memoryAddress, data.readerIndex(), data.writerIndex());
+                writtenBytes = socket.sendAddress(memoryAddress, data.readerIndex(), data.writerIndex());
             } else {
                 writtenBytes = socket.sendToAddressDomainSocket(memoryAddress, data.readerIndex(), data.writerIndex(),
                         remoteAddress.path().getBytes(CharsetUtil.UTF_8));
@@ -197,7 +197,7 @@ private boolean doWriteMessage(Object msg) throws Exception {
         } else {
             ByteBuffer nioData = data.internalNioBuffer(data.readerIndex(), data.readableBytes());
             if (remoteAddress == null) {
-                writtenBytes = socket.write(nioData, nioData.position(), nioData.limit());
+                writtenBytes = socket.send(nioData, nioData.position(), nioData.limit());
             } else {
                 writtenBytes = socket.sendToDomainSocket(nioData, nioData.position(), nioData.limit(),
                         remoteAddress.path().getBytes(CharsetUtil.UTF_8));

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketShutdownOutputByPeerTest.java
Patch:
@@ -58,7 +58,7 @@ protected void write(LinuxSocket s, int data) throws IOException {
         final ByteBuffer buf = Buffer.allocateDirectWithNativeOrder(4);
         buf.putInt(data);
         buf.flip();
-        s.write(buf, buf.position(), buf.limit());
+        s.send(buf, buf.position(), buf.limit());
         Buffer.free(buf);
     }
 

File: handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java
Patch:
@@ -25,12 +25,12 @@
 import io.netty.util.CharsetUtil;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
-import org.junit.AssumptionViolatedException;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
+import org.opentest4j.TestAbortedException;
 
 import javax.crypto.Cipher;
 import javax.crypto.spec.IvParameterSpec;
@@ -1030,7 +1030,7 @@ private void testWrapWithDifferentSizes(SSLEngineTestParam param, String protoco
             } catch (SSLException e) {
                 if (e.getMessage().contains("unsupported protocol") ||
                         e.getMessage().contains("no protocols available")) {
-                    throw new AssumptionViolatedException(protocol + " not supported with cipher " + cipher, e);
+                    throw new TestAbortedException(protocol + " not supported with cipher " + cipher, e);
                 }
                 throw e;
             }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -229,9 +229,11 @@ protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throw
             assumeThat(e.getMessage()).doesNotContainIgnoringCase("unsupported address type");
             throw e;
         }
+        SocketAddress sendAddress = address instanceof InetSocketAddress ?
+                sendToAddress((InetSocketAddress) address) : address;
         for (int i = 0; i < 100; i++) {
             try {
-                client.send(new java.net.DatagramPacket(EmptyArrays.EMPTY_BYTES, 0, address));
+                client.send(new java.net.DatagramPacket(EmptyArrays.EMPTY_BYTES, 0, sendAddress));
             } catch (BindException e) {
                 throw new TestAbortedException("JDK sockets do not support binding to these addresses.", e);
             }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
Patch:
@@ -321,7 +321,7 @@ static void validateHeaderValue(CharSequence value) {
             char c = value.charAt(i);
             if (c == 0) {
                 throw new IllegalArgumentException(
-                        "value contains null character: " + value);
+                        "value contains null character");
             }
         }
     }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
Patch:
@@ -54,7 +54,7 @@ public interface DnsCache {
      * @param hostname the hostname
      * @param additionals the additional records
      * @param address the resolved address
-     * @param originalTtl the TLL as returned by the DNS server
+     * @param originalTtl the TTL as returned by the DNS server
      * @param loop the {@link EventLoop} used to register the TTL timeout
      * @return The {@link DnsCacheEntry} corresponding to this cache entry.
      */

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java
Patch:
@@ -32,13 +32,12 @@
 import java.util.Map;
 
 public final class EpollDatagramChannelConfig extends EpollChannelConfig implements DatagramChannelConfig {
-    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = new FixedRecvByteBufAllocator(2048);
     private boolean activeOnOpen;
     private volatile int maxDatagramSize;
 
     EpollDatagramChannelConfig(EpollDatagramChannel channel) {
         super(channel);
-        setRecvByteBufAllocator(DEFAULT_RCVBUF_ALLOCATOR);
+        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDomainDatagramChannelConfig.java
Patch:
@@ -34,13 +34,11 @@
 @UnstableApi
 public final class EpollDomainDatagramChannelConfig extends EpollChannelConfig implements DomainDatagramChannelConfig {
 
-    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = new FixedRecvByteBufAllocator(2048);
-
     private boolean activeOnOpen;
 
     EpollDomainDatagramChannelConfig(EpollDomainDatagramChannel channel) {
         super(channel);
-        setRecvByteBufAllocator(DEFAULT_RCVBUF_ALLOCATOR);
+        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannelConfig.java
Patch:
@@ -44,12 +44,11 @@
 
 @UnstableApi
 public final class KQueueDatagramChannelConfig extends KQueueChannelConfig implements DatagramChannelConfig {
-    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = new FixedRecvByteBufAllocator(2048);
     private boolean activeOnOpen;
 
     KQueueDatagramChannelConfig(KQueueDatagramChannel channel) {
         super(channel);
-        setRecvByteBufAllocator(DEFAULT_RCVBUF_ALLOCATOR);
+        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDomainDatagramChannelConfig.java
Patch:
@@ -35,13 +35,11 @@
 public final class KQueueDomainDatagramChannelConfig
         extends KQueueChannelConfig implements DomainDatagramChannelConfig {
 
-    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = new FixedRecvByteBufAllocator(2048);
-
     private boolean activeOnOpen;
 
     KQueueDomainDatagramChannelConfig(KQueueDomainDatagramChannel channel) {
         super(channel);
-        setRecvByteBufAllocator(DEFAULT_RCVBUF_ALLOCATOR);
+        setRecvByteBufAllocator(new FixedRecvByteBufAllocator(2048));
     }
 
     @Override

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollServerChannelConfig.java
Patch:
@@ -153,8 +153,8 @@ public int getTcpFastopen() {
      * @see <a href="https://tools.ietf.org/html/rfc7413#appendix-A.2">RFC 7413 Passive Open</a>
      */
     public EpollServerChannelConfig setTcpFastopen(int pendingFastOpenRequestsThreshold) {
-        checkPositiveOrZero(this.pendingFastOpenRequestsThreshold, "pendingFastOpenRequestsThreshold");
-        this.pendingFastOpenRequestsThreshold = pendingFastOpenRequestsThreshold;
+        this.pendingFastOpenRequestsThreshold = checkPositiveOrZero(pendingFastOpenRequestsThreshold,
+                "pendingFastOpenRequestsThreshold");
         return this;
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
Patch:
@@ -49,6 +49,8 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.parseLine;
 import static io.netty.handler.codec.http.HttpScheme.HTTP;
 import static io.netty.handler.codec.http.HttpScheme.HTTPS;
+import static io.netty.handler.codec.http.HttpUtil.isAsteriskForm;
+import static io.netty.handler.codec.http.HttpUtil.isOriginForm;
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 import static io.netty.handler.codec.http2.Http2Exception.streamError;
@@ -434,8 +436,7 @@ public static Http2Headers toHttp2Headers(HttpMessage in, boolean validateHeader
         if (in instanceof HttpRequest) {
             HttpRequest request = (HttpRequest) in;
             String host = inHeaders.getAsString(HttpHeaderNames.HOST);
-            if (request.uri().startsWith("/") || "*".equals(request.uri())) {
-                // Origin or asterisk form
+            if (isOriginForm(request.uri()) || isAsteriskForm(request.uri())) {
                 out.path(new AsciiString(request.uri()));
                 setHttp2Scheme(inHeaders, out);
             } else {

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueChannelConfig.java
Patch:
@@ -67,7 +67,7 @@ public <T> T getOption(ChannelOption<T> option) {
             }
             if (option instanceof RawUnixChannelOption) {
                 RawUnixChannelOption opt = (RawUnixChannelOption) option;
-                ByteBuffer out = ByteBuffer.allocate(opt.level());
+                ByteBuffer out = ByteBuffer.allocate(opt.length());
                 ((AbstractKQueueChannel) channel).socket.getRawOpt(opt.level(), opt.optname(), out);
                 return (T) out.flip();
             }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -351,7 +351,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
             if (serverException.get() != null) {
                 break;
             }
-            if (serverException.get() != null) {
+            if (clientException.get() != null) {
                 break;
             }
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -674,7 +674,7 @@ public Future<Channel> sslCloseFuture() {
     @Override
     public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
         try {
-            if (!pendingUnencryptedWrites.isEmpty()) {
+            if (pendingUnencryptedWrites != null && !pendingUnencryptedWrites.isEmpty()) {
                 // Check if queue is not empty first because create a new ChannelException is expensive
                 pendingUnencryptedWrites.releaseAndFailAll(ctx,
                   new ChannelException("Pending write on removal of SslHandler"));
@@ -1975,10 +1975,10 @@ private void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exc
     @Override
     public void handlerAdded(final ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
-
         Channel channel = ctx.channel();
-        setOpensslEngineSocketFd(channel);
         pendingUnencryptedWrites = new SslHandlerCoalescingBufferQueue(channel, 16);
+
+        setOpensslEngineSocketFd(channel);
         boolean fastOpen = Boolean.TRUE.equals(channel.config().getOption(ChannelOption.TCP_FASTOPEN_CONNECT));
         boolean active = channel.isActive();
         if (active || fastOpen) {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastIPv6Test.java
Patch:
@@ -18,8 +18,8 @@
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SuppressJava6Requirement;
-import org.junit.AssumptionViolatedException;
 import org.junit.jupiter.api.BeforeAll;
+import org.opentest4j.TestAbortedException;
 
 import java.io.IOException;
 import java.net.StandardProtocolFamily;
@@ -38,7 +38,7 @@ public static void assumeIpv6Supported() {
             Channel channel = SelectorProvider.provider().openDatagramChannel(StandardProtocolFamily.INET6);
             channel.close();
         } catch (UnsupportedOperationException e) {
-           throw new AssumptionViolatedException("IPv6 not supported", e);
+           throw new TestAbortedException("IPv6 not supported", e);
         } catch (IOException ignore) {
             // Ignore
         }

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/SocketTest.java
Patch:
@@ -17,10 +17,10 @@
 
 import io.netty.channel.unix.Buffer;
 import io.netty.channel.unix.Socket;
-import org.junit.AssumptionViolatedException;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.opentest4j.TestAbortedException;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -127,10 +127,10 @@ public void testRawOpt() throws IOException {
     }
 
     protected int level() {
-        throw new AssumptionViolatedException("Not supported");
+        throw new TestAbortedException("Not supported");
     }
 
     protected int optname() {
-        throw new AssumptionViolatedException("Not supported");
+        throw new TestAbortedException("Not supported");
     }
 }

File: codec/src/test/java/io/netty/handler/codec/compression/AbstractIntegrationTest.java
Patch:
@@ -154,7 +154,7 @@ public void testSequential() throws Exception {
     protected void testIdentity(final byte[] data, boolean heapBuffer) {
         initChannels();
         final ByteBuf in = heapBuffer? Unpooled.wrappedBuffer(data) :
-                Unpooled.directBuffer(data.length).setBytes(0, data);
+                Unpooled.directBuffer(data.length).writeBytes(data);
         final CompositeByteBuf compressed = Unpooled.compositeBuffer();
         final CompositeByteBuf decompressed = Unpooled.compositeBuffer();
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
Patch:
@@ -454,7 +454,7 @@ public void run() throws Http2Exception {
 
     @Test
     public void priorityUsingHigherValuedStreamIdDoesNotPreventUsingLowerStreamId() throws Exception {
-        bootstrapEnv(1, 1, 2, 0);
+        bootstrapEnv(1, 1, 3, 0);
 
         final Http2Headers headers = dummyHeaders();
         runInChannel(clientChannel, new Http2Runnable() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -164,8 +164,8 @@ public class Http2FrameCodec extends Http2ConnectionHandler {
             new IntObjectHashMap<DefaultHttp2FrameStream>(8);
 
     Http2FrameCodec(Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder, Http2Settings initialSettings,
-                    boolean decoupleCloseAndGoAway) {
-        super(decoder, encoder, initialSettings, decoupleCloseAndGoAway);
+                    boolean decoupleCloseAndGoAway, boolean flushPreface) {
+        super(decoder, encoder, initialSettings, decoupleCloseAndGoAway, flushPreface);
 
         decoder.frameListener(new FrameListener());
         connection().addListener(new ConnectionListener());

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -102,8 +102,8 @@ public class Http2MultiplexCodec extends Http2FrameCodec {
                         Http2ConnectionDecoder decoder,
                         Http2Settings initialSettings,
                         ChannelHandler inboundStreamHandler,
-                        ChannelHandler upgradeStreamHandler, boolean decoupleCloseAndGoAway) {
-        super(encoder, decoder, initialSettings, decoupleCloseAndGoAway);
+                        ChannelHandler upgradeStreamHandler, boolean decoupleCloseAndGoAway, boolean flushPreface) {
+        super(encoder, decoder, initialSettings, decoupleCloseAndGoAway, flushPreface);
         this.inboundStreamHandler = inboundStreamHandler;
         this.upgradeStreamHandler = upgradeStreamHandler;
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java
Patch:
@@ -220,7 +220,7 @@ public void flowControlShouldBeResilientToMissingStreams() throws Http2Exception
         Http2Connection conn = new DefaultHttp2Connection(true);
         Http2ConnectionEncoder enc = new DefaultHttp2ConnectionEncoder(conn, new DefaultHttp2FrameWriter());
         Http2ConnectionDecoder dec = new DefaultHttp2ConnectionDecoder(conn, enc, new DefaultHttp2FrameReader());
-        Http2FrameCodec codec = new Http2FrameCodec(enc, dec, new Http2Settings(), false);
+        Http2FrameCodec codec = new Http2FrameCodec(enc, dec, new Http2Settings(), false, true);
         EmbeddedChannel em = new EmbeddedChannel(codec);
 
         // We call #consumeBytes on a stream id which has not been seen yet to emulate the case

File: common/src/main/java/io/netty/util/internal/Hidden.java
Patch:
@@ -135,7 +135,7 @@ public void applyTo(BlockHound.Builder builder) {
                     "parse");
 
             builder.allowBlockingCallsInside(
-                    "io.netty.util.NetUil$SoMaxConnAction",
+                    "io.netty.util.NetUtil$SoMaxConnAction",
                     "run");
 
             builder.nonBlockingThreadPredicate(new Function<Predicate<Thread>, Predicate<Thread>>() {

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -85,7 +85,7 @@ public void run() {
             validateAndCalculateChunkSize(DEFAULT_PAGE_SIZE, defaultMaxOrder);
         } catch (Throwable t) {
             maxOrderFallbackCause = t;
-            defaultMaxOrder = 11;
+            defaultMaxOrder = 9;
         }
         DEFAULT_MAX_ORDER = defaultMaxOrder;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -82,7 +82,7 @@ private File tempFile() throws IOException {
         String newpostfix;
         String diskFilename = getDiskFilename();
         if (diskFilename != null) {
-            newpostfix = '_' + diskFilename;
+            newpostfix = '_' + Integer.toString(diskFilename.hashCode());
         } else {
             newpostfix = getPostfix();
         }

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -300,7 +300,7 @@ public HashedWheelTimer(
         }
 
         if (duration < MILLISECOND_NANOS) {
-            logger.warn("Configured tickDuration {} smaller then {}, using 1ms.",
+            logger.warn("Configured tickDuration {} smaller than {}, using 1ms.",
                         tickDuration, MILLISECOND_NANOS);
             this.tickDuration = MILLISECOND_NANOS;
         } else {

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostMultiPartRequestDecoderTest.java
Patch:
@@ -361,7 +361,7 @@ private static void commonNotBadReleaseBuffersDuringDecoding(HttpDataFactory fac
             assertTrue(Arrays.equals(body, data.get()));
         }
         // To not be done since will load full file on memory: assertEquals(data.get().length, fileSize);
-        // Not mandatory since implicitely called during destroy of decoder
+        // Not mandatory since implicitly called during destroy of decoder
         for (InterfaceHttpData httpData: decoder.getBodyHttpDatas()) {
             httpData.release();
             factory.removeHttpDataFromClean(request, httpData);

File: common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java
Patch:
@@ -78,7 +78,7 @@ public final class InternalThreadLocalMap extends UnpaddedInternalThreadLocalMap
     private BitSet cleanerFlags;
 
     /** @deprecated These padding fields will be removed in the future. */
-    public long rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;
+    public long rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8;
 
     static {
         STRING_BUILDER_INITIAL_SIZE =

File: common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java
Patch:
@@ -63,7 +63,7 @@ protected void run() {
         for (;;) {
             Runnable task = takeTask();
             if (task != null) {
-                task.run();
+                runTask(task);
                 updateLastExecutionTime();
             }
 

File: transport/src/main/java/io/netty/channel/DefaultEventLoop.java
Patch:
@@ -51,7 +51,7 @@ protected void run() {
         for (;;) {
             Runnable task = takeTask();
             if (task != null) {
-                task.run();
+                runTask(task);
                 updateLastExecutionTime();
             }
 

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -171,7 +171,8 @@ static long epollWait(FileDescriptor epollFd, EpollEventArray events, FileDescri
                                 int timeoutSec, int timeoutNs, long millisThreshold) throws IOException {
         if (timeoutSec == 0 && timeoutNs == 0) {
             // Zero timeout => poll (aka return immediately)
-            return epollWait(epollFd, events, 0);
+            // We shift this to be consistent with what is done in epollWait0(...)
+            return ((long) epollWait(epollFd, events, 0)) << 32;
         }
         if (timeoutSec == Integer.MAX_VALUE) {
             // Max timeout => wait indefinitely: disarm timerfd first

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -89,9 +89,7 @@ public EpollDatagramChannel() {
      * on the Operation Systems default which will be chosen.
      */
     public EpollDatagramChannel(InternetProtocolFamily family) {
-        this(family == null ?
-                newSocketDgram(Socket.isIPv6Preferred()) : newSocketDgram(family == InternetProtocolFamily.IPv6),
-                false);
+        this(newSocketDgram(family), false);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -523,9 +523,10 @@ private void readSettingsFrame(ChannelHandlerContext ctx, ByteBuf payload,
                     settings.put(id, Long.valueOf(value));
                 } catch (IllegalArgumentException e) {
                     if (id == SETTINGS_INITIAL_WINDOW_SIZE) {
-                        throw connectionError(FLOW_CONTROL_ERROR, e, e.getMessage());
+                        throw connectionError(FLOW_CONTROL_ERROR, e,
+                                "Failed setting initial window size: %s", e.getMessage());
                     }
-                    throw connectionError(PROTOCOL_ERROR, e, e.getMessage());
+                    throw connectionError(PROTOCOL_ERROR, e, "Protocol error: %s", e.getMessage());
                 }
             }
             listener.onSettingsRead(ctx, settings);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -133,7 +133,7 @@ public Http2Headers decodeHeaders(int streamId, ByteBuf headerBlock) throws Http
             // Default handler for any other types of errors that may have occurred. For example,
             // the Header builder throws IllegalArgumentException if the key or value was invalid
             // for any reason (e.g. the key was an invalid pseudo-header).
-            throw connectionError(COMPRESSION_ERROR, e, e.getMessage());
+            throw connectionError(COMPRESSION_ERROR, e, "Error decoding headers: %s", e.getMessage());
         }
     }
 

File: common/src/main/java/io/netty/util/concurrent/ScheduledFuture.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.util.concurrent;
 
 /**
- * The result of an scheduled asynchronous operation.
+ * The result of a scheduled asynchronous operation.
  */
 @SuppressWarnings("ClassNameSameAsAncestorName")
 public interface ScheduledFuture<V> extends Future<V>, java.util.concurrent.ScheduledFuture<V> {

File: handler/src/main/java/io/netty/handler/timeout/TimeoutException.java
Patch:
@@ -28,8 +28,8 @@ public class TimeoutException extends ChannelException {
     TimeoutException() {
     }
 
-    TimeoutException(boolean shared) {
-        super(null, null, shared);
+    TimeoutException(String message, boolean shared) {
+        super(message, null, shared);
     }
 
     // Suppress a warning since the method doesn't need synchronization

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -160,14 +160,14 @@ public static void sendUnsupportedWebSocketVersionResponse(Channel channel) {
     }
 
     /**
-     * Return that we need cannot not support the web socket version
+     * Return that we need cannot support the web socket version
      */
     public static ChannelFuture sendUnsupportedVersionResponse(Channel channel) {
         return sendUnsupportedVersionResponse(channel, channel.newPromise());
     }
 
     /**
-     * Return that we need cannot not support the web socket version
+     * Return that we need cannot support the web socket version
      */
     public static ChannelFuture sendUnsupportedVersionResponse(Channel channel, ChannelPromise promise) {
         HttpResponse res = new DefaultFullHttpResponse(

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
Patch:
@@ -248,7 +248,7 @@ public ChannelFuture writeHeaders(final ChannelHandlerContext ctx, final int str
      * @param contentEncoding the value of the {@code content-encoding} header
      * @return a new {@link ByteToMessageDecoder} if the specified encoding is supported. {@code null} otherwise
      * (alternatively, you can throw a {@link Http2Exception} to block unknown encoding).
-     * @throws Http2Exception If the specified encoding is not not supported and warrants an exception
+     * @throws Http2Exception If the specified encoding is not supported and warrants an exception
      */
     protected EmbeddedChannel newContentCompressor(ChannelHandlerContext ctx, CharSequence contentEncoding)
             throws Http2Exception {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java
Patch:
@@ -74,7 +74,7 @@ public static ReadOnlyHttp2Headers trailers(boolean validateHeaders, AsciiString
      * @param path The value for {@link PseudoHeaderName#PATH}.
      * @param scheme The value for {@link PseudoHeaderName#SCHEME}.
      * @param authority The value for {@link PseudoHeaderName#AUTHORITY}.
-     * @param otherHeaders A an array of key:value pairs. Must not contain any
+     * @param otherHeaders An array of key:value pairs. Must not contain any
      *                     <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.1">pseudo headers</a>
      *                     or {@code null} names/values.
      *                     A copy will <strong>NOT</strong> be made of this array. If the contents of this array

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -510,7 +510,7 @@ protected long delayNanos(long currentTimeNanos) {
     }
 
     /**
-     * Returns the absolute point in time (relative to {@link #nanoTime()}) at which the the next
+     * Returns the absolute point in time (relative to {@link #nanoTime()}) at which the next
      * closest scheduled task should run.
      */
     @UnstableApi

File: handler/src/main/java/io/netty/handler/ssl/Java7SslParametersUtils.java
Patch:
@@ -27,7 +27,7 @@ private Java7SslParametersUtils() {
     }
 
     /**
-     * Utility method that is used by {@link OpenSslEngine} and so allow use not not have any reference to
+     * Utility method that is used by {@link OpenSslEngine} and so allow use not have any reference to
      * {@link AlgorithmConstraints} in the code. This helps us to not get into trouble when using it in java
      * version < 7 and especially when using on android.
      */

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -489,7 +489,7 @@ static boolean isValidHostNameForSNI(String hostname) {
     }
 
     /**
-     * Returns {@code true} if the the given cipher (in openssl format) is for TLSv1.3, {@code false} otherwise.
+     * Returns {@code true} if the given cipher (in openssl format) is for TLSv1.3, {@code false} otherwise.
      */
     static boolean isTLSv13Cipher(String cipher) {
         // See https://tools.ietf.org/html/rfc8446#appendix-B.4

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -228,7 +228,7 @@ public void handlerAdded(ChannelHandlerContext ctx) {
         if (serverConfig.decoderConfig().withUTF8Validator() && cp.get(Utf8FrameValidator.class) == null) {
             // Add the UFT8 checking before this one.
             cp.addBefore(ctx.name(), Utf8FrameValidator.class.getName(),
-                    new Utf8FrameValidator());
+                    new Utf8FrameValidator(serverConfig.decoderConfig().closeOnProtocolViolation()));
         }
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -236,7 +236,7 @@ public float windowUpdateRatio() {
      * of bytes processed since the last update has meet or exceeded this ratio then a window update will
      * be sent. This window update ratio will only be applied to {@code streamId}.
      * <p>
-     * Note it is the responsibly of the caller to ensure that the the
+     * Note it is the responsibly of the caller to ensure that the
      * initial {@code SETTINGS} frame is sent before this is called. It would
      * be considered a {@link Http2Error#PROTOCOL_ERROR} if a {@code WINDOW_UPDATE}
      * was generated by this method before the initial {@code SETTINGS} frame is sent.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
Patch:
@@ -164,7 +164,7 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers
      * @param contentEncoding the value of the {@code content-encoding} header
      * @return a new {@link ByteToMessageDecoder} if the specified encoding is supported. {@code null} otherwise
      *         (alternatively, you can throw a {@link Http2Exception} to block unknown encoding).
-     * @throws Http2Exception If the specified encoding is not not supported and warrants an exception
+     * @throws Http2Exception If the specified encoding is not supported and warrants an exception
      */
     protected EmbeddedChannel newContentDecompressor(final ChannelHandlerContext ctx, CharSequence contentEncoding)
             throws Http2Exception {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -871,7 +871,7 @@ private void checkCloseConnection(ChannelFuture future) {
     }
 
     /**
-     * Close the remote endpoint with with a {@code GO_AWAY} frame. Does <strong>not</strong> flush
+     * Close the remote endpoint with a {@code GO_AWAY} frame. Does <strong>not</strong> flush
      * immediately, this is the responsibility of the caller.
      */
     private ChannelFuture goAway(ChannelHandlerContext ctx, Http2Exception cause, ChannelPromise promise) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java
Patch:
@@ -55,7 +55,7 @@ public final class ReadOnlyHttp2Headers implements Http2Headers {
      * <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.1">RFC 7540, 8.1.2.1</a>.
      * @param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol
      *                        compliance.
-     * @param otherHeaders A an array of key:value pairs. Must not contain any
+     * @param otherHeaders An array of key:value pairs. Must not contain any
      *                     <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.1">pseudo headers</a>
      *                     or {@code null} names/values.
      *                     A copy will <strong>NOT</strong> be made of this array. If the contents of this array
@@ -98,7 +98,7 @@ public static ReadOnlyHttp2Headers clientHeaders(boolean validateHeaders,
      * @param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol
      *                        compliance.
      * @param status The value for {@link PseudoHeaderName#STATUS}.
-     * @param otherHeaders A an array of key:value pairs. Must not contain any
+     * @param otherHeaders An array of key:value pairs. Must not contain any
      *                     <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.1">pseudo headers</a>
      *                     or {@code null} names/values.
      *                     A copy will <strong>NOT</strong> be made of this array. If the contents of this array

File: common/src/main/java/io/netty/util/internal/ObjectUtil.java
Patch:
@@ -247,7 +247,7 @@ public static char[] checkNonEmpty(char[] array, String name) {
      */
     public static <T extends Collection<?>> T checkNonEmpty(T collection, String name) {
         //No String concatenation for check
-        if (checkNotNull(collection, name).size() == 0) {
+        if (checkNotNull(collection, name).isEmpty()) {
             throw new IllegalArgumentException("Param '" + name + "' must not be empty");
         }
         return collection;
@@ -290,7 +290,7 @@ public static CharSequence checkNonEmpty(final CharSequence value, final String
     }
 
     /**
-     * Trims the the given argument and checks whether it is neither null nor empty.
+     * Trims the given argument and checks whether it is neither null nor empty.
      * If it is, throws {@link NullPointerException} or {@link IllegalArgumentException}.
      * Otherwise, returns the trimmed argument.
      *

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -152,8 +152,8 @@ public void testComponentAtOffset() {
             ByteBuf _buf = buf.componentAtOffset(index++);
             assertNotNull(_buf);
             assertTrue(_buf.capacity() > 0);
-            assertNotNull(_buf.getByte(0));
-            assertNotNull(_buf.getByte(_buf.readableBytes() - 1));
+            assertTrue(_buf.getByte(0) > 0);
+            assertTrue(_buf.getByte(_buf.readableBytes() - 1) > 0);
         }
 
         buf.release();

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java
Patch:
@@ -87,7 +87,7 @@ public void testMainSuccess() {
         assertEquals("main", resExts.get(0).name());
         assertTrue(resExts.get(0).parameters().isEmpty());
         assertNotNull(ch.pipeline().get(DummyDecoder.class));
-        assertNotNull(ch.pipeline().get(DummyEncoder.class) != null);
+        assertNotNull(ch.pipeline().get(DummyEncoder.class));
 
         verify(mainHandshakerMock).newRequestData();
         verify(mainHandshakerMock).handshakeExtension(any(WebSocketExtensionData.class));

File: common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.util.concurrent;
 
 import io.netty.util.internal.InternalThreadLocalMap;
-import io.netty.util.internal.ThrowableUtil;
 import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -423,7 +423,7 @@ public static int defaultPageSize() {
     }
 
     /**
-     * Default maximum order - System Property: io.netty.allocator.maxOrder - default 11
+     * Default maximum order - System Property: io.netty.allocator.maxOrder - default 9
      */
     public static int defaultMaxOrder() {
         return DEFAULT_MAX_ORDER;

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -430,7 +430,7 @@ public static int defaultMaxOrder() {
     }
 
     /**
-     * Default thread caching behavior - System Property: io.netty.allocator.useCacheForAllThreads - default true
+     * Default thread caching behavior - System Property: io.netty.allocator.useCacheForAllThreads - default false
      */
     public static boolean defaultUseCacheForAllThreads() {
         return DEFAULT_USE_CACHE_FOR_ALL_THREADS;

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -1712,7 +1712,7 @@ private static boolean isHandshakeFinished(SSLEngineResult result) {
         return result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED;
     }
 
-    private void runDelegatedTasks(boolean delegate, SSLEngineResult result, SSLEngine engine) throws Exception {
+    private void runDelegatedTasks(boolean delegate, SSLEngineResult result, SSLEngine engine) {
         if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
             for (;;) {
                 Runnable task = engine.getDelegatedTask();
@@ -1722,7 +1722,7 @@ private void runDelegatedTasks(boolean delegate, SSLEngineResult result, SSLEngi
                 if (!delegate) {
                     task.run();
                 } else {
-                    delegatingExecutor.submit(task).get();
+                    delegatingExecutor.execute(task);
                 }
             }
         }

File: handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.ssl;
 
 import io.netty.util.internal.SuppressJava6Requirement;
+import io.netty.util.CharsetUtil;
 
 import javax.net.ssl.SNIHostName;
 import javax.net.ssl.SNIMatcher;
@@ -69,7 +70,7 @@ static List getSniHostNames(List<String> names) {
         }
         List<SNIServerName> sniServerNames = new ArrayList<SNIServerName>(names.size());
         for (String name: names) {
-            sniServerNames.add(new SNIHostName(name));
+            sniServerNames.add(new SNIHostName(name.getBytes(CharsetUtil.UTF_8)));
         }
         return sniServerNames;
     }

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -144,7 +144,7 @@ public void run() {
         }
 
         DEFAULT_USE_CACHE_FOR_ALL_THREADS = SystemPropertyUtil.getBoolean(
-                "io.netty.allocator.useCacheForAllThreads", true);
+                "io.netty.allocator.useCacheForAllThreads", false);
 
         // Use 1023 by default as we use an ArrayDeque as backing storage which will then allocate an internal array
         // of 1024 elements. Otherwise we would allocate 2048 and only use 1024 which is wasteful.

File: buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
Patch:
@@ -149,7 +149,7 @@ public void testArenaMetricsNoCache() {
 
     @Test
     public void testArenaMetricsCache() {
-        testArenaMetrics0(new PooledByteBufAllocator(true, 2, 2, 8192, 9, 1000, 1000, 1000), 100, 1, 1, 0);
+        testArenaMetrics0(new PooledByteBufAllocator(true, 2, 2, 8192, 9, 1000, 1000, 1000, true, 0), 100, 1, 1, 0);
     }
 
     @Test

File: common/src/main/java/io/netty/util/internal/logging/FormattingTuple.java
Patch:
@@ -42,7 +42,7 @@
 /**
  * Holds the results of formatting done by {@link MessageFormatter}.
  */
-final class FormattingTuple {
+public final class FormattingTuple {
 
     private final String message;
     private final Throwable throwable;

File: common/src/main/java/io/netty/util/internal/logging/MessageFormatter.java
Patch:
@@ -108,7 +108,7 @@
  * {@link #format(String, Object, Object)} and
  * {@link #arrayFormat(String, Object[])} methods for more details.
  */
-final class MessageFormatter {
+public final class MessageFormatter {
     private static final String DELIM_STR = "{}";
     private static final char ESCAPE_CHAR = '\\';
 

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -42,7 +42,7 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator implements
     private static final int DEFAULT_NUM_DIRECT_ARENA;
 
     private static final int DEFAULT_PAGE_SIZE;
-    private static final int DEFAULT_MAX_ORDER; // 8192 << 11 = 16 MiB per chunk
+    private static final int DEFAULT_MAX_ORDER; // 8192 << 9 = 4 MiB per chunk
     private static final int DEFAULT_SMALL_CACHE_SIZE;
     private static final int DEFAULT_NORMAL_CACHE_SIZE;
     static final int DEFAULT_MAX_CACHED_BUFFER_CAPACITY;
@@ -77,7 +77,7 @@ public void run() {
         DEFAULT_PAGE_SIZE = defaultPageSize;
         DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT = defaultAlignment;
 
-        int defaultMaxOrder = SystemPropertyUtil.getInt("io.netty.allocator.maxOrder", 11);
+        int defaultMaxOrder = SystemPropertyUtil.getInt("io.netty.allocator.maxOrder", 9);
         Throwable maxOrderFallbackCause = null;
         try {
             validateAndCalculateChunkSize(DEFAULT_PAGE_SIZE, defaultMaxOrder);

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -143,7 +143,7 @@ public void encode(final ByteBuf in, final ByteBuf out, final int length) {
      * @param in The input buffer to read 4 bytes from
      * @param index The index to read at
      * @param shift The shift value, for ensuring that the resulting value is
-     *     withing the range of our hash table size
+     *     within the range of our hash table size
      * @return A 32-bit hash of 4 bytes located at index
      */
     private static int hash(ByteBuf in, int index, int shift) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -196,8 +196,9 @@ public static long getContentLength(HttpMessage message, long defaultValue) {
      * Get an {@code int} representation of {@link #getContentLength(HttpMessage, long)}.
      *
      * @return the content length or {@code defaultValue} if this message does
-     *         not have the {@code "Content-Length"} header or its value is not
-     *         a number. Not to exceed the boundaries of integer.
+     *         not have the {@code "Content-Length"} header.
+     *
+     * @throws NumberFormatException if the {@code "Content-Length"} header does not parse as an int
      */
     public static int getContentLength(HttpMessage message, int defaultValue) {
         return (int) Math.min(Integer.MAX_VALUE, getContentLength(message, (long) defaultValue));

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -160,7 +160,8 @@ private void tcacheAllocateSmall(PoolThreadCache cache, PooledByteBuf<T> buf, fi
             final PoolSubpage<T> s = head.next;
             needsNormalAllocation = s == head;
             if (!needsNormalAllocation) {
-                assert s.doNotDestroy && s.elemSize == sizeIdx2size(sizeIdx);
+                assert s.doNotDestroy && s.elemSize == sizeIdx2size(sizeIdx) : "doNotDestroy=" +
+                        s.doNotDestroy + ", elemSize=" + s.elemSize + ", sizeIdx=" + sizeIdx;
                 long handle = s.allocate();
                 assert handle >= 0;
                 s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity, cache);

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -70,8 +70,8 @@ public final class NetUtil {
     public static final NetworkInterface LOOPBACK_IF;
 
     /**
-     * The SOMAXCONN value of the current machine.  If failed to get the value,  {@code 200}  is used as a
-     * default value for Windows or {@code 128} for others.
+     * The SOMAXCONN value of the current machine.  If failed to get the value,  {@code 200} is used as a
+     * default value for Windows and {@code 128} for others.
      */
     public static final int SOMAXCONN;
 
@@ -86,7 +86,7 @@ public final class NetUtil {
     private static final int IPV6_MAX_CHAR_COUNT = 39;
 
     /**
-     * Number of bytes needed to represent and IPV6 value
+     * Number of bytes needed to represent an IPV6 value
      */
     private static final int IPV6_BYTE_COUNT = 16;
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java
Patch:
@@ -420,6 +420,7 @@ public void testLiteralWithIncrementalIndexingCompleteEviction() throws Http2Exc
             sb.append("61"); // 'a'
         }
         decode(sb.toString());
+        verify(mockHeaders).contains(of(":authority"));
         verify(mockHeaders).add(of(":authority"), of(value));
         verifyNoMoreInteractions(mockHeaders);
         reset(mockHeaders);

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -480,6 +480,7 @@ public boolean isDirectBufferPooled() {
     }
 
     /**
+     * @deprecated will be removed
      * Returns {@code true} if the calling {@link Thread} has a {@link ThreadLocal} cache for the allocated
      * buffers.
      */
@@ -489,6 +490,7 @@ public boolean hasThreadLocalCache() {
     }
 
     /**
+     * @deprecated will be removed
      * Free all cached buffers for the calling {@link Thread}.
      */
     @Deprecated

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2Constants.java
Patch:
@@ -49,6 +49,8 @@ final class Bzip2Constants {
     static final int MIN_BLOCK_SIZE = 1;
     static final int MAX_BLOCK_SIZE = 9;
 
+    static final int THREAD_POOL_DELAY_SECONDS = 10;
+
     static final int MAX_BLOCK_LENGTH = MAX_BLOCK_SIZE * BASE_BLOCK_SIZE;
 
     /**

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -40,6 +40,8 @@ public class JZlibEncoder extends ZlibEncoder {
     private volatile boolean finished;
     private volatile ChannelHandlerContext ctx;
 
+    private static final int THREAD_POOL_DELAY_SECONDS = 10;
+
     /**
      * Creates a new zlib encoder with the default compression level ({@code 6}),
      * default window bits ({@code 15}), default memory level ({@code 8}),
@@ -336,7 +338,7 @@ public void operationComplete(ChannelFuture f) throws Exception {
                 public void run() {
                     ctx.close(promise);
                 }
-            }, 10, TimeUnit.SECONDS); // FIXME: Magic number
+            }, THREAD_POOL_DELAY_SECONDS, TimeUnit.SECONDS);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/Cookie.java
Patch:
@@ -137,7 +137,7 @@ public interface Cookie extends Comparable<Cookie> {
      * Determines if this {@link Cookie} is HTTP only.
      * If set to true, this {@link Cookie} cannot be accessed by a client
      * side script. However, this works only if the browser supports it.
-     * For for information, please look
+     * For information, please look
      * <a href="https://owasp.org/www-community/HttpOnly">here</a>.
      *
      * @param httpOnly True if the {@link Cookie} is HTTP only, otherwise false.

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
Patch:
@@ -100,7 +100,7 @@ public Set<String> origins() {
      * Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
      * from the local file system.
      *
-     * If isNullOriginAllowed is true then the server will response with the wildcard for the
+     * If isNullOriginAllowed is true then the server will response with the wildcard for
      * the CORS response header 'Access-Control-Allow-Origin'.
      *
      * @return {@code true} if a 'null' origin should be supported.

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
Patch:
@@ -46,6 +46,7 @@ public class JdkZlibEncoder extends ZlibEncoder {
     private final CRC32 crc = new CRC32();
     private static final byte[] gzipHeader = {0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0};
     private boolean writeHeader = true;
+    private static final int THREAD_POOL_DELAY_SECONDS = 10;
 
     /**
      * Creates a new zlib encoder with the default compression level ({@code 6})
@@ -278,7 +279,7 @@ public void operationComplete(ChannelFuture f) throws Exception {
                 public void run() {
                     ctx.close(promise);
                 }
-            }, 10, TimeUnit.SECONDS); // FIXME: Magic number
+            }, THREAD_POOL_DELAY_SECONDS, TimeUnit.SECONDS);
         }
     }
 

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4Constants.java
Patch:
@@ -41,6 +41,9 @@ final class Lz4Constants {
      * Offsets of header's parts.
      */
     static final int TOKEN_OFFSET = 8;
+
+    static final int THREAD_POOL_DELAY_SECONDS = 10;
+
     static final int COMPRESSED_LENGTH_OFFSET = TOKEN_OFFSET + 1;
     static final int DECOMPRESSED_LENGTH_OFFSET = COMPRESSED_LENGTH_OFFSET + 4;
     static final int CHECKSUM_OFFSET = DECOMPRESSED_LENGTH_OFFSET + 4;

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java
Patch:
@@ -49,6 +49,7 @@
 import static io.netty.handler.codec.compression.Lz4Constants.MAX_BLOCK_SIZE;
 import static io.netty.handler.codec.compression.Lz4Constants.MIN_BLOCK_SIZE;
 import static io.netty.handler.codec.compression.Lz4Constants.TOKEN_OFFSET;
+import static io.netty.handler.codec.compression.Lz4Constants.THREAD_POOL_DELAY_SECONDS;
 
 /**
  * Compresses a {@link ByteBuf} using the LZ4 format.
@@ -383,7 +384,7 @@ public void operationComplete(ChannelFuture f) throws Exception {
                 public void run() {
                     ctx.close(promise);
                 }
-            }, 10, TimeUnit.SECONDS); // FIXME: Magic number
+            }, THREAD_POOL_DELAY_SECONDS, TimeUnit.SECONDS);
         }
     }
 

File: codec/src/test/java/io/netty/handler/codec/compression/BrotliEncoderTest.java
Patch:
@@ -23,12 +23,14 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.PlatformDependent;
+import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.condition.DisabledIf;
 
 @DisabledIf(value = "isNotSupported", disabledReason = "Brotli is not supported on this platform")
 public class BrotliEncoderTest extends AbstractEncoderTest {
 
-    static {
+    @BeforeAll
+    static void setUp() {
         try {
             Brotli.ensureAvailability();
         } catch (Throwable throwable) {

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -49,7 +49,7 @@ final class PoolThreadCache {
     final PoolArena<byte[]> heapArena;
     final PoolArena<ByteBuffer> directArena;
 
-    // Hold the caches for the different size classes, which are tiny, small and normal.
+    // Hold the caches for the different size classes, which are small and normal.
     private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;
     private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;
     private final MemoryRegionCache<byte[]>[] normalHeapCaches;

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -478,7 +478,10 @@ static ByteBuf toBase64(ByteBufAllocator allocator, ByteBuf src) {
      * Validate that the given hostname can be used in SNI extension.
      */
     static boolean isValidHostNameForSNI(String hostname) {
+        // See  https://datatracker.ietf.org/doc/html/rfc6066#section-3
         return hostname != null &&
+               // SNI HostName has to be a FQDN according to TLS SNI Extension spec (see [1]),
+               // which means that is has to have at least a host name and a domain part.
                hostname.indexOf('.') > 0 &&
                !hostname.endsWith(".") && !hostname.startsWith("/") &&
                !NetUtil.isValidIpV4Address(hostname) &&

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -62,6 +62,7 @@ private void init0(PoolChunk<T> chunk, ByteBuffer nioBuffer,
         assert !PoolChunk.isSubpage(handle) || chunk.arena.size2SizeIdx(maxLength) <= chunk.arena.smallMaxSizeIdx:
                 "Allocated small sub-page handle for a buffer size that isn't \"small.\"";
 
+        chunk.incrementPinnedMemory(maxLength);
         this.chunk = chunk;
         memory = chunk.memory;
         tmpNioBuf = nioBuffer;
@@ -117,6 +118,7 @@ public final ByteBuf capacity(int newCapacity) {
         }
 
         // Reallocation required.
+        chunk.decrementPinnedMemory(maxLength);
         chunk.arena.reallocate(this, newCapacity, true);
         return this;
     }
@@ -170,6 +172,7 @@ protected final void deallocate() {
             final long handle = this.handle;
             this.handle = -1;
             memory = null;
+            chunk.decrementPinnedMemory(maxLength);
             chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);
             tmpNioBuf = null;
             chunk = null;

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -557,9 +557,9 @@ private void destroyPoolChunkLists(PoolChunkList<T>... chunkLists) {
     static final class HeapArena extends PoolArena<byte[]> {
 
         HeapArena(PooledByteBufAllocator parent, int pageSize, int pageShifts,
-                  int chunkSize, int directMemoryCacheAlignment) {
+                  int chunkSize) {
             super(parent, pageSize, pageShifts, chunkSize,
-                  directMemoryCacheAlignment);
+                  0);
         }
 
         private static byte[] newByteArray(int size) {

File: buffer/src/main/java/io/netty/buffer/PoolChunk.java
Patch:
@@ -571,7 +571,7 @@ void initBufWithSubpage(PooledByteBuf<T> buf, ByteBuffer nioBuffer, long handle,
 
         PoolSubpage<T> s = subpages[runOffset];
         assert s.doNotDestroy;
-        assert reqCapacity <= s.elemSize;
+        assert reqCapacity <= s.elemSize : reqCapacity + "<=" + s.elemSize;
 
         int offset = (runOffset << pageShifts) + bitmapIdx * s.elemSize;
         buf.init(this, nioBuffer, handle, offset, reqCapacity, s.elemSize, threadCache);

File: buffer/src/main/java/io/netty/buffer/PoolSubpage.java
Patch:
@@ -25,6 +25,7 @@
 final class PoolSubpage<T> implements PoolSubpageMetric {
 
     final PoolChunk<T> chunk;
+    final int elemSize;
     private final int pageShifts;
     private final int runOffset;
     private final int runSize;
@@ -34,7 +35,6 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
     PoolSubpage<T> next;
 
     boolean doNotDestroy;
-    int elemSize;
     private int maxNumElems;
     private int bitmapLength;
     private int nextAvail;

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -300,8 +300,7 @@ public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectA
             List<PoolArenaMetric> metrics = new ArrayList<PoolArenaMetric>(heapArenas.length);
             for (int i = 0; i < heapArenas.length; i ++) {
                 PoolArena.HeapArena arena = new PoolArena.HeapArena(this,
-                        pageSize, pageShifts, chunkSize,
-                        directMemoryCacheAlignment);
+                        pageSize, pageShifts, chunkSize);
                 heapArenas[i] = arena;
                 metrics.add(arena);
             }

File: buffer/src/test/java/io/netty/buffer/PoolArenaTest.java
Patch:
@@ -45,7 +45,7 @@ public void testNormalizeCapacity() {
     public void testNormalizeAlignedCapacity() {
         PoolArena<ByteBuffer> arena = new PoolArena.DirectArena(null, PAGE_SIZE, PAGE_SHIFTS, CHUNK_SIZE, 64);
         int[] reqCapacities = {0, 15, 510, 1024, 1023, 1025};
-        int[] expectedResult = {16, 64, 512, 1024, 1024, 1280};
+        int[] expectedResult = {64, 64, 512, 1024, 1024, 1280};
         for (int i = 0; i < reqCapacities.length; i ++) {
             assertEquals(expectedResult[i], arena.sizeIdx2size(arena.size2SizeIdx(reqCapacities[i])));
         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1761,7 +1761,7 @@ void runComplete() {
             // buffer if its empty which would then result in an IllegalReferenceCountException when we try to continue
             // decoding.
             //
-            // See https://github.com/netty/netty-tcnative/issues/68
+            // See https://github.com/netty/netty-tcnative/issues/680
             executor.execute(new Runnable() {
                 @Override
                 public void run() {

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -279,7 +279,7 @@ public static int indexOf(ByteBuf needle, ByteBuf haystack) {
                         --i;
                     }
                     if (i <= memory) {
-                        return j;
+                        return j + bStartIndex;
                     }
                     j += per;
                     memory = m - per - 1;
@@ -304,7 +304,7 @@ public static int indexOf(ByteBuf needle, ByteBuf haystack) {
                         --i;
                     }
                     if (i < 0) {
-                        return j;
+                        return j + bStartIndex;
                     }
                     j += per;
                 } else {

File: buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java
Patch:
@@ -132,13 +132,13 @@ public void testIndexOf() {
         final ByteBuf needle = Unpooled.copiedBuffer("abc12", CharsetUtil.UTF_8);
         haystack.readerIndex(1);
         needle.readerIndex(1);
-        assertEquals(0, ByteBufUtil.indexOf(needle, haystack));
+        assertEquals(1, ByteBufUtil.indexOf(needle, haystack));
         haystack.readerIndex(2);
         needle.readerIndex(3);
-        assertEquals(1, ByteBufUtil.indexOf(needle, haystack));
+        assertEquals(3, ByteBufUtil.indexOf(needle, haystack));
         haystack.readerIndex(1);
         needle.readerIndex(2);
-        assertEquals(1, ByteBufUtil.indexOf(needle, haystack));
+        assertEquals(2, ByteBufUtil.indexOf(needle, haystack));
         haystack.release();
 
         haystack = new WrappedByteBuf(Unpooled.copiedBuffer("abc123", CharsetUtil.UTF_8));

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -196,7 +196,7 @@ public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long check
      * default max time as delay allowed value of 15000 ms and no limit.
      *
      * @param executor
-     *          the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.
+     *          the {@link EventExecutor} to use for the {@link TrafficCounter}.
      */
     public GlobalTrafficShapingHandler(EventExecutor executor) {
         createGlobalTrafficCounter(executor);

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -3119,8 +3119,9 @@ protected DnsMessage filterMessage(DnsMessage message) {
 
             if (tcpFallback) {
                 // If we are configured to use TCP as a fallback also bind a TCP socket
-                serverSocket = new ServerSocket(dnsServer2.localAddress().getPort());
+                serverSocket = new ServerSocket();
                 serverSocket.setReuseAddress(true);
+                serverSocket.bind(new InetSocketAddress(dnsServer2.localAddress().getPort()));
 
                 builder.socketChannelType(NioSocketChannel.class);
             }

File: buffer/src/main/java/io/netty/buffer/search/AbstractMultiSearchProcessorFactory.java
Patch:
@@ -80,7 +80,7 @@ public abstract class AbstractMultiSearchProcessorFactory implements MultiSearch
      * prefixes of the {@code needles}.
      * <br>
      * Search (the actual application of {@link MultiSearchProcessor}) time is linear in the size of
-     * {@link io.netty.buffer.ByteBuf} on which the search is peformed ({@code O(|haystack|)}).
+     * {@link io.netty.buffer.ByteBuf} on which the search is performed ({@code O(|haystack|)}).
      * Every byte of {@link io.netty.buffer.ByteBuf} is processed only once, sequentually, regardles of
      * the number of {@code needles} being searched for.
      *

File: buffer/src/main/java/io/netty/buffer/PoolChunk.java
Patch:
@@ -310,6 +310,7 @@ boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int sizeIdx, PoolThreadC
             if (handle < 0) {
                 return false;
             }
+            assert !isSubpage(handle);
         }
 
         ByteBuffer nioBuffer = cachedNioBuffers != null? cachedNioBuffers.pollLast() : null;

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -417,17 +417,19 @@ public final void trim() {
 
         @SuppressWarnings({ "unchecked", "rawtypes" })
         private  void freeEntry(Entry entry, boolean finalizer) {
+            // Capture entry state before we recycle the entry object.
             PoolChunk chunk = entry.chunk;
             long handle = entry.handle;
             ByteBuffer nioBuffer = entry.nioBuffer;
+            int normCapacity = entry.normCapacity;
 
             if (!finalizer) {
                 // recycle now so PoolChunk can be GC'ed. This will only be done if this is not freed because of
                 // a finalizer.
                 entry.recycle();
             }
 
-            chunk.arena.freeChunk(chunk, handle, entry.normCapacity, sizeClass, nioBuffer, finalizer);
+            chunk.arena.freeChunk(chunk, handle, normCapacity, sizeClass, nioBuffer, finalizer);
         }
 
         static final class Entry<T> {

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -59,6 +59,8 @@ private void init0(PoolChunk<T> chunk, ByteBuffer nioBuffer,
                        long handle, int offset, int length, int maxLength, PoolThreadCache cache) {
         assert handle >= 0;
         assert chunk != null;
+        assert !PoolChunk.isSubpage(handle) || chunk.arena.size2SizeIdx(maxLength) <= chunk.arena.smallMaxSizeIdx:
+                "Allocated small sub-page handle for a buffer size that isn't \"small.\"";
 
         this.chunk = chunk;
         memory = chunk.memory;

File: common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java
Patch:
@@ -59,7 +59,7 @@ private static InternalLoggerFactory newDefaultFactory(String name) {
 
     private static InternalLoggerFactory useSlf4JLoggerFactory(String name) {
         try {
-            InternalLoggerFactory f = Slf4JLoggerFactory.INSTANCE_WITH_NOP_CHECK;
+            InternalLoggerFactory f = Slf4JLoggerFactory.getInstanceWithNopCheck();
             f.newInstance(name).debug("Using SLF4J as the default logging framework");
             return f;
         } catch (LinkageError ignore) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStreamEvent.java
Patch:
@@ -23,7 +23,8 @@ public final class Http2FrameStreamEvent {
     private final Http2FrameStream stream;
     private final Type type;
 
-    enum Type {
+    @UnstableApi
+    public enum Type {
         State,
         Writability
     }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socks.SocksAuthRequestDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -62,7 +63,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
         ctx.pipeline().remove(this);
     }
 
-    enum State {
+    @UnstableApi
+    public enum State {
         CHECK_PROTOCOL_VERSION,
         READ_USERNAME,
         READ_PASSWORD

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socks.SocksAuthResponseDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -55,7 +56,8 @@ protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteB
         channelHandlerContext.pipeline().remove(this);
     }
 
-    enum State {
+    @UnstableApi
+    public enum State {
         CHECK_PROTOCOL_VERSION,
         READ_AUTH_RESPONSE
     }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socks.SocksCmdRequestDecoder.State;
 import io.netty.util.NetUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -92,7 +93,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
         ctx.pipeline().remove(this);
     }
 
-    enum State {
+    @UnstableApi
+    public enum State {
         CHECK_PROTOCOL_VERSION,
         READ_CMD_HEADER,
         READ_CMD_ADDRESS

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socks.SocksCmdResponseDecoder.State;
 import io.netty.util.NetUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -92,7 +93,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
         ctx.pipeline().remove(this);
     }
 
-    enum State {
+    @UnstableApi
+    public enum State {
         CHECK_PROTOCOL_VERSION,
         READ_CMD_HEADER,
         READ_CMD_ADDRESS

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socks.SocksInitRequestDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -65,7 +66,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
         ctx.pipeline().remove(this);
     }
 
-    enum State {
+    @UnstableApi
+    public enum State {
         CHECK_PROTOCOL_VERSION,
         READ_AUTH_SCHEMES
     }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socks.SocksInitResponseDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -54,7 +55,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
         ctx.pipeline().remove(this);
     }
 
-    enum State {
+    @UnstableApi
+    public enum State {
         CHECK_PROTOCOL_VERSION,
         READ_PREFERRED_AUTH_TYPE
     }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socksx.v4.Socks4ClientDecoder.State;
 import io.netty.util.NetUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -33,7 +34,8 @@
  */
 public class Socks4ClientDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         START,
         SUCCESS,
         FAILURE

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.socksx.v4.Socks4ServerDecoder.State;
 import io.netty.util.CharsetUtil;
 import io.netty.util.NetUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -37,7 +38,8 @@ public class Socks4ServerDecoder extends ReplayingDecoder<State> {
 
     private static final int MAX_FIELD_LENGTH = 255;
 
-    enum State {
+    @UnstableApi
+    public enum State {
         START,
         READ_USERID,
         READ_DOMAIN,

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.socksx.SocksVersion;
 import io.netty.handler.codec.socksx.v5.Socks5CommandRequestDecoder.State;
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -35,7 +36,8 @@
  */
 public class Socks5CommandRequestDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         INIT,
         SUCCESS,
         FAILURE

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.socksx.SocksVersion;
 import io.netty.handler.codec.socksx.v5.Socks5CommandResponseDecoder.State;
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -35,7 +36,8 @@
  */
 public class Socks5CommandResponseDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         INIT,
         SUCCESS,
         FAILURE

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socksx.SocksVersion;
 import io.netty.handler.codec.socksx.v5.Socks5InitialRequestDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -34,7 +35,8 @@
  */
 public class Socks5InitialRequestDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         INIT,
         SUCCESS,
         FAILURE

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialResponseDecoder.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socksx.SocksVersion;
 import io.netty.handler.codec.socksx.v5.Socks5InitialResponseDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -34,7 +35,8 @@
  */
 public class Socks5InitialResponseDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         INIT,
         SUCCESS,
         FAILURE

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoder.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthRequestDecoder.State;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -34,7 +35,8 @@
  */
 public class Socks5PasswordAuthRequestDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         INIT,
         SUCCESS,
         FAILURE

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoder.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthResponseDecoder.State;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -33,7 +34,8 @@
  */
 public class Socks5PasswordAuthResponseDecoder extends ReplayingDecoder<State> {
 
-    enum State {
+    @UnstableApi
+    public enum State {
         INIT,
         SUCCESS,
         FAILURE

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.util.ByteProcessor;
 import io.netty.util.internal.AppendableCharSequence;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -55,7 +56,8 @@ public class StompSubframeDecoder extends ReplayingDecoder<State> {
     private static final int DEFAULT_CHUNK_SIZE = 8132;
     private static final int DEFAULT_MAX_LINE_LENGTH = 1024;
 
-    enum State {
+    @UnstableApi
+    public enum State {
         SKIP_CONTROL_CHARACTERS,
         READ_HEADERS,
         READ_CONTENT,

File: common/src/main/java/io/netty/util/internal/UnstableApi.java
Patch:
@@ -33,7 +33,7 @@
  *         broken in a non-major release!</li>
  * </ol>
  */
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.SOURCE) // TODO Retention policy needs to be CLASS in Netty 5.
 @Target({
         ElementType.ANNOTATION_TYPE,
         ElementType.CONSTRUCTOR,

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackHeader.java
Patch:
@@ -32,6 +32,7 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.util.AsciiString;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -40,7 +41,8 @@
 /**
  * Helper class representing a single header entry. Used by the benchmarks.
  */
-final class HpackHeader {
+@UnstableApi
+public final class HpackHeader {
     private static final String ALPHABET =
             "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
 

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollEventArray.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.channel.unix.Buffer;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
 
 import java.nio.ByteBuffer;
 
@@ -38,7 +39,8 @@
  * We use {@code fd} if the {@code epoll_data union} to store the actual file descriptor of an
  * {@link AbstractEpollChannel} and so be able to map it later.
  */
-final class EpollEventArray {
+@UnstableApi
+public final class EpollEventArray {
     // Size of the epoll_event struct
     private static final int EPOLL_EVENT_SIZE = Native.sizeofEpollEvent();
     // The offset of the data union in the epoll_event struct

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/LinuxSocket.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SocketUtils;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -36,7 +37,8 @@
 /**
  * A socket which provides access Linux native methods.
  */
-final class LinuxSocket extends Socket {
+@UnstableApi
+public final class LinuxSocket extends Socket {
     static final InetAddress INET6_ANY = unsafeInetAddrByName("::");
     private static final InetAddress INET_ANY = unsafeInetAddrByName("0.0.0.0");
     private static final long MAX_UINT32_T = 0xFFFFFFFFL;

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/NativeDatagramPacketArray.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.unix.IovArray;
 import io.netty.channel.unix.Limits;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.Inet6Address;
 import java.net.InetAddress;
@@ -158,7 +159,8 @@ private static InetSocketAddress newAddress(byte[] addr, int addrLen, int port,
      * Used to pass needed data to JNI.
      */
     @SuppressWarnings("unused")
-    final class NativeDatagramPacket {
+    @UnstableApi
+    public final class NativeDatagramPacket {
 
         // This is the actual struct iovec*
         private long memoryAddress;

File: transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java
Patch:
@@ -38,6 +38,7 @@
 import io.netty.channel.unix.UnixChannel;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.Future;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.net.ConnectException;
@@ -363,7 +364,8 @@ private void evSet0(short filter, short flags, int fflags) {
         }
     }
 
-    abstract class AbstractKQueueUnsafe extends AbstractUnsafe {
+    @UnstableApi
+    public abstract class AbstractKQueueUnsafe extends AbstractUnsafe {
         boolean readPending;
         boolean maybeMoreDataToRead;
         private KQueueRecvByteAllocatorHandle allocHandle;

File: buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
Patch:
@@ -175,9 +175,9 @@ private static void testArenaMetrics0(
 
     private static void assertArenaMetrics(
             List<PoolArenaMetric> arenaMetrics, int expectedActive, int expectedAlloc, int expectedDealloc) {
-        int active = 0;
-        int alloc = 0;
-        int dealloc = 0;
+        long active = 0;
+        long alloc = 0;
+        long dealloc = 0;
         for (PoolArenaMetric arena : arenaMetrics) {
             active += arena.numActiveAllocations();
             alloc += arena.numAllocations();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
Patch:
@@ -166,9 +166,9 @@ static int getIndexInsensitive(CharSequence name, CharSequence value) {
         while (index <= MAX_SAME_NAME_FIELD_INDEX) {
             entry = getEntry(index);
             if (!equalsVariableTime(name, entry.name)) {
-                // As far as fields with the same name are placed in the table sequentialy
+                // As far as fields with the same name are placed in the table sequentially
                 // and INDEX_BY_NAME returns index of the fist position, - it's safe to
-                // exit immediatly.
+                // exit immediately.
                 return NOT_FOUND;
             }
             if (equalsVariableTime(value, entry.value)) {
@@ -199,7 +199,7 @@ private static CharSequenceMap<Integer> createMap() {
     /**
      * Returns the last position in the array that contains multiple
      * fields with the same name. Starting from this position, all
-     * names are unique. Similary to {@link #getIndexInsensitive(CharSequence, CharSequence)} method
+     * names are unique. Similar to {@link #getIndexInsensitive(CharSequence, CharSequence)} method
      * assumes all entries for a given header field are sequential
      */
     private static int maxSameNameFieldIndex() {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java
Patch:
@@ -130,7 +130,7 @@ private void expungeInvalidSessions() {
             NativeSslSession session = iterator.next().getValue();
             // As we use a LinkedHashMap we can break the while loop as soon as we find a valid session.
             // This is true as we always drain the cache as soon as we change the timeout to a smaller value as
-            // it was set before. This way its true that the insertation order matches the timeout order.
+            // it was set before. This way its true that the insertion order matches the timeout order.
             if (session.isValid(now)) {
                 break;
             }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslRenegotiateTest.java
Patch:
@@ -39,7 +39,7 @@ protected SslProvider serverSslProvider() {
 
     protected void verifyResult(AtomicReference<Throwable> error) throws Throwable {
         Throwable cause = error.get();
-        // Renegotation is not supported by the OpenSslEngine.
+        // Renegotiation is not supported by the OpenSslEngine.
         assertThat(cause, is(instanceOf(SSLException.class)));
     }
 }

File: resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java
Patch:
@@ -134,7 +134,7 @@ final void cache(String hostname, E value, int ttl, EventLoop loop) {
     }
 
     /**
-     * Return the number of hostames for which we have cached something.
+     * Return the number of hostnames for which we have cached something.
      */
     final int size() {
         return resolveCache.size();

File: transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollEventArray.java
Patch:
@@ -41,7 +41,7 @@
 final class EpollEventArray {
     // Size of the epoll_event struct
     private static final int EPOLL_EVENT_SIZE = Native.sizeofEpollEvent();
-    // The offsiet of the data union in the epoll_event struct
+    // The offset of the data union in the epoll_event struct
     private static final int EPOLL_DATA_OFFSET = Native.offsetofEpollData();
 
     private ByteBuffer memory;

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSpliceTest.java
Patch:
@@ -82,7 +82,7 @@ public void channelActive(ChannelHandlerContext context) throws Exception {
                         // We are splicing two channels together, at this point we have a tcp proxy which handles all
                         // the data transfer only in kernel space!
 
-                        // Integer.MAX_VALUE will splice infinitly.
+                        // Integer.MAX_VALUE will splice infinitely.
                         ch.spliceTo(ch2, Integer.MAX_VALUE).addListener(new ChannelFutureListener() {
                             @Override
                             public void operationComplete(ChannelFuture future) throws Exception {

File: transport/src/test/java/io/netty/channel/pool/FixedChannelPoolMapDeadlockTest.java
Patch:
@@ -61,7 +61,7 @@ public void testDeadlockOnAcquire() throws Exception {
         final FixedChannelPool poolB2 = new FixedChannelPool(bootstrapA2, NOOP_HANDLER, 1);
 
         // Synchronize threads on these barriers to ensure order of execution, first wait until each thread is inside
-        // the newPool callbak, then hold the two threads that should lose the match until the first two returns, then
+        // the newPool callback, then hold the two threads that should lose the match until the first two returns, then
         // release them to test if they deadlock when trying to release their pools on each other's threads.
         final CyclicBarrier arrivalBarrier = new CyclicBarrier(4);
         final CyclicBarrier releaseBarrier = new CyclicBarrier(3);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
Patch:
@@ -70,7 +70,7 @@ public enum ClientHandshakeStateEvent {
         HANDSHAKE_ISSUED,
 
         /**
-         * The Handshake was complete succesful and so the channel was upgraded to websockets
+         * The Handshake was complete successful and so the channel was upgraded to websockets
          */
         HANDSHAKE_COMPLETE
     }

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -87,6 +87,7 @@ public final class Unpooled {
     /**
      * A buffer whose capacity is {@code 0}.
      */
+    @SuppressWarnings("checkstyle:StaticFinalBuffer")  // EmptyByteBuf is not writeable or readable.
     public static final ByteBuf EMPTY_BUFFER = ALLOC.buffer(0, 0);
 
     static {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java
Patch:
@@ -32,11 +32,11 @@
 @Sharable
 public class WebSocket00FrameEncoder extends MessageToMessageEncoder<WebSocketFrame> implements WebSocketFrameEncoder {
     private static final ByteBuf _0X00 = Unpooled.unreleasableBuffer(
-            Unpooled.directBuffer(1, 1).writeByte((byte) 0x00));
+            Unpooled.directBuffer(1, 1).writeByte((byte) 0x00)).asReadOnly();
     private static final ByteBuf _0XFF = Unpooled.unreleasableBuffer(
-            Unpooled.directBuffer(1, 1).writeByte((byte) 0xFF));
+            Unpooled.directBuffer(1, 1).writeByte((byte) 0xFF)).asReadOnly();
     private static final ByteBuf _0XFF_0X00 = Unpooled.unreleasableBuffer(
-            Unpooled.directBuffer(2, 2).writeByte((byte) 0xFF).writeByte((byte) 0x00));
+            Unpooled.directBuffer(2, 2).writeByte((byte) 0xFF).writeByte((byte) 0x00)).asReadOnly();
 
     @Override
     protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object> out) throws Exception {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandler.java
Patch:
@@ -39,7 +39,7 @@
  */
 @UnstableApi
 public final class CleartextHttp2ServerUpgradeHandler extends ByteToMessageDecoder {
-    private static final ByteBuf CONNECTION_PREFACE = unreleasableBuffer(connectionPrefaceBuf());
+    private static final ByteBuf CONNECTION_PREFACE = unreleasableBuffer(connectionPrefaceBuf()).asReadOnly();
 
     private final HttpServerCodec httpServerCodec;
     private final HttpServerUpgradeHandler httpServerUpgradeHandler;

File: codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java
Patch:
@@ -34,7 +34,7 @@ public final class SmtpRequestEncoder extends MessageToMessageEncoder<Object> {
     private static final int CRLF_SHORT = ('\r' << 8) | '\n';
     private static final byte SP = ' ';
     private static final ByteBuf DOT_CRLF_BUFFER = Unpooled.unreleasableBuffer(
-            Unpooled.directBuffer(3).writeByte('.').writeByte('\r').writeByte('\n'));
+            Unpooled.directBuffer(3).writeByte('.').writeByte('\r').writeByte('\n')).asReadOnly();
 
     private boolean contentExpected;
 

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java
Patch:
@@ -44,6 +44,7 @@ final class ReplayingDecoderByteBuf extends ByteBuf {
     private boolean terminated;
     private SwappedByteBuf swapped;
 
+    @SuppressWarnings("checkstyle:StaticFinalBuffer")  // Unpooled.EMPTY_BUFFER is not writeable or readable.
     static final ReplayingDecoderByteBuf EMPTY_BUFFER = new ReplayingDecoderByteBuf(Unpooled.EMPTY_BUFFER);
 
     static {

File: example/src/main/java/io/netty/example/http2/helloworld/frame/server/HelloWorldHttp2Handler.java
Patch:
@@ -42,7 +42,8 @@
 @Sharable
 public class HelloWorldHttp2Handler extends ChannelDuplexHandler {
 
-    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(copiedBuffer("Hello World", CharsetUtil.UTF_8));
+    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(
+            copiedBuffer("Hello World", CharsetUtil.UTF_8)).asReadOnly();
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java
Patch:
@@ -40,7 +40,8 @@
 @Sharable
 public class HelloWorldHttp2Handler extends ChannelDuplexHandler {
 
-    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(copiedBuffer("Hello World", CharsetUtil.UTF_8));
+    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(
+            copiedBuffer("Hello World", CharsetUtil.UTF_8)).asReadOnly();
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {

File: example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp2Handler.java
Patch:
@@ -42,7 +42,8 @@
  */
 public final class HelloWorldHttp2Handler extends Http2ConnectionHandler implements Http2FrameListener {
 
-    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(copiedBuffer("Hello World", CharsetUtil.UTF_8));
+    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(
+            copiedBuffer("Hello World", CharsetUtil.UTF_8)).asReadOnly();
 
     HelloWorldHttp2Handler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
                            Http2Settings initialSettings) {

File: testsuite-http2/src/main/java/io/netty/testsuite/http2/HelloWorldHttp2Handler.java
Patch:
@@ -42,7 +42,8 @@
  */
 public final class HelloWorldHttp2Handler extends Http2ConnectionHandler implements Http2FrameListener {
 
-    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(copiedBuffer("Hello World", CharsetUtil.UTF_8));
+    static final ByteBuf RESPONSE_BYTES = unreleasableBuffer(
+            copiedBuffer("Hello World", CharsetUtil.UTF_8)).asReadOnly();
 
     HelloWorldHttp2Handler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
                            Http2Settings initialSettings) {

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -1338,15 +1338,15 @@ public ByteBuf setDoubleLE(int index, double value) {
     public abstract ByteBuf setZero(int index, int length);
 
     /**
-     * Writes the specified {@link CharSequence} at the current {@code writerIndex} and increases
-     * the {@code writerIndex} by the written bytes.
+     * Writes the specified {@link CharSequence} at the given {@code index}.
+     * The {@code writerIndex} is not modified by this method.
      *
      * @param index on which the sequence should be written
      * @param sequence to write
      * @param charset that should be used.
      * @return the written number of bytes.
      * @throws IndexOutOfBoundsException
-     *         if {@code this.writableBytes} is not large enough to write the whole sequence
+     *         if the sequence at the given index would be out of bounds of the buffer capacity
      */
     public abstract int setCharSequence(int index, CharSequence sequence, Charset charset);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -1187,7 +1187,7 @@ private static boolean loadDataMultipartOptimized(ByteBuf undecodedChunk, String
             if (posDelimiter < 0 &&
                 httpData.definedLength() == httpData.length() + readableBytes - 1 &&
                 undecodedChunk.getByte(readableBytes + startReaderIndex - 1) == HttpConstants.CR) {
-                // Last CR shall preceed a future LF
+                // Last CR shall precede a future LF
                 lastPosition = 0;
                 posDelimiter = readableBytes - 1;
             }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerChannelConfig.java
Patch:
@@ -144,13 +144,13 @@ public int getTcpFastopen() {
     }
 
     /**
-     * Enables tcpFastOpen on the server channel. If the underlying os doesnt support TCP_FASTOPEN setting this has no
+     * Enables tcpFastOpen on the server channel. If the underlying os doesn't support TCP_FASTOPEN setting this has no
      * effect. This has to be set before doing listen on the socket otherwise this takes no effect.
      *
      * @param pendingFastOpenRequestsThreshold number of requests to be pending for fastopen at a given point in time
-     * for security. @see <a href="https://tools.ietf.org/html/rfc7413#appendix-A.2">RFC 7413 Passive Open</a>
+     * for security.
      *
-     * @see <a href="https://tools.ietf.org/html/rfc7413">RFC 7413 TCP FastOpen</a>
+     * @see <a href="https://tools.ietf.org/html/rfc7413#appendix-A.2">RFC 7413 Passive Open</a>
      */
     public EpollServerChannelConfig setTcpFastopen(int pendingFastOpenRequestsThreshold) {
         checkPositiveOrZero(this.pendingFastOpenRequestsThreshold, "pendingFastOpenRequestsThreshold");

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerSocketChannel.java
Patch:
@@ -59,9 +59,10 @@ protected boolean isCompatible(EventLoop loop) {
     @Override
     protected void doBind(SocketAddress localAddress) throws Exception {
         super.doBind(localAddress);
-
-        // TODO(scott): tcp fast open here!
         socket.listen(config.getBacklog());
+        if (config.isTcpFastOpen()) {
+            socket.setTcpFastOpen(true);
+        }
         active = true;
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerChannelConfig.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.ServerChannelRecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.ServerSocketChannelConfig;
 import io.netty.util.NetUtil;
@@ -38,7 +39,7 @@ public class EpollServerChannelConfig extends EpollChannelConfig implements Serv
     private volatile int pendingFastOpenRequestsThreshold;
 
     EpollServerChannelConfig(AbstractEpollChannel channel) {
-        super(channel);
+        super(channel, new ServerChannelRecvByteBufAllocator());
     }
 
     @Override

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueServerChannelConfig.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.ServerChannelRecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.ServerSocketChannelConfig;
 import io.netty.util.NetUtil;
@@ -38,7 +39,7 @@ public class KQueueServerChannelConfig extends KQueueChannelConfig implements Se
     private volatile int backlog = NetUtil.SOMAXCONN;
 
     KQueueServerChannelConfig(AbstractKQueueChannel channel) {
-        super(channel);
+        super(channel, new ServerChannelRecvByteBufAllocator());
     }
 
     @Override

File: transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.ServerChannelRecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.util.NetUtil;
 import io.netty.util.internal.ObjectUtil;
@@ -45,7 +46,7 @@ public class DefaultSctpServerChannelConfig extends DefaultChannelConfig impleme
      */
     public DefaultSctpServerChannelConfig(
             io.netty.channel.sctp.SctpServerChannel channel, SctpServerChannel javaChannel) {
-        super(channel);
+        super(channel, new ServerChannelRecvByteBufAllocator());
         this.javaChannel = ObjectUtil.checkNotNull(javaChannel, "javaChannel");
     }
 

File: transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.ServerChannel;
+import io.netty.channel.ServerChannelRecvByteBufAllocator;
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
 
@@ -35,7 +36,8 @@
  */
 public class LocalServerChannel extends AbstractServerChannel {
 
-    private final ChannelConfig config = new DefaultChannelConfig(this);
+    private final ChannelConfig config =
+            new DefaultChannelConfig(this, new ServerChannelRecvByteBufAllocator()) { };
     private final Queue<Object> inboundBuffer = new ArrayDeque<Object>();
     private final Runnable shutdownHook = new Runnable() {
         @Override

File: transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.ServerChannelRecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.util.NetUtil;
 import io.netty.util.internal.ObjectUtil;
@@ -47,7 +48,7 @@ public class DefaultServerSocketChannelConfig extends DefaultChannelConfig
      * Creates a new instance.
      */
     public DefaultServerSocketChannelConfig(ServerSocketChannel channel, ServerSocket javaSocket) {
-        super(channel);
+        super(channel, new ServerChannelRecvByteBufAllocator());
         this.javaSocket = ObjectUtil.checkNotNull(javaSocket, "javaSocket");
     }
 

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -246,10 +246,10 @@ public static int indexOf(ByteBuf needle, ByteBuf haystack) {
         }
 
         // When the needle has only one byte that can be read,
-        // the firstIndexOf method needs to be called
+        // the ByteBuf.indexOf() can be used
         if (m == 1) {
-            return firstIndexOf((AbstractByteBuf) haystack, haystack.readerIndex(),
-                    haystack.writerIndex(), needle.getByte(needle.readerIndex()));
+            return haystack.indexOf(haystack.readerIndex(), haystack.writerIndex(),
+                          needle.getByte(needle.readerIndex()));
         }
 
         int i;

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java
Patch:
@@ -280,7 +280,7 @@ private void flushBufferedData(ByteBuf out) {
         if (compressedLength >= flushableBytes) {
             blockType = BLOCK_TYPE_NON_COMPRESSED;
             compressedLength = flushableBytes;
-            out.setBytes(idx + HEADER_LENGTH, buffer, 0, flushableBytes);
+            out.setBytes(idx + HEADER_LENGTH, buffer, buffer.readerIndex(), flushableBytes);
         } else {
             blockType = BLOCK_TYPE_COMPRESSED;
         }

File: transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.util.concurrent.GlobalEventExecutor;
 import io.netty.util.concurrent.Promise;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
 import java.lang.reflect.Field;
@@ -33,6 +34,7 @@
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+@Disabled("Flaky test; See: https://github.com/netty/netty/issues/11551")
 public class ThreadPerChannelEventLoopGroupTest {
 
     private static final ChannelHandler NOOP_HANDLER = new ChannelHandlerAdapter() {

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java
Patch:
@@ -95,7 +95,6 @@ protected static void assertInstanceOf(ByteBuf buffer, Class<? extends ByteBuf>
         assertTrue(clazz.isInstance(buffer instanceof SimpleLeakAwareByteBuf ? buffer.unwrap() : buffer));
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void testUsedDirectMemory() {
         T allocator =  newAllocator(true);
@@ -114,7 +113,6 @@ public void testUsedDirectMemory() {
         assertEquals(expectedUsedMemoryAfterRelease(allocator, capacity), metric.usedDirectMemory());
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void testUsedHeapMemory() {
         T allocator =  newAllocator(true);
@@ -141,4 +139,7 @@ protected long expectedUsedMemory(T allocator, int capacity) {
     protected long expectedUsedMemoryAfterRelease(T allocator, int capacity) {
         return 0;
     }
+
+    protected void trimCaches(T allocator) {
+    }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2Constants.java
Patch:
@@ -49,6 +49,8 @@ final class Bzip2Constants {
     static final int MIN_BLOCK_SIZE = 1;
     static final int MAX_BLOCK_SIZE = 9;
 
+    static final int MAX_BLOCK_LENGTH = MAX_BLOCK_SIZE * BASE_BLOCK_SIZE;
+
     /**
      * Maximum possible Huffman alphabet size.
      */

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -117,6 +117,7 @@ public abstract class ReferenceCountedOpenSslContext extends SslContext implemen
     // https://mail.openjdk.java.net/pipermail/security-dev/2021-March/024758.html
     static final boolean CLIENT_ENABLE_SESSION_CACHE =
             SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.sessionCacheClient", false);
+
     /**
      * The OpenSSL SSL_CTX object.
      *
@@ -384,6 +385,8 @@ public ApplicationProtocolConfig.SelectedListenerFailureBehavior selectedListene
             if (asyncPrivateKeyMethod != null) {
                 SSLContext.setPrivateKeyMethod(ctx, new AsyncPrivateKeyMethod(engineMap, asyncPrivateKeyMethod));
             }
+            // Set the curves.
+            SSLContext.setCurvesList(ctx, OpenSsl.NAMED_GROUPS);
             success = true;
         } finally {
             if (!success) {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
Patch:
@@ -43,12 +43,13 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
 
     /**
      * Check if the new size is not reaching the max limit allowed.
-     * The limit is always computed in term of bytes.
+     * The limit is always computed in terms of bytes.
      */
     void checkSize(long newSize) throws IOException;
 
     /**
      * Set the content from the ChannelBuffer (erase any previous data)
+     * <p>{@link ByteBuf#release()} ownership of {@code buffer} is transferred to this {@link HttpData}.
      *
      * @param buffer
      *            must be not null
@@ -58,6 +59,7 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
 
     /**
      * Add the content from the ChannelBuffer
+     * <p>{@link ByteBuf#release()} ownership of {@code buffer} is transferred to this {@link HttpData}.
      *
      * @param buffer
      *            must be not null except if last is set to False

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java
Patch:
@@ -82,7 +82,7 @@ public static MqttMessage newMessage(MqttFixedHeader mqttFixedHeader, Object var
             case AUTH:
                 //Having MqttReasonCodeAndPropertiesVariableHeader
                 return new MqttMessage(mqttFixedHeader,
-                        (MqttReasonCodeAndPropertiesVariableHeader) variableHeader);
+                        variableHeader);
 
             default:
                 throw new IllegalArgumentException("unknown message type: " + mqttFixedHeader.messageType());

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -48,7 +48,6 @@
 import java.security.cert.CertificateRevokedException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
Patch:
@@ -391,7 +391,7 @@ protected void run() {
                     events.increase();
                 }
             } catch (Error e) {
-                throw (Error) e;
+                throw e;
             } catch (Throwable t) {
                 handleLoopException(t);
             } finally {
@@ -404,7 +404,7 @@ protected void run() {
                         }
                     }
                 } catch (Error e) {
-                    throw (Error) e;
+                    throw e;
                 } catch (Throwable t) {
                     handleLoopException(t);
                 }

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketConnectTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.ChannelOption;
 import io.netty.testsuite.transport.TestsuitePermutation;
 import io.netty.testsuite.transport.socket.SocketConnectTest;
 

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java
Patch:
@@ -298,7 +298,7 @@ protected void run() {
                     eventList.realloc(false);
                 }
             } catch (Error e) {
-                throw (Error) e;
+                throw e;
             } catch (Throwable t) {
                 handleLoopException(t);
             } finally {
@@ -311,7 +311,7 @@ protected void run() {
                         }
                     }
                 } catch (Error e) {
-                    throw (Error) e;
+                    throw e;
                 } catch (Throwable t) {
                     handleLoopException(t);
                 }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -516,7 +516,7 @@ protected void run() {
                             selector, e);
                 }
             } catch (Error e) {
-                throw (Error) e;
+                throw e;
             } catch (Throwable t) {
                 handleLoopException(t);
             } finally {
@@ -529,7 +529,7 @@ protected void run() {
                         }
                     }
                 } catch (Error e) {
-                    throw (Error) e;
+                    throw e;
                 } catch (Throwable t) {
                     handleLoopException(t);
                 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java
Patch:
@@ -23,8 +23,8 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.PromiseNotifier;
-import io.netty.util.concurrent.ScheduledFuture;
 
 import java.net.SocketAddress;
 import java.nio.channels.ClosedChannelException;
@@ -128,7 +128,7 @@ private void applyCloseSentTimeout(ChannelHandlerContext ctx) {
             return;
         }
 
-        final ScheduledFuture<?> timeoutTask = ctx.executor().schedule(new Runnable() {
+        final Future<?> timeoutTask = ctx.executor().schedule(new Runnable() {
             @Override
             public void run() {
                 if (!closeSent.isDone()) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -27,7 +27,7 @@
 import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
 import io.netty.handler.codec.http2.Http2Exception.StreamException;
 import io.netty.util.CharsetUtil;
-import io.netty.util.concurrent.ScheduledFuture;
+import io.netty.util.concurrent.Future;
 import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -943,7 +943,7 @@ private static void processGoAwayWriteResult(final ChannelHandlerContext ctx, fi
     private static final class ClosingChannelFutureListener implements ChannelFutureListener {
         private final ChannelHandlerContext ctx;
         private final ChannelPromise promise;
-        private final ScheduledFuture<?> timeoutTask;
+        private final Future<?> timeoutTask;
         private boolean closed;
 
         ClosingChannelFutureListener(ChannelHandlerContext ctx, ChannelPromise promise) {

File: handler-proxy/src/main/java/io/netty/handler/proxy/ProxyHandler.java
Patch:
@@ -27,7 +27,6 @@
 import io.netty.util.concurrent.DefaultPromise;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -60,7 +59,7 @@ public abstract class ProxyHandler extends ChannelDuplexHandler {
     private boolean suppressChannelReadComplete;
     private boolean flushedPrematurely;
     private final LazyChannelPromise connectPromise = new LazyChannelPromise();
-    private ScheduledFuture<?> connectTimeoutFuture;
+    private Future<?> connectTimeoutFuture;
     private final ChannelFutureListener writeListener = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -2102,7 +2102,7 @@ private void applyHandshakeTimeout() {
             return;
         }
 
-        final ScheduledFuture<?> timeoutFuture = ctx.executor().schedule(new Runnable() {
+        final Future<?> timeoutFuture = ctx.executor().schedule(new Runnable() {
             @Override
             public void run() {
                 if (localHandshakePromise.isDone()) {
@@ -2153,7 +2153,7 @@ private void safeClose(
             return;
         }
 
-        final ScheduledFuture<?> timeoutFuture;
+        final Future<?> timeoutFuture;
         if (!flushFuture.isDone()) {
             long closeNotifyTimeout = closeNotifyFlushTimeoutMillis;
             if (closeNotifyTimeout > 0) {
@@ -2189,7 +2189,7 @@ public void operationComplete(ChannelFuture f) {
                     // See https://github.com/netty/netty/issues/2358
                     addCloseListener(ctx.close(ctx.newPromise()), promise);
                 } else {
-                    final ScheduledFuture<?> closeNotifyReadTimeoutFuture;
+                    final Future<?> closeNotifyReadTimeoutFuture;
 
                     if (!sslClosePromise.isDone()) {
                         closeNotifyReadTimeoutFuture = ctx.executor().schedule(new Runnable() {

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -24,9 +24,9 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.concurrent.Future;
 import io.netty.util.internal.ObjectUtil;
 
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -192,7 +192,7 @@ private final class WriteTimeoutTask implements Runnable, ChannelFutureListener
         WriteTimeoutTask prev;
         WriteTimeoutTask next;
 
-        ScheduledFuture<?> scheduledFuture;
+        Future<?> scheduledFuture;
 
         WriteTimeoutTask(ChannelHandlerContext ctx, ChannelPromise promise) {
             this.ctx = ctx;

File: handler/src/test/java/io/netty/handler/timeout/IdleStateHandlerTest.java
Patch:
@@ -22,11 +22,11 @@
 import io.netty.channel.ChannelOutboundBuffer;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.Future;
 import org.junit.jupiter.api.Test;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -384,7 +384,7 @@ long ticksInNanos() {
         }
 
         @Override
-        ScheduledFuture<?> schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit) {
+        Future<?> schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit) {
             this.task = task;
             this.delayInNanos = unit.toNanos(delay);
             return null;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java
Patch:
@@ -30,7 +30,6 @@
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.GenericFutureListener;
 import io.netty.util.concurrent.Promise;
-import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -52,7 +51,7 @@ abstract class DnsQueryContext implements FutureListener<AddressedEnvelope<DnsRe
     private final InetSocketAddress nameServerAddr;
 
     private final boolean recursionDesired;
-    private volatile ScheduledFuture<?> timeoutFuture;
+    private volatile Future<?> timeoutFuture;
 
     DnsQueryContext(DnsNameResolver parent,
                     InetSocketAddress nameServerAddr,
@@ -228,7 +227,7 @@ boolean tryFailure(String message, Throwable cause, boolean timeout) {
     @Override
     public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {
         // Cancel the timeout task.
-        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;
+        Future<?> timeoutFuture = this.timeoutFuture;
         if (timeoutFuture != null) {
             this.timeoutFuture = null;
             timeoutFuture.cancel(false);

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -39,6 +39,7 @@
 import io.netty.channel.unix.Socket;
 import io.netty.channel.unix.UnixChannel;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.Future;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -49,7 +50,6 @@
 import java.nio.channels.ConnectionPendingException;
 import java.nio.channels.NotYetConnectedException;
 import java.nio.channels.UnresolvedAddressException;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 import static io.netty.channel.internal.ChannelUtils.WRITE_STATUS_SNDBUF_FULL;
@@ -64,7 +64,7 @@ abstract class AbstractEpollChannel extends AbstractChannel implements UnixChann
      * connection attempts will fail.
      */
     private ChannelPromise connectPromise;
-    private ScheduledFuture<?> connectTimeoutFuture;
+    private Future<?> connectTimeoutFuture;
     private SocketAddress requestedRemoteAddress;
 
     private volatile SocketAddress local;
@@ -160,7 +160,7 @@ protected void doClose() throws Exception {
                 connectPromise = null;
             }
 
-            ScheduledFuture<?> future = connectTimeoutFuture;
+            Future<?> future = connectTimeoutFuture;
             if (future != null) {
                 future.cancel(false);
                 connectTimeoutFuture = null;

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java
Patch:
@@ -37,6 +37,7 @@
 import io.netty.channel.unix.FileDescriptor;
 import io.netty.channel.unix.UnixChannel;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.Future;
 
 import java.io.IOException;
 import java.net.ConnectException;
@@ -47,7 +48,6 @@
 import java.nio.channels.ConnectionPendingException;
 import java.nio.channels.NotYetConnectedException;
 import java.nio.channels.UnresolvedAddressException;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 import static io.netty.channel.internal.ChannelUtils.WRITE_STATUS_SNDBUF_FULL;
@@ -61,7 +61,7 @@ abstract class AbstractKQueueChannel extends AbstractChannel implements UnixChan
      * connection attempts will fail.
      */
     private ChannelPromise connectPromise;
-    private ScheduledFuture<?> connectTimeoutFuture;
+    private Future<?> connectTimeoutFuture;
     private SocketAddress requestedRemoteAddress;
 
     final BsdSocket socket;

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -29,6 +29,7 @@
 import io.netty.channel.EventLoop;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ReferenceCounted;
+import io.netty.util.concurrent.Future;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -39,7 +40,6 @@
 import java.nio.channels.ConnectionPendingException;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -66,7 +66,7 @@ public void run() {
      * connection attempts will fail.
      */
     private ChannelPromise connectPromise;
-    private ScheduledFuture<?> connectTimeoutFuture;
+    private Future<?> connectTimeoutFuture;
     private SocketAddress requestedRemoteAddress;
 
     /**
@@ -503,7 +503,7 @@ protected void doClose() throws Exception {
             connectPromise = null;
         }
 
-        ScheduledFuture<?> future = connectTimeoutFuture;
+        Future<?> future = connectTimeoutFuture;
         if (future != null) {
             future.cancel(false);
             connectTimeoutFuture = null;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -219,7 +219,7 @@ public ChannelFuture writeData(ChannelHandlerContext ctx, int streamId, ByteBuf
                     ctx.write(frameHeader2, promiseAggregator.newPromise());
 
                     // Write the payload.
-                    if (frameDataBytes != 0 && data != null) { // Make sure Data is not null
+                    if (data != null) { // Make sure Data is not null
                         if (remainingData == 0) {
                             ByteBuf lastFrame = data.readSlice(frameDataBytes);
                             data = null;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
Patch:
@@ -138,8 +138,7 @@ public String toString() {
                 HttpHeaderNames.CONTENT_LENGTH + ": " + length() + "\r\n" +
                 "Completed: " + isCompleted() +
                 "\r\nIsInMemory: " + isInMemory() + "\r\nRealFile: " +
-                (file != null ? file.getAbsolutePath() : "null") + " DefaultDeleteAfter: " +
-                deleteOnExitTemporaryFile;
+                (file != null ? file.getAbsolutePath() : "null") + " DeleteAfter: " + deleteOnExit;
     }
 
     @Override

File: codec-dns/src/test/java/io/netty/handler/codec/dns/TcpDnsTest.java
Patch:
@@ -44,6 +44,7 @@ public void testQueryDecode() {
         DnsQuery readQuery = channel.readInbound();
         assertThat(readQuery, is(query));
         assertThat(readQuery.recordAt(DnsSection.QUESTION).name(), is(query.recordAt(DnsSection.QUESTION).name()));
+        readQuery.release();
         assertFalse(channel.finish());
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java
Patch:
@@ -42,6 +42,7 @@ abstract class ExtendedOpenSslSession extends ExtendedSSLSession implements Open
     private static final String[] LOCAL_SUPPORTED_SIGNATURE_ALGORITHMS = {
             "SHA512withRSA", "SHA512withECDSA", "SHA384withRSA", "SHA384withECDSA", "SHA256withRSA",
             "SHA256withECDSA", "SHA224withRSA", "SHA224withECDSA", "SHA1withRSA", "SHA1withECDSA",
+            "RSASSA-PSS",
     };
 
     private final OpenSslSession wrapped;

File: handler/src/test/java/io/netty/handler/ssl/ConscryptOpenSslEngineInteropTest.java
Patch:
@@ -18,6 +18,8 @@
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.condition.DisabledIf;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLSessionContext;

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -238,13 +238,13 @@ private static char forDigit(int digit) {
      * unreserved characters do not need to be encoded, and include uppercase and lowercase
      * letters, decimal digits, hyphen, period, underscore, and tilde.
      * <p>
-     * unreserved  = ALPHA / DIGIT / "-" / "_" / "." / "*"
+     * unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~" / "*"
      *
      * @param ch the char to be judged whether it need to be encode
      * @return true or false
      */
     private static boolean dontNeedEncoding(char ch) {
         return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'
-                || ch == '-' || ch == '_' || ch == '.' || ch == '*';
+                || ch == '-' || ch == '_' || ch == '.' || ch == '*' || ch == '~';
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/QueryStringDecoderTest.java
Patch:
@@ -105,6 +105,9 @@ public void testBasic() {
         assertEquals(2, d.parameters().get("abc").size());
         assertEquals("1 23", d.parameters().get("abc").get(0));
         assertEquals("124 ", d.parameters().get("abc").get(1));
+
+        d = new QueryStringDecoder("/foo?abc=%7E");
+        assertEquals("~", d.parameters().get("abc").get(0));
     }
 
     @Test

File: codec-dns/src/test/java/io/netty/handler/codec/dns/TcpDnsTest.java
Patch:
@@ -66,6 +66,7 @@ public void testResponseEncode() {
         assertThat(readResponse.<DnsRawRecord>recordAt(DnsSection.ANSWER).content(), is(record.content()));
         ReferenceCountUtil.release(readResponse);
         ReferenceCountUtil.release(record);
+        query.release();
         assertFalse(channel.finish());
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -225,7 +225,7 @@ private static final class ExtendedTrustManagerVerifyCallback extends AbstractCe
 
         ExtendedTrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509ExtendedTrustManager manager) {
             super(engineMap);
-            this.manager = OpenSslTlsv13X509ExtendedTrustManager.wrap(manager);
+            this.manager = manager;
         }
 
         @Override

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java
Patch:
@@ -267,7 +267,7 @@ private static final class ExtendedTrustManagerVerifyCallback extends AbstractCe
 
         ExtendedTrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509ExtendedTrustManager manager) {
             super(engineMap);
-            this.manager = OpenSslTlsv13X509ExtendedTrustManager.wrap(manager);
+            this.manager = manager;
         }
 
         @Override

File: handler/src/main/java/io/netty/handler/ssl/SslContext.java
Patch:
@@ -827,12 +827,14 @@ static SslContext newClientContextInternal(
                         sessionTimeout, keyStoreType);
             case OPENSSL:
                 verifyNullSslContextProvider(provider, sslContextProvider);
+                OpenSsl.ensureAvailability();
                 return new OpenSslClientContext(
                         trustCert, trustManagerFactory, keyCertChain, key, keyPassword,
                         keyManagerFactory, ciphers, cipherFilter, apn, protocols, sessionCacheSize, sessionTimeout,
                         enableOcsp, keyStoreType, options);
             case OPENSSL_REFCNT:
                 verifyNullSslContextProvider(provider, sslContextProvider);
+                OpenSsl.ensureAvailability();
                 return new ReferenceCountedOpenSslClientContext(
                         trustCert, trustManagerFactory, keyCertChain, key, keyPassword,
                         keyManagerFactory, ciphers, cipherFilter, apn, protocols, sessionCacheSize, sessionTimeout,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java
Patch:
@@ -110,7 +110,7 @@ private static void windowUpdateFrameWriteComplete(ChannelFuture future, Channel
         if (cause != null) {
             Throwable unwrappedCause;
             // Unwrap if needed
-            if (cause instanceof Http2FrameStreamException && ((unwrappedCause = cause.getCause()) != null)) {
+            if (cause instanceof Http2FrameStreamException && (unwrappedCause = cause.getCause()) != null) {
                 cause = unwrappedCause;
             }
 
@@ -677,7 +677,7 @@ public void operationComplete(ChannelFuture future) {
 
             // Only ever send a reset frame if the connection is still alive and if the stream was created before
             // as otherwise we may send a RST on a stream in an invalid state and cause a connection error.
-            if (parent().isActive() && !readEOS && Http2CodecUtil.isStreamIdValid(stream.id())) {
+            if (parent().isActive() && !readEOS && isStreamIdValid(stream.id())) {
                 Http2StreamFrame resetFrame = new DefaultHttp2ResetFrame(Http2Error.CANCEL).stream(stream());
                 write(resetFrame, unsafe().voidPromise());
                 flush();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java
Patch:
@@ -45,7 +45,7 @@ public boolean equals(Object o) {
             return false;
         }
         Http2StreamFrame other = (Http2StreamFrame) o;
-        return stream == other.stream() || (stream != null && stream.equals(other.stream()));
+        return stream == other.stream() || stream != null && stream.equals(other.stream());
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -545,7 +545,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
      */
     private final class FlowControlledHeaders extends FlowControlledBase {
         private final Http2Headers headers;
-        private final boolean hasPriorty;
+        private final boolean hasPriority;
         private final int streamDependency;
         private final short weight;
         private final boolean exclusive;
@@ -555,7 +555,7 @@ private final class FlowControlledHeaders extends FlowControlledBase {
                               int padding, boolean endOfStream, ChannelPromise promise) {
             super(stream, padding, endOfStream, promise.unvoid());
             this.headers = headers;
-            this.hasPriorty = hasPriority;
+            this.hasPriority = hasPriority;
             this.streamDependency = streamDependency;
             this.weight = weight;
             this.exclusive = exclusive;
@@ -581,7 +581,7 @@ public void write(ChannelHandlerContext ctx, int allowedBytes) {
             // closeStreamLocal().
             promise.addListener(this);
 
-            ChannelFuture f = sendHeaders(frameWriter, ctx, stream.id(), headers, hasPriorty, streamDependency,
+            ChannelFuture f = sendHeaders(frameWriter, ctx, stream.id(), headers, hasPriority, streamDependency,
                     weight, exclusive, padding, endOfStream, promise);
             // Writing headers may fail during the encode state if they violate HPACK limits.
             Throwable failureCause = f.cause();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java
Patch:
@@ -166,7 +166,7 @@ public boolean equals(Object o) {
     @Override
     public int hashCode() {
         int hash = super.hashCode();
-        hash = hash * 31 + (int) (errorCode ^ (errorCode >>> 32));
+        hash = hash * 31 + (int) (errorCode ^ errorCode >>> 32);
         hash = hash * 31 + extraStreamIds;
         return hash;
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
Patch:
@@ -117,7 +117,7 @@ public DefaultHttp2Headers(boolean validate, int arraySizeHint) {
 
     @Override
     public Http2Headers clear() {
-        this.firstNonPseudo = head;
+        firstNonPseudo = head;
         return super.clear();
     }
 
@@ -203,7 +203,7 @@ protected final HeaderEntry<CharSequence, CharSequence> newHeaderEntry(int h, Ch
     }
 
     private final class Http2HeaderEntry extends HeaderEntry<CharSequence, CharSequence> {
-        protected Http2HeaderEntry(int hash, CharSequence key, CharSequence value,
+        Http2HeaderEntry(int hash, CharSequence key, CharSequence value,
                 HeaderEntry<CharSequence, CharSequence> next) {
             super(hash, key);
             this.value = value;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -80,7 +80,7 @@ public DefaultHttp2HeadersDecoder(boolean validateHeaders, long maxHeaderListSiz
     DefaultHttp2HeadersDecoder(boolean validateHeaders, HpackDecoder hpackDecoder) {
         this.hpackDecoder = ObjectUtil.checkNotNull(hpackDecoder, "hpackDecoder");
         this.validateHeaders = validateHeaders;
-        this.maxHeaderListSizeGoAway =
+        maxHeaderListSizeGoAway =
                 Http2CodecUtil.calculateMaxHeaderListSizeGoAway(hpackDecoder.getMaxHeaderListSize());
     }
 
@@ -101,7 +101,7 @@ public void maxHeaderListSize(long max, long goAwayMax) throws Http2Exception {
                     goAwayMax, max);
         }
         hpackDecoder.setMaxHeaderListSize(max);
-        this.maxHeaderListSizeGoAway = goAwayMax;
+        maxHeaderListSizeGoAway = goAwayMax;
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -410,7 +410,7 @@ public void incrementFlowControlWindows(int delta) throws Http2Exception {
 
             window += delta;
             processedWindow += delta;
-            lowerBound = Math.min(delta, 0);
+            lowerBound = min(delta, 0);
         }
 
         @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -108,7 +108,7 @@ public void onStreamClosed(Http2Stream stream) {
             @Override
             public void onStreamHalfClosed(Http2Stream stream) {
                 if (HALF_CLOSED_LOCAL == stream.state()) {
-                    /**
+                    /*
                      * When this method is called there should not be any
                      * pending frames left if the API is used correctly. However,
                      * it is possible that a erroneous application can sneak

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java
Patch:
@@ -79,7 +79,7 @@ public boolean equals(Object o) {
     @Override
     public int hashCode() {
         int hash = super.hashCode();
-        hash = hash * 31 + (int) (errorCode ^ (errorCode >>> 32));
+        hash = hash * 31 + (int) (errorCode ^ errorCode >>> 32);
         return hash;
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -189,7 +189,7 @@ private void decode(ByteBuf in, Sink sink) throws Http2Exception {
                         }
                     } else {
                         // Literal Header Field without Indexing / never Indexed
-                        indexType = ((b & 0x10) == 0x10) ? IndexType.NEVER : IndexType.NONE;
+                        indexType = (b & 0x10) == 0x10 ? IndexType.NEVER : IndexType.NONE;
                         index = b & 0x0F;
                         switch (index) {
                             case 0:
@@ -560,7 +560,7 @@ public void appendToHeaderList(CharSequence name, CharSequence value) {
 
             if (validate) {
                 try {
-                    previousType = HpackDecoder.validate(streamId, name, previousType);
+                    previousType = validate(streamId, name, previousType);
                 } catch (Http2Exception ex) {
                     validationException = ex;
                     return;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
Patch:
@@ -245,14 +245,14 @@ private static void encodeInteger(ByteBuf out, int mask, int n, int i) {
      */
     private static void encodeInteger(ByteBuf out, int mask, int n, long i) {
         assert n >= 0 && n <= 8 : "N: " + n;
-        int nbits = 0xFF >>> (8 - n);
+        int nbits = 0xFF >>> 8 - n;
         if (i < nbits) {
             out.writeByte((int) (mask | i));
         } else {
             out.writeByte(mask | nbits);
             long length = i - nbits;
             for (; (length & ~0x7F) != 0; length >>>= 7) {
-                out.writeByte((int) ((length & 0x7F) | 0x80));
+                out.writeByte((int) (length & 0x7F | 0x80));
             }
             out.writeByte((int) length);
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackHuffmanEncoder.java
Patch:
@@ -135,7 +135,7 @@ private int getEncodedLengthSlowPath(CharSequence data) {
         for (int i = 0; i < data.length(); i++) {
             len += lengths[data.charAt(i) & 0xFF];
         }
-        return (int) ((len + 7) >> 3);
+        return (int) (len + 7 >> 3);
     }
 
     private final class EncodeProcessor implements ByteProcessor {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
Patch:
@@ -199,7 +199,7 @@ private static CharSequenceMap<Integer> createMap() {
     /**
      * Returns the last position in the array that contains multiple
      * fields with the same name. Starting from this position, all
-     * names are unique. Similary to {@link getIndexInsensitive} method
+     * names are unique. Similary to {@link #getIndexInsensitive(CharSequence, CharSequence)} method
      * assumes all entries for a given header field are sequential
      */
     private static int maxSameNameFieldIndex() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
Patch:
@@ -89,7 +89,7 @@ interface Listener {
 
         /**
          * Called when a {@code GOAWAY} was received from the remote endpoint. This event handler duplicates {@link
-         * Http2FrameListener#onGoAwayRead(io.netty.channel.ChannelHandlerContext, int, long, io.netty.buffer.ByteBuf)}
+         * Http2FrameListener#onGoAwayRead(io.netty.channel.ChannelHandlerContext, int, long, ByteBuf)}
          * but is added here in order to simplify application logic for handling {@code GOAWAY} in a uniform way. An
          * application should generally not handle both events, but if it does this method is called second, after
          * notifying the {@link Http2FrameListener}.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java
Patch:
@@ -40,7 +40,7 @@ public enum Http2Error {
     private final long code;
     private static final Http2Error[] INT_TO_ENUM_MAP;
     static {
-        Http2Error[] errors = Http2Error.values();
+        Http2Error[] errors = values();
         Http2Error[] map = new Http2Error[errors.length];
         for (Http2Error error : errors) {
             map[(int) error.code()] = error;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
Patch:
@@ -71,7 +71,7 @@ enum PseudoHeaderName {
         private static final CharSequenceMap<PseudoHeaderName> PSEUDO_HEADERS = new CharSequenceMap<PseudoHeaderName>();
 
         static {
-            for (PseudoHeaderName pseudoHeader : PseudoHeaderName.values()) {
+            for (PseudoHeaderName pseudoHeader : values()) {
                 PSEUDO_HEADERS.add(pseudoHeader.value(), pseudoHeader);
             }
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -43,7 +43,7 @@ public class Http2MultiplexCodecBuilder
     }
 
     private static ChannelHandler checkSharable(ChannelHandler handler) {
-        if ((handler instanceof ChannelHandlerAdapter && !((ChannelHandlerAdapter) handler).isSharable()) &&
+        if (handler instanceof ChannelHandlerAdapter && !((ChannelHandlerAdapter) handler).isSharable() &&
                 !handler.getClass().isAnnotationPresent(ChannelHandler.Sharable.class)) {
             throw new IllegalArgumentException("The handler must be Sharable");
         }
@@ -77,7 +77,7 @@ public static Http2MultiplexCodecBuilder forServer(ChannelHandler childHandler)
     }
 
     public Http2MultiplexCodecBuilder withUpgradeStreamHandler(ChannelHandler upgradeStreamHandler) {
-        if (this.isServer()) {
+        if (isServer()) {
             throw new IllegalArgumentException("Server codecs don't use an extra handler for the upgrade stream");
         }
         this.upgradeStreamHandler = upgradeStreamHandler;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java
Patch:
@@ -78,7 +78,7 @@ public Http2StreamFrameToHttpObjectCodec(final boolean isServer) {
 
     @Override
     public boolean acceptInboundMessage(Object msg) throws Exception {
-        return (msg instanceof Http2HeadersFrame) || (msg instanceof Http2DataFrame);
+        return msg instanceof Http2HeadersFrame || msg instanceof Http2DataFrame;
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
Patch:
@@ -443,7 +443,7 @@ public static Http2Headers toHttp2Headers(HttpMessage in, boolean validateHeader
             if (!isOriginForm(requestTargetUri) && !isAsteriskForm(requestTargetUri)) {
                 // Attempt to take from HOST header before taking from the request-line
                 String host = inHeaders.getAsString(HttpHeaderNames.HOST);
-                setHttp2Authority((host == null || host.isEmpty()) ? requestTargetUri.getAuthority() : host, out);
+                setHttp2Authority(host == null || host.isEmpty() ? requestTargetUri.getAuthority() : host, out);
             }
         } else if (in instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) in;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java
Patch:
@@ -485,7 +485,7 @@ public boolean containsTimeMillis(CharSequence name, long value) {
 
     @Override
     public int size() {
-        return (pseudoHeaders.length + otherHeaders.length) >>> 1;
+        return pseudoHeaders.length + otherHeaders.length >>> 1;
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
Patch:
@@ -126,7 +126,7 @@ public StreamBufferingEncoder(Http2ConnectionEncoder delegate) {
 
     public StreamBufferingEncoder(Http2ConnectionEncoder delegate, int initialMaxConcurrentStreams) {
         super(delegate);
-        this.maxConcurrentStreams = initialMaxConcurrentStreams;
+        maxConcurrentStreams = initialMaxConcurrentStreams;
         connection().addListener(new Http2ConnectionAdapter() {
 
             @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
Patch:
@@ -159,7 +159,7 @@ void updateStreamableBytes(int newStreamableBytes, boolean hasFrame, int windowS
             //    we gave the state a chance to write zero length frames. We wait until updateStreamableBytes is
             //    called again before this state is allowed to write.
             windowNegative = windowSize < 0;
-            if (hasFrame && (windowSize > 0 || (windowSize == 0 && !writing))) {
+            if (hasFrame && (windowSize > 0 || windowSize == 0 && !writing)) {
                 addToQueue();
             }
         }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java
Patch:
@@ -442,6 +442,7 @@ protected void initChannel(Channel ch) throws Exception {
                         .codec(decoder, clientEncoder).build();
                 p.addLast(clientHandler);
                 p.addLast(new ChannelInboundHandlerAdapter() {
+                    @Override
                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
                         if (evt == Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.INSTANCE) {
                             prefaceWrittenLatch.countDown();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java
Patch:
@@ -492,6 +492,7 @@ public void execute() throws Throwable {
         }
     }
 
+    @Test
     public void headersReadForUnknownStreamShouldThrow() throws Exception {
         when(connection.stream(STREAM_ID)).thenReturn(null);
         assertThrows(Http2Exception.class, new Executable() {
@@ -636,7 +637,7 @@ public void execute() throws Throwable {
         }
     }
 
-    @Test()
+    @Test
     public void headersReadForPromisedStreamShouldCloseStream() throws Exception {
         when(stream.state()).thenReturn(RESERVED_REMOTE);
         decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriterTest.java
Patch:
@@ -161,7 +161,7 @@ public void writeHeadersNotEndStream() throws Exception {
     }
 
     /**
-     * Test large headers that exceed {@link DefaultHttp2FrameWriter#maxFrameSize}
+     * Test large headers that exceed {@link DefaultHttp2FrameWriter#maxFrameSize()}
      * the remaining headers will be sent in a CONTINUATION frame
      */
     @Test

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
Patch:
@@ -185,7 +185,7 @@ static void verifyPseudoHeadersFirst(Http2Headers headers) {
             if (entry.getKey().length() == 0 || entry.getKey().charAt(0) != ':') {
                 lastNonPseudoName = entry.getKey();
             } else if (lastNonPseudoName != null) {
-                fail("All pseudo headers must be fist in iteration. Pseudo header " + entry.getKey() +
+                fail("All pseudo headers must be first in iteration. Pseudo header " + entry.getKey() +
                         " is after a non pseudo header " + lastNonPseudoName);
             }
         }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDynamicTableTest.java
Patch:
@@ -98,7 +98,7 @@ public void testSetCapacity() {
         table.add(entry2);
         assertEquals(2, table.length());
         assertEquals(size1 + size2, table.size());
-        table.setCapacity((size1 + size2) * 2); //larger capacity
+        table.setCapacity(((long) size1 + size2) * 2); //larger capacity
         assertEquals(2, table.length());
         assertEquals(size1 + size2, table.size());
         table.setCapacity(size2); //smaller capacity

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java
Patch:
@@ -120,7 +120,7 @@ public void tearDown() throws Exception {
     }
 
     private void setUp(Http2FrameCodecBuilder frameCodecBuilder, Http2Settings initialRemoteSettings) throws Exception {
-        /**
+        /*
          * Some tests call this method twice. Once with JUnit's @Before and once directly to pass special settings.
          * This call ensures that in case of two consecutive calls to setUp(), the previous channel is shutdown and
          * ByteBufs are released correctly.

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameInboundWriter.java
Patch:
@@ -46,7 +46,7 @@ final class Http2FrameInboundWriter {
     }
 
     Http2FrameInboundWriter(EmbeddedChannel channel, Http2FrameWriter writer) {
-        this.ctx = new WriteInboundChannelHandlerContext(channel);
+        ctx = new WriteInboundChannelHandlerContext(channel);
         this.writer = writer;
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexTest.java
Patch:
@@ -616,7 +616,7 @@ public void inboundRstStreamFireChannelInactive() {
         assertFalse(inboundHandler.isChannelActive());
 
         // A RST_STREAM frame should NOT be emitted, as we received a RST_STREAM.
-        verify(frameWriter, Mockito.never()).writeRstStream(eqCodecCtx(), eqStreamId(channel),
+        verify(frameWriter, never()).writeRstStream(eqCodecCtx(), eqStreamId(channel),
                 anyLong(), anyChannelPromise());
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexTransportTest.java
Patch:
@@ -63,7 +63,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -241,7 +240,7 @@ public void run() {
                                             }
                                         });
                                     }
-                                }, 500, TimeUnit.MILLISECONDS);
+                                }, 500, MILLISECONDS);
                             }
                             ReferenceCountUtil.release(msg);
                         }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrapTest.java
Patch:
@@ -158,7 +158,7 @@ public void open0FailsPromiseOnHttp2MultiplexHandlerError() {
         when(ctx.executor()).thenReturn(executor);
         when(ctx.handler()).thenReturn(handler);
 
-        Promise<Http2StreamChannel> promise = new DefaultPromise(mock(EventExecutor.class));
+        Promise<Http2StreamChannel> promise = new DefaultPromise<Http2StreamChannel>(mock(EventExecutor.class));
         bootstrap.open0(ctx, promise);
         assertThat(promise.isDone(), is(true));
         assertThat(promise.cause(), is(instanceOf(IllegalStateException.class)));

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpConversionUtilTest.java
Patch:
@@ -145,7 +145,7 @@ public void stripTEHeadersAccountsForValueSimilarToTrailers() {
     @Test
     public void stripTEHeadersAccountsForOWS() {
         HttpHeaders inHeaders = new DefaultHttpHeaders();
-        inHeaders.add(TE, " " + TRAILERS + " ");
+        inHeaders.add(TE, " " + TRAILERS + ' ');
         Http2Headers out = new DefaultHttp2Headers();
         HttpConversionUtil.toHttp2Headers(inHeaders, out);
         assertSame(TRAILERS, out.get(TE));

File: codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java
Patch:
@@ -727,6 +727,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
                     }
                 });
                 p.addLast(new ChannelInboundHandlerAdapter() {
+                    @Override
                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
                         if (evt == Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.INSTANCE) {
                             prefaceWrittenLatch.countDown();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/ReadOnlyHttp2HeadersTest.java
Patch:
@@ -244,11 +244,10 @@ public void execute() {
 
     @Test
     public void testIteratorMultipleValues() {
-        Http2Headers headers = ReadOnlyHttp2Headers.serverHeaders(false, new AsciiString("200"), new AsciiString[] {
+        Http2Headers headers = ReadOnlyHttp2Headers.serverHeaders(false, new AsciiString("200"),
                 new AsciiString("name2"), new AsciiString("value1"),
                 new AsciiString("name1"), new AsciiString("value2"),
-                new AsciiString("name2"), new AsciiString("value3")
-        });
+                new AsciiString("name2"), new AsciiString("value3"));
         Iterator<CharSequence> itr = headers.valueIterator("name2");
         assertTrue(itr.hasNext());
         assertTrue(AsciiString.contentEqualsIgnoreCase("value1", itr.next()));

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainDatagramPathTest.java
Patch:
@@ -41,7 +41,7 @@ void testConnectPathDoesNotExist(TestInfo testInfo) throws Throwable {
             public void run(Bootstrap bootstrap) {
                 try {
                     bootstrap.handler(new ChannelInboundHandlerAdapter())
-                             .connect(EpollSocketTestPermutation.newSocketAddress()).sync().channel();
+                             .connect(EpollSocketTestPermutation.newDomainSocketAddress()).sync().channel();
                     fail("Expected FileNotFoundException");
                 } catch (Exception e) {
                     assertTrue(e instanceof FileNotFoundException);
@@ -57,10 +57,10 @@ void testWriteReceiverPathDoesNotExist(TestInfo testInfo) throws Throwable {
             public void run(Bootstrap bootstrap) {
                 try {
                     Channel ch = bootstrap.handler(new ChannelInboundHandlerAdapter())
-                                          .bind(EpollSocketTestPermutation.newSocketAddress()).sync().channel();
+                                          .bind(EpollSocketTestPermutation.newDomainSocketAddress()).sync().channel();
                     ch.writeAndFlush(new DomainDatagramPacket(
                             Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII),
-                            EpollSocketTestPermutation.newSocketAddress())).sync();
+                            EpollSocketTestPermutation.newDomainSocketAddress())).sync();
                     fail("Expected FileNotFoundException");
                 } catch (Exception e) {
                     assertTrue(e instanceof FileNotFoundException);

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainDatagramUnicastTest.java
Patch:
@@ -80,7 +80,7 @@ protected List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>>
 
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketDataReadInitialStateTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketDataReadInitialStateTest extends SocketDataReadInitialStateTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketEchoTest.java
Patch:
@@ -25,7 +25,7 @@
 public class EpollDomainSocketEchoTest extends EpollSocketEchoTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketFdTest.java
Patch:
@@ -43,7 +43,7 @@
 public class EpollDomainSocketFdTest extends AbstractSocketTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketFileRegionTest.java
Patch:
@@ -25,7 +25,7 @@
 public class EpollDomainSocketFileRegionTest extends EpollSocketFileRegionTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketFixedLengthEchoTest.java
Patch:
@@ -27,7 +27,7 @@ public class EpollDomainSocketFixedLengthEchoTest extends SocketFixedLengthEchoT
 
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketGatheringWriteTest.java
Patch:
@@ -27,7 +27,7 @@ public class EpollDomainSocketGatheringWriteTest extends SocketGatheringWriteTes
 
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketObjectEchoTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketObjectEchoTest extends SocketObjectEchoTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketReuseFdTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketReuseFdTest extends AbstractSocketReuseFdTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketShutdownOutputByPeerTest.java
Patch:
@@ -35,7 +35,7 @@ protected List<BootstrapFactory<ServerBootstrap>> newFactories() {
 
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketSslClientRenegotiateTest.java
Patch:
@@ -31,6 +31,6 @@ protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Boots
 
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 }

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketSslEchoTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketSslEchoTest extends SocketSslEchoTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketSslGreetingTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketSslGreetingTest extends SocketSslGreetingTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketStartTlsTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketStartTlsTest extends SocketStartTlsTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketStringEchoTest.java
Patch:
@@ -26,7 +26,7 @@
 public class EpollDomainSocketStringEchoTest extends SocketStringEchoTest {
     @Override
     protected SocketAddress newSocketAddress() {
-        return EpollSocketTestPermutation.newSocketAddress();
+        return EpollSocketTestPermutation.newDomainSocketAddress();
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTest.java
Patch:
@@ -47,7 +47,7 @@ public void testPeerCreds() throws IOException {
         LinuxSocket s2 = LinuxSocket.newSocketDomain();
 
         try {
-            DomainSocketAddress dsa = UnixTestUtils.newSocketAddress();
+            DomainSocketAddress dsa = UnixTestUtils.newDomainSocketAddress();
             s1.bind(dsa);
             s1.listen(1);
 

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTestPermutation.java
Patch:
@@ -259,7 +259,7 @@ public Bootstrap newInstance() {
         );
     }
 
-    public static DomainSocketAddress newSocketAddress() {
-        return UnixTestUtils.newSocketAddress();
+    public static DomainSocketAddress newDomainSocketAddress() {
+        return UnixTestUtils.newDomainSocketAddress();
     }
 }

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketTest.java
Patch:
@@ -40,7 +40,7 @@ public void testPeerCreds() throws IOException {
         BsdSocket s2 = BsdSocket.newSocketDomain();
 
         try {
-            DomainSocketAddress dsa = UnixTestUtils.newSocketAddress();
+            DomainSocketAddress dsa = UnixTestUtils.newDomainSocketAddress();
             s1.bind(dsa);
             s1.listen(1);
 
@@ -61,7 +61,7 @@ public void testPeerPID() throws IOException {
         BsdSocket s2 = BsdSocket.newSocketDomain();
 
         try {
-            DomainSocketAddress dsa = UnixTestUtils.newSocketAddress();
+            DomainSocketAddress dsa = UnixTestUtils.newDomainSocketAddress();
             s1.bind(dsa);
             s1.listen(1);
 

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketTestPermutation.java
Patch:
@@ -50,7 +50,7 @@ class KQueueSocketTestPermutation extends SocketTestPermutation {
     public List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
 
         List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
-                combo(serverSocket(), clientSocket());
+                combo(serverSocket(), clientSocketWithFastOpen());
 
         list.remove(list.size() - 1); // Exclude NIO x NIO test
 
@@ -202,6 +202,6 @@ public Bootstrap newInstance() {
     }
 
     public static DomainSocketAddress newSocketAddress() {
-        return UnixTestUtils.newSocketAddress();
+        return UnixTestUtils.newDomainSocketAddress();
     }
 }

File: buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
Patch:
@@ -35,6 +35,7 @@
 
 final class AdvancedLeakAwareByteBuf extends SimpleLeakAwareByteBuf {
 
+    // If set to true we will only record stacktraces for touch(...), release(...) and retain(...) calls.
     private static final String PROP_ACQUIRE_AND_RELEASE_ONLY = "io.netty.leakDetection.acquireAndReleaseOnly";
     private static final boolean ACQUIRE_AND_RELEASE_ONLY;
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -331,6 +331,8 @@ public final class OpenSsl {
 
             addIfSupported(availableJavaCipherSuites, defaultCiphers, DEFAULT_CIPHER_SUITES);
             addIfSupported(availableJavaCipherSuites, defaultCiphers, TLSV13_CIPHER_SUITES);
+            // Also handle the extra supported ciphers as these will contain some more stuff on BoringSSL.
+            addIfSupported(availableJavaCipherSuites, defaultCiphers, EXTRA_SUPPORTED_TLS_1_3_CIPHERS);
 
             useFallbackCiphersIfDefaultIsEmpty(defaultCiphers, availableJavaCipherSuites);
             DEFAULT_CIPHERS = Collections.unmodifiableList(defaultCiphers);

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -33,7 +33,6 @@
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
 import java.security.Provider;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -120,7 +119,7 @@ final class SslUtils {
             DEFAULT_TLSV13_CIPHER_SUITES = EmptyArrays.EMPTY_STRINGS;
         }
 
-        List<String> defaultCiphers = new ArrayList<String>();
+        Set<String> defaultCiphers = new LinkedHashSet<String>();
         // GCM (Galois/Counter Mode) requires JDK 8.
         defaultCiphers.add("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384");
         defaultCiphers.add("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256");

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java
Patch:
@@ -323,7 +323,7 @@ private boolean upgrade(final ChannelHandlerContext ctx, final FullHttpRequest r
         // Make sure the CONNECTION header is present.
         List<String> connectionHeaderValues = request.headers().getAll(HttpHeaderNames.CONNECTION);
 
-        if (connectionHeaderValues == null) {
+        if (connectionHeaderValues == null || connectionHeaderValues.isEmpty()) {
             return false;
         }
 

File: buffer/src/main/java/io/netty/buffer/search/AbstractSearchProcessorFactory.java
Patch:
@@ -39,7 +39,7 @@
  * {@link io.netty.buffer.ByteBuf}s). A new instance should be created with {@link AbstractSearchProcessorFactory} for
  * every search session. However, a {@link SearchProcessor} can (and should) be reused within the search session,
  * eg. when searching for all occurrences of the {@code needle} within the same {@code haystack}. That way, it can
- * also detect overlapping occurrences of the {@code needle} (eg. a string "ABABAB" contains two occurences of "BAB"
+ * also detect overlapping occurrences of the {@code needle} (eg. a string "ABABAB" contains two occurrences of "BAB"
  * that overlap by one character "B"). For this to work correctly, after an occurrence of the {@code needle} is
  * found ending at index {@code idx}, the search should continue starting from the index {@code idx + 1}.
  * <br>

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -576,7 +576,7 @@ public DnsCache resolveCache() {
     /**
      * Returns the {@link DnsCnameCache}.
      */
-    DnsCnameCache cnameCache() {
+    public DnsCnameCache cnameCache() {
         return cnameCache;
     }
 

File: handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
Patch:
@@ -285,7 +285,7 @@ public File certificate() {
     }
 
     /**
-     * Returns the generated RSA private key file in PEM format.
+     * Returns the generated EC/RSA private key file in PEM format.
      */
     public File privateKey() {
         return privateKey;
@@ -299,14 +299,14 @@ public X509Certificate cert() {
     }
 
     /**
-     * Returns the generated RSA private key.
+     * Returns the generated EC/RSA private key.
      */
     public PrivateKey key() {
         return key;
     }
 
     /**
-     * Deletes the generated X.509 certificate file and RSA private key file.
+     * Deletes the generated X.509 certificate file and EC/RSA private key file.
      */
     public void delete() {
         safeDelete(certificate);

File: handler/src/test/java/io/netty/handler/ssl/Java8SslTestUtils.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 
-import static org.junit.Assert.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 public final class Java8SslTestUtils {
 
@@ -70,7 +70,7 @@ public static X509Certificate[] loadCertCollection(String... resourceNames)
             InputStream is = null;
             try {
                 is = SslContextTest.class.getResourceAsStream(resourceName);
-                assertNotNull("Cannot find " + resourceName, is);
+                assertNotNull(is, "Cannot find " + resourceName);
                 certCollection[i] = (X509Certificate) certFactory
                         .generateCertificate(is);
             } finally {

File: handler/src/test/java/io/netty/handler/ssl/OpenSslClientContextTest.java
Patch:
@@ -16,14 +16,14 @@
 package io.netty.handler.ssl;
 
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
 import javax.net.ssl.SSLException;
 import java.io.File;
 
 public class OpenSslClientContextTest extends SslContextTest  {
 
-    @BeforeClass
+    @BeforeAll
     public static void checkOpenSsl() {
         OpenSsl.ensureAvailability();
     }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.internal.tcnative.SSL;
 import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.PlatformDependent;
-import org.junit.Assert;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLEngineResult;
@@ -29,6 +28,8 @@
 import java.util.List;
 import java.util.function.BiFunction;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
 /**
  * Special {@link SSLEngine} which allows to wrap a {@link ReferenceCountedOpenSslEngine} and verify that that
  * Error stack is empty after each method call.
@@ -436,6 +437,6 @@ public ReferenceCountedOpenSslEngine getWrappedEngine() {
 
     private static void assertErrorStackEmpty() {
         long error = SSL.getLastErrorNumber();
-        Assert.assertEquals("SSL error stack non-empty: " + SSL.getErrorString(error), 0, error);
+        assertEquals(0, error, "SSL error stack non-empty: " + SSL.getErrorString(error));
     }
 }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslRenegotiateTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.ssl;
 
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -24,11 +24,10 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assume.assumeTrue;
 
 public class OpenSslRenegotiateTest extends RenegotiateTest {
 
-    @BeforeClass
+    @BeforeAll
     public static void checkOpenSsl() {
         OpenSsl.ensureAvailability();
     }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslServerContextTest.java
Patch:
@@ -15,14 +15,14 @@
  */
 package io.netty.handler.ssl;
 
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
 import javax.net.ssl.SSLException;
 import java.io.File;
 
 public class OpenSslServerContextTest extends SslContextTest {
 
-    @BeforeClass
+    @BeforeAll
     public static void checkOpenSsl() {
         OpenSsl.ensureAvailability();
     }

File: handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
Patch:
@@ -72,7 +72,7 @@
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-import static org.junit.Assume.assumeTrue;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;

File: handler/src/test/java/io/netty/handler/ssl/SslContextTest.java
Patch:
@@ -31,7 +31,7 @@
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLException;
 
-import static org.junit.Assume.assumeNotNull;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -124,7 +124,7 @@ public void testSupportedCiphers() throws KeyManagementException, NoSuchAlgorith
         } catch (IllegalArgumentException e) {
             exception = e;
         }
-        assumeNotNull(exception);
+        assumeTrue(exception != null);
         File keyFile = ResourcesUtil.getFile(getClass(), "test_unencrypted.pem");
         File crtFile = ResourcesUtil.getFile(getClass(), "test.crt");
 

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -103,7 +103,6 @@
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
 import static org.junit.jupiter.api.Assumptions.assumeFalse;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilderTest.java
Patch:
@@ -32,7 +32,7 @@
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
-import org.junit.AfterClass;
+import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
@@ -124,7 +124,7 @@ protected void initChannel(Channel ch) throws Exception {
         assertTrue(serverChannelLatch.await(5, SECONDS));
     }
 
-    @AfterClass
+    @AfterAll
     public static void shutdown() {
         group.shutdownGracefully(0, 5, SECONDS);
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -44,8 +44,8 @@
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;
 import static io.netty.util.ReferenceCountUtil.release;
 import static java.lang.Math.min;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyByte;

File: microbench/src/main/java/io/netty/microbench/handler/ssl/AbstractSslHandlerBenchmark.java
Patch:
@@ -34,7 +34,6 @@
 import javax.net.ssl.SSLException;
 
 import static io.netty.handler.codec.ByteToMessageDecoder.COMPOSITE_CUMULATOR;
-import static org.junit.Assert.assertNull;
 
 public class AbstractSslHandlerBenchmark extends AbstractMicrobenchmark {
     private static final String PROTOCOL_TLS_V1_2 = "TLSv1.2";
@@ -176,6 +175,8 @@ protected void handleException(Throwable t) {
     }
 
     public static void handleUnexpectedException(Throwable t) {
-        assertNull(t);
+        if (t != null) {
+            throw new IllegalStateException(t);
+        }
     }
 }

File: microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.microbench.util;
 
-import static org.junit.Assert.assertNull;
 import io.netty.channel.EventLoop;
 import io.netty.util.concurrent.AbstractEventExecutor;
 import io.netty.util.concurrent.Future;
@@ -154,6 +153,8 @@ protected String[] jvmArgs() {
     }
 
     public static void handleUnexpectedException(Throwable t) {
-        assertNull(t);
+        if (t != null) {
+            throw new IllegalStateException(t);
+        }
     }
 }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastIPv6Test.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SuppressJava6Requirement;
-import org.junit.Assume;
+import org.junit.AssumptionViolatedException;
 import org.junit.jupiter.api.BeforeAll;
 
 import java.io.IOException;
@@ -38,7 +38,7 @@ public static void assumeIpv6Supported() {
             Channel channel = SelectorProvider.provider().openDatagramChannel(StandardProtocolFamily.INET6);
             channel.close();
         } catch (UnsupportedOperationException e) {
-            Assume.assumeNoException("IPv6 not supported", e);
+           throw new AssumptionViolatedException("IPv6 not supported", e);
         } catch (IOException ignore) {
             // Ignore
         }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
Patch:
@@ -37,7 +37,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class SocketSpdyEchoTest extends AbstractSocketTest {
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/AbstractUdtTest.java
Patch:
@@ -17,9 +17,9 @@
 package io.netty.test.udt.nio;
 
 import io.netty.test.udt.util.UnitHelp;
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
-import static org.junit.Assume.*;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
 
 /**
  * Base for UDT tests.
@@ -29,7 +29,7 @@ public abstract class AbstractUdtTest {
     /**
      * UDT test assumptions.
      */
-    @BeforeClass
+    @BeforeAll
     public static void assumeConditions() {
         assumeTrue(UnitHelp.canLoadAndInitClass("com.barchart.udt.SocketUDT"));
     }

File: codec/src/test/java/io/netty/handler/codec/compression/BrotliDecoderTest.java
Patch:
@@ -62,8 +62,7 @@ public class BrotliDecoderTest {
     }
 
     static boolean isNotSupported() {
-        return (PlatformDependent.isOsx() || PlatformDependent.isWindows())
-                && "aarch_64".equals(PlatformDependent.normalizedArch());
+        return PlatformDependent.isOsx() && "aarch_64".equals(PlatformDependent.normalizedArch());
     }
 
     private static void fillArrayWithCompressibleData(byte[] array) {

File: codec/src/test/java/io/netty/handler/codec/compression/BrotliEncoderTest.java
Patch:
@@ -71,7 +71,6 @@ protected ByteBuf readDecompressed(final int dataLength) throws Exception {
     }
 
     static boolean isNotSupported() {
-        return (PlatformDependent.isOsx() || PlatformDependent.isWindows())
-                && "aarch_64".equals(PlatformDependent.normalizedArch());
+        return PlatformDependent.isOsx() && "aarch_64".equals(PlatformDependent.normalizedArch());
     }
 }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastIPv6Test.java
Patch:
@@ -26,7 +26,7 @@
 import java.nio.channels.Channel;
 import java.nio.channels.spi.SelectorProvider;
 
-public class DatagramUnicastIPv6Test extends DatagramUnicastTest {
+public class DatagramUnicastIPv6Test extends DatagramUnicastInetTest {
 
     @SuppressJava6Requirement(reason = "Guarded by java version check")
     @BeforeAll

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDatagramUnicastTest.java
Patch:
@@ -27,7 +27,7 @@
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.testsuite.transport.TestsuitePermutation;
-import io.netty.testsuite.transport.socket.DatagramUnicastTest;
+import io.netty.testsuite.transport.socket.DatagramUnicastInetTest;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
 
@@ -41,7 +41,7 @@
 import static org.junit.jupiter.api.Assertions.fail;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 
-public class EpollDatagramUnicastTest extends DatagramUnicastTest {
+public class EpollDatagramUnicastTest extends DatagramUnicastInetTest {
     @Override
     protected List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> newFactories() {
         return EpollSocketTestPermutation.INSTANCE.datagram(InternetProtocolFamily.IPv4);

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramUnicastTest.java
Patch:
@@ -18,11 +18,11 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.testsuite.transport.TestsuitePermutation;
-import io.netty.testsuite.transport.socket.DatagramUnicastTest;
+import io.netty.testsuite.transport.socket.DatagramUnicastInetTest;
 
 import java.util.List;
 
-public class KQueueDatagramUnicastTest extends DatagramUnicastTest {
+public class KQueueDatagramUnicastTest extends DatagramUnicastInetTest {
     @Override
     protected List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> newFactories() {
         return KQueueSocketTestPermutation.INSTANCE.datagram(InternetProtocolFamily.IPv4);

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/DomainSocketAddress.java
Patch:
@@ -24,7 +24,7 @@
  * A address for a
  * <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix Domain Socket</a>.
  */
-public final class DomainSocketAddress extends SocketAddress {
+public class DomainSocketAddress extends SocketAddress {
     private static final long serialVersionUID = -6934618000832236893L;
     private final String socketPath;
 

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/Unix.java
Patch:
@@ -43,7 +43,7 @@ public final class Unix {
                 IOException.class, PortUnreachableException.class,
 
                 // netty_unix_socket
-                DatagramSocketAddress.class, InetSocketAddress.class
+                DatagramSocketAddress.class, DomainDatagramSocketAddress.class, InetSocketAddress.class
         );
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -2393,7 +2393,7 @@ public void putValue(String name, Object value) {
             }
 
             if (value instanceof SSLSessionBindingListener) {
-                // Use newSSLSessionBindingEvent so we alway use the wrapper if needed.
+                // Use newSSLSessionBindingEvent so we always use the wrapper if needed.
                 ((SSLSessionBindingListener) value).valueBound(newSSLSessionBindingEvent(name));
             }
             notifyUnbound(old, name);
@@ -2439,7 +2439,7 @@ public String[] getValueNames() {
 
         private void notifyUnbound(Object value, String name) {
             if (value instanceof SSLSessionBindingListener) {
-                // Use newSSLSessionBindingEvent so we alway use the wrapper if needed.
+                // Use newSSLSessionBindingEvent so we always use the wrapper if needed.
                 ((SSLSessionBindingListener) value).valueUnbound(newSSLSessionBindingEvent(name));
             }
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
Patch:
@@ -778,6 +778,7 @@ private static void assertEncodedResponse(HttpResponse res) {
         assertThat(res.headers().get(HttpHeaderNames.CONTENT_LENGTH), is(nullValue()));
         assertThat(res.headers().get(HttpHeaderNames.CONTENT_ENCODING), is("gzip"));
     }
+
     private static void assertAssembledEncodedResponse(EmbeddedChannel ch) {
         Object o = ch.readOutbound();
         assertThat(o, is(instanceOf(AssembledHttpResponse.class)));

File: codec/src/test/java/io/netty/handler/codec/compression/BrotliDecoderTest.java
Patch:
@@ -136,7 +136,7 @@ private void testDecompression(final ByteBuf expected, final ByteBuf data) {
         decompressed.release();
     }
 
-  private void testDecompressionOfBatchedFlow(final ByteBuf expected, final ByteBuf data) {
+    private void testDecompressionOfBatchedFlow(final ByteBuf expected, final ByteBuf data) {
         final int compressedLength = data.readableBytes();
         int written = 0, length = RANDOM.nextInt(100);
         while (written + length < compressedLength) {
@@ -155,7 +155,7 @@ private void testDecompressionOfBatchedFlow(final ByteBuf expected, final ByteBu
         data.release();
     }
 
-  private static ByteBuf readDecompressed(final EmbeddedChannel channel) {
+    private static ByteBuf readDecompressed(final EmbeddedChannel channel) {
         CompositeByteBuf decompressed = Unpooled.compositeBuffer();
         ByteBuf msg;
         while ((msg = channel.readInbound()) != null) {

File: handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
Patch:
@@ -107,8 +107,8 @@ private static String[] defaultProtocols(SSLContext context, SSLEngine engine) {
         List<String> protocols = new ArrayList<String>();
         addIfSupported(
                 supportedProtocolsSet, protocols,
-                SslUtils.PROTOCOL_TLS_V1_3, SslUtils.PROTOCOL_TLS_V1_2,
-                SslUtils.PROTOCOL_TLS_V1_1, SslUtils.PROTOCOL_TLS_V1);
+                SslProtocols.TLS_v1_3, SslProtocols.TLS_v1_2,
+                SslProtocols.TLS_v1_1, SslProtocols.TLS_v1);
 
         if (!protocols.isEmpty()) {
             return protocols.toArray(EmptyArrays.EMPTY_STRINGS);
@@ -154,7 +154,7 @@ private static List<String> defaultCiphers(SSLEngine engine, Set<String> support
 
     private static boolean isTlsV13Supported(String[] protocols) {
         for (String protocol: protocols) {
-            if (SslUtils.PROTOCOL_TLS_V1_3.equals(protocol)) {
+            if (SslProtocols.TLS_v1_3.equals(protocol)) {
                 return true;
             }
         }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslTlsv13X509ExtendedTrustManager.java
Patch:
@@ -66,7 +66,7 @@ public void checkServerTrusted(X509Certificate[] x509Certificates, String s, Soc
 
     private static SSLEngine wrapEngine(final SSLEngine engine) {
         final SSLSession session = engine.getHandshakeSession();
-        if (session != null && SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol())) {
+        if (session != null && SslProtocols.TLS_v1_3.equals(session.getProtocol())) {
             return new JdkSslEngine(engine) {
                 @Override
                 public String getNegotiatedApplicationProtocol() {
@@ -93,7 +93,7 @@ public String[] getPeerSupportedSignatureAlgorithms() {
 
                             @Override
                             public String getProtocol() {
-                                return SslUtils.PROTOCOL_TLS_V1_2;
+                                return SslProtocols.TLS_v1_2;
                             }
                         };
                     } else {
@@ -181,7 +181,7 @@ public String getCipherSuite() {
 
                             @Override
                             public String getProtocol() {
-                                return SslUtils.PROTOCOL_TLS_V1_2;
+                                return SslProtocols.TLS_v1_2;
                             }
 
                             @Override

File: handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java
Patch:
@@ -124,7 +124,7 @@ public void testHandshake(SslProvider serverSslProvider, SslProvider clientSslPr
                 .sslProvider(serverSslProvider)
                 .ciphers(ciphers)
                 // As this is not a TLSv1.3 cipher we should ensure we talk something else.
-                .protocols(SslUtils.PROTOCOL_TLS_V1_2)
+                .protocols(SslProtocols.TLS_v1_2)
                 .build();
 
         final ExecutorService executorService = delegate ? Executors.newCachedThreadPool() : null;
@@ -134,7 +134,7 @@ public void testHandshake(SslProvider serverSslProvider, SslProvider clientSslPr
                     .sslProvider(clientSslProvider)
                     .ciphers(ciphers)
                     // As this is not a TLSv1.3 cipher we should ensure we talk something else.
-                    .protocols(SslUtils.PROTOCOL_TLS_V1_2)
+                    .protocols(SslProtocols.TLS_v1_2)
                     .trustManager(InsecureTrustManagerFactory.INSTANCE)
                     .build();
 

File: handler/src/test/java/io/netty/handler/ssl/DelegatingSslContextTest.java
Patch:
@@ -25,7 +25,7 @@
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 
 public class DelegatingSslContextTest {
-    private static final String[] EXPECTED_PROTOCOLS = { SslUtils.PROTOCOL_TLS_V1_1 };
+    private static final String[] EXPECTED_PROTOCOLS = { SslProtocols.TLS_v1_1 };
 
     @Test
     public void testInitEngineOnNewEngine() throws Exception {

File: handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
Patch:
@@ -299,7 +299,7 @@ public void testAlpnCompatibleProtocolsDifferentClientOrder() throws Exception {
 
     @Test
     public void testEnablingAnAlreadyDisabledSslProtocol() throws Exception {
-        testEnablingAnAlreadyDisabledSslProtocol(new String[]{}, new String[]{ SslUtils.PROTOCOL_TLS_V1_2 });
+        testEnablingAnAlreadyDisabledSslProtocol(new String[]{}, new String[]{ SslProtocols.TLS_v1_2 });
     }
 
     @Ignore /* Does the JDK support a "max certificate chain length"? */

File: handler/src/test/java/io/netty/handler/ssl/ParameterizedSslHandlerTest.java
Patch:
@@ -405,7 +405,7 @@ private void testCloseNotify(SslProvider clientProvider, SslProvider serverProvi
                                                          // Use TLSv1.2 as we depend on the fact that the handshake
                                                          // is done in an extra round trip in the test which
                                                          // is not true in TLSv1.3
-                                                         .protocols(SslUtils.PROTOCOL_TLS_V1_2)
+                                                         .protocols(SslProtocols.TLS_v1_2)
                                                          .build();
 
         final SslContext sslClientCtx = SslContextBuilder.forClient()
@@ -414,7 +414,7 @@ private void testCloseNotify(SslProvider clientProvider, SslProvider serverProvi
                                                          // Use TLSv1.2 as we depend on the fact that the handshake
                                                          // is done in an extra round trip in the test which
                                                          // is not true in TLSv1.3
-                                                         .protocols(SslUtils.PROTOCOL_TLS_V1_2)
+                                                         .protocols(SslProtocols.TLS_v1_2)
                                                          .build();
 
         EventLoopGroup group = new NioEventLoopGroup();

File: handler/src/test/java/io/netty/handler/ssl/RenegotiateTest.java
Patch:
@@ -50,7 +50,7 @@ public void testRenegotiateServer() throws Throwable {
         try {
             final SslContext context = SslContextBuilder.forServer(cert.key(), cert.cert())
                     .sslProvider(serverSslProvider())
-                    .protocols(SslUtils.PROTOCOL_TLS_V1_2)
+                    .protocols(SslProtocols.TLS_v1_2)
                     .build();
 
             ServerBootstrap sb = new ServerBootstrap();
@@ -105,7 +105,7 @@ public void operationComplete(Future<Channel> future) throws Exception {
             final SslContext clientContext = SslContextBuilder.forClient()
                     .trustManager(InsecureTrustManagerFactory.INSTANCE)
                     .sslProvider(SslProvider.JDK)
-                    .protocols(SslUtils.PROTOCOL_TLS_V1_2)
+                    .protocols(SslProtocols.TLS_v1_2)
                     .build();
 
             Bootstrap bootstrap = new Bootstrap();

File: handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
Patch:
@@ -611,7 +611,7 @@ protected void initChannel(Channel ch) throws Exception {
      * This is a {@link SslHandler} that will call {@code release()} on the {@link SslContext} when
      * the client disconnects.
      *
-     * @see SniHandlerTest#testReplaceHandler()
+     * @see SniHandlerTest#testReplaceHandler(SslProvider)
      */
     private static class CustomSslHandler extends SslHandler {
         private final SslContext sslContext;

File: handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
Patch:
@@ -37,7 +37,7 @@
 import io.netty.handler.timeout.IdleStateEvent;
 import io.netty.handler.timeout.IdleStateHandler;
 import io.netty.util.ReferenceCountUtil;
-import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
 
@@ -64,7 +64,7 @@ public static void init() {
         GROUP = new NioEventLoopGroup();
     }
 
-    @AfterEach
+    @AfterAll
     public static void destroy() {
         GROUP.shutdownGracefully();
     }

File: microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmarkBase.java
Patch:
@@ -15,15 +15,14 @@
  */
 package io.netty.microbench.util;
 
-import static org.junit.Assert.assertNull;
 import io.netty.util.ResourceLeakDetector;
 import io.netty.util.internal.SystemPropertyUtil;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
@@ -33,6 +32,8 @@
 import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;
 import org.openjdk.jmh.runner.options.OptionsBuilder;
 
+import static org.junit.jupiter.api.Assertions.assertNull;
+
 /**
  * Base class for all JMH benchmarks.
  */

File: codec-http/src/test/java/io/netty/handler/codec/http/EmptyHttpHeadersInitializationTest.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.handler.codec.http;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 /**
  * A test to validate that either order of initialization of the {@link EmptyHttpHeaders#INSTANCE} and

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
Patch:
@@ -15,12 +15,13 @@
  */
 package io.netty.handler.codec.http;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.text.ParseException;
 import java.util.Date;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 public class HttpHeaderDateFormatTest {
     /**

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.util.CharsetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Random;
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -20,8 +20,7 @@
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.AsciiString;
 import io.netty.util.CharsetUtil;
-
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.List;
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpServerExpectContinueHandlerTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.ReferenceCountUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpServerUpgradeHandlerTest.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.Collection;
 import java.util.Collections;
 
-import org.junit.Test;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelDuplexHandler;
@@ -33,6 +31,7 @@
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodec;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodecFactory;
 import io.netty.util.CharsetUtil;
+import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -43,7 +42,7 @@
 
 public class HttpServerUpgradeHandlerTest {
 
-    private class TestUpgradeCodec implements UpgradeCodec {
+    private static class TestUpgradeCodec implements UpgradeCodec {
         @Override
         public Collection<CharSequence> requiredUpgradeHeaders() {
             return Collections.<CharSequence>emptyList();

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpUtilTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.function.Executable;
 
 import java.net.InetAddress;

File: codec-http/src/test/java/io/netty/handler/codec/rtsp/RtspEncoderTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.rtsp;
 
-import static org.junit.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -27,8 +26,9 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.util.CharsetUtil;
+import org.junit.jupiter.api.Test;
 
-import org.junit.Test;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /**
  * Test cases for RTSP encoder.

File: codec-http/src/test/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersTest.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec.spdy;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 public class DefaultSpdyHeadersTest {
 

File: common/src/test/java/io/netty/util/concurrent/ScheduledFutureTaskTest.java
Patch:
@@ -15,13 +15,13 @@
  */
 package io.netty.util.concurrent;
 
-import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Assertions;
 
 public class ScheduledFutureTaskTest {
 
     @Test
     public void testDeadlineNanosNotOverflow() {
-        Assert.assertEquals(Long.MAX_VALUE, ScheduledFutureTask.deadlineNanos(Long.MAX_VALUE));
+        Assertions.assertEquals(Long.MAX_VALUE, ScheduledFutureTask.deadlineNanos(Long.MAX_VALUE));
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
Patch:
@@ -17,9 +17,9 @@
 package io.netty.test.udt.nio;
 
 import io.netty.channel.udt.nio.NioUdtByteAcceptorChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class NioUdtByteAcceptorChannelTest extends AbstractUdtTest {
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
Patch:
@@ -17,9 +17,9 @@
 package io.netty.test.udt.nio;
 
 import io.netty.channel.udt.nio.NioUdtByteConnectorChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
Patch:
@@ -17,9 +17,9 @@
 package io.netty.test.udt.nio;
 
 import io.netty.channel.udt.nio.NioUdtMessageAcceptorChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class NioUdtMessageAcceptorChannelTest extends AbstractUdtTest {
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
Patch:
@@ -17,9 +17,9 @@
 package io.netty.test.udt.nio;
 
 import io.netty.channel.udt.nio.NioUdtMessageConnectorChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class NioUdtMessageConnectorChannelTest extends AbstractUdtTest {
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java
Patch:
@@ -235,7 +235,7 @@ public final class HttpHeaderValues {
     /**
      * {@code "XmlHttpRequest"}
      */
-    public static final AsciiString XML_HTTP_REQUEST = AsciiString.cached("XmlHttpRequest");
+    public static final AsciiString XML_HTTP_REQUEST = AsciiString.cached("XMLHttpRequest");
 
     private HttpHeaderValues() { }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java
Patch:
@@ -315,6 +315,7 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromi
                 compressor.maxCompressedLength(buffer.readableBytes()) + HEADER_LENGTH);
         flushBufferedData(footer);
 
+        footer.ensureWritable(HEADER_LENGTH);
         final int idx = footer.writerIndex();
         footer.setLong(idx, MAGIC_NUMBER);
         footer.setByte(idx + TOKEN_OFFSET, (byte) (BLOCK_TYPE_NON_COMPRESSED | compressionLevel));

File: transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
Patch:
@@ -25,12 +25,13 @@
 import io.netty.util.concurrent.GlobalEventExecutor;
 import io.netty.util.concurrent.Promise;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.lang.reflect.Field;
 import java.util.concurrent.TimeUnit;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class ThreadPerChannelEventLoopGroupTest {
 

File: transport/src/test/java/io/netty/channel/pool/FixedChannelPoolMapDeadlockTest.java
Patch:
@@ -23,14 +23,14 @@
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.util.concurrent.Future;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.concurrent.Callable;
 import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 /**
  * This is a test case for the deadlock scenario described in https://github.com/netty/netty/issues/8238.

File: codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttConnectPayloadTest.java
Patch:
@@ -16,10 +16,10 @@
 
 package io.netty.handler.codec.mqtt;
 
-import static org.junit.Assert.assertNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 import io.netty.util.CharsetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Collections;
 

File: codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttMessageBuildersTest.java
Patch:
@@ -17,9 +17,9 @@
 package io.netty.handler.codec.mqtt;
 
 import io.netty.handler.codec.mqtt.MqttMessageBuilders.PropertiesInitializer;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class MqttMessageBuildersTest {
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HashCollisionTest.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.util.AsciiString;
 import io.netty.util.internal.PlatformDependent;
-import org.junit.Ignore;
+import org.junit.jupiter.api.Disabled;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -37,7 +37,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 
-@Ignore
+@Disabled
 public final class HashCollisionTest {
     private HashCollisionTest() { }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2DefaultFramesTest.java
Patch:
@@ -17,9 +17,9 @@
 
 import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.buffer.Unpooled;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class Http2DefaultFramesTest {
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2EmptyDataFrameConnectionDecoderTest.java
Patch:
@@ -15,13 +15,13 @@
 package io.netty.handler.codec.http2;
 
 import org.hamcrest.CoreMatchers;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.ArgumentCaptor;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.junit.Assert.assertNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java
Patch:
@@ -67,7 +67,6 @@
 import static org.hamcrest.Matchers.instanceOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;

File: transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
Patch:
@@ -295,7 +295,7 @@ public void connect(
         if (!outboundCtx.removed) {
             outboundHandler.connect(outboundCtx, remoteAddress, localAddress, promise);
         } else {
-            outboundCtx.connect(localAddress, promise);
+            outboundCtx.connect(remoteAddress, localAddress, promise);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -602,7 +602,7 @@ public static long normalizeAndGetContentLength(
         }
         // Ensure we not allow sign as part of the content-length:
         // See https://github.com/squid-cache/squid/security/advisories/GHSA-qf3v-rc95-96j5
-        if (!Character.isDigit(firstField.charAt(0))) {
+        if (firstField.isEmpty() || !Character.isDigit(firstField.charAt(0))) {
             // Reject the message as invalid
             throw new IllegalArgumentException(
                     "Content-Length value is not a number: " + firstField);

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -64,7 +64,7 @@ public void test1002() throws Throwable {
                 -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
                 -1,   -1
         };
-        testIdentity(data);
+        testIdentity(data, true);
     }
 
     // These tests were found using testRandom() with large RANDOM_RUNS.
@@ -104,7 +104,7 @@ public void testRandom() throws Throwable {
     private void testWithSeed(long seed) {
         byte[] data = new byte[16 * 1048576];
         new Random(seed).nextBytes(data);
-        testIdentity(data);
+        testIdentity(data, true);
     }
 
     private static void printSeedAsTest(long l) {

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -98,7 +98,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
                 final Result<?> decodedVariableHeader = decodeVariableHeader(ctx, buffer, mqttFixedHeader);
                 variableHeader = decodedVariableHeader.value;
                 if (bytesRemainingInVariablePart > maxBytesInMessage) {
-                    buffer.skipBytes(buffer.readableBytes());
+                    buffer.skipBytes(actualReadableBytes());
                     throw new TooLongFrameException("too large message: " + bytesRemainingInVariablePart + " bytes");
                 }
                 bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -142,7 +142,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                     if (isFull) {
                         out.add(ReferenceCountUtil.retain(res));
                     } else {
-                        out.add(res);
+                        out.add(ReferenceCountUtil.retain(res));
                         // Pass through all following contents.
                         state = State.PASS_THROUGH;
                     }
@@ -165,7 +165,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                     if (isFull) {
                         out.add(ReferenceCountUtil.retain(res));
                     } else {
-                        out.add(res);
+                        out.add(ReferenceCountUtil.retain(res));
                         // Pass through all following contents.
                         state = State.PASS_THROUGH;
                     }

File: buffer/src/main/java/io/netty/buffer/search/AbstractMultiSearchProcessorFactory.java
Patch:
@@ -40,7 +40,7 @@
  *      MultiSearchProcessor processor = factory.newSearchProcessor();
  *
  *      int idx1 = haystack.forEachByte(processor);
- *      // idx1 is 1 (index of the last character of the occurence of "AB" in the haystack)
+ *      // idx1 is 1 (index of the last character of the occurrence of "AB" in the haystack)
  *      // processor.getFoundNeedleId() is 0 (index of "AB" in needles[])
  *
  *      int continueFrom1 = idx1 + 1;

File: handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java
Patch:
@@ -195,7 +195,7 @@ public boolean matches(InetSocketAddress remoteAddress) {
             final InetAddress inetAddress = remoteAddress.getAddress();
             if (inetAddress instanceof Inet6Address) {
                 BigInteger ipAddress = ipToInt((Inet6Address) inetAddress);
-                return ipAddress.and(subnetMask).equals(networkAddress);
+                return ipAddress.and(subnetMask).equals(subnetMask) || ipAddress.and(subnetMask).equals(networkAddress);
             }
             return false;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -300,6 +300,8 @@ protected boolean isContentAlwaysEmpty(HttpMessage msg) {
                             }
                         }
                         break;
+                    default:
+                        break;
                 }
             }
             return super.isContentAlwaysEmpty(msg);

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -312,6 +312,8 @@ private void initialize(ChannelHandlerContext ctx) {
         case 1:
         case 2:
             return;
+        default:
+             break;
         }
 
         state = 1;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
Patch:
@@ -65,6 +65,8 @@ public static DnsOpCode valueOf(int b) {
             return NOTIFY;
         case 0x05:
             return UPDATE;
+        default:
+            break;
         }
 
         return new DnsOpCode(b);

File: resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java
Patch:
@@ -20,15 +20,16 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.util.NetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.Comparator;
 import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class DefaultAuthoritativeDnsServerCacheTest {
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java
Patch:
@@ -23,14 +23,14 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.Promise;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.SocketAddress;
 import java.nio.channels.UnsupportedAddressTypeException;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.instanceOf;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class DnsAddressResolverGroupTest {
     @Test

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java
Patch:
@@ -22,8 +22,8 @@
 import io.netty.handler.codec.dns.DnsRecord;
 import io.netty.util.internal.SocketUtils;
 import io.netty.util.concurrent.Future;
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 
 import java.net.InetAddress;
 import java.util.Collections;
@@ -34,7 +34,7 @@ public class DnsNameResolverClientSubnetTest {
 
     // See https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html
     // Ignore as this needs to query real DNS servers.
-    @Ignore
+    @Disabled
     @Test
     public void testSubnetQuery() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup(1);

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java
Patch:
@@ -16,11 +16,11 @@
 package io.netty.resolver.dns;
 
 import io.netty.channel.embedded.EmbeddedChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.UnknownHostException;
 
-import static org.junit.Assert.fail;
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class DnsResolveContextTest {
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java
Patch:
@@ -17,7 +17,7 @@
 package io.netty.resolver.dns;
 
 import io.netty.util.NetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.InetSocketAddress;
 import java.util.Collections;

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastIPv6Test.java
Patch:
@@ -18,15 +18,16 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.util.internal.PlatformDependent;
-import org.junit.Assume;
+
+import static org.junit.jupiter.api.Assumptions.assumeFalse;
 
 public class DatagramMulticastIPv6Test extends DatagramMulticastTest {
 
     @Override
     public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {
         // Not works on windows atm.
         // See https://github.com/netty/netty/issues/11285
-        Assume.assumeFalse(PlatformDependent.isWindows());
+        assumeFalse(PlatformDependent.isWindows());
         super.testMulticast(sb, cb);
     }
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastIPv6Test.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SuppressJava6Requirement;
 import org.junit.Assume;
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
 import java.io.IOException;
 import java.net.StandardProtocolFamily;
@@ -29,7 +29,7 @@
 public class DatagramUnicastIPv6Test extends DatagramUnicastTest {
 
     @SuppressJava6Requirement(reason = "Guarded by java version check")
-    @BeforeClass
+    @BeforeAll
     public static void assumeIpv6Supported() {
         try {
             if (PlatformDependent.javaVersion() < 7) {

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollChannelConfigTest.java
Patch:
@@ -16,9 +16,10 @@
 package io.netty.channel.epoll;
 
 import io.netty.channel.ChannelException;
-import org.junit.Test;
 
-import static org.junit.Assert.fail;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class EpollChannelConfigTest {
 

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDatagramChannelConfigTest.java
Patch:
@@ -15,9 +15,10 @@
  */
 package io.netty.channel.epoll;
 
-import org.junit.Test;
 
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class EpollDatagramChannelConfigTest {
 

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollKQueueIovArrayTest.java
Patch:
@@ -16,12 +16,11 @@
 package io.netty.channel.epoll;
 
 import io.netty.channel.unix.tests.IovArrayTest;
-import org.junit.Assume;
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
 public class EpollKQueueIovArrayTest extends IovArrayTest {
 
-    @BeforeClass
+    @BeforeAll
     public static void loadNative() {
         Epoll.ensureAvailability();
     }

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueEventLoopTest.java
Patch:
@@ -21,12 +21,12 @@
 import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.testsuite.transport.AbstractSingleThreadEventLoopTest;
 import io.netty.util.concurrent.Future;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.concurrent.TimeUnit;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class KQueueEventLoopTest extends AbstractSingleThreadEventLoopTest {
 

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueIovArrayTest.java
Patch:
@@ -16,11 +16,11 @@
 package io.netty.channel.kqueue;
 
 import io.netty.channel.unix.tests.IovArrayTest;
-import org.junit.BeforeClass;
+import org.junit.jupiter.api.BeforeAll;
 
 public class KQueueIovArrayTest extends IovArrayTest {
 
-    @BeforeClass
+    @BeforeAll
     public static void loadNative() {
         KQueue.ensureAvailability();
     }

File: buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.buffer;
 
 import static io.netty.buffer.Unpooled.*;
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import io.netty.util.CharsetUtil;
 import io.netty.util.ResourceLeakTracker;

File: buffer/src/test/java/io/netty/buffer/ByteBufAllocatorTest.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.buffer;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public abstract class ByteBufAllocatorTest {
 

File: buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.netty.buffer;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.nio.ByteOrder;
 import java.util.Random;

File: buffer/src/test/java/io/netty/buffer/ByteProcessorTest.java
Patch:
@@ -16,11 +16,11 @@
 
 package io.netty.buffer;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import io.netty.util.ByteProcessor;
 import io.netty.util.CharsetUtil;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class ByteProcessorTest {
     @Test

File: buffer/src/test/java/io/netty/buffer/ConsolidationTest.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.buffer;
 
 import io.netty.util.CharsetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static io.netty.buffer.Unpooled.*;
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /**
  * Tests buffer consolidation

File: buffer/src/test/java/io/netty/buffer/LittleEndianDirectByteBufTest.java
Patch:
@@ -15,7 +15,8 @@
  */
 package io.netty.buffer;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 import java.nio.ByteOrder;
 

File: buffer/src/test/java/io/netty/buffer/LittleEndianHeapByteBufTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.buffer;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 import java.nio.ByteOrder;
 

File: buffer/src/test/java/io/netty/buffer/LongPriorityQueueTest.java
Patch:
@@ -32,7 +32,7 @@ public void mustThrowWhenAddingNoValue() {
         final LongPriorityQueue pq = new LongPriorityQueue();
         assertThrows(IllegalArgumentException.class, new Executable() {
             @Override
-            public void execute() throws Throwable {
+            public void execute() {
                 pq.offer(LongPriorityQueue.NO_VALUE);
             }
         });

File: buffer/src/test/java/io/netty/buffer/PooledBigEndianDirectByteBufTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteOrder;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 /**
  * Tests big-endian direct channel buffers

File: buffer/src/test/java/io/netty/buffer/PooledLittleEndianDirectByteBufTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteOrder;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 /**
  * Tests little-endian direct channel buffers

File: buffer/src/test/java/io/netty/buffer/PooledLittleEndianHeapByteBufTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteOrder;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 /**
  * Tests little-endian heap channel buffers

File: buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufferBufTest.java
Patch:
@@ -16,11 +16,11 @@
 package io.netty.buffer;
 
 import io.netty.util.internal.PlatformDependent;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.nio.ByteBuffer;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class ReadOnlyByteBufferBufTest extends ReadOnlyDirectByteBufferBufTest {
     @Override

File: buffer/src/test/java/io/netty/buffer/RetainedDuplicatedByteBufTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.netty.buffer;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class RetainedDuplicatedByteBufTest extends DuplicatedByteBufTest {
     @Override

File: buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java
Patch:
@@ -16,16 +16,15 @@
 
 package io.netty.buffer;
 
-
-import org.junit.Assert;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class RetainedSlicedByteBufTest extends SlicedByteBufTest {
 
     @Override
     protected ByteBuf newSlice(ByteBuf buffer, int offset, int length) {
         ByteBuf slice = buffer.retainedSlice(offset, length);
         buffer.release();
-        Assert.assertEquals(buffer.refCnt(), slice.refCnt());
+        assertEquals(buffer.refCnt(), slice.refCnt());
         return slice;
     }
 }

File: buffer/src/test/java/io/netty/buffer/search/MultiSearchProcessorTest.java
Patch:
@@ -18,9 +18,9 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.util.CharsetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class MultiSearchProcessorTest {
 

File: codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpRequestTest.java
Patch:
@@ -16,11 +16,11 @@
 package io.netty.handler.codec.http;
 
 import io.netty.util.AsciiString;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static io.netty.handler.codec.http.HttpHeadersTestUtils.of;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class DefaultHttpRequestTest {
 

File: codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpResponseTest.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec.http;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
 
 public class DefaultHttpResponseTest {
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpServerExpectContinueHandlerTest.java
Patch:
@@ -21,7 +21,8 @@
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class HttpServerExpectContinueHandlerTest {
 

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
Patch:
@@ -27,7 +27,7 @@
 import io.netty.util.AsciiString;
 import io.netty.util.ReferenceCountUtil;
 import org.hamcrest.core.IsEqual;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Arrays;
 import java.util.Collections;

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07Test.java
Patch:
@@ -19,11 +19,11 @@
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.URI;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class WebSocketClientHandshaker07Test extends WebSocketClientHandshakerTest {
 

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionFilterProviderTest.java
Patch:
@@ -15,9 +15,10 @@
  */
 package io.netty.handler.codec.http.websocketx.extensions;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 public class WebSocketExtensionFilterProviderTest {
 

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionFilterTest.java
Patch:
@@ -21,9 +21,10 @@
 import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class WebSocketExtensionFilterTest {
 

File: common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java
Patch:
@@ -119,18 +119,17 @@ private static Class<?> find0(
                 if (actualTypeParam instanceof TypeVariable) {
                     // Resolved type parameter points to another type parameter.
                     TypeVariable<?> v = (TypeVariable<?>) actualTypeParam;
-                    currentClass = thisClass;
                     if (!(v.getGenericDeclaration() instanceof Class)) {
                         return Object.class;
                     }
 
+                    currentClass = thisClass;
                     parametrizedSuperclass = (Class<?>) v.getGenericDeclaration();
                     typeParamName = v.getName();
                     if (parametrizedSuperclass.isAssignableFrom(thisClass)) {
                         continue;
-                    } else {
-                        return Object.class;
                     }
+                    return Object.class;
                 }
 
                 return fail(thisClass, typeParamName);

File: common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java
Patch:
@@ -15,10 +15,9 @@
  */
 package io.netty.util.internal;
 
+import org.junit.jupiter.api.Test;
 
-import org.junit.Test;
-
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class AppendableCharSequenceTest {
 

File: common/src/test/java/io/netty/util/internal/logging/CommonsLoggerFactoryTest.java
Patch:
@@ -15,9 +15,10 @@
  */
 package io.netty.util.internal.logging;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class CommonsLoggerFactoryTest {
 

File: common/src/test/java/io/netty/util/internal/logging/CommonsLoggerTest.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.util.internal.logging;
 
 import org.apache.commons.logging.Log;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.Mockito.*;
 
 public class CommonsLoggerTest {

File: common/src/test/java/io/netty/util/internal/logging/JdkLoggerFactoryTest.java
Patch:
@@ -15,9 +15,10 @@
  */
 package io.netty.util.internal.logging;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class JdkLoggerFactoryTest {
 

File: common/src/test/java/io/netty/util/internal/logging/Log4J2LoggerFactoryTest.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.util.internal.logging;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class Log4J2LoggerFactoryTest {
 

File: common/src/test/java/io/netty/util/internal/logging/Log4JLoggerFactoryTest.java
Patch:
@@ -15,9 +15,10 @@
  */
 package io.netty.util.internal.logging;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class Log4JLoggerFactoryTest {
 

File: common/src/test/java/io/netty/util/internal/logging/MessageFormatterTest.java
Patch:
@@ -38,9 +38,10 @@
  */
 package io.netty.util.internal.logging;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class MessageFormatterTest {
 

File: common/src/test/java/io/netty/util/internal/logging/Slf4JLoggerTest.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.util.internal.logging;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.slf4j.Logger;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.Mockito.*;
 
 public class Slf4JLoggerTest {

File: codec/src/test/java/io/netty/handler/codec/DateFormatterTest.java
Patch:
@@ -15,13 +15,14 @@
  */
 package io.netty.handler.codec;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Calendar;
 import java.util.Date;
 
-import static org.junit.Assert.*;
 import static io.netty.handler.codec.DateFormatter.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class DateFormatterTest {
     /**

File: codec/src/test/java/io/netty/handler/codec/DelimiterBasedFrameDecoderTest.java
Patch:
@@ -20,11 +20,12 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.nio.charset.Charset;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class DelimiterBasedFrameDecoderTest {
 

File: codec/src/test/java/io/netty/handler/codec/ReplayingDecoderByteBufTest.java
Patch:
@@ -19,9 +19,10 @@
 import io.netty.buffer.Unpooled;
 import io.netty.util.CharsetUtil;
 import io.netty.util.Signal;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class ReplayingDecoderByteBufTest {
 

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.EmptyArrays;
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 import java.util.Random;
 
@@ -30,7 +30,7 @@ public class ByteArrayDecoderTest {
 
     private EmbeddedChannel ch;
 
-    @Before
+    @BeforeEach
     public void setUp() {
         ch = new EmbeddedChannel(new ByteArrayDecoder());
     }

File: codec/src/test/java/io/netty/handler/codec/compression/Bzip2EncoderTest.java
Patch:
@@ -24,13 +24,13 @@
 import java.io.InputStream;
 
 import static io.netty.handler.codec.compression.Bzip2Constants.*;
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class Bzip2EncoderTest extends AbstractEncoderTest {
 
     @Override
-    public void initChannel() {
-        channel = new EmbeddedChannel(new Bzip2Encoder(MIN_BLOCK_SIZE));
+    protected EmbeddedChannel createChannel() {
+        return new EmbeddedChannel(new Bzip2Encoder(MIN_BLOCK_SIZE));
     }
 
     @Override

File: codec/src/test/java/io/netty/handler/codec/compression/Bzip2IntegrationTest.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.channel.embedded.EmbeddedChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class Bzip2IntegrationTest extends AbstractIntegrationTest {
 

File: codec/src/test/java/io/netty/handler/codec/compression/FastLzIntegrationTest.java
Patch:
@@ -22,7 +22,8 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class FastLzIntegrationTest extends AbstractIntegrationTest {
 

File: codec/src/test/java/io/netty/handler/codec/compression/LzfEncoderTest.java
Patch:
@@ -23,8 +23,8 @@
 public class LzfEncoderTest extends AbstractEncoderTest {
 
     @Override
-    public void initChannel() {
-        channel = new EmbeddedChannel(new LzfEncoder());
+    protected EmbeddedChannel createChannel() {
+        return new EmbeddedChannel(new LzfEncoder());
     }
 
     @Override

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.channel.embedded.EmbeddedChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Random;
 

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
Patch:
@@ -22,7 +22,8 @@
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.TooLongFrameException;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class RiverMarshallingDecoderTest extends RiverCompatibleMarshallingDecoderTest {
 

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
Patch:
@@ -22,7 +22,8 @@
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.TooLongFrameException;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class SerialMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest {
 

File: codec/src/test/java/io/netty/handler/codec/serialization/CompactObjectSerializationTest.java
Patch:
@@ -19,8 +19,8 @@
 import java.io.PipedOutputStream;
 import java.util.List;
 
-import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
 
 public class CompactObjectSerializationTest {
 
@@ -31,6 +31,6 @@ public void testInterfaceSerialization() throws Exception {
         CompactObjectOutputStream out = new CompactObjectOutputStream(pipeOut);
         CompactObjectInputStream in = new CompactObjectInputStream(pipeIn, ClassResolvers.cacheDisabled(null));
         out.writeObject(List.class);
-        Assert.assertSame(List.class, in.readObject());
+        Assertions.assertSame(List.class, in.readObject());
     }
 }

File: codec/src/test/java/io/netty/handler/codec/serialization/CompatibleObjectEncoderTest.java
Patch:
@@ -18,14 +18,14 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.channel.embedded.EmbeddedChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 
 public class CompatibleObjectEncoderTest {
     @Test

File: transport/src/test/java/io/netty/channel/BaseChannelTest.java
Patch:
@@ -15,15 +15,14 @@
  */
 package io.netty.channel;
 
-
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 class BaseChannelTest {
 

File: transport/src/test/java/io/netty/channel/DefaultChannelIdTest.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -29,7 +29,7 @@
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.CoreMatchers.sameInstance;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 @SuppressWarnings("DynamicRegexReplaceableByCompiledPattern")
 public class DefaultChannelIdTest {

File: transport/src/test/java/io/netty/channel/DelegatingChannelPromiseNotifierTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 
 public class DelegatingChannelPromiseNotifierTest {

File: transport/src/test/java/io/netty/channel/ReentrantChannelTest.java
Patch:
@@ -22,12 +22,13 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import org.hamcrest.Matchers;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.nio.channels.ClosedChannelException;
 
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class ReentrantChannelTest extends BaseChannelTest {
 

File: transport/src/test/java/io/netty/channel/SucceededChannelFutureTest.java
Patch:
@@ -15,10 +15,11 @@
  */
 package io.netty.channel;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class SucceededChannelFutureTest {
     @Test

File: transport/src/test/java/io/netty/channel/group/DefaultChannelGroupTest.java
Patch:
@@ -23,7 +23,7 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.util.concurrent.GlobalEventExecutor;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class DefaultChannelGroupTest {
 

File: transport/src/test/java/io/netty/channel/socket/InternetProtocolFamilyTest.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel.socket;
 
 import io.netty.util.NetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.InetAddress;
 

File: transport/src/test/java/io/netty/channel/socket/nio/NioDatagramChannelTest.java
Patch:
@@ -24,14 +24,14 @@
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.GlobalEventExecutor;
-import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.InetSocketAddress;
 import java.net.SocketOption;
 import java.net.StandardSocketOptions;
 import java.nio.channels.NetworkChannel;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class NioDatagramChannelTest extends AbstractNioChannelTest<NioDatagramChannel> {
 
@@ -58,7 +58,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {
                         .bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
                 channelGroup.add(datagramChannel);
             }
-            Assert.assertEquals(100, channelGroup.size());
+            assertEquals(100, channelGroup.size());
         } finally {
             channelGroup.close().sync();
             group.shutdownGracefully().sync();

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socks;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class SocksAuthRequestTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
Patch:
@@ -18,9 +18,10 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 public class SocksAuthResponseDecoderTest {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksAuthResponseDecoderTest.class);

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socks;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class SocksAuthResponseTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksInitRequestTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socks;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class SocksInitRequestTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksInitResponseTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socks;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class SocksInitResponseTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoderTest.java
Patch:
@@ -16,11 +16,12 @@
 package io.netty.handler.codec.socksx.v4;
 
 import io.netty.channel.embedded.EmbeddedChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class Socks4ClientDecoderTest {
     private static final Logger logger = LoggerFactory.getLogger(Socks4ClientDecoderTest.class);

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandRequestTest.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.handler.codec.socksx.v5;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.*;
 
 public class DefaultSocks5CommandRequestTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5InitialRequestTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socksx.v5;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class DefaultSocks5InitialRequestTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5InitialResponseTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socksx.v5;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class DefaultSocks5InitialResponseTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PasswordAuthRequestTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socksx.v5;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class DefaultSocks5PasswordAuthRequestTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PasswordAuthResponseTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.socksx.v5;
 
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class DefaultSocks5PasswordAuthResponseTest {
     @Test

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoderTest.java
Patch:
@@ -16,9 +16,10 @@
 package io.netty.handler.codec.socksx.v5;
 
 import io.netty.channel.embedded.EmbeddedChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class Socks5PasswordAuthRequestDecoderTest {
 

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoderTest.java
Patch:
@@ -18,9 +18,10 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertSame;
 
 public class Socks5PasswordAuthResponseDecoderTest {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompHeadersTest.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.handler.codec.stomp;
 
 import io.netty.util.AsciiString;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 
 public class StompHeadersTest {
     @Test

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java
Patch:
@@ -18,9 +18,9 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.util.CharsetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class BinaryMemcacheMessageTest {
 

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -21,14 +21,14 @@
 import io.netty.handler.codec.memcache.DefaultLastMemcacheContent;
 import io.netty.handler.codec.memcache.DefaultMemcacheContent;
 import io.netty.util.CharsetUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.*;
 import static org.hamcrest.core.IsNull.notNullValue;
 import static org.hamcrest.core.IsNull.nullValue;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 /**
  * Verifies the correct functionality of the {@link BinaryMemcacheObjectAggregator}.

File: codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java
Patch:
@@ -21,11 +21,11 @@
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SocketUtils;
 import io.netty.util.internal.StringUtil;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.net.InetAddress;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class DefaultDnsRecordEncoderTest {
 

File: codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java
Patch:
@@ -27,13 +27,14 @@
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class HAProxyIntegrationTest {
 

File: codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxySSLTLVTest.java
Patch:
@@ -17,11 +17,12 @@
 package io.netty.handler.codec.haproxy;
 
 import io.netty.buffer.Unpooled;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Collections;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class HAProxySSLTLVTest {
 

File: common/src/main/java/io/netty/util/internal/MathUtil.java
Patch:
@@ -57,11 +57,11 @@ public static int safeFindNextPositivePowerOfTwo(final int value) {
      * @param index The starting index.
      * @param length The length which will be utilized (starting from {@code index}).
      * @param capacity The capacity that {@code index + length} is allowed to be within.
-     * @return {@code true} if the requested {@code index} and {@code length} will fit within {@code capacity}.
-     * {@code false} if this would result in an index out of bounds exception.
+     * @return {@code false} if the requested {@code index} and {@code length} will fit within {@code capacity}.
+     * {@code true} if this would result in an index out of bounds exception.
      */
     public static boolean isOutOfBounds(int index, int length, int capacity) {
-        return (index | length | (index + length) | (capacity - (index + length))) < 0;
+        return (index | length | capacity | (index + length) | (capacity - (index + length))) < 0;
     }
 
     /**

File: common/src/test/java/io/netty/util/internal/MathUtilTest.java
Patch:
@@ -68,6 +68,9 @@ public void testIsOutOfBounds() {
         assertTrue(isOutOfBounds(Integer.MAX_VALUE - 1, 1, Integer.MAX_VALUE - 1));
         assertTrue(isOutOfBounds(Integer.MAX_VALUE - 1, 2, Integer.MAX_VALUE));
         assertTrue(isOutOfBounds(1, Integer.MAX_VALUE, Integer.MAX_VALUE));
+        assertTrue(isOutOfBounds(0, 1, Integer.MIN_VALUE));
+        assertTrue(isOutOfBounds(0, 1, -1));
+        assertTrue(isOutOfBounds(0, Integer.MAX_VALUE, 0));
     }
 
     @Test

File: resolver-dns-native-macos/src/main/java/io/netty/resolver/dns/macos/MacOSDnsServerAddressStreamProvider.java
Patch:
@@ -82,7 +82,7 @@ public int compare(DnsResolver r1, DnsResolver r2) {
     }
 
     private static void loadNativeLibrary() {
-        if (PlatformDependent.isOsx()) {
+        if (!PlatformDependent.isOsx()) {
             throw new IllegalStateException("Only supported on MacOS/OSX");
         }
         String staticLibName = "netty_resolver_dns_native_macos";

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsCodecUtil.java
Patch:
@@ -120,7 +120,7 @@ static String decodeDomainName(ByteBuf in) {
 
     /**
      * Decompress pointer data.
-     * @param compression comporession data
+     * @param compression compressed data
      * @return decompressed data
      */
     static ByteBuf decompressDomainName(ByteBuf compression) {

File: common/src/main/java/io/netty/util/internal/Hidden.java
Patch:
@@ -128,7 +128,7 @@ public void applyTo(BlockHound.Builder builder) {
                     "parseEtcResolverOptions");
 
             builder.allowBlockingCallsInside(
-                    "io.netty.resolver.HostsFileParser",
+                    "io.netty.resolver.HostsFileEntriesProvider$ParserImpl",
                     "parse");
 
             builder.nonBlockingThreadPredicate(new Function<Predicate<Thread>, Predicate<Thread>>() {

File: resolver/src/main/java/io/netty/resolver/HostsFileEntries.java
Patch:
@@ -22,7 +22,9 @@
 import java.util.Map;
 
 /**
- * A container of hosts file entries
+ * A container of hosts file entries.
+ * The mappings contain only the first entry per hostname.
+ * Consider using {@link HostsFileEntriesProvider} when mappings with all entries per hostname are needed.
  */
 public final class HostsFileEntries {
 

File: handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
Patch:
@@ -332,6 +332,9 @@ static String[] newSelfSignedCertificate(
             wrappedBuf.release();
         }
 
+        // Change all asterisk to 'x' for file name safety.
+        fqdn = fqdn.replaceAll("[^\\w.-]", "x");
+
         File keyFile = PlatformDependent.createTempFile("keyutil_" + fqdn + '_', ".key", null);
         keyFile.deleteOnExit();
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -84,8 +84,9 @@ public abstract class ReferenceCountedOpenSslContext extends SslContext implemen
     private static final int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE = Math.max(1,
             SystemPropertyUtil.getInt("io.netty.handler.ssl.openssl.bioNonApplicationBufferSize",
                     2048));
+    // Let's use tasks by default but still allow the user to disable it via system property just in case.
     static final boolean USE_TASKS =
-            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", false);
+            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", true);
     private static final Integer DH_KEY_LENGTH;
     private static final ResourceLeakDetector<ReferenceCountedOpenSslContext> leakDetector =
             ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ReferenceCountedOpenSslContext.class);

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttVersion.java
Patch:
@@ -59,6 +59,8 @@ public static MqttVersion fromProtocolNameAndLevel(String protocolName, byte pro
         case 5:
             mv = MQTT_5;
             break;
+        default:
+            break;
         }
         if (mv == null) {
             throw new MqttUnacceptableProtocolVersionException(protocolName + "is unknown protocol name");

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java
Patch:
@@ -951,7 +951,8 @@ private void tryToFinishResolve(final DnsServerAddressStream nameServerAddrStrea
             // If cause != null we know this was caused by a timeout / cancel / transport exception. In this case we
             // won't try to resolve the CNAME as we only should do this if we could not get the expected records
             // because they do not exist and the DNS server did probably signal it.
-            if (cause == null && !triedCNAME) {
+            if (cause == null && !triedCNAME &&
+                    (question.type() == DnsRecordType.A || question.type() == DnsRecordType.AAAA)) {
                 // As the last resort, try to query CNAME, just in case the name server has it.
                 triedCNAME = true;
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java
Patch:
@@ -31,6 +31,7 @@
 import static io.netty.handler.codec.mqtt.MqttCodecUtil.getMqttVersion;
 import static io.netty.handler.codec.mqtt.MqttCodecUtil.isValidClientId;
 import static io.netty.handler.codec.mqtt.MqttCodecUtil.setMqttVersion;
+import static io.netty.handler.codec.mqtt.MqttConstant.DEFAULT_MAX_CLIENT_ID_LENGTH;
 
 /**
  * Encodes Mqtt messages into bytes following the protocol specification v3.1
@@ -124,7 +125,7 @@ private static ByteBuf encodeConnectMessage(
 
         // Client id
         String clientIdentifier = payload.clientIdentifier();
-        if (!isValidClientId(mqttVersion, clientIdentifier)) {
+        if (!isValidClientId(mqttVersion, DEFAULT_MAX_CLIENT_ID_LENGTH, clientIdentifier)) {
             throw new MqttIdentifierRejectedException("invalid clientIdentifier: " + clientIdentifier);
         }
         int clientIdentifierBytes = utf8Bytes(clientIdentifier);

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -526,6 +526,7 @@ public void testSetSupportedCiphers() throws Exception {
     @Test(expected = SSLHandshakeException.class)
     public void testIncompatibleCiphers() throws Exception {
         assumeTrue(SslProvider.isTlsv13Supported(sslClientProvider()));
+        assumeTrue(SslProvider.isTlsv13Supported(sslServerProvider()));
 
         SelfSignedCertificate ssc = new SelfSignedCertificate();
         // Select a mandatory cipher from the TLSv1.2 RFC https://www.ietf.org/rfc/rfc5246.txt so handshakes won't fail

File: handler/src/test/java/io/netty/handler/ssl/SslContextBuilderTest.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.util.CharsetUtil;
+import org.junit.Assert;
 import org.junit.Assume;
 import org.junit.Test;
 
@@ -102,6 +103,7 @@ public void testContextFromManagersJdk() throws Exception {
     @Test
     public void testContextFromManagersOpenssl() throws Exception {
         Assume.assumeTrue(OpenSsl.isAvailable());
+        Assume.assumeTrue(OpenSsl.useKeyManagerFactory());
         testContextFromManagers(SslProvider.OPENSSL);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.compression.CompressionException;
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
+import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;
 
 class SpdyHeaderBlockJZlibEncoder extends SpdyHeaderBlockRawEncoder {
 
@@ -122,9 +123,8 @@ private ByteBuf encode(ByteBufAllocator alloc) {
 
     @Override
     public ByteBuf encode(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Exception {
-        if (frame == null) {
-            throw new IllegalArgumentException("frame");
-        }
+        checkNotNullWithIAE(alloc, "alloc");
+        checkNotNullWithIAE(frame, "frame");
 
         if (finished) {
             return Unpooled.EMPTY_BUFFER;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibEncoder.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.zip.Deflater;
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
+import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;
 
 class SpdyHeaderBlockZlibEncoder extends SpdyHeaderBlockRawEncoder {
 
@@ -89,9 +90,8 @@ private boolean compressInto(ByteBuf compressed) {
 
     @Override
     public ByteBuf encode(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Exception {
-        if (frame == null) {
-            throw new IllegalArgumentException("frame");
-        }
+        checkNotNullWithIAE(alloc, "alloc");
+        checkNotNullWithIAE(frame, "frame");
 
         if (finished) {
             return Unpooled.EMPTY_BUFFER;

File: buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+
 import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.StringUtil;
@@ -108,7 +110,7 @@ public ByteBufInputStream(ByteBuf buffer, int length, boolean releaseOnClose) {
             if (releaseOnClose) {
                 buffer.release();
             }
-            throw new IllegalArgumentException("length: " + length);
+            checkPositiveOrZero(length, "length");
         }
         if (length > buffer.readableBytes()) {
             if (releaseOnClose) {

File: transport-udt/src/test/java/io/netty/test/udt/util/TrafficControl.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.netty.test.udt.util;
 
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -62,9 +64,7 @@ public static boolean isAvailable() {
      * @param time - delay in milliseconds; use zero to remove delay.
      */
     public static void delay(final int time) throws Exception {
-        if (time < 0) {
-            throw new IllegalArgumentException("negative latency");
-        }
+        checkPositiveOrZero(time, "time");
         final int delay = time / 2;
         if (delay == 0) {
             UnitHelp.process(String.format(TC_RESET, "lo"));

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -321,10 +321,10 @@ public ChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
      * is of type {@link MaxMessagesRecvByteBufAllocator}.
      */
     private void setRecvByteBufAllocator(RecvByteBufAllocator allocator, ChannelMetadata metadata) {
+        checkNotNull(allocator, "allocator");
+        checkNotNull(metadata, "metadata");
         if (allocator instanceof MaxMessagesRecvByteBufAllocator) {
             ((MaxMessagesRecvByteBufAllocator) allocator).maxMessagesPerRead(metadata.defaultMaxMessagesPerRead());
-        } else if (allocator == null) {
-            throw new NullPointerException("allocator");
         }
         setRecvByteBufAllocator(allocator);
     }

File: handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolConfig.java
Patch:
@@ -22,6 +22,7 @@
 
 import static io.netty.handler.ssl.ApplicationProtocolUtil.toList;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkNonEmpty;
 
 /**
  * Provides an {@link SSLEngine} agnostic way to configure a {@link ApplicationProtocolNegotiator}.
@@ -80,9 +81,7 @@ private ApplicationProtocolConfig(
         if (protocol == Protocol.NONE) {
             throw new IllegalArgumentException("protocol (" + Protocol.NONE + ") must not be " + Protocol.NONE + '.');
         }
-        if (supportedProtocols.isEmpty()) {
-            throw new IllegalArgumentException("supportedProtocols must be not empty");
-        }
+        checkNonEmpty(supportedProtocols, "supportedProtocols");
     }
 
     /**

File: handler/src/main/java/io/netty/handler/ssl/OpenSslX509KeyManagerFactory.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import static io.netty.util.internal.ObjectUtil.checkNonEmpty;
+
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.internal.tcnative.SSL;
@@ -204,9 +206,7 @@ private static final class OpenSslPopulatedKeyMaterialProvider extends OpenSslKe
                             destroy();
                         }
                     }
-                    if (materialMap.isEmpty()) {
-                        throw new IllegalArgumentException("aliases must be non-empty");
-                    }
+                    checkNonEmpty(materialMap, "materialMap");
                 }
 
                 @Override

File: handler/src/main/java/io/netty/handler/ssl/PemX509Certificate.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import static io.netty.util.internal.ObjectUtil.checkNonEmpty;
+
 import java.math.BigInteger;
 import java.security.Principal;
 import java.security.PublicKey;
@@ -55,9 +57,7 @@ public final class PemX509Certificate extends X509Certificate implements PemEnco
     static PemEncoded toPEM(ByteBufAllocator allocator, boolean useDirect,
             X509Certificate... chain) throws CertificateEncodingException {
 
-        if (chain == null || chain.length == 0) {
-            throw new IllegalArgumentException("X.509 certificate chain can't be null or empty");
-        }
+        checkNonEmpty(chain, "chain");
 
         // We can take a shortcut if there is only one certificate and
         // it already happens to be a PemEncoded instance. This is the

File: handler/src/main/java/io/netty/handler/ssl/PseudoRandomFunction.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+
 import io.netty.util.internal.EmptyArrays;
 
 import javax.crypto.Mac;
@@ -59,9 +61,7 @@ private PseudoRandomFunction() {
      * @throws IllegalArgumentException if the algo could not be found.
      */
     static byte[] hash(byte[] secret, byte[] label, byte[] seed, int length, String algo) {
-        if (length < 0) {
-            throw new IllegalArgumentException("You must provide a length greater than zero.");
-        }
+        checkPositiveOrZero(length, "length");
         try {
             Mac hmac = Mac.getInstance(algo);
             hmac.init(new SecretKeySpec(secret, algo));

File: handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.traffic;
 
+import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;
+
 import io.netty.handler.traffic.GlobalChannelTrafficShapingHandler.PerChannel;
 
 import java.util.concurrent.ScheduledExecutorService;
@@ -36,9 +38,7 @@ public class GlobalChannelTrafficCounter extends TrafficCounter {
     public GlobalChannelTrafficCounter(GlobalChannelTrafficShapingHandler trafficShapingHandler,
             ScheduledExecutorService executor, String name, long checkInterval) {
         super(trafficShapingHandler, executor, name, checkInterval);
-        if (executor == null) {
-            throw new IllegalArgumentException("Executor must not be null");
-        }
+        checkNotNullWithIAE(executor, "executor");
     }
 
     /**

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1660,6 +1660,9 @@ public ByteBuffer nioBuffer(int index, int length) {
             if (buf.nioBufferCount() == 1) {
                 return buf.nioBuffer(c.idx(index), length);
             }
+            break;
+        default:
+            break;
         }
 
         ByteBuffer[] buffers = nioBuffers(index, length);

File: common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.netty.util.concurrent;
 
+import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
+
 public class DefaultProgressivePromise<V> extends DefaultPromise<V> implements ProgressivePromise<V> {
 
     /**
@@ -37,9 +39,7 @@ public ProgressivePromise<V> setProgress(long progress, long total) {
         if (total < 0) {
             // total unknown
             total = -1; // normalize
-            if (progress < 0) {
-                throw new IllegalArgumentException("progress: " + progress + " (expected: >= 0)");
-            }
+            checkPositiveOrZero(progress, "progress");
         } else if (progress < 0 || progress > total) {
             throw new IllegalArgumentException(
                     "progress: " + progress + " (expected: 0 <= progress <= total (" + total + "))");

File: common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.util.concurrent;
 
+import static io.netty.util.internal.ObjectUtil.checkPositive;
+
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -68,9 +70,7 @@ protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object.
      */
     protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                             EventExecutorChooserFactory chooserFactory, Object... args) {
-        if (nThreads <= 0) {
-            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
-        }
+        checkPositive(nThreads, "nThreads");
 
         if (executor == null) {
             executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());

File: common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
+import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;
 
 /**
  * {@link GenericFutureListener} implementation which takes other {@link Promise}s
@@ -54,9 +55,7 @@ public PromiseNotifier(Promise<? super V>... promises) {
     public PromiseNotifier(boolean logNotifyFailure, Promise<? super V>... promises) {
         checkNotNull(promises, "promises");
         for (Promise<? super V> promise: promises) {
-            if (promise == null) {
-                throw new IllegalArgumentException("promises contains null Promise");
-            }
+            checkNotNullWithIAE(promise, "promise");
         }
         this.promises = promises.clone();
         this.logNotifyFailure = logNotifyFailure;

File: common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java
Patch:
@@ -97,8 +97,7 @@ public DefaultThreadFactory(String poolName, boolean daemon, int priority, Threa
     }
 
     public DefaultThreadFactory(String poolName, boolean daemon, int priority) {
-        this(poolName, daemon, priority, System.getSecurityManager() == null ?
-                Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());
+        this(poolName, daemon, priority, null);
     }
 
     @Override

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java
Patch:
@@ -472,7 +472,6 @@ public Integer answer(InvocationOnMock in) throws Throwable {
         } catch (RuntimeException cause) {
             verify(localFlow)
                     .receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));
-            verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));
             verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(padding), eq(true));
             assertEquals(0, localFlow.unconsumedBytes(stream));
         } finally {

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -52,7 +52,7 @@ void init(PoolChunk<T> chunk, ByteBuffer nioBuffer,
     }
 
     void initUnpooled(PoolChunk<T> chunk, int length) {
-        init0(chunk, null, 0, chunk.offset, length, length, null);
+        init0(chunk, null, 0, 0, length, length, null);
     }
 
     private void init0(PoolChunk<T> chunk, ByteBuffer nioBuffer,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -461,8 +461,8 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
             return;
         }
         promise = promise.unvoid();
-        // Avoid NotYetConnectedException
-        if (!ctx.channel().isActive()) {
+        // Avoid NotYetConnectedException and avoid sending before connection preface
+        if (!ctx.channel().isActive() || !prefaceSent()) {
             ctx.close(promise);
             return;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -193,7 +193,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                     res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
                     res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
 
-                    out.add(res);
+                    out.add(ReferenceCountUtil.retain(res));
                     state = State.AWAIT_CONTENT;
                     if (!(msg instanceof HttpContent)) {
                         // only break out the switch statement if we have not content to process

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -835,7 +835,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
             }
         });
 
-        serverChannel = sb.bind(new InetSocketAddress(8443)).sync().channel();
+        serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();
         int port = ((InetSocketAddress) serverChannel.localAddress()).getPort();
 
         ChannelFuture ccf = cb.connect(new InetSocketAddress(NetUtil.LOCALHOST, port));

File: common/src/main/java/io/netty/util/internal/Hidden.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.function.Predicate;
 
 /**
- * Contains classes that must be have public visibility but are not public API.
+ * Contains classes that must have public visibility but are not public API.
  */
 class Hidden {
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -33,6 +33,7 @@
 import java.util.concurrent.Executor;
 
 import static io.netty.channel.epoll.LinuxSocket.newSocketStream;
+import static io.netty.channel.epoll.Native.IS_SUPPORTING_TCP_FASTOPEN_CLIENT;
 
 /**
  * {@link SocketChannel} implementation that uses linux EPOLL Edge-Triggered Mode for
@@ -116,7 +117,7 @@ protected AbstractEpollUnsafe newUnsafe() {
 
     @Override
     boolean doConnect0(SocketAddress remote) throws Exception {
-        if (Native.IS_SUPPORTING_TCP_FASTOPEN && config.isTcpFastOpenConnect()) {
+        if (IS_SUPPORTING_TCP_FASTOPEN_CLIENT && config.isTcpFastOpenConnect()) {
             ChannelOutboundBuffer outbound = unsafe().outboundBuffer();
             outbound.addFlush();
             Object curr;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/NativeStaticallyReferencedJniMethods.java
Patch:
@@ -41,6 +41,6 @@ private NativeStaticallyReferencedJniMethods() { }
     static native int uioMaxIov();
     static native boolean isSupportingSendmmsg();
     static native boolean isSupportingRecvmmsg();
-    static native boolean isSupportingTcpFastopen();
+    static native int tcpFastopenMode();
     static native String kernelVersion();
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -404,8 +404,8 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers
                             stream.setProperty(contentLengthKey, new ContentLength(cLength));
                         }
                     } catch (IllegalArgumentException e) {
-                        throw streamError(stream.id(), PROTOCOL_ERROR,
-                                "Multiple content-length headers received", e);
+                        throw streamError(stream.id(), PROTOCOL_ERROR, e,
+                                "Multiple content-length headers received");
                     }
                 }
             }

File: common/src/main/java/io/netty/util/concurrent/PromiseTask.java
Patch:
@@ -90,7 +90,7 @@ public final boolean equals(Object obj) {
     }
 
     @SuppressWarnings("unchecked")
-    final V runTask() throws Exception {
+    V runTask() throws Throwable {
         final Object task = this.task;
         if (task instanceof Callable) {
             return ((Callable<V>) task).call();

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -905,7 +905,7 @@ private static int findNonWhitespace(AppendableCharSequence sb, int offset, bool
             } else if (validateOWS && !isOWS(c)) {
                 // Only OWS is supported for whitespace
                 throw new IllegalArgumentException("Invalid separator, only a single space or horizontal tab allowed," +
-                        " but received a '" + c + "'");
+                        " but received a '" + c + "' (0x" + Integer.toHexString(c) + ")");
             }
         }
         return sb.length();

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -188,13 +188,14 @@ public OpenSslClientContext(File trustCertCollectionFile, TrustManagerFactory tr
                                 long sessionCacheSize, long sessionTimeout, boolean enableOcsp, String keyStore,
                          Map.Entry<SslContextOption<?>, Object>... options)
             throws SSLException {
-        super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, keyCertChain,
+        super(ciphers, cipherFilter, apn, SSL.SSL_MODE_CLIENT, keyCertChain,
                 ClientAuth.NONE, protocols, false, enableOcsp, options);
         boolean success = false;
         try {
             OpenSslKeyMaterialProvider.validateKeyMaterialSupported(keyCertChain, key, keyPassword);
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,
-                                               keyCertChain, key, keyPassword, keyManagerFactory, keyStore);
+                                               keyCertChain, key, keyPassword, keyManagerFactory, keyStore,
+                                               sessionCacheSize, sessionTimeout);
             success = true;
         } finally {
             if (!success) {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
Patch:
@@ -346,15 +346,16 @@ private OpenSslServerContext(
             long sessionCacheSize, long sessionTimeout, ClientAuth clientAuth, String[] protocols, boolean startTls,
             boolean enableOcsp, String keyStore, Map.Entry<SslContextOption<?>, Object>... options)
             throws SSLException {
-        super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_SERVER, keyCertChain,
+        super(ciphers, cipherFilter, apn, SSL.SSL_MODE_SERVER, keyCertChain,
                 clientAuth, protocols, startTls, enableOcsp, options);
 
         // Create a new SSL_CTX and configure it.
         boolean success = false;
         try {
             OpenSslKeyMaterialProvider.validateKeyMaterialSupported(keyCertChain, key, keyPassword);
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,
-                                               keyCertChain, key, keyPassword, keyManagerFactory, keyStore);
+                                               keyCertChain, key, keyPassword, keyManagerFactory, keyStore,
+                                               sessionCacheSize, sessionTimeout);
             success = true;
         } finally {
             if (!success) {

File: handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java
Patch:
@@ -167,6 +167,8 @@ protected SSLEngine wrapEngine(SSLEngine engine) {
     protected SslContext wrapContext(SslContext context) {
         if (context instanceof OpenSslContext) {
             ((OpenSslContext) context).setUseTasks(useTasks);
+            // Explicit enable the session cache as its disabled by default on the client side.
+            ((OpenSslContext) context).sessionContext().setSessionCacheEnabled(true);
         }
         return context;
     }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslJdkSslEngineInteroptTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.ssl;
 
-import io.netty.util.internal.PlatformDependent;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -153,6 +152,8 @@ protected SSLEngine wrapEngine(SSLEngine engine) {
     protected SslContext wrapContext(SslContext context) {
         if (context instanceof OpenSslContext) {
             ((OpenSslContext) context).setUseTasks(useTasks);
+            // Explicit enable the session cache as its disabled by default on the client side.
+            ((OpenSslContext) context).sessionContext().setSessionCacheEnabled(true);
         }
         return context;
     }

File: handler/src/test/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngineTest.java
Patch:
@@ -78,6 +78,8 @@ public void testNotLeakOnException() throws Exception {
     protected SslContext wrapContext(SslContext context) {
         if (context instanceof ReferenceCountedOpenSslContext) {
             ((ReferenceCountedOpenSslContext) context).setUseTasks(useTasks);
+            // Explicit enable the session cache as its disabled by default on the client side.
+            ((ReferenceCountedOpenSslContext) context).sessionContext().setSessionCacheEnabled(true);
         }
         return context;
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
Patch:
@@ -106,6 +106,9 @@ public void addContent(ByteBuf buffer, boolean last)
             size += localsize;
             if (byteBuf == null) {
                 byteBuf = buffer;
+            } else if (localsize == 0) {
+                // Nothing to add and byteBuf already exists
+                buffer.release();
             } else if (byteBuf instanceof CompositeByteBuf) {
                 CompositeByteBuf cbb = (CompositeByteBuf) byteBuf;
                 cbb.addComponent(true, buffer);

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
Patch:
@@ -270,9 +270,6 @@ public String getValue() throws IOException {
 
     @Override
     public void setValue(String value) throws IOException {
-        if (value != null) {
-            checkSize(value.getBytes().length);
-        }
         attribute.setValue(value);
     }
 

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -152,7 +152,7 @@ boolean allocateSmall(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity,
     }
 
     /**
-     * Try to allocate a small buffer out of the cache. Returns {@code true} if successful {@code false} otherwise
+     * Try to allocate a normal buffer out of the cache. Returns {@code true} if successful {@code false} otherwise
      */
     boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int sizeIdx) {
         return allocate(cacheForNormal(area, sizeIdx), buf, reqCapacity);

File: common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
Patch:
@@ -171,7 +171,7 @@ protected static void safeExecute(Runnable task) {
      * Like {@link #execute(Runnable)} but does not guarantee the task will be run until either
      * a non-lazy task is executed or the executor is shut down.
      *
-     * This is equivalent to submitting a {@link EventExecutor.LazyRunnable} to
+     * This is equivalent to submitting a {@link AbstractEventExecutor.LazyRunnable} to
      * {@link #execute(Runnable)} but for an arbitrary {@link Runnable}.
      *
      * The default implementation just delegates to {@link #execute(Runnable)}.

File: resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java
Patch:
@@ -86,7 +86,7 @@ static DnsServerAddressStreamProvider parseSilently() {
      * the default DNS server to use, and also overrides for individual domains. Also parse list of files of the format
      * <a href="
      * https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html">
-     * /etc/resolver</a> which may contain multiple files to override the name servers used for multimple domains.
+     * /etc/resolver</a> which may contain multiple files to override the name servers used for multiple domains.
      * @param etcResolvConf <a href="https://linux.die.net/man/5/resolver">/etc/resolv.conf</a>.
      * @param etcResolverFiles List of files of the format defined in
      * <a href="
@@ -121,7 +121,7 @@ public UnixResolverDnsServerAddressStreamProvider(File etcResolvConf, File... et
      * the default DNS server to use, and also overrides for individual domains. Also parse a directory of the format
      * <a href="
      * https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html">
-     * /etc/resolver</a> which may contain multiple files to override the name servers used for multimple domains.
+     * /etc/resolver</a> which may contain multiple files to override the name servers used for multiple domains.
      * @param etcResolvConf <a href="https://linux.die.net/man/5/resolver">/etc/resolv.conf</a>.
      * @param etcResolverDir Directory containing files of the format defined in
      * <a href="
@@ -379,7 +379,7 @@ static List<String> parseEtcResolverSearchDomains(File etcResolvConf) throws IOE
                 } else if (line.startsWith(SEARCH_ROW_LABEL)) {
                     int i = indexOfNonWhiteSpace(line, SEARCH_ROW_LABEL.length());
                     if (i >= 0) {
-                        // May contain more then one entry, either seperated by whitespace or tab.
+                        // May contain more then one entry, either separated by whitespace or tab.
                         // See https://linux.die.net/man/5/resolver
                         String[] domains = WHITESPACE_PATTERN.split(line.substring(i));
                         Collections.addAll(searchDomains, domains);

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -4551,7 +4551,7 @@ private void testGetReadOnlyDst(boolean direct) {
 
     @Test
     public void testReadBytesAndWriteBytesWithFileChannel() throws IOException {
-        File file = File.createTempFile("file-channel", ".tmp");
+        File file = PlatformDependent.createTempFile("file-channel", ".tmp", null);
         RandomAccessFile randomAccessFile = null;
         try {
             randomAccessFile = new RandomAccessFile(file, "rw");
@@ -4594,7 +4594,7 @@ public void testReadBytesAndWriteBytesWithFileChannel() throws IOException {
 
     @Test
     public void testGetBytesAndSetBytesWithFileChannel() throws IOException {
-        File file = File.createTempFile("file-channel", ".tmp");
+        File file = PlatformDependent.createTempFile("file-channel", ".tmp", null);
         RandomAccessFile randomAccessFile = null;
         try {
             randomAccessFile = new RandomAccessFile(file, "rw");

File: buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java
Patch:
@@ -306,7 +306,7 @@ public void testWrapBufferRoundTrip() {
 
     @Test
     public void testWrapMemoryMapped() throws Exception {
-        File file = File.createTempFile("netty-test", "tmp");
+        File file = PlatformDependent.createTempFile("netty-test", "tmp", null);
         FileChannel output = null;
         FileChannel input = null;
         ByteBuf b1 = null;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.handler.codec.http.HttpConstants;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -88,9 +89,9 @@ private File tempFile() throws IOException {
         File tmpFile;
         if (getBaseDirectory() == null) {
             // create a temporary file
-            tmpFile = File.createTempFile(getPrefix(), newpostfix);
+            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, null);
         } else {
-            tmpFile = File.createTempFile(getPrefix(), newpostfix, new File(
+            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, new File(
                     getBaseDirectory()));
         }
         if (deleteOnExit()) {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.handler.stream.ChunkedNioStream;
 import io.netty.handler.stream.ChunkedStream;
 import io.netty.handler.stream.ChunkedWriteHandler;
+import io.netty.util.internal.PlatformDependent;
 import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
@@ -46,7 +47,7 @@ public class HttpChunkedInputTest {
 
         FileOutputStream out = null;
         try {
-            TMP = File.createTempFile("netty-chunk-", ".tmp");
+            TMP = PlatformDependent.createTempFile("netty-chunk-", ".tmp", null);
             TMP.deleteOnExit();
             out = new FileOutputStream(TMP);
             out.write(BYTES);

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpDataTest.java
Patch:
@@ -39,7 +39,7 @@ public class AbstractDiskHttpDataTest {
     public void testGetChunk() throws Exception {
         TestHttpData test = new TestHttpData("test", UTF_8, 0);
         try {
-            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), ".tmp");
+            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), ".tmp", null);
             tmpFile.deleteOnExit();
             FileOutputStream fos = new FileOutputStream(tmpFile);
             byte[] bytes = new byte[4096];

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
Patch:
@@ -43,7 +43,7 @@ public class AbstractMemoryHttpDataTest {
     public void testSetContentFromFile() throws Exception {
         TestHttpData test = new TestHttpData("test", UTF_8, 0);
         try {
-            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), ".tmp");
+            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), ".tmp", null);
             tmpFile.deleteOnExit();
             FileOutputStream fos = new FileOutputStream(tmpFile);
             byte[] bytes = new byte[4096];
@@ -70,7 +70,7 @@ public void testSetContentFromFile() throws Exception {
     public void testRenameTo() throws Exception {
         TestHttpData test = new TestHttpData("test", UTF_8, 0);
         try {
-            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), ".tmp");
+            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), ".tmp", null);
             tmpFile.deleteOnExit();
             final int totalByteCount = 4096;
             byte[] bytes = new byte[totalByteCount];

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/DiskFileUploadTest.java
Patch:
@@ -273,7 +273,7 @@ public void setSetContentFromFileExceptionally() throws Exception {
             assertEquals(maxSize, f1.length());
             byte[] bytes = new byte[8];
             PlatformDependent.threadLocalRandom().nextBytes(bytes);
-            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), ".tmp");
+            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), ".tmp", null);
             tmpFile.deleteOnExit();
             FileOutputStream fos = new FileOutputStream(tmpFile);
             try {

File: common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
Patch:
@@ -177,7 +177,7 @@ public static void load(String originalName, ClassLoader loader) {
             String prefix = libname.substring(0, index);
             String suffix = libname.substring(index);
 
-            tmpFile = File.createTempFile(prefix, suffix, WORKDIR);
+            tmpFile = PlatformDependent.createTempFile(prefix, suffix, WORKDIR);
             in = url.openStream();
             out = new FileOutputStream(tmpFile);
 

File: handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.PlatformDependent;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -55,7 +56,7 @@ public class ChunkedWriteHandlerTest {
 
         FileOutputStream out = null;
         try {
-            TMP = File.createTempFile("netty-chunk-", ".tmp");
+            TMP = PlatformDependent.createTempFile("netty-chunk-", ".tmp", null);
             TMP.deleteOnExit();
             out = new FileOutputStream(TMP);
             out.write(BYTES);

File: handler/src/test/java/io/netty/handler/traffic/FileRegionThrottleTest.java
Patch:
@@ -32,6 +32,7 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.PlatformDependent;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
@@ -61,7 +62,7 @@ public static void beforeClass() throws IOException {
             BYTES[i] = (byte) r.nextInt(255);
         }
 
-        tmp = File.createTempFile("netty-traffic", ".tmp");
+        tmp = PlatformDependent.createTempFile("netty-traffic", ".tmp", null);
         tmp.deleteOnExit();
         FileOutputStream out = null;
         try {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
Patch:
@@ -102,7 +102,7 @@ public void testFileRegionVoidPromiseNotAutoRead(ServerBootstrap sb, Bootstrap c
     }
 
     public void testFileRegionCountLargerThenFile(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        File file = File.createTempFile("netty-", ".tmp");
+        File file = PlatformDependent.createTempFile("netty-", ".tmp", null);
         file.deleteOnExit();
 
         final FileOutputStream out = new FileOutputStream(file);
@@ -136,7 +136,7 @@ private static void testFileRegion0(
         cb.option(ChannelOption.AUTO_READ, autoRead);
 
         final int bufferSize = 1024;
-        final File file = File.createTempFile("netty-", ".tmp");
+        final File file = PlatformDependent.createTempFile("netty-", ".tmp", null);
         file.deleteOnExit();
 
         final FileOutputStream out = new FileOutputStream(file);

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSpliceTest.java
Patch:
@@ -28,6 +28,7 @@
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.unix.FileDescriptor;
 import io.netty.util.NetUtil;
+import io.netty.util.internal.PlatformDependent;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -192,7 +193,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     @Test(timeout = 10000)
     public void spliceToFile() throws Throwable {
         EventLoopGroup group = new EpollEventLoopGroup(1);
-        File file = File.createTempFile("netty-splice", null);
+        File file = PlatformDependent.createTempFile("netty-splice", null, null);
         file.deleteOnExit();
 
         SpliceHandler sh = new SpliceHandler(file);

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/UnixTestUtils.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.channel.unix.DomainSocketAddress;
 import io.netty.channel.unix.Socket;
+import io.netty.util.internal.PlatformDependent;
 
 import java.io.File;
 import java.io.IOException;
@@ -26,7 +27,7 @@ public static DomainSocketAddress newSocketAddress() {
         try {
             File file;
             do {
-                file = File.createTempFile("NETTY", "UDS");
+                file = PlatformDependent.createTempFile("NETTY", "UDS", null);
                 if (!file.delete()) {
                     throw new IOException("failed to delete: " + file);
                 }

File: transport/src/test/java/io/netty/channel/DefaultFileRegionTest.java
Patch:
@@ -39,7 +39,7 @@ public class DefaultFileRegionTest {
     }
 
     private static File newFile() throws IOException {
-        File file = File.createTempFile("netty-", ".tmp");
+        File file = PlatformDependent.createTempFile("netty-", ".tmp", null);
         file.deleteOnExit();
 
         final FileOutputStream out = new FileOutputStream(file);

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -358,8 +358,7 @@ public List<byte[]> getStatusResponses() {
                 }
 
                 if (!jdkCompatibilityMode) {
-                    SSL.setMode(ssl, SSL.getMode(ssl) | SSL.SSL_MODE_ENABLE_PARTIAL_WRITE
-                            | SSL.SSL_MODE_ENABLE_FALSE_START);
+                    SSL.setMode(ssl, SSL.getMode(ssl) | SSL.SSL_MODE_ENABLE_PARTIAL_WRITE);
                 }
 
                 // setMode may impact the overhead.

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -263,7 +263,7 @@ void init(Channel channel) {
         p.addLast(config.handler());
 
         setChannelOptions(channel, newOptionsArray(), logger);
-        setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));
+        setAttributes(channel, newAttributesArray());
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
Patch:
@@ -286,7 +286,8 @@ private static SSLContext newSSLContext(Provider sslContextProvider,
                 trustManagerFactory = buildTrustManagerFactory(trustCertCollection, trustManagerFactory, keyStore);
             }
             if (keyCertChain != null) {
-                keyManagerFactory = buildKeyManagerFactory(keyCertChain, key, keyPassword, keyManagerFactory, keyStore);
+                keyManagerFactory = buildKeyManagerFactory(keyCertChain, null,
+                        key, keyPassword, keyManagerFactory, keyStore);
             }
             SSLContext ctx = sslContextProvider == null ? SSLContext.getInstance(PROTOCOL)
                 : SSLContext.getInstance(PROTOCOL, sslContextProvider);

File: handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java
Patch:
@@ -263,7 +263,8 @@ private static SSLContext newSSLContext(Provider sslContextProvider, X509Certifi
                 trustManagerFactory = buildTrustManagerFactory(trustCertCollection, trustManagerFactory, keyStore);
             }
             if (key != null) {
-                keyManagerFactory = buildKeyManagerFactory(keyCertChain, key, keyPassword, keyManagerFactory, null);
+                keyManagerFactory = buildKeyManagerFactory(keyCertChain, null,
+                        key, keyPassword, keyManagerFactory, null);
             }
 
             // Initialize the SSLContext to work with our key managers.

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -49,8 +49,7 @@
  * {@link ReferenceCountedOpenSslEngine} is called which uses this class's JNI resources the JVM may crash.
  */
 public final class ReferenceCountedOpenSslClientContext extends ReferenceCountedOpenSslContext {
-    private static final InternalLogger logger =
-            InternalLoggerFactory.getInstance(ReferenceCountedOpenSslClientContext.class);
+
     private static final Set<String> SUPPORTED_KEY_TYPES = Collections.unmodifiableSet(new LinkedHashSet<String>(
             Arrays.asList(OpenSslKeyMaterialManager.KEY_TYPE_RSA,
                           OpenSslKeyMaterialManager.KEY_TYPE_DH_RSA,

File: handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.netty.handler.ssl;
 
+import io.netty.handler.ssl.util.KeyManagerFactoryWrapper;
+import io.netty.handler.ssl.util.TrustManagerFactoryWrapper;
 import io.netty.util.internal.UnstableApi;
 
 import javax.net.ssl.KeyManager;

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -2947,7 +2947,8 @@ private void testSessionAfterHandshake0(boolean useKeyManagerFactory, boolean mu
         SelfSignedCertificate ssc = new SelfSignedCertificate();
         KeyManagerFactory kmf = useKeyManagerFactory ?
                 SslContext.buildKeyManagerFactory(
-                        new java.security.cert.X509Certificate[] { ssc.cert()}, ssc.key(), null, null, null) : null;
+                        new java.security.cert.X509Certificate[] { ssc.cert()}, null,
+                        ssc.key(), null, null, null) : null;
 
         SslContextBuilder clientContextBuilder = SslContextBuilder.forClient();
         if (mutualAuth) {
@@ -3509,7 +3510,7 @@ private KeyManagerFactory newKeyManagerFactory(SelfSignedCertificate ssc)
             throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException,
             CertificateException, IOException {
         return SslContext.buildKeyManagerFactory(
-                new java.security.cert.X509Certificate[] { ssc.cert() }, ssc.key(), null, null, null);
+                new java.security.cert.X509Certificate[] { ssc.cert() }, null, ssc.key(), null, null, null);
     }
 
     private final class TestTrustManagerFactory extends X509ExtendedTrustManager {

File: handler/src/test/java/io/netty/handler/ssl/SniClientJava8TestUtil.java
Patch:
@@ -260,7 +260,7 @@ static KeyManagerFactory newSniX509KeyManagerFactory(SelfSignedCertificate cert,
                    IOException, CertificateException {
         return new SniX509KeyManagerFactory(
                 new SNIHostName(hostname), SslContext.buildKeyManagerFactory(
-                new X509Certificate[] { cert.cert() }, cert.key(), null, null, null));
+                new X509Certificate[] { cert.cert() }, null,  cert.key(), null, null, null));
     }
 
     private static final class SniX509KeyManagerFactory extends KeyManagerFactory {

File: handler/src/test/java/io/netty/handler/ssl/SniClientTest.java
Patch:
@@ -113,7 +113,8 @@ private static void testSniClient(SslProvider sslServerProvider, SslProvider ssl
                 KeyManagerFactory kmf = PlatformDependent.javaVersion() >= 8 ?
                         SniClientJava8TestUtil.newSniX509KeyManagerFactory(cert, sniHostName) :
                         SslContext.buildKeyManagerFactory(
-                                new X509Certificate[] { cert.cert() }, cert.key(), null, null, null);
+                                new X509Certificate[] { cert.cert() }, null,
+                                cert.key(), null, null, null);
 
                sslServerContext = SslContextBuilder.forServer(kmf)
                                                    .sslProvider(sslServerProvider)

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/UnixTestUtils.java
Patch:
@@ -30,7 +30,7 @@ public static DomainSocketAddress newSocketAddress() {
                 if (!file.delete()) {
                     throw new IOException("failed to delete: " + file);
                 }
-            } while (file.getAbsolutePath().length() > Socket.UDS_SUN_PATH_SIZE);
+            } while (file.getAbsolutePath().length() > 128);
             return new DomainSocketAddress(file);
         } catch (IOException e) {
             throw new IllegalStateException(e);

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/Socket.java
Patch:
@@ -46,7 +46,8 @@
  */
 public class Socket extends FileDescriptor {
 
-    public static final int UDS_SUN_PATH_SIZE = udsSunPathSize();
+    @Deprecated
+    public static final int UDS_SUN_PATH_SIZE = 100;
 
     protected final boolean ipv6;
 

File: handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java
Patch:
@@ -435,6 +435,7 @@ public ReferenceCountedOpenSslEngine getWrappedEngine() {
     }
 
     private static void assertErrorStackEmpty() {
-        Assert.assertEquals("SSL error stack non-empty", 0, SSL.getLastErrorNumber());
+        long error = SSL.getLastErrorNumber();
+        Assert.assertEquals("SSL error stack non-empty: " + SSL.getErrorString(error), 0, error);
     }
 }

File: common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
Patch:
@@ -260,7 +260,9 @@ public void run() {
                     assert stopped;
 
                     // Check if there are pending entries added by execute() or schedule*() while we do CAS above.
-                    if (taskQueue.isEmpty() && (scheduledTaskQueue == null || scheduledTaskQueue.size() == 1)) {
+                    // Do not check scheduledTaskQueue because it is not thread-safe and can only be mutated from a
+                    // TaskRunner actively running tasks.
+                    if (taskQueue.isEmpty()) {
                         // A) No new task was added and thus there's nothing to handle
                         //    -> safe to terminate because there's nothing left to do
                         // B) A new thread started and handled all the new tasks.

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -1223,6 +1223,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                     assertEquals(expected, buffer);
                 } finally {
                     expected.release();
+                    buffer.release();
                 }
             } else {
                 throw (Throwable) obj;

File: resolver-dns-native-macos/src/main/java/io/netty/resolver/dns/macos/MacOSDnsServerAddressStreamProvider.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.resolver.dns.macos;
 
+import io.netty.channel.unix.Unix;
 import io.netty.resolver.dns.DnsServerAddressStream;
 import io.netty.resolver.dns.DnsServerAddressStreamProvider;
 import io.netty.resolver.dns.DnsServerAddressStreamProviders;
@@ -53,6 +54,7 @@ public final class MacOSDnsServerAddressStreamProvider implements DnsServerAddre
     static {
         Throwable cause = null;
         try {
+            Unix.ensureAvailability();
             loadNativeLibrary();
         } catch (Throwable error) {
             cause = error;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel.epoll;
 
 import io.netty.channel.unix.FileDescriptor;
+import io.netty.channel.unix.Unix;
 import io.netty.util.internal.SystemPropertyUtil;
 
 /**
@@ -36,6 +37,7 @@ public final class Epoll {
             FileDescriptor epollFd = null;
             FileDescriptor eventFd = null;
             try {
+                Unix.ensureAvailability();
                 epollFd = Native.newEpollCreate();
                 eventFd = Native.newEventFd();
             } catch (Throwable t) {

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueue.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel.kqueue;
 
 import io.netty.channel.unix.FileDescriptor;
+import io.netty.channel.unix.Unix;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.UnstableApi;
 
@@ -34,6 +35,7 @@ public final class KQueue {
         } else {
             FileDescriptor kqueueFd = null;
             try {
+                Unix.ensureAvailability();
                 kqueueFd = Native.newKQueue();
             } catch (Throwable t) {
                 cause = t;

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/FileDescriptor.java
Patch:
@@ -51,6 +51,7 @@ public class FileDescriptor {
     final int fd;
 
     public FileDescriptor(int fd) {
+        Unix.ensureAvailability();
         checkPositiveOrZero(fd, "fd");
         this.fd = fd;
     }

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/IovArray.java
Patch:
@@ -66,14 +66,15 @@ public final class IovArray implements MessageProcessor {
     private final ByteBuf memory;
     private int count;
     private long size;
-    private long maxBytes = SSIZE_MAX;
+    private long maxBytes;
 
     public IovArray() {
         this(Unpooled.wrappedBuffer(Buffer.allocateDirectWithNativeOrder(MAX_CAPACITY)).setIndex(0, 0));
     }
 
     @SuppressWarnings("deprecation")
     public IovArray(ByteBuf memory) {
+        Unix.ensureAvailability();
         assert memory.writerIndex() == 0;
         assert memory.readerIndex() == 0;
         this.memory = PlatformDependent.hasUnsafe() ? memory : memory.order(
@@ -84,6 +85,7 @@ public IovArray(ByteBuf memory) {
             // Fallback to using JNI as we were not be able to access the address otherwise.
             memoryAddress = Buffer.memoryAddress(memory.internalNioBuffer(0, memory.capacity()));
         }
+        maxBytes = SSIZE_MAX;
     }
 
     public void clear() {

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/IovArrayTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
 public abstract class IovArrayTest {
@@ -40,6 +41,7 @@ public void testNotFailsWihtoutMemoryAddress() {
         assertEquals(16, array.size());
         assertTrue(buf.release());
         assertTrue(buf2.release());
+        assertNotEquals(-1, array.memoryAddress(0));
         array.release();
         assertEquals(0, buffer.refCnt());
     }

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/IovArray.java
Patch:
@@ -212,7 +212,7 @@ public long maxBytes() {
      * Returns the {@code memoryAddress} for the given {@code offset}.
      */
     public long memoryAddress(int offset) {
-        return memory.memoryAddress() + idx(offset);
+        return memoryAddress + idx(offset);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -1132,7 +1132,7 @@ private static int findDelimiter(ByteBuf undecodedChunk, String delimiter, int o
                 newOffset = toRead;
                 return -newOffset;
             }
-            newOffset = posFirstChar + offset;
+            newOffset = posFirstChar + newOffset;
             if (newOffset + delimeterLength > toRead) {
                 return -newOffset;
             }

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
Patch:
@@ -47,9 +47,9 @@ public UnpooledUnsafeDirectByteBuf(ByteBufAllocator alloc, int initialCapacity,
      * @param maxCapacity the maximum capacity of the underlying direct buffer
      */
     protected UnpooledUnsafeDirectByteBuf(ByteBufAllocator alloc, ByteBuffer initialBuffer, int maxCapacity) {
-        // We never try to free the buffer if it was provided by the end-user as we not know if this is an duplicate or
-        // an slice. This is done to prevent an IllegalArgumentException when using Java9 as Unsafe.invokeCleaner(...)
-        // will check if the given buffer is either an duplicate or slice and in this case throw an
+        // We never try to free the buffer if it was provided by the end-user as we don't know if this is a duplicate or
+        // a slice. This is done to prevent an IllegalArgumentException when using Java9 as Unsafe.invokeCleaner(...)
+        // will check if the given buffer is either a duplicate or slice and in this case throw an
         // IllegalArgumentException.
         //
         // See https://hg.openjdk.java.net/jdk9/hs-demo/jdk/file/0d2ab72ba600/src/jdk.unsupported/share/classes/

File: codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java
Patch:
@@ -96,7 +96,7 @@ private int readable(int length) {
     }
 
     /**
-     * Exception that will get thrown if the {@link Object} is to big to unmarshall
+     * Exception that will get thrown if the {@link Object} is too big to unmarshall
      *
      */
     static final class TooBigObjectException extends IOException {

File: testsuite-native-image-client/src/main/java/io/netty/testsuite/svm/client/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * A hello world server that should be compiled to native.
+ * A client that uses netty-dns and gets compiled to a native image.
  */
 package io.netty.testsuite.svm.client;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -121,7 +121,8 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
         if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {
             switch (state) {
                 case ST_INIT:
-                    throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
+                    throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg)
+                        + ", state: " + state);
                 case ST_CONTENT_NON_CHUNK:
                     final long contentLength = contentLength(msg);
                     if (contentLength > 0) {

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeEncoderTest.java
Patch:
@@ -76,9 +76,7 @@ public void testUtf8FrameEncoding() {
 
         channel.writeOutbound(frame);
 
-        ByteBuf headers = channel.readOutbound();
-        ByteBuf content = channel.readOutbound();
-        ByteBuf fullFrame = Unpooled.wrappedBuffer(headers, content);
+        ByteBuf fullFrame = channel.readOutbound();
         assertEquals(SEND_FRAME_UTF8, fullFrame.toString(CharsetUtil.UTF_8));
         assertTrue(fullFrame.release());
     }

File: example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketProtocolCodec.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageCodec;
+import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
@@ -58,7 +59,7 @@ protected void encode(ChannelHandlerContext ctx, StompSubframe stompFrame, List<
 
     @Override
     protected void decode(ChannelHandlerContext ctx, WebSocketFrame webSocketFrame, List<Object> out) {
-        if (webSocketFrame instanceof TextWebSocketFrame) {
+        if (webSocketFrame instanceof TextWebSocketFrame || webSocketFrame instanceof BinaryWebSocketFrame) {
             out.add(webSocketFrame.content().retain());
         } else {
             ctx.close();

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -89,6 +89,8 @@ public void recycle(Object object) {
         RATIO = max(0, SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8));
         DELAYED_QUEUE_RATIO = max(0, SystemPropertyUtil.getInt("io.netty.recycler.delayedQueue.ratio", RATIO));
 
+        INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256);
+
         if (logger.isDebugEnabled()) {
             if (DEFAULT_MAX_CAPACITY_PER_THREAD == 0) {
                 logger.debug("-Dio.netty.recycler.maxCapacityPerThread: disabled");
@@ -104,8 +106,6 @@ public void recycle(Object object) {
                 logger.debug("-Dio.netty.recycler.delayedQueue.ratio: {}", DELAYED_QUEUE_RATIO);
             }
         }
-
-        INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256);
     }
 
     private final int maxCapacityPerThread;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -120,6 +120,7 @@ public void remoteSettings(Http2Settings settings) throws Http2Exception {
     @Override
     public ChannelFuture writeData(final ChannelHandlerContext ctx, final int streamId, ByteBuf data, int padding,
             final boolean endOfStream, ChannelPromise promise) {
+        promise = promise.unvoid();
         final Http2Stream stream;
         try {
             stream = requireStream(streamId);

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -45,7 +45,7 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator implements
     private static final int DEFAULT_MAX_ORDER; // 8192 << 11 = 16 MiB per chunk
     private static final int DEFAULT_SMALL_CACHE_SIZE;
     private static final int DEFAULT_NORMAL_CACHE_SIZE;
-    private static final int DEFAULT_MAX_CACHED_BUFFER_CAPACITY;
+    static final int DEFAULT_MAX_CACHED_BUFFER_CAPACITY;
     private static final int DEFAULT_CACHE_TRIM_INTERVAL;
     private static final long DEFAULT_CACHE_TRIM_INTERVAL_MILLIS;
     private static final boolean DEFAULT_USE_CACHE_FOR_ALL_THREADS;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -165,7 +165,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
                         logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                     }
                 } else {
-                    res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
+                    res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
                 }
             }
 
@@ -189,7 +189,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
 
             String protocol = req.headers().get(HttpHeaderNames.WEBSOCKET_PROTOCOL);
             if (protocol != null) {
-                res.headers().add(HttpHeaderNames.WEBSOCKET_PROTOCOL, selectSubprotocol(protocol));
+                res.headers().set(HttpHeaderNames.WEBSOCKET_PROTOCOL, selectSubprotocol(protocol));
             }
         }
         return res;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -161,7 +161,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
                     logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                 }
             } else {
-                res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
+                res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
             }
         }
         return res;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -167,7 +167,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
                     logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                 }
             } else {
-                res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
+                res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
             }
         }
         return res;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -165,7 +165,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
                     logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                 }
             } else {
-                res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
+                res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
             }
         }
         return res;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
Patch:
@@ -234,7 +234,7 @@ private void initDecompressor(ChannelHandlerContext ctx, int streamId, Http2Head
         if (decompressor != null) {
             // The content length will be for the compressed data. Since we will decompress the data
             // this content-length will not be correct. Instead of queuing messages or delaying sending
-            // header frames...just remove the content-length header
+            // header frames just remove the content-length header.
             headers.remove(CONTENT_LENGTH);
 
             // The first time that we initialize a decompressor, decorate the local flow controller to

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ControlFrameLimitEncoderTest.java
Patch:
@@ -266,7 +266,7 @@ private void verifyFlushAndClose(int invocations, boolean failed) {
         verify(ctx, atLeast(invocations)).flush();
         verify(ctx, times(invocations)).close();
         if (failed) {
-            verify(writer, times(1)).writeGoAway(eq(ctx), eq(0), eq(ENHANCE_YOUR_CALM.code()),
+            verify(writer, times(1)).writeGoAway(eq(ctx), eq(Integer.MAX_VALUE), eq(ENHANCE_YOUR_CALM.code()),
                     any(ByteBuf.class), any(ChannelPromise.class));
         }
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -332,7 +332,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         } else if (msg instanceof Http2SettingsFrame) {
             encoder().writeSettings(ctx, ((Http2SettingsFrame) msg).settings(), promise);
         } else if (msg instanceof Http2SettingsAckFrame) {
-            // In the event of manual SETTINGS ACK is is assumed the encoder will apply the earliest received but not
+            // In the event of manual SETTINGS ACK, it is assumed the encoder will apply the earliest received but not
             // yet ACKed settings.
             encoder().writeSettingsAck(ctx, promise);
         } else if (msg instanceof Http2GoAwayFrame) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
Patch:
@@ -43,7 +43,7 @@ public interface Http2DataFrame extends Http2StreamFrame, ByteBufHolder {
     int initialFlowControlledBytes();
 
     /**
-     * Returns {@code true} if the END_STREAM flag ist set.
+     * Returns {@code true} if the END_STREAM flag is set.
      */
     boolean isEndStream();
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
Patch:
@@ -34,7 +34,7 @@ public interface Http2HeadersFrame extends Http2StreamFrame {
     int padding();
 
     /**
-     * Returns {@code true} if the END_STREAM flag ist set.
+     * Returns {@code true} if the END_STREAM flag is set.
      */
     boolean isEndStream();
 }

File: buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java
Patch:
@@ -189,7 +189,7 @@ public void writeShortBE() {
 
         buf = buffer(2).order(ByteOrder.LITTLE_ENDIAN);
         ByteBufUtil.writeShortBE(buf, expected);
-        assertEquals((short) expected, buf.readShortLE());
+        assertEquals(ByteBufUtil.swapShort((short) expected), buf.readShortLE());
         buf.resetReaderIndex();
         assertEquals(ByteBufUtil.swapShort((short) expected), buf.readShort());
         buf.release();
@@ -209,7 +209,7 @@ public void setShortBE() {
 
         buf = Unpooled.wrappedBuffer(new byte[2]).order(ByteOrder.LITTLE_ENDIAN);
         ByteBufUtil.setShortBE(buf, 0, shortValue);
-        assertEquals((short) shortValue, buf.readShortLE());
+        assertEquals(ByteBufUtil.swapShort((short) shortValue), buf.readShortLE());
         buf.resetReaderIndex();
         assertEquals(ByteBufUtil.swapShort((short) shortValue), buf.readShort());
         buf.release();
@@ -229,7 +229,7 @@ public void writeMediumBE() {
 
         buf = buffer(4).order(ByteOrder.LITTLE_ENDIAN);
         ByteBufUtil.writeMediumBE(buf, mediumValue);
-        assertEquals(mediumValue, buf.readMediumLE());
+        assertEquals(ByteBufUtil.swapMedium(mediumValue), buf.readMediumLE());
         buf.resetReaderIndex();
         assertEquals(ByteBufUtil.swapMedium(mediumValue), buf.readMedium());
         buf.release();

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/Errors.java
Patch:
@@ -107,7 +107,7 @@ int expectedErr() {
         }
     }
 
-    static void throwConnectException(String method, int err)
+    public static void throwConnectException(String method, int err)
             throws IOException {
         if (err == ERROR_EALREADY_NEGATIVE) {
             throw new ConnectionPendingException();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java
Patch:
@@ -147,8 +147,8 @@ private enum ReadStatus {
         REQUESTED
     }
 
-    private final AbstractHttp2StreamChannel.Http2StreamChannelConfig config = new Http2StreamChannelConfig(this);
-    private final AbstractHttp2StreamChannel.Http2ChannelUnsafe unsafe = new Http2ChannelUnsafe();
+    private final Http2StreamChannelConfig config = new Http2StreamChannelConfig(this);
+    private final Http2ChannelUnsafe unsafe = new Http2ChannelUnsafe();
     private final ChannelId channelId;
     private final ChannelPipeline pipeline;
     private final DefaultHttp2FrameStream stream;
@@ -258,7 +258,7 @@ private void setUnwritable(boolean invokeLater) {
             final int oldValue = unwritable;
             final int newValue = oldValue | 1;
             if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {
-                if (oldValue == 0 && newValue != 0) {
+                if (oldValue == 0) {
                     fireChannelWritabilityChanged(invokeLater);
                 }
                 break;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -219,7 +219,7 @@ public ChannelFuture writeData(ChannelHandlerContext ctx, int streamId, ByteBuf
                     ctx.write(frameHeader2, promiseAggregator.newPromise());
 
                     // Write the payload.
-                    if (frameDataBytes != 0) {
+                    if (frameDataBytes != 0 && data != null) { // Make sure Data is not null
                         if (remainingData == 0) {
                             ByteBuf lastFrame = data.readSlice(frameDataBytes);
                             data = null;

File: transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
Patch:
@@ -991,11 +991,11 @@ private static boolean safeExecute(EventExecutor executor, Runnable runnable,
             return true;
         } catch (Throwable cause) {
             try {
-                promise.setFailure(cause);
-            } finally {
                 if (msg != null) {
                     ReferenceCountUtil.release(msg);
                 }
+            } finally {
+                promise.setFailure(cause);
             }
             return false;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakeException.java
Patch:
@@ -5,7 +5,7 @@
  * version 2.0 (the "License"); you may not use this file except in compliance
  * with the License. You may obtain a copy of the License at:
  *
- *   http://www.apache.org/licenses/LICENSE-2.0
+ *   https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakeException.java
Patch:
@@ -5,7 +5,7 @@
  * version 2.0 (the "License"); you may not use this file except in compliance
  * with the License. You may obtain a copy of the License at:
  *
- *   http://www.apache.org/licenses/LICENSE-2.0
+ *   https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeExceptionTest.java
Patch:
@@ -5,7 +5,7 @@
  * version 2.0 (the "License"); you may not use this file except in compliance
  * with the License. You may obtain a copy of the License at:
  *
- *   http://www.apache.org/licenses/LICENSE-2.0
+ *   https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -324,9 +324,9 @@ public final void finishHandshake(Channel channel, FullHttpResponse response) {
         } // else mixed cases - which are all errors
 
         if (!protocolValid) {
-            throw new WebSocketHandshakeException(String.format(
+            throw new WebSocketClientHandshakeException(String.format(
                     "Invalid subprotocol. Actual: %s. Expected one of: %s",
-                    receivedProtocol, expectedSubprotocol));
+                    receivedProtocol, expectedSubprotocol), response);
         }
 
         setHandshakeComplete();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
Patch:
@@ -162,7 +162,7 @@ public static WebSocketClientHandshaker newHandshaker(
                     webSocketURL, V00, subprotocol, customHeaders, maxFramePayloadLength, forceCloseTimeoutMillis);
         }
 
-        throw new WebSocketHandshakeException("Protocol version " + version + " not supported.");
+        throw new WebSocketClientHandshakeException("Protocol version " + version + " not supported.");
     }
 
     /**
@@ -220,6 +220,6 @@ public static WebSocketClientHandshaker newHandshaker(
                 maxFramePayloadLength, forceCloseTimeoutMillis, absoluteUpgradeUrl);
         }
 
-        throw new WebSocketHandshakeException("Protocol version " + version + " not supported.");
+        throw new WebSocketClientHandshakeException("Protocol version " + version + " not supported.");
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
Patch:
@@ -73,7 +73,8 @@ public void operationComplete(ChannelFuture future) throws Exception {
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         if (!handshakePromise.isDone()) {
-            handshakePromise.tryFailure(new WebSocketHandshakeException("channel closed with handshake in progress"));
+            handshakePromise.tryFailure(new WebSocketClientHandshakeException("channel closed with handshake " +
+                                                                              "in progress"));
         }
 
         super.channelInactive(ctx);
@@ -115,7 +116,7 @@ public void run() {
                     return;
                 }
 
-                if (localHandshakePromise.tryFailure(new WebSocketHandshakeException("handshake timed out"))) {
+                if (localHandshakePromise.tryFailure(new WebSocketClientHandshakeException("handshake timed out"))) {
                     ctx.flush()
                        .fireUserEventTriggered(ClientHandshakeStateEvent.HANDSHAKE_TIMEOUT)
                        .close();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -126,7 +126,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         // Serve the WebSocket handshake request.
         if (!req.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE, true)
                 || !HttpHeaderValues.WEBSOCKET.contentEqualsIgnoreCase(req.headers().get(HttpHeaderNames.UPGRADE))) {
-            throw new WebSocketHandshakeException("not a WebSocket handshake request: missing upgrade");
+            throw new WebSocketServerHandshakeException("not a WebSocket handshake request: missing upgrade", req);
         }
 
         // Hixie 75 does not contain these headers while Hixie 76 does
@@ -136,7 +136,8 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         String origin = req.headers().get(HttpHeaderNames.ORIGIN);
         //throw before allocating FullHttpResponse
         if (origin == null && !isHixie76) {
-            throw new WebSocketHandshakeException("Missing origin header, got only " + req.headers().names());
+            throw new WebSocketServerHandshakeException("Missing origin header, got only " + req.headers().names(),
+                                                        req);
         }
 
         // Create the WebSocket handshake response.

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -130,7 +130,7 @@ public WebSocketServerHandshaker07(String webSocketURL, String subprotocols, Web
     protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
         CharSequence key = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_KEY);
         if (key == null) {
-            throw new WebSocketHandshakeException("not a WebSocket request: missing key");
+            throw new WebSocketServerHandshakeException("not a WebSocket request: missing key", req);
         }
 
         FullHttpResponse res =

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -137,7 +137,7 @@ public WebSocketServerHandshaker08(
     protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
         CharSequence key = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_KEY);
         if (key == null) {
-            throw new WebSocketHandshakeException("not a WebSocket request: missing key");
+            throw new WebSocketServerHandshakeException("not a WebSocket request: missing key", req);
         }
 
         FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -136,7 +136,7 @@ public WebSocketServerHandshaker13(
     protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
         CharSequence key = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_KEY);
         if (key == null) {
-            throw new WebSocketHandshakeException("not a WebSocket request: missing key");
+            throw new WebSocketServerHandshakeException("not a WebSocket request: missing key", req);
         }
 
         FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -158,7 +158,7 @@ private void applyHandshakeTimeout() {
             @Override
             public void run() {
                 if (!localHandshakePromise.isDone() &&
-                        localHandshakePromise.tryFailure(new WebSocketHandshakeException("handshake timed out"))) {
+                    localHandshakePromise.tryFailure(new WebSocketServerHandshakeException("handshake timed out"))) {
                     ctx.flush()
                        .fireUserEventTriggered(ServerHandshakeStateEvent.HANDSHAKE_TIMEOUT)
                        .close();

File: codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java
Patch:
@@ -152,7 +152,7 @@ public HAProxyMessageDecoder(int maxTlvSize, boolean failFast) {
             v2MaxHeaderSize = V2_MAX_LENGTH;
         } else {
             int calcMax = maxTlvSize + V2_MIN_LENGTH;
-            if (calcMax > V2_MAX_LENGTH) {
+            if (calcMax > V2_MAX_LENGTH) {  // lgtm[java/constant-comparison]
                 v2MaxHeaderSize = V2_MAX_LENGTH;
             } else {
                 v2MaxHeaderSize = calcMax;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -992,7 +992,8 @@ private final class LineParser extends HeaderParser {
 
         @Override
         public AppendableCharSequence parse(ByteBuf buffer) {
-            reset();
+            // Suppress a warning because HeaderParser.reset() is supposed to be called
+            reset();    // lgtm[java/subtle-inherited-call]
             return super.parse(buffer);
         }
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java
Patch:
@@ -57,7 +57,8 @@ public enum MqttConnectReturnCode {
         VALUES = new MqttConnectReturnCode[160];
         for (MqttConnectReturnCode code : values) {
             final int unsignedByte = code.byteValue & 0xFF;
-            VALUES[unsignedByte] = code;
+            // Suppress a warning about out of bounds access since the enum contains only correct values
+            VALUES[unsignedByte] = code;    // lgtm [java/index-out-of-bounds]
         }
     }
 

File: codec-xml/src/main/java/io/netty/handler/codec/xml/XmlElement.java
Patch:
@@ -69,7 +69,7 @@ public boolean equals(Object o) {
         if (namespace != null ? !namespace.equals(that.namespace) : that.namespace != null) {
             return false;
         }
-        if (namespaces != null ? !namespaces.equals(that.namespaces) : that.namespaces != null) {
+        if (!namespaces.equals(that.namespaces)) {
             return false;
         }
         if (prefix != null ? !prefix.equals(that.prefix) : that.prefix != null) {
@@ -84,7 +84,7 @@ public int hashCode() {
         int result = name.hashCode();
         result = 31 * result + (namespace != null ? namespace.hashCode() : 0);
         result = 31 * result + (prefix != null ? prefix.hashCode() : 0);
-        result = 31 * result + (namespaces != null ? namespaces.hashCode() : 0);
+        result = 31 * result + namespaces.hashCode();
         return result;
     }
 

File: codec-xml/src/main/java/io/netty/handler/codec/xml/XmlElementStart.java
Patch:
@@ -47,7 +47,7 @@ public boolean equals(Object o) {
 
         XmlElementStart that = (XmlElementStart) o;
 
-        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) {
+        if (!attributes.equals(that.attributes)) {
             return false;
         }
 
@@ -57,7 +57,7 @@ public boolean equals(Object o) {
     @Override
     public int hashCode() {
         int result = super.hashCode();
-        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);
+        result = 31 * result + attributes.hashCode();
         return result;
     }
 

File: codec/src/main/java/io/netty/handler/codec/DateFormatter.java
Patch:
@@ -101,7 +101,7 @@ public static Date parseHttpDate(CharSequence txt, int start, int end) {
         } else if (length < 0) {
             throw new IllegalArgumentException("Can't have end < start");
         } else if (length > 64) {
-            throw new IllegalArgumentException("Can't parse more than 64 chars," +
+            throw new IllegalArgumentException("Can't parse more than 64 chars, " +
                     "looks like a user error or a malformed header");
         }
         return formatter().parse0(checkNotNull(txt, "txt"), start, end);

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -383,7 +383,9 @@ private ChannelFuture finishEncode(ChannelHandlerContext ctx, ChannelPromise pro
             if (resultCode != JZlib.Z_OK && resultCode != JZlib.Z_STREAM_END) {
                 promise.setFailure(ZlibUtil.deflaterException(z, "compression failure", resultCode));
                 return promise;
-            } else if (z.next_out_index != 0) {
+            } else if (z.next_out_index != 0) { // lgtm[java/constant-comparison]
+                // Suppressed a warning above to be on the safe side
+                // even if z.next_out_index seems to be always 0 here
                 footer = Unpooled.wrappedBuffer(out, 0, z.next_out_index);
             } else {
                 footer = Unpooled.EMPTY_BUFFER;

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -71,7 +71,9 @@ protected ObjectOutputStream newObjectOutputStream(OutputStream out) throws Exce
 
     @Override
     protected void encode(ChannelHandlerContext ctx, Serializable msg, ByteBuf out) throws Exception {
-        ObjectOutputStream oos = newObjectOutputStream(new ByteBufOutputStream(out));
+        // Suppress a warning about resource leak since oss is closed below
+        ObjectOutputStream oos = newObjectOutputStream(
+                new ByteBufOutputStream(out));  // lgtm[java/output-resource-leak]
         try {
             if (resetInterval != 0) {
                 // Resetting will prevent OOM on the receiving side.

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectEncoderOutputStream.java
Patch:
@@ -79,7 +79,9 @@ public ObjectEncoderOutputStream(OutputStream out, int estimatedLength) {
     public void writeObject(Object obj) throws IOException {
         ByteBuf buf = Unpooled.buffer(estimatedLength);
         try {
-            ObjectOutputStream oout = new CompactObjectOutputStream(new ByteBufOutputStream(buf));
+            // Suppress a warning about resource leak since oout is closed below
+            ObjectOutputStream oout = new CompactObjectOutputStream(
+                    new ByteBufOutputStream(buf));  // lgtm[java/output-resource-leak]
             try {
                 oout.writeObject(obj);
                 oout.flush();

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -439,7 +439,7 @@ private static void reportTooManyInstances() {
         if (logger.isErrorEnabled()) {
             String resourceType = simpleClassName(HashedWheelTimer.class);
             logger.error("You are creating too many " + resourceType + " instances. " +
-                    resourceType + " is a shared resource that must be reused across the JVM," +
+                    resourceType + " is a shared resource that must be reused across the JVM, " +
                     "so that only a few instances are created.");
         }
     }

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -318,8 +318,9 @@ public Integer run() {
     private static Integer sysctlGetInt(String sysctlKey) throws IOException {
         Process process = new ProcessBuilder("sysctl", sysctlKey).start();
         try {
-            InputStream is = process.getInputStream();
-            InputStreamReader isr = new InputStreamReader(is);
+            // Suppress warnings about resource leaks since the buffered reader is closed below
+            InputStream is = process.getInputStream();  // lgtm[java/input-resource-leak
+            InputStreamReader isr = new InputStreamReader(is);  // lgtm[java/input-resource-leak
             BufferedReader br = new BufferedReader(isr);
             try {
                 String line = br.readLine();

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -632,8 +632,10 @@ public String toString() {
                 // Strip the noisy stack trace elements.
                 String[] exclusions = excludedMethods.get();
                 for (int k = 0; k < exclusions.length; k += 2) {
+                    // Suppress a warning about out of bounds access
+                    // since the length of excludedMethods is always even, see addExclusions()
                     if (exclusions[k].equals(element.getClassName())
-                            && exclusions[k + 1].equals(element.getMethodName())) {
+                            && exclusions[k + 1].equals(element.getMethodName())) { // lgtm[java/index-out-of-bounds]
                         continue out;
                     }
                 }

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -140,8 +140,9 @@ public boolean isCancellable() {
     private static final class LeanCancellationException extends CancellationException {
         private static final long serialVersionUID = 2794674970981187807L;
 
+        // Suppress a warning since the method doesn't need synchronization
         @Override
-        public Throwable fillInStackTrace() {
+        public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]
             setStackTrace(CANCELLATION_STACK);
             return this;
         }

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -1635,7 +1635,7 @@ public final void setEnabledProtocols(String[] protocols) {
                 if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) {
                     minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;
                 }
-                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) {
+                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) { // lgtm[java/constant-comparison]
                     maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;
                 }
             } else if (p.equals(PROTOCOL_SSL_V3)) {

File: handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java
Patch:
@@ -390,7 +390,7 @@ public SslContextBuilder keyManager(InputStream keyCertChainInputStream, InputSt
     public SslContextBuilder keyManager(PrivateKey key, String keyPassword, X509Certificate... keyCertChain) {
         if (forServer) {
             checkNotNull(keyCertChain, "keyCertChain required for servers");
-            if (keyCertChain.length == 0) {
+            if (keyCertChain.length == 0) { // lgtm[java/dereferenced-value-may-be-null]
                 throw new IllegalArgumentException("keyCertChain must be non-empty");
             }
             checkNotNull(key, "key required for servers");

File: handler/src/main/java/io/netty/handler/timeout/TimeoutException.java
Patch:
@@ -32,8 +32,9 @@ public class TimeoutException extends ChannelException {
         super(null, null, shared);
     }
 
+    // Suppress a warning since the method doesn't need synchronization
     @Override
-    public Throwable fillInStackTrace() {
+    public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]
         return this;
     }
 }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
Patch:
@@ -66,8 +66,9 @@ public DnsQuestion question() {
         return question;
     }
 
+    // Suppress a warning since the method doesn't need synchronization
     @Override
-    public Throwable fillInStackTrace() {
+    public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]
         setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
         return this;
     }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java
Patch:
@@ -266,8 +266,9 @@ private static final class SearchDomainUnknownHostException extends UnknownHostE
             initCause(cause.getCause());
         }
 
+        // Suppress a warning since this method doesn't need synchronization
         @Override
-        public Throwable fillInStackTrace() {
+        public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]
             return this;
         }
     }

File: resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java
Patch:
@@ -99,7 +99,8 @@ public UnixResolverDnsServerAddressStreamProvider(File etcResolvConf, File... et
         final boolean useEtcResolverFiles = etcResolverFiles != null && etcResolverFiles.length != 0;
         domainToNameServerStreamMap = useEtcResolverFiles ? parse(etcResolverFiles) : etcResolvConfMap;
 
-        DnsServerAddresses defaultNameServerAddresses = etcResolvConfMap.get(etcResolvConf.getName());
+        DnsServerAddresses defaultNameServerAddresses
+                = etcResolvConfMap.get(etcResolvConf.getName());  // lgtm[java/dereferenced-value-may-be-null]
         if (defaultNameServerAddresses == null) {
             Collection<DnsServerAddresses> values = etcResolvConfMap.values();
             if (values.isEmpty()) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventArray.java
Patch:
@@ -109,7 +109,8 @@ int fd(int index) {
 
     private int getInt(int index, int offset) {
         if (PlatformDependent.hasUnsafe()) {
-            return PlatformDependent.getInt(memoryAddress + index * EPOLL_EVENT_SIZE + offset);
+            long n = (long) index * (long) EPOLL_EVENT_SIZE;
+            return PlatformDependent.getInt(memoryAddress + n + offset);
         }
         return memory.getInt(index * EPOLL_EVENT_SIZE + offset);
     }

File: transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
Patch:
@@ -50,7 +50,8 @@ public class AdaptiveRecvByteBufAllocator extends DefaultMaxMessagesRecvByteBufA
             sizeTable.add(i);
         }
 
-        for (int i = 512; i > 0; i <<= 1) {
+        // Suppress a warning since i becomes negative when an integer overflow happens
+        for (int i = 512; i > 0; i <<= 1) { // lgtm[java/constant-comparison]
             sizeTable.add(i);
         }
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -603,7 +603,7 @@ private void setUnwritable(boolean invokeLater) {
             final int oldValue = unwritable;
             final int newValue = oldValue | 1;
             if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {
-                if (oldValue == 0 && newValue != 0) {
+                if (oldValue == 0) {
                     fireChannelWritabilityChanged(invokeLater);
                 }
                 break;

File: transport/src/main/java/io/netty/channel/ExtendedClosedChannelException.java
Patch:
@@ -25,8 +25,9 @@ final class ExtendedClosedChannelException extends ClosedChannelException {
         }
     }
 
+    // Suppress a warning since the method doesn't need synchronization
     @Override
-    public Throwable fillInStackTrace() {
+    public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]
         return this;
     }
 }

File: transport/src/main/java/io/netty/channel/StacklessClosedChannelException.java
Patch:
@@ -30,7 +30,8 @@ private StacklessClosedChannelException() { }
 
     @Override
     public Throwable fillInStackTrace() {
-        return this;
+        // Suppress a warning since this method doesn't need synchronization
+        return this; // lgtm [java/non-sync-override]
     }
 
     /**

File: transport/src/main/java/io/netty/channel/group/VoidChannelGroupFuture.java
Patch:
@@ -24,7 +24,8 @@
 import java.util.Iterator;
 import java.util.concurrent.TimeUnit;
 
-final class VoidChannelGroupFuture implements ChannelGroupFuture {
+// Suppress a warning about returning the same iterator since it always returns an empty iterator
+final class VoidChannelGroupFuture implements ChannelGroupFuture {  // lgtm[java/iterable-wraps-iterator]
 
     private static final Iterator<ChannelFuture> EMPTY = Collections.<ChannelFuture>emptyList().iterator();
     private final ChannelGroup group;

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -196,8 +196,10 @@ public void onTimeout(AcquireTask task) {
                         // Fail the promise as we timed out.
                         task.promise.setFailure(new TimeoutException(
                                 "Acquire operation took longer then configured maximum time") {
+
+                            // Suppress a warning since the method doesn't need synchronization
                             @Override
-                            public Throwable fillInStackTrace() {
+                            public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]
                                 return this;
                             }
                         });

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackHuffmanDecoder.java
Patch:
@@ -34,7 +34,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.util.AsciiString;
 import io.netty.util.ByteProcessor;
-import io.netty.util.internal.ThrowableUtil;
 
 import static io.netty.handler.codec.http2.Http2Error.COMPRESSION_ERROR;
 
@@ -4665,9 +4664,9 @@ final class HpackHuffmanDecoder implements ByteProcessor {
             HUFFMAN_FAIL << 8,
     };
 
-    private static final Http2Exception BAD_ENCODING = ThrowableUtil.unknownStackTrace(
+    private static final Http2Exception BAD_ENCODING =
             Http2Exception.newStatic(COMPRESSION_ERROR, "HPACK - Bad Encoding",
-                    Http2Exception.ShutdownHint.HARD_SHUTDOWN), HpackHuffmanDecoder.class, "decode(..)");
+                    Http2Exception.ShutdownHint.HARD_SHUTDOWN, HpackHuffmanDecoder.class, "decode(..)");
 
     private byte[] dest;
     private int k;

File: transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
Patch:
@@ -29,7 +29,6 @@
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ReadOnlyIterator;
-import io.netty.util.internal.ThrowableUtil;
 
 import java.util.Collections;
 import java.util.Iterator;
@@ -132,8 +131,8 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels, Executor executor, Obj
         this.maxChannels = maxChannels;
         this.executor = executor;
 
-        tooManyChannels = ThrowableUtil.unknownStackTrace(
-                ChannelException.newStatic("too many channels (max: " + maxChannels + ')', null),
+        tooManyChannels =
+                ChannelException.newStatic("too many channels (max: " + maxChannels + ')',
                 ThreadPerChannelEventLoopGroup.class, "nextChild()");
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/Cookie.java
Patch:
@@ -127,7 +127,7 @@ public interface Cookie extends Comparable<Cookie> {
      * Checks to see if this {@link Cookie} can only be accessed via HTTP.
      * If this returns true, the {@link Cookie} cannot be accessed through
      * client side script - But only if the browser supports it.
-     * For more information, please look <a href="http://www.owasp.org/index.php/HTTPOnly">here</a>
+     * For more information, please look <a href="https://owasp.org/www-community/HttpOnly">here</a>
      *
      * @return True if this {@link Cookie} is HTTP-only or false if it isn't
      */
@@ -138,7 +138,7 @@ public interface Cookie extends Comparable<Cookie> {
      * If set to true, this {@link Cookie} cannot be accessed by a client
      * side script. However, this works only if the browser supports it.
      * For for information, please look
-     * <a href="http://www.owasp.org/index.php/HTTPOnly">here</a>.
+     * <a href="https://owasp.org/www-community/HttpOnly">here</a>.
      *
      * @param httpOnly True if the {@link Cookie} is HTTP only, otherwise false.
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
Patch:
@@ -237,7 +237,7 @@ public boolean renameTo(File dest) throws IOException {
             return true;
         }
         int length = byteBuf.readableBytes();
-        int written = 0;
+        long written = 0;
         RandomAccessFile accessFile = new RandomAccessFile(dest, "rw");
         try {
             FileChannel fileChannel = accessFile.getChannel();

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanStageEncoder.java
Patch:
@@ -219,7 +219,7 @@ private void optimiseSelectorsAndHuffmanTables(final boolean storeSelectors) {
             final int groupEnd = Math.min(groupStart + HUFFMAN_GROUP_RUN_LENGTH, mtfLength) - 1;
 
             // Calculate the cost of this group when encoded by each table
-            short[] cost = new short[totalTables];
+            int[] cost = new int[totalTables];
             for (int i = groupStart; i <= groupEnd; i++) {
                 final int value = mtfBlock[i];
                 for (int j = 0; j < totalTables; j++) {

File: handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java
Patch:
@@ -165,7 +165,7 @@ public static SslContextBuilder forServer(KeyManagerFactory keyManagerFactory) {
     /**
      * Creates a builder for new server-side {@link SslContext} with {@link KeyManager}.
      *
-     * @param KeyManager non-{@code null} KeyManager for server's private key
+     * @param keyManager non-{@code null} KeyManager for server's private key
      */
     public static SslContextBuilder forServer(KeyManager keyManager) {
         return new SslContextBuilder(true).keyManager(keyManager);

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java
Patch:
@@ -38,7 +38,7 @@ public static MqttMessage newMessage(MqttFixedHeader mqttFixedHeader, Object var
             case SUBSCRIBE:
                 return new MqttSubscribeMessage(
                         mqttFixedHeader,
-                        (MqttMessageIdAndPropertiesVariableHeader) variableHeader,
+                        (MqttMessageIdVariableHeader) variableHeader,
                         (MqttSubscribePayload) payload);
 
             case SUBACK:
@@ -56,7 +56,7 @@ public static MqttMessage newMessage(MqttFixedHeader mqttFixedHeader, Object var
             case UNSUBSCRIBE:
                 return new MqttUnsubscribeMessage(
                         mqttFixedHeader,
-                        (MqttMessageIdAndPropertiesVariableHeader) variableHeader,
+                        (MqttMessageIdVariableHeader) variableHeader,
                         (MqttUnsubscribePayload) payload);
 
             case PUBLISH:

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java
Patch:
@@ -32,7 +32,7 @@ public MqttSubAckMessage(
             MqttFixedHeader mqttFixedHeader,
             MqttMessageIdVariableHeader variableHeader,
             MqttSubAckPayload payload) {
-        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);
+        this(mqttFixedHeader, variableHeader.withDefaultEmptyProperties(), payload);
     }
 
     @Override

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java
Patch:
@@ -33,7 +33,7 @@ public MqttSubscribeMessage(
             MqttFixedHeader mqttFixedHeader,
             MqttMessageIdVariableHeader variableHeader,
             MqttSubscribePayload payload) {
-        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);
+        this(mqttFixedHeader, variableHeader.withDefaultEmptyProperties(), payload);
     }
 
     @Override

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java
Patch:
@@ -24,7 +24,7 @@ public final class MqttUnsubAckMessage extends MqttMessage {
     public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,
                                MqttMessageIdAndPropertiesVariableHeader variableHeader,
                                MqttUnsubAckPayload payload) {
-        super(mqttFixedHeader, variableHeader, payload);
+        super(mqttFixedHeader, variableHeader, MqttUnsubAckPayload.withEmptyDefaults(payload));
     }
 
     public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java
Patch:
@@ -33,7 +33,7 @@ public MqttUnsubscribeMessage(
             MqttFixedHeader mqttFixedHeader,
             MqttMessageIdVariableHeader variableHeader,
             MqttUnsubscribePayload payload) {
-        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);
+        this(mqttFixedHeader, variableHeader.withDefaultEmptyProperties(), payload);
     }
 
     @Override

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java
Patch:
@@ -20,7 +20,7 @@
  */
 public final class MqttSubscriptionOption {
 
-    enum RetainedHandlingPolicy {
+    public enum RetainedHandlingPolicy {
         SEND_AT_SUBSCRIBE(0),
         SEND_AT_SUBSCRIBE_IF_NOT_YET_EXISTS(1),
         DONT_SEND_AT_SUBSCRIBE(2);

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -705,7 +705,7 @@ private int setCharSequence0(int index, CharSequence sequence, Charset charset,
             } else {
                 checkIndex(index, length);
             }
-            return ByteBufUtil.writeUtf8(this, index, sequence, sequence.length());
+            return ByteBufUtil.writeUtf8(this, index, length, sequence, sequence.length());
         }
         if (charset.equals(CharsetUtil.US_ASCII) || charset.equals(CharsetUtil.ISO_8859_1)) {
             int length = sequence.length();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/LinuxSocket.java
Patch:
@@ -45,7 +45,7 @@ final class LinuxSocket extends Socket {
         super(fd);
     }
 
-    private InternetProtocolFamily family() {
+    InternetProtocolFamily family() {
         return ipv6 ? InternetProtocolFamily.IPv6 : InternetProtocolFamily.IPv4;
     }
 

File: handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java
Patch:
@@ -29,7 +29,7 @@
  * will be accepted.
  *
  * If you would like to explicitly take action on rejected {@link Channel}s, you should override
- * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.
+ * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.
  */
 @Sharable
 public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageType.java
Patch:
@@ -33,7 +33,8 @@ public enum MqttMessageType {
     UNSUBACK(11),
     PINGREQ(12),
     PINGRESP(13),
-    DISCONNECT(14);
+    DISCONNECT(14),
+    AUTH(15);
 
     private final int value;
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -392,7 +392,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
             ByteBuffer[] nioBuffers = in.nioBuffers(1024, maxBytesPerGatheringWrite);
             int nioBufferCnt = in.nioBufferCount();
 
-            // Always us nioBuffers() to workaround data-corruption.
+            // Always use nioBuffers() to workaround data-corruption.
             // See https://github.com/netty/netty/issues/2761
             switch (nioBufferCnt) {
                 case 0:

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.util.IllegalReferenceCountException;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
@@ -152,7 +153,7 @@ public FullHttpRequest replace(ByteBuf content) {
     public int hashCode() {
         int hash = this.hash;
         if (hash == 0) {
-            if (content().refCnt() != 0) {
+            if (ByteBufUtil.isAccessible(content())) {
                 try {
                     hash = 31 + content().hashCode();
                 } catch (IllegalReferenceCountException ignored) {

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.util.IllegalReferenceCountException;
 
@@ -159,7 +160,7 @@ public FullHttpResponse replace(ByteBuf content) {
     public int hashCode() {
         int hash = this.hash;
         if (hash == 0) {
-            if (content().refCnt() != 0) {
+            if (ByteBufUtil.isAccessible(content())) {
                 try {
                     hash = 31 + content().hashCode();
                 } catch (IllegalReferenceCountException ignored) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -399,8 +399,8 @@ public DnsNameResolver(
         this.cnameCache = checkNotNull(cnameCache, "cnameCache");
         this.dnsQueryLifecycleObserverFactory = traceEnabled ?
                 dnsQueryLifecycleObserverFactory instanceof NoopDnsQueryLifecycleObserverFactory ?
-                        new TraceDnsQueryLifeCycleObserverFactory() :
-                        new BiDnsQueryLifecycleObserverFactory(new TraceDnsQueryLifeCycleObserverFactory(),
+                        new LoggingDnsQueryLifeCycleObserverFactory() :
+                        new BiDnsQueryLifecycleObserverFactory(new LoggingDnsQueryLifeCycleObserverFactory(),
                                                                dnsQueryLifecycleObserverFactory) :
                 checkNotNull(dnsQueryLifecycleObserverFactory, "dnsQueryLifecycleObserverFactory");
         this.searchDomains = searchDomains != null ? searchDomains.clone() : DEFAULT_SEARCH_DOMAINS;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -324,7 +324,10 @@ public DnsNameResolverBuilder maxQueriesPerResolve(int maxQueriesPerResolve) {
      *
      * @param traceEnabled true if trace is enabled
      * @return {@code this}
+     * @deprecated Prefer to {@linkplain #dnsQueryLifecycleObserverFactory(DnsQueryLifecycleObserverFactory) configure}
+     * a {@link LoggingDnsQueryLifeCycleObserverFactory} instead.
      */
+    @Deprecated
     public DnsNameResolverBuilder traceEnabled(boolean traceEnabled) {
         this.traceEnabled = traceEnabled;
         return this;

File: resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java
Patch:
@@ -26,13 +26,13 @@
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
-final class TraceDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {
+final class LoggingDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {
     private final InternalLogger logger;
     private final InternalLogLevel level;
     private final DnsQuestion question;
     private InetSocketAddress dnsServerAddress;
 
-    TraceDnsQueryLifecycleObserver(DnsQuestion question, InternalLogger logger, InternalLogLevel level) {
+    LoggingDnsQueryLifecycleObserver(DnsQuestion question, InternalLogger logger, InternalLogLevel level) {
         this.question = checkNotNull(question, "question");
         this.logger = checkNotNull(logger, "logger");
         this.level = checkNotNull(level, "level");

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -36,7 +36,7 @@
  * A {@link DnsNameResolver} builder.
  */
 public final class DnsNameResolverBuilder {
-    private EventLoop eventLoop;
+    volatile EventLoop eventLoop;
     private ChannelFactory<? extends DatagramChannel> channelFactory;
     private ChannelFactory<? extends SocketChannel> socketChannelFactory;
     private DnsCache resolveCache;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -274,7 +274,7 @@ public ChannelFuture writePriority(ChannelHandlerContext ctx, int streamId,
             int streamDependency, short weight, boolean exclusive, ChannelPromise promise) {
         try {
             verifyStreamId(streamId, STREAM_ID);
-            verifyStreamId(streamDependency, STREAM_DEPENDENCY);
+            verifyStreamOrConnectionId(streamDependency, STREAM_DEPENDENCY);
             verifyWeight(weight);
 
             ByteBuf buf = ctx.alloc().buffer(PRIORITY_FRAME_LENGTH);
@@ -602,11 +602,11 @@ private static void writePaddingLength(ByteBuf buf, int padding) {
     }
 
     private static void verifyStreamId(int streamId, String argumentName) {
-        checkPositive(streamId, "streamId");
+        checkPositive(streamId, argumentName);
     }
 
     private static void verifyStreamOrConnectionId(int streamId, String argumentName) {
-        checkPositiveOrZero(streamId, "streamId");
+        checkPositiveOrZero(streamId, argumentName);
     }
 
     private static void verifyWeight(short weight) {

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -260,9 +260,6 @@ public ApplicationProtocolConfig.SelectedListenerFailureBehavior selectedListene
             int options = SSLContext.getOptions(ctx) |
                           SSL.SSL_OP_NO_SSLv2 |
                           SSL.SSL_OP_NO_SSLv3 |
-                          // Disable TLSv1.3 by default for now. Even if TLSv1.3 is not supported this will
-                          // work fine as in this case SSL_OP_NO_TLSv1_3 will be 0.
-                          SSL.SSL_OP_NO_TLSv1_3 |
 
                           SSL.SSL_OP_CIPHER_SERVER_PREFERENCE |
 

File: handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
Patch:
@@ -66,7 +66,8 @@ static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date
         info.set(X509CertInfo.VALIDITY, new CertificateValidity(notBefore, notAfter));
         info.set(X509CertInfo.KEY, new CertificateX509Key(keypair.getPublic()));
         info.set(X509CertInfo.ALGORITHM_ID,
-                new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha256WithRSAEncryption_oid)));
+                // sha256WithRSAEncryption
+                new CertificateAlgorithmId(AlgorithmId.get("1.2.840.113549.1.1.11")));
 
         // Sign the cert to identify the algorithm that's used.
         X509CertImpl cert = new X509CertImpl(info);

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -120,7 +120,8 @@ public final class OpenSsl {
         } else {
             // Test if netty-tcnative is in the classpath first.
             try {
-                Class.forName("io.netty.internal.tcnative.SSLContext", false, OpenSsl.class.getClassLoader());
+                Class.forName("io.netty.internal.tcnative.SSLContext", false,
+                        PlatformDependent.getClassLoader(OpenSsl.class));
             } catch (ClassNotFoundException t) {
                 cause = t;
                 logger.debug(
@@ -586,7 +587,7 @@ private static void loadTcNative() throws Exception {
         libNames.add(staticLibName + "_" + arch);
         libNames.add(staticLibName);
 
-        NativeLibraryLoader.loadFirstAvailable(SSLContext.class.getClassLoader(),
+        NativeLibraryLoader.loadFirstAvailable(PlatformDependent.getClassLoader(SSLContext.class),
             libNames.toArray(new String[0]));
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -675,7 +675,7 @@ public void writabilityChanged(Http2Stream stream) {
     static class DefaultHttp2FrameStream implements Http2FrameStream {
 
         private volatile int id = -1;
-        volatile Http2Stream stream;
+        private volatile Http2Stream stream;
 
         final Http2FrameStreamEvent stateChanged = Http2FrameStreamEvent.stateChanged(this);
         final Http2FrameStreamEvent writabilityChanged = Http2FrameStreamEvent.writabilityChanged(this);

File: example/src/main/java/io/netty/example/http2/helloworld/frame/client/Http2FrameClient.java
Patch:
@@ -103,7 +103,7 @@ public static void main(String[] args) throws Exception {
             headers.method("GET");
             headers.path(PATH);
             headers.scheme(SSL? "https" : "http");
-            final Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(headers);
+            final Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(headers, true);
             streamChannel.writeAndFlush(headersFrame);
             System.out.println("Sent HTTP/2 GET request to " + PATH);
 

File: codec/src/main/java/io/netty/handler/codec/CodecOutputList.java
Patch:
@@ -206,7 +206,8 @@ Object getUnsafe(int index) {
 
     private void checkIndex(int index) {
         if (index >= size) {
-            throw new IndexOutOfBoundsException();
+            throw new IndexOutOfBoundsException("expected: index < ("
+                    + size + "),but actual is (" + size + ")");
         }
     }
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -1146,6 +1146,8 @@ private static long maxDirectMemory0() {
                     case 'g': case 'G':
                         maxDirectMemory *= 1024 * 1024 * 1024;
                         break;
+                    default:
+                        break;
                 }
                 break;
             }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -738,6 +738,8 @@ private static void processSelectedKey(SelectionKey k, NioTask<SelectableChannel
                     invokeChannelUnregistered(task, k, null);
                 }
                 break;
+            default:
+                 break;
             }
         }
     }

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -922,7 +922,7 @@ public Object run() {
         }
 
         static <T> Queue<T> newMpscQueue(final int maxCapacity) {
-            // Calculate the max capacity which can not be bigger then MAX_ALLOWED_MPSC_CAPACITY.
+            // Calculate the max capacity which can not be bigger than MAX_ALLOWED_MPSC_CAPACITY.
             // This is forced by the MpscChunkedArrayQueue implementation as will try to round it
             // up to the next power of two and so will overflow otherwise.
             final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -73,9 +73,6 @@ public final class ReferenceCountedOpenSslClientContext extends ReferenceCounted
         try {
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,
                                                keyCertChain, key, keyPassword, keyManagerFactory, keyStore);
-            if (ENABLE_SESSION_TICKET) {
-                sessionContext.setTicketKeys();
-            }
             success = true;
         } finally {
             if (!success) {
@@ -170,6 +167,9 @@ static OpenSslSessionContext newSessionContext(ReferenceCountedOpenSslContext th
                 throw new SSLException("unable to setup trustmanager", e);
             }
             OpenSslClientSessionContext context = new OpenSslClientSessionContext(thiz, keyMaterialProvider);
+            if (ENABLE_SESSION_TICKET) {
+                context.setTicketKeys();
+            }
             keyMaterialProvider = null;
             return context;
         } finally {

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -120,7 +120,7 @@ public final class OpenSsl {
         } else {
             // Test if netty-tcnative is in the classpath first.
             try {
-                Class.forName("io.netty.internal.tcnative.SSL", false, OpenSsl.class.getClassLoader());
+                Class.forName("io.netty.internal.tcnative.SSLContext", false, OpenSsl.class.getClassLoader());
             } catch (ClassNotFoundException t) {
                 cause = t;
                 logger.debug(
@@ -586,7 +586,7 @@ private static void loadTcNative() throws Exception {
         libNames.add(staticLibName + "_" + arch);
         libNames.add(staticLibName);
 
-        NativeLibraryLoader.loadFirstAvailable(SSL.class.getClassLoader(),
+        NativeLibraryLoader.loadFirstAvailable(SSLContext.class.getClassLoader(),
             libNames.toArray(new String[0]));
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDynamicTable.java
Patch:
@@ -83,7 +83,7 @@ public long capacity() {
      */
     public HpackHeaderField getEntry(int index) {
         if (index <= 0 || index > length()) {
-            throw new IndexOutOfBoundsException();
+            throw new IndexOutOfBoundsException("Index " + index + " out of bounds for length " + length());
         }
         int i = head - index;
         if (i < 0) {

File: common/src/main/java/io/netty/util/ResourceLeakDetectorFactory.java
Patch:
@@ -88,7 +88,8 @@ public abstract <T> ResourceLeakDetector<T> newResourceLeakDetector(
      */
     @SuppressWarnings("deprecation")
     public <T> ResourceLeakDetector<T> newResourceLeakDetector(Class<T> resource, int samplingInterval) {
-        return newResourceLeakDetector(resource, ResourceLeakDetector.SAMPLING_INTERVAL, Long.MAX_VALUE);
+        ObjectUtil.checkPositive(samplingInterval, "samplingInterval");
+        return newResourceLeakDetector(resource, samplingInterval, Long.MAX_VALUE);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java
Patch:
@@ -229,7 +229,7 @@ public final class HttpHeaderValues {
      */
     public static final AsciiString WEBSOCKET = AsciiString.cached("websocket");
     /**
-     * {@code "websocket"}
+     * {@code "XmlHttpRequest"}
      */
     public static final AsciiString XML_HTTP_REQUEST = AsciiString.cached("XmlHttpRequest");
 

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspObjectDecoder.java
Patch:
@@ -20,6 +20,8 @@
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpObjectDecoder;
 
+import static io.netty.handler.codec.rtsp.RtspDecoder.DEFAULT_MAX_CONTENT_LENGTH;
+
 /**
  * Decodes {@link ByteBuf}s into RTSP messages represented in
  * {@link HttpMessage}s.
@@ -59,7 +61,7 @@ public abstract class RtspObjectDecoder extends HttpObjectDecoder {
      * {@code maxContentLength (8192)}.
      */
     protected RtspObjectDecoder() {
-        this(4096, 8192, 8192);
+        this(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, DEFAULT_MAX_CONTENT_LENGTH);
     }
 
     /**

File: handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
Patch:
@@ -473,7 +473,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
         channel.flushInbound();
         assertNull(channel.readInbound());
 
-        Thread.sleep(delayMillis);
+        Thread.sleep(delayMillis + 20L);
         channel.runPendingTasks();
         assertEquals(IdleStateEvent.FIRST_READER_IDLE_STATE_EVENT, userEvents.poll());
         assertFalse(channel.finish());

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -300,7 +300,7 @@ public static void set100ContinueExpected(HttpMessage message, boolean expected)
      * @return True if transfer encoding is chunked, otherwise false
      */
     public static boolean isTransferEncodingChunked(HttpMessage message) {
-        return message.headers().contains(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED, true);
+        return message.headers().containsValue(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED, true);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -147,8 +147,8 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             res.headers().add(headers);
         }
 
-        res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
-        res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
+        res.headers().set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
+                     .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
 
         // Fill in the headers and contents depending on handshake getMethod.
         if (isHixie76) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -149,9 +149,9 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             logger.debug("WebSocket version 07 server handshake key: {}, response: {}.", key, accept);
         }
 
-        res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
-        res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
-        res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
+        res.headers().set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
+                     .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
+                     .set(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
 
         String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         if (subprotocols != null) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -155,9 +155,9 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             logger.debug("WebSocket version 08 server handshake key: {}, response: {}", key, accept);
         }
 
-        res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
-        res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
-        res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
+        res.headers().set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
+                     .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
+                     .set(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
 
         String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         if (subprotocols != null) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -153,9 +153,9 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             logger.debug("WebSocket version 13 server handshake key: {}, response: {}", key, accept);
         }
 
-        res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
-        res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
-        res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
+        res.headers().set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
+                     .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
+                     .set(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
 
         String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         if (subprotocols != null) {

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -377,9 +377,9 @@ void reclaimAllSpaceAndUnlink() {
         void add(DefaultHandle<?> handle) {
             handle.lastRecycledId = id;
 
-            // While we also enforce the recycling ratio one we transfer objects from the WeakOrderQueue to the Stack
+            // While we also enforce the recycling ratio when we transfer objects from the WeakOrderQueue to the Stack
             // we better should enforce it as well early. Missing to do so may let the WeakOrderQueue grow very fast
-            // without control if the Stack
+            // without control
             if (handleRecycleCount < interval) {
                 handleRecycleCount++;
                 // Drop the item to prevent recycling to aggressive.

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -529,8 +529,7 @@ public final void setPrivateKeyMethod(OpenSslPrivateKeyMethod method) {
         }
     }
 
-    // Exposed for testing only
-    final void setUseTasks(boolean useTasks) {
+    public final void setUseTasks(boolean useTasks) {
         Lock writerLock = ctxLock.writeLock();
         writerLock.lock();
         try {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java
Patch:
@@ -986,7 +986,9 @@ static String decodeDomainName(ByteBuf in) {
 
     private DnsServerAddressStream getNameServers(String hostname) {
         DnsServerAddressStream stream = getNameServersFromCache(hostname);
-        return stream == null ? nameServerAddrs.duplicate() : stream;
+        // We need to obtain a new stream from the parent DnsNameResolver as the hostname may not be the same as the
+        // one used for the original query (for example we may follow CNAMEs).
+        return stream == null ? parent.newNameServerAddressStream(hostname) : stream;
     }
 
     private void followCname(DnsQuestion question, String cname, DnsQueryLifecycleObserver queryLifecycleObserver,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -31,7 +31,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
 import io.netty.handler.codec.http2.Http2Exception.StreamException;
-import io.netty.handler.codec.http2.Http2Stream.State;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.UnstableApi;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
Patch:
@@ -37,7 +37,6 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static io.netty.handler.codec.http2.HpackUtil.equalsConstantTime;
 import static io.netty.handler.codec.http2.HpackUtil.equalsVariableTime;
 
 final class HpackStaticTable {

File: codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
Patch:
@@ -185,7 +185,7 @@ public void testBackslashInString1() {
         EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
         // {"foo" : "bar\""}
         String json = "{\"foo\" : \"bar\\\"\"}";
-        System.out.println(json);
+
         ch.writeInbound(Unpooled.copiedBuffer(json, CharsetUtil.UTF_8));
 
         ByteBuf res = ch.readInbound();
@@ -200,7 +200,7 @@ public void testBackslashInString2() {
         EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
         // {"foo" : "bar\\"}
         String json = "{\"foo\" : \"bar\\\\\"}";
-        System.out.println(json);
+
         ch.writeInbound(Unpooled.copiedBuffer(json, CharsetUtil.UTF_8));
 
         ByteBuf res = ch.readInbound();
@@ -215,7 +215,7 @@ public void testBackslashInString3() {
         EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
         // {"foo" : "bar\\\""}
         String json = "{\"foo\" : \"bar\\\\\\\"\"}";
-        System.out.println(json);
+
         ch.writeInbound(Unpooled.copiedBuffer(json, CharsetUtil.UTF_8));
 
         ByteBuf res = ch.readInbound();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -28,7 +28,6 @@
 import java.util.Queue;
 
 import static io.netty.handler.codec.http.HttpStatusClass.INFORMATIONAL;
-import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;

File: codec-http/src/test/java/io/netty/handler/codec/rtsp/RtspDecoderTest.java
Patch:
@@ -59,7 +59,6 @@ public void testReceiveAnnounce() {
                         Unpooled.wrappedBuffer(data2));
 
         HttpObject res1 = ch.readInbound();
-        System.out.println(res1);
         assertNotNull(res1);
         assertTrue(res1 instanceof FullHttpRequest);
         ((FullHttpRequest) res1).release();

File: handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java
Patch:
@@ -144,7 +144,8 @@ public SSLEngine wrapSslEngine(SSLEngine engine, ByteBufAllocator alloc,
                 return isServer ? JettyAlpnSslEngine.newServerEngine(engine, applicationNegotiator)
                         : JettyAlpnSslEngine.newClientEngine(engine, applicationNegotiator);
             }
-            throw new RuntimeException("Unable to wrap SSLEngine of type " + engine.getClass().getName());
+            throw new UnsupportedOperationException("ALPN not supported. Unable to wrap SSLEngine of type '"
+                    + engine.getClass().getName() + "')");
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -124,8 +124,8 @@ public void setContent(ByteBuf buffer) throws IOException {
                 return;
             }
             RandomAccessFile accessFile = new RandomAccessFile(file, "rw");
-            accessFile.setLength(0);
             try {
+                accessFile.setLength(0);
                 FileChannel localfileChannel = accessFile.getChannel();
                 ByteBuffer byteBuffer = buffer.nioBuffer();
                 int written = 0;
@@ -216,9 +216,9 @@ public void setContent(InputStream inputStream) throws IOException {
         }
         file = tempFile();
         RandomAccessFile accessFile = new RandomAccessFile(file, "rw");
-        accessFile.setLength(0);
         int written = 0;
         try {
+            accessFile.setLength(0);
             FileChannel localfileChannel = accessFile.getChannel();
             byte[] bytes = new byte[4096 * 4];
             ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);

File: handler/src/main/java/io/netty/handler/ssl/Conscrypt.java
Patch:
@@ -56,7 +56,8 @@ private static boolean canInstanceProvider() {
      * Indicates whether or not conscrypt is available on the current system.
      */
     static boolean isAvailable() {
-        return CAN_INSTANCE_PROVIDER && IS_CONSCRYPT_SSLENGINE != null && PlatformDependent.javaVersion() >= 8;
+        return CAN_INSTANCE_PROVIDER && IS_CONSCRYPT_SSLENGINE != null &&
+            (PlatformDependent.javaVersion() >= 8 || PlatformDependent.isAndroid());
     }
 
     static boolean isEngineSupported(SSLEngine engine) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -160,7 +160,9 @@ private static boolean anyInterfaceSupportsIpV6() {
                 NetworkInterface iface = interfaces.nextElement();
                 Enumeration<InetAddress> addresses = iface.getInetAddresses();
                 while (addresses.hasMoreElements()) {
-                    if (addresses.nextElement() instanceof Inet6Address) {
+                    InetAddress inetAddress = addresses.nextElement();
+                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() &&
+                        !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {
                         return true;
                     }
                 }

File: buffer/src/main/java/io/netty/buffer/PoolChunkList.java
Patch:
@@ -96,15 +96,15 @@ void prevList(PoolChunkList<T> prevList) {
         this.prevList = prevList;
     }
 
-    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {
+    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity, PoolThreadCache threadCache) {
         if (normCapacity > maxCapacity) {
             // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can
             // be handled by the PoolChunks that are contained in this PoolChunkList.
             return false;
         }
 
         for (PoolChunk<T> cur = head; cur != null; cur = cur.next) {
-            if (cur.allocate(buf, reqCapacity, normCapacity)) {
+            if (cur.allocate(buf, reqCapacity, normCapacity, threadCache)) {
                 if (cur.freeBytes <= freeMinThreshold) {
                     remove(cur);
                     nextList.add(cur);

File: transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java
Patch:
@@ -60,7 +60,6 @@
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
 
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -155,13 +154,14 @@ public void testHandshakeWithExecutor() throws Exception {
     }
 
     private static void testHandshakeWithExecutor(Executor executor) throws Exception {
+        String tlsVersion = "TLSv1.2";
         final SslContext sslClientCtx = SslContextBuilder.forClient()
                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
-                .sslProvider(SslProvider.JDK).build();
+                .sslProvider(SslProvider.JDK).protocols(tlsVersion).build();
 
         final SelfSignedCertificate cert = new SelfSignedCertificate();
         final SslContext sslServerCtx = SslContextBuilder.forServer(cert.key(), cert.cert())
-                .sslProvider(SslProvider.JDK).build();
+                .sslProvider(SslProvider.JDK).protocols(tlsVersion).build();
 
         EventLoopGroup group = new NioEventLoopGroup();
         Channel sc = null;

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -2979,8 +2979,8 @@ private void testSessionAfterHandshake0(boolean useKeyManagerFactory, boolean mu
 
             assertNotNull(clientSession.getSessionContext());
 
-            // Workaround for possible JDK 14 regression.
-            // See http://mail.openjdk.java.net/pipermail/security-dev/2020-March/021488.html
+            // Workaround for JDK 14 regression.
+            // See https://bugs.openjdk.java.net/browse/JDK-8242008
             if (PlatformDependent.javaVersion() < 14) {
                 assertNotNull(serverSession.getSessionContext());
             }

File: common/src/main/java/io/netty/util/DomainMappingBuilder.java
Patch:
@@ -20,7 +20,7 @@
  * Builder for immutable {@link DomainNameMapping} instances.
  *
  * @param <V> concrete type of value objects
- * @deprecated Use {@link DomainNameMappingBuilder} instead.
+ * @deprecated Use {@link DomainWildcardMappingBuilder} instead.
  */
 @Deprecated
 public final class DomainMappingBuilder<V> {

File: common/src/main/java/io/netty/util/DomainNameMapping.java
Patch:
@@ -33,7 +33,9 @@
  * DNS wildcard is supported as hostname, so you can use {@code *.netty.io} to match both {@code netty.io}
  * and {@code downloads.netty.io}.
  * </p>
+ * @deprecated Use {@link DomainWildcardMappingBuilder}}
  */
+@Deprecated
 public class DomainNameMapping<V> implements Mapping<String, V> {
 
     final V defaultValue;

File: common/src/main/java/io/netty/util/DomainNameMappingBuilder.java
Patch:
@@ -27,7 +27,9 @@
  * Builder for immutable {@link DomainNameMapping} instances.
  *
  * @param <V> concrete type of value objects
+ * @deprecated Use {@link DomainWildcardMappingBuilder}
  */
+@Deprecated
 public final class DomainNameMappingBuilder<V> {
 
     private final V defaultValue;

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -64,7 +64,7 @@
  *      extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {
  *
  *   protected void decode({@link ChannelHandlerContext} ctx,
- *                           {@link ByteBuf} buf) throws Exception {
+ *                           {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {
  *
  *     out.add(buf.readBytes(buf.readInt()));
  *   }

File: transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.channel.ThreadPerChannelEventLoopGroup;
 
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 
 /**
@@ -53,7 +52,7 @@ public OioEventLoopGroup() {
      *                          Use {@code 0} to use no limit
      */
     public OioEventLoopGroup(int maxChannels) {
-        this(maxChannels, Executors.defaultThreadFactory());
+        this(maxChannels, (ThreadFactory) null);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -241,7 +241,7 @@ protected FullHttpRequest newHandshakeRequest() {
             headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
 
-        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, "7");
+        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, version().toAsciiString());
         return request;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -243,7 +243,7 @@ protected FullHttpRequest newHandshakeRequest() {
             headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
 
-        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, "8");
+        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, version().toAsciiString());
         return request;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -244,7 +244,7 @@ protected FullHttpRequest newHandshakeRequest() {
             headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
 
-        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, "13");
+        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, version().toAsciiString());
         return request;
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
Patch:
@@ -364,7 +364,9 @@ public void testDuplicateWebsocketHandshakeHeaders() {
 
         // add values for the headers that are reserved for use in the websockets handshake
         for (CharSequence header : getHandshakeRequiredHeaderNames()) {
-            inputHeaders.add(header, bogusHeaderValue);
+            if (!HttpHeaderNames.HOST.equals(header)) {
+                inputHeaders.add(header, bogusHeaderValue);
+            }
         }
         inputHeaders.add(getProtocolHeaderName(), bogusSubProtocol);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -811,7 +811,7 @@ private Attribute getContentDispositionAttribute(String... values) {
         } else if (FILENAME_ENCODED.equals(name)) {
             try {
                 name = HttpHeaderValues.FILENAME.toString();
-                String[] split = value.split("'", 3);
+                String[] split = cleanString(value).split("'", 3);
                 value = QueryStringDecoder.decodeComponent(split[2], Charset.forName(split[0]));
             } catch (ArrayIndexOutOfBoundsException e) {
                  throw new ErrorDataDecoderException(e);

File: codec/src/main/java/io/netty/handler/codec/ProtocolDetectionResult.java
Patch:
@@ -25,7 +25,7 @@
 public final class ProtocolDetectionResult<T> {
 
     @SuppressWarnings({ "rawtypes", "unchecked" })
-    private static final ProtocolDetectionResult NEEDS_MORE_DATE =
+    private static final ProtocolDetectionResult NEEDS_MORE_DATA =
             new ProtocolDetectionResult(ProtocolDetectionState.NEEDS_MORE_DATA, null);
     @SuppressWarnings({ "rawtypes", "unchecked" })
     private static final ProtocolDetectionResult INVALID =
@@ -39,7 +39,7 @@ public final class ProtocolDetectionResult<T> {
      */
     @SuppressWarnings("unchecked")
     public static <T> ProtocolDetectionResult<T> needsMoreData() {
-        return NEEDS_MORE_DATE;
+        return NEEDS_MORE_DATA;
     }
 
     /**

File: common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
Patch:
@@ -109,7 +109,7 @@ void setConsumed() {
         // Optimization to avoid checking system clock again
         // after deadline has passed and task has been dequeued
         if (periodNanos == 0) {
-            assert nanoTime() > deadlineNanos;
+            assert nanoTime() >= deadlineNanos;
             deadlineNanos = 0L;
         }
     }

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -607,7 +607,7 @@ static int calculateChecksum(ByteBuf data, int offset, int length) {
         Crc32c crc32 = new Crc32c();
         try {
             crc32.update(data, offset, length);
-            return maskChecksum((int) crc32.getValue());
+            return maskChecksum(crc32.getValue());
         } finally {
             crc32.reset();
         }
@@ -655,7 +655,7 @@ static void validateChecksum(int expectedChecksum, ByteBuf data, int offset, int
      * @param checksum The actual checksum of the data
      * @return The masked checksum
      */
-    static int maskChecksum(int checksum) {
-        return (checksum >> 15 | checksum << 17) + 0xa282ead8;
+    static int maskChecksum(long checksum) {
+        return (int) ((checksum >> 15 | checksum << 17) + 0xa282ead8);
     }
 }

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFrameDecoderTest.java
Patch:
@@ -168,7 +168,7 @@ public void testInvalidChecksumDoesNotThrowException() throws Exception {
             // checksum here is presented as a282986f (little endian)
             ByteBuf in = Unpooled.wrappedBuffer(new byte[]{
                     (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
-                    0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y'
+                    0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, 0x2e, -0x47, 'n', 'e', 't', 't', 'y'
             });
 
             assertTrue(channel.writeInbound(in));

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -2012,7 +2012,8 @@ public void run() {
                 if (localHandshakePromise.isDone()) {
                     return;
                 }
-                SSLException exception = new SSLException("handshake timed out");
+                SSLException exception =
+                        new SslHandshakeTimeoutException("handshake timed out after " + handshakeTimeoutMillis + "ms");
                 try {
                     if (localHandshakePromise.tryFailure(exception)) {
                         SslUtils.handleHandshakeFailure(ctx, exception, true);

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -194,12 +194,12 @@ public boolean isActive() {
         assertFalse(ch.finishAndReleaseAll());
     }
 
-    @Test(expected = SSLException.class, timeout = 3000)
+    @Test(expected = SslHandshakeTimeoutException.class, timeout = 3000)
     public void testClientHandshakeTimeout() throws Exception {
         testHandshakeTimeout(true);
     }
 
-    @Test(expected = SSLException.class, timeout = 3000)
+    @Test(expected = SslHandshakeTimeoutException.class, timeout = 3000)
     public void testServerHandshakeTimeout() throws Exception {
         testHandshakeTimeout(false);
     }

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
Patch:
@@ -22,18 +22,18 @@
 import io.netty.channel.ChannelInboundHandler;
 import io.netty.channel.sctp.SctpMessage;
 import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.util.collection.IntObjectHashMap;
+import io.netty.util.collection.IntObjectMap;
 
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 /**
  * {@link MessageToMessageDecoder} which will take care of handle fragmented {@link SctpMessage}s, so
  * only <strong>complete</strong> {@link SctpMessage}s will be forwarded to the next
  * {@link ChannelInboundHandler}.
  */
 public class SctpMessageCompletionHandler extends MessageToMessageDecoder<SctpMessage> {
-    private final Map<Integer, ByteBuf> fragments = new HashMap<Integer, ByteBuf>();
+    private final IntObjectMap<ByteBuf> fragments = new IntObjectHashMap<ByteBuf>();
 
     @Override
     protected void decode(ChannelHandlerContext ctx, SctpMessage msg, List<Object> out) throws Exception {

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -267,7 +267,7 @@ public ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean
             }
             future = voidFuture;
         } else {
-            Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
+            Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(nonServerChannels.size());
             for (Channel c: nonServerChannels.values()) {
                 if (matcher.matches(c)) {
                     futures.put(c, c.write(safeDuplicate(message)));
@@ -400,7 +400,7 @@ public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher,
             }
             future = voidFuture;
         } else {
-            Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
+            Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(nonServerChannels.size());
             for (Channel c: nonServerChannels.values()) {
                 if (matcher.matches(c)) {
                     futures.put(c, c.writeAndFlush(safeDuplicate(message)));

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -197,7 +197,7 @@ public void onTimeout(AcquireTask task) {
                         task.promise.setFailure(new TimeoutException(
                                 "Acquire operation took longer then configured maximum time") {
                             @Override
-                            public synchronized Throwable fillInStackTrace() {
+                            public Throwable fillInStackTrace() {
                                 return this;
                             }
                         });

File: codec-http/src/test/java/io/netty/handler/codec/rtsp/RtspDecoderTest.java
Patch:
@@ -65,7 +65,6 @@ public void testReceiveAnnounce() {
         ((FullHttpRequest) res1).release();
 
         HttpObject res2 = ch.readInbound();
-        System.out.println(res2);
         assertNotNull(res2);
         assertTrue(res2 instanceof FullHttpResponse);
         ((FullHttpResponse) res2).release();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -214,8 +214,8 @@ private int unconsumedBytes(Http2Stream stream) {
 
     void onGoAwayRead0(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)
             throws Http2Exception {
-        connection.goAwayReceived(lastStreamId, errorCode, debugData);
         listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);
+        connection.goAwayReceived(lastStreamId, errorCode, debugData);
     }
 
     void onUnknownFrame0(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,

File: buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
Patch:
@@ -49,7 +49,7 @@ final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf {
             order = ByteOrder.BIG_ENDIAN;
             nioBufferCount = 1;
             capacity = 0;
-            direct = false;
+            direct = Unpooled.EMPTY_BUFFER.isDirect();
         } else {
             ByteBuf b = buffers[0];
             this.buffers = buffers;

File: buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
Patch:
@@ -432,10 +432,12 @@ public void testHasArrayWithSingleBuffer() {
     }
 
     @Test
-    public void testHasArrayWhenEmpty() {
+    public void testHasArrayWhenEmptyAndIsDirect() {
         ByteBuf buf = newBuffer(new ByteBuf[0]);
         assertTrue(buf.hasArray());
         assertArrayEquals(EMPTY_BUFFER.array(), buf.array());
+        assertEquals(EMPTY_BUFFER.isDirect(), buf.isDirect());
+        assertEquals(EMPTY_BUFFER.memoryAddress(), buf.memoryAddress());
         buf.release();
     }
 

File: codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java
Patch:
@@ -23,7 +23,7 @@ protected ZlibEncoder createEncoder(ZlibWrapper wrapper) {
     }
 
     @Override
-    protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
-        return new JZlibDecoder(wrapper);
+    protected ZlibDecoder createDecoder(ZlibWrapper wrapper, int maxAllocation) {
+        return new JZlibDecoder(wrapper, maxAllocation);
     }
 }

File: codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java
Patch:
@@ -38,8 +38,8 @@ protected ZlibEncoder createEncoder(ZlibWrapper wrapper) {
     }
 
     @Override
-    protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
-        return new JdkZlibDecoder(wrapper);
+    protected ZlibDecoder createDecoder(ZlibWrapper wrapper, int maxAllocation) {
+        return new JdkZlibDecoder(wrapper, maxAllocation);
     }
 
     @Test(expected = DecompressionException.class)

File: codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest1.java
Patch:
@@ -23,7 +23,7 @@ protected ZlibEncoder createEncoder(ZlibWrapper wrapper) {
     }
 
     @Override
-    protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
-        return new JZlibDecoder(wrapper);
+    protected ZlibDecoder createDecoder(ZlibWrapper wrapper, int maxAllocation) {
+        return new JZlibDecoder(wrapper, maxAllocation);
     }
 }

File: codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest2.java
Patch:
@@ -25,8 +25,8 @@ protected ZlibEncoder createEncoder(ZlibWrapper wrapper) {
     }
 
     @Override
-    protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
-        return new JdkZlibDecoder(wrapper);
+    protected ZlibDecoder createDecoder(ZlibWrapper wrapper, int maxAllocation) {
+        return new JdkZlibDecoder(wrapper, maxAllocation);
     }
 
     @Test(expected = DecompressionException.class)

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -934,7 +934,7 @@ public void testHandshakeWithExecutor() throws Exception {
         }
     }
 
-    private void testHandshakeWithExecutor(Executor executor) throws Exception {
+    private static void testHandshakeWithExecutor(Executor executor) throws Exception {
         final SslContext sslClientCtx = SslContextBuilder.forClient()
                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
                 .sslProvider(SslProvider.JDK).build();
@@ -991,7 +991,7 @@ public void testServerHandshakeTimeoutBecauseExecutorNotExecute() throws Excepti
         testHandshakeTimeoutBecauseExecutorNotExecute(false);
     }
 
-    private void testHandshakeTimeoutBecauseExecutorNotExecute(final boolean client) throws Exception {
+    private static void testHandshakeTimeoutBecauseExecutorNotExecute(final boolean client) throws Exception {
         final SslContext sslClientCtx = SslContextBuilder.forClient()
                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
                 .sslProvider(SslProvider.JDK).build();

File: handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
Patch:
@@ -286,7 +286,7 @@ private static SSLContext newSSLContext(Provider sslContextProvider,
                 trustManagerFactory = buildTrustManagerFactory(trustCertCollection, trustManagerFactory, keyStore);
             }
             if (keyCertChain != null) {
-                keyManagerFactory = buildKeyManagerFactory(keyCertChain, key, keyPassword, keyManagerFactory, null);
+                keyManagerFactory = buildKeyManagerFactory(keyCertChain, key, keyPassword, keyManagerFactory, keyStore);
             }
             SSLContext ctx = sslContextProvider == null ? SSLContext.getInstance(PROTOCOL)
                 : SSLContext.getInstance(PROTOCOL, sslContextProvider);

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -154,6 +154,8 @@ protected final ByteBuffer internalNioBuffer() {
         ByteBuffer tmpNioBuf = this.tmpNioBuf;
         if (tmpNioBuf == null) {
             this.tmpNioBuf = tmpNioBuf = newInternalNioBuffer(memory);
+        } else {
+            tmpNioBuf.clear();
         }
         return tmpNioBuf;
     }

File: buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
Patch:
@@ -260,7 +260,7 @@ public ByteBuf setBytes(int index, ByteBuffer src) {
         }
 
         index = idx(index);
-        tmpBuf.clear().position(index).limit(index + length);
+        tmpBuf.limit(index + length).position(index);
         tmpBuf.put(src);
         return this;
     }
@@ -274,7 +274,7 @@ public int setBytes(int index, InputStream in, int length) throws IOException {
             return readBytes;
         }
         ByteBuffer tmpBuf = internalNioBuffer();
-        tmpBuf.clear().position(idx(index));
+        tmpBuf.position(idx(index));
         tmpBuf.put(tmp, 0, readBytes);
         return readBytes;
     }

File: transport/src/test/java/io/netty/channel/pool/SimpleChannelPoolTest.java
Patch:
@@ -334,8 +334,8 @@ protected void initChannel(LocalChannel ch) throws Exception {
         final SimpleChannelPool pool = new SimpleChannelPool(bootstrap, new CountingChannelPoolHandler());
         Channel ch1 = pool.acquire().syncUninterruptibly().getNow();
         Channel ch2 = pool.acquire().syncUninterruptibly().getNow();
-        pool.release(ch1);
-        pool.release(ch2);
+        pool.release(ch1).get(1, TimeUnit.SECONDS);
+        pool.release(ch2).get(1, TimeUnit.SECONDS);
 
         // Assert that returned channels are open before close
         assertTrue(ch1.isOpen());

File: example/src/main/java/io/netty/example/http2/helloworld/client/Http2ClientInitializer.java
Patch:
@@ -98,7 +98,8 @@ protected void configureEndOfPipeline(ChannelPipeline pipeline) {
      */
     private void configureSsl(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
-        pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        // Specify Host in SSLContext New Handler to add TLS SNI Extension
+        pipeline.addLast(sslCtx.newHandler(ch.alloc(), Http2Client.HOST, Http2Client.PORT));
         // We must wait for the handshake to finish and the protocol to be negotiated before configuring
         // the HTTP/2 components of the pipeline.
         pipeline.addLast(new ApplicationProtocolNegotiationHandler("") {

File: handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java
Patch:
@@ -153,8 +153,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                                     select(ctx, extractSniHostname(handshakeBuffer, 0, handshakeLength));
                                     return;
                                 }
+                                break;
                             }
-                            break;
+                            // fall-through
                         default:
                             // not tls, ssl or application data, do not try sni
                             select(ctx, null);

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketUtf8FrameValidatorTest.java
Patch:
@@ -36,8 +36,9 @@ public void testCorruptedFrameExceptionInCheck() {
 
     private void assertCorruptedFrameExceptionHandling(byte[] data) {
         EmbeddedChannel channel = new EmbeddedChannel(new Utf8FrameValidator());
+        TextWebSocketFrame frame = new TextWebSocketFrame(Unpooled.copiedBuffer(data));
         try {
-            channel.writeInbound(new TextWebSocketFrame(Unpooled.copiedBuffer(data)));
+            channel.writeInbound(frame);
             Assert.fail();
         } catch (CorruptedFrameException e) {
             // expected exception
@@ -51,5 +52,6 @@ private void assertCorruptedFrameExceptionHandling(byte[] data) {
             buf.release();
         }
         Assert.assertNull(channel.readOutbound());
+        Assert.assertEquals(0, frame.refCnt());
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -322,7 +322,7 @@ private boolean readClientPrefaceString(ByteBuf in) throws Http2Exception {
          * Peeks at that the next frame in the buffer and verifies that it is a non-ack {@code SETTINGS} frame.
          *
          * @param in the inbound buffer.
-         * @return {@code} true if the next frame is a non-ack {@code SETTINGS} frame, {@code false} if more
+         * @return {@code true} if the next frame is a non-ack {@code SETTINGS} frame, {@code false} if more
          * data is required before we can determine the next frame type.
          * @throws Http2Exception thrown if the next frame is NOT a non-ack {@code SETTINGS} frame.
          */

File: common/src/main/java/io/netty/util/AttributeMap.java
Patch:
@@ -28,7 +28,7 @@ public interface AttributeMap {
     <T> Attribute<T> attr(AttributeKey<T> key);
 
     /**
-     * Returns {@code} true if and only if the given {@link Attribute} exists in this {@link AttributeMap}.
+     * Returns {@code true} if and only if the given {@link Attribute} exists in this {@link AttributeMap}.
      */
     <T> boolean hasAttr(AttributeKey<T> key);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java
Patch:
@@ -107,9 +107,9 @@ public int compare(Cookie c1, Cookie c2) {
             if (diff != 0) {
                 return diff;
             }
-            // Rely on Java's sort stability to retain creation order in cases where
+            // Rely on Arrays.sort's stability to retain creation order in cases where
             // cookies have same path length.
-            return -1;
+            return 0;
         }
     };
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -109,6 +109,7 @@ public WebSocketServerHandshaker07(String webSocketURL, String subprotocols, Web
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
+     * Sec-WebSocket-Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 7
      * </pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -116,6 +116,7 @@ public WebSocketServerHandshaker08(
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
+     * Sec-WebSocket-Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 8
      * </pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -115,6 +115,7 @@ public WebSocketServerHandshaker13(
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
+     * Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 13
      * </pre>

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java
Patch:
@@ -115,7 +115,7 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
         assertTrue(serverReceivedHandshake);
         assertNotNull(serverHandshakeComplete);
         assertEquals("/test", serverHandshakeComplete.requestUri());
-        assertEquals(7, serverHandshakeComplete.requestHeaders().size());
+        assertEquals(8, serverHandshakeComplete.requestHeaders().size());
         assertEquals("test-proto-2", serverHandshakeComplete.selectedSubprotocol());
 
         // Transfer the handshake response and the websocket message to the client

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -288,8 +288,8 @@ private boolean encodeContent(HttpContent c, List<Object> out) {
     /**
      * Prepare to encode the HTTP message content.
      *
-     * @param headers
-     *        the headers
+     * @param httpResponse
+     *        the http response
      * @param acceptEncoding
      *        the value of the {@code "Accept-Encoding"} header
      *
@@ -299,7 +299,7 @@ private boolean encodeContent(HttpContent c, List<Object> out) {
      *         {@code null} if {@code acceptEncoding} is unsupported or rejected
      *         and thus the content should be handled as-is (i.e. no encoding).
      */
-    protected abstract Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception;
+    protected abstract Result beginEncode(HttpResponse httpResponse, String acceptEncoding) throws Exception;
 
     @Override
     public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
Patch:
@@ -41,7 +41,7 @@ public class HttpContentEncoderTest {
 
     private static final class TestEncoder extends HttpContentEncoder {
         @Override
-        protected Result beginEncode(HttpResponse headers, String acceptEncoding) {
+        protected Result beginEncode(HttpResponse httpResponse, String acceptEncoding) {
             return new Result("test", new EmbeddedChannel(new MessageToByteEncoder<ByteBuf>() {
                 @Override
                 protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
@@ -395,7 +395,7 @@ public void testHttp1_0() throws Exception {
     public void testCleanupThrows() {
         HttpContentEncoder encoder = new HttpContentEncoder() {
             @Override
-            protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
+            protected Result beginEncode(HttpResponse httpResponse, String acceptEncoding) throws Exception {
                 return new Result("myencoding", new EmbeddedChannel(
                         new ChannelInboundHandlerAdapter() {
                     @Override

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -54,7 +54,7 @@
 public final class ChannelOutboundBuffer {
     // Assuming a 64-bit JVM:
     //  - 16 bytes object header
-    //  - 8 reference fields
+    //  - 6 reference fields
     //  - 2 long fields
     //  - 2 int fields
     //  - 1 boolean field

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -455,6 +455,7 @@ public void close() {
      *
      * @return Future which represents completion of the close task
      */
+    @Override
     public Future<Void> closeAsync() {
         if (executor.inEventLoop()) {
             return close0();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -684,9 +684,10 @@ private boolean read(EpollRecvByteAllocatorHandle allocHandle, ByteBuf byteBuf,
             if (localAddress == null) {
                 localAddress = localAddress();
             }
+            int received = remoteAddress.receivedAmount();
             allocHandle.lastBytesRead(maxDatagramPacketSize <= 0 ?
-                    remoteAddress.receivedAmount() : writable);
-            byteBuf.writerIndex(byteBuf.writerIndex() + allocHandle.lastBytesRead());
+                    received : writable);
+            byteBuf.writerIndex(writerIndex + received);
             allocHandle.incMessagesRead(1);
 
             pipeline().fireChannelRead(new DatagramPacket(byteBuf, localAddress, remoteAddress));

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -109,7 +109,6 @@ public WebSocketServerHandshaker07(String webSocketURL, String subprotocols, Web
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
-     * Sec-WebSocket-Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 7
      * </pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -116,7 +116,6 @@ public WebSocketServerHandshaker08(
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
-     * Sec-WebSocket-Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 8
      * </pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -115,7 +115,6 @@ public WebSocketServerHandshaker13(
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
-     * Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 13
      * </pre>

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java
Patch:
@@ -115,7 +115,7 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
         assertTrue(serverReceivedHandshake);
         assertNotNull(serverHandshakeComplete);
         assertEquals("/test", serverHandshakeComplete.requestUri());
-        assertEquals(8, serverHandshakeComplete.requestHeaders().size());
+        assertEquals(7, serverHandshakeComplete.requestHeaders().size());
         assertEquals("test-proto-2", serverHandshakeComplete.selectedSubprotocol());
 
         // Transfer the handshake response and the websocket message to the client

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -32,6 +32,7 @@
 import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.epollin;
 import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.epollout;
 import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.epollrdhup;
+import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.isSupportingRecvmmsg;
 import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.isSupportingSendmmsg;
 import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.isSupportingTcpFastopen;
 import static io.netty.channel.epoll.NativeStaticallyReferencedJniMethods.kernelVersion;
@@ -67,6 +68,8 @@ public final class Native {
     public static final int EPOLLERR = epollerr();
 
     public static final boolean IS_SUPPORTING_SENDMMSG = isSupportingSendmmsg();
+    static final boolean IS_SUPPORTING_RECVMMSG = isSupportingRecvmmsg();
+
     public static final boolean IS_SUPPORTING_TCP_FASTOPEN = isSupportingTcpFastopen();
     public static final int TCP_MD5SIG_MAXKEYLEN = tcpMd5SigMaxKeyLen();
     public static final String KERNEL_VERSION = kernelVersion();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/NativeStaticallyReferencedJniMethods.java
Patch:
@@ -40,6 +40,7 @@ private NativeStaticallyReferencedJniMethods() { }
     static native int iovMax();
     static native int uioMaxIov();
     static native boolean isSupportingSendmmsg();
+    static native boolean isSupportingRecvmmsg();
     static native boolean isSupportingTcpFastopen();
     static native String kernelVersion();
 }

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -67,7 +67,7 @@ public abstract class AbstractTrafficShapingHandler extends ChannelDuplexHandler
     static final long DEFAULT_MAX_SIZE = 4 * 1024 * 1024L;
 
     /**
-     * Default minimal time to wait
+     * Default minimal time to wait: 10ms
      */
     static final long MINIMAL_WAIT = 10;
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -911,13 +911,12 @@ static OpenSslKeyMaterialProvider providerFor(KeyManagerFactory factory, String
             return ((OpenSslX509KeyManagerFactory) factory).newProvider();
         }
 
-        X509KeyManager keyManager = chooseX509KeyManager(factory.getKeyManagers());
         if (factory instanceof OpenSslCachingX509KeyManagerFactory) {
             // The user explicit used OpenSslCachingX509KeyManagerFactory which signals us that its fine to cache.
-            return new OpenSslCachingKeyMaterialProvider(keyManager, password);
+            return ((OpenSslCachingX509KeyManagerFactory) factory).newProvider(password);
         }
         // We can not be sure if the material may change at runtime so we will not cache it.
-        return new OpenSslKeyMaterialProvider(keyManager, password);
+        return new OpenSslKeyMaterialProvider(chooseX509KeyManager(factory.getKeyManagers()), password);
     }
 
     private static final class PrivateKeyMethod implements SSLPrivateKeyMethod {

File: handler/src/test/java/io/netty/handler/ssl/OpenSslCachingKeyMaterialProviderTest.java
Patch:
@@ -33,7 +33,7 @@ protected KeyManagerFactory newKeyManagerFactory() throws Exception {
     @Override
     protected OpenSslKeyMaterialProvider newMaterialProvider(KeyManagerFactory factory, String password) {
         return new OpenSslCachingKeyMaterialProvider(ReferenceCountedOpenSslContext.chooseX509KeyManager(
-                factory.getKeyManagers()), password);
+                factory.getKeyManagers()), password, Integer.MAX_VALUE);
     }
 
     @Override

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketFrameHandler.java
Patch:
@@ -15,13 +15,13 @@
  */
 package io.netty.example.http.websocketx.server;
 
-import java.util.Locale;
-
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 
+import java.util.Locale;
+
 /**
  * Echoes uppercase content of text frames.
  */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
Patch:
@@ -136,7 +136,7 @@ public boolean isRequestOnly() {
     Iterator<CharSequence> valueIterator(CharSequence name);
 
     /**
-     * Sets the {@link PseudoHeaderName#METHOD} header or {@code null} if there is no such header
+     * Sets the {@link PseudoHeaderName#METHOD} header
      */
     Http2Headers method(CharSequence value);
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2HeadersValidatorTest.java
Patch:
@@ -39,7 +39,7 @@ public class Http2HeadersValidatorTest {
     @Test
     public void validateConnectionSpecificHeadersShouldThrowIfConnectionHeaderPresent() throws Http2Exception {
         expectedException.expect(StreamException.class);
-        expectedException.expectMessage("Connection-speficic headers like [connection] must not be used with HTTP");
+        expectedException.expectMessage("Connection-specific headers like [connection] must not be used with HTTP");
 
         final Http2Headers headers = newHttp2HeadersWithRequestPseudoHeaders();
         headers.add(CONNECTION, "keep-alive");

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -535,8 +535,8 @@ private T buildFromConnection(Http2Connection connection) {
             encoder = new StreamBufferingEncoder(encoder);
         }
 
-        DefaultHttp2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader,
-                promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame());
+        Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader,
+                promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame(), isValidateHeaders());
         return buildFromCodec(decoder, encoder);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java
Patch:
@@ -242,8 +242,8 @@ public void testAuthorityFormRequestTargetHandled() throws Exception {
         final HttpHeaders httpHeaders = request.headers();
         httpHeaders.setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(), 5);
         final Http2Headers http2Headers =
-                new DefaultHttp2Headers().method(new AsciiString("CONNECT")).path(new AsciiString("/"))
-                .scheme(new AsciiString("http")).authority(new AsciiString("www.example.com:80"));
+                new DefaultHttp2Headers().method(new AsciiString("CONNECT"))
+                                         .authority(new AsciiString("www.example.com:80"));
 
         ChannelPromise writePromise = newPromise();
         verifyHeadersOnly(http2Headers, writePromise, clientChannel.writeAndFlush(request, writePromise));

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -571,6 +571,9 @@ private long waitForNextTick() {
                 // See https://github.com/netty/netty/issues/356
                 if (PlatformDependent.isWindows()) {
                     sleepTimeMs = sleepTimeMs / 10 * 10;
+                    if (sleepTimeMs == 0) {
+                        sleepTimeMs = 1;
+                    }
                 }
 
                 try {

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -81,7 +81,7 @@ public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)
             try {
                 final ByteBuf buffer;
                 if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()
-                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {
+                        || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {
                     // Expand cumulation (by replace it) when either there is not more room in the buffer
                     // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or
                     // duplicate().retain() or if its read-only.
@@ -505,6 +505,8 @@ final void decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in,
             boolean removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;
             decodeState = STATE_INIT;
             if (removePending) {
+                fireChannelRead(ctx, out, out.size());
+                out.clear();
                 handlerRemoved(ctx);
             }
         }

File: common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java
Patch:
@@ -215,7 +215,7 @@ private static final class RunnableScheduledFutureTask<V> extends PromiseTask<V>
 
         RunnableScheduledFutureTask(EventExecutor executor, Runnable runnable,
                                            RunnableScheduledFuture<V> future) {
-            super(executor, runnable, null);
+            super(executor, runnable);
             this.future = future;
         }
 
@@ -232,7 +232,7 @@ public void run() {
             } else if (!isDone()) {
                 try {
                     // Its a periodic task so we need to ignore the return value
-                    task.call();
+                    runTask();
                 } catch (Throwable cause) {
                     if (!tryFailureInternal(cause)) {
                         logger.warn("Failure during execution of task", cause);

File: common/src/main/java/io/netty/util/internal/LongAdderCounter.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.concurrent.atomic.LongAdder;
 
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class LongAdderCounter extends LongAdder implements LongCounter {
 
     @Override

File: common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
Patch:
@@ -482,6 +482,7 @@ private NativeLibraryLoader() {
 
     private static final class NoexecVolumeDetector {
 
+        @SuppressJava6Requirement(reason = "Usage guarded by java version check")
         private static boolean canExecuteExecutable(File file) throws IOException {
             if (PlatformDependent.javaVersion() < 7) {
                 // Pre-JDK7, the Java API did not directly support POSIX permissions; instead of implementing a custom

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -132,6 +132,7 @@ public void freeDirectBuffer(ByteBuffer buffer) {
         if (javaVersion() >= 7) {
             RANDOM_PROVIDER = new ThreadLocalRandomProvider() {
                 @Override
+                @SuppressJava6Requirement(reason = "Usage guarded by java version check")
                 public Random current() {
                     return java.util.concurrent.ThreadLocalRandom.current();
                 }
@@ -964,6 +965,7 @@ public static ClassLoader getSystemClassLoader() {
     /**
      * Returns a new concurrent {@link Deque}.
      */
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     public static <C> Deque<C> newConcurrentDeque() {
         if (javaVersion() < 7) {
             return new LinkedBlockingDeque<C>();

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -33,6 +33,7 @@
 /**
  * The {@link PlatformDependent} operations which requires access to {@code sun.misc.*}.
  */
+@SuppressJava6Requirement(reason = "Unsafe access is guarded")
 final class PlatformDependent0 {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent0.class);

File: common/src/main/java/io/netty/util/internal/SocketUtils.java
Patch:
@@ -88,6 +88,7 @@ public Boolean run() throws IOException {
         }
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     public static void bind(final SocketChannel socketChannel, final SocketAddress address) throws IOException {
         try {
             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
@@ -115,6 +116,7 @@ public SocketChannel run() throws IOException {
         }
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     public static void bind(final DatagramChannel networkChannel, final SocketAddress address) throws IOException {
         try {
             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
@@ -182,6 +184,7 @@ public Enumeration<InetAddress> run() {
         });
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     public static InetAddress loopbackAddress() {
         return AccessController.doPrivileged(new PrivilegedAction<InetAddress>() {
             @Override

File: common/src/main/java/io/netty/util/internal/SuppressJava6Requirement.java
Patch:
@@ -25,7 +25,7 @@
  * Annotation to suppress the Java 6 source code requirement checks for a method.
  */
 @Retention(RetentionPolicy.CLASS)
-@Target({ ElementType.METHOD, ElementType.CONSTRUCTOR })
+@Target({ ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.TYPE })
 public @interface SuppressJava6Requirement {
 
     String reason();

File: handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import io.netty.util.internal.SuppressJava6Requirement;
+
 import javax.net.ssl.ExtendedSSLSession;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -29,6 +31,7 @@
  * Delegates all operations to a wrapped {@link OpenSslSession} except the methods defined by {@link ExtendedSSLSession}
  * itself.
  */
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 abstract class ExtendedOpenSslSession extends ExtendedSSLSession implements OpenSslSession {
 
     // TODO: use OpenSSL API to actually fetch the real data but for now just do what Conscrypt does:

File: handler/src/main/java/io/netty/handler/ssl/Java7SslParametersUtils.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import io.netty.util.internal.SuppressJava6Requirement;
+
 import javax.net.ssl.SSLParameters;
 import java.security.AlgorithmConstraints;
 
@@ -29,6 +31,7 @@ private Java7SslParametersUtils() {
      * {@link AlgorithmConstraints} in the code. This helps us to not get into trouble when using it in java
      * version < 7 and especially when using on android.
      */
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     static void setAlgorithmConstraints(SSLParameters sslParameters, Object algorithmConstraints) {
         sslParameters.setAlgorithmConstraints((AlgorithmConstraints) algorithmConstraints);
     }

File: handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import io.netty.util.internal.SuppressJava6Requirement;
+
 import javax.net.ssl.SNIHostName;
 import javax.net.ssl.SNIMatcher;
 import javax.net.ssl.SNIServerName;
@@ -25,6 +27,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class Java8SslUtils {
 
     private Java8SslUtils() { }

File: handler/src/main/java/io/netty/handler/ssl/Java9SslEngine.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.ssl;
 
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.SuppressJava6Requirement;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLEngineResult;
@@ -30,6 +31,7 @@
 import static io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelectionListener;
 import static io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelector;
 
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class Java9SslEngine extends JdkSslEngine {
     private final ProtocolSelectionListener selectionListener;
     private final AlpnSelector alpnSelector;

File: handler/src/main/java/io/netty/handler/ssl/Java9SslUtils.java
Patch:
@@ -27,9 +27,11 @@
 
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class Java9SslUtils {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Java9SslUtils.class);
     private static final Method SET_APPLICATION_PROTOCOLS;

File: handler/src/main/java/io/netty/handler/ssl/JdkSslEngine.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import io.netty.util.internal.SuppressJava6Requirement;
+
 import java.nio.ByteBuffer;
 
 import javax.net.ssl.SSLEngine;
@@ -145,6 +147,7 @@ public void setEnabledProtocols(String[] strings) {
         engine.setEnabledProtocols(strings);
     }
 
+    @SuppressJava6Requirement(reason = "Can only be called when running on JDK7+")
     @Override
     public SSLSession getHandshakeSession() {
         return engine.getHandshakeSession();

File: handler/src/main/java/io/netty/handler/ssl/OpenSslTlsv13X509ExtendedTrustManager.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.ssl;
 
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SuppressJava6Requirement;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -35,6 +36,7 @@
  * default {@link X509ExtendedTrustManager} implementations provided by the JDK that can not handle a protocol version
  * of {@code TLSv1.3}.
  */
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class OpenSslTlsv13X509ExtendedTrustManager extends X509ExtendedTrustManager {
 
     private final X509ExtendedTrustManager tm;

File: handler/src/main/java/io/netty/handler/ssl/OpenSslX509Certificate.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl;
 
+import io.netty.util.internal.SuppressJava6Requirement;
+
 import javax.security.auth.x500.X500Principal;
 import java.io.ByteArrayInputStream;
 import java.math.BigInteger;
@@ -81,7 +83,7 @@ public Collection<List<?>> getIssuerAlternativeNames() throws CertificateParsing
     }
 
     // No @Override annotation as it was only introduced in Java8.
-    @Override
+    @SuppressJava6Requirement(reason = "Can only be called from Java8 as class is package-private")
     public void verify(PublicKey key, Provider sigProvider)
             throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
         unwrap().verify(key, sigProvider);

File: handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -39,6 +40,7 @@
  * This is really a "hack" until there is an official API as requested on the in
  * <a href="https://bugs.openjdk.java.net/projects/JDK/issues/JDK-8210843">JDK-8210843</a>.
  */
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class OpenSslX509TrustManagerWrapper {
     private static final InternalLogger LOGGER = InternalLoggerFactory
             .getInstance(OpenSslX509TrustManagerWrapper.class);
@@ -163,6 +165,7 @@ private static final class UnsafeTrustManagerWrapper implements TrustManagerWrap
             this.tmOffset = tmOffset;
         }
 
+        @SuppressJava6Requirement(reason = "Usage guarded by java version check")
         @Override
         public X509TrustManager wrapIfNeeded(X509TrustManager manager) {
             if (!(manager instanceof X509ExtendedTrustManager)) {

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -28,6 +28,7 @@
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -1952,6 +1953,7 @@ public final boolean getEnableSessionCreation() {
         return false;
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     @Override
     public final synchronized SSLParameters getSSLParameters() {
         SSLParameters sslParameters = super.getSSLParameters();
@@ -1975,6 +1977,7 @@ public final synchronized SSLParameters getSSLParameters() {
         return sslParameters;
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     @Override
     public final synchronized void setSSLParameters(SSLParameters sslParameters) {
         int version = PlatformDependent.javaVersion();

File: handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.netty.handler.ssl.util;
 
+import io.netty.util.internal.SuppressJava6Requirement;
 import sun.security.x509.AlgorithmId;
 import sun.security.x509.CertificateAlgorithmId;
 import sun.security.x509.CertificateIssuerName;
@@ -42,6 +43,7 @@
  */
 final class OpenJdkSelfSignedCertGenerator {
 
+    @SuppressJava6Requirement(reason = "Usage guarded by dependency check")
     static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date notBefore, Date notAfter)
             throws Exception {
         PrivateKey key = keypair.getPrivate();

File: handler/src/main/java/io/netty/handler/ssl/util/X509TrustManagerWrapper.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.ssl.util;
 
+import io.netty.util.internal.SuppressJava6Requirement;
+
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.X509ExtendedTrustManager;
 import javax.net.ssl.X509TrustManager;
@@ -24,6 +26,7 @@
 
 import static io.netty.util.internal.ObjectUtil.*;
 
+@SuppressJava6Requirement(reason = "Usage guarded by java version check")
 final class X509TrustManagerWrapper extends X509ExtendedTrustManager {
 
     private final X509TrustManager delegate;

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.channel.socket.DefaultServerSocketChannelConfig;
 import io.netty.channel.socket.ServerSocketChannelConfig;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -126,6 +127,7 @@ protected SocketAddress localAddress0() {
         return SocketUtils.localSocketAddress(javaChannel().socket());
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     @Override
     protected void doBind(SocketAddress localAddress) throws Exception {
         if (PlatformDependent.javaVersion() >= 7) {
@@ -220,7 +222,6 @@ public <T> T getOption(ChannelOption<T> option) {
             return super.getOption(option);
         }
 
-        @SuppressWarnings("unchecked")
         @Override
         public Map<ChannelOption<?>, Object> getOptions() {
             if (PlatformDependent.javaVersion() >= 7) {

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -33,6 +33,7 @@
 import io.netty.util.concurrent.GlobalEventExecutor;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SocketUtils;
+import io.netty.util.internal.SuppressJava6Requirement;
 import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -152,6 +153,7 @@ public InetSocketAddress remoteAddress() {
         return (InetSocketAddress) super.remoteAddress();
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     @UnstableApi
     @Override
     protected final void doShutdownOutput() throws Exception {
@@ -270,6 +272,7 @@ private void shutdownInput0(final ChannelPromise promise) {
         }
     }
 
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     private void shutdownInput0() throws Exception {
         if (PlatformDependent.javaVersion() >= 7) {
             javaChannel().shutdownInput();
@@ -496,7 +499,6 @@ public <T> T getOption(ChannelOption<T> option) {
             return super.getOption(option);
         }
 
-        @SuppressWarnings("unchecked")
         @Override
         public Map<ChannelOption<?>, Object> getOptions() {
             if (PlatformDependent.javaVersion() >= 7) {

File: transport/src/main/java/io/netty/channel/socket/nio/ProtocolFamilyConverter.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.channel.socket.InternetProtocolFamily;
+import io.netty.util.internal.SuppressJava6Requirement;
 
 import java.net.ProtocolFamily;
 import java.net.StandardProtocolFamily;
@@ -32,6 +33,7 @@ private ProtocolFamilyConverter() {
     /**
      * Convert the {@link InternetProtocolFamily}. This MUST only be called on jdk version >= 7.
      */
+    @SuppressJava6Requirement(reason = "Usage guarded by java version check")
     public static ProtocolFamily convert(InternetProtocolFamily family) {
         switch (family) {
         case IPv4:

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -328,10 +328,11 @@ public void testReleaseSslEngine() throws Exception {
                 .sslProvider(SslProvider.OPENSSL)
                 .build();
             try {
+                assertEquals(1, ((ReferenceCounted) sslContext).refCnt());
                 SSLEngine sslEngine = sslContext.newEngine(ByteBufAllocator.DEFAULT);
                 EmbeddedChannel ch = new EmbeddedChannel(new SslHandler(sslEngine));
 
-                assertEquals(1, ((ReferenceCounted) sslContext).refCnt());
+                assertEquals(2, ((ReferenceCounted) sslContext).refCnt());
                 assertEquals(1, ((ReferenceCounted) sslEngine).refCnt());
 
                 assertTrue(ch.finishAndReleaseAll());

File: codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java
Patch:
@@ -274,7 +274,7 @@ private static HAProxyTLV readNextTLV(final ByteBuf header) {
                 return new HAProxySSLTLV(verify, client, encapsulatedTlvs, rawContent);
             }
             return new HAProxySSLTLV(verify, client, Collections.<HAProxyTLV>emptyList(), rawContent);
-        // If we're not dealing with a SSL Type, we can use the same mechanism
+        // If we're not dealing with an SSL Type, we can use the same mechanism
         case PP2_TYPE_ALPN:
         case PP2_TYPE_AUTHORITY:
         case PP2_TYPE_SSL_VERSION:

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -132,7 +132,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                         copy = new DefaultHttpResponse(r.protocolVersion(), r.status());
                     } else {
                         throw new CodecException("Object of class " + message.getClass().getName() +
-                                                 " is not a HttpRequest or HttpResponse");
+                                                 " is not an HttpRequest or HttpResponse");
                     }
                     copy.headers().set(message.headers());
                     copy.setDecoderResult(message.decoderResult());

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java
Patch:
@@ -17,7 +17,7 @@
 
 
 /**
- * An interface that defines a HTTP message, providing common properties for
+ * An interface that defines an HTTP message, providing common properties for
  * {@link HttpRequest} and {@link HttpResponse}.
  *
  * @see HttpResponse

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -281,7 +281,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
 
             // Check if the buffer is readable first as we use the readable byte count
             // to create the HttpChunk. This is needed as otherwise we may end up with
-            // create a HttpChunk instance that contains an empty buffer and so is
+            // create an HttpChunk instance that contains an empty buffer and so is
             // handled like it is the last HttpChunk.
             //
             // See https://github.com/netty/netty/issues/433

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -518,7 +518,7 @@ public static CharSequence getMimeType(CharSequence contentTypeValue) {
 
     /**
      * Formats the host string of an address so it can be used for computing an HTTP component
-     * such as an URL or a Host header
+     * such as a URL or a Host header
      *
      * @param addr the address
      * @return the formatted String

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -266,7 +266,7 @@ private static boolean addParam(String s, int nameStart, int valueStart, int val
     }
 
     /**
-     * Decodes a bit of an URL encoded by a browser.
+     * Decodes a bit of a URL encoded by a browser.
      * <p>
      * This is equivalent to calling {@link #decodeComponent(String, Charset)}
      * with the UTF-8 charset (recommended to comply with RFC 3986, Section 2).
@@ -281,7 +281,7 @@ public static String decodeComponent(final String s) {
     }
 
     /**
-     * Decodes a bit of an URL encoded by a browser.
+     * Decodes a bit of a URL encoded by a browser.
      * <p>
      * The string is expected to be encoded as per RFC 3986, Section 2.
      * This is the encoding used by JavaScript functions {@code encodeURI}

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -26,7 +26,7 @@
 import java.nio.charset.Charset;
 
 /**
- * Creates an URL-encoded URI from a path string and key-value parameter pairs.
+ * Creates a URL-encoded URI from a path string and key-value parameter pairs.
  * This encoder is for one time use only.  Create a new instance for each URI.
  *
  * <pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
Patch:
@@ -219,7 +219,7 @@ public HttpHeaders preflightResponseHeaders() {
      *
      * CORS headers are set after a request is processed. This may not always be desired
      * and this setting will check that the Origin is valid and if it is not valid no
-     * further processing will take place, and a error will be returned to the calling client.
+     * further processing will take place, and an error will be returned to the calling client.
      *
      * @return {@code true} if a CORS request should short-circuit upon receiving an invalid Origin header.
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
Patch:
@@ -341,7 +341,7 @@ public CorsConfigBuilder noPreflightResponseHeaders() {
      *
      * CORS headers are set after a request is processed. This may not always be desired
      * and this setting will check that the Origin is valid and if it is not valid no
-     * further processing will take place, and a error will be returned to the calling client.
+     * further processing will take place, and an error will be returned to the calling client.
      *
      * @return {@link CorsConfigBuilder} to support method chaining.
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -867,7 +867,7 @@ private String encodeAttribute(String s, Charset charset) throws ErrorDataEncode
 
     /**
      *
-     * @return the next ByteBuf to send as a HttpChunk and modifying currentBuffer accordingly
+     * @return the next ByteBuf to send as an HttpChunk and modifying currentBuffer accordingly
      */
     private ByteBuf fillByteBuf() {
         int length = currentBuffer.readableBytes();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -202,7 +202,7 @@ public final ChannelFuture handshake(Channel channel, FullHttpRequest req,
         ChannelHandlerContext ctx = p.context(HttpRequestDecoder.class);
         final String encoderName;
         if (ctx == null) {
-            // this means the user use a HttpServerCodec
+            // this means the user use an HttpServerCodec
             ctx = p.context(HttpServerCodec.class);
             if (ctx == null) {
                 promise.setFailure(
@@ -276,7 +276,7 @@ public final ChannelFuture handshake(final Channel channel, HttpRequest req,
         ChannelPipeline p = channel.pipeline();
         ChannelHandlerContext ctx = p.context(HttpRequestDecoder.class);
         if (ctx == null) {
-            // this means the user use a HttpServerCodec
+            // this means the user use an HttpServerCodec
             ctx = p.context(HttpServerCodec.class);
             if (ctx == null) {
                 promise.setFailure(

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -193,7 +193,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                 // SYN_STREAM frames initiated by the client are HTTP requests
 
                 // If a client sends a request with a truncated header block, the server must
-                // reply with a HTTP 431 REQUEST HEADER FIELDS TOO LARGE reply.
+                // reply with an HTTP 431 REQUEST HEADER FIELDS TOO LARGE reply.
                 if (spdySynStreamFrame.isTruncated()) {
                     SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
                     spdySynReplyFrame.setLast(true);
@@ -218,7 +218,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                     }
                 } catch (Throwable t) {
                     // If a client sends a SYN_STREAM without all of the getMethod, url (host and path),
-                    // scheme, and version headers the server must reply with a HTTP 400 BAD REQUEST reply.
+                    // scheme, and version headers the server must reply with an HTTP 400 BAD REQUEST reply.
                     // Also sends HTTP 400 BAD REQUEST reply if header name/value pairs are invalid
                     SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
                     spdySynReplyFrame.setLast(true);

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -197,7 +197,7 @@ public void testOversizedRequestWithContentLengthAndDecoder() {
 
     @Test
     public void testOversizedRequestWithoutKeepAlive() {
-        // send a HTTP/1.0 request with no keep-alive header
+        // send an HTTP/1.0 request with no keep-alive header
         HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.PUT, "http://localhost");
         HttpUtil.setContentLength(message, 5);
         checkOversizedRequest(message);

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -145,7 +145,7 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
                 amount = headerLength -  a;
             }
 
-            // if header is done it should produce a HttpRequest
+            // if header is done it should produce an HttpRequest
             channel.writeInbound(Unpooled.copiedBuffer(content, a, amount));
             a += amount;
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
Patch:
@@ -446,7 +446,7 @@ private static void testLastResponseWithTrailingHeaderFragmented(byte[] content,
                 amount = headerLength -  a;
             }
 
-            // if header is done it should produce a HttpRequest
+            // if header is done it should produce an HttpRequest
             boolean headerDone = a + amount == headerLength;
             assertEquals(headerDone, ch.writeInbound(Unpooled.copiedBuffer(content, a, amount)));
             a += amount;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -85,7 +85,7 @@ public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2Conne
     private boolean decoupleCloseAndGoAway;
 
     // The property that will prohibit connection() and codec() if set by server(),
-    // because this property is used only when this builder creates a Http2Connection.
+    // because this property is used only when this builder creates an Http2Connection.
     private Boolean isServer;
     private Integer maxReservedStreams;
 
@@ -552,7 +552,7 @@ private T buildFromCodec(Http2ConnectionDecoder decoder, Http2ConnectionEncoder
         } catch (Throwable t) {
             encoder.close();
             decoder.close();
-            throw new IllegalStateException("failed to build a Http2ConnectionHandler", t);
+            throw new IllegalStateException("failed to build an Http2ConnectionHandler", t);
         }
 
         // Setup post build options

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
Patch:
@@ -36,7 +36,7 @@
 import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
 
 /**
- * A HTTP2 frame listener that will decompress data frames according to the {@code content-encoding} header for each
+ * An HTTP2 frame listener that will decompress data frames according to the {@code content-encoding} header for each
  * stream. The decompression provided by this class will be applied to the data for the entire stream.
  */
 @UnstableApi

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java
Patch:
@@ -97,7 +97,7 @@ public ShutdownHint shutdownHint() {
      * @param error The type of error as defined by the HTTP/2 specification.
      * @param fmt String with the content and format for the additional debug data.
      * @param args Objects which fit into the format defined by {@code fmt}.
-     * @return An exception which can be translated into a HTTP/2 error.
+     * @return An exception which can be translated into an HTTP/2 error.
      */
     public static Http2Exception connectionError(Http2Error error, String fmt, Object... args) {
         return new Http2Exception(error, String.format(fmt, args));
@@ -110,7 +110,7 @@ public static Http2Exception connectionError(Http2Error error, String fmt, Objec
      * @param cause The object which caused the error.
      * @param fmt String with the content and format for the additional debug data.
      * @param args Objects which fit into the format defined by {@code fmt}.
-     * @return An exception which can be translated into a HTTP/2 error.
+     * @return An exception which can be translated into an HTTP/2 error.
      */
     public static Http2Exception connectionError(Http2Error error, Throwable cause,
             String fmt, Object... args) {
@@ -123,7 +123,7 @@ public static Http2Exception connectionError(Http2Error error, Throwable cause,
      * @param error The type of error as defined by the HTTP/2 specification.
      * @param fmt String with the content and format for the additional debug data.
      * @param args Objects which fit into the format defined by {@code fmt}.
-     * @return An exception which can be translated into a HTTP/2 error.
+     * @return An exception which can be translated into an HTTP/2 error.
      */
     public static Http2Exception closedStreamError(Http2Error error, String fmt, Object... args) {
         return new ClosedStreamCreationException(error, String.format(fmt, args));

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -45,8 +45,8 @@
  * <p><em>This API is very immature.</em> The Http2Connection-based API is currently preferred over this API.
  * This API is targeted to eventually replace or reduce the need for the {@link Http2ConnectionHandler} API.
  *
- * <p>A HTTP/2 handler that maps HTTP/2 frames to {@link Http2Frame} objects and vice versa. For every incoming HTTP/2
- * frame, a {@link Http2Frame} object is created and propagated via {@link #channelRead}. Outbound {@link Http2Frame}
+ * <p>An HTTP/2 handler that maps HTTP/2 frames to {@link Http2Frame} objects and vice versa. For every incoming HTTP/2
+ * frame, an {@link Http2Frame} object is created and propagated via {@link #channelRead}. Outbound {@link Http2Frame}
  * objects received via {@link #write} are converted to the HTTP/2 wire format. HTTP/2 frames specific to a stream
  * implement the {@link Http2StreamFrame} interface. The {@link Http2FrameCodec} is instantiated using the
  * {@link Http2FrameCodecBuilder}. It's recommended for channel handlers to inherit from the
@@ -79,7 +79,7 @@
  *
  * <h3>New inbound Streams</h3>
  *
- * The first frame of a HTTP/2 stream must be a {@link Http2HeadersFrame}, which will have a {@link Http2FrameStream}
+ * The first frame of an HTTP/2 stream must be an {@link Http2HeadersFrame}, which will have an {@link Http2FrameStream}
  * object attached.
  *
  * <h3>New outbound Streams</h3>

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodecBuilder.java
Patch:
@@ -36,14 +36,14 @@ public class Http2FrameCodecBuilder extends
     }
 
     /**
-     * Creates a builder for a HTTP/2 client.
+     * Creates a builder for an HTTP/2 client.
      */
     public static Http2FrameCodecBuilder forClient() {
         return new Http2FrameCodecBuilder(false);
     }
 
     /**
-     * Creates a builder for a HTTP/2 server.
+     * Creates a builder for an HTTP/2 server.
      */
     public static Http2FrameCodecBuilder forServer() {
         return new Http2FrameCodecBuilder(true);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStream.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.util.internal.UnstableApi;
 
 /**
- * A single stream within a HTTP/2 connection. To be used with the {@link Http2FrameCodec}.
+ * A single stream within an HTTP/2 connection. To be used with the {@link Http2FrameCodec}.
  */
 @UnstableApi
 public interface Http2FrameStream {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStreamException.java
Patch:
@@ -21,7 +21,7 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
- * A HTTP/2 exception for a specific {@link Http2FrameStream}.
+ * An HTTP/2 exception for a specific {@link Http2FrameStream}.
  */
 @UnstableApi
 public final class Http2FrameStreamException extends Exception {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -57,7 +57,7 @@ Http2MultiplexCodecBuilder frameWriter(Http2FrameWriter frameWriter) {
     }
 
     /**
-     * Creates a builder for a HTTP/2 client.
+     * Creates a builder for an HTTP/2 client.
      *
      * @param childHandler the handler added to channels for remotely-created streams. It must be
      *     {@link ChannelHandler.Sharable}.
@@ -67,7 +67,7 @@ public static Http2MultiplexCodecBuilder forClient(ChannelHandler childHandler)
     }
 
     /**
-     * Creates a builder for a HTTP/2 server.
+     * Creates a builder for an HTTP/2 server.
      *
      * @param childHandler the handler added to channels for remotely-created streams. It must be
      *     {@link ChannelHandler.Sharable}.

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexTest.java
Patch:
@@ -394,7 +394,7 @@ private Http2StreamChannel newOutboundStream(ChannelHandler handler) {
     }
 
     /**
-     * A child channel for a HTTP/2 stream in IDLE state (that is no headers sent or received),
+     * A child channel for an HTTP/2 stream in IDLE state (that is no headers sent or received),
      * should not emit a RST_STREAM frame on close, as this is a connection error of type protocol error.
      */
     @Test

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
Patch:
@@ -27,7 +27,7 @@
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
- * A HTTP server showing how to use the HTTP multipart package for file uploads and decoding post data.
+ * An HTTP server showing how to use the HTTP multipart package for file uploads and decoding post data.
  */
 public final class HttpUploadServer {
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -142,9 +142,9 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
             }
             responseContent.append("\r\n\r\n");
 
-            // if GET Method: should not try to create a HttpPostRequestDecoder
+            // if GET Method: should not try to create an HttpPostRequestDecoder
             if (HttpMethod.GET.equals(request.method())) {
-                // GET Method: should not try to create a HttpPostRequestDecoder
+                // GET Method: should not try to create an HttpPostRequestDecoder
                 // So stop here
                 responseContent.append("\r\n\r\nEND OF GET CONTENT\r\n");
                 // Not now: LastHttpContent will be sent writeResponse(ctx.channel());

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
Patch:
@@ -27,7 +27,7 @@
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
- * A HTTP server which serves Web Socket requests at:
+ * An HTTP server which serves Web Socket requests at:
  *
  * http://localhost:8080/websocket
  *

File: example/src/main/java/io/netty/example/http2/helloworld/frame/server/Http2Server.java
Patch:
@@ -38,7 +38,7 @@
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
- * A HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
+ * An HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
  * server with the example client.
  *
  * <p>This example is making use of the "multiplexing" http2 API, where streams are mapped to child

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2Server.java
Patch:
@@ -38,7 +38,7 @@
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
- * A HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
+ * An HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
  * server with the example client.
  *
  * <p>This example is making use of the "multiplexing" http2 API, where streams are mapped to child

File: example/src/main/java/io/netty/example/http2/helloworld/server/Http2Server.java
Patch:
@@ -38,7 +38,7 @@
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
- * A HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
+ * An HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
  * server with the example client.
  */
 public final class Http2Server {

File: example/src/main/java/io/netty/example/http2/tiles/Http2Server.java
Patch:
@@ -40,7 +40,7 @@
 import javax.net.ssl.SSLException;
 
 /**
- * Demonstrates a Http2 server using Netty to display a bunch of images and
+ * Demonstrates an Http2 server using Netty to display a bunch of images and
  * simulate latency. It is a Netty version of the <a href="https://http2.golang.org/gophertiles?latency=0">
  * Go lang HTTP2 tiles demo</a>.
  */

File: example/src/main/java/io/netty/example/http2/tiles/HttpServer.java
Patch:
@@ -31,7 +31,7 @@
 import io.netty.handler.logging.LoggingHandler;
 
 /**
- * Demonstrates a http server using Netty to display a bunch of images, simulate
+ * Demonstrates an http server using Netty to display a bunch of images, simulate
  * latency and compare it against the http2 implementation.
  */
 public final class HttpServer {

File: example/src/main/java/io/netty/example/ocsp/OcspClientExample.java
Patch:
@@ -58,8 +58,8 @@
 import io.netty.util.concurrent.Promise;
 
 /**
- * This is a very simple example for a HTTPS client that uses OCSP stapling.
- * The client connects to a HTTPS server that has OCSP stapling enabled and
+ * This is a very simple example for an HTTPS client that uses OCSP stapling.
+ * The client connects to an HTTPS server that has OCSP stapling enabled and
  * then uses BC to parse and validate it.
  */
 public class OcspClientExample {

File: example/src/main/java/io/netty/example/ocsp/OcspServerExample.java
Patch:
@@ -71,7 +71,7 @@ public static void main(String[] args) throws Exception {
         X509Certificate issuer = keyCertChain[keyCertChain.length - 1];
 
         // Step 2: We need the URL of the CA's OCSP responder server. It's somewhere encoded
-        // into the certificate! Notice that it's a HTTP URL.
+        // into the certificate! Notice that it's an HTTP URL.
         URI uri = OcspUtils.ocspUri(certificate);
         System.out.println("OCSP Responder URI: " + uri);
 

File: handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java
Patch:
@@ -37,7 +37,7 @@
  * many events as they like for any given input. A channel's auto reading configuration doesn't usually
  * apply in these scenarios. This is causing problems in downstream {@link ChannelHandler}s that would
  * like to hold subsequent events while they're processing one event. It's a common problem with the
- * {@code HttpObjectDecoder} that will very often fire a {@code HttpRequest} that is immediately followed
+ * {@code HttpObjectDecoder} that will very often fire an {@code HttpRequest} that is immediately followed
  * by a {@code LastHttpContent} event.
  *
  * <pre>{@code

File: handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiationHandler.java
Patch:
@@ -85,7 +85,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
                 if (handshakeEvent.isSuccess()) {
                     SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
                     if (sslHandler == null) {
-                        throw new IllegalStateException("cannot find a SslHandler in the pipeline (required for "
+                        throw new IllegalStateException("cannot find an SslHandler in the pipeline (required for "
                                 + "application-level protocol negotiation)");
                     }
                     String protocol = sslHandler.applicationProtocol();

File: handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java
Patch:
@@ -497,7 +497,7 @@ private void testCorrectlyCalculateSpaceForAlert(boolean jdkCompatabilityMode) t
 
             ByteBuffer empty = allocateBuffer(0);
             ByteBuffer dst = allocateBuffer(clientEngine.getSession().getPacketBufferSize());
-            // Limit to something that is guaranteed to be too small to hold a SSL Record.
+            // Limit to something that is guaranteed to be too small to hold an SSL Record.
             dst.limit(1);
 
             // As we called closeOutbound() before this should produce a BUFFER_OVERFLOW.

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -2285,7 +2285,7 @@ public void testCloseNotifySequence() throws Exception {
             assertTrue(client.isOutboundDone());
             assertTrue(client.isInboundDone());
 
-            // Ensure that calling wrap or unwrap again will not produce a SSLException
+            // Ensure that calling wrap or unwrap again will not produce an SSLException
             encryptedServerToClient.clear();
             plainServerOut.clear();
 

File: microbench/src/main/java/io/netty/microbench/http/HttpRequestDecoderBenchmark.java
Patch:
@@ -98,7 +98,7 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
                 amount = headerLength -  a;
             }
 
-            // if header is done it should produce a HttpRequest
+            // if header is done it should produce an HttpRequest
             channel.writeInbound(Unpooled.wrappedBuffer(content, a, amount).asReadOnly());
             a += amount;
         }

File: testsuite-http2/src/main/java/io/netty/testsuite/http2/Http2Server.java
Patch:
@@ -26,7 +26,7 @@
 import io.netty.handler.logging.LoggingHandler;
 
 /**
- * A HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
+ * An HTTP/2 Server that responds to requests with a Hello World. Once started, you can test the
  * server with the example client.
  */
 public final class Http2Server {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -275,7 +275,7 @@ public final void channelWritabilityChanged(final ChannelHandlerContext ctx) thr
             forEachActiveStream(AbstractHttp2StreamChannel.WRITABLE_VISITOR);
         }
 
-        ctx.fireChannelWritabilityChanged();
+        super.channelWritabilityChanged(ctx);
     }
 
     final void flush0(ChannelHandlerContext ctx) {

File: transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java
Patch:
@@ -75,7 +75,7 @@ public void testShutdownGracefullyNoQuietPeriod() throws Exception {
         b.bind(0).sync().channel();
 
         Future<?> f = loop.shutdownGracefully(0, 1, TimeUnit.MINUTES);
-        assertTrue(loop.awaitTermination(2, TimeUnit.SECONDS));
+        assertTrue(loop.awaitTermination(600, TimeUnit.MILLISECONDS));
         assertTrue(f.syncUninterruptibly().isSuccess());
         assertTrue(loop.isShutdown());
         assertTrue(loop.isTerminated());

File: transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
Patch:
@@ -122,7 +122,7 @@ public int guess() {
         }
 
         private void record(int actualReadBytes) {
-            if (actualReadBytes <= SIZE_TABLE[max(0, index - INDEX_DECREMENT - 1)]) {
+            if (actualReadBytes <= SIZE_TABLE[max(0, index - INDEX_DECREMENT)]) {
                 if (decreaseNow) {
                     index = max(index - INDEX_DECREMENT, minIndex);
                     nextReceiveBufferSize = SIZE_TABLE[index];

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -219,7 +219,7 @@ private static char forDigit(int digit) {
      * unreserved characters do not need to be encoded, and include uppercase and lowercase
      * letters, decimal digits, hyphen, period, underscore, and tilde.
      * <p>
-     * unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
+     * unreserved  = ALPHA / DIGIT / "-" / "_" / "." / "*"
      *
      * @param ch the char to be judged whether it need to be encode
      * @return true or false

File: handler/src/test/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngineTest.java
Patch:
@@ -72,7 +72,9 @@ public void testNotLeakOnException() throws Exception {
 
     @Override
     protected SslContext wrapContext(SslContext context) {
-        ((ReferenceCountedOpenSslContext) context).setUseTasks(useTasks);
+        if (context instanceof ReferenceCountedOpenSslContext) {
+            ((ReferenceCountedOpenSslContext) context).setUseTasks(useTasks);
+        }
         return context;
     }
 }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java
Patch:
@@ -56,9 +56,6 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 }
 
                 final int authMethodCnt = in.readUnsignedByte();
-                if (actualReadableBytes() < authMethodCnt) {
-                    break;
-                }
 
                 final Socks5AuthMethod[] authMethods = new Socks5AuthMethod[authMethodCnt];
                 for (int i = 0; i < authMethodCnt; i++) {

File: common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java
Patch:
@@ -274,7 +274,7 @@ public void run() {
                         //
                         // The above cases can be distinguished by performing a
                         // compareAndSet(NONE, RUNNING). If it returns "false", it is case 1; otherwise it is case 2.
-                        if (tasks.peek() == null || !state.compareAndSet(NONE, RUNNING)) {
+                        if (tasks.isEmpty() || !state.compareAndSet(NONE, RUNNING)) {
                             return; // done
                         }
                     }

File: handler/src/main/java/io/netty/handler/ssl/SslMasterKeyHandler.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.internal.tcnative.SSL;
 import io.netty.util.internal.ReflectionUtil;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -140,8 +139,7 @@ public final void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                     }
                     accept(secretKey, sslSession);
                 } else if (OpenSsl.isAvailable() && engine instanceof ReferenceCountedOpenSslEngine) {
-                    SecretKeySpec secretKey = new SecretKeySpec(
-                            SSL.getMasterKey(((ReferenceCountedOpenSslEngine) engine).sslPointer()), "AES");
+                    SecretKeySpec secretKey = ((ReferenceCountedOpenSslEngine) engine).masterKey();
                     accept(secretKey, sslSession);
                 }
             }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequest.java
Patch:
@@ -27,7 +27,6 @@
  * @see SocksAuthRequestDecoder
  */
 public final class SocksAuthRequest extends SocksRequest {
-    private static final CharsetEncoder asciiEncoder = CharsetUtil.encoder(CharsetUtil.US_ASCII);
     private static final SocksSubnegotiationVersion SUBNEGOTIATION_VERSION = SocksSubnegotiationVersion.AUTH_PASSWORD;
     private final String username;
     private final String password;
@@ -40,6 +39,7 @@ public SocksAuthRequest(String username, String password) {
         if (password == null) {
             throw new NullPointerException("username");
         }
+        final CharsetEncoder asciiEncoder = CharsetUtil.encoder(CharsetUtil.US_ASCII);
         if (!asciiEncoder.canEncode(username) || !asciiEncoder.canEncode(password)) {
             throw new IllegalArgumentException(
                     "username: " + username + " or password: **** values should be in pure ascii");

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutException.java
Patch:
@@ -18,8 +18,8 @@
 import io.netty.util.internal.PlatformDependent;
 
 /**
- * A {@link TimeoutException} raised by {@link WriteTimeoutHandler} when no data
- * was written within a certain period of time.
+ * A {@link TimeoutException} raised by {@link WriteTimeoutHandler} when a write operation
+ * cannot finish in a certain period of time.
  */
 public final class WriteTimeoutException extends TimeoutException {
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
Patch:
@@ -70,6 +70,7 @@ public class SocketTestPermutation {
             new OioEventLoopGroup(Integer.MAX_VALUE, new DefaultThreadFactory("testsuite-oio-worker", true));
 
     protected <A extends AbstractBootstrap<?, ?>, B extends AbstractBootstrap<?, ?>>
+
     List<BootstrapComboFactory<A, B>> combo(List<BootstrapFactory<A>> sbfs, List<BootstrapFactory<B>> cbfs) {
 
         List<BootstrapComboFactory<A, B>> list = new ArrayList<BootstrapComboFactory<A, B>>();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
Patch:
@@ -45,6 +45,8 @@ public final class EpollChannelOption<T> extends UnixChannelOption<T> {
 
     public static final ChannelOption<Map<InetAddress, byte[]>> TCP_MD5SIG = valueOf("TCP_MD5SIG");
 
+    public static final ChannelOption<Integer> MAX_DATAGRAM_PAYLOAD_SIZE = valueOf("MAX_DATAGRAM_PAYLOAD_SIZE");
+
     @SuppressWarnings({ "unused", "deprecation" })
     private EpollChannelOption() {
     }

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java
Patch:
@@ -323,7 +323,7 @@ private boolean doWriteMessage(Object msg) throws Exception {
             }
         } else if (data.nioBufferCount() > 1) {
             IovArray array = ((KQueueEventLoop) eventLoop()).cleanArray();
-            array.add(data);
+            array.add(data, data.readerIndex(), data.readableBytes());
             int cnt = array.count();
             assert cnt != 0;
 

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -270,10 +270,8 @@ public HashedWheelTimer(
         }
 
         if (duration < MILLISECOND_NANOS) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("Configured tickDuration {} smaller then {}, using 1ms.",
+            logger.warn("Configured tickDuration {} smaller then {}, using 1ms.",
                         tickDuration, MILLISECOND_NANOS);
-            }
             this.tickDuration = MILLISECOND_NANOS;
         } else {
             this.tickDuration = duration;

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -119,9 +119,7 @@ private void resumeTransfer0(ChannelHandlerContext ctx) {
         try {
             doFlush(ctx);
         } catch (Exception e) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("Unexpected exception while sending chunks.", e);
-            }
+            logger.warn("Unexpected exception while sending chunks.", e);
         }
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -701,9 +701,7 @@ private static void safeClosePipe(FileDescriptor fd) {
             try {
                 fd.close();
             } catch (IOException e) {
-                if (logger.isWarnEnabled()) {
-                    logger.warn("Error while closing a pipe", e);
-                }
+                logger.warn("Error while closing a pipe", e);
             }
         }
     }

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java
Patch:
@@ -79,9 +79,7 @@ public NioUdtMessageConnectorChannel(final Channel parent, final SocketChannelUD
             try {
                 channelUDT.close();
             } catch (final Exception e2) {
-                if (logger.isWarnEnabled()) {
-                    logger.warn("Failed to close channel.", e2);
-                }
+                logger.warn("Failed to close channel.", e2);
             }
             throw new ChannelException("Failed to configure channel.", e);
         }

File: transport/src/main/java/io/netty/channel/DefaultFileRegion.java
Patch:
@@ -161,9 +161,7 @@ protected void deallocate() {
         try {
             file.close();
         } catch (IOException e) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("Failed to close a file.", e);
-            }
+            logger.warn("Failed to close a file.", e);
         }
     }
 

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -86,10 +86,8 @@ protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInter
             try {
                 ch.close();
             } catch (IOException e2) {
-                if (logger.isWarnEnabled()) {
-                    logger.warn(
+                logger.warn(
                             "Failed to close a partially initialized socket.", e2);
-                }
             }
 
             throw new ChannelException("Failed to enter non-blocking mode.", e);

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -271,8 +271,8 @@ public HashedWheelTimer(
 
         if (duration < MILLISECOND_NANOS) {
             if (logger.isWarnEnabled()) {
-                logger.warn("Configured tickDuration %d smaller then %d, using 1ms.",
-                            tickDuration, MILLISECOND_NANOS);
+                logger.warn("Configured tickDuration {} smaller then {}, using 1ms.",
+                        tickDuration, MILLISECOND_NANOS);
             }
             this.tickDuration = MILLISECOND_NANOS;
         } else {

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
Patch:
@@ -47,7 +47,7 @@ public final <T extends DnsRecord> T decodeRecord(ByteBuf in) throws Exception {
         final String name = decodeName(in);
 
         final int endOffset = in.writerIndex();
-        if (endOffset - startOffset < 10) {
+        if (endOffset - in.readerIndex() < 10) {
             // Not enough data
             in.readerIndex(startOffset);
             return null;

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -532,15 +532,15 @@ public boolean contentEqualsIgnoreCase(CharSequence string) {
 
         if (string instanceof AsciiString) {
             AsciiString rhs = (AsciiString) string;
-            for (int i = arrayOffset(), j = rhs.arrayOffset(); i < length(); ++i, ++j) {
+            for (int i = arrayOffset(), j = rhs.arrayOffset(), end = i + length(); i < end; ++i, ++j) {
                 if (!equalsIgnoreCase(value[i], rhs.value[j])) {
                     return false;
                 }
             }
             return true;
         }
 
-        for (int i = arrayOffset(), j = 0; i < length(); ++i, ++j) {
+        for (int i = arrayOffset(), j = 0, end = length(); j < end; ++i, ++j) {
             if (!equalsIgnoreCase(b2c(value[i]), string.charAt(j))) {
                 return false;
             }

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java
Patch:
@@ -21,8 +21,8 @@
 import io.netty.channel.FileRegion;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.RandomAccessFile;
 import java.nio.channels.FileChannel;
 
 /**
@@ -45,7 +45,7 @@ public class ChunkedNioFile implements ChunkedInput<ByteBuf> {
      * Creates a new instance that fetches data from the specified file.
      */
     public ChunkedNioFile(File in) throws IOException {
-        this(new FileInputStream(in).getChannel());
+        this(new RandomAccessFile(in, "r").getChannel());
     }
 
     /**
@@ -55,7 +55,7 @@ public ChunkedNioFile(File in) throws IOException {
      *                  {@link #readChunk(ChannelHandlerContext)} call
      */
     public ChunkedNioFile(File in, int chunkSize) throws IOException {
-        this(new FileInputStream(in).getChannel(), chunkSize);
+        this(new RandomAccessFile(in, "r").getChannel(), chunkSize);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java
Patch:
@@ -757,6 +757,8 @@ public void beginRead() {
             if (!isActive()) {
                 return;
             }
+            updateLocalWindowIfNeeded();
+
             switch (readStatus) {
                 case IDLE:
                     readStatus = ReadStatus.IN_PROGRESS;
@@ -833,8 +835,6 @@ void notifyReadComplete(RecvByteBufAllocator.Handle allocHandle, boolean forceRe
                 readStatus = ReadStatus.IDLE;
             }
 
-            updateLocalWindowIfNeeded();
-
             allocHandle.readComplete();
             pipeline().fireChannelReadComplete();
             // Reading data may result in frames being written (e.g. WINDOW_UPDATE, RST, etc..). If the parent

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -110,7 +110,7 @@ public final ByteBuf capacity(int newCapacity) {
                     (maxLength > 512 || newCapacity > maxLength - 16)) {
                 // here newCapacity < length
                 length = newCapacity;
-                setIndex(Math.min(readerIndex(), newCapacity), Math.min(writerIndex(), newCapacity));
+                trimIndicesToCapacity(newCapacity);
                 return this;
             }
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
Patch:
@@ -108,7 +108,7 @@ public static WebSocketClientHandshaker newHandshaker(
             boolean allowExtensions, HttpHeaders customHeaders, int maxFramePayloadLength,
             boolean performMasking, boolean allowMaskMismatch) {
         return newHandshaker(webSocketURL, version, subprotocol, allowExtensions, customHeaders,
-                maxFramePayloadLength, true, false, -1);
+                maxFramePayloadLength, performMasking, allowMaskMismatch, -1);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -132,6 +132,8 @@ public static long calculateMaxHeaderListSizeGoAway(long maxHeaderListSize) {
 
     public static final long DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS = MILLISECONDS.convert(30, SECONDS);
 
+    public static final int DEFAULT_MAX_QUEUED_CONTROL_FRAMES = 10000;
+
     /**
      * Returns {@code true} if the stream is an outbound stream.
      *

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelId;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelMetadata;
@@ -873,8 +874,8 @@ protected void onUnhandledInboundException(Throwable cause) {
         }
 
         @Override
-        protected void onUnhandledInboundMessage(Object msg) {
-          handleInboundMessage(msg);
+        protected void onUnhandledInboundMessage(ChannelHandlerContext ctx, Object msg) {
+            handleInboundMessage(msg);
         }
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -126,8 +126,8 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object
 
         int length = data.readableBytes();
 
-        if (logger.isDebugEnabled()) {
-            logger.debug("Encoding WebSocket Frame opCode=" + opcode + " length=" + length);
+        if (logger.isTraceEnabled()) {
+            logger.trace("Encoding WebSocket Frame opCode={} length={}", opcode, length);
         }
 
         int b0 = 0;

File: common/src/main/java/io/netty/util/concurrent/Future.java
Patch:
@@ -155,14 +155,14 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
      * Return the result without blocking. If the future is not done yet this will return {@code null}.
      *
      * As it is possible that a {@code null} value is used to mark the future as successful you also need to check
-     * if the future is really done with {@link #isDone()} and not relay on the returned {@code null} value.
+     * if the future is really done with {@link #isDone()} and not rely on the returned {@code null} value.
      */
     V getNow();
 
     /**
      * {@inheritDoc}
      *
-     * If the cancellation was successful it will fail the future with an {@link CancellationException}.
+     * If the cancellation was successful it will fail the future with a {@link CancellationException}.
      */
     @Override
     boolean cancel(boolean mayInterruptIfRunning);

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
Patch:
@@ -228,7 +228,8 @@ public void write(final ChannelHandlerContext ctx, final Object msg, final Chann
     }
 
     private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {
-        HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN);
+        HttpResponse response = new DefaultFullHttpResponse(
+                request.protocolVersion(), FORBIDDEN, ctx.alloc().buffer(0));
         response.headers().set(HttpHeaderNames.CONTENT_LENGTH, HttpHeaderValues.ZERO);
         release(request);
         respond(ctx, request, response);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
Patch:
@@ -108,7 +108,7 @@ private WebSocketFrame decodeBinaryFrame(ChannelHandlerContext ctx, byte type, B
 
         if (type == (byte) 0xFF && frameSize == 0) {
             receivedClosingHandshake = true;
-            return new CloseWebSocketFrame();
+            return new CloseWebSocketFrame(true, 0, ctx.alloc().buffer(0));
         }
         ByteBuf payload = readBytes(ctx.alloc(), buffer, (int) frameSize);
         return new BinaryWebSocketFrame(payload);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -178,7 +178,8 @@ protected FullHttpRequest newHandshakeRequest() {
         URI wsURL = uri();
 
         // Format request
-        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL));
+        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL),
+                Unpooled.wrappedBuffer(key3));
         HttpHeaders headers = request.headers();
 
         if (customHeaders != null) {
@@ -200,7 +201,6 @@ protected FullHttpRequest newHandshakeRequest() {
         // Set Content-Length to workaround some known defect.
         // See also: http://www.ietf.org/mail-archive/web/hybi/current/msg02149.html
         headers.set(HttpHeaderNames.CONTENT_LENGTH, key3.length);
-        request.content().writeBytes(key3);
         return request;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -211,7 +212,8 @@ protected FullHttpRequest newHandshakeRequest() {
         }
 
         // Format request
-        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL));
+        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL),
+                Unpooled.EMPTY_BUFFER);
         HttpHeaders headers = request.headers();
 
         if (customHeaders != null) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -213,7 +214,8 @@ protected FullHttpRequest newHandshakeRequest() {
         }
 
         // Format request
-        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL));
+        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL),
+                Unpooled.EMPTY_BUFFER);
         HttpHeaders headers = request.headers();
 
         if (customHeaders != null) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -214,7 +215,8 @@ protected FullHttpRequest newHandshakeRequest() {
         }
 
         // Format request
-        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL));
+        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, upgradeUrl(wsURL),
+                Unpooled.EMPTY_BUFFER);
         HttpHeaders headers = request.headers();
 
         if (customHeaders != null) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -141,7 +141,8 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
 
         // Create the WebSocket handshake response.
         FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, new HttpResponseStatus(101,
-                isHixie76 ? "WebSocket Protocol Handshake" : "Web Socket Protocol Handshake"));
+                isHixie76 ? "WebSocket Protocol Handshake" : "Web Socket Protocol Handshake"),
+                req.content().alloc().buffer(0));
         if (headers != null) {
             res.headers().add(headers);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -134,7 +134,8 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         }
 
         FullHttpResponse res =
-                new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS);
+                new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS,
+                        req.content().alloc().buffer(0));
 
         if (headers != null) {
             res.headers().add(headers);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -140,7 +140,8 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             throw new WebSocketHandshakeException("not a WebSocket request: missing key");
         }
 
-        FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS);
+        FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS,
+                req.content().alloc().buffer(0));
 
         if (headers != null) {
             res.headers().add(headers);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -139,7 +139,8 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             throw new WebSocketHandshakeException("not a WebSocket request: missing key");
         }
 
-        FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS);
+        FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.SWITCHING_PROTOCOLS,
+                req.content().alloc().buffer(0));
         if (headers != null) {
             res.headers().add(headers);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -172,7 +172,7 @@ public static ChannelFuture sendUnsupportedVersionResponse(Channel channel) {
     public static ChannelFuture sendUnsupportedVersionResponse(Channel channel, ChannelPromise promise) {
         HttpResponse res = new DefaultFullHttpResponse(
                 HttpVersion.HTTP_1_1,
-                HttpResponseStatus.UPGRADE_REQUIRED);
+                HttpResponseStatus.UPGRADE_REQUIRED, channel.alloc().buffer(0));
         res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, WebSocketVersion.V13.toHttpHeaderValue());
         HttpUtil.setContentLength(res, 0);
         return channel.writeAndFlush(res, promise);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -266,7 +266,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 if (msg instanceof FullHttpRequest) {
                     ((FullHttpRequest) msg).release();
                     FullHttpResponse response =
-                            new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.FORBIDDEN);
+                            new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.FORBIDDEN, ctx.alloc().buffer(0));
                     ctx.channel().writeAndFlush(response);
                 } else {
                     ctx.fireChannelRead(msg);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -77,7 +77,7 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
 
         try {
             if (!GET.equals(req.method())) {
-                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
+                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN, ctx.alloc().buffer(0)));
                 return;
             }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08EncoderDecoderTest.java
Patch:
@@ -76,6 +76,7 @@ public void testWebSocketProtocolViolation() {
         Assert.assertNotNull(response);
         Assert.assertEquals(expectedStatus.code(), response.statusCode());
         Assert.assertEquals(errorMessage, response.reasonText());
+        response.release();
 
         // Without auto-close
         config = WebSocketDecoderConfig.newBuilder()

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
Patch:
@@ -258,7 +258,9 @@ protected WebSocketFrameEncoder newWebSocketEncoder() {
         // Create a EmbeddedChannel which we will use to encode a BinaryWebsocketFrame to bytes and so use these
         // to test the actual handshaker.
         WebSocketServerHandshakerFactory factory = new WebSocketServerHandshakerFactory(url, null, false);
-        WebSocketServerHandshaker socketServerHandshaker = factory.newHandshaker(shaker.newHandshakeRequest());
+        FullHttpRequest request = shaker.newHandshakeRequest();
+        WebSocketServerHandshaker socketServerHandshaker = factory.newHandshaker(request);
+        request.release();
         EmbeddedChannel websocketChannel = new EmbeddedChannel(socketServerHandshaker.newWebSocketEncoder(),
                 socketServerHandshaker.newWebsocketDecoder());
         assertTrue(websocketChannel.writeOutbound(new BinaryWebSocketFrame(Unpooled.wrappedBuffer(data))));

File: example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.http.cors;
 
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
@@ -30,7 +31,8 @@
 public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {
     @Override
     public void channelRead0(ChannelHandlerContext ctx, Object msg) {
-        final FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        final FullHttpResponse response = new DefaultFullHttpResponse(
+                HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.EMPTY_BUFFER);
         response.headers().set("custom-response-header", "Some value");
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.example.http.snoop;
 
 import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
@@ -83,7 +84,7 @@ public static void main(String[] args) throws Exception {
 
             // Prepare the HTTP request.
             HttpRequest request = new DefaultFullHttpRequest(
-                    HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());
+                    HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath(), Unpooled.EMPTY_BUFFER);
             request.headers().set(HttpHeaderNames.HOST, host);
             request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);
             request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -185,7 +185,7 @@ private boolean writeResponse(HttpObject currentObj, ChannelHandlerContext ctx)
     }
 
     private static void send100Continue(ChannelHandlerContext ctx) {
-        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, CONTINUE);
+        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, CONTINUE, Unpooled.EMPTY_BUFFER);
         ctx.write(response);
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/benchmarkserver/WebSocketServerHandler.java
Patch:
@@ -72,13 +72,13 @@ public void channelReadComplete(ChannelHandlerContext ctx) {
     private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) {
         // Handle a bad request.
         if (!req.decoderResult().isSuccess()) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST, Unpooled.EMPTY_BUFFER));
             return;
         }
 
         // Allow only GET methods.
         if (!GET.equals(req.method())) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN, Unpooled.EMPTY_BUFFER));
             return;
         }
 
@@ -94,7 +94,7 @@ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) {
             return;
         }
         if ("/favicon.ico".equals(req.uri())) {
-            FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND);
+            FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND, Unpooled.EMPTY_BUFFER);
             sendHttpResponse(ctx, req, res);
             return;
         }

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketIndexPageHandler.java
Patch:
@@ -57,13 +57,13 @@ public WebSocketIndexPageHandler(String websocketPath) {
     protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
         // Handle a bad request.
         if (!req.decoderResult().isSuccess()) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST, Unpooled.EMPTY_BUFFER));
             return;
         }
 
         // Allow only GET methods.
         if (!GET.equals(req.method())) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN, Unpooled.EMPTY_BUFFER));
             return;
         }
 
@@ -78,7 +78,7 @@ protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) thro
 
             sendHttpResponse(ctx, req, res);
         } else {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND, Unpooled.EMPTY_BUFFER));
         }
     }
 

File: example/src/main/java/io/netty/example/http2/helloworld/client/Http2Client.java
Patch:
@@ -15,6 +15,7 @@
 package io.netty.example.http2.helloworld.client;
 
 import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
@@ -113,7 +114,7 @@ public static void main(String[] args) throws Exception {
             System.err.println("Sending request(s)...");
             if (URL != null) {
                 // Create a simple GET request.
-                FullHttpRequest request = new DefaultFullHttpRequest(HTTP_1_1, GET, URL);
+                FullHttpRequest request = new DefaultFullHttpRequest(HTTP_1_1, GET, URL, Unpooled.EMPTY_BUFFER);
                 request.headers().add(HttpHeaderNames.HOST, hostName);
                 request.headers().add(HttpConversionUtil.ExtensionHeaderNames.SCHEME.text(), scheme.name());
                 request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);

File: example/src/main/java/io/netty/example/http2/helloworld/client/Http2ClientInitializer.java
Patch:
@@ -14,6 +14,7 @@
  */
 package io.netty.example.http2.helloworld.client;
 
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
@@ -137,7 +138,7 @@ private final class UpgradeRequestHandler extends ChannelInboundHandlerAdapter {
         @Override
         public void channelActive(ChannelHandlerContext ctx) throws Exception {
             DefaultFullHttpRequest upgradeRequest =
-                    new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
+                    new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/", Unpooled.EMPTY_BUFFER);
 
             // Set HOST header as the remote peer may require it.
             InetSocketAddress remote = (InetSocketAddress) ctx.channel().remoteAddress();

File: example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp1Handler.java
Patch:
@@ -28,6 +28,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
@@ -49,7 +50,7 @@ public HelloWorldHttp1Handler(String establishApproach) {
     @Override
     public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
         if (HttpUtil.is100ContinueExpected(req)) {
-            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
+            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE, Unpooled.EMPTY_BUFFER));
         }
         boolean keepAlive = HttpUtil.isKeepAlive(req);
 

File: example/src/main/java/io/netty/example/http2/tiles/FallbackRequestHandler.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.netty.example.http2.tiles;
 
+import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
 import static io.netty.buffer.Unpooled.copiedBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
@@ -47,7 +48,7 @@ public final class FallbackRequestHandler extends SimpleChannelInboundHandler<Ht
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, HttpRequest req) throws Exception {
         if (HttpUtil.is100ContinueExpected(req)) {
-            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
+            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE, EMPTY_BUFFER));
         }
 
         ByteBuf content = ctx.alloc().buffer();

File: example/src/main/java/io/netty/example/http2/tiles/Http1RequestHandler.java
Patch:
@@ -23,6 +23,8 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
 import static io.netty.handler.codec.http.HttpVersion.HTTP_1_0;
 import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
@@ -40,7 +42,7 @@ public final class Http1RequestHandler extends Http2RequestHandler {
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
         if (HttpUtil.is100ContinueExpected(request)) {
-            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
+            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE, Unpooled.EMPTY_BUFFER));
         }
         super.channelRead0(ctx, request);
     }

File: example/src/main/java/io/netty/example/ocsp/OcspClientExample.java
Patch:
@@ -21,6 +21,7 @@
 import javax.net.ssl.SSLSession;
 import javax.security.cert.X509Certificate;
 
+import io.netty.buffer.Unpooled;
 import org.bouncycastle.asn1.ocsp.OCSPResponseStatus;
 import org.bouncycastle.cert.ocsp.BasicOCSPResp;
 import org.bouncycastle.cert.ocsp.CertificateStatus;
@@ -164,7 +165,8 @@ private static class HttpClientHandler extends ChannelInboundHandlerAdapter {
 
         @Override
         public void channelActive(ChannelHandlerContext ctx) throws Exception {
-            FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
+            FullHttpRequest request = new DefaultFullHttpRequest(
+                    HttpVersion.HTTP_1_1, HttpMethod.GET, "/", Unpooled.EMPTY_BUFFER);
             request.headers().set(HttpHeaderNames.HOST, host);
             request.headers().set(HttpHeaderNames.USER_AGENT, "netty-ocsp-example/1.0");
 

File: example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.example.spdy.client;
 
 import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
@@ -84,7 +85,8 @@ public static void main(String[] args) throws Exception {
             System.out.println("Connected to " + HOST + ':' + PORT);
 
             // Create a GET request.
-            HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "");
+            HttpRequest request = new DefaultFullHttpRequest(
+                    HttpVersion.HTTP_1_1, HttpMethod.GET, "", Unpooled.EMPTY_BUFFER);
             request.headers().set(HttpHeaderNames.HOST, HOST);
             request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);
 

File: example/src/main/java/io/netty/example/spdy/server/SpdyServerHandler.java
Patch:
@@ -50,7 +50,7 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
             HttpRequest req = (HttpRequest) msg;
 
             if (is100ContinueExpected(req)) {
-                ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
+                ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE, Unpooled.EMPTY_BUFFER));
             }
             boolean keepAlive = isKeepAlive(req);
 

File: testsuite-autobahn/src/main/java/io/netty/testsuite/autobahn/AutobahnServerHandler.java
Patch:
@@ -73,13 +73,13 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req)
             throws Exception {
         // Handle a bad request.
         if (!req.decoderResult().isSuccess()) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST, ctx.alloc().buffer(0)));
             return;
         }
 
         // Allow only GET methods.
         if (!GET.equals(req.method())) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
+            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN, ctx.alloc().buffer(0)));
             return;
         }
 

File: testsuite-http2/src/main/java/io/netty/testsuite/http2/HelloWorldHttp1Handler.java
Patch:
@@ -47,7 +47,7 @@ public class HelloWorldHttp1Handler extends SimpleChannelInboundHandler<FullHttp
     @Override
     public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
         if (HttpUtil.is100ContinueExpected(req)) {
-            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
+            ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE, ctx.alloc().buffer(0)));
         }
         boolean keepAlive = HttpUtil.isKeepAlive(req);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -209,8 +209,8 @@ public final ChannelFuture handshake(Channel channel, FullHttpRequest req,
                         new IllegalStateException("No HttpDecoder and no HttpServerCodec in the pipeline"));
                 return promise;
             }
-            p.addBefore(ctx.name(), "wsdecoder", newWebsocketDecoder());
             p.addBefore(ctx.name(), "wsencoder", newWebSocketEncoder());
+            p.addBefore(ctx.name(), "wsdecoder", newWebsocketDecoder());
             encoderName = ctx.name();
         } else {
             p.replace(ctx.name(), "wsdecoder", newWebsocketDecoder());

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java
Patch:
@@ -783,7 +783,7 @@ void doBeginRead() {
                 do {
                     flowControlledBytes += doRead0((Http2Frame) message, allocHandle);
                 } while ((readEOS || (continueReading = allocHandle.continueReading())) &&
-                        (message = inboundBuffer.poll()) != null);
+                        inboundBuffer != null && (message = inboundBuffer.poll()) != null);
 
                 if (continueReading && isParentReadInProgress() && !readEOS) {
                     // Currently the parent and child channel are on the same EventLoop thread. If the parent is

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -205,7 +205,7 @@ public final ChannelFuture spliceTo(final FileDescriptor ch, final int offset, f
     public final ChannelFuture spliceTo(final FileDescriptor ch, final int offset, final int len,
                                         final ChannelPromise promise) {
         checkPositiveOrZero(len, "len");
-        checkPositiveOrZero(offset, "offser");
+        checkPositiveOrZero(offset, "offset");
         if (config().getEpollMode() != EpollMode.LEVEL_TRIGGERED) {
             throw new IllegalStateException("spliceTo() supported only when using " + EpollMode.LEVEL_TRIGGERED);
         }
@@ -977,7 +977,7 @@ public boolean spliceOut() throws Exception {
     private final class SpliceFdTask extends SpliceInTask {
         private final FileDescriptor fd;
         private final ChannelPromise promise;
-        private final int offset;
+        private int offset;
 
         SpliceFdTask(FileDescriptor fd, int offset, int len, ChannelPromise promise) {
             super(len, promise);
@@ -1007,6 +1007,7 @@ public boolean spliceIn(RecvByteBufAllocator.Handle handle) {
                         }
                         do {
                             int splicedOut = Native.splice(pipeIn.intValue(), -1, fd.intValue(), offset, splicedIn);
+                            offset += splicedOut;
                             splicedIn -= splicedOut;
                         } while (splicedIn > 0);
                         if (len == 0) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -213,13 +213,13 @@ public void handlerAdded(ChannelHandlerContext ctx) {
         ChannelPipeline cp = ctx.pipeline();
         if (cp.get(WebSocketServerProtocolHandshakeHandler.class) == null) {
             // Add the WebSocketHandshakeHandler before this one.
-            ctx.pipeline().addBefore(ctx.name(), WebSocketServerProtocolHandshakeHandler.class.getName(),
+            cp.addBefore(ctx.name(), WebSocketServerProtocolHandshakeHandler.class.getName(),
                     new WebSocketServerProtocolHandshakeHandler(
                         websocketPath, subprotocols, checkStartsWith, handshakeTimeoutMillis, decoderConfig));
         }
         if (cp.get(Utf8FrameValidator.class) == null) {
             // Add the UFT8 checking before this one.
-            ctx.pipeline().addBefore(ctx.name(), Utf8FrameValidator.class.getName(),
+            cp.addBefore(ctx.name(), Utf8FrameValidator.class.getName(),
                     new Utf8FrameValidator());
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -44,8 +44,6 @@
  */
 class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {
 
-    private static final long DEFAULT_HANDSHAKE_TIMEOUT_MS = 10000L;
-
     private final String websocketPath;
     private final String subprotocols;
     private final boolean checkStartsWith;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -189,7 +189,7 @@ public WebSocketClientHandshaker13(URI webSocketURL, WebSocketVersion version, S
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
-     * Sec-WebSocket-Origin: http://example.com
+     * Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 13
      * </pre>
@@ -225,7 +225,7 @@ protected FullHttpRequest newHandshakeRequest() {
                .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
                .set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key)
                .set(HttpHeaderNames.HOST, websocketHostValue(wsURL))
-               .set(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(wsURL));
+               .set(HttpHeaderNames.ORIGIN, websocketOriginValue(wsURL));
 
         String expectedSubprotocol = expectedSubprotocol();
         if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {
@@ -251,7 +251,7 @@ protected FullHttpRequest newHandshakeRequest() {
      *
      * @param response
      *            HTTP response returned from the server for the request sent by beginOpeningHandshake00().
-     * @throws WebSocketHandshakeException
+     * @throws WebSocketHandshakeException if handshake response is invalid.
      */
     @Override
     protected void verify(FullHttpResponse response) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -115,7 +115,7 @@ public WebSocketServerHandshaker13(
      * Upgrade: websocket
      * Connection: Upgrade
      * Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
-     * Sec-WebSocket-Origin: http://example.com
+     * Origin: http://example.com
      * Sec-WebSocket-Protocol: chat, superchat
      * Sec-WebSocket-Version: 13
      * </pre>

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07Test.java
Patch:
@@ -46,7 +46,7 @@ protected CharSequence[] getHandshakeHeaderNames() {
                 HttpHeaderNames.CONNECTION,
                 HttpHeaderNames.SEC_WEBSOCKET_KEY,
                 HttpHeaderNames.HOST,
-                HttpHeaderNames.SEC_WEBSOCKET_ORIGIN,
+                getOriginHeaderName(),
                 HttpHeaderNames.SEC_WEBSOCKET_VERSION,
         };
     }

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackDecoderBenchmark.java
Patch:
@@ -72,7 +72,7 @@ public void teardown() {
     @Benchmark
     @BenchmarkMode(Mode.Throughput)
     public void decode(final Blackhole bh) throws Http2Exception {
-        HpackDecoder hpackDecoder = new HpackDecoder(DEFAULT_HEADER_LIST_SIZE);
+        HpackDecoder hpackDecoder = new HpackDecoder(Integer.MAX_VALUE);
         @SuppressWarnings("unchecked")
         Http2Headers headers =
                 new DefaultHttp2Headers() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -89,6 +89,7 @@ final class HpackDecoder {
     private static final byte READ_LITERAL_HEADER_VALUE_LENGTH = 8;
     private static final byte READ_LITERAL_HEADER_VALUE = 9;
 
+    private final HpackHuffmanDecoder huffmanDecoder = new HpackHuffmanDecoder();
     private final HpackDynamicTable hpackDynamicTable;
     private long maxHeaderListSize;
     private long maxDynamicTableSize;
@@ -445,7 +446,7 @@ private void insertHeader(Sink sink, CharSequence name, CharSequence value, Inde
 
     private CharSequence readStringLiteral(ByteBuf in, int length, boolean huffmanEncoded) throws Http2Exception {
         if (huffmanEncoded) {
-            return HpackHuffmanDecoder.decode(in, length);
+            return huffmanDecoder.decode(in, length);
         }
         byte[] buf = new byte[length];
         in.readBytes(buf);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackHuffmanTest.java
Patch:
@@ -153,7 +153,7 @@ private static void roundTrip(HpackHuffmanEncoder encoder, byte[] buf)
     private static byte[] decode(byte[] bytes) throws Http2Exception {
         ByteBuf buffer = Unpooled.wrappedBuffer(bytes);
         try {
-            AsciiString decoded = HpackHuffmanDecoder.decode(buffer, buffer.readableBytes());
+            AsciiString decoded = new HpackHuffmanDecoder().decode(buffer, buffer.readableBytes());
             Assert.assertFalse(buffer.isReadable());
             return decoded.toByteArray();
         } finally {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -117,7 +117,6 @@ public final class Http2CodecUtil {
     public static final int SMALLEST_MAX_CONCURRENT_STREAMS = 100;
     static final int DEFAULT_MAX_RESERVED_STREAMS = SMALLEST_MAX_CONCURRENT_STREAMS;
     static final int DEFAULT_MIN_ALLOCATION_CHUNK = 1024;
-    static final int DEFAULT_INITIAL_HUFFMAN_DECODE_CAPACITY = 32;
 
     /**
      * Calculate the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java
Patch:
@@ -88,6 +88,7 @@ public Http2ConnectionHandlerBuilder headerSensitivityDetector(SensitivityDetect
     }
 
     @Override
+    @Deprecated
     public Http2ConnectionHandlerBuilder initialHuffmanDecodeCapacity(int initialHuffmanDecodeCapacity) {
         return super.initialHuffmanDecodeCapacity(initialHuffmanDecodeCapacity);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodecBuilder.java
Patch:
@@ -137,6 +137,7 @@ public Http2FrameCodecBuilder encoderIgnoreMaxHeaderListSize(boolean ignoreMaxHe
     }
 
     @Override
+    @Deprecated
     public Http2FrameCodecBuilder initialHuffmanDecodeCapacity(int initialHuffmanDecodeCapacity) {
         return super.initialHuffmanDecodeCapacity(initialHuffmanDecodeCapacity);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -166,6 +166,7 @@ public Http2MultiplexCodecBuilder encoderIgnoreMaxHeaderListSize(boolean ignoreM
     }
 
     @Override
+    @Deprecated
     public Http2MultiplexCodecBuilder initialHuffmanDecodeCapacity(int initialHuffmanDecodeCapacity) {
         return super.initialHuffmanDecodeCapacity(initialHuffmanDecodeCapacity);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerBuilder.java
Patch:
@@ -80,6 +80,7 @@ public HttpToHttp2ConnectionHandlerBuilder headerSensitivityDetector(
     }
 
     @Override
+    @Deprecated
     public HttpToHttp2ConnectionHandlerBuilder initialHuffmanDecodeCapacity(int initialHuffmanDecodeCapacity) {
         return super.initialHuffmanDecodeCapacity(initialHuffmanDecodeCapacity);
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java
Patch:
@@ -79,7 +79,7 @@ private void decode(String encoded) throws Http2Exception {
 
     @Before
     public void setUp() {
-        hpackDecoder = new HpackDecoder(8192, 32);
+        hpackDecoder = new HpackDecoder(8192);
         mockHeaders = mock(Http2Headers.class);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackEncoderTest.java
Patch:
@@ -33,7 +33,7 @@ public class HpackEncoderTest {
     @Before
     public void setUp() {
         hpackEncoder = new HpackEncoder();
-        hpackDecoder = new HpackDecoder(DEFAULT_HEADER_LIST_SIZE, 32);
+        hpackDecoder = new HpackDecoder(DEFAULT_HEADER_LIST_SIZE);
         mockHeaders = mock(Http2Headers.class);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackTestCase.java
Patch:
@@ -174,7 +174,7 @@ private HpackDecoder createDecoder() {
             maxHeaderTableSize = Integer.MAX_VALUE;
         }
 
-        return new HpackDecoder(DEFAULT_HEADER_LIST_SIZE, 32, maxHeaderTableSize);
+        return new HpackDecoder(DEFAULT_HEADER_LIST_SIZE, maxHeaderTableSize);
     }
 
     private static byte[] encode(HpackEncoder hpackEncoder, List<HpackHeaderField> headers, int maxHeaderTableSize,

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -139,7 +139,7 @@ public static HpackDecoder newTestDecoder() {
     }
 
     public static HpackDecoder newTestDecoder(long maxHeaderListSize, long maxHeaderTableSize) throws Http2Exception {
-        HpackDecoder hpackDecoder = new HpackDecoder(maxHeaderListSize, 32);
+        HpackDecoder hpackDecoder = new HpackDecoder(maxHeaderListSize);
         hpackDecoder.setMaxHeaderTableSize(maxHeaderTableSize);
         return hpackDecoder;
     }

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackDecoderBenchmark.java
Patch:
@@ -72,7 +72,7 @@ public void teardown() {
     @Benchmark
     @BenchmarkMode(Mode.Throughput)
     public void decode(final Blackhole bh) throws Http2Exception {
-        HpackDecoder hpackDecoder = new HpackDecoder(DEFAULT_HEADER_LIST_SIZE, 32);
+        HpackDecoder hpackDecoder = new HpackDecoder(DEFAULT_HEADER_LIST_SIZE);
         @SuppressWarnings("unchecked")
         Http2Headers headers =
                 new DefaultHttp2Headers() {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -119,7 +119,7 @@ public static HpackEncoder newTestEncoder() {
 
     public static HpackEncoder newTestEncoder(boolean ignoreMaxHeaderListSize,
                                               long maxHeaderListSize, long maxHeaderTableSize) throws Http2Exception {
-        HpackEncoder hpackEncoder = new HpackEncoder();
+        HpackEncoder hpackEncoder = new HpackEncoder(false, 16, 0);
         ByteBuf buf = Unpooled.buffer();
         try {
             hpackEncoder.setMaxHeaderTableSize(buf, maxHeaderTableSize);

File: buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
Patch:
@@ -163,7 +163,8 @@ public boolean markSupported() {
 
     @Override
     public int read() throws IOException {
-        if (!buffer.isReadable()) {
+        int available = available();
+        if (available == 0) {
             return -1;
         }
         return buffer.readByte() & 0xff;

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -1095,7 +1095,7 @@ private static String prettyHexDump(ByteBuf buffer, int offset, int length) {
             if (length == 0) {
               return StringUtil.EMPTY_STRING;
             } else {
-                int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;
+                int rows = length / 16 + ((length & 15) == 0? 0 : 1) + 4;
                 StringBuilder buf = new StringBuilder(rows * 80);
                 appendPrettyHexDump(buf, buffer, offset, length);
                 return buf.toString();

File: transport/src/main/java/io/netty/channel/ChannelHandlerMask.java
Patch:
@@ -175,7 +175,7 @@ public Boolean run() throws Exception {
                         "Class {} missing method {}, assume we can not skip execution", handlerType, methodName, e);
                     return false;
                 }
-                return m.isAnnotationPresent(Skip.class);
+                return m != null && m.isAnnotationPresent(Skip.class);
             }
         });
     }

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -113,6 +113,7 @@ final class SslUtils {
         defaultCiphers.add("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384");
         defaultCiphers.add("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256");
         defaultCiphers.add("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256");
+        defaultCiphers.add("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384");
         defaultCiphers.add("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA");
         // AES256 requires JCE unlimited strength jurisdiction policy files.
         defaultCiphers.add("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA");

File: buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
Patch:
@@ -684,7 +684,7 @@ public int readBytes(FileChannel out, long position, int length) {
     @Override
     public CharSequence readCharSequence(int length, Charset charset) {
         checkLength(length);
-        return null;
+        return StringUtil.EMPTY_STRING;
     }
 
     @Override

File: example/src/main/java/io/netty/example/http2/helloworld/frame/server/Http2ServerInitializer.java
Patch:
@@ -100,8 +100,7 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws E
                 // If this handler is hit then no upgrade has been attempted and the client is just talking HTTP.
                 System.err.println("Directly talking: " + msg.protocolVersion() + " (no upgrade was attempted)");
                 ChannelPipeline pipeline = ctx.pipeline();
-                ChannelHandlerContext thisCtx = pipeline.context(this);
-                pipeline.addAfter(thisCtx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
+                pipeline.addAfter(ctx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
                 pipeline.replace(this, null, new HttpObjectAggregator(maxHttpContentLength));
                 ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
             }

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2ServerInitializer.java
Patch:
@@ -102,8 +102,7 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws E
                 // If this handler is hit then no upgrade has been attempted and the client is just talking HTTP.
                 System.err.println("Directly talking: " + msg.protocolVersion() + " (no upgrade was attempted)");
                 ChannelPipeline pipeline = ctx.pipeline();
-                ChannelHandlerContext thisCtx = pipeline.context(this);
-                pipeline.addAfter(thisCtx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
+                pipeline.addAfter(ctx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
                 pipeline.replace(this, null, new HttpObjectAggregator(maxHttpContentLength));
                 ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
             }

File: example/src/main/java/io/netty/example/http2/helloworld/server/Http2ServerInitializer.java
Patch:
@@ -101,8 +101,7 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws E
                 // If this handler is hit then no upgrade has been attempted and the client is just talking HTTP.
                 System.err.println("Directly talking: " + msg.protocolVersion() + " (no upgrade was attempted)");
                 ChannelPipeline pipeline = ctx.pipeline();
-                ChannelHandlerContext thisCtx = pipeline.context(this);
-                pipeline.addAfter(thisCtx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
+                pipeline.addAfter(ctx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
                 pipeline.replace(this, null, new HttpObjectAggregator(maxHttpContentLength));
                 ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -638,7 +638,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                         replacement.append("; ")
                                    .append(HttpHeaderValues.FILENAME)
                                    .append("=\"")
-                                   .append(fileUpload.getFilename())
+                                   .append(currentFileUpload.getFilename())
                                    .append('"');
                     }
 

File: microbench/src/main/java/io/netty/microbench/internal/RecyclableArrayListBenchmark.java
Patch:
@@ -36,8 +36,8 @@ public class RecyclableArrayListBenchmark extends AbstractMicrobenchmark {
     public int size;
 
     @Benchmark
-    public void recycleSameThread() {
+    public boolean recycleSameThread() {
         RecyclableArrayList list = RecyclableArrayList.newInstance(size);
-        list.recycle();
+        return list.recycle();
     }
 }

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollEventLoopTest.java
Patch:
@@ -51,7 +51,7 @@ public void testScheduleBigDelayNotOverflow() {
 
         final EventLoopGroup group = new EpollEventLoop(null,
                 new ThreadPerTaskExecutor(new DefaultThreadFactory(getClass())), 0,
-                DefaultSelectStrategyFactory.INSTANCE.newSelectStrategy(), RejectedExecutionHandlers.reject()) {
+                DefaultSelectStrategyFactory.INSTANCE.newSelectStrategy(), RejectedExecutionHandlers.reject(), null) {
             @Override
             void handleLoopException(Throwable t) {
                 capture.set(t);

File: handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java
Patch:
@@ -78,8 +78,6 @@ public void run() {
                 perChannel.channelTrafficCounter.resetAccounting(newLastTime);
             }
             trafficShapingHandler1.doAccounting(counter);
-            counter.scheduledFuture = counter.executor.schedule(this, counter.checkInterval.get(),
-                                                                TimeUnit.MILLISECONDS);
         }
     }
 
@@ -97,7 +95,7 @@ public synchronized void start() {
             monitorActive = true;
             monitor = new MixedTrafficMonitoringTask((GlobalChannelTrafficShapingHandler) trafficShapingHandler, this);
             scheduledFuture =
-                executor.schedule(monitor, localCheckInterval, TimeUnit.MILLISECONDS);
+                executor.scheduleAtFixedRate(monitor, 0, localCheckInterval, TimeUnit.MILLISECONDS);
         }
     }
 

File: handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java
Patch:
@@ -174,7 +174,6 @@ public void run() {
             if (trafficShapingHandler != null) {
                 trafficShapingHandler.doAccounting(TrafficCounter.this);
             }
-            scheduledFuture = executor.schedule(this, checkInterval.get(), TimeUnit.MILLISECONDS);
         }
     }
 
@@ -192,7 +191,7 @@ public synchronized void start() {
             monitorActive = true;
             monitor = new TrafficMonitoringTask();
             scheduledFuture =
-                executor.schedule(monitor, localCheckInterval, TimeUnit.MILLISECONDS);
+                executor.scheduleAtFixedRate(monitor, 0, localCheckInterval, TimeUnit.MILLISECONDS);
         }
     }
 
@@ -317,7 +316,8 @@ public void configure(long newCheckInterval) {
                 // No more active monitoring
                 lastTime.set(milliSecondFromNano());
             } else {
-                // Start if necessary
+                // Restart
+                stop();
                 start();
             }
         }

File: codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java
Patch:
@@ -66,6 +66,9 @@ private static Method updateByteBuffer(Checksum checksum) {
 
     static ByteBufChecksum wrapChecksum(Checksum checksum) {
         ObjectUtil.checkNotNull(checksum, "checksum");
+        if (checksum instanceof ByteBufChecksum) {
+            return (ByteBufChecksum) checksum;
+        }
         if (checksum instanceof Adler32 && ADLER32_UPDATE_METHOD != null) {
             return new ReflectiveByteBufChecksum(checksum, ADLER32_UPDATE_METHOD);
         }

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java
Patch:
@@ -31,7 +31,6 @@
 import net.jpountz.lz4.LZ4Compressor;
 import net.jpountz.lz4.LZ4Exception;
 import net.jpountz.lz4.LZ4Factory;
-import net.jpountz.xxhash.XXHashFactory;
 
 import java.nio.ByteBuffer;
 import java.util.concurrent.TimeUnit;
@@ -125,8 +124,7 @@ public Lz4FrameEncoder() {
      *                        and is slower but compresses more efficiently
      */
     public Lz4FrameEncoder(boolean highCompressor) {
-        this(LZ4Factory.fastestInstance(), highCompressor, DEFAULT_BLOCK_SIZE,
-                XXHashFactory.fastestInstance().newStreamingHash32(DEFAULT_SEED).asChecksum());
+        this(LZ4Factory.fastestInstance(), highCompressor, DEFAULT_BLOCK_SIZE, new Lz4XXHash32(DEFAULT_SEED));
     }
 
     /**

File: codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java
Patch:
@@ -100,7 +100,7 @@ public void update(ByteBuf b, int off, int len) {
                 update(b.array(), b.arrayOffset() + off, len);
             } else {
                 try {
-                    method.invoke(checksum, CompressionUtil.safeNioBuffer(b));
+                    method.invoke(checksum, CompressionUtil.safeNioBuffer(b, off, len));
                 } catch (Throwable cause) {
                     throw new Error();
                 }

File: codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java
Patch:
@@ -55,7 +55,7 @@ private static Method updateByteBuffer(Checksum checksum) {
         if (PlatformDependent.javaVersion() >= 8) {
             try {
                 Method method = checksum.getClass().getDeclaredMethod("update", ByteBuffer.class);
-                method.invoke(method, ByteBuffer.allocate(1));
+                method.invoke(checksum, ByteBuffer.allocate(1));
                 return method;
             } catch (Throwable ignore) {
                 return null;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -764,8 +764,6 @@ private InterfaceHttpData findMultipartDisposition() {
                         }
                     }
                 }
-            } else {
-                throw new ErrorDataDecoderException("Unknown Params: " + newline);
             }
         }
         // Is it a FileUpload

File: codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java
Patch:
@@ -63,7 +63,7 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
             @SuppressWarnings("rawtypes")
             AddressedEnvelope envelope = (AddressedEnvelope) msg;
             return encoder.acceptOutboundMessage(envelope.content())
-                    && envelope.sender() instanceof InetSocketAddress
+                    && (envelope.sender() instanceof InetSocketAddress || envelope.sender() == null)
                     && envelope.recipient() instanceof InetSocketAddress;
         }
         return false;

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1630,7 +1630,7 @@ public ByteBuffer nioBuffer(int index, int length) {
         ByteBuffer[] buffers = nioBuffers(index, length);
 
         if (buffers.length == 1) {
-            return buffers[0].duplicate();
+            return buffers[0];
         }
 
         ByteBuffer merged = ByteBuffer.allocate(length).order(order());

File: buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
Patch:
@@ -194,7 +194,7 @@ public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
 
     @Override
     public ByteBuf getBytes(int index, ByteBuffer dst) {
-        checkIndex(index, dst.remaining());
+        ensureAccessible();
         dst.put(array, index, dst.remaining());
         return this;
     }

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -260,6 +260,7 @@ public final class OpenSsl {
                                                 " is deprecated and so will be ignored in the future");
                                     }
                                 } else {
+                                    useKeyManagerFactory = true;
                                     if (propertySet) {
                                         logger.info("System property " +
                                                 "'io.netty.handler.ssl.openssl.useKeyManagerFactory'" +

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateEncoder.java
Patch:
@@ -114,7 +114,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg,
 
         ByteBuf compressedContent;
         if (removeFrameTail(msg)) {
-            int realLength = fullCompressedContent.readableBytes() - FRAME_TAIL.length;
+            int realLength = fullCompressedContent.readableBytes() - FRAME_TAIL.readableBytes();
             compressedContent = fullCompressedContent.slice(0, realLength);
         } else {
             compressedContent = fullCompressedContent;

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -81,7 +81,7 @@ public void testDecodeWholeRequestAtOnceMixedDelimiters() {
 
     private static void testDecodeWholeRequestAtOnce(byte[] content) {
         EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
-        assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(content)));
+        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(content)));
         HttpRequest req = channel.readInbound();
         assertNotNull(req);
         checkHeaders(req.headers());
@@ -146,13 +146,13 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
             }
 
             // if header is done it should produce a HttpRequest
-            channel.writeInbound(Unpooled.wrappedBuffer(content, a, amount));
+            channel.writeInbound(Unpooled.copiedBuffer(content, a, amount));
             a += amount;
         }
 
         for (int i = CONTENT_LENGTH; i > 0; i --) {
             // Should produce HttpContent
-            channel.writeInbound(Unpooled.wrappedBuffer(content, content.length - i, 1));
+            channel.writeInbound(Unpooled.copiedBuffer(content, content.length - i, 1));
         }
 
         HttpRequest req = channel.readInbound();

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateEncoderTest.java
Patch:
@@ -63,7 +63,7 @@ public void testCompressedFrame() {
         assertEquals(WebSocketExtension.RSV1 | WebSocketExtension.RSV3, compressedFrame.rsv());
 
         assertTrue(decoderChannel.writeInbound(compressedFrame.content()));
-        assertTrue(decoderChannel.writeInbound(Unpooled.wrappedBuffer(DeflateDecoder.FRAME_TAIL)));
+        assertTrue(decoderChannel.writeInbound(DeflateDecoder.FRAME_TAIL.duplicate()));
         ByteBuf uncompressedPayload = decoderChannel.readInbound();
         assertEquals(300, uncompressedPayload.readableBytes());
 
@@ -160,7 +160,7 @@ public void testFramementedFrame() {
         uncompressedPayload2.release();
 
         assertTrue(decoderChannel.writeInbound(compressedFrame3.content()));
-        assertTrue(decoderChannel.writeInbound(Unpooled.wrappedBuffer(DeflateDecoder.FRAME_TAIL)));
+        assertTrue(decoderChannel.writeInbound(DeflateDecoder.FRAME_TAIL.duplicate()));
         ByteBuf uncompressedPayload3 = decoderChannel.readInbound();
         byte[] finalPayload3 = new byte[100];
         uncompressedPayload3.readBytes(finalPayload3);

File: codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java
Patch:
@@ -245,7 +245,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         byte[] bytes = new byte[1024];
         PlatformDependent.threadLocalRandom().nextBytes(bytes);
 
-        assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(bytes)));
+        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(bytes)));
         assertBuffer(Unpooled.wrappedBuffer(bytes), (ByteBuf) channel.readInbound());
         assertNull(channel.readInbound());
         assertFalse(channel.finish());
@@ -277,7 +277,7 @@ protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
         byte[] bytes = new byte[1024];
         PlatformDependent.threadLocalRandom().nextBytes(bytes);
 
-        assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(bytes)));
+        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(bytes)));
         assertBuffer(Unpooled.wrappedBuffer(bytes, 0, bytes.length - 1), (ByteBuf) channel.readInbound());
         assertNull(channel.readInbound());
         assertTrue(channel.finish());

File: codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java
Patch:
@@ -223,7 +223,7 @@ private static void dispose(EmbeddedChannel ch) {
     // Test for https://github.com/netty/netty/issues/2572
     private void testDecompressOnly(ZlibWrapper decoderWrapper, byte[] compressed, byte[] data) throws Exception {
         EmbeddedChannel chDecoder = new EmbeddedChannel(createDecoder(decoderWrapper));
-        chDecoder.writeInbound(Unpooled.wrappedBuffer(compressed));
+        chDecoder.writeInbound(Unpooled.copiedBuffer(compressed));
         assertTrue(chDecoder.finish());
 
         ByteBuf decoded = Unpooled.buffer(data.length);
@@ -236,7 +236,7 @@ private void testDecompressOnly(ZlibWrapper decoderWrapper, byte[] compressed, b
             decoded.writeBytes(buf);
             buf.release();
         }
-        assertEquals(Unpooled.wrappedBuffer(data), decoded);
+        assertEquals(Unpooled.copiedBuffer(data), decoded);
         decoded.release();
     }
 

File: microbench/src/main/java/io/netty/microbench/http/HttpRequestDecoderBenchmark.java
Patch:
@@ -99,13 +99,13 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
             }
 
             // if header is done it should produce a HttpRequest
-            channel.writeInbound(Unpooled.wrappedBuffer(content, a, amount));
+            channel.writeInbound(Unpooled.wrappedBuffer(content, a, amount).asReadOnly());
             a += amount;
         }
 
         for (int i = CONTENT_LENGTH; i > 0; i --) {
             // Should produce HttpContent
-            channel.writeInbound(Unpooled.wrappedBuffer(content, content.length - i, 1));
+            channel.writeInbound(Unpooled.wrappedBuffer(content, content.length - i, 1).asReadOnly());
         }
     }
 }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java
Patch:
@@ -55,7 +55,9 @@ public final class DefaultDnsServerAddressStreamProvider implements DnsServerAdd
             DirContextUtils.addNameServers(defaultNameServers, DNS_PORT);
         }
 
-        if (defaultNameServers.isEmpty()) {
+        // Only try when using Java8 and lower as otherwise it will produce:
+        // WARNING: Illegal reflective access by io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider
+        if (PlatformDependent.javaVersion() < 9 && defaultNameServers.isEmpty()) {
             try {
                 Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");
                 Method open = configClass.getMethod("open");

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -47,8 +47,6 @@
  */
 public abstract class WebSocketServerHandshaker {
     protected static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketServerHandshaker.class);
-    private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(
-            new ClosedChannelException(), WebSocketServerHandshaker.class, "handshake(...)");
 
     private final String uri;
 
@@ -282,7 +280,9 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
             @Override
             public void channelInactive(ChannelHandlerContext ctx) throws Exception {
                 // Fail promise if Channel was closed
-                promise.tryFailure(CLOSED_CHANNEL_EXCEPTION);
+                if (!promise.isDone()) {
+                    promise.tryFailure(new ClosedChannelException());
+                }
                 ctx.fireChannelInactive();
             }
         });

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -34,9 +34,9 @@
 public class SpdySessionHandler extends ChannelDuplexHandler {
 
     private static final SpdyProtocolException PROTOCOL_EXCEPTION = ThrowableUtil.unknownStackTrace(
-            new SpdyProtocolException(), SpdySessionHandler.class, "handleOutboundMessage(...)");
+            SpdyProtocolException.newStatic(null), SpdySessionHandler.class, "handleOutboundMessage(...)");
     private static final SpdyProtocolException STREAM_CLOSED = ThrowableUtil.unknownStackTrace(
-            new SpdyProtocolException("Stream closed"), SpdySessionHandler.class, "removeStream(...)");
+            SpdyProtocolException.newStatic("Stream closed"), SpdySessionHandler.class, "removeStream(...)");
 
     private static final int DEFAULT_WINDOW_SIZE = 64 * 1024; // 64 KB default initial window size
     private int initialSendWindowSize    = DEFAULT_WINDOW_SIZE;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -117,8 +117,6 @@ public void operationComplete(ChannelFuture future) {
     };
 
     private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
-    private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(
-            new ClosedChannelException(), DefaultHttp2StreamChannel.Http2ChannelUnsafe.class, "write(...)");
     /**
      * Number of bytes to consider non-payload messages. 9 is arbitrary, but also the minimum size of an HTTP/2 frame.
      * Primarily is non-zero.
@@ -1091,7 +1089,7 @@ public void write(Object msg, final ChannelPromise promise) {
                         // Once the outbound side was closed we should not allow header / data frames
                         outboundClosed && (msg instanceof Http2HeadersFrame || msg instanceof Http2DataFrame)) {
                     ReferenceCountUtil.release(msg);
-                    promise.setFailure(CLOSED_CHANNEL_EXCEPTION);
+                    promise.setFailure(new ClosedChannelException());
                     return;
                 }
 

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -41,8 +41,6 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
             AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class, Object.class, "result");
     private static final Object SUCCESS = new Object();
     private static final Object UNCANCELLABLE = new Object();
-    private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(ThrowableUtil.unknownStackTrace(
-            new CancellationException(), DefaultPromise.class, "cancel(...)"));
 
     private volatile Object result;
     private final EventExecutor executor;
@@ -304,7 +302,8 @@ public V getNow() {
      */
     @Override
     public boolean cancel(boolean mayInterruptIfRunning) {
-        if (RESULT_UPDATER.compareAndSet(this, null, CANCELLATION_CAUSE_HOLDER)) {
+        if (RESULT_UPDATER.get(this) == null &&
+                RESULT_UPDATER.compareAndSet(this, null, new CauseHolder(new CancellationException()))) {
             if (checkNotifyWaiters()) {
                 notifyListeners();
             }

File: common/src/main/java/io/netty/util/internal/SuppressJava6Requirement.java
Patch:
@@ -25,7 +25,7 @@
  * Annotation to suppress the Java 6 source code requirement checks for a method.
  */
 @Retention(RetentionPolicy.CLASS)
-@Target({ ElementType.METHOD })
+@Target({ ElementType.METHOD, ElementType.CONSTRUCTOR })
 public @interface SuppressJava6Requirement {
 
     String reason();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -57,8 +57,6 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 abstract class AbstractEpollChannel extends AbstractChannel implements UnixChannel {
-    private static final ClosedChannelException DO_CLOSE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(
-            new ClosedChannelException(), AbstractEpollChannel.class, "doClose()");
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
     final LinuxSocket socket;
     /**
@@ -158,7 +156,7 @@ protected void doClose() throws Exception {
             ChannelPromise promise = connectPromise;
             if (promise != null) {
                 // Use tryFailure() instead of setFailure() to avoid the race against cancel().
-                promise.tryFailure(DO_CLOSE_CLOSED_CHANNEL_EXCEPTION);
+                promise.tryFailure(new ClosedChannelException());
                 connectPromise = null;
             }
 

File: transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
Patch:
@@ -135,7 +135,7 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels, Executor executor, Obj
         this.executor = executor;
 
         tooManyChannels = ThrowableUtil.unknownStackTrace(
-                new ChannelException("too many channels (max: " + maxChannels + ')'),
+                ChannelException.newStatic("too many channels (max: " + maxChannels + ')', null),
                 ThreadPerChannelEventLoopGroup.class, "nextChild()");
     }
 

File: transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java
Patch:
@@ -310,7 +310,7 @@ public void run() {
             pool.release(channel).syncUninterruptibly();
             fail();
         } catch (IllegalStateException e) {
-            assertSame(FixedChannelPool.POOL_CLOSED_ON_RELEASE_EXCEPTION, e);
+            // expected
         }
         // Since the pool is closed, the Channel should have been closed as well.
         channel.closeFuture().syncUninterruptibly();

File: example/src/main/java/io/netty/example/ocsp/OcspServerExample.java
Patch:
@@ -54,7 +54,7 @@
 
 /**
  * ATTENTION: This is an incomplete example! In order to provide a fully functional
- * end-to-end example we'd need a X.509 certificate and the matching PrivateKey.
+ * end-to-end example we'd need an X.509 certificate and the matching PrivateKey.
  */
 @SuppressWarnings("unused")
 public class OcspServerExample {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslX509KeyManagerFactory.java
Patch:
@@ -52,6 +52,8 @@
  * Special {@link KeyManagerFactory} that pre-compute the keymaterial used when {@link SslProvider#OPENSSL} or
  * {@link SslProvider#OPENSSL_REFCNT} is used and so will improve handshake times and its performance.
  *
+ *
+ *
  * Because the keymaterial is pre-computed any modification to the {@link KeyStore} is ignored after
  * {@link #init(KeyStore, char[])} is called.
  *

File: handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
Patch:
@@ -48,7 +48,7 @@
  * It is purely for testing purposes, and thus it is very insecure.
  * It even uses an insecure pseudo-random generator for faster generation internally.
  * </p><p>
- * A X.509 certificate file and a RSA private key file are generated in a system's temporary directory using
+ * An X.509 certificate file and a RSA private key file are generated in a system's temporary directory using
  * {@link java.io.File#createTempFile(String, String)}, and they are deleted when the JVM exits using
  * {@link java.io.File#deleteOnExit()}.
  * </p><p>

File: handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
Patch:
@@ -238,7 +238,7 @@ public String select(List<String> protocols) {
 
                 SslContext serverSslCtx = new JdkSslServerContext(providerType.provider(),
                     ssc.certificate(), ssc.privateKey(), null, null,
-                    IdentityCipherSuiteFilter.INSTANCE, serverApn, 0, 0);
+                    IdentityCipherSuiteFilter.INSTANCE, serverApn, 0, 0, null);
                 SslContext clientSslCtx = new JdkSslClientContext(providerType.provider(), null,
                     InsecureTrustManagerFactory.INSTANCE, null,
                     IdentityCipherSuiteFilter.INSTANCE, clientApn, 0, 0);

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -2903,7 +2903,7 @@ private void testSessionAfterHandshake0(boolean useKeyManagerFactory, boolean mu
         SelfSignedCertificate ssc = new SelfSignedCertificate();
         KeyManagerFactory kmf = useKeyManagerFactory ?
                 SslContext.buildKeyManagerFactory(
-                        new java.security.cert.X509Certificate[] { ssc.cert()}, ssc.key(), null, null) : null;
+                        new java.security.cert.X509Certificate[] { ssc.cert()}, ssc.key(), null, null, null) : null;
 
         SslContextBuilder clientContextBuilder = SslContextBuilder.forClient();
         if (mutualAuth) {
@@ -3249,7 +3249,7 @@ private KeyManagerFactory newKeyManagerFactory(SelfSignedCertificate ssc)
             throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException,
             CertificateException, IOException {
         return SslContext.buildKeyManagerFactory(
-                new java.security.cert.X509Certificate[] { ssc.cert() }, ssc.key(), null, null);
+                new java.security.cert.X509Certificate[] { ssc.cert() }, ssc.key(), null, null, null);
     }
 
     private final class TestTrustManagerFactory extends X509ExtendedTrustManager {

File: handler/src/test/java/io/netty/handler/ssl/SniClientJava8TestUtil.java
Patch:
@@ -260,7 +260,7 @@ static KeyManagerFactory newSniX509KeyManagerFactory(SelfSignedCertificate cert,
                    IOException, CertificateException {
         return new SniX509KeyManagerFactory(
                 new SNIHostName(hostname), SslContext.buildKeyManagerFactory(
-                new X509Certificate[] { cert.cert() }, cert.key(), null, null));
+                new X509Certificate[] { cert.cert() }, cert.key(), null, null, null));
     }
 
     private static final class SniX509KeyManagerFactory extends KeyManagerFactory {

File: handler/src/test/java/io/netty/handler/ssl/SniClientTest.java
Patch:
@@ -114,7 +114,7 @@ private static void testSniClient(SslProvider sslServerProvider, SslProvider ssl
                 KeyManagerFactory kmf = PlatformDependent.javaVersion() >= 8 ?
                         SniClientJava8TestUtil.newSniX509KeyManagerFactory(cert, sniHostName) :
                         SslContext.buildKeyManagerFactory(
-                                new X509Certificate[] { cert.cert() }, cert.key(), null, null);
+                                new X509Certificate[] { cert.cert() }, cert.key(), null, null, null);
 
                sslServerContext = SslContextBuilder.forServer(kmf)
                                                    .sslProvider(sslServerProvider)

File: handler/src/test/java/io/netty/handler/ssl/SslContextTrustManagerTest.java
Patch:
@@ -110,7 +110,7 @@ private static X509TrustManager getTrustManager(String[] resourceNames)
             throws Exception {
         X509Certificate[] certCollection = loadCertCollection(resourceNames);
         TrustManagerFactory tmf = SslContext.buildTrustManagerFactory(
-                certCollection, null);
+                certCollection, null, null);
 
         for (TrustManager tm : tmf.getTrustManagers()) {
             if (tm instanceof X509TrustManager) {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialProvider.java
Patch:
@@ -120,7 +120,7 @@ OpenSslKeyMaterial chooseKeyMaterial(ByteBufAllocator allocator, String alias) t
 
             OpenSslKeyMaterial keyMaterial;
             if (key instanceof OpenSslPrivateKey) {
-                keyMaterial = ((OpenSslPrivateKey) key).toKeyMaterial(chain, certificates);
+                keyMaterial = ((OpenSslPrivateKey) key).newKeyMaterial(chain, certificates);
             } else {
                 pkeyBio = toBIO(allocator, key);
                 pkey = key == null ? 0 : SSL.parsePrivateKey(pkeyBio, password);

File: handler/src/main/java/io/netty/handler/ssl/OpenSslPrivateKeyMethod.java
Patch:
@@ -45,7 +45,7 @@ public interface OpenSslPrivateKeyMethod {
      * @param engine                the {@link SSLEngine}
      * @param signatureAlgorithm    the algorithm to use for signing
      * @param input                 the digest itself
-     * @return                      the signed data
+     * @return                      the signed data (must not be {@code null})
      * @throws Exception            thrown if an error is encountered during the signing
      */
     byte[] sign(SSLEngine engine, int signatureAlgorithm, byte[] input) throws Exception;
@@ -55,7 +55,7 @@ public interface OpenSslPrivateKeyMethod {
      *
      * @param engine                the {@link SSLEngine}
      * @param input                 the input which should be decrypted
-     * @return                      the decrypted data
+     * @return                      the decrypted data (must not be {@code null})
      * @throws Exception            thrown if an error is encountered during the decrypting
      */
     byte[] decrypt(SSLEngine engine, byte[] input) throws Exception;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -165,8 +165,8 @@ public Handle newHandle() {
                         Http2ConnectionDecoder decoder,
                         Http2Settings initialSettings,
                         ChannelHandler inboundStreamHandler,
-                        ChannelHandler upgradeStreamHandler) {
-        super(encoder, decoder, initialSettings);
+                        ChannelHandler upgradeStreamHandler, boolean decoupleCloseAndGoAway) {
+        super(encoder, decoder, initialSettings, decoupleCloseAndGoAway);
         this.inboundStreamHandler = inboundStreamHandler;
         this.upgradeStreamHandler = upgradeStreamHandler;
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -727,7 +727,7 @@ public void gracefulShutdownTimeoutTest() throws Exception {
         final long expectedMillis = 1234;
         handler.gracefulShutdownTimeoutMillis(expectedMillis);
         handler.close(ctx, promise);
-        verify(executor).schedule(any(Runnable.class), eq(expectedMillis), eq(TimeUnit.MILLISECONDS));
+        verify(executor, atLeastOnce()).schedule(any(Runnable.class), eq(expectedMillis), eq(TimeUnit.MILLISECONDS));
     }
 
     @Test

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -291,7 +291,7 @@ public ChannelFuture writeSettingsAck(ChannelHandlerContext ctx, ChannelPromise
         // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our
         // remote peer applies these settings before any subsequent frames that we may send which depend upon
         // these new settings. See https://github.com/netty/netty/issues/6520.
-        frameWriter.writeSettingsAck(ctx, aggregator);
+        frameWriter.writeSettingsAck(ctx, aggregator.newPromise());
 
         // We create a "new promise" to make sure that status from both the write and the application are taken into
         // account independently.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodecBuilder.java
Patch:
@@ -162,7 +162,8 @@ public Http2FrameCodec build() {
             if (encoderEnforceMaxConcurrentStreams()) {
                 encoder = new StreamBufferingEncoder(encoder);
             }
-            Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, frameReader);
+            Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, frameReader,
+                    promisedRequestVerifier(), isAutoAckSettingsFrame());
 
             return build(decoder, encoder, initialSettings());
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -1119,7 +1119,7 @@ public void operationComplete(ChannelFuture future) {
                             }
                             return;
                         }
-                    } else  {
+                    } else {
                         String msgStr = msg.toString();
                         ReferenceCountUtil.release(msg);
                         promise.setFailure(new IllegalArgumentException(

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java
Patch:
@@ -59,7 +59,6 @@
 import static io.netty.handler.codec.http2.Http2TestUtil.anyHttp2Settings;
 import static io.netty.handler.codec.http2.Http2TestUtil.assertEqualsAndRelease;
 import static io.netty.handler.codec.http2.Http2TestUtil.bb;
-
 import static org.hamcrest.Matchers.instanceOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -152,6 +151,8 @@ private void setUp(Http2FrameCodecBuilder frameCodecBuilder, Http2Settings initi
 
         Http2SettingsFrame settingsFrame = inboundHandler.readInbound();
         assertNotNull(settingsFrame);
+        Http2SettingsAckFrame settingsAckFrame = inboundHandler.readInbound();
+        assertNotNull(settingsAckFrame);
     }
 
     @Test

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
Patch:
@@ -46,12 +46,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static io.netty.util.ReferenceCountUtil.release;
 import static io.netty.handler.codec.http2.Http2TestUtil.anyChannelPromise;
 import static io.netty.handler.codec.http2.Http2TestUtil.anyHttp2Settings;
 import static io.netty.handler.codec.http2.Http2TestUtil.assertEqualsAndRelease;
 import static io.netty.handler.codec.http2.Http2TestUtil.bb;
-
+import static io.netty.util.ReferenceCountUtil.release;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -107,6 +106,8 @@ public void setUp() {
 
         Http2SettingsFrame settingsFrame = parentChannel.readInbound();
         assertNotNull(settingsFrame);
+        Http2SettingsAckFrame settingsAckFrame = parentChannel.readInbound();
+        assertNotNull(settingsAckFrame);
 
         // Handshake
         verify(frameWriter).writeSettings(eqMultiplexCodecCtx(),

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDomainSocketChannelConfig.java
Patch:
@@ -26,8 +26,8 @@
 
 import java.util.Map;
 
-import static io.netty.channel.ChannelOption.*;
-import static io.netty.channel.unix.UnixChannelOption.*;
+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;
+import static io.netty.channel.unix.UnixChannelOption.DOMAIN_SOCKET_READ_MODE;
 
 public final class EpollDomainSocketChannelConfig extends EpollChannelConfig
         implements DomainSocketChannelConfig {

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1764,7 +1764,7 @@ public CompositeByteBuf discardReadComponents() {
             return this; // Nothing to discard
         }
         Component la = lastAccessed;
-        if (la != null && la.endOffset < readerIndex) {
+        if (la != null && la.endOffset <= readerIndex) {
             lastAccessed = null;
         }
         removeCompRange(0, firstComponentId);
@@ -1820,7 +1820,7 @@ public CompositeByteBuf discardReadBytes() {
             c.slice = slice.slice(trimmedBytes, c.length());
         }
         Component la = lastAccessed;
-        if (la != null && la.endOffset < readerIndex) {
+        if (la != null && la.endOffset <= readerIndex) {
             lastAccessed = null;
         }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java
Patch:
@@ -71,11 +71,13 @@ public X509TrustManager wrapIfNeeded(X509TrustManager manager) {
                             @Override
                             public void checkClientTrusted(X509Certificate[] x509Certificates, String s)
                                     throws CertificateException {
+                                throw new CertificateException();
                             }
 
                             @Override
                             public void checkServerTrusted(X509Certificate[] x509Certificates, String s)
                                     throws CertificateException {
+                                throw new CertificateException();
                             }
 
                             @Override

File: transport/src/main/java/io/netty/channel/MessageSizeEstimator.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.channel;
 
 /**
- * Responsible to estimate size of a message. The size represent how much memory the message will ca. reserve in
- * memory.
+ * Responsible to estimate the size of a message. The size represents approximately how much memory the message will
+ * reserve in memory.
  */
 public interface MessageSizeEstimator {
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -106,7 +106,9 @@ public ServerSocketChannelConfig config() {
 
     @Override
     public boolean isActive() {
-        return javaChannel().socket().isBound();
+        // As java.nio.ServerSocketChannel.isBound() will continue to return true even after the channel was closed
+        // we will also need to check if it is open.
+        return isOpen() && javaChannel().socket().isBound();
     }
 
     @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
Patch:
@@ -217,7 +217,7 @@ private void testHttpResponseAndFrameInSameBuffer(boolean codec) {
         String url = "ws://localhost:9999/ws";
         final WebSocketClientHandshaker shaker = newHandshaker(URI.create(url));
         final WebSocketClientHandshaker handshaker = new WebSocketClientHandshaker(
-                shaker.uri(), shaker.version(), null, EmptyHttpHeaders.INSTANCE, Integer.MAX_VALUE) {
+                shaker.uri(), shaker.version(), null, EmptyHttpHeaders.INSTANCE, Integer.MAX_VALUE, -1) {
             @Override
             protected FullHttpRequest newHandshakeRequest() {
                 return shaker.newHandshakeRequest();

File: transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.netty.channel;
 
+import io.netty.channel.ChannelHandlerMask.Skip;
 import io.netty.util.internal.InternalThreadLocalMap;
 
 import java.util.Map;
@@ -84,6 +85,7 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
      *
      * @deprecated is part of {@link ChannelInboundHandler}
      */
+    @Skip
     @Override
     @Deprecated
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1243,7 +1243,7 @@ protected void decrementPendingOutboundBytes(long size) {
     final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
 
         TailContext(DefaultChannelPipeline pipeline) {
-            super(pipeline, null, TAIL_NAME, true, false);
+            super(pipeline, null, TAIL_NAME, TailContext.class);
             setAddComplete();
         }
 
@@ -1306,7 +1306,7 @@ final class HeadContext extends AbstractChannelHandlerContext
         private final Unsafe unsafe;
 
         HeadContext(DefaultChannelPipeline pipeline) {
-            super(pipeline, null, HEAD_NAME, true, true);
+            super(pipeline, null, HEAD_NAME, HeadContext.class);
             unsafe = pipeline.channel().unsafe();
             setAddComplete();
         }

File: codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
Patch:
@@ -399,7 +399,6 @@ protected void finishAggregation(O aggregated) throws Exception { }
 
     private void invokeHandleOversizedMessage(ChannelHandlerContext ctx, S oversized) throws Exception {
         handlingOversizedMessage = true;
-        aggregating = false;
         currentMessage = null;
         try {
             handleOversizedMessage(ctx, oversized);

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -189,6 +189,7 @@ public OpenSslClientContext(File trustCertCollectionFile, TrustManagerFactory tr
                 ClientAuth.NONE, protocols, false, enableOcsp);
         boolean success = false;
         try {
+            OpenSslKeyMaterialProvider.validateKeyMaterialSupported(keyCertChain, key, keyPassword);
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,
                                                keyCertChain, key, keyPassword, keyManagerFactory);
             success = true;

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
Patch:
@@ -344,9 +344,11 @@ private OpenSslServerContext(
             boolean enableOcsp) throws SSLException {
         super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_SERVER, keyCertChain,
                 clientAuth, protocols, startTls, enableOcsp);
+
         // Create a new SSL_CTX and configure it.
         boolean success = false;
         try {
+            OpenSslKeyMaterialProvider.validateKeyMaterialSupported(keyCertChain, key, keyPassword);
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,
                                                keyCertChain, key, keyPassword, keyManagerFactory);
             success = true;

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -65,7 +65,10 @@ public static boolean exists(String name) {
     /**
      * Creates a new {@link ChannelOption} for the given {@code name} or fail with an
      * {@link IllegalArgumentException} if a {@link ChannelOption} for the given {@code name} exists.
+     *
+     * @deprecated use {@link #valueOf(String)}.
      */
+    @Deprecated
     @SuppressWarnings("unchecked")
     public static <T> ChannelOption<T> newInstance(String name) {
         return (ChannelOption<T>) pool.newInstance(name);

File: transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.util.concurrent.DefaultThreadFactory;
 import io.netty.util.concurrent.Future;
 import org.hamcrest.core.IsInstanceOf;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -258,6 +259,7 @@ public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throw
         }
     }
 
+    @Ignore
     @Test
     public void testChannelsRegistered()  {
         NioEventLoopGroup group = new NioEventLoopGroup(1);

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -191,7 +191,8 @@ public interface ChannelHandler {
     /**
      * Gets called if a {@link Throwable} was thrown.
      *
-     * @deprecated is part of {@link ChannelInboundHandler}
+     * @deprecated if you want to handle this event you should implement {@link ChannelInboundHandler} and
+     * implement the method there.
      */
     @Deprecated
     void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;

File: transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
Patch:
@@ -126,6 +126,7 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio
      * Sub-classes may override this method to change behavior.
      */
     @Override
+    @SuppressWarnings("deprecation")
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
             throws Exception {
         ctx.fireExceptionCaught(cause);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -593,7 +593,7 @@ private ChannelFuture writeContinuationFrames(ChannelHandlerContext ctx, int str
                 if (paddingBytes(padding) > 0) {
                     ctx.write(ZERO_BUFFER.slice(0, paddingBytes(padding)), promiseAggregator.newPromise());
                 }
-            } while(headerBlock.isReadable());
+            } while (headerBlock.isReadable());
         }
         return promiseAggregator;
     }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -141,23 +141,23 @@ public static void epollCtlAdd(int efd, final int fd, final int flags) throws IO
             throw newIOException("epoll_ctl", res);
         }
     }
-    private static native int epollCtlAdd0(int efd, final int fd, final int flags);
+    private static native int epollCtlAdd0(int efd, int fd, int flags);
 
     public static void epollCtlMod(int efd, final int fd, final int flags) throws IOException {
         int res = epollCtlMod0(efd, fd, flags);
         if (res < 0) {
             throw newIOException("epoll_ctl", res);
         }
     }
-    private static native int epollCtlMod0(int efd, final int fd, final int flags);
+    private static native int epollCtlMod0(int efd, int fd, int flags);
 
     public static void epollCtlDel(int efd, final int fd) throws IOException {
         int res = epollCtlDel0(efd, fd);
         if (res < 0) {
             throw newIOException("epoll_ctl", res);
         }
     }
-    private static native int epollCtlDel0(int efd, final int fd);
+    private static native int epollCtlDel0(int efd, int fd);
 
     // File-descriptor operations
     public static int splice(int fd, long offIn, int fdOut, long offOut, long len) throws IOException {

File: handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java
Patch:
@@ -289,7 +289,7 @@ private void verifyException(Throwable cause, String messagePart, Promise<Void>
                 // When the error is produced on the client side and the client side uses JDK as provider it will always
                 // use "certificate unknown".
                 !serverProduceError && clientProvider == SslProvider.JDK &&
-                        message.toLowerCase(Locale.UK).contains("certificate unknown")) {
+                        message.toLowerCase(Locale.UK).contains("unknown")) {
             promise.setSuccess(null);
         } else {
             Throwable error = new AssertionError("message not contains '" + messagePart + "': " + message);

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -474,7 +474,7 @@ protected synchronized PoolThreadCache initialValue() {
 
         @Override
         protected void onRemoval(PoolThreadCache threadCache) {
-            threadCache.free();
+            threadCache.free(false);
         }
 
         private <T> PoolArena<T> leastUsedArena(PoolArena<T>[] arenas) {

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.ThreadExecutorMap;
 import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -161,7 +162,7 @@ protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor
         super(parent);
         this.addTaskWakesUp = addTaskWakesUp;
         this.maxPendingTasks = Math.max(16, maxPendingTasks);
-        this.executor = ObjectUtil.checkNotNull(executor, "executor");
+        this.executor = ThreadExecutorMap.apply(executor, this);
         taskQueue = newTaskQueue(this.maxPendingTasks);
         rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
     }

File: transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
-import io.netty.util.DefaultAttributeMap;
 import io.netty.util.Recycler;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ResourceLeakHint;
@@ -35,8 +34,7 @@
 import java.net.SocketAddress;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
-abstract class AbstractChannelHandlerContext extends DefaultAttributeMap
-        implements ChannelHandlerContext, ResourceLeakHint {
+abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannelHandlerContext.class);
     volatile AbstractChannelHandlerContext next;

File: common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
Patch:
@@ -138,7 +138,7 @@ public static void load(String originalName, ClassLoader loader) {
         } catch (Throwable ex) {
             suppressed.add(ex);
             logger.debug(
-                    "{} cannot be loaded from java.libary.path, "
+                    "{} cannot be loaded from java.library.path, "
                     + "now trying export to -Dio.netty.native.workdir: {}", name, WORKDIR, ex);
         }
 

File: handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java
Patch:
@@ -172,7 +172,7 @@ protected Object newInitialMessage(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    protected boolean handleResponse(ChannelHandlerContext ctx, Object response) throws HttpProxyConnectException {
+    protected boolean handleResponse(ChannelHandlerContext ctx, Object response) throws Exception {
         if (response instanceof HttpResponse) {
             if (status != null) {
                 throw new HttpProxyConnectException(exceptionMessage("too many responses"), /*headers=*/ null);

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -1687,7 +1687,6 @@ private SSLEngineResult.HandshakeStatus handshake() throws SSLException {
         }
         // if SSL_do_handshake returns > 0 or sslError == SSL.SSL_ERROR_NAME it means the handshake was finished.
         session.handshakeFinished();
-        engineMap.remove(ssl);
         return FINISHED;
     }
 

File: buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java
Patch:
@@ -424,8 +424,8 @@ public final int refCnt() {
     }
 
     @Override
-    int internalRefCnt() {
-        return wrapped.internalRefCnt();
+    final boolean isAccessible() {
+        return wrapped.isAccessible();
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
Patch:
@@ -108,7 +108,7 @@ public ChannelFuture writeData(final ChannelHandlerContext ctx, final int stream
                 return promise;
             }
 
-            PromiseCombiner combiner = new PromiseCombiner();
+            PromiseCombiner combiner = new PromiseCombiner(ctx.executor());
             for (;;) {
                 ByteBuf nextBuf = nextReadableBuf(channel);
                 boolean compressedEndOfStream = nextBuf == null && endOfStream;

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
Patch:
@@ -132,7 +132,7 @@ private static void writeVoidPromise(ChannelHandlerContext ctx, CodecOutputList
     }
 
     private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) {
-        final PromiseCombiner combiner = new PromiseCombiner();
+        final PromiseCombiner combiner = new PromiseCombiner(ctx.executor());
         for (int i = 0; i < out.size(); i++) {
             combiner.add(ctx.write(out.getUnsafe(i)));
         }

File: common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 
 /**
- * @deprecated Use {@link PromiseCombiner}
+ * @deprecated Use {@link PromiseCombiner#PromiseCombiner(EventExecutor)}.
  *
  * {@link GenericFutureListener} implementation which consolidates multiple {@link Future}s
  * into one, by listening to individual {@link Future}s and producing an aggregated result

File: transport/src/main/java/io/netty/channel/PendingWriteQueue.java
Patch:
@@ -130,7 +130,7 @@ public ChannelFuture removeAndWriteAll() {
         }
 
         ChannelPromise p = ctx.newPromise();
-        PromiseCombiner combiner = new PromiseCombiner();
+        PromiseCombiner combiner = new PromiseCombiner(ctx.executor());
         try {
             // It is possible for some of the written promises to trigger more writes. The new writes
             // will "revive" the queue, so we need to write them up until the queue is empty.

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -1151,7 +1151,7 @@ private static void writeAndVerifyReceived(ByteBuf message, Channel sendChannel,
                                                MessageReceiver receiver) throws Exception {
         List<ByteBuf> dataCapture = null;
         try {
-            assertTrue(sendChannel.writeAndFlush(message).await(50, TimeUnit.SECONDS));
+            assertTrue(sendChannel.writeAndFlush(message).await(5, TimeUnit.SECONDS));
             receiverLatch.await(5, TimeUnit.SECONDS);
             message.resetReaderIndex();
             ArgumentCaptor<ByteBuf> captor = ArgumentCaptor.forClass(ByteBuf.class);

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java
Patch:
@@ -105,10 +105,10 @@ public String encode(Cookie cookie) {
             add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge());
             Date expires = new Date(cookie.maxAge() * 1000 + System.currentTimeMillis());
             buf.append(CookieHeaderNames.EXPIRES);
-            buf.append((char) HttpConstants.EQUALS);
+            buf.append('=');
             DateFormatter.append(expires, buf);
-            buf.append((char) HttpConstants.SEMICOLON);
-            buf.append((char) HttpConstants.SP);
+            buf.append(';');
+            buf.append(HttpConstants.SP_CHAR);
         }
 
         if (cookie.path() != null) {

File: handler/src/test/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngineTest.java
Patch:
@@ -23,8 +23,8 @@
 
 public class ReferenceCountedOpenSslEngineTest extends OpenSslEngineTest {
 
-    public ReferenceCountedOpenSslEngineTest(BufferType type, ProtocolCipherCombo combo) {
-        super(type, combo);
+    public ReferenceCountedOpenSslEngineTest(BufferType type, ProtocolCipherCombo combo, boolean delegate) {
+        super(type, combo, delegate);
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketSslClientRenegotiateTest.java
Patch:
@@ -26,8 +26,8 @@
 
 public class EpollDomainSocketSslClientRenegotiateTest extends SocketSslClientRenegotiateTest {
 
-    public EpollDomainSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public EpollDomainSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketSslGreetingTest.java
Patch:
@@ -26,8 +26,8 @@
 
 public class EpollDomainSocketSslGreetingTest extends SocketSslGreetingTest {
 
-    public EpollDomainSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public EpollDomainSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslClientRenegotiateTest.java
Patch:
@@ -25,8 +25,8 @@
 
 public class EpollSocketSslClientRenegotiateTest extends SocketSslClientRenegotiateTest {
 
-    public EpollSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public EpollSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslGreetingTest.java
Patch:
@@ -25,8 +25,8 @@
 
 public class EpollSocketSslGreetingTest extends SocketSslGreetingTest {
 
-    public EpollSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public EpollSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDomainSocketSslClientRenegotiateTest.java
Patch:
@@ -26,8 +26,8 @@
 
 public class KQueueDomainSocketSslClientRenegotiateTest extends SocketSslClientRenegotiateTest {
 
-    public KQueueDomainSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public KQueueDomainSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDomainSocketSslGreetingTest.java
Patch:
@@ -26,8 +26,8 @@
 
 public class KQueueDomainSocketSslGreetingTest extends SocketSslGreetingTest {
 
-    public KQueueDomainSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public KQueueDomainSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketSslClientRenegotiateTest.java
Patch:
@@ -25,8 +25,8 @@
 
 public class KQueueSocketSslClientRenegotiateTest extends SocketSslClientRenegotiateTest {
 
-    public KQueueSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public KQueueSocketSslClientRenegotiateTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketSslGreetingTest.java
Patch:
@@ -25,8 +25,8 @@
 
 public class KQueueSocketSslGreetingTest extends SocketSslGreetingTest {
 
-    public KQueueSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx) {
-        super(serverCtx, clientCtx);
+    public KQueueSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx, boolean delegate) {
+        super(serverCtx, clientCtx, delegate);
     }
 
     @Override

File: buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
Patch:
@@ -461,7 +461,7 @@ private static final class AllocationThread extends Thread {
         private final ByteBufAllocator allocator;
         private final AtomicReference<Object> finish = new AtomicReference<Object>();
 
-        public AllocationThread(ByteBufAllocator allocator) {
+        AllocationThread(ByteBufAllocator allocator) {
             this.allocator = allocator;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java
Patch:
@@ -79,7 +79,7 @@ public CharSequence escape(CharSequence value) {
             return charSequenceEscaper;
         }
 
-        public CombinedHttpHeadersImpl(HashingStrategy<CharSequence> nameHashingStrategy,
+        CombinedHttpHeadersImpl(HashingStrategy<CharSequence> nameHashingStrategy,
                 ValueConverter<CharSequence> valueConverter,
                 io.netty.handler.codec.DefaultHeaders.NameValidator<CharSequence> nameValidator) {
             super(nameHashingStrategy, valueConverter, nameValidator);

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
Patch:
@@ -59,7 +59,9 @@ protected AbstractHttpData(String name, Charset charset, long size) {
     }
 
     @Override
-    public long getMaxSize() { return maxSize; }
+    public long getMaxSize() {
+        return maxSize;
+    }
 
     @Override
     public void setMaxSize(long maxSize) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
Patch:
@@ -45,7 +45,9 @@ public class WebSocketClientProtocolHandler extends WebSocketProtocolHandler {
     /**
      * Returns the used handshaker
      */
-    public WebSocketClientHandshaker handshaker() { return handshaker; }
+    public WebSocketClientHandshaker handshaker() {
+        return handshaker;
+    }
 
     /**
      * Events that are fired to notify about handshake status

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java
Patch:
@@ -47,7 +47,7 @@ abstract class DeflateDecoder extends WebSocketExtensionDecoder {
      * Constructor
      * @param noContext true to disable context takeover.
      */
-    public DeflateDecoder(boolean noContext) {
+    DeflateDecoder(boolean noContext) {
         this.noContext = noContext;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateEncoder.java
Patch:
@@ -49,7 +49,7 @@ abstract class DeflateEncoder extends WebSocketExtensionEncoder {
      * @param windowSize maximum size of the window compressor buffer.
      * @param noContext true to disable context takeover.
      */
-    public DeflateEncoder(int compressionLevel, int windowSize, boolean noContext) {
+    DeflateEncoder(int compressionLevel, int windowSize, boolean noContext) {
         this.compressionLevel = compressionLevel;
         this.windowSize = windowSize;
         this.noContext = noContext;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateFrameClientExtensionHandshaker.java
Patch:
@@ -81,7 +81,7 @@ private static class DeflateFrameClientExtension implements WebSocketClientExten
 
         private final int compressionLevel;
 
-        public DeflateFrameClientExtension(int compressionLevel) {
+        DeflateFrameClientExtension(int compressionLevel) {
             this.compressionLevel = compressionLevel;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateFrameServerExtensionHandshaker.java
Patch:
@@ -74,7 +74,7 @@ private static class DeflateFrameServerExtension implements WebSocketServerExten
         private final String extensionName;
         private final int compressionLevel;
 
-        public DeflateFrameServerExtension(int compressionLevel, String extensionName) {
+        DeflateFrameServerExtension(int compressionLevel, String extensionName) {
             this.extensionName = extensionName;
             this.compressionLevel = compressionLevel;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerFrameDeflateDecoder.java
Patch:
@@ -30,7 +30,7 @@ class PerFrameDeflateDecoder extends DeflateDecoder {
      * Constructor
      * @param noContext true to disable context takeover.
      */
-    public PerFrameDeflateDecoder(boolean noContext) {
+    PerFrameDeflateDecoder(boolean noContext) {
         super(noContext);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerFrameDeflateEncoder.java
Patch:
@@ -32,7 +32,7 @@ class PerFrameDeflateEncoder extends DeflateEncoder {
      * @param windowSize maximum size of the window compressor buffer.
      * @param noContext true to disable context takeover.
      */
-    public PerFrameDeflateEncoder(int compressionLevel, int windowSize, boolean noContext) {
+    PerFrameDeflateEncoder(int compressionLevel, int windowSize, boolean noContext) {
         super(compressionLevel, windowSize, noContext);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java
Patch:
@@ -176,7 +176,7 @@ public int rsv() {
             return RSV1;
         }
 
-        public PermessageDeflateExtension(boolean serverNoContext, int serverWindowSize,
+        PermessageDeflateExtension(boolean serverNoContext, int serverWindowSize,
                 boolean clientNoContext, int clientWindowSize) {
             this.serverNoContext = serverNoContext;
             this.serverWindowSize = serverWindowSize;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateDecoder.java
Patch:
@@ -35,7 +35,7 @@ class PerMessageDeflateDecoder extends DeflateDecoder {
      * Constructor
      * @param noContext true to disable context takeover.
      */
-    public PerMessageDeflateDecoder(boolean noContext) {
+    PerMessageDeflateDecoder(boolean noContext) {
         super(noContext);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateEncoder.java
Patch:
@@ -37,7 +37,7 @@ class PerMessageDeflateEncoder extends DeflateEncoder {
      * @param windowSize maximum size of the window compressor buffer.
      * @param noContext true to disable context takeover.
      */
-    public PerMessageDeflateEncoder(int compressionLevel, int windowSize, boolean noContext) {
+    PerMessageDeflateEncoder(int compressionLevel, int windowSize, boolean noContext) {
         super(compressionLevel, windowSize, noContext);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java
Patch:
@@ -151,7 +151,7 @@ private static class PermessageDeflateExtension implements WebSocketServerExtens
         private final boolean clientNoContext;
         private final int clientWindowSize;
 
-        public PermessageDeflateExtension(int compressionLevel, boolean serverNoContext,
+        PermessageDeflateExtension(int compressionLevel, boolean serverNoContext,
                 int serverWindowSize, boolean clientNoContext, int clientWindowSize) {
             this.compressionLevel = compressionLevel;
             this.serverNoContext = serverNoContext;

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java
Patch:
@@ -69,7 +69,7 @@ static final class WebSocketExtensionDataMatcher implements ArgumentMatcher<WebS
 
         private final String name;
 
-        public WebSocketExtensionDataMatcher(String name) {
+        WebSocketExtensionDataMatcher(String name) {
             this.name = name;
         }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -930,7 +930,7 @@ private final class ActiveStreams {
         private final Set<Http2Stream> streams = new LinkedHashSet<Http2Stream>();
         private int pendingIterations;
 
-        public ActiveStreams(List<Listener> listeners) {
+        ActiveStreams(List<Listener> listeners) {
             this.listeners = listeners;
         }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -296,7 +296,7 @@ private static boolean isClosed(Http2Stream stream) {
      * received.
      */
     private final class AutoRefillState extends DefaultState {
-        public AutoRefillState(Http2Stream stream, int initialWindowSize) {
+        AutoRefillState(Http2Stream stream, int initialWindowSize) {
             super(stream, initialWindowSize);
         }
 
@@ -349,7 +349,7 @@ private class DefaultState implements FlowState {
         private int lowerBound;
         private boolean endOfStream;
 
-        public DefaultState(Http2Stream stream, int initialWindowSize) {
+        DefaultState(Http2Stream stream, int initialWindowSize) {
             this.stream = stream;
             window(initialWindowSize);
             streamWindowUpdateRatio = windowUpdateRatio;
@@ -613,7 +613,7 @@ private final class WindowUpdateVisitor implements Http2StreamVisitor {
         private CompositeStreamException compositeException;
         private final int delta;
 
-        public WindowUpdateVisitor(int delta) {
+        WindowUpdateVisitor(int delta) {
             this.delta = delta;
         }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -528,7 +528,7 @@ private static final class Http2HeadersSink implements Sink {
         private HeaderType previousType;
         private Http2Exception validationException;
 
-        public Http2HeadersSink(int streamId, Http2Headers headers, long maxHeaderListSize, boolean validate) {
+        Http2HeadersSink(int streamId, Http2Headers headers, long maxHeaderListSize, boolean validate) {
             this.headers = headers;
             this.maxHeaderListSize = maxHeaderListSize;
             this.streamId = streamId;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
Patch:
@@ -75,14 +75,14 @@ final class HpackEncoder {
     /**
      * Creates a new encoder.
      */
-    public HpackEncoder(boolean ignoreMaxHeaderListSize) {
+    HpackEncoder(boolean ignoreMaxHeaderListSize) {
         this(ignoreMaxHeaderListSize, 16);
     }
 
     /**
      * Creates a new encoder.
      */
-    public HpackEncoder(boolean ignoreMaxHeaderListSize, int arraySizeHint) {
+    HpackEncoder(boolean ignoreMaxHeaderListSize, int arraySizeHint) {
         this.ignoreMaxHeaderListSize = ignoreMaxHeaderListSize;
         maxHeaderTableSize = DEFAULT_HEADER_TABLE_SIZE;
         maxHeaderListSize = MAX_HEADER_LIST_SIZE;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -233,7 +233,7 @@ private final class PrefaceDecoder extends BaseDecoder {
         private ByteBuf clientPrefaceString;
         private boolean prefaceSent;
 
-        public PrefaceDecoder(ChannelHandlerContext ctx) throws Exception {
+        PrefaceDecoder(ChannelHandlerContext ctx) throws Exception {
             clientPrefaceString = clientPrefaceString(encoder.connection());
             // This handler was just added to the context. In case it was handled after
             // the connection became active, send the connection preface now.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java
Patch:
@@ -194,7 +194,7 @@ public static int streamId(Http2Exception e) {
     /**
      * Provides a hint as to if shutdown is justified, what type of shutdown should be executed.
      */
-    public static enum ShutdownHint {
+    public enum ShutdownHint {
         /**
          * Do not shutdown the underlying channel.
          */

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java
Patch:
@@ -624,7 +624,7 @@ private static final class ListenerExceptionThrower implements Answer<Void> {
         private final boolean[] array;
         private final int index;
 
-        public ListenerExceptionThrower(boolean[] array, int index) {
+        ListenerExceptionThrower(boolean[] array, int index) {
             this.array = array;
             this.index = index;
         }
@@ -640,7 +640,7 @@ private static final class ListenerVerifyCallAnswer implements Answer<Void> {
         private final boolean[] array;
         private final int index;
 
-        public ListenerVerifyCallAnswer(boolean[] array, int index) {
+        ListenerVerifyCallAnswer(boolean[] array, int index) {
             this.array = array;
             this.index = index;
         }

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2DivSufSort.java
Patch:
@@ -568,7 +568,9 @@ private void ssMergeForward(final int pa, int[] buf, final int bufoffset,
                     SA[i++] = SA[k];
                     SA[k++] = SA[i];
                     if (last <= k) {
-                        while (j < bufend) { SA[i++] = buf[j]; buf[j++] = SA[i]; }
+                        while (j < bufend) {
+                            SA[i++] = buf[j]; buf[j++] = SA[i];
+                        }
                         SA[i] = buf[j]; buf[j] = t;
                         return;
                     }

File: codec/src/test/java/io/netty/handler/codec/DefaultHeadersTest.java
Patch:
@@ -41,11 +41,11 @@ public class DefaultHeadersTest {
 
     private static final class TestDefaultHeaders extends
             DefaultHeaders<CharSequence, CharSequence, TestDefaultHeaders> {
-        public TestDefaultHeaders() {
+        TestDefaultHeaders() {
             this(CharSequenceValueConverter.INSTANCE);
         }
 
-        public TestDefaultHeaders(ValueConverter<CharSequence> converter) {
+        TestDefaultHeaders(ValueConverter<CharSequence> converter) {
             super(converter);
         }
     }

File: common/src/main/java/io/netty/util/CharsetUtil.java
Patch:
@@ -65,7 +65,9 @@ public final class CharsetUtil {
     private static final Charset[] CHARSETS = new Charset[]
             { UTF_16, UTF_16BE, UTF_16LE, UTF_8, ISO_8859_1, US_ASCII };
 
-    public static Charset[] values() { return CHARSETS; }
+    public static Charset[] values() {
+        return CHARSETS;
+    }
 
     /**
      * @deprecated Use {@link #encoder(Charset)}.

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -498,8 +498,9 @@ public boolean close(T trackedObject) {
          */
         private static void reachabilityFence0(Object ref) {
             if (ref != null) {
-                // Empty synchronized is ok: https://stackoverflow.com/a/31933260/1151521
-                synchronized (ref) { }
+                synchronized (ref) {
+                    // Empty synchronized is ok: https://stackoverflow.com/a/31933260/1151521
+                }
             }
         }
 

File: example/src/main/java/io/netty/example/ocsp/OcspClientExample.java
Patch:
@@ -157,7 +157,7 @@ private static class HttpClientHandler extends ChannelInboundHandlerAdapter {
 
         private final Promise<FullHttpResponse> promise;
 
-        public HttpClientHandler(String host, Promise<FullHttpResponse> promise) {
+        HttpClientHandler(String host, Promise<FullHttpResponse> promise) {
             this.host = host;
             this.promise = promise;
         }
@@ -203,7 +203,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 
     private static class ExampleOcspClientHandler extends OcspClientHandler {
 
-        public ExampleOcspClientHandler(ReferenceCountedOpenSslEngine engine) {
+        ExampleOcspClientHandler(ReferenceCountedOpenSslEngine engine) {
             super(engine);
         }
 

File: handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java
Patch:
@@ -431,7 +431,9 @@ public static void stopServers() {
 
     private final TestItem testItem;
 
-    public ProxyHandlerTest(TestItem testItem) { this.testItem = testItem; }
+    public ProxyHandlerTest(TestItem testItem) {
+        this.testItem = testItem;
+    }
 
     @Before
     public void clearServerExceptions() throws Exception {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslJavaxX509Certificate.java
Patch:
@@ -32,7 +32,7 @@ final class OpenSslJavaxX509Certificate extends X509Certificate {
     private final byte[] bytes;
     private X509Certificate wrapped;
 
-    public OpenSslJavaxX509Certificate(byte[] bytes) {
+    OpenSslJavaxX509Certificate(byte[] bytes) {
         this.bytes = bytes;
     }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslX509Certificate.java
Patch:
@@ -41,7 +41,7 @@ final class OpenSslX509Certificate extends X509Certificate {
     private final byte[] bytes;
     private X509Certificate wrapped;
 
-    public OpenSslX509Certificate(byte[] bytes) {
+    OpenSslX509Certificate(byte[] bytes) {
         this.bytes = bytes;
     }
 

File: handler/src/main/java/io/netty/handler/ssl/PemValue.java
Patch:
@@ -34,7 +34,7 @@ class PemValue extends AbstractReferenceCounted implements PemEncoded {
 
     private final boolean sensitive;
 
-    public PemValue(ByteBuf content, boolean sensitive) {
+    PemValue(ByteBuf content, boolean sensitive) {
         this.content = ObjectUtil.checkNotNull(content, "content");
         this.sensitive = sensitive;
     }

File: handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
Patch:
@@ -542,7 +542,7 @@ protected void initChannel(Channel ch) throws Exception {
     private static class CustomSslHandler extends SslHandler {
         private final SslContext sslContext;
 
-        public CustomSslHandler(SslContext sslContext, SSLEngine sslEngine) {
+        CustomSslHandler(SslContext sslContext, SSLEngine sslEngine) {
             super(sslEngine);
             this.sslContext = ObjectUtil.checkNotNull(sslContext, "sslContext");
         }

File: handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java
Patch:
@@ -262,7 +262,7 @@ private static void verifyException(Throwable cause, String messagePart, Promise
     private static final class TestCertificateException extends CertificateException {
         private static final long serialVersionUID = -5816338303868751410L;
 
-        public TestCertificateException(Throwable cause) {
+        TestCertificateException(Throwable cause) {
             super(cause);
         }
     }

File: handler/src/test/java/io/netty/handler/ssl/ocsp/OcspTest.java
Patch:
@@ -459,7 +459,7 @@ private static final class TestClientOcspContext implements OcspClientCallback {
 
         private volatile byte[] response;
 
-        public TestClientOcspContext(boolean valid) {
+        TestClientOcspContext(boolean valid) {
             this.valid = valid;
         }
 
@@ -481,7 +481,7 @@ private static final class OcspClientCallbackHandler extends OcspClientHandler {
 
         private final OcspClientCallback callback;
 
-        public OcspClientCallbackHandler(ReferenceCountedOpenSslEngine engine, OcspClientCallback callback) {
+        OcspClientCallbackHandler(ReferenceCountedOpenSslEngine engine, OcspClientCallback callback) {
             super(engine);
             this.callback = callback;
         }
@@ -496,7 +496,7 @@ protected boolean verify(ChannelHandlerContext ctx, ReferenceCountedOpenSslEngin
     private static final class OcspTestException extends IllegalStateException {
         private static final long serialVersionUID = 4516426833250228159L;
 
-        public OcspTestException(String message) {
+        OcspTestException(String message) {
             super(message);
         }
     }

File: handler/src/test/java/io/netty/handler/timeout/IdleStateHandlerTest.java
Patch:
@@ -317,7 +317,7 @@ private static class TestableIdleStateHandler extends IdleStateHandler {
 
         private long ticksInNanos;
 
-        public TestableIdleStateHandler(boolean observeOutput,
+        TestableIdleStateHandler(boolean observeOutput,
                 long readerIdleTime, long writerIdleTime, long allIdleTime,
                 TimeUnit unit) {
             super(observeOutput, readerIdleTime, writerIdleTime, allIdleTime, unit);
@@ -369,7 +369,7 @@ ScheduledFuture<?> schedule(ChannelHandlerContext ctx, Runnable task, long delay
 
     private static class ObservableChannel extends EmbeddedChannel {
 
-        public ObservableChannel(ChannelHandler... handlers) {
+        ObservableChannel(ChannelHandler... handlers) {
             super(handlers);
         }
 

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackBenchmarkUtil.java
Patch:
@@ -49,7 +49,7 @@ private static class HeadersKey {
         final HpackHeadersSize size;
         final boolean limitToAscii;
 
-        public HeadersKey(HpackHeadersSize size, boolean limitToAscii) {
+        HeadersKey(HpackHeadersSize size, boolean limitToAscii) {
             this.size = size;
             this.limitToAscii = limitToAscii;
         }

File: microbench/src/main/java/io/netty/microbench/concurrent/BurstCostExecutorsBenchmark.java
Patch:
@@ -67,7 +67,7 @@ public void run() {
         private final AtomicBoolean poisoned = new AtomicBoolean();
         private final Thread executorThread;
 
-        public SpinExecutorService(int maxTasks) {
+        SpinExecutorService(int maxTasks) {
             tasks = PlatformDependent.newFixedMpscQueue(maxTasks);
             executorThread = new Thread(new Runnable() {
                 @Override

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -388,7 +388,9 @@ public void run() {
          */
         abstract void epollInReady();
 
-        final void epollInBefore() { maybeMoreDataToRead = false; }
+        final void epollInBefore() {
+            maybeMoreDataToRead = false;
+        }
 
         final void epollInFinally(ChannelConfig config) {
             maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorStreamingHandle.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.RecvByteBufAllocator;
 
 final class EpollRecvByteAllocatorStreamingHandle extends EpollRecvByteAllocatorHandle {
-    public EpollRecvByteAllocatorStreamingHandle(RecvByteBufAllocator.ExtendedHandle handle) {
+    EpollRecvByteAllocatorStreamingHandle(RecvByteBufAllocator.ExtendedHandle handle) {
         super(handle);
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/LinuxSocket.java
Patch:
@@ -40,7 +40,7 @@ final class LinuxSocket extends Socket {
     private static final ClosedChannelException SENDFILE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(
             new ClosedChannelException(), Native.class, "sendfile(...)");
 
-    public LinuxSocket(int fd) {
+    LinuxSocket(int fd) {
         super(fd);
     }
 

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSpliceTest.java
Patch:
@@ -296,7 +296,7 @@ private static class SpliceHandler extends ChannelInboundHandlerAdapter {
         volatile ChannelFuture future;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
-        public SpliceHandler(File file) {
+        SpliceHandler(File file) {
             this.file = file;
         }
 

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java
Patch:
@@ -392,7 +392,9 @@ final void readReady(long numberBytesPending) {
 
         abstract void readReady(KQueueRecvByteAllocatorHandle allocHandle);
 
-        final void readReadyBefore() { maybeMoreDataToRead = false; }
+        final void readReadyBefore() {
+            maybeMoreDataToRead = false;
+        }
 
         final void readReadyFinally(ChannelConfig config) {
             maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();

File: transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
Patch:
@@ -95,7 +95,7 @@ private final class HandleImpl extends MaxMessageHandle {
         private int nextReceiveBufferSize;
         private boolean decreaseNow;
 
-        public HandleImpl(int minIndex, int maxIndex, int initial) {
+        HandleImpl(int minIndex, int maxIndex, int initial) {
             this.minIndex = minIndex;
             this.maxIndex = maxIndex;
 

File: transport/src/main/java/io/netty/channel/FixedRecvByteBufAllocator.java
Patch:
@@ -26,7 +26,7 @@ public class FixedRecvByteBufAllocator extends DefaultMaxMessagesRecvByteBufAllo
     private final class HandleImpl extends MaxMessageHandle {
         private final int bufferSize;
 
-        public HandleImpl(int bufferSize) {
+        HandleImpl(int bufferSize) {
             this.bufferSize = bufferSize;
         }
 

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -366,7 +366,7 @@ private final class AcquireTask extends AcquireListener {
         final long expireNanoTime = System.nanoTime() + acquireTimeoutNanos;
         ScheduledFuture<?> timeoutFuture;
 
-        public AcquireTask(Promise<Channel> promise) {
+        AcquireTask(Promise<Channel> promise) {
             super(promise);
             // We need to create a new promise as we need to ensure the AcquireListener runs in the correct
             // EventLoop.

File: transport/src/test/java/io/netty/channel/AbstractChannelTest.java
Patch:
@@ -96,7 +96,7 @@ private class TestUnsafe extends AbstractUnsafe {
             public void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) { }
         }
 
-        public TestChannel() {
+        TestChannel() {
             super(null);
         }
 

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTailTest.java
Patch:
@@ -237,7 +237,7 @@ protected void onUnhandledInboundWritabilityChanged() {
     private static class MyChannelFactory implements ChannelFactory<MyChannel> {
         private final MyChannel channel;
 
-        public MyChannelFactory(MyChannel channel) {
+        MyChannelFactory(MyChannel channel) {
             this.channel = channel;
         }
 
@@ -365,7 +365,7 @@ public void connect(SocketAddress remoteAddress, SocketAddress localAddress, Cha
 
         private class MyChannelPipeline extends DefaultChannelPipeline {
 
-            public MyChannelPipeline(Channel channel) {
+            MyChannelPipeline(Channel channel) {
                 super(channel);
             }
 

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -497,7 +497,7 @@ private void updateComponentOffsets(int cIndex) {
             return;
         }
 
-        int nextIndex = cIndex > 0 ? components[cIndex].endOffset : 0;
+        int nextIndex = cIndex > 0 ? components[cIndex - 1].endOffset : 0;
         for (; cIndex < size; cIndex++) {
             Component c = components[cIndex];
             c.reposition(nextIndex);
@@ -748,6 +748,7 @@ public CompositeByteBuf capacity(int newCapacity) {
                 consolidateIfNeeded();
             }
         } else if (newCapacity < oldCapacity) {
+            lastAccessed = null;
             int i = size - 1;
             for (int bytesToTrim = oldCapacity - newCapacity; i >= 0; i--) {
                 Component c = components[i];
@@ -801,7 +802,7 @@ public int maxNumComponents() {
      */
     public int toComponentIndex(int offset) {
         checkIndex(offset);
-        return toComponentIndex(offset);
+        return toComponentIndex0(offset);
     }
 
     private int toComponentIndex0(int offset) {

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -813,7 +813,7 @@ private void throwIfInEventLoop(String method) {
 
     /**
      * Returns the {@link ThreadProperties} of the {@link Thread} that powers the {@link SingleThreadEventExecutor}.
-     * If the {@link SingleThreadEventExecutor} is not started yet, this operation will start it and block until the
+     * If the {@link SingleThreadEventExecutor} is not started yet, this operation will start it and block until
      * it is fully started.
      */
     public final ThreadProperties threadProperties() {

File: common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java
Patch:
@@ -31,7 +31,7 @@
 public class SingleThreadEventExecutorTest {
 
     @Test
-    public void testWrappedExecutureIsShutdown() {
+    public void testWrappedExecutorIsShutdown() {
         ExecutorService executorService = Executors.newSingleThreadExecutor();
 
         SingleThreadEventExecutor executor = new SingleThreadEventExecutor(null, executorService, false) {

File: transport/src/test/java/io/netty/channel/ChannelInitializerTest.java
Patch:
@@ -335,7 +335,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg)  {
                                             }
 
                                             @Override
-                                            public void channelUnregistered(ChannelHandlerContext ctx) {
+                                            public void handlerRemoved(ChannelHandlerContext ctx) {
                                                 latch.countDown();
                                             }
                                         });
@@ -369,6 +369,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         client.closeFuture().sync();
         server.closeFuture().sync();
 
+        // Wait until the handler is removed from the pipeline and so no more events are handled by it.
         latch.await();
 
         assertEquals(1, invokeCount.get());

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.util.ReferenceCountUtil;
 
@@ -164,7 +165,7 @@ private void decodeContent(HttpContent c, List<Object> out) {
             if (headers.isEmpty()) {
                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
             } else {
-                out.add(new ComposedLastHttpContent(headers));
+                out.add(new ComposedLastHttpContent(headers, DecoderResult.SUCCESS));
             }
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufHolder;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.MessageToMessageCodec;
 import io.netty.util.ReferenceCountUtil;
 
@@ -264,7 +265,7 @@ private boolean encodeContent(HttpContent c, List<Object> out) {
             if (headers.isEmpty()) {
                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
             } else {
-                out.add(new ComposedLastHttpContent(headers));
+                out.add(new ComposedLastHttpContent(headers, DecoderResult.SUCCESS));
             }
             return true;
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.EncoderException;
 import io.netty.handler.codec.MessageToByteEncoder;
 import io.netty.util.CharsetUtil;
@@ -156,6 +157,7 @@ public void testChunkedContentWithTrailingHeader() throws Exception {
         assertThat(chunk.content().isReadable(), is(false));
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         assertEquals("Netty", ((LastHttpContent) chunk).trailingHeaders().get(of("X-Test")));
+        assertEquals(DecoderResult.SUCCESS, res.decoderResult());
         chunk.release();
 
         assertThat(ch.readOutbound(), is(nullValue()));
@@ -285,6 +287,7 @@ public void testEmptyFullContentWithTrailer() throws Exception {
         assertThat(res.content().readableBytes(), is(0));
         assertThat(res.content().toString(CharsetUtil.US_ASCII), is(""));
         assertEquals("Netty", res.trailingHeaders().get(of("X-Test")));
+        assertEquals(DecoderResult.SUCCESS, res.decoderResult());
         assertThat(ch.readOutbound(), is(nullValue()));
     }
 

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -597,7 +597,7 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
     @Override
     ChannelPipeline fireChannelRegistered();
 
-     @Override
+    @Override
     ChannelPipeline fireChannelUnregistered();
 
     @Override

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -219,7 +219,7 @@ public static ByteBuf wrappedBuffer(long memoryAddress, int size, boolean doFree
      * Creates a new buffer which wraps the specified buffer's readable bytes.
      * A modification on the specified buffer's content will be visible to the
      * returned buffer.
-     * @param buffer The buffer to wrap. Reference count ownership of this variable is transfered to this method.
+     * @param buffer The buffer to wrap. Reference count ownership of this variable is transferred to this method.
      * @return The readable portion of the {@code buffer}, or an empty buffer if there is no readable portion.
      * The caller is responsible for releasing this buffer.
      */
@@ -245,7 +245,7 @@ public static ByteBuf wrappedBuffer(byte[]... arrays) {
      * Creates a new big-endian composite buffer which wraps the readable bytes of the
      * specified buffers without copying them.  A modification on the content
      * of the specified buffers will be visible to the returned buffer.
-     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method.
+     * @param buffers The buffers to wrap. Reference count ownership of all variables is transferred to this method.
      * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer.
      */
     public static ByteBuf wrappedBuffer(ByteBuf... buffers) {
@@ -300,7 +300,7 @@ public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays) {
      * of the specified buffers will be visible to the returned buffer.
      * @param maxNumComponents Advisement as to how many independent buffers are allowed to exist before
      * consolidation occurs.
-     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method.
+     * @param buffers The buffers to wrap. Reference count ownership of all variables is transferred to this method.
      * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer.
      */
     public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1695,7 +1695,7 @@ public String toString() {
     }
 
     /**
-     * Returns a deap copy of the passed in {@link HttpHeaders}.
+     * Returns a deep copy of the passed in {@link HttpHeaders}.
      */
     public HttpHeaders copy() {
         return new DefaultHttpHeaders().set(this);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
Patch:
@@ -37,7 +37,7 @@ public interface Http2DataFrame extends Http2StreamFrame, ByteBufHolder {
     ByteBuf content();
 
     /**
-     * Returns the number of bytes that are flow-controlled initialy, so even if the {@link #content()} is consumed
+     * Returns the number of bytes that are flow-controlled initially, so even if the {@link #content()} is consumed
      * this will not change.
      */
     int initialFlowControlledBytes();

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -134,7 +134,7 @@ public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)
                 return buffer;
             } finally {
                 if (in != null) {
-                    // We must release if the ownership was not transfered as otherwise it may produce a leak if
+                    // We must release if the ownership was not transferred as otherwise it may produce a leak if
                     // writeBytes(...) throw for whatever release (for example because of OutOfMemoryError).
                     in.release();
                 }

File: common/src/main/java/io/netty/util/HashingStrategy.java
Patch:
@@ -41,7 +41,7 @@ public interface HashingStrategy<T> {
      * This method has the following restrictions:
      * <ul>
      * <li><i>reflexive</i> - {@code equals(a, a)} should return true</li>
-     * <li><i>symmetric</i> - {@code equals(a, b)} returns {@code true} iff {@code equals(b, a)} returns
+     * <li><i>symmetric</i> - {@code equals(a, b)} returns {@code true} if {@code equals(b, a)} returns
      * {@code true}</li>
      * <li><i>transitive</i> - if {@code equals(a, b)} returns {@code true} and {@code equals(a, c)} returns
      * {@code true} then {@code equals(b, c)} should also return {@code true}</li>

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -1199,7 +1199,7 @@ private SSLEngineResult sslReadErrorResult(int error, int stackError, int bytesC
         // See https://github.com/netty/netty/issues/3900
         if (SSL.bioLengthNonApplication(networkBIO) > 0) {
             if (handshakeException == null && handshakeState != HandshakeState.FINISHED) {
-                // we seems to have data left that needs to be transfered and so the user needs
+                // we seems to have data left that needs to be transferred and so the user needs
                 // call wrap(...). Store the error so we can pick it up later.
                 handshakeException = new SSLHandshakeException(SSL.getErrorString(stackError));
             }

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueChannelConfig.java
Patch:
@@ -67,7 +67,7 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
     }
 
     /**
-     * If this is {@code true} then the {@link RecvByteBufAllocator.Handle#guess()} will be overriden to always attempt
+     * If this is {@code true} then the {@link RecvByteBufAllocator.Handle#guess()} will be overridden to always attempt
      * to read as many bytes as kqueue says are available.
      */
     public KQueueChannelConfig setRcvAllocTransportProvidesGuess(boolean transportProvidesGuess) {
@@ -76,7 +76,7 @@ public KQueueChannelConfig setRcvAllocTransportProvidesGuess(boolean transportPr
     }
 
     /**
-     * If this is {@code true} then the {@link RecvByteBufAllocator.Handle#guess()} will be overriden to always attempt
+     * If this is {@code true} then the {@link RecvByteBufAllocator.Handle#guess()} will be overridden to always attempt
      * to read as many bytes as kqueue says are available.
      */
     public boolean getRcvAllocTransportProvidesGuess() {

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueChannelOption.java
Patch:
@@ -27,7 +27,7 @@ public final class KQueueChannelOption<T> extends UnixChannelOption<T> {
     public static final ChannelOption<AcceptFilter> SO_ACCEPTFILTER =
             valueOf(KQueueChannelOption.class, "SO_ACCEPTFILTER");
     /**
-     * If this is {@code true} then the {@link RecvByteBufAllocator.Handle#guess()} will be overriden to always attempt
+     * If this is {@code true} then the {@link RecvByteBufAllocator.Handle#guess()} will be overridden to always attempt
      * to read as many bytes as kqueue says are available.
      */
     public static final ChannelOption<Boolean> RCV_ALLOC_TRANSPORT_PROVIDES_GUESS =

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/Native.java
Patch:
@@ -44,7 +44,7 @@
 import static io.netty.channel.unix.Errors.newIOException;
 
 /**
- * Navite helper methods
+ * Native helper methods
  * <p><strong>Internal usage only!</strong>
  */
 final class Native {

File: transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java
Patch:
@@ -40,7 +40,7 @@ public abstract class AbstractCoalescingBufferQueue {
      *
      * @param channel the {@link Channel} which will have the {@link Channel#isWritable()} reflect the amount of queued
      *                buffers or {@code null} if there is no writability state updated.
-     * @param initSize theinitial size of the underlying queue.
+     * @param initSize the initial size of the underlying queue.
      */
     protected AbstractCoalescingBufferQueue(Channel channel, int initSize) {
         bufAndListenerPairs = new ArrayDeque<Object>(initSize);

File: transport/src/main/java/io/netty/channel/DefaultFileRegion.java
Patch:
@@ -44,7 +44,7 @@ public class DefaultFileRegion extends AbstractReferenceCounted implements FileR
     /**
      * Create a new instance
      *
-     * @param file      the {@link FileChannel} which should be transfered
+     * @param file      the {@link FileChannel} which should be transferred
      * @param position  the position from which the transfer should start
      * @param count     the number of bytes to transfer
      */
@@ -68,7 +68,7 @@ public DefaultFileRegion(FileChannel file, long position, long count) {
      * Create a new instance using the given {@link File}. The {@link File} will be opened lazily or
      * explicitly via {@link #open()}.
      *
-     * @param f         the {@link File} which should be transfered
+     * @param f         the {@link File} which should be transferred
      * @param position  the position from which the transfer should start
      * @param count     the number of bytes to transfer
      */

File: transport/src/main/java/io/netty/channel/FileRegion.java
Patch:
@@ -58,15 +58,15 @@ public interface FileRegion extends ReferenceCounted {
     long position();
 
     /**
-     * Returns the bytes which was transfered already.
+     * Returns the bytes which was transferred already.
      *
      * @deprecated Use {@link #transferred()} instead.
      */
     @Deprecated
     long transfered();
 
     /**
-     * Returns the bytes which was transfered already.
+     * Returns the bytes which was transferred already.
      */
     long transferred();
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -123,7 +123,7 @@ public ChannelMetadata metadata() {
     /**
      * {@inheritDoc}
      *
-     * This can be safetly cast to {@link OioDatagramChannelConfig}.
+     * This can be safely cast to {@link OioDatagramChannelConfig}.
      */
     @Override
     // TODO: Change return type to OioDatagramChannelConfig in next major release

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -148,7 +148,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {
 
     private final Integer initialFlowControlWindowSize;
 
-    private ChannelHandlerContext ctx;
+    ChannelHandlerContext ctx;
 
     /** Number of buffered streams if the {@link StreamBufferingEncoder} is used. **/
     private int numBufferedStreams;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/TestChannelInitializer.java
Patch:
@@ -50,9 +50,9 @@ public void initChannel(Channel channel) {
     /**
      * Designed to read a single byte at a time to control the number of reads done at a fine granularity.
      */
-    private static final class TestNumReadsRecvByteBufAllocator implements RecvByteBufAllocator {
+    static final class TestNumReadsRecvByteBufAllocator implements RecvByteBufAllocator {
         private final AtomicInteger numReads;
-        TestNumReadsRecvByteBufAllocator(AtomicInteger numReads) {
+        private TestNumReadsRecvByteBufAllocator(AtomicInteger numReads) {
             this.numReads = numReads;
         }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -805,7 +805,7 @@ void fireChildRead(Http2Frame frame) {
 
         void fireChildReadComplete() {
             assert eventLoop().inEventLoop();
-            assert readStatus == ReadStatus.IN_PROGRESS;
+            assert readStatus != ReadStatus.IDLE;
             unsafe.notifyReadComplete(unsafe.recvBufAllocHandle());
         }
 

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -107,7 +107,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
     /**
      * Decode from one message to an other. This method will be called for each written message that can be handled
-     * by this encoder.
+     * by this decoder.
      *
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToMessageDecoder} belongs to
      * @param msg           the message to decode to an other one

File: handler/src/main/java/io/netty/handler/ipfilter/UniqueIpFilter.java
Patch:
@@ -38,10 +38,9 @@ public class UniqueIpFilter extends AbstractRemoteAddressFilter<InetSocketAddres
     @Override
     protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {
         final InetAddress remoteIp = remoteAddress.getAddress();
-        if (connected.contains(remoteIp)) {
+        if (!connected.add(remoteIp)) {
             return false;
         } else {
-            connected.add(remoteIp);
             ctx.channel().closeFuture().addListener(new ChannelFutureListener() {
                 @Override
                 public void operationComplete(ChannelFuture future) throws Exception {

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -64,9 +64,9 @@ private CompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumCompo
         if (alloc == null) {
             throw new NullPointerException("alloc");
         }
-        if (maxNumComponents < 2) {
+        if (maxNumComponents < 1) {
             throw new IllegalArgumentException(
-                    "maxNumComponents: " + maxNumComponents + " (expected: >= 2)");
+                    "maxNumComponents: " + maxNumComponents + " (expected: >= 1)");
         }
         this.alloc = alloc;
         this.direct = direct;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -195,7 +195,7 @@ public ChannelFuture writeData(ChannelHandlerContext ctx, int streamId, ByteBuf
                     ctx.write(lastFrame, promiseAggregator.newPromise());
 
                     // Write the payload.
-                    lastFrame = data.readSlice(maxFrameSize);
+                    lastFrame = data.readableBytes() != maxFrameSize ? data.readSlice(maxFrameSize) : data;
                     data = null;
                     ctx.write(lastFrame, promiseAggregator.newPromise());
                 }

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1331,7 +1331,7 @@ final class HeadContext extends AbstractChannelHandlerContext
         private final Unsafe unsafe;
 
         HeadContext(DefaultChannelPipeline pipeline) {
-            super(pipeline, null, HEAD_NAME, false, true);
+            super(pipeline, null, HEAD_NAME, true, true);
             unsafe = pipeline.channel().unsafe();
             setAddComplete();
         }

File: transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java
Patch:
@@ -74,7 +74,7 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
     }
 
     /**
-     * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward
+     * Calls {@link ChannelHandlerContext#deregister(ChannelPromise)} to forward
      * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1570,7 +1570,8 @@ private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boo
                         //
                         // See https://github.com/netty/netty/issues/1340
                         String msg = e.getMessage();
-                        if (msg == null || !msg.contains("possible truncation attack")) {
+                        if (msg == null || !(msg.contains("possible truncation attack") ||
+                                msg.contains("closing inbound before receiving peer's close_notify"))) {
                             logger.debug("{} SSLEngine.closeInbound() raised an exception.", ctx.channel(), e);
                         }
                     }

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -250,7 +250,7 @@ public String run() {
                     }
                 } else {
                     CipherSuiteConverter.convertToCipherStrings(
-                            unmodifiableCiphers, cipherBuilder, cipherTLSv13Builder);
+                            unmodifiableCiphers, cipherBuilder, cipherTLSv13Builder, OpenSsl.isBoringSSL());
 
                     // Set non TLSv1.3 ciphers.
                     SSLContext.setCipherSuite(ctx, cipherBuilder.toString(), false);

File: buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java
Patch:
@@ -585,7 +585,7 @@ static void getBytes(AbstractByteBuf buf, long addr, int index, OutputStream out
         if (length != 0) {
             int len = Math.min(length, ByteBufUtil.WRITE_CHUNK_SIZE);
             if (len <= ByteBufUtil.MAX_TL_ARRAY_LEN || !buf.alloc().isDirectBufferPooled()) {
-                getBytes(addr, ByteBufUtil.threadLocalTempArray(length), 0, len, out, length);
+                getBytes(addr, ByteBufUtil.threadLocalTempArray(len), 0, len, out, length);
             } else {
                 // if direct buffers are pooled chances are good that heap buffers are pooled as well.
                 ByteBuf tmpBuf = buf.alloc().heapBuffer(len);

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -969,7 +969,7 @@ protected void initChannel(Channel ch) {
                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), type));
 
                 ChannelPipeline p = ch.pipeline();
-                SSLEngine engine = serverSslCtx.newEngine(ch.alloc());
+                SSLEngine engine = wrapEngine(serverSslCtx.newEngine(ch.alloc()));
                 engine.setUseClientMode(false);
                 engine.setNeedClientAuth(true);
 
@@ -1679,7 +1679,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
             @Override
             protected void initChannel(Channel ch) throws Exception {
                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), type));
-                ch.pipeline().addLast(new SslHandler(clientSslCtx.newEngine(ch.alloc())));
+                ch.pipeline().addLast(new SslHandler(wrapEngine(clientSslCtx.newEngine(ch.alloc()))));
             }
 
         }).connect(serverChannel.localAddress()).syncUninterruptibly().channel();
@@ -2649,7 +2649,7 @@ public void testInvalidCipher() throws Exception {
         try {
             serverSslCtx = SslContextBuilder.forServer(cert.key(), cert.cert()).sslProvider(sslClientProvider())
                                             .ciphers(cipherList).build();
-            server = serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);
+            server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
             fail();
         } catch (IllegalArgumentException expected) {
             // expected when invalid cipher is used.

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -319,7 +319,7 @@ public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers) {
             for (int i = 0; i < buffers.length; i++) {
                 ByteBuf buf = buffers[i];
                 if (buf.isReadable()) {
-                    return new CompositeByteBuf(ALLOC, false, maxNumComponents, buffers, i, buffers.length);
+                    return new CompositeByteBuf(ALLOC, false, maxNumComponents, buffers, i);
                 }
                 buf.release();
             }

File: handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
Patch:
@@ -64,16 +64,16 @@ static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date
         info.set(X509CertInfo.VALIDITY, new CertificateValidity(notBefore, notAfter));
         info.set(X509CertInfo.KEY, new CertificateX509Key(keypair.getPublic()));
         info.set(X509CertInfo.ALGORITHM_ID,
-                new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha1WithRSAEncryption_oid)));
+                new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha256WithRSAEncryption_oid)));
 
         // Sign the cert to identify the algorithm that's used.
         X509CertImpl cert = new X509CertImpl(info);
-        cert.sign(key, "SHA1withRSA");
+        cert.sign(key, "SHA256withRSA");
 
         // Update the algorithm and sign again.
         info.set(CertificateAlgorithmId.NAME + '.' + CertificateAlgorithmId.ALGORITHM, cert.get(X509CertImpl.SIG_ALG));
         cert = new X509CertImpl(info);
-        cert.sign(key, "SHA1withRSA");
+        cert.sign(key, "SHA256withRSA");
         cert.verify(keypair.getPublic());
 
         return newSelfSignedCertificate(fqdn, key, cert);

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -154,8 +154,8 @@ public Random current() {
                 DIRECT_MEMORY_COUNTER = new AtomicLong();
             }
         }
-        DIRECT_MEMORY_LIMIT = maxDirectMemory;
         logger.debug("-Dio.netty.maxDirectMemory: {} bytes", maxDirectMemory);
+        DIRECT_MEMORY_LIMIT = maxDirectMemory >= 1 ? maxDirectMemory : MAX_DIRECT_MEMORY;
 
         int tryAllocateUninitializedArray =
                 SystemPropertyUtil.getInt("io.netty.uninitializedArrayAllocationThreshold", 1024);
@@ -284,7 +284,7 @@ public static boolean directBufferPreferred() {
      * Returns the maximum memory reserved for direct buffer allocation.
      */
     public static long maxDirectMemory() {
-        return MAX_DIRECT_MEMORY;
+        return DIRECT_MEMORY_LIMIT;
     }
 
     /**

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -374,7 +374,7 @@ public DnsNameResolver(
             default:
                 throw new IllegalArgumentException("Unknown ResolvedAddressTypes " + resolvedAddressTypes);
         }
-        preferredAddressType = preferredAddressType(resolvedAddressTypes);
+        preferredAddressType = preferredAddressType(this.resolvedAddressTypes);
         this.authoritativeDnsServerCache = checkNotNull(authoritativeDnsServerCache, "authoritativeDnsServerCache");
         nameServerComparator = new NameServerComparator(preferredAddressType.addressType());
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -537,7 +537,7 @@ private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int st
                 // elsewhere so we don't close the stream or otherwise modify the stream's state.
 
                 if (logger.isInfoEnabled()) {
-                    logger.info("{} ignoring {} frame for stream {} {}", ctx.channel(), frameName,
+                    logger.info("{} ignoring {} frame for stream {}", ctx.channel(), frameName,
                             stream.isResetSent() ? "RST_STREAM sent." :
                                 ("Stream created after GOAWAY sent. Last known stream by peer " +
                                  connection.remote().lastStreamKnownByPeer()));

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -501,7 +501,7 @@ public String toString() {
 
             if (duped > 0) {
                 buf.append(": ")
-                        .append(dropped)
+                        .append(duped)
                         .append(" leak records were discarded because they were duplicates")
                         .append(NEWLINE);
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java
Patch:
@@ -186,12 +186,12 @@ public PermessageDeflateExtension(boolean serverNoContext, int serverWindowSize,
 
         @Override
         public WebSocketExtensionEncoder newExtensionEncoder() {
-            return new PerMessageDeflateEncoder(compressionLevel, serverWindowSize, serverNoContext);
+            return new PerMessageDeflateEncoder(compressionLevel, clientWindowSize, clientNoContext);
         }
 
         @Override
         public WebSocketExtensionDecoder newExtensionDecoder() {
-            return new PerMessageDeflateDecoder(clientNoContext);
+            return new PerMessageDeflateDecoder(serverNoContext);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java
Patch:
@@ -167,12 +167,12 @@ public int rsv() {
 
         @Override
         public WebSocketExtensionEncoder newExtensionEncoder() {
-            return new PerMessageDeflateEncoder(compressionLevel, clientWindowSize, clientNoContext);
+            return new PerMessageDeflateEncoder(compressionLevel, serverWindowSize, serverNoContext);
         }
 
         @Override
         public WebSocketExtensionDecoder newExtensionDecoder() {
-            return new PerMessageDeflateDecoder(serverNoContext);
+            return new PerMessageDeflateDecoder(clientNoContext);
         }
 
         @Override

File: handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java
Patch:
@@ -42,7 +42,6 @@ abstract class ExtendedOpenSslSession extends ExtendedSSLSession implements Open
     private final OpenSslSession wrapped;
 
     ExtendedOpenSslSession(OpenSslSession wrapped) {
-        assert !(wrapped instanceof ExtendedSSLSession);
         this.wrapped = wrapped;
     }
 
@@ -153,7 +152,7 @@ public final String getCipherSuite() {
     }
 
     @Override
-    public final String getProtocol() {
+    public String getProtocol() {
         return wrapped.getProtocol();
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -233,7 +233,7 @@ private static final class ExtendedTrustManagerVerifyCallback extends AbstractCe
 
         ExtendedTrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509ExtendedTrustManager manager) {
             super(engineMap);
-            this.manager = manager;
+            this.manager = OpenSslTlsv13X509ExtendedTrustManager.wrap(manager, true);
         }
 
         @Override

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java
Patch:
@@ -239,7 +239,7 @@ private static final class ExtendedTrustManagerVerifyCallback extends AbstractCe
 
         ExtendedTrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509ExtendedTrustManager manager) {
             super(engineMap);
-            this.manager = manager;
+            this.manager = OpenSslTlsv13X509ExtendedTrustManager.wrap(manager, false);
         }
 
         @Override

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -97,10 +97,11 @@ final class SslUtils {
 
     static final String[] DEFAULT_CIPHER_SUITES;
     static final String[] DEFAULT_TLSV13_CIPHER_SUITES;
+    static final String[] TLSV13_CIPHER_SUITES = { "TLS_AES_128_GCM_SHA256", "TLS_AES_256_GCM_SHA384" };
 
     static {
         if (PlatformDependent.javaVersion() >= 11) {
-            DEFAULT_TLSV13_CIPHER_SUITES = new String[] { "TLS_AES_128_GCM_SHA256", "TLS_AES_256_GCM_SHA384" };
+            DEFAULT_TLSV13_CIPHER_SUITES = TLSV13_CIPHER_SUITES;
         } else {
             DEFAULT_TLSV13_CIPHER_SUITES = EmptyArrays.EMPTY_STRINGS;
         }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java
Patch:
@@ -73,7 +73,7 @@ public static Collection<Object[]> data() {
         for (BufferType type: BufferType.values()) {
             params.add(new Object[] { type, ProtocolCipherCombo.tlsv12()});
 
-            if (PlatformDependent.javaVersion() >= 11 && OpenSsl.isTlsv13Supported()) {
+            if (OpenSsl.isTlsv13Supported()) {
                 params.add(new Object[] { type, ProtocolCipherCombo.tlsv13() });
             }
         }

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -1201,6 +1201,7 @@ public void testSSLSessionId() throws Exception {
     @Test(timeout = 30000)
     public void clientInitiatedRenegotiationWithFatalAlertDoesNotInfiniteLoopServer()
             throws CertificateException, SSLException, InterruptedException, ExecutionException {
+        Assume.assumeTrue(PlatformDependent.javaVersion() >= 11);
         final SelfSignedCertificate ssc = new SelfSignedCertificate();
         serverSslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                         .sslProvider(sslServerProvider())

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -294,7 +294,7 @@ public void register(final SelectableChannel ch, final int interestOps, final Ni
         }
 
         try {
-            ch.register(selector, interestOps, task);
+            ch.register(unwrappedSelector, interestOps, task);
         } catch (Exception e) {
             throw new EventLoopException("failed to register a channel", e);
         }

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueChannelConfig.java
Patch:
@@ -31,13 +31,11 @@
 
 @UnstableApi
 public class KQueueChannelConfig extends DefaultChannelConfig {
-    final AbstractKQueueChannel channel;
     private volatile boolean transportProvidesGuess;
     private volatile long maxBytesPerGatheringWrite = SSIZE_MAX;
 
     KQueueChannelConfig(AbstractKQueueChannel channel) {
         super(channel);
-        this.channel = channel;
     }
 
     @Override
@@ -154,7 +152,7 @@ public KQueueChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimato
 
     @Override
     protected final void autoReadCleared() {
-        channel.clearReadFilter();
+        ((AbstractKQueueChannel) channel).clearReadFilter();
     }
 
     final void setMaxBytesPerGatheringWrite(long maxBytesPerGatheringWrite) {

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -508,7 +508,7 @@ protected static X509Certificate[] certificates(byte[][] chain) {
     protected static X509TrustManager chooseTrustManager(TrustManager[] managers) {
         for (TrustManager m : managers) {
             if (m instanceof X509TrustManager) {
-                return (X509TrustManager) m;
+                return OpenSslX509TrustManagerWrapper.wrapIfNeeded((X509TrustManager) m);
             }
         }
         throw new IllegalStateException("no X509TrustManager found");

File: handler/src/test/java/io/netty/handler/ssl/ParameterizedSslHandlerTest.java
Patch:
@@ -340,7 +340,7 @@ protected void initChannel(Channel ch) throws Exception {
                                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                                     if (cause.getCause() instanceof SSLException) {
                                         // We received the alert and so produce an SSLException.
-                                        promise.setSuccess(null);
+                                        promise.trySuccess(null);
                                     }
                                 }
                             });

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressEncoder.java
Patch:
@@ -44,7 +44,6 @@ public void encodeAddress(Socks5AddressType addrType, String addrValue, ByteBuf
                     out.writeByte(addrValue.length());
                     out.writeCharSequence(addrValue, CharsetUtil.US_ASCII);
                 } else {
-                    out.writeByte(1);
                     out.writeByte(0);
                 }
             } else if (typeVal == Socks5AddressType.IPv6.byteValue()) {

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandResponseTest.java
Patch:
@@ -51,8 +51,7 @@ public void testEmptyDomain() {
                 0x00, // success reply
                 0x00, // reserved
                 0x03, // address type domain
-                0x01, // length of domain
-                0x00, // domain value
+                0x00, // length of domain
                 0x00, // port value
                 0x00
         };

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
Patch:
@@ -38,6 +38,7 @@ public final class EpollChannelOption<T> extends UnixChannelOption<T> {
     public static final ChannelOption<Integer> TCP_DEFER_ACCEPT =
             ChannelOption.valueOf(EpollChannelOption.class, "TCP_DEFER_ACCEPT");
     public static final ChannelOption<Boolean> TCP_QUICKACK = valueOf(EpollChannelOption.class, "TCP_QUICKACK");
+    public static final ChannelOption<Integer> SO_BUSY_POLL = valueOf(EpollChannelOption.class, "SO_BUSY_POLL");
 
     public static final ChannelOption<EpollMode> EPOLL_MODE =
             ChannelOption.valueOf(EpollChannelOption.class, "EPOLL_MODE");

File: codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
Patch:
@@ -137,6 +137,8 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Except
             } else {
                 discardedBytes += buffer.readableBytes();
                 buffer.readerIndex(buffer.writerIndex());
+                // We skip everything in the buffer, we need to set the offset to 0 again.
+                offset = 0;
             }
             return null;
         }

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -82,11 +82,11 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
             }
 
             case READ_VARIABLE_HEADER:  try {
+                final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);
+                variableHeader = decodedVariableHeader.value;
                 if (bytesRemainingInVariablePart > maxBytesInMessage) {
                     throw new DecoderException("too large message: " + bytesRemainingInVariablePart + " bytes");
                 }
-                final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);
-                variableHeader = decodedVariableHeader.value;
                 bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;
                 checkpoint(DecoderState.READ_PAYLOAD);
                 // fall through
@@ -133,7 +133,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
 
     private MqttMessage invalidMessage(Throwable cause) {
       checkpoint(DecoderState.BAD_MESSAGE);
-      return MqttMessageFactory.newInvalidMessage(cause);
+      return MqttMessageFactory.newInvalidMessage(mqttFixedHeader, variableHeader, cause);
     }
 
     /**

File: buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
Patch:
@@ -64,7 +64,7 @@ public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int ma
         }
 
         this.alloc = alloc;
-        setByteBuffer(ByteBuffer.allocateDirect(initialCapacity));
+        setByteBuffer(allocateDirect(initialCapacity));
     }
 
     /**

File: buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
Patch:
@@ -401,7 +401,7 @@ public void testHasMemoryAddressWhenEmpty() {
         buf.release();
     }
 
-    @Test(expected = UnsupportedOperationException.class)
+    @Test
     public void testHasNoMemoryAddressWhenMultipleBuffers() {
         ByteBuf buf1 = directBuffer(10);
         if (!buf1.hasMemoryAddress()) {
@@ -415,6 +415,8 @@ public void testHasNoMemoryAddressWhenMultipleBuffers() {
         try {
             buf.memoryAddress();
             fail();
+        } catch (UnsupportedOperationException expected) {
+            // expected
         } finally {
             buf.release();
         }

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -78,6 +78,7 @@ public static <T> ChannelOption<T> newInstance(String name) {
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS = valueOf("CONNECT_TIMEOUT_MILLIS");
     /**
      * @deprecated Use {@link MaxMessagesRecvByteBufAllocator}
+     * and {@link MaxMessagesRecvByteBufAllocator#maxMessagesPerRead(int)}.
      */
     @Deprecated
     public static final ChannelOption<Integer> MAX_MESSAGES_PER_READ = valueOf("MAX_MESSAGES_PER_READ");

File: resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.resolver.dns;
 
 import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 final class RotationalDnsServerAddresses extends DefaultDnsServerAddresses {
@@ -27,7 +28,7 @@ final class RotationalDnsServerAddresses extends DefaultDnsServerAddresses {
     @SuppressWarnings("UnusedDeclaration")
     private volatile int startIdx;
 
-    RotationalDnsServerAddresses(InetSocketAddress[] addresses) {
+    RotationalDnsServerAddresses(List<InetSocketAddress> addresses) {
         super("rotational", addresses);
     }
 
@@ -36,7 +37,7 @@ public DnsServerAddressStream stream() {
         for (;;) {
             int curStartIdx = startIdx;
             int nextStartIdx = curStartIdx + 1;
-            if (nextStartIdx >= addresses.length) {
+            if (nextStartIdx >= addresses.size()) {
                 nextStartIdx = 0;
             }
             if (startIdxUpdater.compareAndSet(this, curStartIdx, nextStartIdx)) {

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -304,7 +304,7 @@ protected boolean hasTasks() {
      * Return the number of tasks that are pending for processing.
      *
      * <strong>Be aware that this operation may be expensive as it depends on the internal implementation of the
-     * SingleThreadEventExecutor. So use it was care!</strong>
+     * SingleThreadEventExecutor. So use it with care!</strong>
      */
     public int pendingTasks() {
         return taskQueue.size();

File: handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java
Patch:
@@ -70,7 +70,9 @@ public int errorCode() {
     }
 
     private static int checkErrorCode(int errorCode) {
-        if (!CertificateVerifier.isValid(errorCode)) {
+        // Call OpenSsl.isAvailable() to ensure we try to load the native lib as CertificateVerifier.isValid(...)
+        // will depend on it. If loading fails we will just skip the validation.
+        if (OpenSsl.isAvailable() && !CertificateVerifier.isValid(errorCode)) {
             throw new IllegalArgumentException("errorCode '" + errorCode +
                     "' invalid, see https://www.openssl.org/docs/man1.0.2/apps/verify.html.");
         }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -790,7 +790,7 @@ protected void doResolveAll(String inetHost,
         }
     }
 
-    private boolean doResolveAllCached(String hostname,
+    boolean doResolveAllCached(String hostname,
                                        DnsRecord[] additionals,
                                        Promise<List<InetAddress>> promise,
                                        DnsCache resolveCache) {

File: handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java
Patch:
@@ -69,7 +69,7 @@ static void setSNIMatchers(SSLParameters sslParameters, Collection<?> matchers)
     }
 
     @SuppressWarnings("unchecked")
-    static boolean checkSniHostnameMatch(Collection<?> matchers, String hostname) {
+    static boolean checkSniHostnameMatch(Collection<?> matchers, byte[] hostname) {
         if (matchers != null && !matchers.isEmpty()) {
             SNIHostName name = new SNIHostName(hostname);
             Iterator<SNIMatcher> matcherIt = (Iterator<SNIMatcher>) matchers.iterator();

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.internal.tcnative.Buffer;
 import io.netty.internal.tcnative.SSL;
 import io.netty.util.AbstractReferenceCounted;
+import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCounted;
 import io.netty.util.ResourceLeakDetector;
 import io.netty.util.ResourceLeakDetectorFactory;
@@ -1817,7 +1818,7 @@ private boolean isDestroyed() {
         return destroyed != 0;
     }
 
-    final boolean checkSniHostnameMatch(String hostname) {
+    final boolean checkSniHostnameMatch(byte[] hostname) {
         return Java8SslUtils.checkSniHostnameMatch(matchers, hostname);
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.internal.tcnative.SSL;
 import io.netty.internal.tcnative.SSLContext;
 import io.netty.internal.tcnative.SniHostNameMatcher;
+import io.netty.util.CharsetUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -244,7 +245,8 @@ private static final class OpenSslSniHostnameMatcher implements SniHostNameMatch
         public boolean match(long ssl, String hostname) {
             ReferenceCountedOpenSslEngine engine = engineMap.get(ssl);
             if (engine != null) {
-                return engine.checkSniHostnameMatch(hostname);
+                // TODO: In the next release of tcnative we should pass the byte[] directly in and not use a String.
+                return engine.checkSniHostnameMatch(hostname.getBytes(CharsetUtil.UTF_8));
             }
             logger.warn("No ReferenceCountedOpenSslEngine found for SSL pointer: {}", ssl);
             return false;

File: handler/src/test/java/io/netty/handler/ssl/Java8SslTestUtils.java
Patch:
@@ -23,17 +23,18 @@
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLParameters;
 import java.security.Provider;
+import java.util.Arrays;
 import java.util.Collections;
 
 final class Java8SslTestUtils {
 
     private Java8SslTestUtils() { }
 
-    static void setSNIMatcher(SSLParameters parameters) {
+    static void setSNIMatcher(SSLParameters parameters, final byte[] match) {
         SNIMatcher matcher = new SNIMatcher(0) {
             @Override
             public boolean matches(SNIServerName sniServerName) {
-                return false;
+                return Arrays.equals(match, sniServerName.getEncoded());
             }
         };
         parameters.setSNIMatchers(Collections.singleton(matcher));

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -301,7 +301,7 @@ public boolean awaitUninterruptibly(long timeoutMillis) {
     @Override
     public V getNow() {
         Object result = this.result;
-        if (result instanceof CauseHolder || result == SUCCESS) {
+        if (result instanceof CauseHolder || result == SUCCESS || result == UNCANCELLABLE) {
             return null;
         }
         return (V) result;

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -722,7 +722,7 @@ public int indexOf(char ch, int start) {
         }
 
         final byte chAsByte = c2b0(ch);
-        final int len = offset + start + length;
+        final int len = offset + length;
         for (int i = start + offset; i < len; ++i) {
             if (value[i] == chAsByte) {
                 return i - offset;

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -368,7 +368,7 @@ public Object run() {
     }
 
     static boolean isExplicitNoUnsafe() {
-        return EXPLICIT_NO_UNSAFE_CAUSE == null;
+        return EXPLICIT_NO_UNSAFE_CAUSE != null;
     }
 
     private static Throwable explicitNoUnsafeCause0() {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java
Patch:
@@ -770,7 +770,7 @@ public void canWriteDataFrameAfterGoAwayReceived() throws Exception {
     }
 
     @Test
-    public void canWriteHeaderFrameAfterGoAwayReceived() {
+    public void canWriteHeaderFrameAfterGoAwayReceived() throws Http2Exception {
         writeAllFlowControlledFrames();
         goAwayReceived(STREAM_ID);
         ChannelPromise promise = newPromise();
@@ -803,11 +803,11 @@ private Http2Stream stream(int streamId) {
         return connection.stream(streamId);
     }
 
-    private void goAwayReceived(int lastStreamId) {
+    private void goAwayReceived(int lastStreamId) throws Http2Exception {
         connection.goAwayReceived(lastStreamId, 0, EMPTY_BUFFER);
     }
 
-    private void goAwaySent(int lastStreamId) {
+    private void goAwaySent(int lastStreamId) throws Http2Exception {
         connection.goAwaySent(lastStreamId, 0, EMPTY_BUFFER);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
Patch:
@@ -222,7 +222,7 @@ public void alternatingWritesToActiveAndBufferedStreams() {
     }
 
     @Test
-    public void bufferingNewStreamFailsAfterGoAwayReceived() {
+    public void bufferingNewStreamFailsAfterGoAwayReceived() throws Http2Exception {
         encoder.writeSettingsAck(ctx, newPromise());
         setMaxConcurrentStreams(0);
         connection.goAwayReceived(1, 8, EMPTY_BUFFER);
@@ -235,7 +235,7 @@ public void bufferingNewStreamFailsAfterGoAwayReceived() {
     }
 
     @Test
-    public void receivingGoAwayFailsBufferedStreams() {
+    public void receivingGoAwayFailsBufferedStreams() throws Http2Exception {
         encoder.writeSettingsAck(ctx, newPromise());
         setMaxConcurrentStreams(5);
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -864,9 +864,9 @@ private void updateMaxStreams() {
         private void checkNewStreamAllowed(int streamId, State state) throws Http2Exception {
             assert state != IDLE;
             if (goAwayReceived() && streamId > localEndpoint.lastStreamKnownByPeer()) {
-                throw connectionError(PROTOCOL_ERROR, "Cannot create stream %d since this endpoint has received a " +
-                                                      "GOAWAY frame with last stream id %d.", streamId,
-                                                      localEndpoint.lastStreamKnownByPeer());
+                throw streamError(streamId, REFUSED_STREAM,
+                      "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",
+                      streamId, localEndpoint.lastStreamKnownByPeer());
             }
             if (!isValidStreamId(streamId)) {
                 if (streamId < 0) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -701,7 +701,9 @@ protected void onStreamError(ChannelHandlerContext ctx, boolean outbound,
         }
 
         if (stream == null) {
-            resetUnknownStream(ctx, streamId, http2Ex.error().code(), ctx.newPromise());
+            if (!outbound || connection().local().mayHaveCreatedStream(streamId)) {
+                resetUnknownStream(ctx, streamId, http2Ex.error().code(), ctx.newPromise());
+            }
         } else {
             resetStream(ctx, stream, http2Ex.error().code(), ctx.newPromise());
         }

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -158,7 +158,7 @@ public Random current() {
         } else {
             USE_DIRECT_BUFFER_NO_CLEANER = true;
             if (maxDirectMemory < 0) {
-                maxDirectMemory = maxDirectMemory0();
+                maxDirectMemory = MAX_DIRECT_MEMORY;
                 if (maxDirectMemory <= 0) {
                     DIRECT_MEMORY_COUNTER = null;
                 } else {

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
Patch:
@@ -240,8 +240,8 @@ protected WebSocketFrameEncoder newWebSocketEncoder() {
             }
         };
 
-        byte[] data = new byte[24];
-        PlatformDependent.threadLocalRandom().nextBytes(data);
+        // use randomBytes helper from utils to check that it functions properly
+        byte[] data = WebSocketUtil.randomBytes(24);
 
         // Create a EmbeddedChannel which we will use to encode a BinaryWebsocketFrame to bytes and so use these
         // to test the actual handshaker.

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieEncoder.java
Patch:
@@ -44,7 +44,8 @@ protected void validateCookie(String name, String value) {
             }
 
             if ((pos = firstInvalidCookieValueOctet(unwrappedValue)) >= 0) {
-                throw new IllegalArgumentException("Cookie value contains an invalid char: " + value.charAt(pos));
+                throw new IllegalArgumentException("Cookie value contains an invalid char: " +
+                                                   unwrappedValue.charAt(pos));
             }
         }
     }

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -238,7 +238,7 @@ public static ByteBuf wrappedBuffer(ByteBuf buffer) {
      * content will be visible to the returned buffer.
      */
     public static ByteBuf wrappedBuffer(byte[]... arrays) {
-        return wrappedBuffer(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, arrays);
+        return wrappedBuffer(arrays.length, arrays);
     }
 
     /**
@@ -249,7 +249,7 @@ public static ByteBuf wrappedBuffer(byte[]... arrays) {
      * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer.
      */
     public static ByteBuf wrappedBuffer(ByteBuf... buffers) {
-        return wrappedBuffer(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, buffers);
+        return wrappedBuffer(buffers.length, buffers);
     }
 
     /**
@@ -258,7 +258,7 @@ public static ByteBuf wrappedBuffer(ByteBuf... buffers) {
      * specified buffers will be visible to the returned buffer.
      */
     public static ByteBuf wrappedBuffer(ByteBuffer... buffers) {
-        return wrappedBuffer(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, buffers);
+        return wrappedBuffer(buffers.length, buffers);
     }
 
     /**

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -126,7 +126,7 @@ public B channelFactory(ChannelFactory<? extends C> channelFactory) {
      * {@link io.netty.channel.ChannelFactory} which is used to create {@link Channel} instances from
      * when calling {@link #bind()}. This method is usually only used if {@link #channel(Class)}
      * is not working for you because of some more complex needs. If your {@link Channel} implementation
-     * has a no-args constructor, its highly recommend to just use {@link #channel(Class)} for
+     * has a no-args constructor, its highly recommend to just use {@link #channel(Class)} to
      * simplify your code.
      */
     @SuppressWarnings({ "unchecked", "deprecation" })

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java
Patch:
@@ -39,7 +39,7 @@ protected AbstractEpollServerChannel(int fd) {
     }
 
     AbstractEpollServerChannel(LinuxSocket fd, boolean active) {
-        super(null, fd, Native.EPOLLIN, active);
+        super(null, fd, active);
     }
 
     @Override

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -99,19 +99,19 @@ protected AbstractEpollStreamChannel(int fd) {
     }
 
     AbstractEpollStreamChannel(Channel parent, LinuxSocket fd) {
-        super(parent, fd, Native.EPOLLIN, true);
+        super(parent, fd, true);
         // Add EPOLLRDHUP so we are notified once the remote peer close the connection.
         flags |= Native.EPOLLRDHUP;
     }
 
     AbstractEpollStreamChannel(Channel parent, LinuxSocket fd, SocketAddress remote) {
-        super(parent, fd, Native.EPOLLIN, remote);
+        super(parent, fd, remote);
         // Add EPOLLRDHUP so we are notified once the remote peer close the connection.
         flags |= Native.EPOLLRDHUP;
     }
 
     protected AbstractEpollStreamChannel(LinuxSocket fd, boolean active) {
-        super(null, fd, Native.EPOLLIN, active);
+        super(null, fd, active);
         // Add EPOLLRDHUP so we are notified once the remote peer close the connection.
         flags |= Native.EPOLLRDHUP;
     }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -59,7 +59,7 @@ public final class EpollDatagramChannel extends AbstractEpollChannel implements
     private volatile boolean connected;
 
     public EpollDatagramChannel() {
-        super(newSocketDgram(), Native.EPOLLIN);
+        super(newSocketDgram());
         config = new EpollDatagramChannelConfig(this);
     }
 
@@ -68,7 +68,7 @@ public EpollDatagramChannel(int fd) {
     }
 
     EpollDatagramChannel(LinuxSocket fd) {
-        super(null, fd, Native.EPOLLIN, true);
+        super(null, fd, true);
         config = new EpollDatagramChannelConfig(this);
     }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
Patch:
@@ -84,11 +84,11 @@ protected UnpooledHeapByteBuf(ByteBufAllocator alloc, byte[] initialArray, int m
         setIndex(0, initialArray.length);
     }
 
-    byte[] allocateArray(int initialCapacity) {
+    protected byte[] allocateArray(int initialCapacity) {
         return new byte[initialCapacity];
     }
 
-    void freeArray(byte[] array) {
+    protected void freeArray(byte[] array) {
         // NOOP
     }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java
Patch:
@@ -30,7 +30,7 @@ class UnpooledUnsafeHeapByteBuf extends UnpooledHeapByteBuf {
     }
 
     @Override
-    byte[] allocateArray(int initialCapacity) {
+    protected byte[] allocateArray(int initialCapacity) {
         return PlatformDependent.allocateUninitializedArray(initialCapacity);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -143,7 +143,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {
 
     private static final InternalLogger LOG = InternalLoggerFactory.getInstance(Http2FrameCodec.class);
 
-    private final PropertyKey streamKey;
+    protected final PropertyKey streamKey;
     private final PropertyKey upgradeKey;
 
     private final Integer initialFlowControlWindowSize;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
Patch:
@@ -670,7 +670,7 @@ public TestableHttp2MultiplexCodec(Http2ConnectionEncoder encoder,
                                            Http2ConnectionDecoder decoder,
                                            Http2Settings initialSettings,
                                            ChannelHandler inboundStreamHandler) {
-            super(encoder, decoder, initialSettings, inboundStreamHandler);
+            super(encoder, decoder, initialSettings, inboundStreamHandler, null);
         }
 
         void onHttp2Frame(Http2Frame frame) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -83,7 +83,8 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
         ByteBuf buf = null;
         if (msg instanceof HttpMessage) {
             if (state != ST_INIT) {
-                throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
+                throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg)
+                        + ", state: " + state);
             }
 
             @SuppressWarnings({ "unchecked", "CastConflictsWithInstanceof" })

File: codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java
Patch:
@@ -77,7 +77,7 @@ public CharSequence convertByte(byte value) {
 
     @Override
     public byte convertToByte(CharSequence value) {
-        if (value instanceof AsciiString) {
+        if (value instanceof AsciiString && value.length() == 1) {
             return ((AsciiString) value).byteAt(0);
         }
         return Byte.parseByte(value.toString());

File: common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
Patch:
@@ -35,7 +35,9 @@ static long nanoTime() {
     }
 
     static long deadlineNanos(long delay) {
-        return nanoTime() + delay;
+        long deadlineNanos = nanoTime() + delay;
+        // Guard against overflow
+        return deadlineNanos < 0 ? Long.MAX_VALUE : deadlineNanos;
     }
 
     private final long id = nextTaskId.getAndIncrement();

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -99,12 +99,9 @@ public static <T> ChannelOption<T> newInstance(String name) {
     public static final ChannelOption<Boolean> AUTO_READ = valueOf("AUTO_READ");
 
     /**
-     * @deprecated  Auto close will be removed in a future release.
-     *
      * If {@code true} then the {@link Channel} is closed automatically and immediately on write failure.
      * The default value is {@code true}.
      */
-    @Deprecated
     public static final ChannelOption<Boolean> AUTO_CLOSE = valueOf("AUTO_CLOSE");
 
     public static final ChannelOption<Boolean> SO_BROADCAST = valueOf("SO_BROADCAST");

File: transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java
Patch:
@@ -394,7 +394,8 @@ public void close() {
             if (channel == null) {
                 break;
             }
-            channel.close();
+            // Just ignore any errors that are reported back from close().
+            channel.close().awaitUninterruptibly();
         }
     }
 }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackEncoderTest.java
Patch:
@@ -74,7 +74,7 @@ public void testWillEncode16MBHeaderByDefault() throws Http2Exception {
 
         try {
             hpackEncoder.encodeHeaders(0, buf, headersIn, Http2HeadersEncoder.NEVER_SENSITIVE);
-            hpackDecoder.setMaxHeaderListSize(bigHeaderSize + 1024, bigHeaderSize + 1024);
+            hpackDecoder.setMaxHeaderListSize(bigHeaderSize + 1024);
             hpackDecoder.decode(0, buf, headersOut, false);
         } finally {
             buf.release();

File: handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java
Patch:
@@ -416,7 +416,7 @@ public boolean release() {
 
     @Override
     public boolean release(int decrement) {
-        return getWrappedEngine().release();
+        return getWrappedEngine().release(decrement);
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/CodecOutputList.java
Patch:
@@ -148,7 +148,7 @@ public void add(int index, Object element) {
             expandArray();
         }
 
-        if (index != size - 1) {
+        if (index != size) {
             System.arraycopy(array, index, array, index + 1, size - index);
         }
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslClientRenegotiateTest.java
Patch:
@@ -162,7 +162,7 @@ public void initChannel(Channel sch) throws Exception {
         Future<Channel> clientHandshakeFuture = clientSslHandler.handshakeFuture();
         clientHandshakeFuture.sync();
 
-        String renegotiation = "SSL_RSA_WITH_3DES_EDE_CBC_SHA";
+        String renegotiation = clientSslHandler.engine().getSupportedCipherSuites()[0];
         clientSslHandler.engine().setEnabledCipherSuites(new String[] { renegotiation });
         clientSslHandler.renegotiate().await();
         serverChannel.close().awaitUninterruptibly();

File: resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
Patch:
@@ -65,8 +65,8 @@ public DefaultDnsCache() {
      * @param negativeTtl the TTL for failed queries
      */
     public DefaultDnsCache(int minTtl, int maxTtl, int negativeTtl) {
-        this.minTtl = checkPositiveOrZero(minTtl, "minTtl");
-        this.maxTtl = checkPositiveOrZero(maxTtl, "maxTtl");
+        this.minTtl = Math.min(MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(minTtl, "minTtl"));
+        this.maxTtl = Math.min(MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(maxTtl, "maxTtl"));
         if (minTtl > maxTtl) {
             throw new IllegalArgumentException(
                     "minTtl: " + minTtl + ", maxTtl: " + maxTtl + " (expected: 0 <= minTtl <= maxTtl)");

File: buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
Patch:
@@ -97,7 +97,7 @@ private boolean release0(int decrement) {
         } else if (oldRef < decrement || oldRef - decrement > oldRef) {
             // Ensure we don't over-release, and avoid underflow.
             refCntUpdater.getAndAdd(this, decrement);
-            throw new IllegalReferenceCountException(oldRef, decrement);
+            throw new IllegalReferenceCountException(oldRef, -decrement);
         }
         return false;
     }

File: common/src/main/java/io/netty/util/AbstractReferenceCounted.java
Patch:
@@ -84,7 +84,7 @@ private boolean release0(int decrement) {
         } else if (oldRef < decrement || oldRef - decrement > oldRef) {
             // Ensure we don't over-release, and avoid underflow.
             refCntUpdater.getAndAdd(this, decrement);
-            throw new IllegalReferenceCountException(oldRef, decrement);
+            throw new IllegalReferenceCountException(oldRef, -decrement);
         }
         return false;
     }

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -43,10 +43,10 @@ public class FixedChannelPool extends SimpleChannelPool {
             new TimeoutException("Acquire operation took longer then configured maximum time"),
             FixedChannelPool.class, "<init>(...)");
     static final IllegalStateException POOL_CLOSED_ON_RELEASE_EXCEPTION = ThrowableUtil.unknownStackTrace(
-            new IllegalStateException("FixedChannelPooled was closed"),
+            new IllegalStateException("FixedChannelPool was closed"),
             FixedChannelPool.class, "release(...)");
     static final IllegalStateException POOL_CLOSED_ON_ACQUIRE_EXCEPTION = ThrowableUtil.unknownStackTrace(
-            new IllegalStateException("FixedChannelPooled was closed"),
+            new IllegalStateException("FixedChannelPool was closed"),
             FixedChannelPool.class, "acquire0(...)");
     public enum AcquireTimeoutAction {
         /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -315,8 +315,9 @@ private void increaseInitialConnectionWindow(int deltaBytes) throws Http2Excepti
 
     final boolean consumeBytes(int streamId, int bytes) throws Http2Exception {
         Http2Stream stream = connection().stream(streamId);
-        // upgraded requests are ineligible for stream control
-        if (streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {
+        // Upgraded requests are ineligible for stream control. We add the null check
+        // in case the stream has been deregistered.
+        if (stream != null && streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {
             Boolean upgraded = stream.getProperty(upgradeKey);
             if (Boolean.TRUE.equals(upgraded)) {
                 return false;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -337,9 +337,6 @@ public boolean visit(Http2FrameStream stream) {
         } catch (Http2Exception e) {
             ctx.fireExceptionCaught(e);
             ctx.close();
-        } finally {
-            // We need to ensure we release the goAwayFrame.
-            goAwayFrame.release();
         }
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
Patch:
@@ -31,6 +31,7 @@ public final class EpollChannelOption<T> extends UnixChannelOption<T> {
             valueOf(EpollChannelOption.class, "TCP_USER_TIMEOUT");
     public static final ChannelOption<Boolean> IP_FREEBIND = valueOf("IP_FREEBIND");
     public static final ChannelOption<Boolean> IP_TRANSPARENT = valueOf("IP_TRANSPARENT");
+    public static final ChannelOption<Boolean> IP_RECVORIGDSTADDR = valueOf("IP_RECVORIGDSTADDR");
     public static final ChannelOption<Integer> TCP_FASTOPEN = valueOf(EpollChannelOption.class, "TCP_FASTOPEN");
     public static final ChannelOption<Boolean> TCP_FASTOPEN_CONNECT =
             valueOf(EpollChannelOption.class, "TCP_FASTOPEN_CONNECT");

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java
Patch:
@@ -76,9 +76,9 @@ public boolean remoteSideOpen() {
      * <ul>
      * <li>{@link State#OPEN} if {@link #state()} is {@link State#IDLE} and {@code halfClosed} is {@code false}.</li>
      * <li>{@link State#HALF_CLOSED_LOCAL} if {@link #state()} is {@link State#IDLE} and {@code halfClosed}
-     * is {@code true} and the stream is local.</li>
+     * is {@code true} and the stream is local. In this state, {@link #isHeadersSent()} is {@code true}</li>
      * <li>{@link State#HALF_CLOSED_REMOTE} if {@link #state()} is {@link State#IDLE} and {@code halfClosed}
-     * is {@code true} and the stream is remote.</li>
+     * is {@code true} and the stream is remote. In this state, {@link #isHeadersReceived()} is {@code true}</li>
      * <li>{@link State#RESERVED_LOCAL} if {@link #state()} is {@link State#HALF_CLOSED_REMOTE}.</li>
      * <li>{@link State#RESERVED_REMOTE} if {@link #state()} is {@link State#HALF_CLOSED_LOCAL}.</li>
      * </ul>

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java
Patch:
@@ -294,12 +294,14 @@ public void clientCreateStreamShouldSucceed() throws Http2Exception {
         assertEquals(State.HALF_CLOSED_REMOTE, stream.state());
         assertEquals(2, client.numActiveStreams());
         assertEquals(4, client.remote().lastStreamCreated());
+        assertTrue(stream.isHeadersReceived());
 
         stream = client.local().createStream(3, true);
         assertEquals(3, stream.id());
         assertEquals(State.HALF_CLOSED_LOCAL, stream.state());
         assertEquals(3, client.numActiveStreams());
         assertEquals(3, client.local().lastStreamCreated());
+        assertTrue(stream.isHeadersSent());
 
         stream = client.local().createStream(5, false);
         assertEquals(5, stream.id());

File: resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java
Patch:
@@ -258,7 +258,7 @@ private static String nextIp6() {
 
         private final Set<String> domains;
 
-        public TestRecordStore(Set<String> domains) {
+        private TestRecordStore(Set<String> domains) {
             this.domains = domains;
         }
 

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -261,7 +261,7 @@ public void run() {
                 Link head = link;
                 while (head != null) {
                     reclaimSpace(LINK_CAPACITY);
-                    head = link.next;
+                    head = head.next;
                 }
             }
 

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -436,7 +436,9 @@ private void finishPeerRead0(LocalChannel peer) {
             }
         }
         ChannelPipeline peerPipeline = peer.pipeline();
-        if (peer.readInProgress) {
+        // We should only set readInProgress to false if there is any data that was read as otherwise we may miss to
+        // forward data later on.
+        if (peer.readInProgress && !peer.inboundBuffer.isEmpty()) {
             peer.readInProgress = false;
             for (;;) {
                 Object received = peer.inboundBuffer.poll();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
Patch:
@@ -41,7 +41,6 @@
 import java.util.Map;
 
 import static io.netty.handler.codec.http2.HpackUtil.equalsConstantTime;
-import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_TABLE_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;
@@ -86,7 +85,7 @@ public HpackEncoder(boolean ignoreMaxHeaderListSize) {
     public HpackEncoder(boolean ignoreMaxHeaderListSize, int arraySizeHint) {
         this.ignoreMaxHeaderListSize = ignoreMaxHeaderListSize;
         maxHeaderTableSize = DEFAULT_HEADER_TABLE_SIZE;
-        maxHeaderListSize = DEFAULT_HEADER_LIST_SIZE;
+        maxHeaderListSize = MAX_HEADER_LIST_SIZE;
         // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less
         // than the length of this array, and we want the mask to be > 0.
         headerFields = new HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -168,7 +168,7 @@ public static int hashCode(ByteBuf buffer) {
         final int intCount = aLen >>> 2;
         final int byteCount = aLen & 3;
 
-        int hashCode = 1;
+        int hashCode = EmptyByteBuf.EMPTY_BYTE_BUF_HASH_CODE;
         int arrayIndex = buffer.readerIndex();
         if (buffer.order() == ByteOrder.BIG_ENDIAN) {
             for (int i = intCount; i > 0; i --) {

File: buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
Patch:
@@ -36,6 +36,7 @@
  */
 public final class EmptyByteBuf extends ByteBuf {
 
+    static final int EMPTY_BYTE_BUF_HASH_CODE = 1;
     private static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.allocateDirect(0);
     private static final long EMPTY_BYTE_BUFFER_ADDRESS;
 
@@ -976,7 +977,7 @@ public String toString(int index, int length, Charset charset) {
 
     @Override
     public int hashCode() {
-        return 0;
+        return EMPTY_BYTE_BUF_HASH_CODE;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
Patch:
@@ -38,6 +38,7 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.OK;
 import static io.netty.util.ReferenceCountUtil.release;
 import static io.netty.util.internal.ObjectUtil.checkNonEmpty;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * Handles <a href="http://www.w3.org/TR/cors/">Cross Origin Resource Sharing</a> (CORS) requests.
@@ -60,7 +61,7 @@ public class CorsHandler extends ChannelDuplexHandler {
      * Creates a new instance with a single {@link CorsConfig}.
      */
     public CorsHandler(final CorsConfig config) {
-        this(Collections.singletonList(config), config.isShortCircuit());
+        this(Collections.singletonList(checkNotNull(config, "config")), config.isShortCircuit());
     }
 
     /**
@@ -137,7 +138,7 @@ private CorsConfig getForOrigin(String requestOrigin) {
 
     private boolean setOrigin(final HttpResponse response) {
         final String origin = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (origin != null) {
+        if (origin != null && config != null) {
             if (NULL_ORIGIN.equals(origin) && config.isNullOriginAllowed()) {
                 setNullOrigin(response);
                 return true;

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -688,7 +688,7 @@ public int indexOf(CharSequence subString, int start) {
             return INDEX_NOT_FOUND;
         }
         final byte firstCharAsByte = c2b0(firstChar);
-        final int len = offset + start + length - subCount;
+        final int len = offset + length - subCount;
         for (int i = start + offset; i <= len; ++i) {
             if (value[i] == firstCharAsByte) {
                 int o1 = i, o2 = 0;
@@ -773,7 +773,7 @@ public int lastIndexOf(CharSequence subString, int start) {
         }
         final byte firstCharAsByte = c2b0(firstChar);
         final int end = offset + start;
-        for (int i = offset + start + length - subCount; i >= end; --i) {
+        for (int i = offset + length - subCount; i >= end; --i) {
             if (value[i] == firstCharAsByte) {
                 int o1 = i, o2 = 0;
                 while (++o2 < subCount && b2c(value[++o1]) == subString.charAt(o2)) {

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java
Patch:
@@ -140,7 +140,7 @@ public Cookie decode(String header) {
                 cookieBuilder.appendAttribute(nameBegin, nameEnd, valueBegin, valueEnd);
             }
         }
-        return cookieBuilder.cookie();
+        return cookieBuilder != null ? cookieBuilder.cookie() : null;
     }
 
     private static class CookieBuilder {

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -1192,6 +1192,7 @@ public ByteBuf retainedSlice() {
 
     @Override
     public ByteBuf slice(int index, int length) {
+        ensureAccessible();
         return new UnpooledSlicedByteBuf(this, index, length);
     }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
@@ -113,7 +114,6 @@ public boolean isDirect() {
 
     @Override
     public int capacity() {
-        ensureAccessible();
         return array.length;
     }
 
@@ -552,7 +552,7 @@ private ByteBuffer internalNioBuffer() {
     @Override
     protected void deallocate() {
         freeArray(array);
-        array = null;
+        array = EmptyArrays.EMPTY_BYTES;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
Patch:
@@ -205,7 +205,7 @@ public void write(final ChannelHandlerContext ctx, final Object msg, final Chann
                 setExposeHeaders(response);
             }
         }
-        ctx.writeAndFlush(msg, promise);
+        ctx.write(msg, promise);
     }
 
     private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java
Patch:
@@ -277,6 +277,6 @@ private void setUpgradeRequestHeaders(ChannelHandlerContext ctx, HttpRequest req
             builder.append(',');
         }
         builder.append(HttpHeaderValues.UPGRADE);
-        request.headers().set(HttpHeaderNames.CONNECTION, builder.toString());
+        request.headers().add(HttpHeaderNames.CONNECTION, builder.toString());
     }
 }

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -299,8 +299,8 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 ctx.flush();
                 requiresFlush = false;
             } else {
-                ctx.write(pendingMessage, currentWrite.promise);
                 this.currentWrite = null;
+                ctx.write(pendingMessage, currentWrite.promise);
                 requiresFlush = true;
             }
 

File: codec-redis/src/main/java/io/netty/handler/codec/redis/RedisConstants.java
Patch:
@@ -33,6 +33,9 @@ private RedisConstants() {
 
     static final int REDIS_MESSAGE_MAX_LENGTH = 512 * 1024 * 1024; // 512MB
 
+    // 64KB is max inline length of current Redis server implementation.
+    static final int REDIS_INLINE_MESSAGE_MAX_LENGTH = 64 * 1024;
+
     static final int POSITIVE_LONG_MAX_LENGTH = 19; // length of Long.MAX_VALUE
 
     static final int LONG_MAX_LENGTH = POSITIVE_LONG_MAX_LENGTH + 1; // +1 is sign

File: codec/src/main/java/io/netty/handler/codec/EmptyHeaders.java
Patch:
@@ -30,7 +30,7 @@ public V get(K name) {
 
     @Override
     public V get(K name, V defaultValue) {
-        return null;
+        return defaultValue;
     }
 
     @Override
@@ -40,7 +40,7 @@ public V getAndRemove(K name) {
 
     @Override
     public V getAndRemove(K name, V defaultValue) {
-        return null;
+        return defaultValue;
     }
 
     @Override

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -369,7 +369,8 @@ private static final class DefaultResourceLeak<T>
             // be collected via the WeakReference.
             trackedHash = System.identityHashCode(referent);
             allLeaks.put(this, LeakEntry.INSTANCE);
-            headUpdater.set(this, Record.BOTTOM);
+            // Create a new Record so we always have the creation stacktrace included.
+            headUpdater.set(this, new Record(Record.BOTTOM));
             this.allLeaks = allLeaks;
         }
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
Patch:
@@ -219,7 +219,7 @@ public final void channelActive(ChannelHandlerContext ctx) throws Exception {
             if (!autoRead) {
                 ctx.read();
             }
-            super.channelInactive(ctx);
+            super.channelActive(ctx);
         }
 
         @Override

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
Patch:
@@ -28,11 +28,9 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.spdy.SpdyFrameCodec;
 import io.netty.handler.codec.spdy.SpdyVersion;
-import io.netty.util.NetUtil;
 import org.junit.Test;
 
 import java.io.IOException;
-import java.net.InetSocketAddress;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -195,7 +193,6 @@ public void initChannel(SocketChannel channel) throws Exception {
         cb.handler(ch);
 
         Channel sc = sb.bind().sync().channel();
-        int port = ((InetSocketAddress) sc.localAddress()).getPort();
 
         Channel cc = cb.connect(sc.localAddress()).sync().channel();
         cc.writeAndFlush(frames);

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -356,10 +356,9 @@ protected final void flush0() {
             // Flush immediately only when there's no pending flush.
             // If there's a pending flush operation, event loop will call forceFlush() later,
             // and thus there's no need to call it now.
-            if (isFlushPending()) {
-                return;
+            if (!isFlushPending()) {
+                super.flush0();
             }
-            super.flush0();
         }
 
         @Override

File: handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java
Patch:
@@ -81,7 +81,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                                         "not an SSL/TLS record: " + ByteBufUtil.hexDump(in));
                                 in.skipBytes(in.readableBytes());
                                 ctx.fireUserEventTriggered(new SniCompletionEvent(e));
-                                SslUtils.notifyHandshakeFailure(ctx, e, true);
+                                SslUtils.handleHandshakeFailure(ctx, e, true);
                                 throw e;
                             }
                             if (len == SslUtils.NOT_ENOUGH_DATA ||

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -310,7 +310,7 @@ private static int getEncryptedPacketLength(ByteBuffer buffer) {
         return packetLength;
     }
 
-    static void notifyHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean notify) {
+    static void handleHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean notify) {
         // We have may haven written some parts of data before an exception was thrown so ensure we always flush.
         // See https://github.com/netty/netty/issues/3900#issuecomment-172481830
         ctx.flush();

File: codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java
Patch:
@@ -48,7 +48,7 @@ public enum Type {
         OTHER;
 
         /**
-         * Returns the the {@link Type} for a specific byte value as defined in the PROXY protocol 1.5 spec
+         * Returns the {@link Type} for a specific byte value as defined in the PROXY protocol 1.5 spec
          * <p>
          * If the byte value is not an official one, it will return {@link Type#OTHER}.
          *

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -136,7 +136,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                 }
 
                 if (isFull) {
-                    // Pass through the full response with empty content and continue waiting for the the next resp.
+                    // Pass through the full response with empty content and continue waiting for the next resp.
                     if (!((ByteBufHolder) res).content().isReadable()) {
                         out.add(ReferenceCountUtil.retain(res));
                         break;

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
Patch:
@@ -99,7 +99,7 @@ public static CorsConfigBuilder forOrigins(final String... origins) {
     /**
      * Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
      * from the local file system. Calling this method will enable a successful CORS response
-     * with a {@code "null"} value for the the CORS response header 'Access-Control-Allow-Origin'.
+     * with a {@code "null"} value for the CORS response header 'Access-Control-Allow-Origin'.
      *
      * @return {@link CorsConfigBuilder} to support method chaining.
      */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -123,7 +123,7 @@ public Http2Headers decodeHeaders(int streamId, ByteBuf headerBlock) throws Http
             throw e;
         } catch (Throwable e) {
             // Default handler for any other types of errors that may have occurred. For example,
-            // the the Header builder throws IllegalArgumentException if the key or value was invalid
+            // the Header builder throws IllegalArgumentException if the key or value was invalid
             // for any reason (e.g. the key was an invalid pseudo-header).
             throw connectionError(COMPRESSION_ERROR, e, e.getMessage());
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -456,7 +456,7 @@ public boolean hasFrame() {
         }
 
         /**
-         * Returns the the head of the pending queue, or {@code null} if empty.
+         * Returns the head of the pending queue, or {@code null} if empty.
          */
         private FlowControlled peek() {
             return pendingWriteQueue.peek();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackHuffmanDecoder.java
Patch:
@@ -168,8 +168,8 @@ void reset() {
          * currentBits represents how many of the low order bits of current are actually valid.
          * currentBits will vary between 0 and 15.
          *
-         * symbolBits is the number of bits of the the symbol being decoded, *including* all those
-         * of the parent nodes. symbolBits tells how far down the tree we are. For example, when
+         * symbolBits is the number of bits of the symbol being decoded, *including* all those of
+         * the parent nodes. symbolBits tells how far down the tree we are. For example, when
          * decoding the invalid sequence {0xff, 0xff}, currentBits will be 0, but symbolBits will be
          * 16. This is used to know if buf ended early (before consuming a whole symbol) or if
          * there is too much padding.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -162,7 +162,7 @@ public static boolean isMaxFrameSizeValid(int maxFrameSize) {
     }
 
     /**
-     * Returns a buffer containing the the {@link #CONNECTION_PREFACE}.
+     * Returns a buffer containing the {@link #CONNECTION_PREFACE}.
      */
     public static ByteBuf connectionPrefaceBuf() {
         // Return a duplicate so that modifications to the reader index will not affect the original buffer.

File: codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
Patch:
@@ -44,7 +44,7 @@ public class CompatibleMarshallingDecoder extends ReplayingDecoder<Void> {
      *        for the {@link Channel}
      * @param maxObjectSize
      *        the maximal size (in bytes) of the {@link Object} to unmarshal. Once the size is
-     *        exceeded the {@link Channel} will get closed. Use a a maxObjectSize of
+     *        exceeded the {@link Channel} will get closed. Use a maxObjectSize of
      *        {@link Integer#MAX_VALUE} to disable this.  You should only do this if you are sure
      *        that the received Objects will never be big and the sending side are trusted, as this
      *        opens the possibility for a DOS-Attack due an {@link OutOfMemoryError}.

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
Patch:
@@ -23,7 +23,7 @@
 import io.netty.handler.codec.MessageToByteEncoder;
 
 /**
- * An encoder that prepends the the Google Protocol Buffers
+ * An encoder that prepends the Google Protocol Buffers
  * <a href="https://developers.google.com/protocol-buffers/docs/encoding?csw=1#varints">Base
  * 128 Varints</a> integer length field. For example:
  * <pre>

File: common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
Patch:
@@ -96,7 +96,7 @@ protected final Runnable pollScheduledTask() {
 
     /**
      * Return the {@link Runnable} which is ready to be executed with the given {@code nanoTime}.
-     * You should use {@link #nanoTime()} to retrieve the the correct {@code nanoTime}.
+     * You should use {@link #nanoTime()} to retrieve the correct {@code nanoTime}.
      */
     protected final Runnable pollScheduledTask(long nanoTime) {
         assert inEventLoop();

File: resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
Patch:
@@ -195,7 +195,7 @@ public void testMultipleSearchDomain() throws Exception {
         resolved = assertResolve(resolver, "host2");
         assertEquals(store.getAddress("host2.bar.com"), resolved);
 
-        // "host3" resolves via the the "foo.com" search path as it is the first one
+        // "host3" resolves via the "foo.com" search path as it is the first one
         resolved = assertResolve(resolver, "host3");
         assertEquals(store.getAddress("host3.foo.com"), resolved);
 

File: transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
Patch:
@@ -97,7 +97,7 @@ public long writeCounter() {
 
     /**
      * Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and
-     * their pendingDatasize is smaller after the the current writeCounter returned by {@link #writeCounter()}.
+     * their pendingDatasize is smaller after the current writeCounter returned by {@link #writeCounter()}.
      *
      * After a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and
      * so not receive anymore notification.

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.util.concurrent;
 
-import io.netty.util.Signal;
 import io.netty.util.internal.InternalThreadLocalMap;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
@@ -40,8 +39,8 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
     @SuppressWarnings("rawtypes")
     private static final AtomicReferenceFieldUpdater<DefaultPromise, Object> RESULT_UPDATER =
             AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class, Object.class, "result");
-    private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, "SUCCESS");
-    private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, "UNCANCELLABLE");
+    private static final Object SUCCESS = new Object();
+    private static final Object UNCANCELLABLE = new Object();
     private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(ThrowableUtil.unknownStackTrace(
             new CancellationException(), DefaultPromise.class, "cancel(...)"));
 

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -85,7 +85,7 @@ protected CharBuffer initialValue() throws Exception {
 
         DEFAULT_ALLOCATOR = alloc;
 
-        THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 64 * 1024);
+        THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 0);
         logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", THREAD_LOCAL_BUFFER_SIZE);
 
         MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.maxThreadLocalCharBufferSize", 16 * 1024);

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -49,7 +49,7 @@ public void recycle(Object object) {
     };
     private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);
     private static final int OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();
-    private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 32768; // Use 32k instances as default.
+    private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 4 * 1024; // Use 4k instances as default.
     private static final int DEFAULT_MAX_CAPACITY_PER_THREAD;
     private static final int INITIAL_CAPACITY;
     private static final int MAX_SHARED_CAPACITY_FACTOR;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java
Patch:
@@ -76,7 +76,7 @@ public ChannelFuture writeSettingsAck(ChannelHandlerContext ctx, ChannelPromise
     }
 
     @Override
-    public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, ByteBuf data, ChannelPromise promise) {
+    public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {
         return delegate.writePing(ctx, ack, data, promise);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -272,7 +272,7 @@ public ChannelFuture writeSettingsAck(ChannelHandlerContext ctx, ChannelPromise
     }
 
     @Override
-    public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, ByteBuf data, ChannelPromise promise) {
+    public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {
         return frameWriter.writePing(ctx, ack, data, promise);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -266,7 +266,7 @@ private void processPayloadState(ChannelHandlerContext ctx, ByteBuf in, Http2Fra
                 readPushPromiseFrame(ctx, payload, listener);
                 break;
             case PING:
-                readPingFrame(ctx, payload, listener);
+                readPingFrame(ctx, payload.readLong(), listener);
                 break;
             case GO_AWAY:
                 readGoAwayFrame(ctx, payload, listener);
@@ -574,9 +574,8 @@ public void processFragment(boolean endOfHeaders, ByteBuf fragment,
         resetHeadersContinuationIfEnd(flags.endOfHeaders());
     }
 
-    private void readPingFrame(ChannelHandlerContext ctx, ByteBuf payload,
+    private void readPingFrame(ChannelHandlerContext ctx, long data,
             Http2FrameListener listener) throws Http2Exception {
-        ByteBuf data = payload.readSlice(payload.readableBytes());
         if (flags.ack()) {
             listener.onPingAckRead(ctx, data);
         } else {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java
Patch:
@@ -58,11 +58,11 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) th
     }
 
     @Override
-    public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+    public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
     }
 
     @Override
-    public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+    public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameAdapter.java
Patch:
@@ -61,11 +61,11 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings)
     }
 
     @Override
-    public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+    public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
     }
 
     @Override
-    public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+    public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java
Patch:
@@ -70,12 +70,12 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) th
     }
 
     @Override
-    public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+    public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
         listener.onPingRead(ctx, data);
     }
 
     @Override
-    public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+    public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
         listener.onPingAckRead(ctx, data);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java
Patch:
@@ -147,11 +147,11 @@ ChannelFuture writeSettings(ChannelHandlerContext ctx, Http2Settings settings,
      * @param ctx the context to use for writing.
      * @param ack indicates whether this is an ack of a PING frame previously received from the
      *            remote endpoint.
-     * @param data the payload of the frame. This will be released by this method.
+     * @param data the payload of the frame.
      * @param promise the promise for the write.
      * @return the future for the write.
      */
-    ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, ByteBuf data,
+    ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, long data,
             ChannelPromise promise);
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java
Patch:
@@ -94,13 +94,13 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings)
             }
 
             @Override
-            public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+            public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
                 logger.logPing(INBOUND, ctx, data);
                 listener.onPingRead(ctx, data);
             }
 
             @Override
-            public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+            public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
                 logger.logPingAck(INBOUND, ctx, data);
                 listener.onPingAckRead(ctx, data);
             }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
Patch:
@@ -90,7 +90,7 @@ public ChannelFuture writeSettingsAck(ChannelHandlerContext ctx, ChannelPromise
 
     @Override
     public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack,
-            ByteBuf data, ChannelPromise promise) {
+            long data, ChannelPromise promise) {
         if (ack) {
             logger.logPingAck(OUTBOUND, ctx, data);
         } else {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
Patch:
@@ -175,13 +175,11 @@ public void inboundDataFrameShouldEmitWindowUpdateFrame() {
 
     @Test
     public void unhandledHttp2FramesShouldBePropagated() {
-        ByteBuf content = UnpooledByteBufAllocator.DEFAULT.buffer(8).writeLong(0);
-        Http2PingFrame decodedFrame = new DefaultHttp2PingFrame(content);
+        Http2PingFrame decodedFrame = new DefaultHttp2PingFrame(0);
 
         codec.onHttp2Frame(decodedFrame);
         Http2PingFrame receivedPing = parentChannel.readInbound();
         assertSame(receivedPing, decodedFrame);
-        assertTrue(receivedPing.release());
     }
 
     @Test

File: example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp2Handler.java
Patch:
@@ -138,11 +138,11 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) {
     }
 
     @Override
-    public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) {
+    public void onPingRead(ChannelHandlerContext ctx, long data) {
     }
 
     @Override
-    public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) {
+    public void onPingAckRead(ChannelHandlerContext ctx, long data) {
     }
 
     @Override

File: testsuite-http2/src/main/java/io/netty/testsuite/http2/HelloWorldHttp2Handler.java
Patch:
@@ -138,11 +138,11 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) {
     }
 
     @Override
-    public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) {
+    public void onPingRead(ChannelHandlerContext ctx, long data) {
     }
 
     @Override
-    public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) {
+    public void onPingAckRead(ChannelHandlerContext ctx, long data) {
     }
 
     @Override

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -750,7 +750,7 @@ static String decodeDomainName(ByteBuf in) {
 
     private DnsServerAddressStream getNameServers(String hostname) {
         DnsServerAddressStream stream = getNameServersFromCache(hostname);
-        return stream == null ? nameServerAddrs : stream;
+        return stream == null ? nameServerAddrs.duplicate() : stream;
     }
 
     private void followCname(String cname, final DnsQueryLifecycleObserver queryLifecycleObserver, Promise<T> promise) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java
Patch:
@@ -719,7 +719,7 @@ public void upgradeEventNoRefCntError() throws Exception {
                 UpgradeEvent.class.getDeclaredConstructor(CharSequence.class, FullHttpRequest.class);
 
         // Check if we could make it accessible which may fail on java9.
-        Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor) == null);
+        Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor, true) == null);
 
         HttpServerUpgradeHandler.UpgradeEvent upgradeEvent = constructor.newInstance(
                 "HTTP/2", new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
@@ -757,7 +757,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 UpgradeEvent.class.getDeclaredConstructor(CharSequence.class, FullHttpRequest.class);
 
         // Check if we could make it accessible which may fail on java9.
-        Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor) == null);
+        Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor, true) == null);
 
         String longString = new String(new char[70000]).replace("\0", "*");
         DefaultFullHttpRequest request =

File: common/src/test/java/io/netty/util/internal/logging/Log4J2LoggerTest.java
Patch:
@@ -67,7 +67,7 @@ private static <T> T getFieldValue(Class<?> clazz, String fieldName) {
         try {
             Field field = clazz.getDeclaredField(fieldName);
             if (!field.isAccessible()) {
-                Assume.assumeThat(ReflectionUtil.trySetAccessible(field), CoreMatchers.nullValue());
+                Assume.assumeThat(ReflectionUtil.trySetAccessible(field, true), CoreMatchers.nullValue());
             }
             return (T) field.get(AbstractInternalLogger.class);
         } catch (ReflectiveOperationException e) {
@@ -87,7 +87,7 @@ protected void setLevelEnable(InternalLogLevel level, boolean enable) throws Exc
 
         Method method = mockLog.getClass().getDeclaredMethod("setLevel", Level.class);
         if (!method.isAccessible()) {
-            Assume.assumeThat(ReflectionUtil.trySetAccessible(method), CoreMatchers.nullValue());
+            Assume.assumeThat(ReflectionUtil.trySetAccessible(method, true), CoreMatchers.nullValue());
         }
         method.invoke(mockLog, targetLevel);
     }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -214,11 +214,11 @@ public Object run() {
                     Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");
                     Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");
 
-                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField);
+                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, true);
                     if (cause != null) {
                         return cause;
                     }
-                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField);
+                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);
                     if (cause != null) {
                         return cause;
                     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -115,7 +115,7 @@ public Configuration configuration() {
     public Http2Headers decodeHeaders(int streamId, ByteBuf headerBlock) throws Http2Exception {
         try {
             final Http2Headers headers = newHeaders();
-            hpackDecoder.decode(streamId, headerBlock, headers);
+            hpackDecoder.decode(streamId, headerBlock, headers, validateHeaders);
             headerArraySizeAccumulator = HEADERS_COUNT_WEIGHT_NEW * headers.size() +
                                          HEADERS_COUNT_WEIGHT_HISTORICAL * headerArraySizeAccumulator;
             return headers;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackEncoderTest.java
Patch:
@@ -31,7 +31,7 @@ public class HpackEncoderTest {
     private Http2Headers mockHeaders;
 
     @Before
-    public void setUp() throws Http2Exception {
+    public void setUp() {
         hpackEncoder = new HpackEncoder();
         hpackDecoder = new HpackDecoder(DEFAULT_HEADER_LIST_SIZE, 32);
         mockHeaders = mock(Http2Headers.class);
@@ -42,7 +42,7 @@ public void testSetMaxHeaderTableSizeToMaxValue() throws Http2Exception {
         ByteBuf buf = Unpooled.buffer();
         hpackEncoder.setMaxHeaderTableSize(buf, MAX_HEADER_TABLE_SIZE);
         hpackDecoder.setMaxHeaderTableSize(MAX_HEADER_TABLE_SIZE);
-        hpackDecoder.decode(0, buf, mockHeaders);
+        hpackDecoder.decode(0, buf, mockHeaders, true);
         assertEquals(MAX_HEADER_TABLE_SIZE, hpackDecoder.getMaxHeaderTableSize());
         buf.release();
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HpackTestCase.java
Patch:
@@ -214,7 +214,7 @@ private static List<HpackHeaderField> decode(HpackDecoder hpackDecoder, byte[] e
         try {
             List<HpackHeaderField> headers = new ArrayList<HpackHeaderField>();
             TestHeaderListener listener = new TestHeaderListener(headers);
-            hpackDecoder.decode(0, in, listener);
+            hpackDecoder.decode(0, in, listener, true);
             return headers;
         } finally {
             in.release();

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackDecoderBenchmark.java
Patch:
@@ -82,7 +82,7 @@ public Http2Headers add(CharSequence name, CharSequence value) {
                 return this;
             }
         };
-        hpackDecoder.decode(0, input.duplicate(), headers);
+        hpackDecoder.decode(0, input.duplicate(), headers, true);
     }
 
     private byte[] getSerializedHeaders(Http2Headers headers, boolean sensitive) throws Http2Exception {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
Patch:
@@ -185,7 +185,7 @@ public CharSequence status() {
 
     @Override
     public boolean contains(CharSequence name, CharSequence value, boolean caseInsensitive) {
-        return contains(name, value, caseInsensitive? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER);
+        return contains(name, value, caseInsensitive ? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER);
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -112,7 +112,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
                 }
             }
         } catch (Throwable t) {
-            onError(ctx, t);
+            onError(ctx, true, t);
             promiseAggregator.setFailure(t);
         } finally {
             if (release) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
Patch:
@@ -227,6 +227,9 @@ final void onHttp2Frame(ChannelHandlerContext ctx, Http2Frame frame) {
             if (settings.initialWindowSize() != null) {
                 initialOutboundStreamWindow = settings.initialWindowSize();
             }
+        } else {
+            // Send any other frames down the pipeline
+            ctx.fireChannelRead(frame);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -1467,7 +1467,7 @@ private static String[] splitMultipartHeader(String sb) {
         valueStart = HttpPostBodyUtil.findNonWhitespace(sb, colonEnd);
         valueEnd = HttpPostBodyUtil.findEndOfString(sb);
         headers.add(sb.substring(nameStart, nameEnd));
-        String svalue = sb.substring(valueStart, valueEnd);
+        String svalue = (valueStart >= valueEnd) ? StringUtil.EMPTY_STRING : sb.substring(valueStart, valueEnd);
         String[] values;
         if (svalue.indexOf(';') >= 0) {
             values = splitMultipartHeaderValues(svalue);

File: buffer/src/test/java/io/netty/buffer/ByteProcessorTest.java
Patch:
@@ -37,6 +37,7 @@ public void testForward() {
         assertEquals(16, buf.forEachByte(14, length - 14, ByteProcessor.FIND_NON_LF));
         assertEquals(19, buf.forEachByte(16, length - 16, ByteProcessor.FIND_NUL));
         assertEquals(21, buf.forEachByte(19, length - 19, ByteProcessor.FIND_NON_NUL));
+        assertEquals(24, buf.forEachByte(19, length - 19, ByteProcessor.FIND_ASCII_SPACE));
         assertEquals(24, buf.forEachByte(21, length - 21, ByteProcessor.FIND_LINEAR_WHITESPACE));
         assertEquals(28, buf.forEachByte(24, length - 24, ByteProcessor.FIND_NON_LINEAR_WHITESPACE));
         assertEquals(-1, buf.forEachByte(28, length - 28, ByteProcessor.FIND_LINEAR_WHITESPACE));
@@ -51,6 +52,7 @@ public void testBackward() {
         final int length = buf.readableBytes();
 
         assertEquals(27, buf.forEachByteDesc(0, length, ByteProcessor.FIND_LINEAR_WHITESPACE));
+        assertEquals(25, buf.forEachByteDesc(0, length, ByteProcessor.FIND_ASCII_SPACE));
         assertEquals(23, buf.forEachByteDesc(0, 28, ByteProcessor.FIND_NON_LINEAR_WHITESPACE));
         assertEquals(20, buf.forEachByteDesc(0, 24, ByteProcessor.FIND_NUL));
         assertEquals(18, buf.forEachByteDesc(0, 21, ByteProcessor.FIND_NON_NUL));

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -116,7 +116,7 @@ public HttpResponseDecoder(
     protected HttpMessage createMessage(String[] initialLine) {
         return new DefaultHttpResponse(
                 HttpVersion.valueOf(initialLine[0]),
-                new HttpResponseStatus(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);
+                HttpResponseStatus.valueOf(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
Patch:
@@ -44,6 +44,7 @@
 import static io.netty.handler.codec.http.HttpHeaderNames.COOKIE;
 import static io.netty.handler.codec.http.HttpHeaderNames.TE;
 import static io.netty.handler.codec.http.HttpHeaderValues.TRAILERS;
+import static io.netty.handler.codec.http.HttpResponseStatus.parseLine;
 import static io.netty.handler.codec.http.HttpScheme.HTTP;
 import static io.netty.handler.codec.http.HttpScheme.HTTPS;
 import static io.netty.handler.codec.http.HttpUtil.isAsteriskForm;
@@ -183,7 +184,7 @@ public AsciiString text() {
     public static HttpResponseStatus parseStatus(CharSequence status) throws Http2Exception {
         HttpResponseStatus result;
         try {
-            result = HttpResponseStatus.parseLine(status);
+            result = parseLine(status);
             if (result == HttpResponseStatus.SWITCHING_PROTOCOLS) {
                 throw connectionError(PROTOCOL_ERROR, "Invalid HTTP/2 status code '%d'", result.code());
             }

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -611,8 +611,10 @@ private static void checkMultiplicity(ChannelHandler handler) {
 
     private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
         try {
-            ctx.handler().handlerAdded(ctx);
+            // We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates
+            // any pipeline events ctx.handler() will miss them because the state will not allow it.
             ctx.setAddComplete();
+            ctx.handler().handlerAdded(ctx);
         } catch (Throwable t) {
             boolean removed = false;
             try {

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -682,8 +682,7 @@ static String decodeString(ByteBuf src, int readerIndex, int len, Charset charse
             dst.clear();
         }
         if (src.nioBufferCount() == 1) {
-            // Use internalNioBuffer(...) to reduce object creation.
-            decodeString(decoder, src.internalNioBuffer(readerIndex, len), dst);
+            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);
         } else {
             // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers
             // are both backed by a byte array.

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -323,9 +323,11 @@ final ChannelFuture initAndRegister() {
             if (channel != null) {
                 // channel can be null if newChannel crashed (eg SocketException("too many open files"))
                 channel.unsafe().closeForcibly();
+                // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
+                return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
             }
             // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
-            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
+            return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
         }
 
         ChannelFuture regFuture = config().group().register(channel);

File: transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
Patch:
@@ -290,7 +290,7 @@ public Channel newChannel() {
         // Should fail with the RuntimeException.
         assertThat(connectFuture.await(10000), is(true));
         assertThat(connectFuture.cause(), sameInstance((Throwable) exception));
-        assertThat(connectFuture.channel(), is(nullValue()));
+        assertThat(connectFuture.channel(), is(not(nullValue())));
     }
 
     private static final class DelayedEventLoopGroup extends DefaultEventLoop {

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java
Patch:
@@ -113,15 +113,15 @@ public static ZlibDecoder newZlibDecoder() {
         if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {
             return new JZlibDecoder();
         } else {
-            return new JdkZlibDecoder();
+            return new JdkZlibDecoder(true);
         }
     }
 
     public static ZlibDecoder newZlibDecoder(ZlibWrapper wrapper) {
         if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {
             return new JZlibDecoder(wrapper);
         } else {
-            return new JdkZlibDecoder(wrapper);
+            return new JdkZlibDecoder(wrapper, true);
         }
     }
 

File: buffer/src/test/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBufferBufTest.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.buffer;
 
 import io.netty.util.internal.PlatformDependent;
-import org.junit.Assume;
 import org.junit.BeforeClass;
 
 import java.nio.ByteBuffer;

File: codec/src/main/java/io/netty/handler/codec/compression/FastLz.java
Patch:
@@ -168,7 +168,7 @@ static int compress(final byte[] input, final int inOffset, final int inLength,
                         readU16(input, inOffset + ip - 1) == readU16(input, inOffset + ip + 1)) {
                     distance = 1;
                     ip += 3;
-                    ref = anchor - 1 + 3;
+                    ref = anchor + (3 - 1);
 
                     /*
                      * goto match;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -223,7 +223,7 @@ public static void writeFrameHeader(ByteBuf out, int payloadLength, byte type,
      * Calculate the amount of bytes that can be sent by {@code state}. The lower bound is {@code 0}.
      */
     public static int streamableBytes(StreamByteDistributor.StreamState state) {
-        return max(0, min(state.pendingBytes(), state.windowSize()));
+        return max(0, (int) min(state.pendingBytes(), state.windowSize()));
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
Patch:
@@ -40,7 +40,7 @@ interface StreamState {
          * @return The amount of bytes this stream has pending to send.
          * @see Http2CodecUtil#streamableBytes(StreamState)
          */
-        int pendingBytes();
+        long pendingBytes();
 
         /**
          * Indicates whether or not there are frames pending for this stream.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -162,6 +162,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E
                             default:
                                 // Index was stored as the prefix
                                 name = readName(index);
+                                nameLength = name.length();
                                 state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX;
                         }
                     } else if ((b & 0x20) == 0x20) {
@@ -187,6 +188,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E
                             default:
                             // Index was stored as the prefix
                             name = readName(index);
+                            nameLength = name.length();
                             state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX;
                         }
                     }
@@ -205,6 +207,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E
                 case READ_INDEXED_HEADER_NAME:
                     // Header Name matches an entry in the Header Table
                     name = readName(decodeULE128(in, index));
+                    nameLength = name.length();
                     state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX;
                     break;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java
Patch:
@@ -49,6 +49,9 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         }
     }
 
+    // note that this may behave strangely when used for the initial upgrade
+    // message when using h2c, since that message is ineligible for flow
+    // control, but there is not yet an API for signaling that.
     static void handle(ChannelHandlerContext ctx, Http2Connection connection,
                               Http2FrameListener listener, FullHttpMessage message) throws Http2Exception {
         try {

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/Native.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel.kqueue;
 
 import io.netty.channel.unix.FileDescriptor;
+import io.netty.channel.unix.Socket;
 import io.netty.util.internal.NativeLibraryLoader;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
@@ -58,6 +59,7 @@ final class Native {
             // The library was not previously loaded, load it now.
             loadNativeLibrary();
         }
+        Socket.initialize();
     }
 
     static final short EV_ADD = evAdd();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -302,7 +302,7 @@ protected final ByteBuf newDirectBuffer(ByteBuf buf) {
     protected final ByteBuf newDirectBuffer(Object holder, ByteBuf buf) {
         final int readableBytes = buf.readableBytes();
         if (readableBytes == 0) {
-            ReferenceCountUtil.safeRelease(holder);
+            ReferenceCountUtil.release(holder);
             return Unpooled.EMPTY_BUFFER;
         }
 

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java
Patch:
@@ -248,7 +248,7 @@ protected final ByteBuf newDirectBuffer(ByteBuf buf) {
     protected final ByteBuf newDirectBuffer(Object holder, ByteBuf buf) {
         final int readableBytes = buf.readableBytes();
         if (readableBytes == 0) {
-            ReferenceCountUtil.safeRelease(holder);
+            ReferenceCountUtil.release(holder);
             return Unpooled.EMPTY_BUFFER;
         }
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1882,7 +1882,7 @@ protected ByteBuf compose(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf ne
                 return composite;
             }
             return attemptCopyToCumulation(cumulation, next, wrapDataSize) ? cumulation :
-                    composeIntoComposite(alloc, cumulation, next);
+                    copyAndCompose(alloc, cumulation, next);
         }
 
         @Override

File: transport/src/main/java/io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator.java
Patch:
@@ -86,7 +86,7 @@ public final void incMessagesRead(int amt) {
         }
 
         @Override
-        public final void lastBytesRead(int bytes) {
+        public void lastBytesRead(int bytes) {
             lastBytesRead = bytes;
             if (bytes > 0) {
                 totalBytesRead += bytes;

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -189,9 +189,9 @@ public Boolean run() {
                 availableJavaCipherSuites.add(CipherSuiteConverter.toJava(cipher, "SSL"));
             }
 
+            addIfSupported(availableJavaCipherSuites, defaultCiphers, DEFAULT_CIPHER_SUITES);
             useFallbackCiphersIfDefaultIsEmpty(defaultCiphers, availableJavaCipherSuites);
             DEFAULT_CIPHERS = Collections.unmodifiableList(defaultCiphers);
-            addIfSupported(availableJavaCipherSuites, defaultCiphers, DEFAULT_CIPHER_SUITES);
 
             AVAILABLE_JAVA_CIPHER_SUITES = Collections.unmodifiableSet(availableJavaCipherSuites);
 

File: common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
Patch:
@@ -103,7 +103,7 @@ public static boolean getBoolean(String key, boolean def) {
 
         value = value.trim().toLowerCase();
         if (value.isEmpty()) {
-            return true;
+            return def;
         }
 
         if ("true".equals(value) || "yes".equals(value) || "1".equals(value)) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
Patch:
@@ -65,6 +65,8 @@ DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress addres
 
     /**
      * Cache the resolution failure for a given hostname.
+     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions.
+      *
      * @param hostname the hostname
      * @param additionals the additional records
      * @param cause the resolution failure

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
Patch:
@@ -26,7 +26,7 @@
  * A {@link RuntimeException} raised when {@link DnsNameResolver} failed to perform a successful query.
  */
 @UnstableApi
-public final class DnsNameResolverException extends RuntimeException {
+public class DnsNameResolverException extends RuntimeException {
 
     private static final long serialVersionUID = -8826717909627131850L;
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
Patch:
@@ -65,8 +65,6 @@ DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress addres
 
     /**
      * Cache the resolution failure for a given hostname.
-     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions.
-      *
      * @param hostname the hostname
      * @param additionals the additional records
      * @param cause the resolution failure

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
Patch:
@@ -26,7 +26,7 @@
  * A {@link RuntimeException} raised when {@link DnsNameResolver} failed to perform a successful query.
  */
 @UnstableApi
-public class DnsNameResolverException extends RuntimeException {
+public final class DnsNameResolverException extends RuntimeException {
 
     private static final long serialVersionUID = -8826717909627131850L;
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
Patch:
@@ -65,6 +65,8 @@ DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress addres
 
     /**
      * Cache the resolution failure for a given hostname.
+     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions.
+      *
      * @param hostname the hostname
      * @param additionals the additional records
      * @param cause the resolution failure

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
Patch:
@@ -26,7 +26,7 @@
  * A {@link RuntimeException} raised when {@link DnsNameResolver} failed to perform a successful query.
  */
 @UnstableApi
-public final class DnsNameResolverException extends RuntimeException {
+public class DnsNameResolverException extends RuntimeException {
 
     private static final long serialVersionUID = -8826717909627131850L;
 

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackBenchmarkUtil.java
Patch:
@@ -38,8 +38,8 @@
 /**
  * Utility methods for hpack tests.
  */
-public final class HpackUtil {
-    private HpackUtil() {
+public final class HpackBenchmarkUtil {
+    private HpackBenchmarkUtil() {
     }
 
     /**

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackDecoderBenchmark.java
Patch:
@@ -32,7 +32,6 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
@@ -43,6 +42,8 @@
 import org.openjdk.jmh.annotations.TearDown;
 import org.openjdk.jmh.infra.Blackhole;
 
+import static io.netty.buffer.Unpooled.wrappedBuffer;
+import static io.netty.handler.codec.http2.HpackBenchmarkUtil.http2Headers;
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 
 public class HpackDecoderBenchmark extends AbstractMicrobenchmark {
@@ -60,7 +61,7 @@ public class HpackDecoderBenchmark extends AbstractMicrobenchmark {
 
     @Setup(Level.Trial)
     public void setup() throws Http2Exception {
-        input = Unpooled.wrappedBuffer(getSerializedHeaders(HpackUtil.http2Headers(size, limitToAscii), sensitive));
+        input = wrappedBuffer(getSerializedHeaders(http2Headers(size, limitToAscii), sensitive));
     }
 
     @TearDown(Level.Trial)

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackEncoderBenchmark.java
Patch:
@@ -79,7 +79,7 @@ public class HpackEncoderBenchmark extends AbstractMicrobenchmark {
 
     @Setup(Level.Trial)
     public void setup() {
-        http2Headers = HpackUtil.http2Headers(size, limitToAscii);
+        http2Headers = HpackBenchmarkUtil.http2Headers(size, limitToAscii);
         if (duplicates) {
             int size = http2Headers.size();
             if (size > 0) {

File: microbench/src/main/java/io/netty/handler/codec/http2/HpackUtilBenchmark.java
Patch:
@@ -45,7 +45,7 @@ public class HpackUtilBenchmark extends AbstractMicrobenchmark {
 
     @Setup(Level.Trial)
     public void setup() {
-        hpackHeaders = HpackUtil.headers(size, false);
+        hpackHeaders = HpackBenchmarkUtil.headers(size, false);
     }
 
     @Benchmark

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -853,13 +853,15 @@ public ByteBuf readBytes(int length) {
 
     @Override
     public ByteBuf readSlice(int length) {
+        checkReadableBytes(length);
         ByteBuf slice = slice(readerIndex, length);
         readerIndex += length;
         return slice;
     }
 
     @Override
     public ByteBuf readRetainedSlice(int length) {
+        checkReadableBytes(length);
         ByteBuf slice = retainedSlice(readerIndex, length);
         readerIndex += length;
         return slice;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -641,7 +641,9 @@ ByteBuf slice(int data, int padding, boolean endOfStream) {
                 prevPadding = padding;
                 flags.paddingPresent(padding > 0);
                 flags.endOfStream(endOfStream);
-                frameHeader = buffer.readSlice(DATA_FRAME_HEADER_LENGTH).writerIndex(0);
+                frameHeader = buffer.slice(buffer.readerIndex(), DATA_FRAME_HEADER_LENGTH).writerIndex(0);
+                buffer.setIndex(buffer.readerIndex() + DATA_FRAME_HEADER_LENGTH,
+                                buffer.writerIndex() + DATA_FRAME_HEADER_LENGTH);
 
                 int payloadLength = data + padding;
                 writeFrameHeaderInternal(frameHeader, payloadLength, DATA, flags, streamId);

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -1006,7 +1006,8 @@ public AsciiString toUpperCase() {
     }
 
     /**
-     * Copies this string removing white space characters from the beginning and end of the string.
+     * Duplicates this string removing white space characters from the beginning and end of the
+     * string, without copying.
      *
      * @return a new string with characters {@code <= \\u0020} removed from the beginning and the end.
      */

File: handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java
Patch:
@@ -81,7 +81,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                                         "not an SSL/TLS record: " + ByteBufUtil.hexDump(in));
                                 in.skipBytes(in.readableBytes());
 
-                                SslUtils.notifyHandshakeFailure(ctx, e);
+                                SslUtils.notifyHandshakeFailure(ctx, e, true);
                                 throw e;
                             }
                             if (len == SslUtils.NOT_ENOUGH_DATA ||

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -194,7 +194,7 @@ public FixedChannelPool(Bootstrap bootstrap,
         } else if (action == null && acquireTimeoutMillis != -1) {
             throw new NullPointerException("action");
         } else if (action != null && acquireTimeoutMillis < 0) {
-            throw new IllegalArgumentException("acquireTimeoutMillis: " + acquireTimeoutMillis + " (expected: >= 1)");
+            throw new IllegalArgumentException("acquireTimeoutMillis: " + acquireTimeoutMillis + " (expected: >= 0)");
         } else {
             acquireTimeoutNanos = TimeUnit.MILLISECONDS.toNanos(acquireTimeoutMillis);
             switch (action) {

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1333,7 +1333,7 @@ public int setBytes(int index, FileChannel in, long position, int length) throws
     @Override
     public ByteBuf copy(int index, int length) {
         checkIndex(index, length);
-        ByteBuf dst = Unpooled.buffer(length);
+        ByteBuf dst = allocBuffer(length);
         if (length != 0) {
             copyTo(index, length, toComponentIndex(index), dst);
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java
Patch:
@@ -36,7 +36,7 @@ public class Http2MultiplexCodecBuilder
     }
 
     private static ChannelHandler checkSharable(ChannelHandler handler) {
-        if ((handler instanceof ChannelHandlerAdapter && !((ChannelHandlerAdapter) handler).isSharable()) ||
+        if ((handler instanceof ChannelHandlerAdapter && !((ChannelHandlerAdapter) handler).isSharable()) &&
                 !handler.getClass().isAnnotationPresent(ChannelHandler.Sharable.class)) {
             throw new IllegalArgumentException("The handler must be Sharable");
         }

File: transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java
Patch:
@@ -50,10 +50,11 @@ protected AbstractCoalescingBufferQueue(Channel channel, int initSize) {
     /**
      * Add a buffer to the front of the queue.
      */
-    public final void addFirst(ByteBuf buf) {
+    public final void addFirst(ByteBuf buf, ChannelPromise promise) {
         // Listener would be added here, but since it is null there is no need. The assumption is there is already a
         // listener at the front of the queue, or there is a buffer at the front of the queue, which was spliced from
         // buf via remove().
+        bufAndListenerPairs.addFirst(new DelegatingChannelPromiseNotifier(promise));
         bufAndListenerPairs.addFirst(buf);
 
         incrementReadableBytes(buf.readableBytes());

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -727,6 +727,7 @@ private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Thro
                 EpollRecvByteAllocatorHandle allocHandle) {
             if (byteBuf != null) {
                 if (byteBuf.isReadable()) {
+                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                 } else {
                     byteBuf.release();
@@ -783,7 +784,6 @@ void epollInReady() {
                     // we use a direct buffer here as the native implementations only be able
                     // to handle direct buffers.
                     byteBuf = allocHandle.allocate(allocator);
-                    readPending = false;
                     allocHandle.lastBytesRead(doReadBytes(byteBuf));
                     if (allocHandle.lastBytesRead() <= 0) {
                         // nothing was read, release the buffer.
@@ -793,6 +793,7 @@ void epollInReady() {
                         break;
                     }
                     allocHandle.incMessagesRead(1);
+                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                     byteBuf = null;
 

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java
Patch:
@@ -526,7 +526,6 @@ void readReady(final KQueueRecvByteAllocatorHandle allocHandle) {
                     // we use a direct buffer here as the native implementations only be able
                     // to handle direct buffers.
                     byteBuf = allocHandle.allocate(allocator);
-                    readPending = false;
                     allocHandle.lastBytesRead(doReadBytes(byteBuf));
                     if (allocHandle.lastBytesRead() <= 0) {
                         // nothing was read, release the buffer.
@@ -536,6 +535,7 @@ void readReady(final KQueueRecvByteAllocatorHandle allocHandle) {
                         break;
                     }
                     allocHandle.incMessagesRead(1);
+                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                     byteBuf = null;
 
@@ -572,6 +572,7 @@ private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Thro
                                          KQueueRecvByteAllocatorHandle allocHandle) {
             if (byteBuf != null) {
                 if (byteBuf.isReadable()) {
+                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                 } else {
                     byteBuf.release();

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -225,7 +225,8 @@ protected boolean isContentAlwaysEmpty(HttpMessage msg) {
             final int statusCode = ((HttpResponse) msg).status().code();
             if (statusCode == 100 || statusCode == 101) {
                 // 100-continue and 101 switching protocols response should be excluded from paired comparison.
-                return true;
+                // Just delegate to super method which has all the needed handling.
+                return super.isContentAlwaysEmpty(msg);
             }
 
             // Get the getMethod of the HTTP request that corresponds to the
@@ -236,7 +237,7 @@ protected boolean isContentAlwaysEmpty(HttpMessage msg) {
             switch (firstChar) {
             case 'H':
                 // According to 4.3, RFC2616:
-                // All responses to the HEAD request getMethod MUST NOT include a
+                // All responses to the HEAD request method MUST NOT include a
                 // message-body, even though the presence of entity-header fields
                 // might lead one to believe they do.
                 if (HttpMethod.HEAD.equals(method)) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -223,8 +223,8 @@ private void decrement(Object msg) {
         @Override
         protected boolean isContentAlwaysEmpty(HttpMessage msg) {
             final int statusCode = ((HttpResponse) msg).status().code();
-            if (statusCode == 100) {
-                // 100-continue response should be excluded from paired comparison.
+            if (statusCode == 100 || statusCode == 101) {
+                // 100-continue and 101 switching protocols response should be excluded from paired comparison.
                 return true;
             }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -727,7 +727,6 @@ private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Thro
                 EpollRecvByteAllocatorHandle allocHandle) {
             if (byteBuf != null) {
                 if (byteBuf.isReadable()) {
-                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                 } else {
                     byteBuf.release();
@@ -784,6 +783,7 @@ void epollInReady() {
                     // we use a direct buffer here as the native implementations only be able
                     // to handle direct buffers.
                     byteBuf = allocHandle.allocate(allocator);
+                    readPending = false;
                     allocHandle.lastBytesRead(doReadBytes(byteBuf));
                     if (allocHandle.lastBytesRead() <= 0) {
                         // nothing was read, release the buffer.
@@ -793,7 +793,6 @@ void epollInReady() {
                         break;
                     }
                     allocHandle.incMessagesRead(1);
-                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                     byteBuf = null;
 

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java
Patch:
@@ -526,6 +526,7 @@ void readReady(final KQueueRecvByteAllocatorHandle allocHandle) {
                     // we use a direct buffer here as the native implementations only be able
                     // to handle direct buffers.
                     byteBuf = allocHandle.allocate(allocator);
+                    readPending = false;
                     allocHandle.lastBytesRead(doReadBytes(byteBuf));
                     if (allocHandle.lastBytesRead() <= 0) {
                         // nothing was read, release the buffer.
@@ -535,7 +536,6 @@ void readReady(final KQueueRecvByteAllocatorHandle allocHandle) {
                         break;
                     }
                     allocHandle.incMessagesRead(1);
-                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                     byteBuf = null;
 
@@ -572,7 +572,6 @@ private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Thro
                                          KQueueRecvByteAllocatorHandle allocHandle) {
             if (byteBuf != null) {
                 if (byteBuf.isReadable()) {
-                    readPending = false;
                     pipeline.fireChannelRead(byteBuf);
                 } else {
                     byteBuf.release();

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/SocketTest.java
Patch:
@@ -91,7 +91,8 @@ public void testDoubleCloseDoesNotThrow() throws IOException {
 
     @Test
     public void testTrafficClass() throws IOException {
-        final int value = 0x1;
+        // IPTOS_THROUGHPUT
+        final int value = 0x08;
         socket.setTrafficClass(value);
         assertEquals(value, socket.getTrafficClass());
     }

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -312,7 +312,7 @@ protected String format(ChannelHandlerContext ctx, String eventName, Object firs
         String arg1Str = String.valueOf(firstArg);
         String arg2Str = secondArg.toString();
         StringBuilder buf = new StringBuilder(
-                chStr.length() + 1 + eventName + 2 + arg1Str.length() + 2 + arg2Str.length());
+                chStr.length() + 1 + eventName.length() + 2 + arg1Str.length() + 2 + arg2Str.length());
         buf.append(chStr).append(' ').append(eventName).append(": ").append(arg1Str).append(", ").append(arg2Str);
         return buf.toString();
     }

File: handler/src/test/java/io/netty/handler/logging/LoggingHandlerTest.java
Patch:
@@ -146,8 +146,8 @@ public void shouldLogChannelConnect() throws Exception {
     public void shouldLogChannelConnectWithLocalAddress() throws Exception {
         EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
         channel.connect(new InetSocketAddress(80), new InetSocketAddress(81)).await();
-        verify(appender).doAppend(argThat(
-                new RegexLogMatcher(".+CONNECT: 0.0.0.0/0.0.0.0:80, 0.0.0.0/0.0.0.0:81$")));
+        verify(appender).doAppend(argThat(new RegexLogMatcher(
+                "^\\[id: 0xembedded, L:embedded - R:embedded\\] CONNECT: 0.0.0.0/0.0.0.0:80, 0.0.0.0/0.0.0.0:81$")));
     }
 
     @Test

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -735,7 +735,7 @@ private void followCname(String cname, final DnsQueryLifecycleObserver queryLife
         DnsQuestion cnameQuestion = null;
         if (parent.supportsARecords()) {
             try {
-                if ((cnameQuestion = newQuestion(hostname, DnsRecordType.A)) == null) {
+                if ((cnameQuestion = newQuestion(cname, DnsRecordType.A)) == null) {
                     return;
                 }
             } catch (Throwable cause) {
@@ -746,7 +746,7 @@ private void followCname(String cname, final DnsQueryLifecycleObserver queryLife
         }
         if (parent.supportsAAAARecords()) {
             try {
-                if ((cnameQuestion = newQuestion(hostname, DnsRecordType.AAAA)) == null) {
+                if ((cnameQuestion = newQuestion(cname, DnsRecordType.AAAA)) == null) {
                     return;
                 }
             } catch (Throwable cause) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -127,16 +127,14 @@ protected FullHttpRequest newHandshakeRequest() {
         // Get path
         URI wsURL = uri();
         String path = rawPath(wsURL);
-        int wsPort = websocketPort(wsURL);
-        String host = wsURL.getHost();
 
         // Format request
         FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);
         HttpHeaders headers = request.headers();
         headers.add(HttpHeaderNames.UPGRADE, WEBSOCKET)
                .add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
                .add(HttpHeaderNames.HOST, websocketHostValue(wsURL))
-               .add(HttpHeaderNames.ORIGIN, websocketOriginValue(host, wsPort))
+               .add(HttpHeaderNames.ORIGIN, websocketOriginValue(wsURL))
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY1, key1)
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY2, key2);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -143,16 +143,14 @@ protected FullHttpRequest newHandshakeRequest() {
         }
 
         // Format request
-        int wsPort = websocketPort(wsURL);
-        String host = wsURL.getHost();
         FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);
         HttpHeaders headers = request.headers();
 
         headers.add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
                .add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY, key)
                .add(HttpHeaderNames.HOST, websocketHostValue(wsURL))
-               .add(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(host, wsPort));
+               .add(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(wsURL));
 
         String expectedSubprotocol = expectedSubprotocol();
         if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java
Patch:
@@ -78,7 +78,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java
Patch:
@@ -99,7 +99,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java
Patch:
@@ -92,7 +92,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java
Patch:
@@ -91,7 +91,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java
Patch:
@@ -85,7 +85,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialResponseDecoder.java
Patch:
@@ -76,7 +76,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoder.java
Patch:
@@ -83,7 +83,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoder.java
Patch:
@@ -73,7 +73,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         }
     }
 
-    private void fail(List<Object> out, Throwable cause) {
+    private void fail(List<Object> out, Exception cause) {
         if (!(cause instanceof DecoderException)) {
             cause = new DecoderException(cause);
         }

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -418,7 +418,7 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
             }
         } catch (DecoderException e) {
             throw e;
-        } catch (Throwable cause) {
+        } catch (Exception cause) {
             throw new DecoderException(cause);
         }
     }

File: handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java
Patch:
@@ -234,8 +234,10 @@ public void operationComplete(Future<T> future) throws Exception {
                             onLookupComplete(ctx, hostname, future);
                         } catch (DecoderException err) {
                             ctx.fireExceptionCaught(err);
-                        } catch (Throwable cause) {
+                        } catch (Exception cause) {
                             ctx.fireExceptionCaught(new DecoderException(cause));
+                        } catch (Throwable cause) {
+                            ctx.fireExceptionCaught(cause);
                         }
                     } finally {
                         if (readPending) {

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -265,8 +265,8 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 callDecode(ctx, cumulation, out);
             } catch (DecoderException e) {
                 throw e;
-            } catch (Throwable t) {
-                throw new DecoderException(t);
+            } catch (Exception e) {
+                throw new DecoderException(e);
             } finally {
                 if (cumulation != null && !cumulation.isReadable()) {
                     numReads = 0;
@@ -455,7 +455,7 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
             }
         } catch (DecoderException e) {
             throw e;
-        } catch (Throwable cause) {
+        } catch (Exception cause) {
             throw new DecoderException(cause);
         }
     }

File: handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolAccessor.java
Patch:
@@ -26,5 +26,5 @@ interface ApplicationProtocolAccessor {
      * @return the application-level protocol name or
      *         {@code null} if the negotiation failed or the client does not have ALPN/NPN extension
      */
-    String getApplicationProtocol();
+    String getNegotiatedApplicationProtocol();
 }

File: handler/src/main/java/io/netty/handler/ssl/JdkSslEngine.java
Patch:
@@ -33,11 +33,11 @@ class JdkSslEngine extends SSLEngine implements ApplicationProtocolAccessor {
     }
 
     @Override
-    public String getApplicationProtocol() {
+    public String getNegotiatedApplicationProtocol() {
         return applicationProtocol;
     }
 
-    void setApplicationProtocol(String applicationProtocol) {
+    void setNegotiatedApplicationProtocol(String applicationProtocol) {
         this.applicationProtocol = applicationProtocol;
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -1829,7 +1829,7 @@ final boolean checkSniHostnameMatch(String hostname) {
     }
 
     @Override
-    public String getApplicationProtocol() {
+    public String getNegotiatedApplicationProtocol() {
         return applicationProtocol;
     }
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -66,7 +66,6 @@
 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
 import javax.net.ssl.SSLEngineResult.Status;
 import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSession;
 
 import static io.netty.buffer.ByteBufUtil.ensureWritableSuccess;
 import static io.netty.handler.ssl.SslUtils.getEncryptedPacketLength;
@@ -578,7 +577,7 @@ public String applicationProtocol() {
             return null;
         }
 
-        return ((ApplicationProtocolAccessor) engine).getApplicationProtocol();
+        return ((ApplicationProtocolAccessor) engine).getNegotiatedApplicationProtocol();
     }
 
     /**

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
Patch:
@@ -161,6 +161,7 @@ public void preflightRequestWithCustomHeader() {
         final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
         assertThat(response.headers().get(of("CustomHeader")), equalTo("somevalue"));
         assertThat(response.headers().get(VARY), equalTo(ORIGIN.toString()));
+        assertThat(response.headers().get(CONTENT_LENGTH), is("0"));
     }
 
     @Test
@@ -276,6 +277,7 @@ public void simpleRequestShortCircuit() {
         final CorsConfig config = forOrigin("http://localhost:8080").shortCircuit().build();
         final HttpResponse response = simpleRequest(config, "http://localhost:7777");
         assertThat(response.status(), is(FORBIDDEN));
+        assertThat(response.headers().get(CONTENT_LENGTH), is("0"));
     }
 
     @Test

File: buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
Patch:
@@ -246,7 +246,7 @@ private Component findComponent(int index) {
             readable += b.readableBytes();
             if (index < readable) {
                 if (isBuffer) {
-                    // Create a new component ad store ti in the array so it not create a new object
+                    // Create a new component and store it in the array so it not create a new object
                     // on the next access.
                     comp = new Component(i, readable - b.readableBytes(), b);
                     buffers[i] = comp;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -155,7 +155,7 @@ protected FullHttpMessage newMessage(Http2Stream stream, Http2Headers headers, b
                                          ByteBufAllocator alloc)
             throws Http2Exception {
         return connection.isServer() ? HttpConversionUtil.toFullHttpRequest(stream.id(), headers, alloc,
-                validateHttpHeaders) : HttpConversionUtil.toHttpResponse(stream.id(), headers, alloc,
+                validateHttpHeaders) : HttpConversionUtil.toFullHttpResponse(stream.id(), headers, alloc,
                                                                          validateHttpHeaders);
     }
 

File: common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
Patch:
@@ -79,7 +79,6 @@ public static void loadFirstAvailable(ClassLoader loader, String... names) {
         for (String name : names) {
             try {
                 load(name, loader);
-                logger.debug("Successfully loaded the library: {}", name);
                 return;
             } catch (Throwable t) {
                 logger.debug("Unable to load the library '{}', trying next name...", name, t);
@@ -116,7 +115,6 @@ public static void load(String originalName, ClassLoader loader) {
         try {
             // first try to load from java.library.path
             loadLibrary(loader, name, false);
-            logger.debug("{} was loaded from java.libary.path", name);
             return;
         } catch (Throwable ex) {
             logger.debug(
@@ -200,13 +198,15 @@ private static void loadLibrary(final ClassLoader loader, final String name, fin
             // Make sure the helper is belong to the target ClassLoader.
             final Class<?> newHelper = tryToLoadClass(loader, NativeLibraryUtil.class);
             loadLibraryByHelper(newHelper, name, absolute);
+            logger.debug("Successfully loaded the library {}", name);
             return;
         } catch (UnsatisfiedLinkError e) { // Should by pass the UnsatisfiedLinkError here!
             logger.debug("Unable to load the library '{}', trying other loading mechanism.", name, e);
         } catch (Exception e) {
             logger.debug("Unable to load the library '{}', trying other loading mechanism.", name, e);
         }
         NativeLibraryUtil.loadLibrary(name, absolute);  // Fallback to local helper class.
+        logger.debug("Successfully loaded the library {}", name);
     }
 
     private static void loadLibraryByHelper(final Class<?> helper, final String name, final boolean absolute)

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageBuilders.java
Patch:
@@ -150,7 +150,7 @@ public ConnectBuilder hasPassword(boolean value) {
         }
 
         public ConnectBuilder username(String username) {
-            this.hasUser = true;
+            this.hasUser = username != null;
             this.username = username;
             return this;
         }
@@ -165,7 +165,7 @@ public ConnectBuilder password(String password) {
         }
 
         public ConnectBuilder password(byte[] password) {
-            this.hasPassword = true;
+            this.hasPassword = password != null;
             this.password = password;
             return this;
         }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
Patch:
@@ -372,7 +372,7 @@ public void outboundFlowControlWritability() {
         Http2StreamChannel childChannel = newOutboundStream();
         assertTrue(childChannel.isActive());
 
-        assertFalse(childChannel.isWritable());
+        assertTrue(childChannel.isWritable());
         childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));
         parentChannel.flush();
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelId.java
Patch:
@@ -56,7 +56,7 @@ public int compareTo(ChannelId o) {
 
     @Override
     public int hashCode() {
-        return parentId.hashCode();
+        return id * 31 + parentId.hashCode();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java
Patch:
@@ -36,7 +36,7 @@ public final class DelegatingChannelPromiseNotifier implements ChannelPromise, C
     private final boolean logNotifyFailure;
 
     public DelegatingChannelPromiseNotifier(ChannelPromise delegate) {
-        this(delegate, true);
+        this(delegate, !(delegate instanceof VoidChannelPromise));
     }
 
     public DelegatingChannelPromiseNotifier(ChannelPromise delegate, boolean logNotifyFailure) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -196,7 +196,8 @@ private static void loadNativeLibrary() {
         if (!name.startsWith("linux")) {
             throw new IllegalStateException("Only supported on Linux");
         }
-        NativeLibraryLoader.load("netty_transport_native_epoll", PlatformDependent.getClassLoader(Native.class));
+        NativeLibraryLoader.load("netty_transport_native_epoll_" + PlatformDependent.normalizedArch(),
+                PlatformDependent.getClassLoader(Native.class));
     }
 
     private Native() {

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/Native.java
Patch:
@@ -111,7 +111,8 @@ private static void loadNativeLibrary() {
         if (!name.startsWith("mac") && !name.contains("bsd") && !name.startsWith("darwin")) {
             throw new IllegalStateException("Only supported on BSD");
         }
-        NativeLibraryLoader.load("netty_transport_native_kqueue", PlatformDependent.getClassLoader(Native.class));
+        NativeLibraryLoader.load("netty_transport_native_kqueue_" + PlatformDependent.normalizedArch(),
+                PlatformDependent.getClassLoader(Native.class));
     }
 
     private Native() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -248,7 +248,7 @@ public final void userEventTriggered(ChannelHandlerContext ctx, Object evt) thro
                 upgrade.upgradeRequest().headers().setInt(
                         HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(), HTTP_UPGRADE_STREAM_ID);
                 InboundHttpToHttp2Adapter.handle(
-                        ctx, connection(), decoder().frameListener(), upgrade.upgradeRequest());
+                        ctx, connection(), decoder().frameListener(), upgrade.upgradeRequest().retain());
             } finally {
                 upgrade.release();
             }

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandRequest.java
Patch:
@@ -59,8 +59,8 @@ public DefaultSocks5CommandRequest(
             }
         }
 
-        if (dstPort <= 0 || dstPort >= 65536) {
-            throw new IllegalArgumentException("dstPort: " + dstPort + " (expected: 1~65535)");
+        if (dstPort < 0 || dstPort > 65535) {
+            throw new IllegalArgumentException("dstPort: " + dstPort + " (expected: 0~65535)");
         }
 
         this.type = type;

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -26,12 +26,12 @@
  *
  * As Netty's Cookie merges Expires and MaxAge into one single field, only Max-Age field is sent.
  *
- * Note that multiple cookies are supposed to be sent at once in a single "Set-Cookie" header.
+ * Note that multiple cookies must be sent as separate "Set-Cookie" headers.
  *
  * <pre>
  * // Example
- * {@link HttpRequest} req = ...;
- * res.setHeader("Cookie", {@link ServerCookieEncoder}.encode("JSESSIONID", "1234"));
+ * {@link HttpResponse} res = ...;
+ * res.setHeader("Set-Cookie", {@link ServerCookieEncoder}.encode("JSESSIONID", "1234"));
  * </pre>
  *
  * @see ServerCookieDecoder

File: handler/src/main/java/io/netty/handler/ssl/PemReader.java
Patch:
@@ -111,7 +111,7 @@ static ByteBuf readPrivateKey(File file) throws KeyException {
                 safeClose(in);
             }
         } catch (FileNotFoundException e) {
-            throw new KeyException("could not fine key file: " + file);
+            throw new KeyException("could not find key file: " + file);
         }
     }
 

File: handler/src/main/java/io/netty/handler/ssl/JettyAlpnSslEngine.java
Patch:
@@ -38,7 +38,6 @@ static boolean isAvailable() {
     }
 
     private static boolean initAvailable() {
-        // TODO: Add support for ALPN when using Java9 and still be able to configure it the Netty way.
         if (PlatformDependent.javaVersion() <= 8) {
             try {
                 // Always use bootstrap class loader.

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -573,12 +573,12 @@ public SSLEngine engine() {
      * @return the protocol name or {@code null} if application-level protocol has not been negotiated
      */
     public String applicationProtocol() {
-        SSLSession sess = engine().getSession();
-        if (!(sess instanceof ApplicationProtocolAccessor)) {
+        SSLEngine engine = engine();
+        if (!(engine instanceof ApplicationProtocolAccessor)) {
             return null;
         }
 
-        return ((ApplicationProtocolAccessor) sess).getApplicationProtocol();
+        return ((ApplicationProtocolAccessor) engine).getApplicationProtocol();
     }
 
     /**

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2Encoder.java
Patch:
@@ -113,9 +113,11 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                     out.writeMedium(MAGIC_NUMBER);
                     out.writeByte('0' + streamBlockSize / BASE_BLOCK_SIZE);
                     currentState = State.INIT_BLOCK;
+                    // fall through
                 case INIT_BLOCK:
                     blockCompressor = new Bzip2BlockCompressor(writer, streamBlockSize);
                     currentState = State.WRITE_DATA;
+                    // fall through
                 case WRITE_DATA:
                     if (!in.isReadable()) {
                         return;
@@ -132,6 +134,7 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                         }
                     }
                     currentState = State.CLOSE_BLOCK;
+                    // fall through
                 case CLOSE_BLOCK:
                     closeBlock(out);
                     currentState = State.INIT_BLOCK;

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanAllocator.java
Patch:
@@ -159,6 +159,7 @@ static void allocateHuffmanCodeLengths(final int[] array, final int maximumLengt
         switch (array.length) {
             case 2:
                 array[1] = 1;
+                // fall through
             case 1:
                 array[0] = 1;
                 return;

File: codec/src/main/java/io/netty/handler/codec/compression/FastLz.java
Patch:
@@ -90,6 +90,7 @@ static int calculateOutputBufferLength(int inputLength) {
      *
      * If the input is not compressible, the return value might be larger than length (input buffer size).
      */
+    @SuppressWarnings("IdentityBinaryExpression")
     static int compress(final byte[] input, final int inOffset, final int inLength,
                         final byte[] output, final int outOffset, final int proposedLevel) {
         final int level;

File: codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java
Patch:
@@ -126,6 +126,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 hasChecksum = (options & 0x10) == BLOCK_WITH_CHECKSUM;
 
                 currentState = State.INIT_BLOCK_PARAMS;
+                // fall through
             case INIT_BLOCK_PARAMS:
                 if (in.readableBytes() < 2 + (isCompressed ? 2 : 0) + (hasChecksum ? 4 : 0)) {
                     break;
@@ -135,6 +136,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 originalLength = isCompressed ? in.readUnsignedShort() : chunkLength;
 
                 currentState = State.DECOMPRESS_DATA;
+                // fall through
             case DECOMPRESS_DATA:
                 final int chunkLength = this.chunkLength;
                 if (in.readableBytes() < chunkLength) {

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
Patch:
@@ -242,6 +242,8 @@ protected final ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg,
                 case ZLIB:
                     sizeEstimate += 2; // first two magic bytes
                     break;
+                default:
+                    // no op
             }
         }
         return ctx.alloc().heapBuffer(sizeEstimate);

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameDecoder.java
Patch:
@@ -202,6 +202,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 this.currentChecksum = currentChecksum;
 
                 currentState = State.DECOMPRESS_DATA;
+                // fall through
             case DECOMPRESS_DATA:
                 blockType = this.blockType;
                 compressedLength = this.compressedLength;

File: codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java
Patch:
@@ -140,13 +140,15 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 if (type != BLOCK_TYPE_COMPRESSED) {
                     break;
                 }
+                // fall through
             case INIT_ORIGINAL_LENGTH:
                 if (in.readableBytes() < 2) {
                     break;
                 }
                 originalLength = in.readUnsignedShort();
 
                 currentState = State.DECOMPRESS_DATA;
+                // fall through
             case DECOMPRESS_DATA:
                 final int chunkLength = this.chunkLength;
                 if (in.readableBytes() < chunkLength) {

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -272,6 +272,7 @@ public void decode(ByteBuf in, ByteBuf out) {
             switch (state) {
             case READY:
                 state = State.READING_PREAMBLE;
+                // fall through
             case READING_PREAMBLE:
                 int uncompressedLength = readPreamble(in);
                 if (uncompressedLength == PREAMBLE_NOT_FULL) {
@@ -285,6 +286,7 @@ public void decode(ByteBuf in, ByteBuf out) {
                 }
                 out.ensureWritable(uncompressedLength);
                 state = State.READING_TAG;
+                // fall through
             case READING_TAG:
                 if (!in.isReadable()) {
                     return;

File: common/src/main/java/io/netty/util/internal/StringUtil.java
Patch:
@@ -490,6 +490,7 @@ public static List<CharSequence> unescapeCsvFields(CharSequence value) {
                             break;
                         }
                         // double-quote appears without being enclosed with double-quotes
+                        // fall through
                     case LINE_FEED:
                         // fall through
                     case CARRIAGE_RETURN:

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -439,8 +439,8 @@ protected void run() {
                         if (wakenUp.get()) {
                             selector.wakeup();
                         }
+                        // fall through
                     default:
-                        // fallthrough
                 }
 
                 cancelledKeys = 0;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -599,7 +599,7 @@ private boolean doResolveCached(String hostname,
                                     DnsRecord[] additionals,
                                     Promise<InetAddress> promise,
                                     DnsCache resolveCache) {
-        final List<DnsCacheEntry> cachedEntries = resolveCache.get(hostname, additionals);
+        final List<? extends DnsCacheEntry> cachedEntries = resolveCache.get(hostname, additionals);
         if (cachedEntries == null || cachedEntries.isEmpty()) {
             return false;
         }
@@ -729,7 +729,7 @@ private boolean doResolveAllCached(String hostname,
                                        DnsRecord[] additionals,
                                        Promise<List<InetAddress>> promise,
                                        DnsCache resolveCache) {
-        final List<DnsCacheEntry> cachedEntries = resolveCache.get(hostname, additionals);
+        final List<? extends DnsCacheEntry> cachedEntries = resolveCache.get(hostname, additionals);
         if (cachedEntries == null || cachedEntries.isEmpty()) {
             return false;
         }

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -379,12 +379,12 @@ public final SSLEngine newEngine(ByteBufAllocator alloc, String peerHost, int pe
     }
 
     @Override
-    final SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {
+    protected final SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {
         return new SslHandler(newEngine0(alloc, null, -1, false), startTls, false);
     }
 
     @Override
-    final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {
+    protected final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {
         return new SslHandler(newEngine0(alloc, peerHost, peerPort, false), startTls, false);
     }
 

File: handler/src/main/java/io/netty/handler/ssl/SslContext.java
Patch:
@@ -909,7 +909,7 @@ public final SslHandler newHandler(ByteBufAllocator alloc) {
      * Create a new SslHandler.
      * @see #newHandler(ByteBufAllocator)
      */
-    SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {
+    protected SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {
         return new SslHandler(newEngine(alloc), startTls);
     }
 
@@ -947,7 +947,7 @@ public final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int
      * Create a new SslHandler.
      * @see #newHandler(ByteBufAllocator, String, int, boolean)
      */
-    SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {
+    protected SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {
         return new SslHandler(newEngine(alloc, peerHost, peerPort), startTls);
     }
 

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoderNano.java
Patch:
@@ -82,7 +82,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out)
             msg.getBytes(msg.readerIndex(), array, 0, length);
             offset = 0;
         }
-        MessageNano prototype = clazz.newInstance();
+        MessageNano prototype = clazz.getConstructor().newInstance();
         out.add(MessageNano.mergeFrom(prototype, array, offset, length));
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java
Patch:
@@ -78,7 +78,7 @@ public static void execute(final Class<? extends CaliperBench> klaz)
     public static Run execute(final String name,
             final Class<? extends CaliperBench> klaz) throws Exception {
 
-        final CaliperBench booter = klaz.newInstance();
+        final CaliperBench booter = klaz.getConstructor().newInstance();
 
         final List<Map<String, String>> varsSet = product(booter);
 

File: transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java
Patch:
@@ -35,7 +35,7 @@ public ReflectiveChannelFactory(Class<? extends T> clazz) {
     @Override
     public T newChannel() {
         try {
-            return clazz.newInstance();
+            return clazz.getConstructor().newInstance();
         } catch (Throwable t) {
             throw new ChannelException("Unable to create Channel from class " + clazz, t);
         }

File: common/src/main/java/io/netty/util/internal/StringUtil.java
Patch:
@@ -491,6 +491,7 @@ public static List<CharSequence> unescapeCsvFields(CharSequence value) {
                         }
                         // double-quote appears without being enclosed with double-quotes
                     case LINE_FEED:
+                        // fall through
                     case CARRIAGE_RETURN:
                         // special characters appears without being enclosed with double-quotes
                         throw newInvalidEscapedCsvFieldException(value, i);

File: common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
Patch:
@@ -111,7 +111,7 @@ private static String calculatePackagePrefix() {
      */
     public static void load(String originalName, ClassLoader loader) {
         // Adjust expected name to support shading of native libraries.
-        String name = calculatePackagePrefix().replace('.', '-') + originalName;
+        String name = calculatePackagePrefix().replace('.', '_') + originalName;
 
         String libname = System.mapLibraryName(name);
         String path = NATIVE_RESOURCE_HOME + libname;

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -591,7 +591,9 @@ public static int writeAscii(ByteBuf buf, CharSequence seq) {
                     // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path.
                     buf = buf.unwrap();
                 } else {
-                    buf.writeBytes(seq.toString().getBytes(CharsetUtil.US_ASCII));
+                    byte[] bytes = seq.toString().getBytes(CharsetUtil.US_ASCII);
+                    buf.writeBytes(bytes);
+                    return bytes.length;
                 }
             }
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.UnstableApi;
 
 /**
@@ -174,7 +175,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return "DefaultHttp2GoAwayFrame(errorCode=" + errorCode + ", content=" + content()
-               + ", extraStreamIds=" + extraStreamIds + ", lastStreamId=" + lastStreamId + ")";
+        return StringUtil.simpleClassName(this) + "(errorCode=" + errorCode + ", content=" + content()
+               + ", extraStreamIds=" + extraStreamIds + ", lastStreamId=" + lastStreamId + ')';
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java
Patch:
@@ -53,7 +53,7 @@ public Http2ClientUpgradeCodec(Http2FrameCodec frameCodec, ChannelHandler upgrad
     }
 
     public Http2ClientUpgradeCodec(String handlerName, Http2FrameCodec frameCodec, ChannelHandler upgradeToHandler) {
-        this(handlerName, frameCodec.connectionHandler(), upgradeToHandler);
+        this(handlerName, (Http2ConnectionHandler) frameCodec, upgradeToHandler);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameStreamVisitor.java
Patch:
@@ -19,10 +19,10 @@
 import io.netty.util.internal.UnstableApi;
 
 /**
- * A visitor that allows to iterate over a collection of {@link Http2Stream2}s.
+ * A visitor that allows to iterate over a collection of {@link Http2FrameStream}s.
  */
 @UnstableApi
-public interface Http2Stream2Visitor {
+public interface Http2FrameStreamVisitor {
 
     /**
      * This method is called once for each stream of the collection.
@@ -34,5 +34,5 @@ public interface Http2Stream2Visitor {
      *         <li>{@code false} if the visitor wants to stop handling the stream and abort the loop.</li>
      *         </ul>
      */
-    boolean visit(Http2Stream2 stream);
+    boolean visit(Http2FrameStream stream);
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
Patch:
@@ -36,5 +36,5 @@ public interface Http2HeadersFrame extends Http2StreamFrame {
     /**
      * Returns {@code true} if the END_STREAM flag ist set.
      */
-    boolean endStream();
+    boolean isEndStream();
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerDowngrader.java
Patch:
@@ -70,7 +70,7 @@ protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Ob
             Http2HeadersFrame headersFrame = (Http2HeadersFrame) frame;
             Http2Headers headers = headersFrame.headers();
 
-            if (headersFrame.endStream()) {
+            if (headersFrame.isEndStream()) {
                 if (headers.method() == null) {
                     LastHttpContent last = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);
                     HttpConversionUtil.addHttp2ToHttpHeaders(id, headers, last.trailingHeaders(),
@@ -90,7 +90,7 @@ protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Ob
             }
         } else if (frame instanceof Http2DataFrame) {
             Http2DataFrame dataFrame = (Http2DataFrame) frame;
-            if (dataFrame.endStream()) {
+            if (dataFrame.isEndStream()) {
                 out.add(new DefaultLastHttpContent(dataFrame.content(), validateHeaders));
             } else {
                 out.add(new DefaultHttpContent(dataFrame.content()));

File: codec-http2/src/test/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandlerTest.java
Patch:
@@ -184,8 +184,8 @@ public void downgrade() throws Exception {
     }
 
     @Test
-    public void usedHttp2Codec() throws Exception {
-        final Http2Codec http2Codec = new Http2CodecBuilder(true, new ChannelInitializer<Channel>() {
+    public void usedHttp2MultiplexCodec() throws Exception {
+        final Http2MultiplexCodec http2Codec = new Http2MultiplexCodecBuilder(true, new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {
             }
@@ -196,7 +196,7 @@ public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
                 return new Http2ServerUpgradeCodec(http2Codec);
             }
         };
-        http2ConnectionHandler = http2Codec.frameCodec().connectionHandler();
+        http2ConnectionHandler = http2Codec;
 
         userEvents = new ArrayList<Object>();
 

File: example/src/main/java/io/netty/example/http2/helloworld/frame/server/Http2OrHttpHandler.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpServerCodec;
 import io.netty.handler.codec.http2.Http2FrameCodec;
+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;
 
@@ -37,7 +38,7 @@ protected Http2OrHttpHandler() {
     @Override
     protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {
         if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {
-            ctx.pipeline().addLast(new Http2FrameCodec(true), new HelloWorldHttp2Handler());
+            ctx.pipeline().addLast(Http2FrameCodecBuilder.forServer().build(), new HelloWorldHttp2Handler());
             return;
         }
 

File: example/src/main/java/io/netty/example/http2/helloworld/frame/server/Http2ServerInitializer.java
Patch:
@@ -30,7 +30,7 @@
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodec;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodecFactory;
 import io.netty.handler.codec.http2.Http2CodecUtil;
-import io.netty.handler.codec.http2.Http2FrameCodec;
+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.AsciiString;
@@ -46,7 +46,8 @@ public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
         @Override
         public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
             if (AsciiString.contentEquals(Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME, protocol)) {
-                return new Http2ServerUpgradeCodec(new Http2FrameCodec(true), new HelloWorldHttp2Handler());
+                return new Http2ServerUpgradeCodec(
+                        Http2FrameCodecBuilder.forServer().build(), new HelloWorldHttp2Handler());
             } else {
                 return null;
             }

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java
Patch:
@@ -69,7 +69,7 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
      * If receive a frame with end-of-stream set, send a pre-canned response.
      */
     private static void onDataRead(ChannelHandlerContext ctx, Http2DataFrame data) throws Exception {
-        if (data.endStream()) {
+        if (data.isEndStream()) {
             sendResponse(ctx, data.content());
         } else {
             // We do not send back the response to the remote-peer, so we need to release it.
@@ -82,7 +82,7 @@ private static void onDataRead(ChannelHandlerContext ctx, Http2DataFrame data) t
      */
     private static void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame headers)
             throws Exception {
-        if (headers.endStream()) {
+        if (headers.isEndStream()) {
             ByteBuf content = ctx.alloc().buffer();
             content.writeBytes(RESPONSE_BYTES.duplicate());
             ByteBufUtil.writeAscii(content, " - via HTTP/2");

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2OrHttpHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.example.http2.helloworld.server.HelloWorldHttp1Handler;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpServerCodec;
-import io.netty.handler.codec.http2.Http2CodecBuilder;
+import io.netty.handler.codec.http2.Http2MultiplexCodecBuilder;
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;
 
@@ -37,7 +37,7 @@ protected Http2OrHttpHandler() {
     @Override
     protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {
         if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {
-            ctx.pipeline().addLast(new Http2CodecBuilder(true, new HelloWorldHttp2Handler()).build());
+            ctx.pipeline().addLast(Http2MultiplexCodecBuilder.forServer(new HelloWorldHttp2Handler()).build());
             return;
         }
 

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2ServerInitializer.java
Patch:
@@ -29,7 +29,7 @@
 import io.netty.handler.codec.http.HttpServerUpgradeHandler;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodec;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodecFactory;
-import io.netty.handler.codec.http2.Http2CodecBuilder;
+import io.netty.handler.codec.http2.Http2MultiplexCodecBuilder;
 import io.netty.handler.codec.http2.Http2CodecUtil;
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
@@ -46,7 +46,8 @@ public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
         @Override
         public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
             if (AsciiString.contentEquals(Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME, protocol)) {
-                return new Http2ServerUpgradeCodec(new Http2CodecBuilder(true, new HelloWorldHttp2Handler()).build());
+                return new Http2ServerUpgradeCodec(
+                        Http2MultiplexCodecBuilder.forServer(new HelloWorldHttp2Handler()).build());
             } else {
                 return null;
             }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -78,13 +78,12 @@
 public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2ConnectionHandler,
                                                             B extends AbstractHttp2ConnectionHandlerBuilder<T, B>> {
 
-    private static final long DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS = MILLISECONDS.convert(30, SECONDS);
     private static final SensitivityDetector DEFAULT_HEADER_SENSITIVITY_DETECTOR = Http2HeadersEncoder.NEVER_SENSITIVE;
 
     // The properties that can always be set.
     private Http2Settings initialSettings = Http2Settings.defaultSettings();
     private Http2FrameListener frameListener;
-    private long gracefulShutdownTimeoutMillis = DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;
+    private long gracefulShutdownTimeoutMillis = Http2CodecUtil.DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;
 
     // The property that will prohibit connection() and codec() if set by server(),
     // because this property is used only when this builder creates a Http2Connection.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2WindowUpdateFrame.java
Patch:
@@ -32,8 +32,8 @@ public DefaultHttp2WindowUpdateFrame(int windowUpdateIncrement) {
     }
 
     @Override
-    public DefaultHttp2WindowUpdateFrame streamId(int streamId) {
-        super.streamId(streamId);
+    public DefaultHttp2WindowUpdateFrame stream(Http2Stream2 stream) {
+        super.stream(stream);
         return this;
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerDowngrader.java
Patch:
@@ -70,7 +70,7 @@ protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Ob
             Http2HeadersFrame headersFrame = (Http2HeadersFrame) frame;
             Http2Headers headers = headersFrame.headers();
 
-            if (headersFrame.isEndStream()) {
+            if (headersFrame.endStream()) {
                 if (headers.method() == null) {
                     LastHttpContent last = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);
                     HttpConversionUtil.addHttp2ToHttpHeaders(id, headers, last.trailingHeaders(),
@@ -90,7 +90,7 @@ protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Ob
             }
         } else if (frame instanceof Http2DataFrame) {
             Http2DataFrame dataFrame = (Http2DataFrame) frame;
-            if (dataFrame.isEndStream()) {
+            if (dataFrame.endStream()) {
                 out.add(new DefaultLastHttpContent(dataFrame.content(), validateHeaders));
             } else {
                 out.add(new DefaultHttpContent(dataFrame.content()));

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java
Patch:
@@ -69,7 +69,7 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
      * If receive a frame with end-of-stream set, send a pre-canned response.
      */
     private static void onDataRead(ChannelHandlerContext ctx, Http2DataFrame data) throws Exception {
-        if (data.isEndStream()) {
+        if (data.endStream()) {
             sendResponse(ctx, data.content());
         } else {
             // We do not send back the response to the remote-peer, so we need to release it.
@@ -82,7 +82,7 @@ private static void onDataRead(ChannelHandlerContext ctx, Http2DataFrame data) t
      */
     private static void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame headers)
             throws Exception {
-        if (headers.isEndStream()) {
+        if (headers.endStream()) {
             ByteBuf content = ctx.alloc().buffer();
             content.writeBytes(RESPONSE_BYTES.duplicate());
             ByteBufUtil.writeAscii(content, " - via HTTP/2");

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 
@@ -49,6 +50,7 @@ final class DefaultRxtxChannelConfig extends DefaultChannelConfig implements Rxt
 
     DefaultRxtxChannelConfig(RxtxChannel channel) {
         super(channel);
+        setAllocator(new PreferHeapByteBufAllocator(getAllocator()));
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
+import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.Future;

File: transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
+import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.ServerChannel;
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.concurrent.SingleThreadEventExecutor;

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioDatagramChannelConfig.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.DatagramChannel;
@@ -36,6 +37,7 @@ final class DefaultOioDatagramChannelConfig extends DefaultDatagramChannelConfig
 
     DefaultOioDatagramChannelConfig(DatagramChannel channel, DatagramSocket javaSocket) {
         super(channel, javaSocket);
+        setAllocator(new PreferHeapByteBufAllocator(getAllocator()));
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.DefaultServerSocketChannelConfig;
@@ -39,10 +40,12 @@ public class DefaultOioServerSocketChannelConfig extends DefaultServerSocketChan
     @Deprecated
     public DefaultOioServerSocketChannelConfig(ServerSocketChannel channel, ServerSocket javaSocket) {
         super(channel, javaSocket);
+        setAllocator(new PreferHeapByteBufAllocator(getAllocator()));
     }
 
     DefaultOioServerSocketChannelConfig(OioServerSocketChannel channel, ServerSocket javaSocket) {
         super(channel, javaSocket);
+        setAllocator(new PreferHeapByteBufAllocator(getAllocator()));
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.PreferHeapByteBufAllocator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.channel.socket.DefaultSocketChannelConfig;
@@ -37,10 +38,12 @@ public class DefaultOioSocketChannelConfig extends DefaultSocketChannelConfig im
     @Deprecated
     public DefaultOioSocketChannelConfig(SocketChannel channel, Socket javaSocket) {
         super(channel, javaSocket);
+        setAllocator(new PreferHeapByteBufAllocator(getAllocator()));
     }
 
     DefaultOioSocketChannelConfig(OioSocketChannel channel, Socket javaSocket) {
         super(channel, javaSocket);
+        setAllocator(new PreferHeapByteBufAllocator(getAllocator()));
     }
 
     @Override

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java
Patch:
@@ -74,7 +74,7 @@ public String willTopic() {
      */
     @Deprecated
     public String willMessage() {
-        return new String(willMessage, CharsetUtil.UTF_8);
+        return willMessage == null ? null : new String(willMessage, CharsetUtil.UTF_8);
     }
 
     public byte[] willMessageInBytes() {
@@ -90,7 +90,7 @@ public String userName() {
      */
     @Deprecated
     public String password() {
-        return new String(password, CharsetUtil.UTF_8);
+        return password == null ? null : new String(password, CharsetUtil.UTF_8);
     }
 
     public byte[] passwordInBytes() {

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageBuilders.java
Patch:
@@ -125,7 +125,7 @@ public ConnectBuilder willTopic(String willTopic) {
          */
         @Deprecated
         public ConnectBuilder willMessage(String willMessage) {
-            willMessage(willMessage.getBytes(CharsetUtil.UTF_8));
+            willMessage(willMessage == null ? null : willMessage.getBytes(CharsetUtil.UTF_8));
             return this;
         }
 
@@ -160,7 +160,7 @@ public ConnectBuilder username(String username) {
          */
         @Deprecated
         public ConnectBuilder password(String password) {
-            password(password.getBytes(CharsetUtil.UTF_8));
+            password(password == null ? null : password.getBytes(CharsetUtil.UTF_8));
             return this;
         }
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -935,7 +935,6 @@ private static boolean isWindows0() {
     private static boolean isOsx0() {
         String osname = SystemPropertyUtil.get("os.name", "").toLowerCase(Locale.US)
                 .replaceAll("[^a-z0-9]+", "");
-        System.err.println("osname=" + osname);
         boolean osx = osname.startsWith("macosx") || osname.startsWith("osx");
 
         if (osx) {

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -933,7 +933,9 @@ private static boolean isWindows0() {
     }
 
     private static boolean isOsx0() {
-        String osname = SystemPropertyUtil.get("os.name", "").toLowerCase(Locale.US);
+        String osname = SystemPropertyUtil.get("os.name", "").toLowerCase(Locale.US)
+                .replaceAll("[^a-z0-9]+", "");
+        System.err.println("osname=" + osname);
         boolean osx = osname.startsWith("macosx") || osname.startsWith("osx");
 
         if (osx) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java
Patch:
@@ -62,19 +62,19 @@ private Http2FrameLogger(InternalLogLevel level, InternalLogger logger) {
 
     public void logData(Direction direction, ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
             boolean endStream) {
-        logger.log(level, "{} {} PRIORITY: streamId={} padding={} endStream={} length={} bytes={}", ctx.channel(),
+        logger.log(level, "{} {} DATA: streamId={} padding={} endStream={} length={} bytes={}", ctx.channel(),
                 direction.name(), streamId, padding, endStream, data.readableBytes(), toString(data));
     }
 
     public void logHeaders(Direction direction, ChannelHandlerContext ctx, int streamId, Http2Headers headers,
             int padding, boolean endStream) {
-        logger.log(level, "{} {} PRIORITY: streamId={} headers={} padding={} endStream={}", ctx.channel(),
+        logger.log(level, "{} {} HEADERS: streamId={} headers={} padding={} endStream={}", ctx.channel(),
                 direction.name(), streamId, headers, padding, endStream);
     }
 
     public void logHeaders(Direction direction, ChannelHandlerContext ctx, int streamId, Http2Headers headers,
             int streamDependency, short weight, boolean exclusive, int padding, boolean endStream) {
-        logger.log(level, "{} {} PRIORITY: streamId={} headers={} streamDependency={} weight={} exclusive={} " +
+        logger.log(level, "{} {} HEADERS: streamId={} headers={} streamDependency={} weight={} exclusive={} " +
                         "padding={} endStream={}", ctx.channel(),
                 direction.name(), streamId, headers, streamDependency, weight, exclusive, padding, endStream);
     }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -545,6 +545,7 @@ protected Object filterOutboundMessage(Object msg) {
     private void shutdownOutput0(final ChannelPromise promise) {
         try {
             socket.shutdown(false, true);
+            ((AbstractUnsafe) unsafe()).shutdownOutput();
             promise.setSuccess();
         } catch (Throwable cause) {
             promise.setFailure(cause);
@@ -563,6 +564,7 @@ private void shutdownInput0(final ChannelPromise promise) {
     private void shutdown0(final ChannelPromise promise) {
         try {
             socket.shutdown(true, true);
+            ((AbstractUnsafe) unsafe()).shutdownOutput();
             promise.setSuccess();
         } catch (Throwable cause) {
             promise.setFailure(cause);

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java
Patch:
@@ -373,6 +373,7 @@ protected Object filterOutboundMessage(Object msg) {
     private void shutdownOutput0(final ChannelPromise promise) {
         try {
             socket.shutdown(false, true);
+            ((AbstractUnsafe) unsafe()).shutdownOutput();
             promise.setSuccess();
         } catch (Throwable cause) {
             promise.setFailure(cause);
@@ -391,6 +392,7 @@ private void shutdownInput0(final ChannelPromise promise) {
     private void shutdown0(final ChannelPromise promise) {
         try {
             socket.shutdown(true, true);
+            ((AbstractUnsafe) unsafe()).shutdownOutput();
             promise.setSuccess();
         } catch (Throwable cause) {
             promise.setFailure(cause);

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -259,6 +259,7 @@ private void shutdownOutput0() throws Exception {
         } else {
             javaChannel().socket().shutdownOutput();
         }
+        ((AbstractUnsafe) unsafe()).shutdownOutput();
     }
 
     private void shutdownInput0(final ChannelPromise promise) {

File: handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java
Patch:
@@ -22,7 +22,7 @@
  * The {@link JdkApplicationProtocolNegotiator} to use if you need ALPN and are using {@link SslProvider#JDK}.
  */
 public final class JdkAlpnApplicationProtocolNegotiator extends JdkBaseApplicationProtocolNegotiator {
-    private static final boolean AVAILABLE = ConscryptAlpnSslEngine.isAvailable() || JettyAlpnSslEngine.isAvailable();
+    private static final boolean AVAILABLE = Conscrypt.isAvailable() || JettyAlpnSslEngine.isAvailable();
     private static final SslEngineWrapperFactory ALPN_WRAPPER = AVAILABLE ? new AlpnWrapper() : new FailureWrapper();
 
     /**
@@ -122,7 +122,7 @@ private static final class AlpnWrapper implements SslEngineWrapperFactory {
         @Override
         public SSLEngine wrapSslEngine(SSLEngine engine, ByteBufAllocator alloc,
                                        JdkApplicationProtocolNegotiator applicationNegotiator, boolean isServer) {
-            if (ConscryptAlpnSslEngine.isEngineSupported(engine)) {
+            if (Conscrypt.isEngineSupported(engine)) {
                 return isServer ? ConscryptAlpnSslEngine.newServerEngine(engine, alloc, applicationNegotiator)
                         : ConscryptAlpnSslEngine.newClientEngine(engine, alloc, applicationNegotiator);
             }

File: handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java
Patch:
@@ -46,7 +46,7 @@ public ConscryptJdkSslEngineInteropTest(BufferType type) {
 
     @BeforeClass
     public static void checkConscrypt() {
-        assumeTrue(ConscryptAlpnSslEngine.isAvailable());
+        assumeTrue(Conscrypt.isAvailable());
     }
 
     @Override

File: handler/src/test/java/io/netty/handler/ssl/JdkConscryptSslEngineInteropTest.java
Patch:
@@ -46,7 +46,7 @@ public JdkConscryptSslEngineInteropTest(BufferType type) {
 
     @BeforeClass
     public static void checkConscrypt() {
-        assumeTrue(ConscryptAlpnSslEngine.isAvailable());
+        assumeTrue(Conscrypt.isAvailable());
     }
 
     @Override

File: handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
Patch:
@@ -81,7 +81,7 @@ Provider provider() {
 
             @Override
             boolean isAvailable() {
-                return ConscryptAlpnSslEngine.isAvailable();
+                return Conscrypt.isAvailable();
             }
 
             @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -127,7 +127,7 @@ public Http2FrameCodec(boolean server) {
      * @param server {@code true} this is a server
      */
     public Http2FrameCodec(boolean server, Http2FrameLogger frameLogger) {
-        this(server, new DefaultHttp2FrameWriter(), frameLogger, new Http2Settings());
+        this(server, new DefaultHttp2FrameWriter(), frameLogger, Http2Settings.defaultSettings());
     }
 
     // Visible for testing

File: codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java
Patch:
@@ -204,7 +204,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                     currentState = State.INIT_BLOCK;
                     success = true;
                 } finally {
-                    if (!success) {
+                    if (!success && uncompressed != null) {
                         uncompressed.release();
                     }
                 }

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -235,7 +235,6 @@ protected void deallocate() {
                                   int peerPort, boolean jdkCompatibilityMode, boolean leakDetection) {
         super(peerHost, peerPort);
         OpenSsl.ensureAvailability();
-        leak = leakDetection ? leakDetector.track(this) : null;
         this.alloc = checkNotNull(alloc, "alloc");
         apn = (OpenSslApplicationProtocolNegotiator) context.applicationProtocolNegotiator();
         session = new OpenSslSession(context.sessionContext());
@@ -288,6 +287,7 @@ protected void deallocate() {
                 PlatformDependent.throwException(cause);
             }
         }
+        leak = leakDetection ? leakDetector.track(this) : null;
     }
 
     /**

File: transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java
Patch:
@@ -98,7 +98,7 @@ public ChannelPromise addListener(GenericFutureListener<? extends Future<? super
     }
 
     @Override
-    public ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>[] listeners) {
+    public ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         delegate.addListeners(listeners);
         return this;
     }
@@ -110,7 +110,7 @@ public ChannelPromise removeListener(GenericFutureListener<? extends Future<? su
     }
 
     @Override
-    public ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>[] listeners) {
+    public ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         delegate.removeListeners(listeners);
         return this;
     }

File: testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
Patch:
@@ -92,7 +92,7 @@ public void initChannel(SctpChannel c) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java
Patch:
@@ -58,7 +58,7 @@ public void testSuspendAndResumeAccept(ServerBootstrap sb) throws Throwable {
             long startTime = System.nanoTime();
             for (int i = 0; i < NUM_CHANNELS; i ++) {
                 Socket s = new Socket();
-                SocketUtils.connect(s, addr, 10000);
+                SocketUtils.connect(s, sc.localAddress(), 10000);
                 sockets.add(s);
             }
 
@@ -80,7 +80,7 @@ public void testSuspendAndResumeAccept(ServerBootstrap sb) throws Throwable {
             long startTime = System.nanoTime();
             for (int i = 0; i < NUM_CHANNELS; i ++) {
                 Socket s = new Socket();
-                s.connect(addr, 10000);
+                s.connect(sc.localAddress(), 10000);
                 sockets.add(s);
             }
             long endTime = System.nanoTime();

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java
Patch:
@@ -66,14 +66,13 @@ private static void testAutoReadOffDuringReadOnlyReadsOneTime(boolean readOutsid
 
             serverChannel = sb.bind().syncUninterruptibly().channel();
 
-            cb.remoteAddress(serverChannel.localAddress())
-                    .option(ChannelOption.AUTO_READ, true)
+            cb.option(ChannelOption.AUTO_READ, true)
                     // We want to ensure that we attempt multiple individual read operations per read loop so we can
                     // test the auto read feature being turned off when data is first read.
                     .option(ChannelOption.RCVBUF_ALLOCATOR, new TestRecvByteBufAllocator())
                     .handler(clientInitializer);
 
-            clientChannel = cb.connect().syncUninterruptibly().channel();
+            clientChannel = cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
 
             // 3 bytes means 3 independent reads for TestRecvByteBufAllocator
             clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[3]));

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java
Patch:
@@ -53,7 +53,7 @@ public void testBufRelease(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         cb.handler(clientHandler);
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         // Ensure the server socket accepted the client connection *and* initialized pipeline successfully.
         serverHandler.channelFuture.sync();

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketCancelWriteTest.java
Patch:
@@ -51,7 +51,7 @@ public void testCancelWrite(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         sb.childHandler(sh);
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         ChannelFuture f = cc.write(a);
         assertTrue(f.cancel(false));

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketChannelNotYetConnectedTest.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.socket.SocketChannel;
 import org.junit.Test;
 
-import java.net.InetSocketAddress;
 import java.net.SocketException;
 import java.nio.channels.NotYetConnectedException;
 
@@ -34,7 +33,7 @@ public void testShutdownNotYetConnected() throws Throwable {
 
     public void testShutdownNotYetConnected(Bootstrap cb) throws Throwable {
         SocketChannel ch = (SocketChannel) cb.handler(new ChannelInboundHandlerAdapter())
-                .bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
+                .bind(newSocketAddress()).syncUninterruptibly().channel();
         try {
             try {
                 ch.shutdownInput().syncUninterruptibly();

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketCloseForciblyTest.java
Patch:
@@ -44,7 +44,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
         Channel sc = sb.bind().sync().channel();
 
-        cb.connect().channel().closeFuture().syncUninterruptibly();
+        cb.connect(sc.localAddress()).channel().closeFuture().syncUninterruptibly();
         sc.close().sync();
     }
 }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java
Patch:
@@ -84,7 +84,7 @@ public void testChannelEventsFiredWhenClosedDirectly(ServerBootstrap sb, Bootstr
         Channel cc = null;
         try {
             sb.childHandler(new ChannelInboundHandlerAdapter());
-            sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();
+            sc = sb.bind().syncUninterruptibly().channel();
 
             cb.handler(new ChannelInboundHandlerAdapter() {
                 @Override

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -155,7 +155,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         cb.option(ChannelOption.AUTO_READ, autoRead);
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketExceptionHandlingTest.java
Patch:
@@ -50,9 +50,8 @@ public void testReadPendingIsResetAfterEachRead(ServerBootstrap sb, Bootstrap cb
 
             serverChannel = sb.bind().syncUninterruptibly().channel();
 
-            cb.remoteAddress(serverChannel.localAddress())
-              .handler(new MyInitializer());
-            clientChannel = cb.connect().syncUninterruptibly().channel();
+            cb.handler(new MyInitializer());
+            clientChannel = cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
 
             clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[1024]));
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
Patch:
@@ -146,7 +146,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 
         Channel sc = sb.bind().sync().channel();
 
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
         FileRegion region = new DefaultFileRegion(
                 new FileInputStream(file).getChannel(), startOffset, data.length - bufferSize);
         FileRegion emptyRegion = new DefaultFileRegion(new FileInputStream(file).getChannel(), 0, 0);

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
Patch:
@@ -83,7 +83,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 3), data.length - i);
             cc.writeAndFlush(Unpooled.wrappedBuffer(data, i, length));

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
Patch:
@@ -115,7 +115,7 @@ private void testGatheringWrite0(
         sb.childHandler(sh);
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 8), data.length - i);

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketMultipleConnectTest.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.testsuite.transport.TestsuitePermutation;
-import io.netty.testsuite.util.TestUtils;
 import io.netty.util.NetUtil;
 import org.junit.Test;
 
@@ -44,7 +43,7 @@ public void testMultipleConnect(ServerBootstrap sb, Bootstrap cb) throws Excepti
         Channel cc = null;
         try {
             sb.childHandler(new ChannelInboundHandlerAdapter());
-            sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();
+            sc = sb.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();
 
             cb.handler(new ChannelInboundHandlerAdapter());
             cc = cb.register().syncUninterruptibly().channel();

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
Patch:
@@ -96,7 +96,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
         for (String element : data) {
             cc.writeAndFlush(element);
         }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketReadPendingTest.java
Patch:
@@ -60,12 +60,11 @@ public void testReadPendingIsResetAfterEachRead(ServerBootstrap sb, Bootstrap cb
 
             serverChannel = sb.bind().syncUninterruptibly().channel();
 
-            cb.remoteAddress(serverChannel.localAddress())
-              .option(ChannelOption.AUTO_READ, false)
+            cb.option(ChannelOption.AUTO_READ, false)
               // We intend to do 2 reads per read loop wakeup
               .option(ChannelOption.RCVBUF_ALLOCATOR, new TestNumReadsRecvByteBufAllocator(2))
               .handler(clientInitializer);
-            clientChannel = cb.connect().syncUninterruptibly().channel();
+            clientChannel = cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
 
             // 4 bytes means 2 read loops for TestNumReadsRecvByteBufAllocator
             clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[4]));

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
Patch:
@@ -194,10 +194,10 @@ public void initChannel(SocketChannel channel) throws Exception {
 
         cb.handler(ch);
 
-        Channel sc = sb.localAddress(0).bind().sync().channel();
+        Channel sc = sb.bind().sync().channel();
         int port = ((InetSocketAddress) sc.localAddress()).getPort();
 
-        Channel cc = cb.remoteAddress(NetUtil.LOCALHOST, port).connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
         cc.writeAndFlush(frames);
 
         while (ch.counter < frames.writerIndex() - ignoredBytes) {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslClientRenegotiateTest.java
Patch:
@@ -155,7 +155,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        cb.connect().sync();
+        cb.connect(sc.localAddress()).sync();
 
         Future<Channel> clientHandshakeFuture = clientSslHandler.handshakeFuture();
         clientHandshakeFuture.sync();

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -280,7 +280,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         final Channel sc = sb.bind().sync().channel();
-        cb.connect().sync();
+        cb.connect(sc.localAddress()).sync();
 
         final Future<Channel> clientHandshakeFuture = clientSslHandler.handshakeFuture();
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
Patch:
@@ -140,7 +140,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         ch.latch.await();
 

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -174,7 +174,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         while (cc.isActive()) {
             if (sh.exception.get() != null) {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
Patch:
@@ -98,7 +98,7 @@ public void initChannel(Channel sch) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
         for (String element : data) {
             String delimiter = random.nextBoolean() ? "\r\n" : "\n";
             cc.writeAndFlush(element + delimiter);

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java
Patch:
@@ -324,7 +324,7 @@ protected void initChannel(SocketChannel c) throws Exception {
         });
 
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         int totalNb = 0;
         for (int i = 1; i < multipleMessage.length; i++) {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
Patch:
@@ -33,7 +33,7 @@ public void testWriteBeforeConnect(Bootstrap cb) throws Throwable {
         TestHandler h = new TestHandler();
         SocketChannel ch = null;
         try {
-            ch = (SocketChannel) cb.handler(h).connect().channel();
+            ch = (SocketChannel) cb.handler(h).connect(newSocketAddress()).channel();
             ch.writeAndFlush(Unpooled.wrappedBuffer(new byte[] { 1 }));
         } finally {
             if (ch != null) {

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketFdTest.java
Patch:
@@ -86,7 +86,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         cb.option(EpollChannelOption.DOMAIN_SOCKET_READ_MODE,
                 DomainSocketReadMode.FILE_DESCRIPTORS);
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         Object received = queue.take();
         cc.close().sync();

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSpliceTest.java
Patch:
@@ -59,7 +59,7 @@ public void spliceToSocket() throws Throwable {
         ServerBootstrap bs = new ServerBootstrap();
         bs.channel(EpollServerSocketChannel.class);
         bs.group(group).childHandler(sh);
-        final Channel sc = bs.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();
+        final Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();
 
         ServerBootstrap bs2 = new ServerBootstrap();
         bs2.channel(EpollServerSocketChannel.class);
@@ -125,7 +125,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 });
             }
         });
-        Channel pc = bs2.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();
+        Channel pc = bs2.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();
 
         Bootstrap cb = new Bootstrap();
         cb.group(group);
@@ -201,7 +201,7 @@ public void spliceToFile() throws Throwable {
         bs.channel(EpollServerSocketChannel.class);
         bs.group(group).childHandler(sh);
         bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);
-        Channel sc = bs.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();
+        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();
 
         Bootstrap cb = new Bootstrap();
         cb.group(group);

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDomainSocketFdTest.java
Patch:
@@ -85,7 +85,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         cb.option(KQueueChannelOption.DOMAIN_SOCKET_READ_MODE,
                 DomainSocketReadMode.FILE_DESCRIPTORS);
         Channel sc = sb.bind().sync().channel();
-        Channel cc = cb.connect().sync().channel();
+        Channel cc = cb.connect(sc.localAddress()).sync().channel();
 
         Object received = queue.take();
         cc.close().sync();

File: codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
Patch:
@@ -92,7 +92,6 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
         if (this.idx > in.readerIndex() && lastReaderIndex != in.readerIndex()) {
             this.idx = in.readerIndex();
-            reset();
         }
 
         // index of next byte to process.

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java
Patch:
@@ -63,6 +63,7 @@ private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {
                 .nameServerProvider(
                         new SingletonDnsServerAddressStreamProvider(SocketUtils.socketAddress("8.8.8.8", 53)))
                 .maxQueriesPerResolve(1)
-                .optResourceEnabled(false);
+                .optResourceEnabled(false)
+                .ndots(1);
     }
 }

File: resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
Patch:
@@ -48,7 +48,8 @@ private DnsNameResolverBuilder newResolver() {
             .channelType(NioDatagramChannel.class)
             .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress()))
             .maxQueriesPerResolve(1)
-            .optResourceEnabled(false);
+            .optResourceEnabled(false)
+            .ndots(1);
     }
 
     private TestDnsServer dnsServer;

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -235,7 +235,6 @@ protected void deallocate() {
         } finally {
             readerLock.unlock();
         }
-        ssl = SSL.newSSL(context.ctx, !context.isClient());
         try {
             networkBIO = SSL.bioNewByteBuffer(ssl, context.getBioNonApplicationBufferSize());
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
Patch:
@@ -171,7 +171,8 @@ void remove(AbstractEpollChannel ch) throws IOException {
     @Override
     protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
         // This event loop never calls takeTask()
-        return PlatformDependent.newMpscQueue(maxPendingTasks);
+        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue()
+                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);
     }
 
     @Override

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java
Patch:
@@ -298,7 +298,8 @@ protected void run() {
     @Override
     protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
         // This event loop never calls takeTask()
-        return PlatformDependent.newMpscQueue(maxPendingTasks);
+        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue()
+                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -256,7 +256,8 @@ public SelectorProvider selectorProvider() {
     @Override
     protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
         // This event loop never calls takeTask()
-        return PlatformDependent.newMpscQueue(maxPendingTasks);
+        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue()
+                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);
     }
 
     @Override

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -693,7 +693,8 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
 
                                 @Override
                                 public void channelInactive(ChannelHandlerContext ctx) {
-                                    donePromise.tryFailure(new IllegalStateException("client closed"));
+                                    donePromise.tryFailure(new IllegalStateException("client closed. bytesSeen: " +
+                                                                                     bytesSeen));
                                 }
                             });
                         }

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -880,7 +880,6 @@ public final ChannelPromise voidPromise() {
             return unsafeVoidPromise;
         }
 
-        @Deprecated
         protected final boolean ensureOpen(ChannelPromise promise) {
             if (isOpen()) {
                 return true;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderNames.java
Patch:
@@ -147,7 +147,7 @@ public final class HttpHeaderNames {
     /**
      * {@code "content-security-policy"}
      */
-    public static final CharSequence CONTENT_SECURITY_POLICY = new AsciiString("content-security-policy");
+    public static final AsciiString CONTENT_SECURITY_POLICY = new AsciiString("content-security-policy");
     /**
      * {@code "content-type"}
      */
@@ -353,7 +353,7 @@ public final class HttpHeaderNames {
     /**
      * {@code "x-frame-options"}
      */
-    public static final CharSequence X_FRAME_OPTIONS = new AsciiString("x-frame-options");
+    public static final AsciiString X_FRAME_OPTIONS = new AsciiString("x-frame-options");
 
     private HttpHeaderNames() { }
 }

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -389,7 +389,7 @@ private static void loadTcNative() throws Exception {
         String os = normalizeOs(SystemPropertyUtil.get("os.name", ""));
         String arch = normalizeArch(SystemPropertyUtil.get("os.arch", ""));
 
-        Set<String> libNames = new LinkedHashSet<String>(3);
+        Set<String> libNames = new LinkedHashSet<String>(4);
         // First, try loading the platform-specific library. Platform-specific
         // libraries will be available if using a tcnative uber jar.
         libNames.add("netty-tcnative-" + os + '-' + arch);
@@ -399,6 +399,8 @@ private static void loadTcNative() throws Exception {
         }
         // finally the default library.
         libNames.add("netty-tcnative");
+        // in Java 8, statically compiled JNI code is namespaced
+        libNames.add("netty_tcnative");
 
         NativeLibraryLoader.loadFirstAvailable(SSL.class.getClassLoader(),
             libNames.toArray(new String[libNames.size()]));

File: handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
Patch:
@@ -156,7 +156,8 @@ public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date no
                 logger.debug("Failed to generate a self-signed X.509 certificate using Bouncy Castle:", t2);
                 throw new CertificateException(
                         "No provider succeeded to generate a self-signed certificate. " +
-                                "See debug log for the root cause.");
+                                "See debug log for the root cause.", t2);
+                // TODO: consider using Java 7 addSuppressed to append t
             }
         }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
Patch:
@@ -284,8 +284,8 @@ protected void run() {
                         if (wakenUp == 1) {
                             Native.eventFdWrite(eventFd.intValue(), 1L);
                         }
-                    default:
                         // fallthrough
+                    default:
                 }
 
                 final int ioRatio = this.ioRatio;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -55,7 +55,7 @@ public final class DnsNameResolverBuilder {
     private DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory =
             NoopDnsQueryLifecycleObserverFactory.INSTANCE;
     private String[] searchDomains;
-    private int ndots = 1;
+    private int ndots = -1;
     private boolean decodeIdn = true;
 
     /**

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/UnixChannelUtilTest.java
Patch:
@@ -47,16 +47,15 @@ public void testUnPooledAllocatorIsBufferCopyNeededForWrite() {
     private static void testIsBufferCopyNeededForWrite(ByteBufAllocator alloc) {
         ByteBuf byteBuf = alloc.directBuffer();
         assertFalse(isBufferCopyNeededForWrite(byteBuf));
-        assertTrue(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));
-
+        assertFalse(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));
         assertTrue(byteBuf.release());
 
         byteBuf = alloc.heapBuffer();
         assertTrue(isBufferCopyNeededForWrite(byteBuf));
         assertTrue(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));
         assertTrue(byteBuf.release());
 
-        assertCompositeByteBufIsBufferCopyNeededForWrite(alloc, 2, 0, false);
+        assertCompositeByteBufIsBufferCopyNeededForWrite(alloc, 2, 0, true);
         assertCompositeByteBufIsBufferCopyNeededForWrite(alloc, IOV_MAX + 1, 0, true);
         assertCompositeByteBufIsBufferCopyNeededForWrite(alloc, 0, 2, true);
         assertCompositeByteBufIsBufferCopyNeededForWrite(alloc, 1, 1, true);

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -195,6 +195,7 @@ protected DnsServerAddressStream initialValue() throws Exception {
      * @param dnsServerAddressStreamProvider The {@link DnsServerAddressStreamProvider} used to determine the name
      *                                       servers for each hostname lookup.
      * @param searchDomains the list of search domain
+     *                      (can be null, if so, will try to default to the underlying platform ones)
      * @param ndots the ndots value
      * @param decodeIdn {@code true} if domain / host names should be decoded to unicode when received.
      *                        See <a href="https://tools.ietf.org/html/rfc3492">rfc3492</a>.
@@ -232,7 +233,7 @@ public DnsNameResolver(
         this.authoritativeDnsServerCache = checkNotNull(authoritativeDnsServerCache, "authoritativeDnsServerCache");
         this.dnsQueryLifecycleObserverFactory =
                 checkNotNull(dnsQueryLifecycleObserverFactory, "dnsQueryLifecycleObserverFactory");
-        this.searchDomains = checkNotNull(searchDomains, "searchDomains").clone();
+        this.searchDomains = searchDomains != null ? searchDomains.clone() : DEFAULT_SEARCH_DOMAINS;
         this.ndots = checkPositiveOrZero(ndots, "ndots");
         this.decodeIdn = decodeIdn;
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -54,7 +54,7 @@ public final class DnsNameResolverBuilder {
     private DnsServerAddressStreamProvider dnsServerAddressStreamProvider = platformDefault();
     private DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory =
             NoopDnsQueryLifecycleObserverFactory.INSTANCE;
-    private String[] searchDomains = DnsNameResolver.DEFAULT_SEARCH_DOMAINS;
+    private String[] searchDomains;
     private int ndots = 1;
     private boolean decodeIdn = true;
 

File: transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/UnixChannelUtilTest.java
Patch:
@@ -47,10 +47,13 @@ public void testUnPooledAllocatorIsBufferCopyNeededForWrite() {
     private static void testIsBufferCopyNeededForWrite(ByteBufAllocator alloc) {
         ByteBuf byteBuf = alloc.directBuffer();
         assertFalse(isBufferCopyNeededForWrite(byteBuf));
+        assertTrue(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));
+
         assertTrue(byteBuf.release());
 
         byteBuf = alloc.heapBuffer();
         assertTrue(isBufferCopyNeededForWrite(byteBuf));
+        assertTrue(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));
         assertTrue(byteBuf.release());
 
         assertCompositeByteBufIsBufferCopyNeededForWrite(alloc, 2, 0, false);

File: transport-native-unix-common/src/main/java/io/netty/channel/unix/UnixChannelUtil.java
Patch:
@@ -29,6 +29,6 @@ private UnixChannelUtil() {
      * (We check this because otherwise we need to make it a new direct buffer.)
      */
     public static boolean isBufferCopyNeededForWrite(ByteBuf byteBuf) {
-        return !(byteBuf.hasMemoryAddress() || byteBuf.isDirect() && byteBuf.nioBufferCount() <= IOV_MAX);
+        return !byteBuf.hasMemoryAddress() || !byteBuf.isDirect() || byteBuf.nioBufferCount() > IOV_MAX;
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/QueryStringDecoderTest.java
Patch:
@@ -205,8 +205,8 @@ public void testUrlDecoding() throws Exception {
             "%42",            "B",
             "%5f",            "_",
             "f%4",            "unterminated escape sequence at index 1 of: f%4",
-            "%x2",            "invalid escape sequence '%x2' at index 0 of: %x2",
-            "%4x",            "invalid escape sequence '%4x' at index 0 of: %4x",
+            "%x2",            "invalid hex byte 'x2' at index 1 of '%x2'",
+            "%4x",            "invalid hex byte '4x' at index 1 of '%4x'",
             "Caff%C3%A9",     caffe,
             " ",               " ",
             "%20",             " ",

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
Patch:
@@ -112,7 +112,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
     private final class HttpServerResponseEncoder extends HttpResponseEncoder {
 
         @Override
-        boolean isContentAlwaysEmpty(@SuppressWarnings("unused") HttpResponse msg) {
+        protected boolean isContentAlwaysEmpty(@SuppressWarnings("unused") HttpResponse msg) {
             return HttpMethod.HEAD.equals(queue.poll());
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -101,7 +101,9 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
     @Override
     protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
         String contentEncoding = headers.headers().get(HttpHeaderNames.CONTENT_ENCODING);
-        if (HttpHeaderValues.IDENTITY.contentEqualsIgnoreCase(contentEncoding)) {
+        if (contentEncoding != null) {
+            // Content-Encoding was set, either as something specific or as the IDENTITY encoding
+            // Therefore, we should NOT encode here
             return null;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java
Patch:
@@ -60,7 +60,7 @@ public static HttpVersion valueOf(String text) {
         text = text.trim();
 
         if (text.isEmpty()) {
-            throw new IllegalArgumentException("text is empty");
+            throw new IllegalArgumentException("text is empty (possibly HTTP/0.9)");
         }
 
         // Try to match without convert to uppercase first as this is what 99% of all clients

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java
Patch:
@@ -53,6 +53,6 @@ public SctpOutboundByteStreamHandler(int streamIdentifier, int protocolIdentifie
 
     @Override
     protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {
-        out.add(new SctpMessage(streamIdentifier, protocolIdentifier, unordered, msg.retain()));
+        out.add(new SctpMessage(protocolIdentifier, streamIdentifier, unordered, msg.retain()));
     }
 }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -114,7 +114,9 @@ protected void doClose() throws Exception {
         // socket which has not even been connected yet. This has been observed to block during unit tests.
         inputClosedSeenErrorOnRead = true;
         try {
-            doDeregister();
+            if (isRegistered()) {
+                doDeregister();
+            }
         } finally {
             socket.close();
         }

File: transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java
Patch:
@@ -101,7 +101,9 @@ protected void doClose() throws Exception {
         // The FD will be closed, which will take of deleting from kqueue.
         readFilterEnabled = writeFilterEnabled = false;
         try {
-            ((KQueueEventLoop) eventLoop()).remove(this);
+            if (isRegistered()) {
+                ((KQueueEventLoop) eventLoop()).remove(this);
+            }
         } finally {
             socket.close();
         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -34,6 +34,7 @@
 import io.netty.channel.PendingWriteQueue;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.concurrent.DefaultPromise;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
@@ -580,8 +581,8 @@ public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
             // Check if queue is not empty first because create a new ChannelException is expensive
             pendingUnencryptedWrites.removeAndFailAll(new ChannelException("Pending write on removal of SslHandler"));
         }
-        if (engine instanceof ReferenceCountedOpenSslEngine) {
-            ((ReferenceCountedOpenSslEngine) engine).release();
+        if (engine instanceof ReferenceCounted) {
+            ((ReferenceCounted) engine).release();
         }
     }
 

File: transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.channel.unix.DomainSocketAddress;
 import io.netty.channel.unix.PeerCredentials;
-import io.netty.channel.unix.Socket;
 import io.netty.channel.unix.tests.SocketTest;
 import io.netty.channel.unix.tests.UnixTestUtils;
 import org.junit.BeforeClass;
@@ -27,11 +26,12 @@
 
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 
 public class KQueueSocketTest extends SocketTest<BsdSocket> {
     @BeforeClass
     public static void loadJNI() {
-        KQueue.isAvailable();
+        assumeTrue(KQueue.isAvailable());
     }
 
     @Test

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
 import io.netty.util.internal.UnstableApi;
 
-import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_RESERVED_STREAMS;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
@@ -79,7 +78,7 @@ public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2Conne
     private static final SensitivityDetector DEFAULT_HEADER_SENSITIVITY_DETECTOR = Http2HeadersEncoder.NEVER_SENSITIVE;
 
     // The properties that can always be set.
-    private Http2Settings initialSettings = new Http2Settings().maxHeaderListSize(DEFAULT_HEADER_LIST_SIZE);
+    private Http2Settings initialSettings = Http2Settings.defaultSettings();
     private Http2FrameListener frameListener;
     private long gracefulShutdownTimeoutMillis = DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java
Patch:
@@ -72,7 +72,7 @@ public void setUp() throws InterruptedException {
                     @Override
                     protected void initChannel(Channel ch) throws Exception {
                         serverConnectedChannel = ch;
-                        ch.pipeline().addLast(new Http2Codec(true, serverLastInboundHandler));
+                        ch.pipeline().addLast(new Http2CodecBuilder(true, serverLastInboundHandler).build());
                         serverChannelLatch.countDown();
                     }
                 });
@@ -81,7 +81,7 @@ protected void initChannel(Channel ch) throws Exception {
         Bootstrap cb = new Bootstrap()
                 .channel(LocalChannel.class)
                 .group(group)
-                .handler(new Http2Codec(false, new TestChannelInitializer()));
+                .handler(new Http2CodecBuilder(false, new TestChannelInitializer()).build());
         clientChannel = cb.connect(serverAddress).sync().channel();
         assertTrue(serverChannelLatch.await(5, SECONDS));
     }

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2OrHttpHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.example.http2.helloworld.server.HelloWorldHttp1Handler;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpServerCodec;
-import io.netty.handler.codec.http2.Http2Codec;
+import io.netty.handler.codec.http2.Http2CodecBuilder;
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;
 
@@ -37,7 +37,7 @@ protected Http2OrHttpHandler() {
     @Override
     protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {
         if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {
-            ctx.pipeline().addLast(new Http2Codec(true, new HelloWorldHttp2Handler()));
+            ctx.pipeline().addLast(new Http2CodecBuilder(true, new HelloWorldHttp2Handler()).build());
             return;
         }
 

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2ServerInitializer.java
Patch:
@@ -29,7 +29,7 @@
 import io.netty.handler.codec.http.HttpServerUpgradeHandler;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodec;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodecFactory;
-import io.netty.handler.codec.http2.Http2Codec;
+import io.netty.handler.codec.http2.Http2CodecBuilder;
 import io.netty.handler.codec.http2.Http2CodecUtil;
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
@@ -46,7 +46,7 @@ public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
         @Override
         public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
             if (AsciiString.contentEquals(Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME, protocol)) {
-                return new Http2ServerUpgradeCodec(new Http2Codec(true, new HelloWorldHttp2Handler()));
+                return new Http2ServerUpgradeCodec(new Http2CodecBuilder(true, new HelloWorldHttp2Handler()).build());
             } else {
                 return null;
             }

File: handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java
Patch:
@@ -61,7 +61,7 @@ protected SslProvider sslServerProvider() {
 
     @Override
     protected Provider clientSslContextProvider() {
-        return Java8SslUtils.conscryptProvider();
+        return Java8SslTestUtils.conscryptProvider();
     }
 
     @Ignore /* Does the JDK support a "max certificate chain length"? */

File: handler/src/test/java/io/netty/handler/ssl/Java8SslTestUtils.java
Patch:
@@ -24,9 +24,9 @@
 import java.security.Provider;
 import java.util.Collections;
 
-final class Java8SslUtils {
+final class Java8SslTestUtils {
 
-    private Java8SslUtils() { }
+    private Java8SslTestUtils() { }
 
     static void setSNIMatcher(SSLParameters parameters) {
         SNIMatcher matcher = new SNIMatcher(0) {

File: handler/src/test/java/io/netty/handler/ssl/JdkConscryptSslEngineInteropTest.java
Patch:
@@ -61,7 +61,7 @@ protected SslProvider sslServerProvider() {
 
     @Override
     protected Provider serverSslContextProvider() {
-        return Java8SslUtils.conscryptProvider();
+        return Java8SslTestUtils.conscryptProvider();
     }
 
     @Override

File: handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java
Patch:
@@ -598,7 +598,7 @@ public void testSNIMatchersDoesNotThrow() throws Exception {
         SSLEngine engine = serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);
         try {
             SSLParameters parameters = new SSLParameters();
-            Java8SslUtils.setSNIMatcher(parameters);
+            Java8SslTestUtils.setSNIMatcher(parameters);
             engine.setSSLParameters(parameters);
         } finally {
             cleanupServerSslEngine(engine);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java
Patch:
@@ -82,7 +82,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
             }
         }
         if (msg instanceof LastHttpContent && !shouldKeepAlive()) {
-            promise.addListener(ChannelFutureListener.CLOSE);
+            promise = promise.unvoid().addListener(ChannelFutureListener.CLOSE);
         }
         super.write(ctx, msg, promise);
     }

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -175,7 +175,7 @@ public Random current() {
 
         MAYBE_SUPER_USER = maybeSuperUser0();
 
-        if (!isAndroid()) {
+        if (!isAndroid() && hasUnsafe()) {
             // only direct to method if we are not running on android.
             // See https://github.com/netty/netty/issues/2604
             if (javaVersion() >= 9) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -101,8 +101,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
     @Override
     protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
         String contentEncoding = headers.headers().get(HttpHeaderNames.CONTENT_ENCODING);
-        if (contentEncoding != null &&
-            !HttpHeaderValues.IDENTITY.contentEqualsIgnoreCase(contentEncoding)) {
+        if (HttpHeaderValues.IDENTITY.contentEqualsIgnoreCase(contentEncoding)) {
             return null;
         }
 

File: common/src/main/java/io/netty/util/internal/EmptyArrays.java
Patch:
@@ -24,6 +24,7 @@
 
 public final class EmptyArrays {
 
+    public static final int[] EMPTY_INTS = {};
     public static final byte[] EMPTY_BYTES = {};
     public static final char[] EMPTY_CHARS = {};
     public static final Object[] EMPTY_OBJECTS = {};

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.WriteBufferWaterMark;
-
 import java.io.IOException;
 import java.util.Map;
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java
Patch:
@@ -24,14 +24,14 @@
 
 class EpollRecvByteAllocatorHandle implements RecvByteBufAllocator.ExtendedHandle {
     private final RecvByteBufAllocator.ExtendedHandle delegate;
-    private boolean isEdgeTriggered;
-    private boolean receivedRdHup;
     private final UncheckedBooleanSupplier defaultMaybeMoreDataSupplier = new UncheckedBooleanSupplier() {
         @Override
         public boolean get() {
             return maybeMoreDataToRead();
         }
     };
+    private boolean isEdgeTriggered;
+    private boolean receivedRdHup;
 
     EpollRecvByteAllocatorHandle(RecvByteBufAllocator.ExtendedHandle handle) {
         this.delegate = ObjectUtil.checkNotNull(handle, "handle");

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/TcpMd5Util.java
Patch:
@@ -55,7 +55,7 @@ static Collection<InetAddress> newTcpMd5Sigs(AbstractEpollChannel channel, Colle
         // Remove mappings not present in the new set.
         for (InetAddress addr : current) {
             if (!newKeys.containsKey(addr)) {
-                Native.setTcpMd5Sig(channel.fd().intValue(), addr, null);
+                channel.socket.setTcpMd5Sig(addr, null);
             }
         }
 
@@ -66,7 +66,7 @@ static Collection<InetAddress> newTcpMd5Sigs(AbstractEpollChannel channel, Colle
         // Set new mappings and store addresses which we set.
         final Collection<InetAddress> addresses = new ArrayList<InetAddress>(newKeys.size());
         for (Entry<InetAddress, byte[]> e : newKeys.entrySet()) {
-            Native.setTcpMd5Sig(channel.fd().intValue(), e.getKey(), e.getValue());
+            channel.socket.setTcpMd5Sig(e.getKey(), e.getValue());
             addresses.add(e.getKey());
         }
 

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollAbstractDomainSocketEchoTest.java
Patch:
@@ -23,6 +23,6 @@ public class EpollAbstractDomainSocketEchoTest extends EpollDomainSocketEchoTest
     @Override
     protected SocketAddress newSocketAddress() {
         // these don't actually show up in the file system so creating a temp file isn't reliable
-        return new DomainSocketAddress("\0/tmp/" + UUID.randomUUID());
+        return new DomainSocketAddress("\0" + System.getProperty("java.io.tmpdir") + UUID.randomUUID());
     }
 }

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -267,7 +267,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
         private static void forceClose(Channel child, Throwable t) {
             child.unsafe().closeForcibly();
-            logger.warn("Failed to register an accepted channel: " + child, t);
+            logger.warn("Failed to register an accepted channel: {}", child, t);
         }
 
         @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
Patch:
@@ -147,8 +147,7 @@ protected String getBaseDirectory() {
 
     @Override
     protected String getDiskFilename() {
-        File file = new File(filename);
-        return file.getName();
+        return "upload";
     }
 
     @Override

File: common/src/main/java/io/netty/util/internal/ConstantTimeUtils.java
Patch:
@@ -95,8 +95,8 @@ public static int equalsConstantTime(byte[] bytes1, int startPos1,
         // Benchmarking demonstrates that using an int to accumulate is faster than other data types.
         int b = 0;
         final int end = startPos1 + length;
-        for (int i = startPos1, j = startPos2; i < end; ++i, ++j) {
-            b |= bytes1[i] ^ bytes2[j];
+        for (; startPos1 < end; ++startPos1, ++startPos2) {
+            b |= bytes1[startPos1] ^ bytes2[startPos2];
         }
         return equalsConstantTime(b, 0);
     }

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -76,7 +76,7 @@ public void recycle(Object object) {
         MAX_DELAYED_QUEUES_PER_THREAD = max(0,
                 SystemPropertyUtil.getInt("io.netty.recycler.maxDelayedQueuesPerThread",
                         // We use the same value as default EventLoop number
-                        Runtime.getRuntime().availableProcessors() * 2));
+                        NettyRuntime.availableProcessors() * 2));
 
         LINK_CAPACITY = safeFindNextPositivePowerOfTwo(
                 max(SystemPropertyUtil.getInt("io.netty.recycler.linkCapacity", 16), 16));

File: common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.util.concurrent;
 
+import io.netty.util.NettyRuntime;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -58,7 +59,7 @@ public NonStickyEventExecutorGroupTest(int maxTaskExecutePerRun) {
 
     @Test(timeout = 10000)
     public void testOrdering() throws Throwable {
-        final int threads = Runtime.getRuntime().availableProcessors() * 2;
+        final int threads = NettyRuntime.availableProcessors() * 2;
         final EventExecutorGroup group = new UnorderedThreadPoolEventExecutor(threads);
         final NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(group, maxTaskExecutePerRun);
         try {

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.channel;
 
+import io.netty.util.NettyRuntime;
 import io.netty.util.concurrent.DefaultThreadFactory;
 import io.netty.util.concurrent.EventExecutorChooserFactory;
 import io.netty.util.concurrent.MultithreadEventExecutorGroup;
@@ -37,7 +38,7 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
 
     static {
         DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
-                "io.netty.eventLoopThreads", Runtime.getRuntime().availableProcessors() * 2));
+                "io.netty.eventLoopThreads", NettyRuntime.availableProcessors() * 2));
 
         if (logger.isDebugEnabled()) {
             logger.debug("-Dio.netty.eventLoopThreads: {}", DEFAULT_EVENT_LOOP_THREADS);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
Patch:
@@ -770,7 +770,7 @@ private void toString(StringBuilder sb) {
                     .append(" flags ").append(flags)
                     .append(" pseudoTimeQueue.size() ").append(pseudoTimeQueue.size())
                     .append(" stateOnlyQueueIndex ").append(stateOnlyQueueIndex)
-                    .append(" parent ").append(parent).append("} [");
+                    .append(" parent.streamId ").append(parent == null ? -1 : parent.streamId).append("} [");
 
             if (!pseudoTimeQueue.isEmpty()) {
                 for (State s : pseudoTimeQueue) {

File: buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
Patch:
@@ -219,7 +219,7 @@ public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {
 
     private static void validate(int initialCapacity, int maxCapacity) {
         if (initialCapacity < 0) {
-            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expectd: 0+)");
+            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");
         }
         if (initialCapacity > maxCapacity) {
             throw new IllegalArgumentException(String.format(
@@ -246,7 +246,7 @@ public String toString() {
     @Override
     public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {
         if (minNewCapacity < 0) {
-            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expectd: 0+)");
+            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");
         }
         if (minNewCapacity > maxCapacity) {
             throw new IllegalArgumentException(String.format(

File: buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
Patch:
@@ -123,7 +123,7 @@ public boolean release(int decrement) {
     }
 
     /**
-     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implemement
+     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement
      * {@link #toString()}.
      */
     protected final String contentToString() {

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -232,7 +232,7 @@ private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int req
         }
     }
 
-    // Method must be called insided synchronized(this) { ... }block
+    // Method must be called inside synchronized(this) { ... }block
     private void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {
         if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||
             q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||

File: buffer/src/main/java/io/netty/buffer/PoolChunkListMetric.java
Patch:
@@ -21,12 +21,12 @@
 public interface PoolChunkListMetric extends Iterable<PoolChunkMetric> {
 
     /**
-     * Return the minum usage of the chunk list before which chunks are promoted to the previous list.
+     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list.
      */
     int minUsage();
 
     /**
-     * Return the minum usage of the chunk list after which chunks are promoted to the next list.
+     * Return the maximum usage of the chunk list after which chunks are promoted to the next list.
      */
     int maxUsage();
 }

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -328,14 +328,14 @@ protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
     }
 
     /**
-     * Default number of heap areanas - System Property: io.netty.allocator.numHeapArenas - default 2 * cores
+     * Default number of heap arenas - System Property: io.netty.allocator.numHeapArenas - default 2 * cores
      */
     public static int defaultNumHeapArena() {
         return DEFAULT_NUM_HEAP_ARENA;
     }
 
     /**
-     * Default numer of direct arenas - System Property: io.netty.allocator.numDirectArenas - default 2 * cores
+     * Default number of direct arenas - System Property: io.netty.allocator.numDirectArenas - default 2 * cores
      */
     public static int defaultNumDirectArena() {
         return DEFAULT_NUM_DIRECT_ARENA;
@@ -377,7 +377,7 @@ public static int defaultNormalCacheSize() {
     }
 
     /**
-     * Return {@code true} if direct memory cache aligment is supported, {@code false} otherwise.
+     * Return {@code true} if direct memory cache alignment is supported, {@code false} otherwise.
      */
     public static boolean isDirectMemoryCacheAlignmentSupported() {
         return PlatformDependent.hasUnsafe();

File: buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
Patch:
@@ -1,7 +1,7 @@
 /*
  * Copyright 2012 The Netty Project
  *
- * The Netty Project licenses this file tothe License at:
+ * The Netty Project licenses this file to the License at:
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -38,7 +38,7 @@
  * {@link ByteBuf} heapBuffer    = buffer(128);
  * {@link ByteBuf} directBuffer  = directBuffer(256);
  * {@link ByteBuf} wrappedBuffer = wrappedBuffer(new byte[128], new byte[256]);
- * {@link ByteBuf} copiedBuffe r = copiedBuffer({@link ByteBuffer}.allocate(128));
+ * {@link ByteBuf} copiedBuffer  = copiedBuffer({@link ByteBuffer}.allocate(128));
  * </pre>
  *
  * <h3>Allocating a new buffer</h3>

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOptEcsRecord.java
Patch:
@@ -37,7 +37,7 @@ public interface DnsOptEcsRecord extends DnsOptPseudoRecord {
     int scopePrefixLength();
 
     /**
-     * Retuns the bytes of the {@link InetAddress} to use.
+     * Returns the bytes of the {@link InetAddress} to use.
      */
     byte[] address();
 }

File: codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoderTest.java
Patch:
@@ -93,7 +93,7 @@ public void testDecodePtrRecord() throws Exception {
     public void testDecodeMessageCompression() throws Exception {
         // See https://www.ietf.org/rfc/rfc1035 [4.1.4. Message compression]
         DefaultDnsRecordDecoder decoder = new DefaultDnsRecordDecoder();
-        byte[] rfcExample = new byte[] { 1, 'F', 3, 'I', 'S', 'I', 4, 'A', 'R', 'P', 'A',
+        byte[] rfcExample = { 1, 'F', 3, 'I', 'S', 'I', 4, 'A', 'R', 'P', 'A',
                 0, 3, 'F', 'O', 'O',
                 (byte) 0xC0, 0, // this is 20 in the example
                 (byte) 0xC0, 6, // this is 26 in the example
@@ -103,7 +103,7 @@ public void testDecodeMessageCompression() throws Exception {
         DefaultDnsRawRecord rawUncompressedIndexedRecord = null;
         ByteBuf buffer = Unpooled.wrappedBuffer(rfcExample);
         try {
-            // First lets test that our utility funciton can correctly handle index references and decompression.
+            // First lets test that our utility function can correctly handle index references and decompression.
             String plainName = DefaultDnsRecordDecoder.decodeName(buffer.duplicate());
             assertEquals("F.ISI.ARPA.", plainName);
             String uncompressedPlainName = DefaultDnsRecordDecoder.decodeName(buffer.duplicate().setIndex(16, 20));

File: codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java
Patch:
@@ -96,7 +96,7 @@ public void readResponseTest() throws Exception {
     public ExpectedException exception = ExpectedException.none();
 
     @Test
-    public void readMalormedResponseTest() throws Exception {
+    public void readMalformedResponseTest() throws Exception {
         EmbeddedChannel embedder = new EmbeddedChannel(new DatagramDnsResponseDecoder());
         ByteBuf packet = embedder.alloc().buffer(512).writeBytes(malformedLoopPacket);
         exception.expect(CorruptedFrameException.class);

File: codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolVersion.java
Patch:
@@ -45,7 +45,7 @@ public enum HAProxyProtocolVersion {
     }
 
     /**
-     * Returns the {@link HAProxyProtocolVersion} represented by the higest 4 bits of the specified byte.
+     * Returns the {@link HAProxyProtocolVersion} represented by the highest 4 bits of the specified byte.
      *
      * @param verCmdByte protocol version and command byte
      */

File: codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProxiedProtocol.java
Patch:
@@ -120,7 +120,7 @@ public TransportProtocol transportProtocol() {
      */
     public enum AddressFamily {
         /**
-         * The UNSPECIFIED address family represents a connection which was forwarded for an unkown protocol.
+         * The UNSPECIFIED address family represents a connection which was forwarded for an unknown protocol.
          */
         AF_UNSPEC(AF_UNSPEC_BYTE),
         /**
@@ -184,7 +184,7 @@ public byte byteValue() {
      */
     public enum TransportProtocol {
         /**
-         * The UNSPEC transport protocol represents a connection which was forwarded for an unkown protocol.
+         * The UNSPEC transport protocol represents a connection which was forwarded for an unknown protocol.
          */
         UNSPEC(TRANSPORT_UNSPEC_BYTE),
         /**

File: codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoderTest.java
Patch:
@@ -184,23 +184,23 @@ public void testCloseOnInvalid() {
 
     @Test
     public void testTransportProtocolAndAddressFamily() {
-        final byte unkown = HAProxyProxiedProtocol.UNKNOWN.byteValue();
+        final byte unknown = HAProxyProxiedProtocol.UNKNOWN.byteValue();
         final byte tcp4 = HAProxyProxiedProtocol.TCP4.byteValue();
         final byte tcp6 = HAProxyProxiedProtocol.TCP6.byteValue();
         final byte udp4 = HAProxyProxiedProtocol.UDP4.byteValue();
         final byte udp6 = HAProxyProxiedProtocol.UDP6.byteValue();
         final byte unix_stream = HAProxyProxiedProtocol.UNIX_STREAM.byteValue();
         final byte unix_dgram = HAProxyProxiedProtocol.UNIX_DGRAM.byteValue();
 
-        assertEquals(TransportProtocol.UNSPEC, TransportProtocol.valueOf(unkown));
+        assertEquals(TransportProtocol.UNSPEC, TransportProtocol.valueOf(unknown));
         assertEquals(TransportProtocol.STREAM, TransportProtocol.valueOf(tcp4));
         assertEquals(TransportProtocol.STREAM, TransportProtocol.valueOf(tcp6));
         assertEquals(TransportProtocol.STREAM, TransportProtocol.valueOf(unix_stream));
         assertEquals(TransportProtocol.DGRAM, TransportProtocol.valueOf(udp4));
         assertEquals(TransportProtocol.DGRAM, TransportProtocol.valueOf(udp6));
         assertEquals(TransportProtocol.DGRAM, TransportProtocol.valueOf(unix_dgram));
 
-        assertEquals(AddressFamily.AF_UNSPEC, AddressFamily.valueOf(unkown));
+        assertEquals(AddressFamily.AF_UNSPEC, AddressFamily.valueOf(unknown));
         assertEquals(AddressFamily.AF_IPv4, AddressFamily.valueOf(tcp4));
         assertEquals(AddressFamily.AF_IPv4, AddressFamily.valueOf(udp4));
         assertEquals(AddressFamily.AF_IPv6, AddressFamily.valueOf(tcp6));

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -54,7 +54,7 @@ public static boolean isOriginForm(URI uri) {
     }
 
     /**
-     * Determine if a uri is in asteric-form according to
+     * Determine if a uri is in asterisk-form according to
      * <a href="https://tools.ietf.org/html/rfc7230#section-5.3">rfc7230, 5.3</a>.
      */
     public static boolean isAsteriskForm(URI uri) {
@@ -217,7 +217,7 @@ public static int getContentLength(HttpMessage message, int defaultValue) {
      * specified message is not a web socket message, {@code -1} is returned.
      */
     private static int getWebSocketContentLength(HttpMessage message) {
-        // WebSockset messages have constant content-lengths.
+        // WebSocket messages have constant content-lengths.
         HttpHeaders h = message.headers();
         if (message instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) message;

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
Patch:
@@ -148,7 +148,7 @@ public Set<String> exposedHeaders() {
      * xhr.withCredentials = true;
      * </pre>
      * The default value for 'withCredentials' is false in which case no cookies are sent.
-     * Settning this to true will included cookies in cross origin requests.
+     * Setting this to true will included cookies in cross origin requests.
      *
      * @return {@code true} if cookies are supported.
      */
@@ -221,7 +221,7 @@ public HttpHeaders preflightResponseHeaders() {
      * and this setting will check that the Origin is valid and if it is not valid no
      * further processing will take place, and a error will be returned to the calling client.
      *
-     * @return {@code true} if a CORS request should short-curcuit upon receiving an invalid Origin header.
+     * @return {@code true} if a CORS request should short-circuit upon receiving an invalid Origin header.
      */
     public boolean isShortCircuit() {
         return shortCircuit;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -506,7 +506,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
          *      add multipart delimiter, multipart body header and Data to multipart list
          *      reset currentFileUpload, duringMixedMode
          * if FileUpload: take care of multiple file for one field => mixed mode
-         *      if (duringMixeMode)
+         *      if (duringMixedMode)
          *          if (currentFileUpload.name == data.name)
          *              add mixedmultipart delimiter, mixedmultipart body header and Data to multipart list
          *          else

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -384,7 +384,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     }
 
     /**
-     * Verfiy the {@link FullHttpResponse} and throws a {@link WebSocketHandshakeException} if something is wrong.
+     * Verify the {@link FullHttpResponse} and throws a {@link WebSocketHandshakeException} if something is wrong.
      */
     protected abstract void verify(FullHttpResponse response);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandler.java
Patch:
@@ -65,8 +65,8 @@ public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise pr
             HttpRequest request = (HttpRequest) msg;
             String headerValue = request.headers().getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);
 
-            for (WebSocketClientExtensionHandshaker extentionHandshaker : extensionHandshakers) {
-                WebSocketExtensionData extensionData = extentionHandshaker.newRequestData();
+            for (WebSocketClientExtensionHandshaker extensionHandshaker : extensionHandshakers) {
+                WebSocketExtensionData extensionData = extensionHandshaker.newRequestData();
                 headerValue = WebSocketExtensionUtil.appendExtension(headerValue,
                         extensionData.name(), extensionData.parameters());
             }
@@ -109,7 +109,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg)
                             validExtensions.add(validExtension);
                         } else {
                             throw new CodecException(
-                                    "invalid WebSocket Extension handhshake for \"" + extensionsHeader + "\"");
+                                    "invalid WebSocket Extension handshake for \"" + extensionsHeader + '"');
                         }
                     }
 

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspHeaderNames.java
Patch:
@@ -35,7 +35,7 @@ public final class RtspHeaderNames {
      */
     public static final AsciiString ACCEPT_ENCODING = HttpHeaderNames.ACCEPT_ENCODING;
     /**
-     * {@code "accept-lanugage"}
+     * {@code "accept-language"}
      */
     public static final AsciiString ACCEPT_LANGUAGE = HttpHeaderNames.ACCEPT_LANGUAGE;
     /**

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspHeaders.java
Patch:
@@ -43,7 +43,7 @@ public static final class Names {
          */
         public static final String ACCEPT_ENCODING = HttpHeaders.Names.ACCEPT_ENCODING;
         /**
-         * {@code "Accept-Lanugage"}
+         * {@code "Accept-Language"}
          */
         public static final String ACCEPT_LANGUAGE = HttpHeaders.Names.ACCEPT_LANGUAGE;
         /**

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java
Patch:
@@ -27,7 +27,7 @@
 import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;
 
 public class DefaultSpdyHeaders extends DefaultHeaders<CharSequence, CharSequence, SpdyHeaders> implements SpdyHeaders {
-    private static final NameValidator<CharSequence> SpydNameValidator = new NameValidator<CharSequence>() {
+    private static final NameValidator<CharSequence> SpdyNameValidator = new NameValidator<CharSequence>() {
         @Override
         public void validateName(CharSequence name) {
             SpdyCodecUtil.validateHeaderName(name);
@@ -42,7 +42,7 @@ public DefaultSpdyHeaders() {
     public DefaultSpdyHeaders(boolean validate) {
         super(CASE_INSENSITIVE_HASHER,
                 validate ? HeaderValueConverterAndValidator.INSTANCE : CharSequenceValueConverter.INSTANCE,
-                validate ? SpydNameValidator : NameValidator.NOT_NULL);
+                validate ? SpdyNameValidator : NameValidator.NOT_NULL);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -179,7 +179,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                 try {
                     FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());
 
-                    // Set the Stream-ID, Associated-To-Stream-ID, iand Priority as headers
+                    // Set the Stream-ID, Associated-To-Stream-ID, and Priority as headers
                     httpRequestWithEntity.headers().setInt(Names.STREAM_ID, streamId);
                     httpRequestWithEntity.headers().setInt(Names.ASSOCIATED_TO_STREAM_ID, associatedToStreamId);
                     httpRequestWithEntity.headers().setInt(Names.PRIORITY, spdySynStreamFrame.priority());

File: codec-http/src/test/java/io/netty/handler/codec/http/CombinedHttpHeadersTest.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.http;
 
 import io.netty.handler.codec.http.HttpHeadersTestUtils.HeaderValue;
-import io.netty.util.internal.StringUtil;
 import org.junit.Test;
 
 import java.util.Arrays;
@@ -25,7 +24,6 @@
 import static io.netty.util.AsciiString.contentEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
 public class CombinedHttpHeadersTest {
@@ -169,7 +167,7 @@ public void addIterableCsvSingleValue() {
     }
 
     @Test
-    public void addIterableCsvEmtpy() {
+    public void addIterableCsvEmpty() {
         final CombinedHttpHeaders headers = newCombinedHttpHeaders();
         headers.add(HEADER_NAME, Collections.<CharSequence>emptyList());
         assertEquals(Arrays.asList(""), headers.getAll(HEADER_NAME));

File: codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java
Patch:
@@ -43,7 +43,7 @@ public void nullHeaderNameNotAllowed() {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void emtpyHeaderNameNotAllowed() {
+    public void emptyHeaderNameNotAllowed() {
         new DefaultHttpHeaders().add(StringUtil.EMPTY_STRING, "foo");
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java
Patch:
@@ -155,7 +155,7 @@ public void testServerCloseSocketInputProvidesData() throws InterruptedException
         ServerBootstrap sb = new ServerBootstrap();
         Bootstrap cb = new Bootstrap();
         final CountDownLatch serverChannelLatch = new CountDownLatch(1);
-        final CountDownLatch responseRecievedLatch = new CountDownLatch(1);
+        final CountDownLatch responseReceivedLatch = new CountDownLatch(1);
         try {
             sb.group(new NioEventLoopGroup(2));
             sb.channel(NioServerSocketChannel.class);
@@ -212,7 +212,7 @@ protected void initChannel(Channel ch) throws Exception {
                     ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {
                         @Override
                         protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) {
-                            responseRecievedLatch.countDown();
+                            responseReceivedLatch.countDown();
                         }
                     });
                 }
@@ -226,7 +226,7 @@ protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) {
             Channel clientChannel = ccf.channel();
             assertTrue(serverChannelLatch.await(5, SECONDS));
             clientChannel.writeAndFlush(new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
-            assertTrue(responseRecievedLatch.await(5, SECONDS));
+            assertTrue(responseReceivedLatch.await(5, SECONDS));
         } finally {
             sb.config().group().shutdownGracefully();
             sb.config().childGroup().shutdownGracefully();

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java
Patch:
@@ -29,7 +29,7 @@
 import static org.junit.Assert.*;
 
 public class HttpResponseEncoderTest {
-    private static final long INTEGER_OVERLFLOW = (long) Integer.MAX_VALUE + 1;
+    private static final long INTEGER_OVERFLOW = (long) Integer.MAX_VALUE + 1;
     private static final FileRegion FILE_REGION = new DummyLongFileRegion();
 
     @Test
@@ -83,7 +83,7 @@ public long transferred() {
 
         @Override
         public long count() {
-            return INTEGER_OVERLFLOW;
+            return INTEGER_OVERFLOW;
         }
 
         @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java
Patch:
@@ -55,7 +55,7 @@ public void testHandover() throws Exception {
             public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
                 if (evt == ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) {
                     serverReceivedHandshake = true;
-                    // immediatly send a message to the client on connect
+                    // immediately send a message to the client on connect
                     ctx.writeAndFlush(new TextWebSocketFrame("abc"));
                 } else if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) {
                     serverHandshakeComplete = (WebSocketServerProtocolHandler.HandshakeComplete) evt;

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketRequestBuilder.java
Patch:
@@ -146,7 +146,7 @@ public FullHttpRequest build() {
         return req;
     }
 
-    public static HttpRequest sucessful() {
+    public static HttpRequest successful() {
         return new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                 .method(HttpMethod.GET)
                 .uri("/test")

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -124,7 +124,7 @@ public void testHandleTextFrame() {
 
         if (ch.pipeline().context(HttpRequestDecoder.class) != null) {
             // Removing the HttpRequestDecoder because we are writing a TextWebSocketFrame and thus
-            // decoding is not neccessary.
+            // decoding is not necessary.
             ch.pipeline().remove(HttpRequestDecoder.class);
         }
 
@@ -147,7 +147,7 @@ private EmbeddedChannel createChannel(ChannelHandler handler) {
     }
 
     private static void writeUpgradeRequest(EmbeddedChannel ch) {
-        ch.writeInbound(WebSocketRequestBuilder.sucessful());
+        ch.writeInbound(WebSocketRequestBuilder.successful());
     }
 
     private static String getResponseMessage(FullHttpResponse response) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -433,9 +433,9 @@ protected final B self() {
         return (B) this;
     }
 
-    private void enforceNonCodecConstraints(String rejectee) {
-        enforceConstraint(rejectee, "server/connection", decoder);
-        enforceConstraint(rejectee, "server/connection", encoder);
+    private void enforceNonCodecConstraints(String rejected) {
+        enforceConstraint(rejected, "server/connection", decoder);
+        enforceConstraint(rejected, "server/connection", encoder);
     }
 
     private static void enforceConstraint(String methodName, String rejectorName, Object value) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -71,7 +71,7 @@ public DefaultHttp2HeadersDecoder(boolean validateHeaders, long maxHeaderListSiz
     }
 
     /**
-     * Exposed Used for testing only! Default values used in the initial settings frame are overriden intentionally
+     * Exposed Used for testing only! Default values used in the initial settings frame are overridden intentionally
      * for testing but violate the RFC if used outside the scope of testing.
      */
     DefaultHttp2HeadersDecoder(boolean validateHeaders, HpackDecoder hpackDecoder) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
Patch:
@@ -47,7 +47,7 @@ public DefaultHttp2HeadersEncoder(SensitivityDetector sensitivityDetector, boole
     }
 
     /**
-     * Exposed Used for testing only! Default values used in the initial settings frame are overriden intentionally
+     * Exposed Used for testing only! Default values used in the initial settings frame are overridden intentionally
      * for testing but violate the RFC if used outside the scope of testing.
      */
     DefaultHttp2HeadersEncoder(SensitivityDetector sensitivityDetector, HpackEncoder hpackEncoder) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -239,12 +239,12 @@ private int minUsableChannelBytes() {
     }
 
     private int maxUsableChannelBytes() {
-        // If the channel isWritable, allow at least minUseableChannelBytes.
+        // If the channel isWritable, allow at least minUsableChannelBytes.
         int channelWritableBytes = (int) min(Integer.MAX_VALUE, ctx.channel().bytesBeforeUnwritable());
-        int useableBytes = channelWritableBytes > 0 ? max(channelWritableBytes, minUsableChannelBytes()) : 0;
+        int usableBytes = channelWritableBytes > 0 ? max(channelWritableBytes, minUsableChannelBytes()) : 0;
 
         // Clip the usable bytes by the connection window.
-        return min(connectionState.windowSize(), useableBytes);
+        return min(connectionState.windowSize(), usableBytes);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -101,7 +101,7 @@ final class HpackDecoder {
     }
 
     /**
-     * Exposed Used for testing only! Default values used in the initial settings frame are overriden intentionally
+     * Exposed Used for testing only! Default values used in the initial settings frame are overridden intentionally
      * for testing but violate the RFC if used outside the scope of testing.
      */
     HpackDecoder(long maxHeaderListSize, int initialHuffmanDecodeCapacity, int maxHeaderTableSize) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -173,7 +173,7 @@ public static ByteBuf emptyPingBuf() {
     }
 
     /**
-     * Iteratively looks through the causaility chain for the given exception and returns the first
+     * Iteratively looks through the causality chain for the given exception and returns the first
      * {@link Http2Exception} or {@code null} if none.
      */
     public static Http2Exception getEmbeddedHttp2Exception(Throwable cause) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
Patch:
@@ -270,7 +270,7 @@ interface PropertyKey {
 
     /**
      * Removes a listener of stream life-cycle events. If the same listener was added multiple times
-     * then only the first occurence gets removed.
+     * then only the first occurrence gets removed.
      */
     void removeListener(Listener listener);
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
Patch:
@@ -162,7 +162,7 @@ void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependenc
      * Handles an inbound {@code PUSH_PROMISE} frame. Only called if {@code END_HEADERS} encountered.
      * <p>
      * Promised requests MUST be authoritative, cacheable, and safe.
-     * See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.2">[RFC http2], Seciton 8.2</a>.
+     * See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.2">[RFC http2], Section 8.2</a>.
      * <p>
      * Only one of the following methods will be called for each {@code HEADERS} frame sequence.
      * One will be called when the {@code END_HEADERS} flag has been received.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
Patch:
@@ -161,7 +161,7 @@ void updateStreamableBytes(int newStreamableBytes, boolean hasFrame, int windowS
             }
             // In addition to only enqueuing state when they have frames we enforce the following restrictions:
             // 1. If the window has gone negative. We never want to queue a state. However we also don't want to
-            //    Immediately remove the item if it is already queued because removal from dequeue is O(n). So
+            //    Immediately remove the item if it is already queued because removal from deque is O(n). So
             //    we allow it to stay queued and rely on the distribution loop to remove this state.
             // 2. If the window is zero we only want to queue if we are not writing. If we are writing that means
             //    we gave the state a chance to write zero length frames. We wait until updateStreamableBytes is

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java
Patch:
@@ -114,7 +114,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
 
     @After
-    public void cleaup() throws IOException {
+    public void cleanup() throws IOException {
         serverOut.close();
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
Patch:
@@ -37,7 +37,7 @@ public void nullHeaderNameNotAllowed() {
     }
 
     @Test(expected = Http2Exception.class)
-    public void emtpyHeaderNameNotAllowed() {
+    public void emptyHeaderNameNotAllowed() {
         new DefaultHttp2Headers().add(StringUtil.EMPTY_STRING, "foo");
     }
 
@@ -105,7 +105,7 @@ public void testPseudoHeadersWithClearDoesNotLeak() {
     }
 
     @Test
-    public void testSetHeadersOrdersPsuedoHeadersCorrectly() {
+    public void testSetHeadersOrdersPseudoHeadersCorrectly() {
         Http2Headers headers = newHeaders();
         Http2Headers other = new DefaultHttp2Headers().add("name2", "value2").authority("foo");
 
@@ -117,7 +117,7 @@ public void testSetHeadersOrdersPsuedoHeadersCorrectly() {
     }
 
     @Test
-    public void testSetAllOrdersPsuedoHeadersCorrectly() {
+    public void testSetAllOrdersPseudoHeadersCorrectly() {
         Http2Headers headers = newHeaders();
         Http2Headers other = new DefaultHttp2Headers().add("name2", "value2").authority("foo");
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -620,7 +620,7 @@ public void channelClosedDoesNotThrowPrefaceException() throws Exception {
     }
 
     @Test
-    public void writeRstStreamForUnkownStreamUsingVoidPromise() throws Exception {
+    public void writeRstStreamForUnknownStreamUsingVoidPromise() throws Exception {
         writeRstStreamUsingVoidPromise(NON_EXISTANT_STREAM_ID);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
Patch:
@@ -132,7 +132,7 @@ public void teardown() throws Exception {
     }
 
     @Test
-    public void inflightFrameAfterStreamResetShouldNotMakeConnectionUnsuable() throws Exception {
+    public void inflightFrameAfterStreamResetShouldNotMakeConnectionUnusable() throws Exception {
         bootstrapEnv(1, 1, 2, 1);
         final CountDownLatch latch = new CountDownLatch(1);
         doAnswer(new Answer<Void>() {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/ReadOnlyHttp2HeadersTest.java
Patch:
@@ -60,7 +60,7 @@ public void nullValuesAreNotAllowed() {
     }
 
     @Test
-    public void emtpyHeaderNameAllowed() {
+    public void emptyHeaderNameAllowed() {
         ReadOnlyHttp2Headers.trailers(false, AsciiString.EMPTY_STRING, new AsciiString("foo"));
     }
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -35,7 +35,7 @@
 /**
  * Decodes Mqtt messages from bytes, following
  * <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html">
- *     the MQTT protocl specification v3.1</a>
+ *     the MQTT protocol specification v3.1</a>
  */
 public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribePayload.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 
 /**
- * Pyaload of the {@link MqttUnsubscribeMessage}
+ * Payload of the {@link MqttUnsubscribeMessage}
  */
 public final class MqttUnsubscribePayload {
 

File: codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java
Patch:
@@ -356,7 +356,7 @@ private static MqttUnsubscribeMessage createUnsubscribeMessage() {
         return new MqttUnsubscribeMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttUnsubscribePayload);
     }
 
-    // Helper methdos to compare expected and actual
+    // Helper methods to compare expected and actual
     // MQTT messages
 
     private static void validateFixedHeaders(MqttFixedHeader expected, MqttFixedHeader actual) {

File: codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java
Patch:
@@ -53,7 +53,7 @@ private enum State {
     }
 
     /**
-     * Creates a new instance with default {@code maxInlineMessageLength} and {@code messageaPool}.
+     * Creates a new instance with default {@code maxInlineMessageLength} and {@code messagePool}.
      */
     public RedisDecoder() {
         // 1024 * 64 is max inline length of current Redis server implementation.

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
Patch:
@@ -40,9 +40,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
                     out.add(SocksCommonUtils.UNKNOWN_SOCKS_RESPONSE);
                     break;
                 }
-                checkpoint(State.READ_PREFFERED_AUTH_TYPE);
+                checkpoint(State.READ_PREFERRED_AUTH_TYPE);
             }
-            case READ_PREFFERED_AUTH_TYPE: {
+            case READ_PREFERRED_AUTH_TYPE: {
                 SocksAuthScheme authScheme = SocksAuthScheme.valueOf(byteBuf.readByte());
                 out.add(new SocksInitResponse(authScheme));
                 break;
@@ -56,6 +56,6 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
 
     enum State {
         CHECK_PROTOCOL_VERSION,
-        READ_PREFFERED_AUTH_TYPE
+        READ_PREFERRED_AUTH_TYPE
     }
 }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -451,7 +451,7 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
      * @param ctx           the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to
      * @param in            the {@link ByteBuf} from which to read data
      * @param out           the {@link List} to which decoded messages should be added
-     * @throws Exception    is thrown if an error accour
+     * @throws Exception    is thrown if an error occurs
      */
     protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
 

File: codec/src/main/java/io/netty/handler/codec/DecoderException.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec;
 
 /**
- * An {@link CodecException} which is thrown by a dencoder.
+ * An {@link CodecException} which is thrown by a decoder.
  */
 public class DecoderException extends CodecException {
 

File: codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
Patch:
@@ -77,7 +77,7 @@ protected MessageToByteEncoder(boolean preferDirect) {
     /**
      * Create a new instance
      *
-     * @param outboundMessageType   The tpye of messages to match
+     * @param outboundMessageType   The type of messages to match
      * @param preferDirect          {@code true} if a direct {@link ByteBuf} should be tried to be used as target for
      *                              the encoded messages. If {@code false} is used it will allocate a heap
      *                              {@link ByteBuf}, which is backed by an byte array.
@@ -132,7 +132,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
 
     /**
      * Allocate a {@link ByteBuf} which will be used as argument of {@link #encode(ChannelHandlerContext, I, ByteBuf)}.
-     * Sub-classes may override this method to returna {@link ByteBuf} with a perfect matching {@code initialCapacity}.
+     * Sub-classes may override this method to return {@link ByteBuf} with a perfect matching {@code initialCapacity}.
      */
     protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("unused") I msg,
                                boolean preferDirect) throws Exception {
@@ -150,7 +150,7 @@ protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("u
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToByteEncoder} belongs to
      * @param msg           the message to encode
      * @param out           the {@link ByteBuf} into which the encoded message will be written
-     * @throws Exception    is thrown if an error accour
+     * @throws Exception    is thrown if an error occurs
      */
     protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;
 

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -40,7 +40,7 @@
  *             out.add(msg.longValue());
  *         }
  *
- *         {@code @Overrride}
+ *         {@code @Override}
  *         public {@link Integer} encode({@link ChannelHandlerContext} ctx, {@link Long} msg, List&lt;Object&gt; out)
  *                 throws {@link Exception} {
  *             out.add(msg.intValue());

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -112,7 +112,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToMessageDecoder} belongs to
      * @param msg           the message to decode to an other one
      * @param out           the {@link List} to which decoded messages should be added
-     * @throws Exception    is thrown if an error accour
+     * @throws Exception    is thrown if an error occurs
      */
     protected abstract void decode(ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception;
 }

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
Patch:
@@ -137,8 +137,8 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToMessageEncoder} belongs to
      * @param msg           the message to encode to an other one
      * @param out           the {@link List} into which the encoded msg should be added
-     *                      needs to do some kind of aggragation
-     * @throws Exception    is thrown if an error accour
+     *                      needs to do some kind of aggregation
+     * @throws Exception    is thrown if an error occurs
      */
     protected abstract void encode(ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception;
 }

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java
Patch:
@@ -277,7 +277,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 }
                 // It used to avoid "Bzip2Decoder.decode() did not read anything but decoded a message" exception.
                 // Because previous operation may read only a few bits from Bzip2BitReader.bitBuffer and
-                // don't read incomming ByteBuf.
+                // don't read incoming ByteBuf.
                 if (in.readerIndex() == oldReaderIndex && in.isReadable()) {
                     reader.refill();
                 }

File: codec/src/main/java/io/netty/handler/codec/compression/FastLz.java
Patch:
@@ -59,7 +59,7 @@ final class FastLz {
     /**
      * In this case {@link #compress(byte[], int, int, byte[], int, int)} will choose level
      * automatically depending on the length of the input buffer. If length less than
-     * {@link #MIN_RECOMENDED_LENGTH_FOR_LEVEL_2} {@link #LEVEL_1} will be choosen,
+     * {@link #MIN_RECOMENDED_LENGTH_FOR_LEVEL_2} {@link #LEVEL_1} will be chosen,
      * otherwise {@link #LEVEL_2}.
      */
     static final int LEVEL_AUTO = 0;

File: codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java
Patch:
@@ -71,7 +71,7 @@ private enum State {
     private boolean hasChecksum;
 
     /**
-     * Chechsum value of current received chunk of data which has checksum.
+     * Checksum value of current received chunk of data which has checksum.
      */
     private int currentChecksum;
 

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java
Patch:
@@ -372,7 +372,7 @@ private void verifyCrc(ByteBuf in) {
         long readCrc = crc.getValue();
         if (crcValue != readCrc) {
             throw new DecompressionException(
-                    "CRC value missmatch. Expected: " + crcValue + ", Got: " + readCrc);
+                    "CRC value mismatch. Expected: " + crcValue + ", Got: " + readCrc);
         }
     }
 

File: codec/src/main/java/io/netty/handler/codec/compression/LzfEncoder.java
Patch:
@@ -73,7 +73,7 @@ public LzfEncoder(boolean safeInstance) {
 
     /**
      * Creates a new LZF encoder with specified total length of encoded chunk. You can configure it to encode
-     * your data flow more efficient if you know the avarage size of messages that you send.
+     * your data flow more efficient if you know the average size of messages that you send.
      *
      * @param totalLength
      *        Expected total length of content to compress; only matters for outgoing messages that is smaller

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
Patch:
@@ -21,5 +21,5 @@
  */
 @Deprecated
 public class SnappyFramedDecoder extends SnappyFrameDecoder {
-    // Nothing new. Just stting here for backward compatibility.
+    // Nothing new. Just staying here for backward compatibility.
 }

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
Patch:
@@ -21,5 +21,5 @@
  */
 @Deprecated
 public class SnappyFramedEncoder extends SnappyFrameEncoder {
-    // Nothing new. Just stting here for backward compatibility.
+    // Nothing new. Just staying here for backward compatibility.
 }

File: codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingEncoder.java
Patch:
@@ -28,7 +28,7 @@
  * an Object.
  *
  * See <a href="http://www.jboss.org/jbossmarshalling">JBoss Marshalling website</a>
- * for more informations
+ * for more information
  *
  * Use {@link MarshallingEncoder} if possible.
  *

File: codec/src/main/java/io/netty/handler/codec/marshalling/MarshallingEncoder.java
Patch:
@@ -31,7 +31,7 @@
  * Use this with {@link MarshallingDecoder}
  *
  * See <a href="http://www.jboss.org/jbossmarshalling">JBoss Marshalling website</a>
- * for more informations
+ * for more information
  *
  */
 @Sharable

File: common/src/main/java/io/netty/util/ReferenceCounted.java
Patch:
@@ -53,7 +53,7 @@ public interface ReferenceCounted {
     ReferenceCounted touch();
 
     /**
-     * Records the current access location of this object with an additonal arbitrary information for debugging
+     * Records the current access location of this object with an additional arbitrary information for debugging
      * purposes.  If this object is determined to be leaked, the information recorded by this operation will be
      * provided to you via {@link ResourceLeakDetector}.
      */

File: common/src/main/java/io/netty/util/ThreadDeathWatcher.java
Patch:
@@ -45,7 +45,7 @@ public final class ThreadDeathWatcher {
     static final ThreadFactory threadFactory;
 
     // Use a MPMC queue as we may end up checking isEmpty() from multiple threads which may not be allowed to do
-    // concurrently depending on the implemenation of it in a MPSC queue.
+    // concurrently depending on the implementation of it in a MPSC queue.
     private static final Queue<Entry> pendingEntries = new ConcurrentLinkedQueue<Entry>();
     private static final Watcher watcher = new Watcher();
     private static final AtomicBoolean started = new AtomicBoolean();

File: common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
Patch:
@@ -31,7 +31,7 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E
 
     /**
      * Returns {@code true} if and only if all {@link EventExecutor}s managed by this {@link EventExecutorGroup}
-     * are being {@linkplain #shutdownGracefully() shut down gracefuclly} or was {@linkplain #isShutdown() shut down}.
+     * are being {@linkplain #shutdownGracefully() shut down gracefully} or was {@linkplain #isShutdown() shut down}.
      */
     boolean isShuttingDown();
 

File: common/src/main/java/io/netty/util/concurrent/RejectedExecutionHandlers.java
Patch:
@@ -54,7 +54,7 @@ public static RejectedExecutionHandler backoff(final int retries, long backoffAm
             public void rejected(Runnable task, SingleThreadEventExecutor executor) {
                 if (!executor.inEventLoop()) {
                     for (int i = 0; i < retries; i++) {
-                        // Try to wakup the executor so it will empty its task queue.
+                        // Try to wake up the executor so it will empty its task queue.
                         executor.wakeup(false);
 
                         LockSupport.parkNanos(backOffNanos);

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -368,7 +368,7 @@ protected boolean runAllTasks() {
      *
      * @param taskQueue To poll and execute all tasks.
      *
-     * @return {@code true} if atleast one task was executed.
+     * @return {@code true} if at least one task was executed.
      */
     protected final boolean runAllTasksFrom(Queue<Runnable> taskQueue) {
         Runnable task = pollTaskFrom(taskQueue);

File: common/src/main/java/io/netty/util/internal/MacAddressUtil.java
Patch:
@@ -187,7 +187,7 @@ public static byte[] parseMAC(String value) {
 
     private static void validateMacSeparator(char separator) {
         if (separator != ':' && separator != '-') {
-            throw new IllegalArgumentException("unsupported seperator: " + separator + " (expected: [:-])");
+            throw new IllegalArgumentException("unsupported separator: " + separator + " (expected: [:-])");
         }
     }
 

File: common/src/main/java/io/netty/util/internal/PendingWrite.java
Patch:
@@ -59,7 +59,7 @@ public boolean recycle() {
     }
 
     /**
-     * Fails the underlying {@link Promise} with the given cause and reycle this instance.
+     * Fails the underlying {@link Promise} with the given cause and recycle this instance.
      */
     public boolean failAndRecycle(Throwable cause) {
         ReferenceCountUtil.release(msg);
@@ -70,7 +70,7 @@ public boolean failAndRecycle(Throwable cause) {
     }
 
     /**
-     * Mark the underlying {@link Promise} successed and reycle this instance.
+     * Mark the underlying {@link Promise} successfully and recycle this instance.
      */
     public boolean successAndRecycle() {
         if (promise != null) {

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -289,7 +289,7 @@ public Object run() {
                 @Override
                 public Object run() {
                     try {
-                        // Java9 has jdk.internal.misc.Unsafe and not all methods are propergated to
+                        // Java9 has jdk.internal.misc.Unsafe and not all methods are propagated to
                         // sun.misc.Unsafe
                         Class<?> internalUnsafeClass = getClassLoader(PlatformDependent0.class)
                                 .loadClass("jdk.internal.misc.Unsafe");

File: common/src/test/java/io/netty/util/ResourceLeakDetectorTest.java
Patch:
@@ -26,7 +26,7 @@
 public class ResourceLeakDetectorTest {
 
     @Test(timeout = 60000)
-    public void testConcurentUsage() throws Throwable {
+    public void testConcurrentUsage() throws Throwable {
         final AtomicBoolean finished = new AtomicBoolean();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
         // With 50 threads issue #6087 is reproducible on every run.

File: common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
Patch:
@@ -458,7 +458,8 @@ public void run() {
             }
         });
 
-        assertTrue("Should have notifed " + expectedCount + " listeners", latch.await(5, TimeUnit.SECONDS));
+        assertTrue("Should have notified " + expectedCount + " listeners",
+                   latch.await(5, TimeUnit.SECONDS));
         executor.shutdownGracefully().sync();
     }
 

File: common/src/test/java/io/netty/util/concurrent/DefaultThreadFactoryTest.java
Patch:
@@ -131,7 +131,7 @@ public DefaultThreadFactory call() throws Exception {
     // test that when DefaultThreadFactory is constructed it is sticky to the thread group from the thread group of the
     // thread that created it
     @Test(timeout = 2000)
-    public void testDefaulThreadFactoryInheritsThreadGroup() throws InterruptedException {
+    public void testDefaultThreadFactoryInheritsThreadGroup() throws InterruptedException {
         final ThreadGroup sticky = new ThreadGroup("sticky");
 
         runStickyThreadGroupTest(

File: common/src/test/java/io/netty/util/concurrent/PromiseAggregatorTest.java
Patch:
@@ -19,7 +19,6 @@
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
-import static org.mockito.Mockito.verify;
 
 import org.junit.Rule;
 import org.junit.Test;
@@ -48,7 +47,7 @@ public void testAddNullFuture() {
 
     @SuppressWarnings("unchecked")
     @Test
-    public void testSucessfulNoPending() throws Exception {
+    public void testSuccessfulNoPending() throws Exception {
         Promise<Void> p = mock(Promise.class);
         PromiseAggregator<Void, Future<Void>> a =
                 new PromiseAggregator<Void, Future<Void>>(p);

File: example/src/main/java/io/netty/example/file/FileServerHandler.java
Patch:
@@ -29,7 +29,7 @@ public class FileServerHandler extends SimpleChannelInboundHandler<String> {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) {
-        ctx.writeAndFlush("HELO: Type the path of the file to retrieve.\n");
+        ctx.writeAndFlush("HELLO: Type the path of the file to retrieve.\n");
     }
 
     @Override

File: example/src/main/java/io/netty/example/http/cors/HttpCorsServer.java
Patch:
@@ -29,7 +29,7 @@
  * This example server aims to demonstrate
  * <a href="http://www.w3.org/TR/cors/">Cross Origin Resource Sharing</a> (CORS) in Netty.
  * It does not have a client like most of the other examples, but instead has
- * a html page that is loaded to try out CORS support in a web brower.
+ * a html page that is loaded to try out CORS support in a web browser.
  * <p>
  *
  * CORS is configured in {@link HttpCorsServerInitializer} and by updating the config you can
@@ -50,7 +50,7 @@
  * <h3>Using a web server</h3>
  * To test CORS support you can serve the file {@code src/main/resources/cors/cors.html}
  * using a web server. You can then add a new host name to your systems hosts file, for
- * example if you are on Linux you may update /etc/hosts to add an addtional name
+ * example if you are on Linux you may update /etc/hosts to add an additional name
  * for you local system:
  * <pre>
  * 127.0.0.1   localhost domain1.com

File: example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
Patch:
@@ -61,7 +61,7 @@
  * <li>Last-Modified</li>
  * <li>Pragma</li>
  * </ul>
- * Any of the above response headers can be retreived by:
+ * Any of the above response headers can be retrieved by:
  * <pre>
  * xhr.getResponseHeader("Content-Type");
  * </pre>

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -113,7 +113,7 @@ public static void main(String[] args) throws Exception {
 
         try {
             Bootstrap b = new Bootstrap();
-            b.group(group).channel(NioSocketChannel.class).handler(new HttpUploadClientIntializer(sslCtx));
+            b.group(group).channel(NioSocketChannel.class).handler(new HttpUploadClientInitializer(sslCtx));
 
             // Simple Get form: no factory used (not usable)
             List<Entry<String, String>> headers = formget(b, host, port, get, uriSimple);

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientInitializer.java
Patch:
@@ -23,11 +23,11 @@
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.stream.ChunkedWriteHandler;
 
-public class HttpUploadClientIntializer extends ChannelInitializer<SocketChannel> {
+public class HttpUploadClientInitializer extends ChannelInitializer<SocketChannel> {
 
     private final SslContext sslCtx;
 
-    public HttpUploadClientIntializer(SslContext sslCtx) {
+    public HttpUploadClientInitializer(SslContext sslCtx) {
         this.sslCtx = sslCtx;
     }
 

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
Patch:
@@ -29,7 +29,7 @@ public class HexDumpProxyFrontendHandler extends ChannelInboundHandlerAdapter {
     private final String remoteHost;
     private final int remotePort;
 
-    // As we use inboundChannel.eventLoop() when buildling the Bootstrap this does not need to be volatile as
+    // As we use inboundChannel.eventLoop() when building the Bootstrap this does not need to be volatile as
     // the outboundChannel will use the same EventLoop (and therefore Thread) as the inboundChannel.
     private Channel outboundChannel;
 

File: handler-proxy/src/main/java/io/netty/handler/proxy/ProxyHandler.java
Patch:
@@ -103,7 +103,7 @@ public final <T extends SocketAddress> T destinationAddress() {
     }
 
     /**
-     * Rerutns {@code true} if and only if the connection to the destination has been established successfully.
+     * Returns {@code true} if and only if the connection to the destination has been established successfully.
      */
     public final boolean isConnected() {
         return connectPromise.isSuccess();

File: handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java
Patch:
@@ -43,7 +43,7 @@ final class CipherSuiteConverter {
      * C - bulk cipher
      * D - HMAC algorithm
      *
-     * This regular expression assumees that:
+     * This regular expression assumes that:
      *
      * 1) A is always TLS or SSL, and
      * 2) D is always a single word.

File: handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java
Patch:
@@ -110,7 +110,7 @@ private static final class FailureWrapper implements SslEngineWrapperFactory {
         @Override
         public SSLEngine wrapSslEngine(SSLEngine engine, JdkApplicationProtocolNegotiator applicationNegotiator,
                                        boolean isServer) {
-            throw new RuntimeException("ALPN unsupported. Is your classpatch configured correctly?"
+            throw new RuntimeException("ALPN unsupported. Is your classpath configured correctly?"
                     + " For Conscrypt, add the appropriate Conscrypt JAR to classpath and set the security provider."
                     + " For Jetty-ALPN, see "
                     + "http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-starting");

File: handler/src/main/java/io/netty/handler/ssl/JdkNpnApplicationProtocolNegotiator.java
Patch:
@@ -24,7 +24,7 @@ public final class JdkNpnApplicationProtocolNegotiator extends JdkBaseApplicatio
     private static final SslEngineWrapperFactory NPN_WRAPPER = new SslEngineWrapperFactory() {
         {
             if (!JettyNpnSslEngine.isAvailable()) {
-                throw new RuntimeException("NPN unsupported. Is your classpatch configured correctly?"
+                throw new RuntimeException("NPN unsupported. Is your classpath configured correctly?"
                         + " See https://wiki.eclipse.org/Jetty/Feature/NPN");
             }
         }

File: handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
Patch:
@@ -159,7 +159,7 @@ public JdkSslContext(SSLContext sslContext, boolean isClient,
      *
      * @param sslContext the {@link SSLContext} to use.
      * @param isClient {@code true} if this context should create {@link SSLEngine}s for client-side usage.
-     * @param ciphers the ciphers to use or {@code null} if the standart should be used.
+     * @param ciphers the ciphers to use or {@code null} if the standard should be used.
      * @param cipherFilter the filter to use.
      * @param apn the {@link ApplicationProtocolConfig} to use.
      * @param clientAuth the {@link ClientAuth} to use. This will only be used when {@param isClient} is {@code false}.

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -72,7 +72,7 @@ public abstract class ReferenceCountedOpenSslContext extends SslContext implemen
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(ReferenceCountedOpenSslContext.class);
     /**
-     * To make it easier for users to replace JDK implemention with OpenSsl version we also use
+     * To make it easier for users to replace JDK implementation with OpenSsl version we also use
      * {@code jdk.tls.rejectClientInitiatedRenegotiation} to allow disabling client initiated renegotiation.
      * Java8+ uses this system property as well.
      * <p>

File: handler/src/main/java/io/netty/handler/ssl/SslContext.java
Patch:
@@ -939,8 +939,8 @@ public final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int
      * @return a key specification
      *
      * @throws IOException if parsing {@code key} fails
-     * @throws NoSuchAlgorithmException if the algorithm used to encrypt {@code key} is unkown
-     * @throws NoSuchPaddingException if the padding scheme specified in the decryption algorithm is unkown
+     * @throws NoSuchAlgorithmException if the algorithm used to encrypt {@code key} is unknown
+     * @throws NoSuchPaddingException if the padding scheme specified in the decryption algorithm is unknown
      * @throws InvalidKeySpecException if the decryption key based on {@code password} cannot be generated
      * @throws InvalidKeyException if the decryption key based on {@code password} cannot be used to decrypt
      *                             {@code key}

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -90,7 +90,7 @@ static SSLHandshakeException toSSLHandshakeException(Throwable e) {
      *                  otherwise it will throw an {@link IllegalArgumentException}.
      * @return length
      *                  The length of the encrypted packet that is included in the buffer or
-     *                  {@link #SslUtils#NOT_ENOUGH_DATA} if not enought data is present in the
+     *                  {@link #SslUtils#NOT_ENOUGH_DATA} if not enough data is present in the
      *                  {@link ByteBuf}. This will return {@link SslUtils#NOT_ENCRYPTED} if
      *                  the given {@link ByteBuf} is not encrypted at all.
      * @throws IllegalArgumentException

File: handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
Patch:
@@ -134,7 +134,7 @@ public X509Certificate[] getAcceptedIssuers() {
     /**
      * Creates a new instance.
      *
-     * @param fingerprints a list of SHA1 fingerprints in heaxdecimal form
+     * @param fingerprints a list of SHA1 fingerprints in hexadecimal form
      */
     public FingerprintTrustManagerFactory(Iterable<String> fingerprints) {
         this(toFingerprintArray(fingerprints));
@@ -143,7 +143,7 @@ public FingerprintTrustManagerFactory(Iterable<String> fingerprints) {
     /**
      * Creates a new instance.
      *
-     * @param fingerprints a list of SHA1 fingerprints in heaxdecimal form
+     * @param fingerprints a list of SHA1 fingerprints in hexadecimal form
      */
     public FingerprintTrustManagerFactory(String... fingerprints) {
         this(toFingerprintArray(Arrays.asList(fingerprints)));

File: handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
Patch:
@@ -105,7 +105,7 @@ public SelfSignedCertificate(String fqdn) throws CertificateException {
      * @param notAfter Certificate is not valid after this time
      */
     public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter) throws CertificateException {
-        // Bypass entrophy collection by using insecure random generator.
+        // Bypass entropy collection by using insecure random generator.
         // We just want to generate it without any delay because it's for testing purposes only.
         this(fqdn, ThreadLocalInsecureRandom.current(), 1024, notBefore, notAfter);
     }

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -240,7 +240,7 @@ public long getAllIdleTimeInMillis() {
     @Override
     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         if (ctx.channel().isActive() && ctx.channel().isRegistered()) {
-            // channelActvie() event has been fired already, which means this.channelActive() will
+            // channelActive() event has been fired already, which means this.channelActive() will
             // not be invoked. We have to initialize here instead.
             initialize(ctx);
         } else {

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -323,7 +323,7 @@ public long getCheckInterval() {
     }
 
     /**
-     * @param checkInterval the interval in ms between each step check to set, default value beeing 1000 ms.
+     * @param checkInterval the interval in ms between each step check to set, default value being 1000 ms.
      */
     public void setCheckInterval(long checkInterval) {
         this.checkInterval = checkInterval;
@@ -451,7 +451,7 @@ public void run() {
                 ctx.channel().read();
             }
             if (logger.isDebugEnabled()) {
-                logger.debug("Unsupsend final status => " + config.isAutoRead() + ':'
+                logger.debug("Unsuspend final status => " + config.isAutoRead() + ':'
                         + isHandlerActive(ctx));
             }
         }

File: handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficShapingHandler.java
Patch:
@@ -700,7 +700,7 @@ protected void submitWrite(final ChannelHandlerContext ctx, final Object msg,
         Integer key = channel.hashCode();
         PerChannel perChannel = channelQueues.get(key);
         if (perChannel == null) {
-            // in case write occurs before handlerAdded is raized for this handler
+            // in case write occurs before handlerAdded is raised for this handler
             // imply a synchronized only if needed
             perChannel = getOrSetPerChannel(ctx);
         }

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -333,7 +333,7 @@ void submitWrite(final ChannelHandlerContext ctx, final Object msg,
         Integer key = channel.hashCode();
         PerChannel perChannel = channelQueues.get(key);
         if (perChannel == null) {
-            // in case write occurs before handlerAdded is raized for this handler
+            // in case write occurs before handlerAdded is raised for this handler
             // imply a synchronized only if needed
             perChannel = getOrSetPerChannel(ctx);
         }

File: handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java
Patch:
@@ -307,10 +307,10 @@ private void init(long checkInterval) {
     /**
      * Change checkInterval between two computations in millisecond.
      *
-     * @param newcheckInterval The new check interval (in milliseconds)
+     * @param newCheckInterval The new check interval (in milliseconds)
      */
-    public void configure(long newcheckInterval) {
-        long newInterval = newcheckInterval / 10 * 10;
+    public void configure(long newCheckInterval) {
+        long newInterval = newCheckInterval / 10 * 10;
         if (checkInterval.getAndSet(newInterval) != newInterval) {
             if (newInterval <= 0) {
                 stop();

File: handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java
Patch:
@@ -244,7 +244,7 @@ protected void initChannel(final Channel ch) {
                     public void operationComplete(final Future<Channel> future) {
                         ch.pipeline().remove(sslHandler);
 
-                        // Schedule the close so removal has time to propergate exception if any.
+                        // Schedule the close so removal has time to propagate exception if any.
                         ch.eventLoop().execute(new Runnable() {
                             @Override
                             public void run() {

File: microbench/src/main/java/io/netty/microbench/buffer/HeapByteBufBenchmark.java
Patch:
@@ -30,7 +30,7 @@ public class HeapByteBufBenchmark extends AbstractMicrobenchmark {
     private ByteBuf buffer;
 
     private static ByteBuf newBuffer(String classname) throws Exception {
-        // Using reflection to workound package-private implementations.
+        // Using reflection to workaround package-private implementations.
         Class<?> clazz = Class.forName(classname);
         Constructor<?> constructor = clazz.getDeclaredConstructor(ByteBufAllocator.class, int.class, int.class);
         constructor.setAccessible(true);

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
Patch:
@@ -55,7 +55,7 @@ public interface DnsCache {
      * Cache a resolved address for a given hostname.
      * @param hostname the hostname
      * @param additionals the additional records
-     * @param address the resolved adresse
+     * @param address the resolved address
      * @param originalTtl the TLL as returned by the DNS server
      * @param loop the {@link EventLoop} used to register the TTL timeout
      */

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -100,9 +100,9 @@ public DnsNameResolverBuilder resolveCache(DnsCache resolveCache) {
     }
 
     /**
-     * Sets the cache for authoritive NS servers
+     * Sets the cache for authoritative NS servers
      *
-     * @param authoritativeDnsServerCache the authoritive NS servers cache
+     * @param authoritativeDnsServerCache the authoritative NS servers cache
      * @return {@code this}
      */
     public DnsNameResolverBuilder authoritativeDnsServerCache(DnsCache authoritativeDnsServerCache) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -672,8 +672,8 @@ static String decodeDomainName(ByteBuf in) {
         }
     }
 
-    private DnsServerAddressStream getNameServers(String hostame) {
-        DnsServerAddressStream stream = getNameServersFromCache(hostame);
+    private DnsServerAddressStream getNameServers(String hostname) {
+        DnsServerAddressStream stream = getNameServersFromCache(hostname);
         return stream == null ? nameServerAddrs : stream;
     }
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java
Patch:
@@ -110,7 +110,7 @@ private IntObjectMap<DnsQueryContext> getOrCreateContextMap(InetSocketAddress na
                 if (a4.isLoopbackAddress()) {
                     map.put(new InetSocketAddress(NetUtil.LOCALHOST6, port), newContexts);
                 } else {
-                    map.put(new InetSocketAddress(toCompatAddress(a4), port), newContexts);
+                    map.put(new InetSocketAddress(toCompactAddress(a4), port), newContexts);
                 }
             } else if (a instanceof Inet6Address) {
                 // Also add the mapping for the IPv4 address if this IPv6 address is compatible.
@@ -126,7 +126,7 @@ private IntObjectMap<DnsQueryContext> getOrCreateContextMap(InetSocketAddress na
         }
     }
 
-    private static Inet6Address toCompatAddress(Inet4Address a4) {
+    private static Inet6Address toCompactAddress(Inet4Address a4) {
         byte[] b4 = a4.getAddress();
         byte[] b6 = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b4[0], b4[1], b4[2], b4[3] };
         try {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java
Patch:
@@ -258,7 +258,7 @@ public void testAutoReadGlobalTrafficShapping(ServerBootstrap sb, Bootstrap cb)
     /**
      *
      * @param additionalExecutor
-     *            shall the pipeline add the handler using an additionnal executor
+     *            shall the pipeline add the handler using an additional executor
      * @param limitRead
      *            True to set Read Limit on Server side
      * @param limitWrite
@@ -339,7 +339,7 @@ protected void initChannel(SocketChannel c) throws Exception {
 
         promise.await();
         Long stop = TrafficCounter.milliSecondFromNano();
-        assertTrue("Error during exceution of TrafficShapping: " + promise.cause(), promise.isSuccess());
+        assertTrue("Error during execution of TrafficShapping: " + promise.cause(), promise.isSuccess());
 
         float average = (totalNb * messageSize) / (float) (stop - start);
         logger.info("TEST: " + currentTestName + " RUN: " + currentTestRun +

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -264,7 +264,7 @@ public static Paritybit valueOf(int value) {
     /**
      * Sets the maximal time (in ms) to block while try to read from the serial port. Default is 1000ms
      */
-    RxtxChannelConfig setReadTimeout(int readTimout);
+    RxtxChannelConfig setReadTimeout(int readTimeout);
 
     /**
      * Return the maximal time (in ms) to block and wait for something to be ready to read.

File: transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java
Patch:
@@ -111,7 +111,7 @@ public static synchronized InetSocketAddress findLocalAddress(
             socket = new ServerSocket(0, 3, address);
             return (InetSocketAddress) socket.getLocalSocketAddress();
         } catch (final Exception e) {
-            log.error("Failed to find addess.");
+            log.error("Failed to find address.");
             return null;
         } finally {
             if (socket != null) {

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -174,7 +174,7 @@ private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, fin
             regFuture.addListener(new ChannelFutureListener() {
                 @Override
                 public void operationComplete(ChannelFuture future) throws Exception {
-                    // Direclty obtain the cause and do a null check so we only need one volatile read in case of a
+                    // Directly obtain the cause and do a null check so we only need one volatile read in case of a
                     // failure.
                     Throwable cause = future.cause();
                     if (cause != null) {

File: transport/src/main/java/io/netty/channel/ChannelConfig.java
Patch:
@@ -206,7 +206,7 @@ public interface ChannelConfig {
     /**
      * @deprecated  Auto close will be removed in a future release.
      *
-     * Sets whether the {@link Channel} should be closed automatically and immediately on write faillure.
+     * Sets whether the {@link Channel} should be closed automatically and immediately on write failure.
      * The default is {@code false}.
      */
     @Deprecated

File: transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
Patch:
@@ -162,7 +162,7 @@ public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause) {
      *
      * So after this operation this {@link ChannelFutureListener} is empty.
      *
-     * @param cause1    the {@link Throwable} which will be used to fail all of the {@link ChannelFuture}s whichs
+     * @param cause1    the {@link Throwable} which will be used to fail all of the {@link ChannelFuture}s which
      *                  pendingDataSize is smaller then the current writeCounter returned by {@link #writeCounter()}
      * @param cause2    the {@link Throwable} which will be used to fail the remaining {@link ChannelFuture}s
      */

File: transport/src/main/java/io/netty/channel/ChannelId.java
Patch:
@@ -23,7 +23,7 @@
  * <p>
  * The identifier is generated from various sources listed in the following:
  * <ul>
- * <li>MAC address (EUI-48 or EUI-64) or the network adapter, preferrably a globally unique one,</li>
+ * <li>MAC address (EUI-48 or EUI-64) or the network adapter, preferably a globally unique one,</li>
  * <li>the current process ID,</li>
  * <li>{@link System#currentTimeMillis()},</li>
  * <li>{@link System#nanoTime()},</li>

File: transport/src/main/java/io/netty/channel/ChannelInitializer.java
Patch:
@@ -100,7 +100,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         if (ctx.channel().isRegistered()) {
             // This should always be true with our current DefaultChannelPipeline implementation.
             // The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering
-            // suprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers
+            // surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers
             // will be added in the expected order.
             initChannel(ctx);
         }

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -166,7 +166,7 @@
  *     }
  * }
  *
- * public clas MyOutboundHandler extends {@link ChannelOutboundHandlerAdapter} {
+ * public class MyOutboundHandler extends {@link ChannelOutboundHandlerAdapter} {
  *     {@code @Override}
  *     public void close({@link ChannelHandlerContext} ctx, {@link ChannelPromise} promise) {
  *         System.out.println("Closing ..");

File: transport/src/main/java/io/netty/channel/PendingWriteQueue.java
Patch:
@@ -85,7 +85,7 @@ private int size(Object msg) {
         // we should add them to the queue and let removeAndFailAll() fail them later.
         int messageSize = estimatorHandle.size(msg);
         if (messageSize < 0) {
-            // Size may be unknow so just use 0
+            // Size may be unknown so just use 0
             messageSize = 0;
         }
         return messageSize + PENDING_WRITE_OVERHEAD;

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -406,7 +406,7 @@ private void flushOutbound0() {
     }
 
     /**
-     * Mark this {@link Channel} as finished. Any futher try to write data to it will fail.
+     * Mark this {@link Channel} as finished. Any further try to write data to it will fail.
      *
      * @return bufferReadable returns {@code true} if any of the used buffers has something left to read
      */
@@ -416,7 +416,7 @@ public boolean finish() {
 
     /**
      * Mark this {@link Channel} as finished and release all pending message in the inbound and outbound buffer.
-     * Any futher try to write data to it will fail.
+     * Any further try to write data to it will fail.
      *
      * @return bufferReadable returns {@code true} if any of the used buffers has something left to read
      */
@@ -425,7 +425,7 @@ public boolean finishAndReleaseAll() {
     }
 
     /**
-     * Mark this {@link Channel} as finished. Any futher try to write data to it will fail.
+     * Mark this {@link Channel} as finished. Any further try to write data to it will fail.
      *
      * @param releaseAll if {@code true} all pending message in the inbound and outbound buffer are released.
      * @return bufferReadable returns {@code true} if any of the used buffers has something left to read

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -606,7 +606,7 @@ private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
                 // to close ch.
                 return;
             }
-            // Only close ch if ch is still registerd to this EventLoop. ch could have deregistered from the event loop
+            // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
             // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
             // still healthy and should not be closed.
             // See https://github.com/netty/netty/issues/5125
@@ -716,7 +716,7 @@ int selectNow() throws IOException {
         try {
             return selector.selectNow();
         } finally {
-            // restore wakup state if needed
+            // restore wakeup state if needed
             if (wakenUp.get()) {
                 selector.wakeup();
             }

File: transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java
Patch:
@@ -283,7 +283,7 @@ private void doReleaseChannel(Channel channel, Promise<Void> promise) {
         // Remove the POOL_KEY attribute from the Channel and check if it was acquired from this pool, if not fail.
         if (channel.attr(POOL_KEY).getAndSet(null) != this) {
             closeAndFail(channel,
-                         // Better include a stracktrace here as this is an user error.
+                         // Better include a stacktrace here as this is an user error.
                          new IllegalArgumentException(
                                  "Channel " + channel + " was not acquired from this ChannelPool"),
                          promise);
@@ -315,7 +315,7 @@ public void operationComplete(Future<Boolean> future) throws Exception {
     }
 
     /**
-     * Adds the channel back to the pool only if the channel is healty.
+     * Adds the channel back to the pool only if the channel is healthy.
      * @param channel the channel to put back to the pool
      * @param promise offer operation promise.
      * @param future the future that contains information fif channel is healthy or not.

File: transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
Patch:
@@ -341,7 +341,7 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio
         ch.runPendingTasks();
         assertThat(buf.toString(), is("false "));
 
-        // Ensure reducing the totalPendingWriteBytes down to zero does not trigger channelWritabilityChannged()
+        // Ensure reducing the totalPendingWriteBytes down to zero does not trigger channelWritabilityChanged()
         // because of the user-defined writability flag.
         ch.flush();
         assertThat(cob.totalPendingWriteBytes(), is(0L));

File: transport/src/test/java/io/netty/channel/CombinedChannelDuplexHandlerTest.java
Patch:
@@ -76,7 +76,7 @@ public void testInboundHandlerImplementsOutboundHandler() {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testOutboundHandlerImplementsInbboundHandler() {
+    public void testOutboundHandlerImplementsInboundHandler() {
         new CombinedChannelDuplexHandler<ChannelInboundHandler, ChannelOutboundHandler>(
                 new ChannelInboundHandlerAdapter(), new ChannelDuplexHandler());
     }

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -771,7 +771,7 @@ public void testHandlerAddedAndRemovedCalledInCorrectOrder() throws Throwable {
     }
 
     @Test(timeout = 3000)
-    public void testHandlerAddedExceptionFromChildHandlerIsPropegated() {
+    public void testHandlerAddedExceptionFromChildHandlerIsPropagated() {
         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
         try {
             final Promise<Void> promise = group1.next().newPromise();
@@ -795,7 +795,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Test(timeout = 3000)
-    public void testHandlerRemovedExceptionFromChildHandlerIsPropegated() {
+    public void testHandlerRemovedExceptionFromChildHandlerIsPropagated() {
         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
         try {
             final Promise<Void> promise = group1.next().newPromise();

File: transport/src/test/java/io/netty/channel/ReentrantChannelTest.java
Patch:
@@ -70,7 +70,7 @@ public void testWritabilityChanged() throws Exception {
         //    -> flush() and channelWritabilityChanged() will be triggered.
         //
         // Note that the channelWritabilityChanged() in the step 4 can occur between
-        // the flush() and the channelWritabilityChanged() in the stap 5, because
+        // the flush() and the channelWritabilityChanged() in the step 5, because
         // the flush() is invoked from a non-I/O thread while the other are from
         // an I/O thread.
 

File: transport/src/test/java/io/netty/channel/group/DefaultChannelGroupTest.java
Patch:
@@ -25,7 +25,7 @@
 import io.netty.util.concurrent.GlobalEventExecutor;
 import org.junit.Test;
 
-public class DefaultChannnelGroupTest {
+public class DefaultChannelGroupTest {
 
     // Test for #1183
     @Test

File: transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
Patch:
@@ -892,7 +892,7 @@ private static void closeChannel(Channel cc) {
     static class TestHandler extends ChannelInboundHandlerAdapter {
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-            logger.info(String.format("Received mesage: %s", msg));
+            logger.info(String.format("Received message: %s", msg));
             ReferenceCountUtil.safeRelease(msg);
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -894,9 +894,7 @@ private String encodeAttribute(String s, Charset charset) throws ErrorDataEncode
     private ByteBuf fillByteBuf() {
         int length = currentBuffer.readableBytes();
         if (length > HttpPostBodyUtil.chunkSize) {
-            ByteBuf slice = currentBuffer.slice(currentBuffer.readerIndex(), HttpPostBodyUtil.chunkSize);
-            currentBuffer.skipBytes(HttpPostBodyUtil.chunkSize);
-            return slice;
+            return currentBuffer.readRetainedSlice(HttpPostBodyUtil.chunkSize);
         } else {
             // to continue
             ByteBuf slice = currentBuffer;

File: transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
Patch:
@@ -832,9 +832,9 @@ public ChannelFuture writeAndFlush(Object msg) {
     }
 
     private static void notifyOutboundHandlerException(Throwable cause, ChannelPromise promise) {
-        if (!(promise instanceof VoidChannelPromise)) {
-            PromiseNotificationUtil.tryFailure(promise, cause, logger);
-        }
+        // Only log if the given promise is not of type VoidChannelPromise as tryFailure(...) is expected to return
+        // false.
+        PromiseNotificationUtil.tryFailure(promise, cause, promise instanceof VoidChannelPromise ? null : logger);
     }
 
     private void notifyHandlerException(Throwable cause) {

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -108,7 +108,7 @@ public String toString() {
     private static String encodeComponent(String s, Charset charset) {
         // TODO: Optimize me.
         try {
-            return URLEncoder.encode(s, PATTERN.matcher(charset.name()).replaceAll("%20"));
+            return PATTERN.matcher(URLEncoder.encode(s, charset.name())).replaceAll("%20");
         } catch (UnsupportedEncodingException ignored) {
             throw new UnsupportedCharsetException(charset.name());
         }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -62,6 +62,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.DNS_PORT;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static io.netty.util.internal.ObjectUtil.checkPositive;
 import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
@@ -288,7 +289,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
     // Only here to override in unit tests.
     int dnsRedirectPort(@SuppressWarnings("unused") InetAddress server) {
-        return DnsServerAddresses.DNS_PORT;
+        return DNS_PORT;
     }
 
     /**

File: resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.List;
 import java.util.Map;
 
-import static io.netty.resolver.dns.DnsServerAddresses.DNS_PORT;
+import static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.DNS_PORT;
 import static io.netty.util.internal.StringUtil.indexOfNonWhiteSpace;
 
 /**

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -69,6 +69,7 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
+import static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.DNS_PORT;
 import static io.netty.resolver.dns.DnsServerAddresses.sequential;
 import static org.hamcrest.Matchers.greaterThan;
 import static org.hamcrest.Matchers.hasSize;
@@ -774,7 +775,7 @@ HostsFileEntriesResolver.DEFAULT, new SingletonDnsServerAddressStreamProvider(dn
             @Override
             int dnsRedirectPort(InetAddress server) {
                 return server.equals(dnsServerAuthority.localAddress().getAddress()) ?
-                        dnsServerAuthority.localAddress().getPort() : DnsServerAddresses.DNS_PORT;
+                        dnsServerAuthority.localAddress().getPort() : DNS_PORT;
             }
         };
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.IdentityHashMap;
 import java.util.Set;
 
+import static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.defaultAddressList;
 import static org.hamcrest.Matchers.*;
 import static org.junit.Assert.*;
 
@@ -35,7 +36,7 @@ public class DnsServerAddressesTest {
 
     @Test
     public void testDefaultAddresses() {
-        assertThat(DnsServerAddresses.defaultAddressList().size(), is(greaterThan(0)));
+        assertThat(defaultAddressList().size(), is(greaterThan(0)));
     }
 
     @Test

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -54,10 +54,10 @@ public final class ReferenceCountedOpenSslClientContext extends ReferenceCounted
                                          X509Certificate[] keyCertChain, PrivateKey key, String keyPassword,
                                          KeyManagerFactory keyManagerFactory, Iterable<String> ciphers,
                                          CipherSuiteFilter cipherFilter, ApplicationProtocolConfig apn,
-                                         String[] protocols, long sessionCacheSize, long sessionTimeout)
-            throws SSLException {
+                                         String[] protocols, long sessionCacheSize, long sessionTimeout,
+                                         boolean enableOcsp) throws SSLException {
         super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, keyCertChain,
-              ClientAuth.NONE, protocols, false, true);
+              ClientAuth.NONE, protocols, false, enableOcsp, true);
         boolean success = false;
         try {
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -615,7 +615,7 @@ public final boolean release(int decrement) {
         return refCnt.release(decrement);
     }
 
-    abstract static class AbstractCertificateVerifier implements CertificateVerifier {
+    abstract static class AbstractCertificateVerifier extends CertificateVerifier {
         private final OpenSslEngineMap engineMap;
 
         AbstractCertificateVerifier(OpenSslEngineMap engineMap) {

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -71,7 +71,7 @@
  * <ol>
  * <li>Request #1 returns the content of {@code /file1.txt}.</li>
  * <li>Contents of {@code /file1.txt} is cached by the browser.</li>
- * <li>Request #2 for {@code /file1.txt} does return the contents of the
+ * <li>Request #2 for {@code /file1.txt} does not return the contents of the
  *     file again. Rather, a 304 Not Modified is returned. This tells the
  *     browser to use the contents stored in its cache.</li>
  * <li>The server knows the file has not been modified because the

File: handler/src/test/java/io/netty/handler/ssl/JdkConscryptSslEngineInteropTest.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.ssl;
 
 import java.security.Provider;
-import org.conscrypt.OpenSSLProvider;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -62,7 +61,7 @@ protected SslProvider sslServerProvider() {
 
     @Override
     protected Provider serverSslContextProvider() {
-        return new OpenSSLProvider();
+        return Java8SslUtils.conscryptProvider();
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java
Patch:
@@ -103,6 +103,7 @@ private boolean shouldKeepAlive() {
      * <p>
      * <ul>
      *     <li>See <a href="https://tools.ietf.org/html/rfc7230#section-6.3"/></li>
+     *     <li>See <a href="https://tools.ietf.org/html/rfc7230#section-3.3.2"/></li>
      *     <li>See <a href="https://tools.ietf.org/html/rfc7230#section-3.3.3"/></li>
      * </ul>
      *
@@ -112,7 +113,7 @@ private boolean shouldKeepAlive() {
      */
     private static boolean isSelfDefinedMessageLength(HttpResponse response) {
         return isContentLengthSet(response) || isTransferEncodingChunked(response) || isMultipart(response) ||
-               isInformational(response);
+               isInformational(response) || response.status().code() == HttpResponseStatus.NO_CONTENT.code();
     }
 
     private static boolean isInformational(HttpResponse response) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -34,6 +34,7 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.StringUtil;
 
 import java.net.IDN;
@@ -96,7 +97,7 @@ protected DnsNameResolverContext(DnsNameResolver parent,
         this.additionals = additionals;
         this.resolveCache = resolveCache;
 
-        this.nameServerAddrs = nameServerAddrs;
+        this.nameServerAddrs = ObjectUtil.checkNotNull(nameServerAddrs, "nameServerAddrs");
         maxAllowedQueries = parent.maxQueriesPerResolve();
         resolvedInternetProtocolFamilies = parent.resolvedInternetProtocolFamiliesUnsafe();
         traceEnabled = parent.isTraceEnabled();

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java
Patch:
@@ -29,8 +29,9 @@ public interface DnsServerAddressStreamProvider {
     /**
      * Ask this provider for the name servers to query for {@code hostname}.
      * @param hostname The hostname for which to lookup the DNS server addressed to use.
-     * @return The {@link DnsServerAddressStream} which should be used to resolve {@code hostname} or {@code null} to
-     * use the default resolvers.
+     *                 If this is the final {@link DnsServerAddressStreamProvider} to be queried then generally empty
+     *                 string or {@code '.'} correspond to the default {@link DnsServerAddressStream}.
+     * @return The {@link DnsServerAddressStream} which should be used to resolve {@code hostname}.
      */
     DnsServerAddressStream nameServerAddressStream(String hostname);
 }

File: resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java
Patch:
@@ -52,17 +52,17 @@ public final class UnixResolverDnsServerAddressStreamProvider implements DnsServ
 
     /**
      * Attempt to parse {@code /etc/resolv.conf} and files in the {@code /etc/resolver} directory by default.
-     * A failure to parse will return {@link NoopDnsServerAddressStreamProvider}.
+     * A failure to parse will return {@link DefaultDnsServerAddressStreamProvider}.
      */
     public static DnsServerAddressStreamProvider parseSilently() {
         try {
             UnixResolverDnsServerAddressStreamProvider nameServerCache =
                     new UnixResolverDnsServerAddressStreamProvider("/etc/resolv.conf", "/etc/resolver");
             return nameServerCache.mayOverrideNameServers() ? nameServerCache
-                                                            : NoopDnsServerAddressStreamProvider.INSTANCE;
+                                                            : DefaultDnsServerAddressStreamProvider.INSTANCE;
         } catch (Exception e) {
             logger.debug("failed to parse /etc/resolv.conf and/or /etc/resolver", e);
-            return NoopDnsServerAddressStreamProvider.INSTANCE;
+            return DefaultDnsServerAddressStreamProvider.INSTANCE;
         }
     }
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java
Patch:
@@ -60,8 +60,8 @@ public void testSubnetQuery() throws Exception {
     private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {
         return new DnsNameResolverBuilder(group.next())
                 .channelType(NioDatagramChannel.class)
-                .nameServerAddresses(DnsServerAddresses.singleton(SocketUtils.socketAddress("8.8.8.8", 53)))
-                .nameServerCache(NoopDnsServerAddressStreamProvider.INSTANCE)
+                .nameServerProvider(
+                        new SingletonDnsServerAddressStreamProvider(SocketUtils.socketAddress("8.8.8.8", 53)))
                 .maxQueriesPerResolve(1)
                 .optResourceEnabled(false);
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2FrameReaderTest.java
Patch:
@@ -367,7 +367,7 @@ private void writeHeaderFramePriorityPresent(
             Http2Flags flags, int streamDependency, int weight) throws Http2Exception {
         ByteBuf headerBlock = Unpooled.buffer();
         try {
-            writeUnsignedInt(streamDependency, headerBlock);
+            headerBlock.writeInt(streamDependency);
             headerBlock.writeByte(weight - 1);
             hpackEncoder.encodeHeaders(streamId, headerBlock, headers, Http2HeadersEncoder.NEVER_SENSITIVE);
             writeFrameHeader(output, headerBlock.readableBytes(), HEADERS, flags, streamId);
@@ -393,7 +393,7 @@ private void writeContinuationFrame(
     private void writePriorityFrame(
             ByteBuf output, int streamId, int streamDependency, int weight) {
         writeFrameHeader(output, 5, PRIORITY, new Http2Flags(), streamId);
-        writeUnsignedInt(streamDependency, output);
+        output.writeInt(streamDependency);
         output.writeByte(weight - 1);
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java
Patch:
@@ -49,7 +49,7 @@
 import static io.netty.util.internal.ObjectUtil.checkPositive;
 import static io.netty.util.internal.ThrowableUtil.unknownStackTrace;
 
-final class HpackDecoder {
+public final class HpackDecoder {
     private static final Http2Exception DECODE_ULE_128_DECOMPRESSION_EXCEPTION = unknownStackTrace(
             connectionError(COMPRESSION_ERROR, "HPACK - decompression failure"), HpackDecoder.class,
             "decodeULE128(..)");
@@ -96,15 +96,15 @@ final class HpackDecoder {
      *  (which is dangerous).
      * @param initialHuffmanDecodeCapacity Size of an intermediate buffer used during huffman decode.
      */
-    HpackDecoder(long maxHeaderListSize, int initialHuffmanDecodeCapacity) {
+    public HpackDecoder(long maxHeaderListSize, int initialHuffmanDecodeCapacity) {
         this(maxHeaderListSize, initialHuffmanDecodeCapacity, DEFAULT_HEADER_TABLE_SIZE);
     }
 
     /**
      * Exposed Used for testing only! Default values used in the initial settings frame are overriden intentionally
      * for testing but violate the RFC if used outside the scope of testing.
      */
-    HpackDecoder(long maxHeaderListSize, int initialHuffmanDecodeCapacity, int maxHeaderTableSize) {
+    public HpackDecoder(long maxHeaderListSize, int initialHuffmanDecodeCapacity, int maxHeaderTableSize) {
         this.maxHeaderListSize = checkPositive(maxHeaderListSize, "maxHeaderListSize");
         this.maxHeaderListSizeGoAway = Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -1611,7 +1611,8 @@ private boolean isDestroyed() {
     }
 
     static int calculateOutNetBufSize(int pendingBytes, int numComponents) {
-        return (int) min(Integer.MAX_VALUE, pendingBytes + (long) MAX_TLS_RECORD_OVERHEAD_LENGTH * numComponents);
+        return (int) min(MAX_ENCRYPTED_PACKET_LENGTH,
+                pendingBytes + (long) MAX_TLS_RECORD_OVERHEAD_LENGTH * numComponents);
     }
 
     private final class OpenSslSession implements SSLSession, ApplicationProtocolAccessor {

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -317,7 +317,6 @@ static ByteBuffer allocateDirectNoCleaner(int capacity) {
     }
 
     static ByteBuffer newDirectBuffer(long address, int capacity) {
-        ObjectUtil.checkPositiveOrZero(address, "address");
         ObjectUtil.checkPositiveOrZero(capacity, "capacity");
 
         try {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -805,7 +805,7 @@ public void reset() {
 
         @Override
         public boolean process(byte value) throws Exception {
-            char nextByte = (char) value;
+            char nextByte = (char) (value & 0xFF);
             if (nextByte == HttpConstants.CR) {
                 return true;
             }

File: buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java
Patch:
@@ -38,6 +38,8 @@ public void testWriteEmptyByteBuf() {
             fail();
         } catch (IndexOutOfBoundsException ignored) {
             // Ignore.
+        } finally {
+            nonEmpty.release();
         }
     }
 

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -461,7 +461,7 @@ private static void setChannelOption(
             }
         } catch (Throwable t) {
             logger.warn(
-                    "Failed to set channel option '{}' with value '{}' for channel '{}'", option, channel, channel, t);
+                    "Failed to set channel option '{}' with value '{}' for channel '{}'", option, value, channel, t);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1573,7 +1573,7 @@ public boolean contains(String name, String value, boolean ignoreCase) {
 
     /**
      * Returns {@code true} if a header with the {@code name} and {@code value} exists, {@code false} otherwise.
-     * This also handles multiple values that are seperated with a {@code ,}.
+     * This also handles multiple values that are separated with a {@code ,}.
      * <p>
      * If {@code ignoreCase} is {@code true} then a case insensitive compare is done on the value.
      * @param name the name of the header to find

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java
Patch:
@@ -28,7 +28,7 @@
 
 import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionTestUtil.*;
 import static org.junit.Assert.*;
-import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java
Patch:
@@ -31,7 +31,7 @@
 import io.netty.handler.codec.http.HttpVersion;
 import org.mockito.ArgumentMatcher;
 
-import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.Mockito.argThat;
 
 public final class WebSocketExtensionTestUtil {
 

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
Patch:
@@ -27,9 +27,7 @@
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.SPDY_HEADER_SIZE;
 import static org.junit.Assert.*;
-import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.*;
-import static org.mockito.Mockito.verify;
 
 public class SpdyFrameDecoderTest {
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java
Patch:
@@ -198,7 +198,7 @@ public void dataWriteShouldSucceed() throws Exception {
         final ByteBuf data = dummyData();
         ChannelPromise p = newPromise();
         encoder.writeData(ctx, STREAM_ID, data, 0, true, p);
-        assertEquals(payloadCaptor.getValue().size(), 8);
+        assertEquals(8, payloadCaptor.getValue().size());
         payloadCaptor.getValue().write(ctx, 8);
         assertEquals(0, payloadCaptor.getValue().size());
         assertEquals("abcdefgh", writtenData.get(0));
@@ -308,7 +308,7 @@ private void assertSplitPaddingOnEmptyBuffer(ByteBuf data) throws Exception {
         when(frameSizePolicy.maxFrameSize()).thenReturn(5);
         ChannelPromise p = newPromise();
         encoder.writeData(ctx, STREAM_ID, data, 10, true, p);
-        assertEquals(payloadCaptor.getValue().size(), 10);
+        assertEquals(10, payloadCaptor.getValue().size());
         payloadCaptor.getValue().write(ctx, 10);
         // writer was called 2 times
         assertEquals(1, writtenData.size());

File: common/src/test/java/io/netty/util/DefaultAttributeMapTest.java
Patch:
@@ -59,7 +59,7 @@ public void testGetSetInt() {
         assertSame(one, map.attr(key));
 
         one.setIfAbsent(3653);
-        assertEquals(one.get(), Integer.valueOf(3653));
+        assertEquals(Integer.valueOf(3653), one.get());
 
         one.setIfAbsent(1);
         assertNotSame(1, one.get());

File: transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
Patch:
@@ -430,7 +430,7 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
 
       // There was no #flushInbound() call so nobody should have called
       // #channelReadComplete()
-      assertEquals(flushCount.get(), 0);
+      assertEquals(0, flushCount.get());
     }
 
     @Test

File: codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java
Patch:
@@ -261,7 +261,7 @@ private void flushBufferedData(ByteBuf out) {
             ByteBuffer outNioBuffer = out.internalNioBuffer(idx + HEADER_LENGTH, out.writableBytes() - HEADER_LENGTH);
             int pos = outNioBuffer.position();
             // We always want to start at position 0 as we take care of reusing the buffer in the encode(...) loop.
-            compressor.compress(buffer.internalNioBuffer(0, flushableBytes), outNioBuffer);
+            compressor.compress(buffer.internalNioBuffer(buffer.readerIndex(), flushableBytes), outNioBuffer);
             compressedLength = outNioBuffer.position() - pos;
         } catch (LZ4Exception e) {
             throw new CompressionException(e);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -135,7 +135,7 @@ protected FullHttpRequest newHandshakeRequest() {
         HttpHeaders headers = request.headers();
         headers.add(HttpHeaderNames.UPGRADE, WEBSOCKET)
                .add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
-               .add(HttpHeaderNames.HOST, host)
+               .add(HttpHeaderNames.HOST, websocketHostValue(wsURL))
                .add(HttpHeaderNames.ORIGIN, websocketOriginValue(host, wsPort))
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY1, key1)
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY2, key2);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -151,7 +151,7 @@ protected FullHttpRequest newHandshakeRequest() {
         headers.add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
                .add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY, key)
-               .add(HttpHeaderNames.HOST, host)
+               .add(HttpHeaderNames.HOST, websocketHostValue(wsURL))
                .add(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(host, wsPort));
 
         String expectedSubprotocol = expectedSubprotocol();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -152,7 +152,7 @@ protected FullHttpRequest newHandshakeRequest() {
         headers.add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
                .add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY, key)
-               .add(HttpHeaderNames.HOST, host)
+               .add(HttpHeaderNames.HOST, websocketHostValue(wsURL))
                .add(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(host, wsPort));
 
         String expectedSubprotocol = expectedSubprotocol();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -151,7 +151,7 @@ protected FullHttpRequest newHandshakeRequest() {
         headers.add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET)
                .add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE)
                .add(HttpHeaderNames.SEC_WEBSOCKET_KEY, key)
-               .add(HttpHeaderNames.HOST, host + ':' + wsPort)
+               .add(HttpHeaderNames.HOST, websocketHostValue(wsURL))
                .add(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(host, wsPort));
 
         String expectedSubprotocol = expectedSubprotocol();

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.util.internal.PlatformDependent;
 
-final class UnpooledUnsafeHeapByteBuf extends UnpooledHeapByteBuf {
+class UnpooledUnsafeHeapByteBuf extends UnpooledHeapByteBuf {
 
     /**
      * Creates a new heap buffer with a newly allocated byte array.

File: buffer/src/test/java/io/netty/buffer/UnpooledByteBufAllocatorTest.java
Patch:
@@ -15,15 +15,15 @@
  */
 package io.netty.buffer;
 
-public class UnpooledByteBufAllocatorTest extends AbstractByteBufAllocatorTest {
+public class UnpooledByteBufAllocatorTest extends AbstractByteBufAllocatorTest<UnpooledByteBufAllocator> {
 
     @Override
-    protected AbstractByteBufAllocator newAllocator(boolean preferDirect) {
+    protected UnpooledByteBufAllocator newAllocator(boolean preferDirect) {
         return new UnpooledByteBufAllocator(preferDirect);
     }
 
     @Override
-    protected AbstractByteBufAllocator newUnpooledAllocator() {
+    protected UnpooledByteBufAllocator newUnpooledAllocator() {
         return new UnpooledByteBufAllocator(false);
     }
 }

File: transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
Patch:
@@ -39,7 +39,10 @@
 
 /**
  * The default {@link UdtChannelConfig} implementation.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class DefaultUdtChannelConfig extends DefaultChannelConfig implements
         UdtChannelConfig {
 

File: transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java
Patch:
@@ -29,7 +29,10 @@
 
 /**
  * The default {@link UdtServerChannelConfig} implementation.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class DefaultUdtServerChannelConfig extends DefaultUdtChannelConfig
         implements UdtServerChannelConfig {
 

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannel.java
Patch:
@@ -24,7 +24,10 @@
  * UDT {@link Channel}.
  * <p>
  * Supported UDT {@link UdtChannel} are available via {@link NioUdtProvider}.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public interface UdtChannel extends Channel {
 
     /**

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
Patch:
@@ -70,7 +70,10 @@
  * {@code "receiveBufferSize"} and {@code "sendBufferSize"} as maximum message
  * size. If received or sent message does not fit specified sizes,
  * {@link ChannelException} will be thrown.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public interface UdtChannelConfig extends ChannelConfig {
 
     /**

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
Patch:
@@ -20,7 +20,10 @@
 
 /**
  * Options for the UDT transport
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public final class UdtChannelOption<T> extends ChannelOption<T> {
 
     /**

File: transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
Patch:
@@ -24,7 +24,10 @@
  * The message container that is used for {@link TypeUDT#DATAGRAM} messages.
  * @see NioUdtProvider#MESSAGE_CONNECTOR
  * @see NioUdtProvider#MESSAGE_RENDEZVOUS
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public final class UdtMessage extends DefaultByteBufHolder {
 
     public UdtMessage(final ByteBuf data) {

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannel.java
Patch:
@@ -22,7 +22,10 @@
  * UDT {@link ServerChannel}.
  * <p>
  * Supported UDT {@link UdtServerChannel} are available via {@link NioUdtProvider}.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public interface UdtServerChannel extends ServerChannel, UdtChannel {
 
 }

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
Patch:
@@ -32,7 +32,10 @@
  * {@code "receiveBufferSize"} and {@code "sendBufferSize"} as maximum message
  * size. If received or sent message does not fit specified sizes,
  * {@link ChannelException} will be thrown.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public interface UdtServerChannelConfig extends UdtChannelConfig {
 
     /**

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java
Patch:
@@ -38,7 +38,10 @@
 
 /**
  * Common base for Netty Byte/Message UDT Stream/Datagram acceptors.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public abstract class NioUdtAcceptorChannel extends AbstractNioMessageChannel implements UdtServerChannel {
 
     protected static final InternalLogger logger =

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteAcceptorChannel.java
Patch:
@@ -21,7 +21,10 @@
 
 /**
  * Byte Channel Acceptor for UDT Streams.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class NioUdtByteAcceptorChannel extends NioUdtAcceptorChannel {
 
     public NioUdtByteAcceptorChannel() {

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
Patch:
@@ -42,7 +42,10 @@
 
 /**
  * Byte Channel Connector for UDT Streams.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class NioUdtByteConnectorChannel extends AbstractNioByteChannel implements UdtChannel {
 
     private static final InternalLogger logger =

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteRendezvousChannel.java
Patch:
@@ -19,7 +19,10 @@
 
 /**
  * Byte Channel Rendezvous for UDT Streams.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class NioUdtByteRendezvousChannel extends NioUdtByteConnectorChannel {
 
     public NioUdtByteRendezvousChannel() {

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageAcceptorChannel.java
Patch:
@@ -21,7 +21,10 @@
 
 /**
  * Message Channel Acceptor for UDT Datagrams.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class NioUdtMessageAcceptorChannel extends NioUdtAcceptorChannel {
 
     public NioUdtMessageAcceptorChannel() {

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java
Patch:
@@ -41,7 +41,10 @@
  * Message Connector for UDT Datagrams.
  * <p>
  * Note: send/receive must use {@link UdtMessage} in the pipeline
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class NioUdtMessageConnectorChannel extends AbstractNioMessageChannel implements UdtChannel {
 
     private static final InternalLogger logger =

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageRendezvousChannel.java
Patch:
@@ -22,7 +22,10 @@
  * Message Rendezvous for UDT Datagrams.
  * <p>
  * Note: send/receive must use {@link UdtMessage} in the pipeline
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public class NioUdtMessageRendezvousChannel extends NioUdtMessageConnectorChannel {
 
     public NioUdtMessageRendezvousChannel() {

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java
Patch:
@@ -38,7 +38,10 @@
  * Provides {@link ChannelFactory} for UDT channels.
  * <p>
  * Provides {@link SelectorProvider} for UDT channels.
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 public final class NioUdtProvider<T extends UdtChannel> implements ChannelFactory<T> {
 
     /**

File: transport-udt/src/main/java/io/netty/channel/udt/nio/package-info.java
Patch:
@@ -17,6 +17,9 @@
  * UDT Transport for NIO Channels.
  * <p>
  * @see io.netty.example.udt
+ *
+ * @deprecated The UDT transport is no longer maintained.
  */
+@Deprecated
 package io.netty.channel.udt.nio;
 

File: transport-udt/src/main/java/io/netty/channel/udt/package-info.java
Patch:
@@ -17,6 +17,9 @@
  * UDT Transport.
  * <p>
  * @see io.netty.example.udt
+ *
+ * @deprecated The UDT transport is no longer maintained and will be removed.
  */
+@Deprecated
 package io.netty.channel.udt;
 

File: buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
Patch:
@@ -92,7 +92,7 @@ public ByteBufInputStream(ByteBuf buffer, boolean releaseOnClose) {
      * Creates a new stream which reads data from the specified {@code buffer}
      * starting at the current {@code readerIndex} and ending at
      * {@code readerIndex + length}.
-     * @param buffer The buffer which provides the content for this {@Link InputStream}.
+     * @param buffer The buffer which provides the content for this {@link InputStream}.
      * @param length The length of the buffer to use for this {@link InputStream}.
      * @param releaseOnClose {@code true} means that when {@link #close()} is called then {@link ByteBuf#release()} will
      *                       be called on {@code buffer}.

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -32,8 +32,9 @@
 /**
  * Acts a Thread cache for allocations. This implementation is moduled after
  * <a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">jemalloc</a> and the descripted
- * technics of <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/
- * 480222803919">Scalable memory allocation using jemalloc</a>.
+ * technics of
+ * <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">
+ * Scalable memory allocation using jemalloc</a>.
  */
 final class PoolThreadCache {
 

File: codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http;
 
+import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
+
 /**
  * A <a href="http://tools.ietf.org/html/rfc6265">RFC6265</a> compliant cookie encoder to be used client side,
  * so only name=value pairs are sent.

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http;
 
+import io.netty.handler.codec.http.cookie.ServerCookieDecoder;
+
 import java.util.Collection;
 import java.util.List;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java
Patch:
@@ -223,12 +223,12 @@ public void run() {
     protected abstract void doWrite(Object msg) throws Exception;
 
     /**
-     * Process end of batch of {@link #doWrite()}s. May be called from any thread.
+     * Process end of batch of {@link #doWrite(ChannelOutboundBuffer)}s. May be called from any thread.
      */
     protected abstract void doWriteComplete();
 
     /**
-     * The ideal thread for events like {@link #doWrite()} to be processed on. May be used for
+     * The ideal thread for events like {@link #doWrite(ChannelOutboundBuffer)} to be processed on. May be used for
      * efficient batching, but not required.
      */
     protected abstract EventExecutor preferredEventExecutor();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -83,7 +83,7 @@ public DefaultHttp2FrameReader() {
     /**
      * Create a new instance.
      * @param validateHeaders {@code true} to validate headers. {@code false} to not validate headers.
-     * @see {@link DefaultHttp2HeadersDecoder(boolean)}
+     * @see DefaultHttp2HeadersDecoder(boolean)
      */
     public DefaultHttp2FrameReader(boolean validateHeaders) {
         this(new DefaultHttp2HeadersDecoder(validateHeaders));

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -664,7 +664,6 @@ protected void onStreamError(ChannelHandlerContext ctx, @SuppressWarnings("unuse
      *
      * @param ctx the channel context
      * @param stream the Http2Stream on which the header was received
-     * @throws Http2Exception if an exception occurs while processing the decode error.
      */
     protected void handleServerHeaderDecodeSizeError(ChannelHandlerContext ctx, Http2Stream stream) {
         encoder().writeHeaders(ctx, stream.id(), HEADERS_TOO_LARGE_HEADERS, 0, true, ctx.newPromise());

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -127,7 +127,7 @@ public void onStreamRemoved(Http2Stream stream) {
      *
      * @param ctx The context to fire the event on
      * @param msg The message to send
-     * @param release {@code true} to release if present in {@link #messageMap}. {@code false} otherwise.
+     * @param release {@code true} to call release on the value if it is present. {@code false} to not call release.
      * @param stream the stream of the message which is being fired
      */
     protected void fireChannelRead(ChannelHandlerContext ctx, FullHttpMessage msg, boolean release,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
Patch:
@@ -38,7 +38,7 @@ interface StreamState {
          * Get the amount of bytes this stream has pending to send. The actual amount written must not exceed
          * {@link #windowSize()}!
          * @return The amount of bytes this stream has pending to send.
-         * @see {@link io.netty.handler.codec.http2.Http2CodecUtil#streamableBytes(StreamState)}
+         * @see Http2CodecUtil#streamableBytes(StreamState)
          */
         int pendingBytes();
 
@@ -54,7 +54,7 @@ interface StreamState {
          * an stream has been given a chance to write an empty frame, and also enables optimizations like not writing
          * empty frames in some situations (don't write headers until data can also be written).
          * @return the size of the stream's flow control window.
-         * @see {@link io.netty.handler.codec.http2.Http2CodecUtil#streamableBytes(StreamState)}
+         * @see Http2CodecUtil#streamableBytes(StreamState)
          */
         int windowSize();
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
Patch:
@@ -48,8 +48,7 @@
  * bytes.
  * <p>
  * Inspiration for this distributor was taken from Linux's
- * <a href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/Documentation/scheduler
- * /sched-design-CFS.txt">Completely Fair Scheduler</a>
+ * <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt">Completely Fair Scheduler</a>
  * to model the distribution of bytes to simulate an "ideal multi-tasking CPU", but in this case we are simulating
  * an "ideal multi-tasking NIC".
  * <p>

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanEncoder.java
Patch:
@@ -116,7 +116,7 @@ private void encodeSlowPath(ByteBuf out, CharSequence data) {
      * Returns the number of bytes required to Huffman encode the input string literal.
      *
      * @param data the string literal to be Huffman encoded
-     * @return the number of bytes required to Huffman encode <code>data</code>
+     * @return the number of bytes required to Huffman encode {@code data}
      */
     int getEncodedLength(CharSequence data) {
         if (data instanceof AsciiString) {

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
Patch:
@@ -49,14 +49,14 @@ protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
     };
 
     /**
-     * @see {@link #ByteToMessageCodec(boolean)} with {@code true} as boolean parameter.
+     * see {@link #ByteToMessageCodec(boolean)} with {@code true} as boolean parameter.
      */
     protected ByteToMessageCodec() {
         this(true);
     }
 
     /**
-     * @see {@link #ByteToMessageCodec(Class, boolean)} with {@code true} as boolean value.
+     * see {@link #ByteToMessageCodec(Class, boolean)} with {@code true} as boolean value.
      */
     protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {
         this(outboundMessageType, true);

File: codec/src/main/java/io/netty/handler/codec/DateFormatter.java
Patch:
@@ -88,8 +88,8 @@ public static Date parseHttpDate(CharSequence txt) {
     /**
      * Parse some text into a {@link Date}, according to RFC6265
      * @param txt text to parse
-     * @param start the start index inside <code>txt</code>
-     * @param end the end index inside <code>txt</code>
+     * @param start the start index inside {@code txt}
+     * @param end the end index inside {@code txt}
      * @return a {@link Date}, or null if text couldn't be parsed
      */
     public static Date parseHttpDate(CharSequence txt, int start, int end) {

File: codec/src/main/java/io/netty/handler/codec/Headers.java
Patch:
@@ -971,9 +971,9 @@ public interface Headers<K, V, T extends Headers<K, V, T>> extends Iterable<Entr
     T set(Headers<? extends K, ? extends V, ?> headers);
 
     /**
-     * Retains all current headers but calls {@link #set(T, T)} for each entry in {@code headers}.
+     * Retains all current headers but calls {@link #set(K, V)} for each entry in {@code headers}.
      *
-     * @param headers The headers used to {@link #set(T, T)} values in this instance
+     * @param headers The headers used to {@link #set(K, V)} values in this instance
      * @return {@code this}
      */
     T setAll(Headers<? extends K, ? extends V, ?> headers);

File: codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
Patch:
@@ -49,14 +49,14 @@ public abstract class MessageToByteEncoder<I> extends ChannelOutboundHandlerAdap
     private final boolean preferDirect;
 
     /**
-     * @see {@link #MessageToByteEncoder(boolean)} with {@code true} as boolean parameter.
+     * see {@link #MessageToByteEncoder(boolean)} with {@code true} as boolean parameter.
      */
     protected MessageToByteEncoder() {
         this(true);
     }
 
     /**
-     * @see {@link #MessageToByteEncoder(Class, boolean)} with {@code true} as boolean value.
+     * see {@link #MessageToByteEncoder(Class, boolean)} with {@code true} as boolean value.
      */
     protected MessageToByteEncoder(Class<? extends I> outboundMessageType) {
         this(outboundMessageType, true);

File: codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java
Patch:
@@ -76,7 +76,7 @@ static ByteBufChecksum wrapChecksum(Checksum checksum) {
     }
 
     /**
-     * @see {@link #update(byte[], int, int)}.
+     * @see #update(byte[], int, int)
      */
     public void update(ByteBuf b, int off, int len) {
         if (b.hasArray()) {

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -21,7 +21,7 @@
  * Uncompresses an input {@link ByteBuf} encoded with Snappy compression into an
  * output {@link ByteBuf}.
  *
- * See <a href="http://code.google.com/p/snappy/source/browse/trunk/format_description.txt">snappy format</a>.
+ * See <a href="https://github.com/google/snappy/blob/master/format_description.txt">snappy format</a>.
  */
 public final class Snappy {
 

File: codec/src/main/java/io/netty/handler/codec/compression/package-info.java
Patch:
@@ -18,6 +18,6 @@
  * Encoder and decoder which compresses and decompresses {@link io.netty.buffer.ByteBuf}s
  * in a compression format such as <a href="http://en.wikipedia.org/wiki/Zlib">zlib</a>,
  * <a href="http://en.wikipedia.org/wiki/Gzip">gzip</a>, and
- * <a href="http://code.google.com/p/snappy/">Snappy</a>.
+ * <a href="https://github.com/google/snappy">Snappy</a>.
  */
 package io.netty.handler.codec.compression;

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
Patch:
@@ -37,7 +37,8 @@
  * +--------+---------------+      +---------------+
  * </pre>
  *
- * @see {@link CodedInputStream} or {@link CodedInputByteBufferNano}
+ * @see CodedInputStream
+ * @see CodedInputByteBufferNano
  */
 public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {
 

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -37,7 +37,7 @@
  * A string which has been encoded into a character encoding whose character always takes a single byte, similarly to
  * ASCII. It internally keeps its content in a byte array unlike {@link String}, which uses a character array, for
  * reduced memory footprint and faster data transfer from/to byte-based data structures such as a byte array and
- * {@link ByteBuffer}. It is often used in conjunction with {@link Headers} that require a {@link CharSequence}.
+ * {@link ByteBuffer}. It is often used in conjunction with {@code Headers} that require a {@link CharSequence}.
  * <p>
  * This class was designed to provide an immutable array of bytes, and caches some internal state based upon the value
  * of this array. However underlying access to this byte array is provided via not copying the array on construction or
@@ -1144,7 +1144,7 @@ public boolean equals(Object obj) {
 
     /**
      * Translates the entire byte string to a {@link String}.
-     * @see {@link #toString(int)}
+     * @see #toString(int)
      */
     @Override
     public String toString() {
@@ -1157,7 +1157,7 @@ public String toString() {
 
     /**
      * Translates the entire byte string to a {@link String} using the {@code charset} encoding.
-     * @see {@link #toString(int, int)}
+     * @see #toString(int, int)
      */
     public String toString(int start) {
         return toString(start, length());

File: common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
Patch:
@@ -75,7 +75,7 @@ protected void cancelScheduledTasks() {
     }
 
     /**
-     * @see {@link #pollScheduledTask(long)}
+     * @see #pollScheduledTask(long)
      */
     protected final Runnable pollScheduledTask() {
         return pollScheduledTask(nanoTime());

File: common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java
Patch:
@@ -24,7 +24,7 @@
  */
 public class DefaultEventExecutorGroup extends MultithreadEventExecutorGroup {
     /**
-     * @see {@link #DefaultEventExecutorGroup(int, ThreadFactory)}
+     * @see #DefaultEventExecutorGroup(int, ThreadFactory)
      */
     public DefaultEventExecutorGroup(int nThreads) {
         this(nThreads, null);

File: handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
Patch:
@@ -88,9 +88,6 @@ public JdkSslClientContext(File certChainFile, TrustManagerFactory trustManagerF
     }
 
     /**
-     * @deprecated Use the constructors that accept {@link ApplicationProtocolConfig} or
-     *             {@link ApplicationProtocolNegotiator} instead.
-     *
      * Creates a new instance.
      *
      * @param certChainFile an X.509 certificate chain file in PEM format.

File: handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Stats exposed by an OpenSSL session context.
  *
- * @see <a href="https://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html"><code>SSL_CTX_sess_number</code></a>
+ * @see <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">SSL_CTX_sess_number</a>
  */
 public final class OpenSslSessionStats {
 

File: microbench/src/main/java/io/netty/microbench/http2/internal/hpack/package-info.java
Patch:
@@ -31,6 +31,6 @@
  */
 
 /**
- * Benchmarks for {@link io.netty.handler.codec.http2.hpack}.
+ * Benchmarks for {@link io.netty.handler.codec.http2.internal.hpack}.
  */
 package io.netty.microbench.http2.internal.hpack;

File: transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
Patch:
@@ -22,8 +22,8 @@
 
 /**
  * The message container that is used for {@link TypeUDT#DATAGRAM} messages.
- * @see {@link NioUdtProvider#MESSAGE_CONNECTOR}
- * @see {@link NioUdtProvider#MESSAGE_RENDEZVOUS}
+ * @see NioUdtProvider#MESSAGE_CONNECTOR
+ * @see NioUdtProvider#MESSAGE_RENDEZVOUS
  */
 public final class UdtMessage extends DefaultByteBufHolder {
 

File: transport-udt/src/main/java/io/netty/channel/udt/nio/package-info.java
Patch:
@@ -16,7 +16,7 @@
 /**
  * UDT Transport for NIO Channels.
  * <p>
- * @see /netty/example/src/main/java/io/netty/example/udt
+ * @see io.netty.example.udt
  */
 package io.netty.channel.udt.nio;
 

File: transport-udt/src/main/java/io/netty/channel/udt/package-info.java
Patch:
@@ -16,7 +16,7 @@
 /**
  * UDT Transport.
  * <p>
- * @see /netty/example/src/main/java/io/netty/example/udt
+ * @see io.netty.example.udt
  */
 package io.netty.channel.udt;
 

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -141,21 +141,21 @@ public B localAddress(SocketAddress localAddress) {
     }
 
     /**
-     * @see {@link #localAddress(SocketAddress)}
+     * @see #localAddress(SocketAddress)
      */
     public B localAddress(int inetPort) {
         return localAddress(new InetSocketAddress(inetPort));
     }
 
     /**
-     * @see {@link #localAddress(SocketAddress)}
+     * @see #localAddress(SocketAddress)
      */
     public B localAddress(String inetHost, int inetPort) {
         return localAddress(SocketUtils.socketAddress(inetHost, inetPort));
     }
 
     /**
-     * @see {@link #localAddress(SocketAddress)}
+     * @see #localAddress(SocketAddress)
      */
     public B localAddress(InetAddress inetHost, int inetPort) {
         return localAddress(new InetSocketAddress(inetHost, inetPort));

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -91,15 +91,15 @@ public Bootstrap remoteAddress(SocketAddress remoteAddress) {
     }
 
     /**
-     * @see {@link #remoteAddress(SocketAddress)}
+     * @see #remoteAddress(SocketAddress)
      */
     public Bootstrap remoteAddress(String inetHost, int inetPort) {
         remoteAddress = InetSocketAddress.createUnresolved(inetHost, inetPort);
         return this;
     }
 
     /**
-     * @see {@link #remoteAddress(SocketAddress)}
+     * @see #remoteAddress(SocketAddress)
      */
     public Bootstrap remoteAddress(InetAddress inetHost, int inetPort) {
         remoteAddress = new InetSocketAddress(inetHost, inetPort);
@@ -157,7 +157,7 @@ public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAdd
     }
 
     /**
-     * @see {@link #connect()}
+     * @see #connect()
      */
     private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
         final ChannelFuture regFuture = initAndRegister();

File: transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java
Patch:
@@ -34,7 +34,7 @@ public interface RecvByteBufAllocator {
     Handle newHandle();
 
     /**
-     * @Deprecated Use {@link ExtendedHandle}.
+     * @deprecated Use {@link ExtendedHandle}.
      */
     @Deprecated
     interface Handle {

File: transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
Patch:
@@ -51,7 +51,7 @@ public abstract class SimpleChannelInboundHandler<I> extends ChannelInboundHandl
     private final boolean autoRelease;
 
     /**
-     * @see {@link #SimpleChannelInboundHandler(boolean)} with {@code true} as boolean parameter.
+     * see {@link #SimpleChannelInboundHandler(boolean)} with {@code true} as boolean parameter.
      */
     protected SimpleChannelInboundHandler() {
         this(true);
@@ -69,7 +69,7 @@ protected SimpleChannelInboundHandler(boolean autoRelease) {
     }
 
     /**
-     * @see {@link #SimpleChannelInboundHandler(Class, boolean)} with {@code true} as boolean value.
+     * see {@link #SimpleChannelInboundHandler(Class, boolean)} with {@code true} as boolean value.
      */
     protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType) {
         this(inboundMessageType, true);

File: transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
Patch:
@@ -36,7 +36,7 @@ public abstract class AbstractNioMessageChannel extends AbstractNioChannel {
     boolean inputShutdown;
 
     /**
-     * @see {@link AbstractNioChannel#AbstractNioChannel(Channel, SelectableChannel, int)}
+     * @see AbstractNioChannel#AbstractNioChannel(Channel, SelectableChannel, int)
      */
     protected AbstractNioMessageChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
         super(parent, ch, readInterestOp);

File: codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java
Patch:
@@ -38,7 +38,7 @@ public class XmlDecoder extends ByteToMessageDecoder {
     private static final AsyncXMLInputFactory XML_INPUT_FACTORY = new InputFactoryImpl();
     private static final XmlDocumentEnd XML_DOCUMENT_END = XmlDocumentEnd.INSTANCE;
 
-    private final AsyncXMLStreamReader streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();
+    private final AsyncXMLStreamReader<AsyncByteArrayFeeder> streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();
     private final AsyncByteArrayFeeder streamFeeder = (AsyncByteArrayFeeder) streamReader.getInputFeeder();
 
     @Override

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -478,7 +478,7 @@ private void notifyListenersNow() {
             if (listeners instanceof DefaultFutureListeners) {
                 notifyListeners0((DefaultFutureListeners) listeners);
             } else {
-                notifyListener0(this, (GenericFutureListener<? extends Future<V>>) listeners);
+                notifyListener0(this, (GenericFutureListener<?>) listeners);
             }
             synchronized (this) {
                 if (this.listeners == null) {
@@ -516,7 +516,7 @@ private void addListener0(GenericFutureListener<? extends Future<? super V>> lis
         } else if (listeners instanceof DefaultFutureListeners) {
             ((DefaultFutureListeners) listeners).add(listener);
         } else {
-            listeners = new DefaultFutureListeners((GenericFutureListener<? extends Future<V>>) listeners, listener);
+            listeners = new DefaultFutureListeners((GenericFutureListener<?>) listeners, listener);
         }
     }
 

File: microbench/src/main/java/io/netty/microbench/headers/HeadersBenchmark.java
Patch:
@@ -210,8 +210,8 @@ public void http2AddAllSlow(Blackhole bh) {
     }
 
     private static final class SlowHeaders implements Headers<CharSequence, CharSequence, SlowHeaders> {
-        private final Headers<CharSequence, CharSequence, ? extends Headers> delegate;
-        private SlowHeaders(Headers<CharSequence, CharSequence, ? extends Headers> delegate) {
+        private final Headers<CharSequence, CharSequence, ? extends Headers<?, ?, ?>> delegate;
+        private SlowHeaders(Headers<CharSequence, CharSequence, ? extends Headers<?, ?, ?>> delegate) {
             this.delegate = delegate;
         }
 

File: resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java
Patch:
@@ -68,7 +68,7 @@ private void doResolveRec(final String inetHost,
         if (resolverIndex >= resolvers.length) {
             promise.setFailure(lastFailure);
         } else {
-            NameResolver resolver = resolvers[resolverIndex];
+            NameResolver<T> resolver = resolvers[resolverIndex];
             resolver.resolve(inetHost).addListener(new FutureListener<T>() {
                 @Override
                 public void operationComplete(Future<T> future) throws Exception {
@@ -94,7 +94,7 @@ private void doResolveAllRec(final String inetHost,
         if (resolverIndex >= resolvers.length) {
             promise.setFailure(lastFailure);
         } else {
-            NameResolver resolver = resolvers[resolverIndex];
+            NameResolver<T> resolver = resolvers[resolverIndex];
             resolver.resolveAll(inetHost).addListener(new FutureListener<List<T>>() {
                 @Override
                 public void operationComplete(Future<List<T>> future) throws Exception {

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.InternalThreadLocalMap;
-import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.PromiseNotificationUtil;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -755,7 +754,7 @@ public interface MessageProcessor {
     static final class Entry {
         private static final Recycler<Entry> RECYCLER = new Recycler<Entry>() {
             @Override
-            protected Entry newObject(Handle handle) {
+            protected Entry newObject(Handle<Entry> handle) {
                 return new Entry(handle);
             }
         };

File: handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
Patch:
@@ -286,7 +286,7 @@ public void testMutualAuthValidClientCertChainTooLongFailRequireClientAuth() thr
     @Override
     protected boolean mySetupMutualAuthServerIsValidException(Throwable cause) {
         // TODO(scott): work around for a JDK issue. The exception should be SSLHandshakeException.
-        return super.mySetupMutualAuthServerIsValidException(cause) || cause instanceof SSLException;
+        return super.mySetupMutualAuthServerIsValidException(cause) || causedBySSLException(cause);
     }
 
     private void runTest() throws Exception {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
Patch:
@@ -118,9 +118,10 @@ public void teardown() throws Exception {
             serverChannel.close().sync();
             serverChannel = null;
         }
+        final Channel serverConnectedChannel = this.serverConnectedChannel;
         if (serverConnectedChannel != null) {
             serverConnectedChannel.close().sync();
-            serverConnectedChannel = null;
+            this.serverConnectedChannel = null;
         }
         Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 0, MILLISECONDS);
         Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 0, MILLISECONDS);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java
Patch:
@@ -113,9 +113,10 @@ public void teardown() throws Exception {
             serverChannel.close().sync();
             serverChannel = null;
         }
+        final Channel serverConnectedChannel = this.serverConnectedChannel;
         if (serverConnectedChannel != null) {
             serverConnectedChannel.close().sync();
-            serverConnectedChannel = null;
+            this.serverConnectedChannel = null;
         }
         Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 0, MILLISECONDS);
         Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 0, MILLISECONDS);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java
Patch:
@@ -119,9 +119,10 @@ public void teardown() throws Exception {
             serverChannel.close().sync();
             serverChannel = null;
         }
+        final Channel serverConnectedChannel = this.serverConnectedChannel;
         if (serverConnectedChannel != null) {
             serverConnectedChannel.close().sync();
-            serverConnectedChannel = null;
+            this.serverConnectedChannel = null;
         }
         Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 0, MILLISECONDS);
         Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 0, MILLISECONDS);

File: handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java
Patch:
@@ -88,6 +88,6 @@ protected void mySetupMutualAuthServerInitSslHandler(SslHandler handler) {
     @Override
     protected boolean mySetupMutualAuthServerIsValidClientException(Throwable cause) {
         // TODO(scott): work around for a JDK issue. The exception should be SSLHandshakeException.
-        return super.mySetupMutualAuthServerIsValidClientException(cause) || cause instanceof SSLException;
+        return super.mySetupMutualAuthServerIsValidClientException(cause) || causedBySSLException(cause);
     }
 }

File: handler/src/test/java/io/netty/handler/ssl/OpenSslJdkSslEngineInteroptTest.java
Patch:
@@ -92,6 +92,6 @@ public void testClientHostnameValidationFail() throws InterruptedException, SSLE
     @Override
     protected boolean mySetupMutualAuthServerIsValidServerException(Throwable cause) {
         // TODO(scott): work around for a JDK issue. The exception should be SSLHandshakeException.
-        return super.mySetupMutualAuthServerIsValidServerException(cause) || cause instanceof SSLException;
+        return super.mySetupMutualAuthServerIsValidServerException(cause) || causedBySSLException(cause);
     }
 }

File: handler/src/main/java/io/netty/handler/ssl/util/ThreadLocalInsecureRandom.java
Patch:
@@ -22,7 +22,8 @@
 import java.util.Random;
 
 /**
- * Insecure {@link SecureRandom} which relies on {@link PlatformDependent#threadLocalRandom()} for random number generation.
+ * Insecure {@link SecureRandom} which relies on {@link PlatformDependent#threadLocalRandom()} for random number
+ * generation.
  */
 final class ThreadLocalInsecureRandom extends SecureRandom {
 

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -384,7 +384,7 @@ protected void doRegister() throws Exception {
         boolean selected = false;
         for (;;) {
             try {
-                selectionKey = javaChannel().register(eventLoop().selector, 0, this);
+                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
                 return;
             } catch (CancelledKeyException e) {
                 if (!selected) {

File: buffer/src/test/java/io/netty/buffer/WrappedUnpooledUnsafeByteBufTest.java
Patch:
@@ -27,7 +27,8 @@ public class WrappedUnpooledUnsafeByteBufTest extends BigEndianUnsafeDirectByteB
     @Before
     @Override
     public void init() {
-        Assume.assumeTrue("sun.misc.Unsafe not found, skip tests", PlatformDependent.hasUnsafe());
+        Assume.assumeTrue("PlatformDependent.useDirectBufferNoCleaner() returned false, skip tests",
+                PlatformDependent.useDirectBufferNoCleaner());
         super.init();
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket07FrameDecoder.java
Patch:
@@ -86,8 +86,8 @@ public WebSocket07FrameDecoder(boolean expectMaskedFrames, boolean allowExtensio
      *            Maximum length of a frame's payload. Setting this to an appropriate value for you application
      *            helps check for denial of services attacks.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocket07FrameDecoder(boolean expectMaskedFrames, boolean allowExtensions, int maxFramePayloadLength,
                                    boolean allowMaskMismatch) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -137,8 +137,8 @@ public WebSocket08FrameDecoder(boolean expectMaskedFrames, boolean allowExtensio
      *            Maximum length of a frame's payload. Setting this to an appropriate value for you application
      *            helps check for denial of services attacks.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocket08FrameDecoder(boolean expectMaskedFrames, boolean allowExtensions, int maxFramePayloadLength,
                                    boolean allowMaskMismatch) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket13FrameDecoder.java
Patch:
@@ -86,8 +86,8 @@ public WebSocket13FrameDecoder(boolean expectMaskedFrames, boolean allowExtensio
      *            Maximum length of a frame's payload. Setting this to an appropriate value for you application
      *            helps check for denial of services attacks.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocket13FrameDecoder(boolean expectMaskedFrames, boolean allowExtensions, int maxFramePayloadLength,
                                    boolean allowMaskMismatch) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -91,8 +91,8 @@ public WebSocketClientHandshaker07(URI webSocketURL, WebSocketVersion version, S
      *            with the websocket specifications. Client applications that communicate with a non-standard server
      *            which doesn't require masking might set this to false to achieve a higher performance.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketClientHandshaker07(URI webSocketURL, WebSocketVersion version, String subprotocol,
             boolean allowExtensions, HttpHeaders customHeaders, int maxFramePayloadLength,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -92,8 +92,8 @@ public WebSocketClientHandshaker08(URI webSocketURL, WebSocketVersion version, S
      *            with the websocket specifications. Client applications that communicate with a non-standard server
      *            which doesn't require masking might set this to false to achieve a higher performance.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketClientHandshaker08(URI webSocketURL, WebSocketVersion version, String subprotocol,
             boolean allowExtensions, HttpHeaders customHeaders, int maxFramePayloadLength,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -92,8 +92,8 @@ public WebSocketClientHandshaker13(URI webSocketURL, WebSocketVersion version, S
      *            with the websocket specifications. Client applications that communicate with a non-standard server
      *            which doesn't require masking might set this to false to achieve a higher performance.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketClientHandshaker13(URI webSocketURL, WebSocketVersion version, String subprotocol,
             boolean allowExtensions, HttpHeaders customHeaders, int maxFramePayloadLength,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
Patch:
@@ -100,8 +100,8 @@ public static WebSocketClientHandshaker newHandshaker(
      *            with the websocket specifications. Client applications that communicate with a non-standard server
      *            which doesn't require masking might set this to false to achieve a higher performance.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public static WebSocketClientHandshaker newHandshaker(
             URI webSocketURL, WebSocketVersion version, String subprotocol,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
Patch:
@@ -83,8 +83,8 @@ public enum ClientHandshakeStateEvent {
      *            with the websocket specifications. Client applications that communicate with a non-standard server
      *            which doesn't require masking might set this to false to achieve a higher performance.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketClientProtocolHandler(URI webSocketURL, WebSocketVersion version, String subprotocol,
                                           boolean allowExtensions, HttpHeaders customHeaders,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -73,8 +73,8 @@ public WebSocketServerHandshaker07(
      *            Maximum allowable frame payload length. Setting this value to your application's
      *            requirement may reduce denial of service attacks using long data frames.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketServerHandshaker07(
             String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -73,8 +73,8 @@ public WebSocketServerHandshaker08(
      *            Maximum allowable frame payload length. Setting this value to your application's
      *            requirement may reduce denial of service attacks using long data frames.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketServerHandshaker08(
             String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -72,8 +72,8 @@ public WebSocketServerHandshaker13(
      *        Maximum allowable frame payload length. Setting this value to your application's
      *        requirement may reduce denial of service attacks using long data frames.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketServerHandshaker13(
             String webSocketURL, String subprotocols, boolean allowExtensions, int maxFramePayloadLength,

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -92,8 +92,8 @@ public WebSocketServerHandshakerFactory(
      *            Maximum allowable frame payload length. Setting this value to your application's
      *            requirement may reduce denial of service attacks using long data frames.
      * @param allowMaskMismatch
-     *            Allows to loosen the masking requirement on received frames. When this is set to false then also
-     *            frames which are not masked properly according to the standard will still be accepted.
+     *            When set to true, frames which are not masked properly according to the standard will still be
+     *            accepted.
      */
     public WebSocketServerHandshakerFactory(
             String webSocketURL, String subprotocols, boolean allowExtensions,

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -1081,7 +1081,6 @@ protected void testEnablingAnAlreadyDisabledSslProtocol(String[] protocols1, Str
 
             // The only protocol that should be enabled is SSLv2Hello
             String[] enabledProtocols = sslEngine.getEnabledProtocols();
-            assertEquals(protocols1.length, enabledProtocols.length);
             assertArrayEquals(protocols1, enabledProtocols);
 
             // Enable a protocol that is currently disabled

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannelId.java
Patch:
@@ -40,7 +40,7 @@ public String asLongText() {
     }
 
     @Override
-    public int compareTo(ChannelId o) {
+    public int compareTo(final ChannelId o) {
         if (o instanceof EmbeddedChannelId) {
             return 0;
         }

File: handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java
Patch:
@@ -88,6 +88,6 @@ protected void mySetupMutualAuthServerInitSslHandler(SslHandler handler) {
     @Override
     protected boolean mySetupMutualAuthServerIsValidClientException(Throwable cause) {
         // TODO(scott): work around for a JDK issue. The exception should be SSLHandshakeException.
-        return super.mySetupMutualAuthServerIsValidException(cause) || cause instanceof SSLException;
+        return super.mySetupMutualAuthServerIsValidClientException(cause) || cause instanceof SSLException;
     }
 }

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -712,7 +712,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
             }
         });
 
-        serverChannel = sb.bind(new InetSocketAddress(9999)).sync().channel();
+        serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();
         int port = ((InetSocketAddress) serverChannel.localAddress()).getPort();
 
         ChannelFuture ccf = cb.connect(new InetSocketAddress(NetUtil.LOCALHOST, port));

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -1467,7 +1467,7 @@ public final boolean getWantClientAuth() {
      * {@link SSL#setVerify(long, int, int)}.
      */
     @UnstableApi
-    public synchronized final void setVerify(int verifyMode, int depth) {
+    public final synchronized void setVerify(int verifyMode, int depth) {
         SSL.setVerify(ssl, verifyMode, depth);
     }
 

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -121,7 +121,7 @@ static OpenSslSessionContext newSessionContext(ReferenceCountedOpenSslContext th
                 throw new SSLException("failed to set certificate and key", e);
             }
 
-            SSLContext.setVerify(ctx, SSL.SSL_VERIFY_NONE, VERIFY_DEPTH);
+            SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_NONE, VERIFY_DEPTH);
 
             try {
                 if (trustCertCollection != null) {

File: handler/src/main/java/io/netty/handler/ssl/Java7SslParametersUtils.java
Patch:
@@ -18,9 +18,9 @@
 import javax.net.ssl.SSLParameters;
 import java.security.AlgorithmConstraints;
 
-final class SslParametersUtils {
+final class Java7SslParametersUtils {
 
-    private SslParametersUtils() {
+    private Java7SslParametersUtils() {
         // Utility
     }
 

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
Patch:
@@ -70,7 +70,7 @@ protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {
      *                              {@link ByteBuf}, which is backed by an byte array.
      */
     protected ByteToMessageCodec(boolean preferDirect) {
-        CodecUtil.ensureNotSharable(this);
+        ensureNotSharable();
         outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");
         encoder = new Encoder(preferDirect);
     }
@@ -84,7 +84,7 @@ protected ByteToMessageCodec(boolean preferDirect) {
      *                              {@link ByteBuf}, which is backed by an byte array.
      */
     protected ByteToMessageCodec(Class<? extends I> outboundMessageType, boolean preferDirect) {
-        CodecUtil.ensureNotSharable(this);
+        ensureNotSharable();
         outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);
         encoder = new Encoder(preferDirect);
     }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -138,7 +138,7 @@ public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)
     private int numReads;
 
     protected ByteToMessageDecoder() {
-        CodecUtil.ensureNotSharable(this);
+        ensureNotSharable();
     }
 
     /**

File: transport-native-epoll/src/main/java/io/netty/channel/unix/Errors.java
Patch:
@@ -61,7 +61,7 @@ public static final class NativeIoException extends IOException {
         private static final long serialVersionUID = 8222160204268655526L;
         private final int expectedErr;
         public NativeIoException(String method, int expectedErr) {
-            super(method);
+            super(method + " failed: " + ERRORS[-expectedErr]);
             this.expectedErr = expectedErr;
         }
 
@@ -74,7 +74,7 @@ static final class NativeConnectException extends ConnectException {
         private static final long serialVersionUID = -5532328671712318161L;
         private final int expectedErr;
         NativeConnectException(String method, int expectedErr) {
-            super(method);
+            super(method + " failed: " + ERRORS[-expectedErr]);
             this.expectedErr = expectedErr;
         }
 

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -1065,6 +1065,7 @@ private static final class AnnotatedConnectException extends ConnectException {
 
         AnnotatedConnectException(ConnectException exception, SocketAddress remoteAddress) {
             super(exception.getMessage() + ": " + remoteAddress);
+            initCause(exception);
             setStackTrace(exception.getStackTrace());
         }
 
@@ -1080,6 +1081,7 @@ private static final class AnnotatedNoRouteToHostException extends NoRouteToHost
 
         AnnotatedNoRouteToHostException(NoRouteToHostException exception, SocketAddress remoteAddress) {
             super(exception.getMessage() + ": " + remoteAddress);
+            initCause(exception);
             setStackTrace(exception.getStackTrace());
         }
 
@@ -1095,6 +1097,7 @@ private static final class AnnotatedSocketException extends SocketException {
 
         AnnotatedSocketException(SocketException exception, SocketAddress remoteAddress) {
             super(exception.getMessage() + ": " + remoteAddress);
+            initCause(exception);
             setStackTrace(exception.getStackTrace());
         }
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -385,7 +385,7 @@ public DnsServerAddressStream nameServerAddressStream(String hostname) {
             try {
                 final Map<String, InetAddress> resultA = testResolve0(resolver, EXCLUSIONS_RESOLVE_A);
                 for (Entry<String, InetAddress> resolvedEntry : resultA.entrySet()) {
-                    if (resolvedEntry.getValue().getHostAddress().equalsIgnoreCase("localhost")) {
+                    if (resolvedEntry.getValue().isLoopbackAddress()) {
                         continue;
                     }
                     if (overridenHostnames.contains(resolvedEntry.getKey())) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java
Patch:
@@ -107,11 +107,11 @@ public void connect(SocketAddress socketAddress, SocketAddress socketAddress2, C
         @Override
         void epollInReady() {
             assert eventLoop().inEventLoop();
-            if (fd().isInputShutdown()) {
+            final ChannelConfig config = config();
+            if (shouldBreakEpollInReady(config)) {
                 clearEpollIn0();
                 return;
             }
-            final ChannelConfig config = config();
             final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();
             allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -523,11 +523,11 @@ public void connect(SocketAddress remote, SocketAddress local, ChannelPromise ch
         @Override
         void epollInReady() {
             assert eventLoop().inEventLoop();
-            if (fd().isInputShutdown()) {
+            DatagramChannelConfig config = config();
+            if (shouldBreakEpollInReady(config)) {
                 clearEpollIn0();
                 return;
             }
-            DatagramChannelConfig config = config();
             final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();
             allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));
 

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketChannelConfigTest.java
Patch:
@@ -140,7 +140,7 @@ public void testSetOptionWhenClosed() {
     public void testGetOptionWhenClosed() {
         ch.close().syncUninterruptibly();
         try {
-        ch.config().getSoLinger();
+            ch.config().getSoLinger();
             fail();
         } catch (ChannelException e) {
             assertTrue(e.getCause() instanceof ClosedChannelException);

File: transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
Patch:
@@ -175,6 +175,7 @@ public AdaptiveRecvByteBufAllocator(int minimum, int initial, int maximum) {
         this.initial = initial;
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public Handle newHandle() {
         return new HandleImpl(minIndex, maxIndex, initial);

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -29,8 +29,8 @@
 import static io.netty.channel.ChannelOption.CONNECT_TIMEOUT_MILLIS;
 import static io.netty.channel.ChannelOption.MAX_MESSAGES_PER_READ;
 import static io.netty.channel.ChannelOption.MESSAGE_SIZE_ESTIMATOR;
-import static io.netty.channel.ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP;
 import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;
+import static io.netty.channel.ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP;
 import static io.netty.channel.ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK;
 import static io.netty.channel.ChannelOption.WRITE_BUFFER_LOW_WATER_MARK;
 import static io.netty.channel.ChannelOption.WRITE_BUFFER_WATER_MARK;
@@ -307,7 +307,7 @@ private void setRecvByteBufAllocator(RecvByteBufAllocator allocator, ChannelMeta
         } else if (allocator == null) {
             throw new NullPointerException("allocator");
         }
-        rcvBufAllocator = allocator;
+        setRecvByteBufAllocator(allocator);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/FixedRecvByteBufAllocator.java
Patch:
@@ -48,6 +48,7 @@ public FixedRecvByteBufAllocator(int bufferSize) {
         this.bufferSize = bufferSize;
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public Handle newHandle() {
         return new HandleImpl(bufferSize);

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java
Patch:
@@ -61,6 +61,7 @@ private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {
         return new DnsNameResolverBuilder(group.next())
                 .channelType(NioDatagramChannel.class)
                 .nameServerAddresses(DnsServerAddresses.singleton(SocketUtils.socketAddress("8.8.8.8", 53)))
+                .nameServerCache(NoopDnsServerAddressStreamProvider.INSTANCE)
                 .maxQueriesPerResolve(1)
                 .optResourceEnabled(false);
     }

File: resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
Patch:
@@ -46,6 +46,7 @@ private DnsNameResolverBuilder newResolver() {
         return new DnsNameResolverBuilder(group.next())
             .channelType(NioDatagramChannel.class)
             .nameServerAddresses(DnsServerAddresses.singleton(dnsServer.localAddress()))
+            .nameServerCache(NoopDnsServerAddressStreamProvider.INSTANCE)
             .maxQueriesPerResolve(1)
             .optResourceEnabled(false);
     }

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -386,7 +386,7 @@ public void testNonCachedResolveNullHostName() throws Exception {
     }
 
     public void testNonCachedResolveEmptyHostName(String inetHost) throws Exception {
-        DnsNameResolver resolver = newNonCachedResolver(InternetProtocolFamily.IPv4).build();
+        DnsNameResolver resolver = newNonCachedResolver(ResolvedAddressTypes.IPV4_ONLY).build();
         try {
             InetAddress addr = resolver.resolve(inetHost).syncUninterruptibly().getNow();
             assertEquals(SocketUtils.addressByName(inetHost), addr);
@@ -406,7 +406,7 @@ public void testNonCachedResolveAllNullHostName() throws Exception {
     }
 
     private static void testNonCachedResolveAllEmptyHostName(String inetHost) throws UnknownHostException {
-        DnsNameResolver resolver = newNonCachedResolver(InternetProtocolFamily.IPv4).build();
+        DnsNameResolver resolver = newNonCachedResolver(ResolvedAddressTypes.IPV4_ONLY).build();
         try {
             List<InetAddress> addrs = resolver.resolveAll(inetHost).syncUninterruptibly().getNow();
             assertEquals(Arrays.asList(

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -74,7 +74,7 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
     private final DnsCache resolveCache;
     private final boolean traceEnabled;
     private final int maxAllowedQueries;
-    private final InternetProtocolFamily[] resolveAddressTypes;
+    private final InternetProtocolFamily[] resolvedInternetProtocolFamilies;
     private final DnsRecord[] additionals;
 
     private final Set<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> queriesInProgress =
@@ -97,7 +97,7 @@ protected DnsNameResolverContext(DnsNameResolver parent,
 
         nameServerAddrs = parent.nameServerAddresses.stream();
         maxAllowedQueries = parent.maxQueriesPerResolve();
-        resolveAddressTypes = parent.resolveAddressTypesUnsafe();
+        resolvedInternetProtocolFamilies = parent.resolvedInternetProtocolFamiliesUnsafe();
         traceEnabled = parent.isTraceEnabled();
         allowedQueries = maxAllowedQueries;
     }
@@ -611,7 +611,7 @@ private void finishResolve(Promise<T> promise) {
 
         if (resolvedEntries != null) {
             // Found at least one resolved address.
-            for (InternetProtocolFamily f: resolveAddressTypes) {
+            for (InternetProtocolFamily f: resolvedInternetProtocolFamilies) {
                 if (finishResolve(f.addressType(), resolvedEntries, promise)) {
                     return;
                 }

File: resolver/src/main/java/io/netty/resolver/SimpleNameResolver.java
Patch:
@@ -55,7 +55,6 @@ public final Future<T> resolve(String inetHost) {
 
     @Override
     public Future<T> resolve(String inetHost, Promise<T> promise) {
-        checkNotNull(inetHost, "inetHost");
         checkNotNull(promise, "promise");
 
         try {
@@ -74,7 +73,6 @@ public final Future<List<T>> resolveAll(String inetHost) {
 
     @Override
     public Future<List<T>> resolveAll(String inetHost, Promise<List<T>> promise) {
-        checkNotNull(inetHost, "inetHost");
         checkNotNull(promise, "promise");
 
         try {

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/DefaultCookie.java
Patch:
@@ -28,7 +28,7 @@ public class DefaultCookie implements Cookie {
     private boolean wrap;
     private String domain;
     private String path;
-    private long maxAge = Long.MIN_VALUE;
+    private long maxAge = UNDEFINED_MAX_AGE;
     private boolean secure;
     private boolean httpOnly;
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -133,6 +133,7 @@ public Http2FrameCodec(boolean server, Http2FrameLogger frameLogger) {
     // Visible for testing
     Http2FrameCodec(boolean server, Http2FrameWriter frameWriter, Http2FrameLogger frameLogger,
                     Http2Settings initialSettings) {
+        // TODO(scott): configure maxReservedStreams when API is more finalized.
         Http2Connection connection = new DefaultHttp2Connection(server);
         frameWriter = new Http2OutboundFrameLogger(frameWriter, frameLogger);
         Http2ConnectionEncoder encoder = new DefaultHttp2ConnectionEncoder(connection, frameWriter);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
Patch:
@@ -340,7 +340,6 @@ public static void addHttp2ToHttpHeaders(int streamId, Http2Headers inputHeaders
      * The following headers are only used if they can not be found in from the {@code HOST} header or the
      * {@code Request-Line} as defined by <a href="https://tools.ietf.org/html/rfc7230">rfc7230</a>
      * <ul>
-     * <li>{@link ExtensionHeaderNames#AUTHORITY}</li>
      * <li>{@link ExtensionHeaderNames#SCHEME}</li>
      * </ul>
      * {@link ExtensionHeaderNames#PATH} is ignored and instead extracted from the {@code Request-Line}.

File: codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
Patch:
@@ -461,7 +461,7 @@ public void closedBufferedStreamReleasesByteBuf() {
     @Test
     public void closeShouldCancelAllBufferedStreams() throws Http2Exception {
         encoder.writeSettingsAck(ctx, newPromise());
-        connection.local().maxStreams(0, 0);
+        connection.local().maxActiveStreams(0);
 
         ChannelFuture f1 = encoderWriteHeaders(3, newPromise());
         ChannelFuture f2 = encoderWriteHeaders(5, newPromise());

File: common/src/main/java/io/netty/util/internal/MathUtil.java
Patch:
@@ -65,7 +65,7 @@ public static boolean isOutOfBounds(int index, int length, int capacity) {
     }
 
     /**
-     * Compare to {@code long} values.
+     * Compare two {@code long} values.
      * @param x the first {@code long} to compare.
      * @param y the second {@code long} to compare.
      * @return

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -337,6 +337,7 @@ private void sendPreface(ChannelHandlerContext ctx) {
             if (!connection().isServer()) {
                 // Clients must send the preface string as the first bytes on the connection.
                 ctx.write(connectionPrefaceBuf()).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
+                ctx.fireUserEventTriggered(Http2ConnectionPrefaceWrittenEvent.INSTANCE);
             }
 
             // Both client and server must send their initial settings.

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -36,6 +36,7 @@
 import io.netty.util.concurrent.Promise;
 import io.netty.util.internal.StringUtil;
 
+import java.net.IDN;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
 import java.net.InetAddress;
@@ -272,7 +273,8 @@ private void onResponseAorAAAA(
 
             final InetAddress resolved;
             try {
-                resolved = InetAddress.getByAddress(hostname, addrBytes);
+                resolved = InetAddress.getByAddress(
+                        parent.isDecodeIdn() ? IDN.toUnicode(hostname) : hostname, addrBytes);
             } catch (UnknownHostException e) {
                 // Should never reach here.
                 throw new Error(e);

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -1599,7 +1599,7 @@ public void testWrapAfterCloseOutbound() throws Exception {
         SSLEngine server = serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);
 
         try {
-            ByteBuffer dst = allocateBuffer(server.getSession().getPacketBufferSize());
+            ByteBuffer dst = allocateBuffer(client.getSession().getPacketBufferSize());
             ByteBuffer src = allocateBuffer(1024);
 
             handshake(client, server);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -209,7 +209,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
      * streams.
      */
     @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Http2Exception {
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         try {
             if (msg instanceof Http2WindowUpdateFrame) {
                 Http2WindowUpdateFrame frame = (Http2WindowUpdateFrame) msg;
@@ -252,7 +252,7 @@ private void writeGoAwayFrame(Http2GoAwayFrame frame, ChannelPromise promise) {
                 http2HandlerCtx, lastStreamId, frame.errorCode(), frame.content().retain(), promise);
     }
 
-    private void writeStreamFrame(Http2StreamFrame frame, ChannelPromise promise) throws Http2Exception {
+    private void writeStreamFrame(Http2StreamFrame frame, ChannelPromise promise) {
         if (frame instanceof Http2DataFrame) {
             Http2DataFrame dataFrame = (Http2DataFrame) frame;
             http2Handler.encoder().writeData(http2HandlerCtx, frame.streamId(), dataFrame.content().retain(),
@@ -267,7 +267,7 @@ private void writeStreamFrame(Http2StreamFrame frame, ChannelPromise promise) th
         }
     }
 
-    private void writeHeadersFrame(Http2HeadersFrame headersFrame, ChannelPromise promise) throws Http2Exception {
+    private void writeHeadersFrame(Http2HeadersFrame headersFrame, ChannelPromise promise) {
         int streamId = headersFrame.streamId();
         if (!isStreamIdValid(streamId)) {
             final Endpoint<Http2LocalFlowController> localEndpoint = http2Handler.connection().local();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
Patch:
@@ -46,15 +46,15 @@ public ChannelFuture writeData(ChannelHandlerContext ctx, int streamId, ByteBuf
 
     @Override
     public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId,
-            Http2Headers headers, int padding, boolean endStream, ChannelPromise promise) throws Http2Exception {
+            Http2Headers headers, int padding, boolean endStream, ChannelPromise promise) {
         logger.logHeaders(OUTBOUND, ctx, streamId, headers, padding, endStream);
         return writer.writeHeaders(ctx, streamId, headers, padding, endStream, promise);
     }
 
     @Override
     public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId,
             Http2Headers headers, int streamDependency, short weight, boolean exclusive,
-            int padding, boolean endStream, ChannelPromise promise) throws Http2Exception {
+            int padding, boolean endStream, ChannelPromise promise) {
         logger.logHeaders(OUTBOUND, ctx, streamId, headers, streamDependency, weight, exclusive,
                 padding, endStream);
         return writer.writeHeaders(ctx, streamId, headers, streamDependency, weight,
@@ -101,7 +101,7 @@ public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack,
 
     @Override
     public ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId,
-            int promisedStreamId, Http2Headers headers, int padding, ChannelPromise promise) throws Http2Exception {
+            int promisedStreamId, Http2Headers headers, int padding, ChannelPromise promise) {
         logger.logPushPromise(OUTBOUND, ctx, streamId, promisedStreamId, headers, padding);
         return writer.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
Patch:
@@ -130,9 +130,8 @@ interface FlowControlled {
          *
          * @param ctx The context to use for writing.
          * @param allowedBytes an upper bound on the number of bytes the payload can write at this time.
-         * @throws Http2Exception if an error occurs during the encode or write.
          */
-        void write(ChannelHandlerContext ctx, int allowedBytes) throws Http2Exception;
+        void write(ChannelHandlerContext ctx, int allowedBytes);
 
         /**
          * Merge the contents of the {@code next} message into this message so they can be written out as one unit.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -124,7 +124,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
 
     private static void writeHeaders(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder, int streamId,
                                      HttpHeaders headers, Http2Headers http2Headers, boolean endStream,
-                                     SimpleChannelPromiseAggregator promiseAggregator) throws Http2Exception {
+                                     SimpleChannelPromiseAggregator promiseAggregator) {
         int dependencyId = headers.getInt(
                 HttpConversionUtil.ExtensionHeaderNames.STREAM_DEPENDENCY_ID.text(), 0);
         short weight = headers.getShort(

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java
Patch:
@@ -565,7 +565,7 @@ public void canWriteDataFrameAfterGoAwayReceived() throws Exception {
     }
 
     @Test
-    public void canWriteHeaderFrameAfterGoAwayReceived() throws Http2Exception {
+    public void canWriteHeaderFrameAfterGoAwayReceived() {
         writeAllFlowControlledFrames();
         goAwayReceived(STREAM_ID);
         ChannelPromise promise = newPromise();

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -127,7 +127,7 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator {
             logger.debug("-Dio.netty.allocator.normalCacheSize: {}", DEFAULT_NORMAL_CACHE_SIZE);
             logger.debug("-Dio.netty.allocator.maxCachedBufferCapacity: {}", DEFAULT_MAX_CACHED_BUFFER_CAPACITY);
             logger.debug("-Dio.netty.allocator.cacheTrimInterval: {}", DEFAULT_CACHE_TRIM_INTERVAL);
-            logger.debug("-Dio.netty.allocator.useCacheForAllThreads", DEFAULT_USE_CACHE_FOR_ALL_THREADS);
+            logger.debug("-Dio.netty.allocator.useCacheForAllThreads: {}", DEFAULT_USE_CACHE_FOR_ALL_THREADS);
         }
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameReader.java
Patch:
@@ -32,9 +32,9 @@ public interface Http2FrameReader extends Closeable {
      */
     interface Configuration {
         /**
-         * Get the {@link Http2HeaderTable} for this {@link Http2FrameReader}
+         * Get the {@link Http2HeadersDecoder.Configuration} for this {@link Http2FrameReader}
          */
-        Http2HeaderTable headerTable();
+        Http2HeadersDecoder.Configuration headersConfiguration();
 
         /**
          * Get the {@link Http2FrameSizePolicy} for this {@link Http2FrameReader}

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
Patch:
@@ -46,15 +46,15 @@ public ChannelFuture writeData(ChannelHandlerContext ctx, int streamId, ByteBuf
 
     @Override
     public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId,
-            Http2Headers headers, int padding, boolean endStream, ChannelPromise promise) {
+            Http2Headers headers, int padding, boolean endStream, ChannelPromise promise) throws Http2Exception {
         logger.logHeaders(OUTBOUND, ctx, streamId, headers, padding, endStream);
         return writer.writeHeaders(ctx, streamId, headers, padding, endStream, promise);
     }
 
     @Override
     public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId,
             Http2Headers headers, int streamDependency, short weight, boolean exclusive,
-            int padding, boolean endStream, ChannelPromise promise) {
+            int padding, boolean endStream, ChannelPromise promise) throws Http2Exception {
         logger.logHeaders(OUTBOUND, ctx, streamId, headers, streamDependency, weight, exclusive,
                 padding, endStream);
         return writer.writeHeaders(ctx, streamId, headers, streamDependency, weight,
@@ -101,7 +101,7 @@ public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack,
 
     @Override
     public ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId,
-            int promisedStreamId, Http2Headers headers, int padding, ChannelPromise promise) {
+            int promisedStreamId, Http2Headers headers, int padding, ChannelPromise promise) throws Http2Exception {
         logger.logPushPromise(OUTBOUND, ctx, streamId, promisedStreamId, headers, padding);
         return writer.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
Patch:
@@ -130,8 +130,9 @@ interface FlowControlled {
          *
          * @param ctx The context to use for writing.
          * @param allowedBytes an upper bound on the number of bytes the payload can write at this time.
+         * @throws Http2Exception if an error occurs during the encode or write.
          */
-        void write(ChannelHandlerContext ctx, int allowedBytes);
+        void write(ChannelHandlerContext ctx, int allowedBytes) throws Http2Exception;
 
         /**
          * Merge the contents of the {@code next} message into this message so they can be written out as one unit.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -112,6 +112,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
                 }
             }
         } catch (Throwable t) {
+            onError(ctx, t);
             promiseAggregator.setFailure(t);
         } finally {
             if (release) {
@@ -123,7 +124,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
 
     private static void writeHeaders(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder, int streamId,
                                      HttpHeaders headers, Http2Headers http2Headers, boolean endStream,
-                                     SimpleChannelPromiseAggregator promiseAggregator) {
+                                     SimpleChannelPromiseAggregator promiseAggregator) throws Http2Exception {
         int dependencyId = headers.getInt(
                 HttpConversionUtil.ExtensionHeaderNames.STREAM_DEPENDENCY_ID.text(), 0);
         short weight = headers.getShort(

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java
Patch:
@@ -565,7 +565,7 @@ public void canWriteDataFrameAfterGoAwayReceived() throws Exception {
     }
 
     @Test
-    public void canWriteHeaderFrameAfterGoAwayReceived() {
+    public void canWriteHeaderFrameAfterGoAwayReceived() throws Http2Exception {
         writeAllFlowControlledFrames();
         goAwayReceived(STREAM_ID);
         ChannelPromise promise = newPromise();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoderTest.java
Patch:
@@ -52,7 +52,7 @@ public void encodeShouldSucceed() throws Http2Exception {
     @Test(expected = StreamException.class)
     public void headersExceedMaxSetSizeShouldFail() throws Http2Exception {
         Http2Headers headers = headers();
-        encoder.headerTable().maxHeaderListSize(2);
+        encoder.maxHeaderListSize(2);
         encoder.encodeHeaders(3 /* randomly chosen */, headers, Unpooled.buffer());
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -446,6 +446,7 @@ public void writeRstOnClosedStreamShouldSucceed() throws Exception {
         when(frameWriter.writeRstStream(eq(ctx), eq(STREAM_ID),
                 anyLong(), any(ChannelPromise.class))).thenReturn(future);
         when(stream.state()).thenReturn(CLOSED);
+        when(stream.isHeadersSent()).thenReturn(true);
         // The stream is "closed" but is still known about by the connection (connection().stream(..)
         // will return the stream). We should still write a RST_STREAM frame in this scenario.
         handler.resetStream(ctx, STREAM_ID, STREAM_CLOSED.code(), promise);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java
Patch:
@@ -40,7 +40,6 @@
 import java.util.List;
 
 import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
-import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_PADDING;
 import static io.netty.handler.codec.http2.Http2HeadersEncoder.NEVER_SENSITIVE;
 import static io.netty.handler.codec.http2.Http2TestUtil.newTestDecoder;
@@ -283,7 +282,9 @@ public void continuedHeadersWithPaddingShouldMatch() throws Exception {
     @Test
     public void headersThatAreTooBigShouldFail() throws Exception {
         reader = new DefaultHttp2FrameReader(false);
-        final Http2Headers headers = headersOfSize(DEFAULT_HEADER_LIST_SIZE + 1);
+        final int maxListSize = 100;
+        reader.configuration().headersConfiguration().maxHeaderListSize(maxListSize, maxListSize);
+        final Http2Headers headers = headersOfSize(maxListSize + 1);
         writer.writeHeaders(ctx, STREAM_ID, headers, 2, (short) 3, true, MAX_PADDING, true, ctx.newPromise());
         try {
             readFrames();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2HeaderBlockIOTest.java
Patch:
@@ -74,10 +74,10 @@ public void successiveCallsShouldSucceed() throws Http2Exception {
 
     @Test
     public void setMaxHeaderSizeShouldBeSuccessful() throws Http2Exception {
-        encoder.headerTable().maxHeaderTableSize(10);
+        encoder.maxHeaderTableSize(10);
         Http2Headers in = headers();
         assertRoundtripSuccessful(in);
-        assertEquals(10, decoder.headerTable().maxHeaderTableSize());
+        assertEquals(10, decoder.maxHeaderTableSize());
     }
 
     private void assertRoundtripSuccessful(Http2Headers in) throws Http2Exception {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -122,9 +122,8 @@ public static Decoder newTestDecoder() {
     }
 
     public static Decoder newTestDecoder(long maxHeaderListSize, long maxHeaderTableSize) throws Http2Exception {
-        Decoder decoder = new Decoder();
+        Decoder decoder = new Decoder(maxHeaderListSize, 32);
         decoder.setMaxHeaderTableSize(maxHeaderTableSize);
-        decoder.setMaxHeaderListSize(maxHeaderListSize);
         return decoder;
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/DecoderTest.java
Patch:
@@ -69,7 +69,7 @@ private void decode(String encoded) throws Http2Exception {
 
     @Before
     public void setUp() throws Http2Exception {
-        decoder = new Decoder();
+        decoder = new Decoder(8192, 32);
         mockHeaders = mock(Http2Headers.class);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/EncoderTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
@@ -34,7 +35,7 @@ public class EncoderTest {
     @Before
     public void setUp() throws Http2Exception {
         encoder = new Encoder();
-        decoder = new Decoder();
+        decoder = new Decoder(DEFAULT_HEADER_LIST_SIZE, 32);
         mockHeaders = mock(Http2Headers.class);
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java
Patch:
@@ -56,6 +56,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2TestUtil.newTestEncoder;
 
@@ -177,7 +178,7 @@ private Decoder createDecoder() {
             maxHeaderTableSize = Integer.MAX_VALUE;
         }
 
-        return new Decoder(32, maxHeaderTableSize);
+        return new Decoder(DEFAULT_HEADER_LIST_SIZE, 32, maxHeaderTableSize);
     }
 
     private static byte[] encode(Encoder encoder, List<HeaderField> headers, int maxHeaderTableSize,

File: microbench/src/main/java/io/netty/microbench/http2/internal/hpack/DecoderBenchmark.java
Patch:
@@ -49,6 +49,7 @@
 import org.openjdk.jmh.annotations.TearDown;
 import org.openjdk.jmh.infra.Blackhole;
 
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_LIST_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;
 import static io.netty.microbench.http2.internal.hpack.HpackUtilBenchmark.newTestEncoder;
@@ -79,7 +80,7 @@ public void teardown() {
     @Benchmark
     @BenchmarkMode(Mode.Throughput)
     public void decode(final Blackhole bh) throws Http2Exception {
-        Decoder decoder = new Decoder();
+        Decoder decoder = new Decoder(DEFAULT_HEADER_LIST_SIZE, 32);
         @SuppressWarnings("unchecked")
         Http2Headers headers =
                 new DefaultHttp2Headers() {

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java
Patch:
@@ -135,7 +135,7 @@ public class ReferenceCountedOpenSslEngine extends SSLEngine implements Referenc
                 @SuppressWarnings({ "rawtypes", "unused" })
                 List serverNames = (List) getServerNamesMethod.invoke(parameters);
                 setServerNamesMethod.invoke(parameters, Collections.emptyList());
-            } catch (Throwable ingore) {
+            } catch (Throwable ignore) {
                 sniHostNameClass = null;
                 getAsciiNameMethod = null;
                 getServerNamesMethod = null;

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -854,8 +854,9 @@ private boolean ignoreException(Throwable t) {
                             && "com.sun.nio.sctp.SctpChannel".equals(clazz.getSuperclass().getName())) {
                         return true;
                     }
-                } catch (ClassNotFoundException e) {
-                    // This should not happen just ignore
+                } catch (Throwable cause) {
+                    logger.debug("Unexpected exception while loading class {} classname {}",
+                                 getClass(), classname, cause);
                 }
             }
         }

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -198,7 +198,6 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparabl
      * are only provided to implement the actual transport, and must be invoked from an I/O thread except for the
      * following methods:
      * <ul>
-     *   <li>{@link #invoker()}</li>
      *   <li>{@link #localAddress()}</li>
      *   <li>{@link #remoteAddress()}</li>
      *   <li>{@link #closeForcibly()}</li>

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanEncoder.java
Patch:
@@ -118,7 +118,7 @@ private void encodeSlowPath(ByteBuf out, CharSequence data) {
      * @param data the string literal to be Huffman encoded
      * @return the number of bytes required to Huffman encode <code>data</code>
      */
-    public int getEncodedLength(CharSequence data) {
+    int getEncodedLength(CharSequence data) {
         if (data instanceof AsciiString) {
             AsciiString string = (AsciiString) data;
             try {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorStreamingHandle.java
Patch:
@@ -28,7 +28,9 @@ boolean maybeMoreDataToRead() {
         /**
          * For stream oriented descriptors we can assume we are done reading if the last read attempt didn't produce
          * a full buffer (see Q9 in <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll man</a>).
+         *
+         * If EPOLLRDHUP has been received we must read until we get a read error.
          */
-        return isEdgeTriggered() && lastBytesRead() == attemptedBytesRead();
+        return isEdgeTriggered() && (lastBytesRead() == attemptedBytesRead() || isReceivedRdHup());
     }
 }

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -246,7 +246,7 @@ public static int compare(ByteBuf bufferA, ByteBuf bufferB) {
             }
             if (res != 0) {
                 // Ensure we not overflow when cast
-                return (int) Math.min(Integer.MAX_VALUE, res);
+                return (int) Math.min(Integer.MAX_VALUE, Math.max(Integer.MIN_VALUE, res));
             }
             aIndex += uintCountIncrement;
             bIndex += uintCountIncrement;

File: common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java
Patch:
@@ -33,7 +33,7 @@ private DefaultEventExecutorChooserFactory() { }
     @Override
     public EventExecutorChooser newChooser(EventExecutor[] executors) {
         if (isPowerOfTwo(executors.length)) {
-            return new PowerOfTowEventExecutorChooser(executors);
+            return new PowerOfTwoEventExecutorChooser(executors);
         } else {
             return new GenericEventExecutorChooser(executors);
         }
@@ -43,11 +43,11 @@ private static boolean isPowerOfTwo(int val) {
         return (val & -val) == val;
     }
 
-    private static final class PowerOfTowEventExecutorChooser implements EventExecutorChooser {
+    private static final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser {
         private final AtomicInteger idx = new AtomicInteger();
         private final EventExecutor[] executors;
 
-        PowerOfTowEventExecutorChooser(EventExecutor[] executors) {
+        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) {
             this.executors = executors;
         }
 

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
Patch:
@@ -31,8 +31,8 @@
  *
  * http://localhost:8080/websocket
  *
- * Open your browser at http://localhost:8080/, then the demo page will be loaded and a Web Socket connection will be
- * made automatically.
+ * Open your browser at <a href="http://localhost:8080/">http://localhost:8080/</a>, then the demo page will be loaded
+ * and a Web Socket connection will be made automatically.
  *
  * This server illustrates support for the different web socket specification versions and will work with:
  *

File: transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
Patch:
@@ -978,7 +978,7 @@ final void setAddPending() {
      * Makes best possible effort to detect if {@link ChannelHandler#handlerAdded(ChannelHandlerContext)} was called
      * yet. If not return {@code false} and if called or could not detect return {@code true}.
      *
-     * If this method returns {@code true} we will not invoke the {@link ChannelHandler} but just forward the event.
+     * If this method returns {@code false} we will not invoke the {@link ChannelHandler} but just forward the event.
      * This is needed as {@link DefaultChannelPipeline} may already put the {@link ChannelHandler} in the linked-list
      * but not called {@link ChannelHandler#handlerAdded(ChannelHandlerContext)}.
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpPostRequestDecoder.java
Patch:
@@ -20,10 +20,9 @@
 import java.util.List;
 
 /**
- * This decoder will decode Body and can handle POST BODY (or for PUT, PATCH or OPTIONS).
+ * This decoder will decode Body and can handle POST BODY.
  *
  * You <strong>MUST</strong> call {@link #destroy()} after completion to release all resources.
- *
  */
 public interface InterfaceHttpPostRequestDecoder {
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
Patch:
@@ -34,7 +34,7 @@ public boolean process(byte value) throws Exception {
             return !isUpperCase(value);
         }
     };
-    private static final NameValidator<CharSequence> HTTP2_NAME_VALIDATOR = new NameValidator<CharSequence>() {
+    static final NameValidator<CharSequence> HTTP2_NAME_VALIDATOR = new NameValidator<CharSequence>() {
         @Override
         public void validateName(CharSequence name) {
             if (name == null || name.length() == 0) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
Patch:
@@ -153,7 +153,7 @@ private static void verifyAllPseudoHeadersPresent(Http2Headers headers) {
         }
     }
 
-    private static void verifyPseudoHeadersFirst(Http2Headers headers) {
+    static void verifyPseudoHeadersFirst(Http2Headers headers) {
         CharSequence lastNonPseudoName = null;
         for (Entry<CharSequence, CharSequence> entry: headers) {
             if (entry.getKey().length() == 0 || entry.getKey().charAt(0) != ':') {

File: codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java
Patch:
@@ -974,7 +974,7 @@ public Entry<K, V> next() {
 
         @Override
         public void remove() {
-            throw new UnsupportedOperationException("read-only iterator");
+            throw new UnsupportedOperationException("read only");
         }
     }
 

File: common/src/main/java/io/netty/util/internal/EmptyArrays.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.netty.util.internal;
 
+import io.netty.util.AsciiString;
+
 import java.nio.ByteBuffer;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
@@ -27,6 +29,7 @@ public final class EmptyArrays {
     public static final Object[] EMPTY_OBJECTS = {};
     public static final Class<?>[] EMPTY_CLASSES = {};
     public static final String[] EMPTY_STRINGS = {};
+    public static final AsciiString[] EMPTY_ASCII_STRINGS = {};
     public static final StackTraceElement[] EMPTY_STACK_TRACE = {};
     public static final ByteBuffer[] EMPTY_BYTE_BUFFERS = {};
     public static final Certificate[] EMPTY_CERTIFICATES = {};

File: microbench/src/main/java/io/netty/microbench/headers/HeadersBenchmark.java
Patch:
@@ -54,7 +54,7 @@ private static String toHttpName(String name) {
         return (name.startsWith(":")) ? name.substring(1) : name;
     }
 
-    private static String toHttp2Name(String name) {
+    static String toHttp2Name(String name) {
         name = name.toLowerCase();
         return (name.equals("host")) ? "xhost" : name;
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -673,7 +673,7 @@ protected class HeadersBlockBuilder {
          */
         private void headerSizeExceeded() throws Http2Exception {
             close();
-            headerListSizeExceeded(streamId, headersDecoder.configuration().headerTable().maxHeaderListSize());
+            headerListSizeExceeded(streamId, headersDecoder.configuration().headerTable().maxHeaderListSize(), true);
         }
 
         /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java
Patch:
@@ -124,7 +124,7 @@ private void encodeHeadersEnforceMaxHeaderListSize(int streamId, ByteBuf out, Ht
             // overflow.
             headerSize += currHeaderSize;
             if (headerSize > maxHeaderListSize) {
-                headerListSizeExceeded(streamId, maxHeaderListSize);
+                headerListSizeExceeded(streamId, maxHeaderListSize, false);
             }
             encodeHeader(out, name, value, sensitivityDetector.isSensitive(name, value), currHeaderSize);
         }

File: handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java
Patch:
@@ -58,6 +58,7 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
+import java.util.Locale;
 
 
 @RunWith(Parameterized.class)
@@ -238,7 +239,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
     // at the moment as there are no different exceptions for the different alerts.
     private static void verifyException(Throwable cause, String messagePart, Promise<Void> promise) {
         String message = cause.getMessage();
-        if (message.contains(messagePart)) {
+        if (message.toLowerCase(Locale.UK).contains(messagePart.toLowerCase(Locale.UK))) {
             promise.setSuccess(null);
         } else {
             promise.setFailure(new AssertionError("message not contains '" + messagePart + "': " + message));

File: buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java
Patch:
@@ -24,6 +24,6 @@ protected Class<? extends ByteBuf> leakClass() {
 
     @Override
     protected ByteBuf wrap(ByteBuf buffer) {
-        return new AdvancedLeakAwareByteBuf(buffer, NoopResourceLeak.INSTANCE);
+        return new AdvancedLeakAwareByteBuf(buffer, new NoopResourceLeakTracker<ByteBuf>());
     }
 }

File: buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBufTest.java
Patch:
@@ -19,7 +19,7 @@ public class AdvancedLeakAwareCompositeByteBufTest extends SimpleLeakAwareCompos
 
     @Override
     protected WrappedCompositeByteBuf wrap(CompositeByteBuf buffer) {
-        return new AdvancedLeakAwareCompositeByteBuf(buffer, NoopResourceLeak.INSTANCE);
+        return new AdvancedLeakAwareCompositeByteBuf(buffer, new NoopResourceLeakTracker<ByteBuf>());
     }
 
     @Override

File: buffer/src/test/java/io/netty/buffer/SimpleLeakAwareByteBufTest.java
Patch:
@@ -27,7 +27,7 @@ protected final ByteBuf newBuffer(int capacity) {
     }
 
     protected ByteBuf wrap(ByteBuf buffer) {
-        return new SimpleLeakAwareByteBuf(buffer, NoopResourceLeak.INSTANCE);
+        return new SimpleLeakAwareByteBuf(buffer, new NoopResourceLeakTracker<ByteBuf>());
     }
 
     protected Class<? extends ByteBuf> leakClass() {

File: buffer/src/test/java/io/netty/buffer/SimpleLeakAwareCompositeByteBufTest.java
Patch:
@@ -24,7 +24,7 @@ public class SimpleLeakAwareCompositeByteBufTest extends WrappedCompositeByteBuf
 
     @Override
     protected WrappedCompositeByteBuf wrap(CompositeByteBuf buffer) {
-        return new SimpleLeakAwareCompositeByteBuf(buffer, NoopResourceLeak.INSTANCE);
+        return new SimpleLeakAwareCompositeByteBuf(buffer, new NoopResourceLeakTracker<ByteBuf>());
     }
 
     protected Class<? extends ByteBuf> leakClass() {

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -76,7 +76,7 @@ public void shouldAggregateChunksOnDecode() {
 
         assertThat(channel.readInbound(), nullValue());
 
-        channel.finish();
+        assertFalse(channel.finish());
     }
 
     @Test

File: buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
Patch:
@@ -69,7 +69,7 @@ public ByteBuf order(ByteOrder endianness) {
 
     @Override
     public ByteBuf unwrap() {
-        return buf.unwrap();
+        return buf;
     }
 
     @Override

File: buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Random;
 
 import static org.hamcrest.Matchers.*;
+import static org.hamcrest.Matchers.sameInstance;
 import static org.junit.Assert.*;
 
 /**
@@ -156,7 +157,7 @@ public void testSwap() throws Exception {
         ByteBuf swapped = buf.order(ByteOrder.LITTLE_ENDIAN);
 
         assertThat(swapped, instanceOf(SwappedByteBuf.class));
-        assertThat(swapped.unwrap(), is((ByteBuf) null));
+        assertThat(swapped.unwrap(), sameInstance(buf));
         assertThat(swapped.order(ByteOrder.LITTLE_ENDIAN), sameInstance(swapped));
         assertThat(swapped.order(ByteOrder.BIG_ENDIAN), sameInstance(buf));
 

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -34,7 +34,7 @@
  * {@link ChannelPool} implementation that takes another {@link ChannelPool} implementation and enforce a maximum
  * number of concurrent connections.
  */
-public final class FixedChannelPool extends SimpleChannelPool {
+public class FixedChannelPool extends SimpleChannelPool {
     private static final IllegalStateException FULL_EXCEPTION = ThrowableUtil.unknownStackTrace(
             new IllegalStateException("Too many outstanding acquire operations"),
             FixedChannelPool.class, "acquire0(...)");

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java
Patch:
@@ -34,9 +34,6 @@
  * A <a href="http://tools.ietf.org/html/rfc6265">RFC6265</a> compliant cookie encoder to be used client side, so
  * only name=value pairs are sent.
  *
- * User-Agents are not supposed to interpret cookies, so, if present, {@link Cookie#rawValue()} will be used.
- * Otherwise, {@link Cookie#value()} will be used unquoted.
- *
  * Note that multiple cookies are supposed to be sent at once in a single "Cookie" header.
  *
  * <pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/DefaultCookie.java
Patch:
@@ -153,8 +153,6 @@ public boolean equals(Object o) {
             if (that.domain() != null) {
                 return false;
             }
-        } else if (that.domain() == null) {
-            return false;
         } else {
             return domain().equalsIgnoreCase(that.domain());
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java
Patch:
@@ -213,7 +213,7 @@ public List<String> encode(Iterable<? extends Cookie> cookies) {
         Map<String, Integer> nameToIndex = strict && cookiesIt.hasNext() ? new HashMap<String, Integer>() : null;
         int i = 0;
         encoded.add(encode(firstCookie));
-        boolean hasDupdName = nameToIndex != null ? nameToIndex.put(firstCookie.name(), i++) != null : false;
+        boolean hasDupdName = nameToIndex != null && nameToIndex.put(firstCookie.name(), i++) != null;
         while (cookiesIt.hasNext()) {
             Cookie c = cookiesIt.next();
             encoded.add(encode(c));

File: codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java
Patch:
@@ -328,8 +328,8 @@ public T addObject(K name, Iterable<?> values) {
 
     @Override
     public T addObject(K name, Object... values) {
-        for (int i = 0; i < values.length; i++) {
-            addObject(name, values[i]);
+        for (Object value: values) {
+            addObject(name, value);
         }
         return thisT();
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.handler.codec.CharSequenceValueConverter;
+import io.netty.handler.codec.DateFormatter;
 import io.netty.handler.codec.DefaultHeaders;
 import io.netty.handler.codec.DefaultHeaders.NameValidator;
 import io.netty.handler.codec.DefaultHeadersImpl;
@@ -391,10 +392,10 @@ public CharSequence convertObject(Object value) {
                 return (CharSequence) value;
             }
             if (value instanceof Date) {
-                return HttpHeaderDateFormat.get().format((Date) value);
+                return DateFormatter.format((Date) value);
             }
             if (value instanceof Calendar) {
-                return HttpHeaderDateFormat.get().format(((Calendar) value).getTime());
+                return DateFormatter.format(((Calendar) value).getTime());
             }
             return value.toString();
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.util.concurrent.FastThreadLocal;
+import io.netty.handler.codec.DateFormatter;
 
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
@@ -32,7 +33,7 @@
  * <li>Sunday, 06-Nov-94 08:49:37 GMT: obsolete specification</li>
  * <li>Sun Nov  6 08:49:37 1994: obsolete specification</li>
  * </ul>
- * @deprecated Use {@link HttpHeaderDateFormatter} instead
+ * @deprecated Use {@link DateFormatter} instead
  */
 @Deprecated
 public final class HttpHeaderDateFormat extends SimpleDateFormat {

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http.cookie;
 
-import io.netty.handler.codec.http.HttpHeaderDateFormatter;
+import io.netty.handler.codec.DateFormatter;
 
 import java.util.Date;
 
@@ -168,7 +168,7 @@ private long mergeMaxAgeAndExpires() {
             if (maxAge != Long.MIN_VALUE) {
                 return maxAge;
             } else if (isValueDefined(expiresStart, expiresEnd)) {
-                Date expiresDate = HttpHeaderDateFormatter.parse(header, expiresStart, expiresEnd);
+                Date expiresDate = DateFormatter.parseHttpDate(header, expiresStart, expiresEnd);
                 if (expiresDate != null) {
                     long maxAgeMillis = expiresDate.getTime() - System.currentTimeMillis();
                     return maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0 ? 1 : 0);

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java
Patch:
@@ -21,7 +21,7 @@
 import static io.netty.handler.codec.http.cookie.CookieUtil.stripTrailingSeparator;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
-import io.netty.handler.codec.http.HttpHeaderDateFormatter;
+import io.netty.handler.codec.DateFormatter;
 import io.netty.handler.codec.http.HttpConstants;
 import io.netty.handler.codec.http.HttpRequest;
 
@@ -106,7 +106,7 @@ public String encode(Cookie cookie) {
             Date expires = new Date(cookie.maxAge() * 1000 + System.currentTimeMillis());
             buf.append(CookieHeaderNames.EXPIRES);
             buf.append((char) HttpConstants.EQUALS);
-            HttpHeaderDateFormatter.append(expires, buf);
+            DateFormatter.append(expires, buf);
             buf.append((char) HttpConstants.SEMICOLON);
             buf.append((char) HttpConstants.SP);
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/cookie/ServerCookieEncoderTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import io.netty.handler.codec.http.HttpHeaderDateFormat;
+import io.netty.handler.codec.DateFormatter;
 
 import java.text.ParseException;
 import java.util.ArrayList;
@@ -51,7 +51,7 @@ public void testEncodingSingleCookieV0() throws ParseException {
 
         Matcher matcher = Pattern.compile(result).matcher(encodedCookie);
         assertTrue(matcher.find());
-        Date expiresDate = HttpHeaderDateFormat.get().parse(matcher.group(1));
+        Date expiresDate = DateFormatter.parseHttpDate(matcher.group(1));
         long diff = (expiresDate.getTime() - System.currentTimeMillis()) / 1000;
         // 2 secs should be fine
         assertTrue(Math.abs(diff - maxAge) <= 2);

File: buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
Patch:
@@ -91,7 +91,7 @@ boolean release0() {
 
     @Override
     public final boolean release(int decrement) {
-        return unwrap().release(decrement);
+        return release0(decrement);
     }
 
     boolean release0(int decrement) {

File: buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java
Patch:
@@ -216,9 +216,7 @@ protected long _getLongLE(int index) {
 
     @Override
     public ByteBuf duplicate() {
-        final ByteBuf duplicate = unwrap().slice(adjustment, length());
-        duplicate.setIndex(readerIndex(), writerIndex());
-        return duplicate;
+        return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -2135,12 +2135,14 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      * Returns a buffer which shares the whole region of this buffer.
      * Modifying the content of the returned buffer or this buffer affects
      * each other's content while they maintain separate indexes and marks.
-     * This method is identical to {@code buf.slice(0, buf.capacity())}.
      * This method does not modify {@code readerIndex} or {@code writerIndex} of
      * this buffer.
      * <p>
      * The reader and writer marks will not be duplicated. Also be aware that this method will
      * NOT call {@link #retain()} and so the reference count will NOT be increased.
+     * @return A buffer whose readable content is equivalent to the buffer returned by {@link #slice()}.
+     * However this buffer will share the capacity of the underlying buffer, and therefore allows access to all of the
+     * underlying content if necessary.
      */
     public abstract ByteBuf duplicate();
 

File: buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java
Patch:
@@ -94,9 +94,7 @@ public ByteBuf retainedSlice(int index, int length) {
 
     @Override
     public ByteBuf duplicate() {
-        ByteBuf duplicate = duplicate0();
-        duplicate.setIndex(readerIndex(), writerIndex());
-        return duplicate;
+        return duplicate0().setIndex(readerIndex(), writerIndex());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -32,7 +32,9 @@
  * <li>Sunday, 06-Nov-94 08:49:37 GMT: obsolete specification</li>
  * <li>Sun Nov  6 08:49:37 1994: obsolete specification</li>
  * </ul>
+ * @deprecated Use {@link HttpHeaderDateFormatter} instead
  */
+@Deprecated
 public final class HttpHeaderDateFormat extends SimpleDateFormat {
     private static final long serialVersionUID = -925286159755905325L;
 

File: buffer/src/main/java/io/netty/buffer/UnpooledDuplicatedByteBuf.java
Patch:
@@ -19,7 +19,7 @@
  * {@link DuplicatedByteBuf} implementation that can do optimizations because it knows the duplicated buffer
  * is of type {@link AbstractByteBuf}.
  */
-final class UnpooledDuplicatedByteBuf extends DuplicatedByteBuf {
+class UnpooledDuplicatedByteBuf extends DuplicatedByteBuf {
     UnpooledDuplicatedByteBuf(AbstractByteBuf buffer) {
         super(buffer);
     }

File: buffer/src/main/java/io/netty/buffer/UnpooledSlicedByteBuf.java
Patch:
@@ -19,8 +19,7 @@
  * A special {@link AbstractUnpooledSlicedByteBuf} that can make optimizations because it knows the sliced buffer is of
  * type {@link AbstractByteBuf}.
  */
-final class UnpooledSlicedByteBuf extends AbstractUnpooledSlicedByteBuf {
-
+class UnpooledSlicedByteBuf extends AbstractUnpooledSlicedByteBuf {
     UnpooledSlicedByteBuf(AbstractByteBuf buffer, int index, int length) {
         super(buffer, index, length);
     }

File: buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java
Patch:
@@ -24,7 +24,8 @@ public class RetainedSlicedByteBufTest extends SlicedByteBufTest {
     @Override
     protected ByteBuf newBuffer(int length) {
         ByteBuf wrapped = Unpooled.wrappedBuffer(new byte[length * 2]);
-        ByteBuf buffer = wrapped.retainedSlice(ThreadLocalRandom.current().nextInt(length - 1) + 1, length);
+        ByteBuf buffer = wrapped.retainedSlice(length > 1 ? ThreadLocalRandom.current().nextInt(length - 1) + 1 : 0,
+                                               length);
         wrapped.release();
 
         assertEquals(0, buffer.readerIndex());

File: buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
Patch:
@@ -31,7 +31,7 @@ public class SlicedByteBufTest extends AbstractByteBufTest {
     @Override
     protected ByteBuf newBuffer(int length) {
         ByteBuf buffer = Unpooled.wrappedBuffer(
-                new byte[length * 2], ThreadLocalRandom.current().nextInt(length - 1) + 1, length);
+                new byte[length * 2], length > 1 ? ThreadLocalRandom.current().nextInt(length - 1) + 1 : 0, length);
         assertEquals(0, buffer.readerIndex());
         assertEquals(length, buffer.writerIndex());
         return buffer;

File: common/src/main/java/io/netty/util/internal/PriorityQueue.java
Patch:
@@ -78,10 +78,9 @@ public void clear() {
 
     @Override
     public boolean offer(T e) {
-        checkNotNull(e, "e");
         if (e.priorityQueueIndex() != INDEX_NOT_IN_QUEUE) {
             throw new IllegalArgumentException("e.priorityQueueIndex(): " + e.priorityQueueIndex() +
-                    " (expected: " + INDEX_NOT_IN_QUEUE + ")");
+                    " (expected: " + INDEX_NOT_IN_QUEUE + ") + e: " + e);
         }
 
         // Check that the array capacity is enough to hold values by doubling capacity.

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java
Patch:
@@ -70,7 +70,8 @@ public class Http2FrameCodecTest {
     @Before
     public void setUp() throws Exception {
         frameWriter = spy(new VerifiableHttp2FrameWriter());
-        framingCodec = new Http2FrameCodec(true, frameWriter, new Http2FrameLogger(LogLevel.TRACE));
+        framingCodec = new Http2FrameCodec(true, frameWriter, new Http2FrameLogger(LogLevel.TRACE),
+                                           new Http2Settings());
         frameListener = ((DefaultHttp2ConnectionDecoder) framingCodec.connectionHandler().decoder())
                 .internalFrameListener();
         inboundHandler = new LastInboundHandler();

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -107,7 +107,7 @@ public LocalChannel() {
         config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));
     }
 
-    LocalChannel(LocalServerChannel parent, LocalChannel peer) {
+    protected LocalChannel(LocalServerChannel parent, LocalChannel peer) {
         super(parent);
         config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));
         this.peer = peer;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -303,7 +303,7 @@ public ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId,
 
             // Encode the entire header block into an intermediate buffer.
             headerBlock = ctx.alloc().buffer();
-            headersEncoder.encodeHeaders(headers, headerBlock);
+            headersEncoder.encodeHeaders(streamId, headers, headerBlock);
 
             // Read the first fragment (possibly everything).
             Http2Flags flags = new Http2Flags().paddingPresent(padding > 0);
@@ -427,7 +427,7 @@ private ChannelFuture writeHeadersInternal(ChannelHandlerContext ctx,
 
             // Encode the entire header block.
             headerBlock = ctx.alloc().buffer();
-            headersEncoder.encodeHeaders(headers, headerBlock);
+            headersEncoder.encodeHeaders(streamId, headers, headerBlock);
 
             Http2Flags flags =
                     new Http2Flags().endOfStream(endStream).priorityPresent(hasPriority).paddingPresent(padding > 0);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
Patch:
@@ -59,7 +59,7 @@ public DefaultHttp2HeadersEncoder(SensitivityDetector sensitivityDetector, boole
     }
 
     @Override
-    public void encodeHeaders(Http2Headers headers, ByteBuf buffer) throws Http2Exception {
+    public void encodeHeaders(int streamId, Http2Headers headers, ByteBuf buffer) throws Http2Exception {
         try {
             // If there was a change in the table size, serialize the output from the encoder
             // resulting from that change.
@@ -68,7 +68,7 @@ public void encodeHeaders(Http2Headers headers, ByteBuf buffer) throws Http2Exce
                 tableSizeChangeOutput.clear();
             }
 
-            encoder.encodeHeaders(buffer, headers, sensitivityDetector);
+            encoder.encodeHeaders(streamId, buffer, headers, sensitivityDetector);
         } catch (Http2Exception e) {
             throw e;
         } catch (Throwable t) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java
Patch:
@@ -54,10 +54,11 @@ interface SensitivityDetector {
     /**
      * Encodes the given headers and writes the output headers block to the given output buffer.
      *
+     * @param streamId  the identifier of the stream for which the headers are encoded.
      * @param headers the headers to be encoded.
      * @param buffer the buffer to receive the encoded headers.
      */
-    void encodeHeaders(Http2Headers headers, ByteBuf buffer) throws Http2Exception;
+    void encodeHeaders(int streamId, Http2Headers headers, ByteBuf buffer) throws Http2Exception;
 
     /**
      * Get the {@link Configuration} for this {@link Http2HeadersEncoder}

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
Patch:
@@ -77,7 +77,7 @@ private static ByteBuf encode(byte[]... entries) throws Exception {
         for (int ix = 0; ix < entries.length;) {
             http2Headers.add(new AsciiString(entries[ix++], false), new AsciiString(entries[ix++], false));
         }
-        encoder.encodeHeaders(out, http2Headers, NEVER_SENSITIVE);
+        encoder.encodeHeaders(3 /* randomly chosen */, out, http2Headers, NEVER_SENSITIVE);
         return out;
     }
 }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2HeaderBlockIOTest.java
Patch:
@@ -81,7 +81,7 @@ public void setMaxHeaderSizeShouldBeSuccessful() throws Http2Exception {
     }
 
     private void assertRoundtripSuccessful(Http2Headers in) throws Http2Exception {
-        encoder.encodeHeaders(in, buffer);
+        encoder.encodeHeaders(3 /* randomly chosen */, in, buffer);
 
         Http2Headers out = decoder.decodeHeaders(0, buffer);
         assertEquals(in, out);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java
Patch:
@@ -195,7 +195,7 @@ public boolean isSensitive(CharSequence name, CharSequence value) {
                 encoder.setMaxHeaderTableSize(buffer, maxHeaderTableSize);
             }
 
-            encoder.encodeHeaders(buffer, http2Headers, sensitivityDetector);
+            encoder.encodeHeaders(3 /* randomly chosen */, buffer, http2Headers, sensitivityDetector);
             byte[] bytes = new byte[buffer.readableBytes()];
             buffer.readBytes(bytes);
             return bytes;

File: microbench/src/main/java/io/netty/microbench/http2/internal/hpack/DecoderBenchmark.java
Patch:
@@ -96,8 +96,9 @@ private byte[] getSerializedHeaders(Http2Headers headers, boolean sensitive) thr
         Encoder encoder = newTestEncoder();
         ByteBuf out = size.newOutBuffer();
         try {
-            encoder.encodeHeaders(out, headers, sensitive ? Http2HeadersEncoder.ALWAYS_SENSITIVE
-                                                          : Http2HeadersEncoder.NEVER_SENSITIVE);
+            encoder.encodeHeaders(3 /* randomly chosen */, out, headers,
+                                  sensitive ? Http2HeadersEncoder.ALWAYS_SENSITIVE
+                                            : Http2HeadersEncoder.NEVER_SENSITIVE);
             byte[] bytes = new byte[out.readableBytes()];
             out.readBytes(bytes);
             return bytes;

File: microbench/src/main/java/io/netty/microbench/http2/internal/hpack/EncoderBenchmark.java
Patch:
@@ -110,7 +110,7 @@ public void tearDown() {
     public void encode(Blackhole bh) throws Exception {
         Encoder encoder = newTestEncoder();
         output.clear();
-        encoder.encodeHeaders(output, http2Headers, sensitivityDetector);
+        encoder.encodeHeaders(3 /*randomly chosen*/, output, http2Headers, sensitivityDetector);
         bh.consume(output);
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -677,7 +677,9 @@ public ChannelFuture goAway(final ChannelHandlerContext ctx, final int lastStrea
                 // Protect against re-entrancy. Could happen if writing the frame fails, and error handling
                 // treating this is a connection handler and doing a graceful shutdown...
                 if (lastStreamId == connection().remote().lastStreamKnownByPeer()) {
-                    return promise;
+                    // Release the data and notify the promise
+                    debugData.release();
+                    return promise.setSuccess();
                 }
                 if (lastStreamId > connection.remote().lastStreamKnownByPeer()) {
                     throw connectionError(PROTOCOL_ERROR, "Last stream identifier must not increase between " +

File: handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
Patch:
@@ -96,6 +96,8 @@ public class JdkSslContext extends SslContext {
                 SUPPORTED_CIPHERS, ciphers,
                 // XXX: Make sure to sync this list with OpenSslEngineFactory.
                 // GCM (Galois/Counter Mode) requires JDK 8.
+                "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
+                "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                 "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                 "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                 // AES256 requires JCE unlimited strength jurisdiction policy files.
@@ -104,8 +106,7 @@ public class JdkSslContext extends SslContext {
                 "TLS_RSA_WITH_AES_128_GCM_SHA256",
                 "TLS_RSA_WITH_AES_128_CBC_SHA",
                 // AES256 requires JCE unlimited strength jurisdiction policy files.
-                "TLS_RSA_WITH_AES_256_CBC_SHA",
-                "SSL_RSA_WITH_3DES_EDE_CBC_SHA");
+                "TLS_RSA_WITH_AES_256_CBC_SHA");
 
         if (ciphers.isEmpty()) {
             // Use the default from JDK as fallback.

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java
Patch:
@@ -160,13 +160,14 @@ public ApplicationProtocolConfig.SelectedListenerFailureBehavior selectedListene
         // XXX: Make sure to sync this list with JdkSslEngineFactory.
         Collections.addAll(
                 ciphers,
+                "ECDHE-ECDSA-AES256-GCM-SHA384",
+                "ECDHE-ECDSA-AES128-GCM-SHA256",
                 "ECDHE-RSA-AES128-GCM-SHA256",
                 "ECDHE-RSA-AES128-SHA",
                 "ECDHE-RSA-AES256-SHA",
                 "AES128-GCM-SHA256",
                 "AES128-SHA",
-                "AES256-SHA",
-                "DES-CBC3-SHA");
+                "AES256-SHA");
         DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);
 
         if (logger.isDebugEnabled()) {

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -104,10 +104,12 @@ public void run() {
 
     public LocalChannel() {
         super(null);
+        config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));
     }
 
     LocalChannel(LocalServerChannel parent, LocalChannel peer) {
         super(parent);
+        config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));
         this.peer = peer;
         localAddress = parent.localAddress();
         remoteAddress = peer.localAddress();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -303,6 +303,8 @@ public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promi
         }
 
         msg.headers().setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_PROMISE_ID.text(), streamId);
+        msg.headers().setShort(HttpConversionUtil.ExtensionHeaderNames.STREAM_WEIGHT.text(),
+                Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT);
 
         processHeadersEnd(ctx, promisedStream, msg, false);
     }

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
Patch:
@@ -69,7 +69,7 @@ public class ProtobufDecoder extends MessageToMessageDecoder<ByteBuf> {
     static {
         boolean hasParser = false;
         try {
-            // MessageLite.getParsetForType() is not available until protobuf 2.5.0.
+            // MessageLite.getParserForType() is not available until protobuf 2.5.0.
             MessageLite.class.getDeclaredMethod("getParserForType");
             hasParser = true;
         } catch (Throwable t) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -98,7 +98,7 @@ public void remoteSettings(Http2Settings settings) throws Http2Exception {
             outboundHeaderTable.maxHeaderTableSize((int) min(headerTableSize, MAX_VALUE));
         }
 
-        Integer maxHeaderListSize = settings.maxHeaderListSize();
+        Long maxHeaderListSize = settings.maxHeaderListSize();
         if (maxHeaderListSize != null) {
             outboundHeaderTable.maxHeaderListSize(maxHeaderListSize);
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/DynamicTable.java
Patch:
@@ -41,13 +41,13 @@ final class DynamicTable {
     HeaderField[] headerFields;
     int head;
     int tail;
-    private int size;
+    private long size;
     private long capacity = -1; // ensure setCapacity creates the array
 
     /**
      * Creates a new dynamic table with the specified initial capacity.
      */
-    DynamicTable(int initialCapacity) {
+    DynamicTable(long initialCapacity) {
         setCapacity(initialCapacity);
     }
 
@@ -106,7 +106,7 @@ public void add(HeaderField header) {
             clear();
             return;
         }
-        while (size + headerSize > capacity) {
+        while (capacity - size < headerSize) {
             remove();
         }
         headerFields[head++] = header;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderField.java
Patch:
@@ -41,7 +41,7 @@ class HeaderField {
     // overhead associated with the structure.
     static final int HEADER_ENTRY_OVERHEAD = 32;
 
-    static int sizeOf(CharSequence name, CharSequence value) {
+    static long sizeOf(CharSequence name, CharSequence value) {
         return name.length() + value.length() + HEADER_ENTRY_OVERHEAD;
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoderTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static io.netty.handler.codec.http2.Http2TestUtil.newTestEncoder;
 import static org.junit.Assert.assertTrue;
 
 /**
@@ -32,7 +33,7 @@ public class DefaultHttp2HeadersEncoderTest {
 
     @Before
     public void setup() {
-        encoder = new DefaultHttp2HeadersEncoder();
+        encoder = new DefaultHttp2HeadersEncoder(Http2HeadersEncoder.NEVER_SENSITIVE, newTestEncoder());
     }
 
     @Test

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2HeaderBlockIOTest.java
Patch:
@@ -83,7 +83,7 @@ public void setMaxHeaderSizeShouldBeSuccessful() throws Http2Exception {
     private void assertRoundtripSuccessful(Http2Headers in) throws Http2Exception {
         encoder.encodeHeaders(in, buffer);
 
-        Http2Headers out = decoder.decodeHeaders(buffer);
+        Http2Headers out = decoder.decodeHeaders(0, buffer);
         assertEquals(in, out);
     }
 

File: example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp2HandlerBuilder.java
Patch:
@@ -41,7 +41,6 @@ public HelloWorldHttp2Handler build() {
     @Override
     protected HelloWorldHttp2Handler build(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
                                            Http2Settings initialSettings) {
-
         HelloWorldHttp2Handler handler = new HelloWorldHttp2Handler(decoder, encoder, initialSettings);
         frameListener(handler);
         return handler;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java
Patch:
@@ -24,10 +24,11 @@
 @UnstableApi
 public abstract class AbstractHttp2StreamFrame implements Http2StreamFrame {
 
-    private int streamId = -1;
+    // Volatile as parent and child channel may be on different eventloops.
+    private volatile int streamId = -1;
 
     @Override
-    public AbstractHttp2StreamFrame setStreamId(int streamId) {
+    public AbstractHttp2StreamFrame streamId(int streamId) {
         if (this.streamId != -1) {
             throw new IllegalStateException("Stream identifier may only be set once.");
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java
Patch:
@@ -76,8 +76,8 @@ public DefaultHttp2DataFrame(ByteBuf content, boolean endStream, int padding) {
     }
 
     @Override
-    public DefaultHttp2DataFrame setStreamId(int streamId) {
-        super.setStreamId(streamId);
+    public DefaultHttp2DataFrame streamId(int streamId) {
+        super.streamId(streamId);
         return this;
     }
 
@@ -154,7 +154,7 @@ public DefaultHttp2DataFrame retain(int increment) {
     @Override
     public String toString() {
         return "DefaultHttp2DataFrame(streamId=" + streamId() + ", content=" + content
-            + ", endStream=" + endStream + ", padding=" + padding + ")";
+               + ", endStream=" + endStream + ", padding=" + padding + ")";
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersFrame.java
Patch:
@@ -63,8 +63,8 @@ public DefaultHttp2HeadersFrame(Http2Headers headers, boolean endStream, int pad
     }
 
     @Override
-    public DefaultHttp2HeadersFrame setStreamId(int streamId) {
-        super.setStreamId(streamId);
+    public DefaultHttp2HeadersFrame streamId(int streamId) {
+        super.streamId(streamId);
         return this;
     }
 
@@ -91,7 +91,7 @@ public int padding() {
     @Override
     public String toString() {
         return "DefaultHttp2HeadersFrame(streamId=" + streamId() + ", headers=" + headers
-            + ", endStream=" + endStream + ", padding=" + padding + ")";
+               + ", endStream=" + endStream + ", padding=" + padding + ")";
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java
Patch:
@@ -45,8 +45,8 @@ public DefaultHttp2ResetFrame(long errorCode) {
     }
 
     @Override
-    public DefaultHttp2ResetFrame setStreamId(int streamId) {
-        super.setStreamId(streamId);
+    public DefaultHttp2ResetFrame streamId(int streamId) {
+        super.streamId(streamId);
         return this;
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2WindowUpdateFrame.java
Patch:
@@ -32,8 +32,8 @@ public DefaultHttp2WindowUpdateFrame(int windowUpdateIncrement) {
     }
 
     @Override
-    public DefaultHttp2WindowUpdateFrame setStreamId(int streamId) {
-        super.setStreamId(streamId);
+    public DefaultHttp2WindowUpdateFrame streamId(int streamId) {
+        super.streamId(streamId);
         return this;
     }
 

File: common/src/main/java/io/netty/util/internal/UnstableApi.java
Patch:
@@ -28,7 +28,7 @@
  *
  * <ol>
  *     <li>Is not needed for things located in *.internal.* packages</li>
- *     <li>Only public acessible classes/interfaces must be annotated</li>
+ *     <li>Only public accessible classes/interfaces must be annotated</li>
  *     <li>If this annotation is not present the API is considered stable and so no backward compatibility can be
  *         broken in a non-major release!</li>
  * </ol>

File: codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java
Patch:
@@ -182,6 +182,9 @@ static HAProxyMessage decodeHeader(ByteBuf header) {
                 addressLen = addressEnd - startIdx;
             }
             dstAddress = header.toString(startIdx, addressLen, CharsetUtil.US_ASCII);
+            // AF_UNIX defines that exactly 108 bytes are reserved for the address. The previous methods
+            // did not increase the reader index although we already consumed the information.
+            header.readerIndex(startIdx + 108);
         } else {
             if (addressFamily == AddressFamily.AF_IPv4) {
                 // IPv4 requires 12 bytes for address information

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -221,7 +221,7 @@ public final ResourceLeak open(T obj) {
         }
 
         if (level.ordinal() < Level.PARANOID.ordinal()) {
-            if ((leakCheckCnt ++ & mask) == 0) {
+            if ((++ leakCheckCnt & mask) == 0) {
                 reportLeak(level);
                 return new DefaultResourceLeak(obj);
             } else {

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressDecoder.java
Patch:
@@ -52,7 +52,7 @@ public String decodeAddress(Socks5AddressType addrType, ByteBuf in) throws Excep
                 } else {
                     byte[] tmp = new byte[IPv6_LEN];
                     in.readBytes(tmp);
-                    return NetUtil.bytesToIpAddress(tmp, 0, IPv6_LEN);
+                    return NetUtil.bytesToIpAddress(tmp);
                 }
             } else {
                 throw new DecoderException("unsupported address type: " + (addrType.byteValue() & 0xFF));

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoderTest.java
Patch:
@@ -67,7 +67,7 @@ public void testCmdRequestDecoderIPv4() {
     @Test
     public void testCmdRequestDecoderIPv6() {
         String[] hosts = {
-                NetUtil.bytesToIpAddress(IPAddressUtil.textToNumericFormatV6("::1"), 0, 16) };
+                NetUtil.bytesToIpAddress(IPAddressUtil.textToNumericFormatV6("::1")) };
         int[] ports = {1, 32769, 65535};
         for (Socks5CommandType cmdType: Arrays.asList(Socks5CommandType.BIND,
                                                       Socks5CommandType.CONNECT,

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoderTest.java
Patch:
@@ -22,7 +22,8 @@
 
 import java.util.Arrays;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class Socks5CommandResponseDecoderTest {
 
@@ -92,7 +93,7 @@ public void testSocksCmdResponseDecoderIncludingHost() {
             test(cmdStatus, Socks5AddressType.IPv6,
                  "2001:db8:85a3:42:1000:8a2e:370:7334", 80);
             test(cmdStatus, Socks5AddressType.IPv6,
-                 "1111:111:11:1:0:0:0:1", 80);
+                 "1111:111:11:1::1", 80);
         }
     }
 }

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java
Patch:
@@ -76,7 +76,7 @@ public void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame headers)
             throws Exception {
         if (headers.isEndStream()) {
             ByteBuf content = ctx.alloc().buffer();
-            content.writeBytes(RESPONSE_BYTES);
+            content.writeBytes(RESPONSE_BYTES.duplicate());
             ByteBufUtil.writeAscii(content, " - via HTTP/2");
             sendResponse(ctx, content);
         }

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2ServerInitializer.java
Patch:
@@ -34,6 +34,7 @@
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.AsciiString;
+import io.netty.util.ReferenceCountUtil;
 
 /**
  * Sets up the Netty pipeline for the example server. Depending on the endpoint config, sets up the
@@ -101,7 +102,7 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws E
                 ChannelHandlerContext thisCtx = pipeline.context(this);
                 pipeline.addAfter(thisCtx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
                 pipeline.replace(this, null, new HttpObjectAggregator(maxHttpContentLength));
-                ctx.fireChannelRead(msg);
+                ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
             }
         });
 

File: example/src/main/java/io/netty/example/http2/helloworld/server/Http2ServerInitializer.java
Patch:
@@ -32,6 +32,7 @@
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.AsciiString;
+import io.netty.util.ReferenceCountUtil;
 
 /**
  * Sets up the Netty pipeline for the example server. Depending on the endpoint config, sets up the
@@ -99,7 +100,7 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws E
                 ChannelHandlerContext thisCtx = pipeline.context(this);
                 pipeline.addAfter(thisCtx.name(), null, new HelloWorldHttp1Handler("Direct. No Upgrade Attempted."));
                 pipeline.replace(this, null, new HttpObjectAggregator(maxHttpContentLength));
-                ctx.fireChannelRead(msg);
+                ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
             }
         });
 

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -268,7 +268,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
     @Override
     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        if (readerIdleTimeNanos > 0 || allIdleTimeNanos > 0) {
+        if ((readerIdleTimeNanos > 0 || allIdleTimeNanos > 0) && reading) {
             lastReadTime = System.nanoTime();
             reading = false;
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -216,7 +216,7 @@ public void onStreamClosed(Http2Stream stream) {
 
         @Override
         public void onGoAwayReceived(final int lastStreamId, long errorCode, ByteBuf debugData) {
-            ctx.fireChannelRead(new DefaultHttp2GoAwayFrame(lastStreamId, errorCode, debugData));
+            ctx.fireChannelRead(new DefaultHttp2GoAwayFrame(lastStreamId, errorCode, debugData.retain()));
         }
     }
 

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -364,7 +364,7 @@ public final int compareTo(Channel o) {
 
     /**
      * Returns the {@link String} representation of this channel.  The returned
-     * string contains the {@linkplain #hashCode()} ID}, {@linkplain #localAddress() local address},
+     * string contains the {@linkplain #hashCode() ID}, {@linkplain #localAddress() local address},
      * and {@linkplain #remoteAddress() remote address} of this channel for
      * easier identification.
      */

File: handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
Patch:
@@ -251,7 +251,7 @@ public JdkSslClientContext(File trustCertCollectionFile, TrustManagerFactory tru
                 trustCertCollectionFile), trustManagerFactory,
                 toX509CertificatesInternal(keyCertChainFile), toPrivateKeyInternal(keyFile, keyPassword),
                 keyPassword, keyManagerFactory, sessionCacheSize, sessionTimeout), true,
-                ciphers, cipherFilter, apn, ClientAuth.NONE);
+                ciphers, cipherFilter, apn, ClientAuth.NONE, false);
     }
 
     JdkSslClientContext(X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory,
@@ -260,7 +260,7 @@ public JdkSslClientContext(File trustCertCollectionFile, TrustManagerFactory tru
                         ApplicationProtocolConfig apn, long sessionCacheSize, long sessionTimeout) throws SSLException {
         super(newSSLContext(trustCertCollection, trustManagerFactory, keyCertChain, key, keyPassword,
                 keyManagerFactory, sessionCacheSize, sessionTimeout), true,
-                ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE);
+                ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE, false);
     }
 
     private static SSLContext newSSLContext(X509Certificate[] trustCertCollection,

File: handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java
Patch:
@@ -215,17 +215,17 @@ public JdkSslServerContext(File trustCertCollectionFile, TrustManagerFactory tru
         super(newSSLContext(toX509CertificatesInternal(trustCertCollectionFile), trustManagerFactory,
                 toX509CertificatesInternal(keyCertChainFile), toPrivateKeyInternal(keyFile, keyPassword),
                 keyPassword, keyManagerFactory, sessionCacheSize, sessionTimeout), false,
-                ciphers, cipherFilter, apn, ClientAuth.NONE);
+                ciphers, cipherFilter, apn, ClientAuth.NONE, false);
     }
 
     JdkSslServerContext(X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory,
                         X509Certificate[] keyCertChain, PrivateKey key, String keyPassword,
                         KeyManagerFactory keyManagerFactory, Iterable<String> ciphers, CipherSuiteFilter cipherFilter,
                         ApplicationProtocolConfig apn, long sessionCacheSize, long sessionTimeout,
-                        ClientAuth clientAuth) throws SSLException {
+                        ClientAuth clientAuth, boolean startTls) throws SSLException {
         super(newSSLContext(trustCertCollection, trustManagerFactory, keyCertChain, key,
                 keyPassword, keyManagerFactory, sessionCacheSize, sessionTimeout), false,
-                ciphers, cipherFilter, toNegotiator(apn, true), clientAuth);
+                ciphers, cipherFilter, toNegotiator(apn, true), clientAuth, startTls);
     }
 
     private static SSLContext newSSLContext(X509Certificate[] trustCertCollection,

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -185,7 +185,7 @@ public OpenSslClientContext(File trustCertCollectionFile, TrustManagerFactory tr
                                 long sessionCacheSize, long sessionTimeout)
             throws SSLException {
         super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, keyCertChain,
-                ClientAuth.NONE);
+                ClientAuth.NONE, false);
         boolean success = false;
         try {
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -57,7 +57,7 @@ public final class ReferenceCountedOpenSslClientContext extends ReferenceCounted
                                          long sessionCacheSize, long sessionTimeout)
             throws SSLException {
         super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, keyCertChain,
-              ClientAuth.NONE, true);
+              ClientAuth.NONE, false, true);
         boolean success = false;
         try {
             sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -1274,7 +1274,7 @@ private int forEachByteAsc0(int start, int end, ByteProcessor processor) throws
     public int forEachByteDesc(ByteProcessor processor) {
         ensureAccessible();
         try {
-            return forEachByteDesc0(writerIndex, readerIndex, processor);
+            return forEachByteDesc0(writerIndex - 1, readerIndex, processor);
         } catch (Exception e) {
             PlatformDependent.throwException(e);
             return -1;

File: handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java
Patch:
@@ -234,7 +234,7 @@ private static final class OpenSslCertificateRequestedCallback implements Certif
         }
 
         @Override
-        public void requested(long ssl, byte[] keyTypeBytes, byte[][] asn1DerEncodedPrincipals) {
+        public KeyMaterial requested(long ssl, byte[] keyTypeBytes, byte[][] asn1DerEncodedPrincipals) {
             final ReferenceCountedOpenSslEngine engine = engineMap.get(ssl);
             try {
                 final Set<String> keyTypesSet = supportedClientKeyTypes(keyTypeBytes);
@@ -248,12 +248,13 @@ public void requested(long ssl, byte[] keyTypeBytes, byte[][] asn1DerEncodedPrin
                         issuers[i] = new X500Principal(asn1DerEncodedPrincipals[i]);
                     }
                 }
-                keyManagerHolder.setKeyMaterial(engine, keyTypes, issuers);
+                return keyManagerHolder.keyMaterial(engine, keyTypes, issuers);
             } catch (Throwable cause) {
                 logger.debug("request of key failed", cause);
                 SSLHandshakeException e = new SSLHandshakeException("General OpenSslEngine problem");
                 e.initCause(cause);
                 engine.handshakeException = e;
+                return null;
             }
         }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -43,6 +43,7 @@
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
+import java.nio.channels.ConnectionPendingException;
 import java.util.Queue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledFuture;
@@ -782,7 +783,7 @@ public void connect(
 
             try {
                 if (connectPromise != null) {
-                    throw new IllegalStateException("connection attempt already made");
+                    throw new ConnectionPendingException();
                 }
 
                 boolean wasActive = isActive();

File: transport-native-epoll/src/main/java/io/netty/channel/unix/ErrorsStaticallyReferencedJniMethods.java
Patch:
@@ -38,5 +38,8 @@ private ErrorsStaticallyReferencedJniMethods() { }
     static native int errnoEWOULDBLOCK();
     static native int errnoEINPROGRESS();
     static native int errorECONNREFUSED();
+    static native int errorEISCONN();
+    static native int errorEALREADY();
+    static native int errorENETUNREACH();
     static native String strError(int err);
 }

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -37,6 +37,7 @@
 import java.net.SocketAddress;
 import java.nio.channels.CancelledKeyException;
 import java.nio.channels.ClosedChannelException;
+import java.nio.channels.ConnectionPendingException;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
 import java.util.concurrent.ScheduledFuture;
@@ -245,7 +246,8 @@ public final void connect(
 
             try {
                 if (connectPromise != null) {
-                    throw new IllegalStateException("connection attempt already made");
+                    // Already a connect in process.
+                    throw new ConnectionPendingException();
                 }
 
                 boolean wasActive = isActive();

File: handler/src/main/java/io/netty/handler/ssl/SslContext.java
Patch:
@@ -869,7 +869,7 @@ public final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int
         return newHandler(newEngine(alloc, peerHost, peerPort));
     }
 
-    private static SslHandler newHandler(SSLEngine engine) {
+    static SslHandler newHandler(SSLEngine engine) {
         return new SslHandler(engine);
     }
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -175,7 +175,7 @@ private void incrementPendingOutboundBytes(long size, boolean invokeLater) {
         }
 
         long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);
-        if (newWriteBufferSize >= channel.config().getWriteBufferHighWaterMark()) {
+        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {
             setUnwritable(invokeLater);
         }
     }
@@ -194,8 +194,7 @@ private void decrementPendingOutboundBytes(long size, boolean invokeLater, boole
         }
 
         long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, -size);
-        if (notifyWritability && (newWriteBufferSize == 0
-            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark())) {
+        if (notifyWritability && newWriteBufferSize < channel.config().getWriteBufferLowWaterMark()) {
             setWritable(invokeLater);
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/DefaultCookie.java
Patch:
@@ -135,7 +135,7 @@ public boolean equals(Object o) {
         }
 
         Cookie that = (Cookie) o;
-        if (!name().equalsIgnoreCase(that.name())) {
+        if (!name().equals(that.name())) {
             return false;
         }
 
@@ -164,7 +164,7 @@ public boolean equals(Object o) {
 
     @Override
     public int compareTo(Cookie c) {
-        int v = name().compareToIgnoreCase(c.name());
+        int v = name().compareTo(c.name());
         if (v != 0) {
             return v;
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -356,7 +356,6 @@ public void error(ChannelHandlerContext ctx, Throwable cause) {
             // Don't update dataSize because we need to ensure the size() method returns a consistent size even after
             // error so we don't invalidate flow control when returning bytes to flow control.
             lifecycleManager.onError(ctx, cause);
-            promise.tryFailure(cause);
         }
 
         @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -1050,7 +1050,7 @@ private void checkNewStreamAllowed(int streamId, State state) throws Http2Except
             }
             if (state.localSideOpen() || state.remoteSideOpen()) {
                 if (!canOpenStream()) {
-                    throw connectionError(REFUSED_STREAM, "Maximum active streams violated for this endpoint.");
+                    throw streamError(streamId, REFUSED_STREAM, "Maximum active streams violated for this endpoint.");
                 }
             } else if (numStreams == maxStreams) {
                 throw streamError(streamId, REFUSED_STREAM, "Maximum streams violated for this endpoint.");

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -262,15 +262,15 @@ private static String sanitizeUri(String uri) {
         return SystemPropertyUtil.get("user.dir") + File.separator + uri;
     }
 
-    private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
+    private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[^-\\._]?[^<>&\\\"]*");
 
     private static void sendListing(ChannelHandlerContext ctx, File dir, String dirPath) {
         FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
         response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8");
 
         StringBuilder buf = new StringBuilder()
             .append("<!DOCTYPE html>\r\n")
-            .append("<html><head><title>")
+            .append("<html><head><meta charset='utf-8' /><title>")
             .append("Listing of: ")
             .append(dirPath)
             .append("</title></head><body>\r\n")

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -137,7 +137,7 @@ public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) thr
 
         if (file.isDirectory()) {
             if (uri.endsWith("/")) {
-                sendListing(ctx, file);
+                sendListing(ctx, file, uri);
             } else {
                 sendRedirect(ctx, uri + '/');
             }
@@ -264,11 +264,10 @@ private static String sanitizeUri(String uri) {
 
     private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
 
-    private static void sendListing(ChannelHandlerContext ctx, File dir) {
+    private static void sendListing(ChannelHandlerContext ctx, File dir, String dirPath) {
         FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
         response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8");
 
-        String dirPath = dir.getPath();
         StringBuilder buf = new StringBuilder()
             .append("<!DOCTYPE html>\r\n")
             .append("<html><head><title>")

File: handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.Set;
 
 import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.freeBio;
-import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.newBIO;
 import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.toBIO;
 
 /**
@@ -104,8 +103,8 @@ private void setKeyMaterial(long ssl, String alias) throws SSLException {
                 // Only encode one time
                 PemEncoded encoded = PemX509Certificate.toPEM(ByteBufAllocator.DEFAULT, true, certificates);
                 try {
-                    keyCertChainBio = newBIO(encoded.content().retainedSlice());
-                    keyCertChainBio2 = newBIO(encoded.content().retainedSlice());
+                    keyCertChainBio = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());
+                    keyCertChainBio2 = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());
 
                     if (key != null) {
                         keyBio = toBIO(key);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java
Patch:
@@ -213,7 +213,7 @@ public void decode(ByteBuf in, Http2Headers headers) throws Http2Exception {
                     if (index == 0x7f) {
                         state = READ_LITERAL_HEADER_NAME_LENGTH;
                     } else {
-                        if (nameLength > maxHeadersLength - headersLength) {
+                        if (index > maxHeadersLength - headersLength) {
                             maxHeaderSizeExceeded();
                         }
                         nameLength = index;

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -498,7 +498,7 @@ public void checkException() {
     }
 
     /**
-     * Ensure the {@link Channel} is open and of not throw an exception.
+     * Ensure the {@link Channel} is open and if not throw an exception.
      */
     protected final void ensureOpen() {
         if (!isOpen()) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -386,7 +386,8 @@ private void applyLocalSettings(Http2Settings settings) throws Http2Exception {
             Long maxConcurrentStreams = settings.maxConcurrentStreams();
             if (maxConcurrentStreams != null) {
                 int value = (int) Math.min(maxConcurrentStreams, Integer.MAX_VALUE);
-                connection.remote().maxActiveStreams(value);
+                // By default just enforce the SETTINGS_MAX_CONCURRENT_STREAMS limit for stream in all states.
+                connection.remote().maxStreams(value, value);
             }
 
             Long headerTableSize = settings.headerTableSize();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -276,7 +276,7 @@ private final class FlowState implements StreamByteDistributor.StreamState {
         private BooleanSupplier isWritableSupplier = new BooleanSupplier() {
             @Override
             public boolean get() throws Exception {
-                return windowSize() - pendingBytes() > 0;
+                return windowSize() > pendingBytes();
             }
         };
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
Patch:
@@ -453,9 +453,9 @@ public void closedBufferedStreamReleasesByteBuf() {
     }
 
     @Test
-    public void closeShouldCancelAllBufferedStreams() {
+    public void closeShouldCancelAllBufferedStreams() throws Http2Exception {
         encoder.writeSettingsAck(ctx, newPromise());
-        connection.local().maxActiveStreams(0);
+        connection.local().maxStreams(0, 0);
 
         ChannelFuture f1 = encoderWriteHeaders(3, newPromise());
         ChannelFuture f2 = encoderWriteHeaders(5, newPromise());

File: buffer/src/test/java/io/netty/buffer/BigEndianUnsafeNoCleanerDirectByteBufTest.java
Patch:
@@ -24,7 +24,8 @@ public class BigEndianUnsafeNoCleanerDirectByteBufTest extends BigEndianDirectBy
 
     @Before
     public void checkHasUnsafe() {
-        Assume.assumeTrue("sun.misc.Unsafe not found, skip tests", PlatformDependent.hasUnsafe());
+        Assume.assumeTrue("java.nio.DirectByteBuffer.<init>(long, int) not found, skip tests",
+                PlatformDependent.useDirectBufferNoCleaner());
     }
 
     @Override

File: buffer/src/test/java/io/netty/buffer/LittleEndianUnsafeNoCleanerDirectByteBufTest.java
Patch:
@@ -23,7 +23,8 @@ public class LittleEndianUnsafeNoCleanerDirectByteBufTest extends LittleEndianDi
 
     @Before
     public void checkHasUnsafe() {
-        Assume.assumeTrue("sun.misc.Unsafe not found, skip tests", PlatformDependent.hasUnsafe());
+        Assume.assumeTrue("java.nio.DirectByteBuffer.<init>(long, int) not found, skip tests",
+                PlatformDependent.useDirectBufferNoCleaner());
     }
 
     @Override

File: transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
Patch:
@@ -77,6 +77,9 @@ public <T> T getOption(ChannelOption<T> option) {
         if (option == SCTP_NODELAY) {
             return (T) Boolean.valueOf(isSctpNoDelay());
         }
+        if (option == SCTP_INIT_MAXSTREAMS) {
+            return (T) getInitMaxStreams();
+        }
         return super.getOption(option);
     }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslEngineMap.java
Patch:
@@ -21,15 +21,15 @@ interface OpenSslEngineMap {
      * Remove the {@link OpenSslEngine} with the given {@code ssl} address and
      * return it.
      */
-    OpenSslEngine remove(long ssl);
+    ReferenceCountedOpenSslEngine remove(long ssl);
 
     /**
      * Add a {@link OpenSslEngine} to this {@link OpenSslEngineMap}.
      */
-    void add(OpenSslEngine engine);
+    void add(ReferenceCountedOpenSslEngine engine);
 
     /**
      * Get the {@link OpenSslEngine} for the given {@code ssl} address.
      */
-    OpenSslEngine get(long ssl);
+    ReferenceCountedOpenSslEngine get(long ssl);
 }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslExtendedKeyMaterialManager.java
Patch:
@@ -28,12 +28,13 @@ final class OpenSslExtendedKeyMaterialManager extends OpenSslKeyMaterialManager
     }
 
     @Override
-    protected String chooseClientAlias(OpenSslEngine engine, String[] keyTypes, X500Principal[] issuer) {
+    protected String chooseClientAlias(ReferenceCountedOpenSslEngine engine, String[] keyTypes,
+                                       X500Principal[] issuer) {
         return keyManager.chooseEngineClientAlias(keyTypes, issuer, engine);
     }
 
     @Override
-    protected String chooseServerAlias(OpenSslEngine engine, String type) {
+    protected String chooseServerAlias(ReferenceCountedOpenSslEngine engine, String type) {
         return keyManager.chooseEngineServerAlias(type, null, engine);
     }
 }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerSessionContext.java
Patch:
@@ -23,7 +23,7 @@
  * {@link OpenSslSessionContext} implementation which offers extra methods which are only useful for the server-side.
  */
 public final class OpenSslServerSessionContext extends OpenSslSessionContext {
-    OpenSslServerSessionContext(OpenSslContext context) {
+    OpenSslServerSessionContext(ReferenceCountedOpenSslContext context) {
         super(context);
     }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java
Patch:
@@ -32,13 +32,13 @@ public abstract class OpenSslSessionContext implements SSLSessionContext {
     private static final Enumeration<byte[]> EMPTY = new EmptyEnumeration();
 
     private final OpenSslSessionStats stats;
-    final OpenSslContext context;
+    final ReferenceCountedOpenSslContext context;
 
     // IMPORTANT: We take the OpenSslContext and not just the long (which points the native instance) to prevent
     //            the GC to collect OpenSslContext as this would also free the pointer and so could result in a
     //            segfault when the user calls any of the methods here that try to pass the pointer down to the native
     //            level.
-    OpenSslSessionContext(OpenSslContext context) {
+    OpenSslSessionContext(ReferenceCountedOpenSslContext context) {
         this.context = context;
         stats = new OpenSslSessionStats(context);
     }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java
Patch:
@@ -25,13 +25,13 @@
  */
 public final class OpenSslSessionStats {
 
-    private final OpenSslContext context;
+    private final ReferenceCountedOpenSslContext context;
 
     // IMPORTANT: We take the OpenSslContext and not just the long (which points the native instance) to prevent
     //            the GC to collect OpenSslContext as this would also free the pointer and so could result in a
     //            segfault when the user calls any of the methods here that try to pass the pointer down to the native
     //            level.
-    OpenSslSessionStats(OpenSslContext context) {
+    OpenSslSessionStats(ReferenceCountedOpenSslContext context) {
         this.context = context;
     }
 

File: handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java
Patch:
@@ -385,6 +385,8 @@ public SslContextBuilder clientAuth(ClientAuth clientAuth) {
 
     /**
      * Create new {@code SslContext} instance with configured settings.
+     * <p>If {@link #sslProvider(SslProvider)} is set to {@link SslProvider#OPENSSL_REFCNT} then the caller is
+     * responsible for releasing this object, or else native memory may leak.
      */
     public SslContext build() throws SSLException {
         if (forServer) {

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -421,9 +421,8 @@ public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
             // Check if queue is not empty first because create a new ChannelException is expensive
             pendingUnencryptedWrites.removeAndFailAll(new ChannelException("Pending write on removal of SslHandler"));
         }
-        if (engine instanceof OpenSslEngine) {
-            // Call shutdown so we ensure all the native memory is released asap
-            ((OpenSslEngine) engine).shutdown();
+        if (engine instanceof ReferenceCountedOpenSslEngine) {
+            ((ReferenceCountedOpenSslEngine) engine).release();
         }
     }
 

File: common/src/test/java/io/netty/util/RecyclerTest.java
Patch:
@@ -94,7 +94,7 @@ private static void testMaxCapacity(int maxCapacity) {
 
     @Test
     public void testRecycleAtDifferentThread() throws Exception {
-        final Recycler<HandledObject> recycler = new Recycler<HandledObject>(256, 10, 2) {
+        final Recycler<HandledObject> recycler = new Recycler<HandledObject>(256, 10, 2, 10) {
             @Override
             protected HandledObject newObject(Recycler.Handle<HandledObject> handle) {
                 return new HandledObject(handle);

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -369,7 +369,7 @@ private abstract static class MemoryRegionCache<T> {
         private int allocations;
 
         MemoryRegionCache(int size, SizeClass sizeClass) {
-            this.size = MathUtil.findNextPositivePowerOfTwo(size);
+            this.size = MathUtil.safeFindNextPositivePowerOfTwo(size);
             queue = PlatformDependent.newFixedMpscQueue(this.size);
             this.sizeClass = sizeClass;
         }

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -307,7 +307,9 @@ public HostsFileEntriesResolver hostsFileEntriesResolver() {
      */
     @Override
     public void close() {
-        ch.close();
+        if (ch.isOpen()) {
+            ch.close();
+        }
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -141,7 +141,7 @@ protected ZlibWrapper determineWrapper(String acceptEncoding) {
             int equalsPos = encoding.indexOf('=');
             if (equalsPos != -1) {
                 try {
-                    q = Float.valueOf(encoding.substring(equalsPos + 1));
+                    q = Float.parseFloat(encoding.substring(equalsPos + 1));
                 } catch (NumberFormatException e) {
                     // Ignore encoding
                     q = 0.0f;

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -1165,7 +1165,7 @@ public ByteBuf copy() {
 
     @Override
     public ByteBuf duplicate() {
-        return new DuplicatedAbstractByteBuf(this);
+        return new UnpooledDuplicatedByteBuf(this);
     }
 
     @Override
@@ -1185,7 +1185,7 @@ public ByteBuf retainedSlice() {
 
     @Override
     public ByteBuf slice(int index, int length) {
-        return new SlicedAbstractByteBuf(this, index, length);
+        return new UnpooledSlicedByteBuf(this, index, length);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
Patch:
@@ -47,6 +47,8 @@ public DuplicatedByteBuf(ByteBuf buffer) {
 
         if (buffer instanceof DuplicatedByteBuf) {
             this.buffer = ((DuplicatedByteBuf) buffer).buffer;
+        } else if (buffer instanceof AbstractPooledDerivedByteBuf) {
+            this.buffer = buffer.unwrap();
         } else {
             this.buffer = buffer;
         }

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -138,7 +138,7 @@ public final ByteBuf unwrap() {
 
     @Override
     public final ByteBuf retainedDuplicate() {
-        return PooledDuplicatedByteBuf.newInstance(this, readerIndex(), writerIndex());
+        return PooledDuplicatedByteBuf.newInstance(this, this, readerIndex(), writerIndex());
     }
 
     @Override
@@ -149,7 +149,7 @@ public final ByteBuf retainedSlice() {
 
     @Override
     public final ByteBuf retainedSlice(int index, int length) {
-        return PooledSlicedByteBuf.newInstance(this, index, length, index);
+        return PooledSlicedByteBuf.newInstance(this, this, index, length);
     }
 
     protected final ByteBuffer internalNioBuffer() {

File: buffer/src/main/java/io/netty/buffer/UnpooledDuplicatedByteBuf.java
Patch:
@@ -19,8 +19,8 @@
  * {@link DuplicatedByteBuf} implementation that can do optimizations because it knows the duplicated buffer
  * is of type {@link AbstractByteBuf}.
  */
-final class DuplicatedAbstractByteBuf extends DuplicatedByteBuf {
-    DuplicatedAbstractByteBuf(AbstractByteBuf buffer) {
+final class UnpooledDuplicatedByteBuf extends DuplicatedByteBuf {
+    UnpooledDuplicatedByteBuf(AbstractByteBuf buffer) {
         super(buffer);
     }
 

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -457,7 +457,7 @@ public void testReadWithEmptyCompositeBuffer() {
     public void testComponentMustBeSlice() {
         CompositeByteBuf buf = releaseLater(compositeBuffer());
         buf.addComponent(buffer(4).setIndex(1, 3));
-        assertThat(buf.component(0), is(instanceOf(SlicedByteBuf.class)));
+        assertThat(buf.component(0), is(instanceOf(AbstractUnpooledSlicedByteBuf.class)));
         assertThat(buf.component(0).capacity(), is(2));
         assertThat(buf.component(0).maxCapacity(), is(2));
     }

File: buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java
Patch:
@@ -34,7 +34,7 @@ public void testSlice() throws Exception {
         ByteBuf buf = Unpooled.buffer(8).setIndex(1, 7);
         ByteBuf slice = buf.slice(1, 7);
 
-        assertThat(slice, instanceOf(SlicedByteBuf.class));
+        assertThat(slice, instanceOf(AbstractUnpooledSlicedByteBuf.class));
         assertThat(slice.unwrap(), sameInstance(buf));
         assertThat(slice.readerIndex(), is(0));
         assertThat(slice.writerIndex(), is(7));
@@ -53,7 +53,7 @@ public void testSliceOfSlice() throws Exception {
         ByteBuf slice2 = slice.slice(0, 6);
 
         assertThat(slice2, not(sameInstance(slice)));
-        assertThat(slice2, instanceOf(SlicedByteBuf.class));
+        assertThat(slice2, instanceOf(AbstractUnpooledSlicedByteBuf.class));
         assertThat(slice2.unwrap(), sameInstance(buf));
         assertThat(slice2.writerIndex(), is(6));
         assertThat(slice2.capacity(), is(6));

File: microbench/src/test/java/io/netty/microbench/buffer/SlicedByteBufBenchmark.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufUtil;
-import io.netty.buffer.SlicedByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import org.openjdk.jmh.annotations.Benchmark;
@@ -42,7 +41,7 @@ public class SlicedByteBufBenchmark extends AbstractMicrobenchmark {
     public void setup() {
         // Use buffer sizes that will also allow to write UTF-8 without grow the buffer
         ByteBuf buffer = Unpooled.buffer(512).retain();
-        slicedByteBuf = new SlicedByteBuf(buffer, 0, 256);
+        slicedByteBuf = buffer.slice(0, 256);
         slicedAbstractByteBuf = buffer.slice(0, 256);
 
         if (slicedByteBuf.getClass() == slicedAbstractByteBuf.getClass()) {

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -49,8 +49,7 @@ public void recycle(Object object) {
     };
     private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);
     private static final int OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();
-    // TODO: Some arbitrary large number - should adjust as we get more production experience.
-    private static final int DEFAULT_INITIAL_MAX_CAPACITY = 262144;
+    private static final int DEFAULT_INITIAL_MAX_CAPACITY = 32768; // Use 32k instances as default max capacity.
 
     private static final int DEFAULT_MAX_CAPACITY;
     private static final int INITIAL_CAPACITY;

File: common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
Patch:
@@ -61,7 +61,6 @@ public void testAutomaticStartStop() throws Exception {
         // Ensure the thread stopped itself after running the task.
         assertThat(thread.isAlive(), is(false));
         assertThat(task.ran.get(), is(true));
-        assertThat(e.thread, sameInstance(thread));
 
         // Ensure another new thread starts again.
         task.ran.set(false);
@@ -74,7 +73,6 @@ public void testAutomaticStartStop() throws Exception {
         // Ensure the thread stopped itself after running the task.
         assertThat(thread.isAlive(), is(false));
         assertThat(task.ran.get(), is(true));
-        assertThat(e.thread, sameInstance(thread));
     }
 
     @Test
@@ -93,7 +91,6 @@ public void testScheduledTasks() throws Exception {
 
         // Now it should be stopped.
         assertThat(thread.isAlive(), is(false));
-        assertThat(e.thread, sameInstance(thread));
     }
 
     // ensure that when a task submission causes a new thread to be created, the thread inherits the thread group of the

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -191,7 +191,7 @@ public DnsNameResolver(
         this.hostsFileEntriesResolver = checkNotNull(hostsFileEntriesResolver, "hostsFileEntriesResolver");
         this.resolveCache = resolveCache;
         this.searchDomains = checkNotNull(searchDomains, "searchDomains").clone();
-        this.ndots = checkPositive(ndots, "ndots");
+        this.ndots = checkPositiveOrZero(ndots, "ndots");
 
         Bootstrap b = new Bootstrap();
         b.group(executor());

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -321,6 +321,7 @@ public DnsNameResolverBuilder searchDomains(Iterable<String> searchDomains) {
 
   /**
    * Set the number of dots which must appear in a name before an initial absolute query is made.
+   * The default value is {@code 1}.
    *
    * @param ndots the ndots value
    * @return {@code this}

File: transport/src/main/java/io/netty/channel/DefaultChannelId.java
Patch:
@@ -17,8 +17,8 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufUtil;
-import io.netty.util.internal.MacAddressUtil;
 import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.MacAddressUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.ThreadLocalRandom;
@@ -136,7 +136,7 @@ private static byte[] defaultMachineId() {
     }
 
     private static int defaultProcessId() {
-        final ClassLoader loader = PlatformDependent.getSystemClassLoader();
+        final ClassLoader loader = PlatformDependent.getClassLoader(DefaultChannelId.class);
         String value;
         try {
             // Invoke java.lang.management.ManagementFactory.getRuntimeMXBean().getName()
@@ -145,7 +145,7 @@ private static int defaultProcessId() {
 
             Method getRuntimeMXBean = mgmtFactoryType.getMethod("getRuntimeMXBean", EmptyArrays.EMPTY_CLASSES);
             Object bean = getRuntimeMXBean.invoke(null, EmptyArrays.EMPTY_OBJECTS);
-            Method getName = runtimeMxBeanType.getDeclaredMethod("getName", EmptyArrays.EMPTY_CLASSES);
+            Method getName = runtimeMxBeanType.getMethod("getName", EmptyArrays.EMPTY_CLASSES);
             value = (String) getName.invoke(bean, EmptyArrays.EMPTY_OBJECTS);
         } catch (Exception e) {
             logger.debug("Could not invoke ManagementFactory.getRuntimeMXBean().getName(); Android?", e);

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -134,7 +134,7 @@ public final class NetUtil {
         // Create IPv4 loopback address.
         Inet4Address localhost4 = null;
         try {
-            localhost4 = (Inet4Address) InetAddress.getByAddress(LOCALHOST4_BYTES);
+            localhost4 = (Inet4Address) InetAddress.getByAddress("localhost", LOCALHOST4_BYTES);
         } catch (Exception e) {
             // We should not get here as long as the length of the address is correct.
             PlatformDependent.throwException(e);
@@ -144,7 +144,7 @@ public final class NetUtil {
         // Create IPv6 loopback address.
         Inet6Address localhost6 = null;
         try {
-            localhost6 = (Inet6Address) InetAddress.getByAddress(LOCALHOST6_BYTES);
+            localhost6 = (Inet6Address) InetAddress.getByAddress("localhost", LOCALHOST6_BYTES);
         } catch (Exception e) {
             // We should not get here as long as the length of the address is correct.
             PlatformDependent.throwException(e);

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -166,7 +166,8 @@ public class DnsNameResolverTest {
             "cnet.com",
             "vimeo.com",
             "redtube.com",
-            "blogspot.in")));
+            "blogspot.in",
+            "localhost")));
 
     /**
      * The list of the domain names to exclude from {@link #testResolveAorAAAA()}.
@@ -232,6 +233,7 @@ public class DnsNameResolverTest {
                 "people.com.cn",
                 "googleusercontent.com",
                 "blogspot.in",
+                "localhost",
                 StringUtil.EMPTY_STRING);
     }
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -154,6 +154,8 @@ final class PlatformDependent0 {
 
         logger.debug("java.nio.DirectByteBuffer.<init>(long, int): {}",
                 DIRECT_BUFFER_CONSTRUCTOR != null? "available" : "unavailable");
+
+        freeDirectBuffer(direct);
     }
 
     static boolean isUnaligned() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java
Patch:
@@ -142,6 +142,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
             if (msg instanceof Http2WindowUpdateFrame) {
                 Http2WindowUpdateFrame frame = (Http2WindowUpdateFrame) msg;
                 consumeBytes(frame.streamId(), frame.windowSizeIncrement());
+                promise.setSuccess();
             } else if (msg instanceof Http2StreamFrame) {
                 writeStreamFrame((Http2StreamFrame) msg, promise);
             } else if (msg instanceof Http2GoAwayFrame) {

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -599,6 +599,9 @@ private boolean await0(long timeoutNanos, boolean interruptable) throws Interrup
         try {
             for (;;) {
                 synchronized (this) {
+                    if (isDone()) {
+                        return true;
+                    }
                     incWaiters();
                     try {
                         wait(waitTime / 1000000, (int) (waitTime % 1000000));

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -128,6 +128,9 @@ public static <T> ChannelOption<T> newInstance(String name) {
     public static final ChannelOption<Boolean> DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION =
             valueOf("DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION");
 
+    public static final ChannelOption<Boolean> SINGLE_EVENTEXECUTOR_PER_GROUP =
+            valueOf("SINGLE_EVENTEXECUTOR_PER_GROUP");
+
     /**
      * Creates a new {@link ChannelOption} with the specified unique {@code name}.
      */

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -927,8 +927,8 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
             pipeline1.fireUserEventTriggered("");
             latch.await();
         } finally {
-            defaultGroup.shutdownGracefully().syncUninterruptibly();
-            eventExecutors.shutdownGracefully().syncUninterruptibly();
+            defaultGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS).syncUninterruptibly();
+            eventExecutors.shutdownGracefully(0, 0, TimeUnit.SECONDS).syncUninterruptibly();
         }
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 import org.junit.After;
 import org.junit.Before;
@@ -124,7 +125,7 @@ public class Http2ConnectionHandlerTest {
     public void setup() throws Exception {
         MockitoAnnotations.initMocks(this);
 
-        promise = new DefaultChannelPromise(channel);
+        promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
 
         Throwable fakeException = new RuntimeException("Fake exception");
         when(encoder.connection()).thenReturn(connection);

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -38,10 +38,10 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 /**
- * Abstract base class for {@link EventExecutor}'s that execute all its submitted tasks in a single thread.
+ * Abstract base class for {@link OrderedEventExecutor}'s that execute all its submitted tasks in a single thread.
  *
  */
-public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor {
+public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
 
     static final int DEFAULT_MAX_PENDING_EXECUTOR_TASKS = Math.max(16,
             SystemPropertyUtil.getInt("io.netty.eventexecutor.maxPendingTasks", Integer.MAX_VALUE));

File: transport/src/main/java/io/netty/channel/EventLoop.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.OrderedEventExecutor;
 
 /**
  * Will handle all the I/O operations for a {@link Channel} once registered.
@@ -24,7 +24,7 @@
  * implementation details and internals.
  *
  */
-public interface EventLoop extends EventExecutor, EventLoopGroup {
+public interface EventLoop extends OrderedEventExecutor, EventLoopGroup {
     @Override
     EventLoopGroup parent();
 }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -27,7 +27,6 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.GenericFutureListener;
-import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 import org.junit.After;
 import org.junit.Before;
@@ -125,7 +124,7 @@ public class Http2ConnectionHandlerTest {
     public void setup() throws Exception {
         MockitoAnnotations.initMocks(this);
 
-        promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
+        promise = new DefaultChannelPromise(channel);
 
         Throwable fakeException = new RuntimeException("Fake exception");
         when(encoder.connection()).thenReturn(connection);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 import org.junit.After;
 import org.junit.Before;
@@ -124,7 +125,7 @@ public class Http2ConnectionHandlerTest {
     public void setup() throws Exception {
         MockitoAnnotations.initMocks(this);
 
-        promise = new DefaultChannelPromise(channel);
+        promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
 
         Throwable fakeException = new RuntimeException("Fake exception");
         when(encoder.connection()).thenReturn(connection);

File: transport-native-epoll/src/main/java/io/netty/channel/unix/ErrorsStaticallyReferencedJniMethods.java
Patch:
@@ -37,5 +37,6 @@ private ErrorsStaticallyReferencedJniMethods() { }
     static native int errnoEAGAIN();
     static native int errnoEWOULDBLOCK();
     static native int errnoEINPROGRESS();
+    static native int errorECONNREFUSED();
     static native String strError(int err);
 }

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -520,7 +520,7 @@ private static void notifyListener0(Future future, GenericFutureListener l) {
         try {
             l.operationComplete(future);
         } catch (Throwable t) {
-            logger.warn("An exception was thrown by {}.operationComplete()", l.getClass().getName(), t);
+            logger.warn("An exception was thrown by " + l.getClass().getName() + ".operationComplete()", t);
         }
     }
 
@@ -747,7 +747,7 @@ private static void notifyProgressiveListener0(
         try {
             l.operationProgressed(future, progress, total);
         } catch (Throwable t) {
-            logger.warn("An exception was thrown by {}.operationProgressed()", l.getClass().getName(), t);
+            logger.warn("An exception was thrown by " + l.getClass().getName() + ".operationProgressed()", t);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1088,7 +1088,7 @@ public static void set100ContinueExpected(HttpMessage message) {
      * @deprecated Use {@link HttpUtil#set100ContinueExpected(HttpMessage, boolean)} instead.
      *
      * Sets or removes the {@code "Expect: 100-continue"} header to / from the
-     * specified message.  If the specified {@code value} is {@code true},
+     * specified message.  If {@code set} is {@code true},
      * the {@code "Expect: 100-continue"} header is set and all other previous
      * {@code "Expect"} headers are removed.  Otherwise, all {@code "Expect"}
      * headers are removed completely.

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java
Patch:
@@ -276,7 +276,7 @@ public static boolean is100ContinueExpected(HttpMessage message) {
 
     /**
      * Sets or removes the {@code "Expect: 100-continue"} header to / from the
-     * specified message. If the specified {@code value} is {@code true},
+     * specified message. If {@code expected} is {@code true},
      * the {@code "Expect: 100-continue"} header is set and all other previous
      * {@code "Expect"} headers are removed.  Otherwise, all {@code "Expect"}
      * headers are removed completely.

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -60,7 +60,7 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
      *
      * Threading - synchronized(this). We must support adding listeners when there is no EventExecutor.
      */
-    private Object listeners;
+    private volatile Object listeners;
     /**
      * Threading - synchronized(this). We are required to hold the monitor to use Java's underlying wait()/notifyAll().
      */
@@ -417,7 +417,6 @@ protected static void notifyListener(
     }
 
     private void notifyListeners() {
-        // Modifications to listeners should be done in a synchronized block before this, and should be visible here.
         if (listeners == null) {
             return;
         }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java
Patch:
@@ -161,7 +161,7 @@ private Encoder createEncoder() {
             maxHeaderTableSize = Integer.MAX_VALUE;
         }
 
-        return new Encoder(maxHeaderTableSize, useIndexing, forceHuffmanOn, forceHuffmanOff);
+        return new Encoder(maxHeaderTableSize, useIndexing, forceHuffmanOn, forceHuffmanOff, 16);
     }
 
     private Decoder createDecoder() {

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -1394,7 +1394,7 @@ public static int hashCode(CharSequence value) {
             return 0;
         }
         if (value.getClass() == AsciiString.class) {
-            return ((AsciiString) value).hashCode();
+            return value.hashCode();
         }
 
         return PlatformDependent.hashCodeAscii(value);

File: codec/src/main/java/io/netty/handler/codec/HeadersUtils.java
Patch:
@@ -211,7 +211,7 @@ public Iterator<String> iterator() {
 
         @Override
         public Object[] toArray() {
-            Object[] arr = new String[size()];
+            Object[] arr = new Object[size()];
             fillArray(arr);
             return arr;
         }

File: common/src/test/java/io/netty/util/internal/PlatformDependentTest.java
Patch:
@@ -124,9 +124,6 @@ public void testHashCodeAscii() {
             assertEquals("length=" + i,
                          hashCodeAsciiSafe(bytes, 0, bytes.length),
                          hashCodeAscii(bytes, 0, bytes.length));
-            assertEquals("length=" + i,
-                    hashCodeAsciiSafe(string),
-                    hashCodeAscii(string));
             assertEquals("length=" + i,
                     hashCodeAscii(bytes, 0, bytes.length),
                     hashCodeAscii(string));

File: microbench/src/main/java/io/netty/microbenchmark/common/AsciiStringBenchmark.java
Patch:
@@ -34,7 +34,7 @@
 @Warmup(iterations = 5)
 public class AsciiStringBenchmark extends AbstractMicrobenchmark {
 
-    @Param({ "3", "5", "7", "8", "10", "20", "50" })
+    @Param({ "3", "5", "7", "8", "10", "20", "50", "100", "1000" })
     public int size;
 
     private AsciiString asciiString;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.util.internal.InternalThreadLocalMap;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.ThrowableUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -34,7 +35,8 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultPromise.class);
     private static final InternalLogger rejectedExecutionLogger =
             InternalLoggerFactory.getInstance(DefaultPromise.class.getName() + ".rejectedExecution");
-    private static final int MAX_LISTENER_STACK_DEPTH = 8;
+    private static final int MAX_LISTENER_STACK_DEPTH = Math.min(8,
+            SystemPropertyUtil.getInt("io.netty.defaultPromise.maxListenerStackDepth", 8));
     @SuppressWarnings("rawtypes")
     private static final AtomicReferenceFieldUpdater<DefaultPromise, Object> RESULT_UPDATER;
     private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, "SUCCESS");

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
Patch:
@@ -24,8 +24,6 @@
  */
 @UnstableApi
 public interface Http2DataFrame extends Http2StreamFrame, ByteBufHolder {
-    @Override
-    Http2DataFrame setStream(Object stream);
 
     /**
      * {@code true} if this frame is the last one in this direction of the stream.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
Patch:
@@ -22,8 +22,6 @@
  */
 @UnstableApi
 public interface Http2HeadersFrame extends Http2StreamFrame {
-    @Override
-    Http2HeadersFrame setStream(Object stream);
 
     /**
      * A complete header list. CONTINUATION frames are automatically handled.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ResetFrame.java
Patch:
@@ -20,8 +20,6 @@
 /** HTTP/2 RST_STREAM frame. */
 @UnstableApi
 public interface Http2ResetFrame extends Http2StreamFrame {
-    @Override
-    Http2ResetFrame setStream(Object stream);
 
     /**
      * The reason for resetting the stream. Represented as an HTTP/2 error code.

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2OrHttpHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.example.http2.helloworld.server.HelloWorldHttp1Handler;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpServerCodec;
-import io.netty.handler.codec.http2.Http2MultiplexCodec;
+import io.netty.handler.codec.http2.Http2Codec;
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;
 
@@ -37,7 +37,7 @@ protected Http2OrHttpHandler() {
     @Override
     protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {
         if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {
-            ctx.pipeline().addLast(new Http2MultiplexCodec(true, new HelloWorldHttp2Handler()));
+            ctx.pipeline().addLast(new Http2Codec(true, new HelloWorldHttp2Handler()));
             return;
         }
 

File: example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/Http2ServerInitializer.java
Patch:
@@ -29,8 +29,8 @@
 import io.netty.handler.codec.http.HttpServerUpgradeHandler;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodec;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeCodecFactory;
+import io.netty.handler.codec.http2.Http2Codec;
 import io.netty.handler.codec.http2.Http2CodecUtil;
-import io.netty.handler.codec.http2.Http2MultiplexCodec;
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.AsciiString;
@@ -45,8 +45,7 @@ public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
         @Override
         public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
             if (AsciiString.contentEquals(Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME, protocol)) {
-                return new Http2ServerUpgradeCodec(new Http2MultiplexCodec(true,
-                      new HelloWorldHttp2Handler()));
+                return new Http2ServerUpgradeCodec(new Http2Codec(true, new HelloWorldHttp2Handler()));
             } else {
                 return null;
             }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderField.java
Patch:
@@ -31,6 +31,7 @@
  */
 package io.netty.handler.codec.http2.internal.hpack;
 
+import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.equalsConstantTime;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 class HeaderField {
@@ -72,9 +73,8 @@ public boolean equals(Object obj) {
             return false;
         }
         HeaderField other = (HeaderField) obj;
-        boolean nameEquals = HpackUtil.equals(name, other.name);
-        boolean valueEquals = HpackUtil.equals(value, other.value);
-        return nameEquals && valueEquals;
+        // To avoid short circuit behavior a bitwise operator is used instead of a boolean operator.
+        return (equalsConstantTime(name, other.name) & equalsConstantTime(value, other.value)) != 0;
     }
 
     @Override

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
Patch:
@@ -337,7 +337,7 @@ private boolean doResolveCached(String hostname,
                                     Promise<InetAddress> promise,
                                     DnsCache resolveCache) {
         final List<DnsCacheEntry> cachedEntries = resolveCache.get(hostname);
-        if (cachedEntries == null) {
+        if (cachedEntries == null || cachedEntries.isEmpty()) {
             return false;
         }
 
@@ -443,7 +443,7 @@ private boolean doResolveAllCached(String hostname,
                                        Promise<List<InetAddress>> promise,
                                        DnsCache resolveCache) {
         final List<DnsCacheEntry> cachedEntries = resolveCache.get(hostname);
-        if (cachedEntries == null) {
+        if (cachedEntries == null || cachedEntries.isEmpty()) {
             return false;
         }
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -26,6 +26,7 @@
 import org.jctools.queues.atomic.MpscAtomicArrayQueue;
 import org.jctools.queues.atomic.MpscLinkedAtomicQueue;
 import org.jctools.queues.atomic.SpscLinkedAtomicQueue;
+import org.jctools.util.Pow2;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -87,12 +88,11 @@ public final class PlatformDependent {
     private static final boolean DIRECT_BUFFER_PREFERRED =
             HAS_UNSAFE && !SystemPropertyUtil.getBoolean("io.netty.noPreferDirect", false);
     private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();
+
     private static final int MPSC_CHUNK_SIZE =  1024;
     private static final int MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2;
     private static final int DEFAULT_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * MPSC_CHUNK_SIZE;
-    // This is currently the maximal allowed capacity in JCTools.
-    // See https://github.com/JCTools/JCTools/issues/115
-    private static final int MAX_ALLOWED_MPSC_CAPACITY =  Integer.MAX_VALUE >> 2;
+    private static final int MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2;
 
     private static final long BYTE_ARRAY_BASE_OFFSET = PlatformDependent0.byteArrayBaseOffset();
 

File: microbench/src/main/java/io/netty/microbenchmark/common/IntObjectHashMapBenchmark.java
Patch:
@@ -16,14 +16,14 @@
 
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import io.netty.util.collection.IntObjectHashMap;
+import org.agrona.collections.Int2ObjectHashMap;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Level;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.Param;
 import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.infra.Blackhole;
-import uk.co.real_logic.agrona.collections.Int2ObjectHashMap;
 
 import java.util.HashSet;
 import java.util.Random;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java
Patch:
@@ -42,7 +42,8 @@ public interface Http2LocalFlowController extends Http2FlowController {
      * stream} is {@code null} or closed, flow control should only be applied to the connection window and the bytes are
      * immediately consumed.
      * @param data payload buffer for the frame.
-     * @param padding the number of padding bytes found at the end of the frame.
+     * @param padding additional bytes that should be added to obscure the true content size. Must be between 0 and
+     *                256 (inclusive).
      * @param endOfStream Indicates whether this is the last frame to be sent from the remote endpoint for this stream.
      * @throws Http2Exception if any flow control errors are encountered.
      */

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
Patch:
@@ -134,7 +134,7 @@ protected void wakeup(boolean inEventLoop) {
     }
 
     /**
-     * Register the given epoll with this {@link io.netty.channel.EventLoop}.
+     * Register the given epoll with this {@link EventLoop}.
      */
     void add(AbstractEpollChannel ch) throws IOException {
         assert inEventLoop();
@@ -168,9 +168,9 @@ void remove(AbstractEpollChannel ch) throws IOException {
     }
 
     @Override
-    protected Queue<Runnable> newTaskQueue() {
+    protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
         // This event loop never calls takeTask()
-        return PlatformDependent.newMpscQueue();
+        return PlatformDependent.newMpscQueue(maxPendingTasks);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -192,9 +192,9 @@ public SelectorProvider selectorProvider() {
     }
 
     @Override
-    protected Queue<Runnable> newTaskQueue() {
+    protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
         // This event loop never calls takeTask()
-        return PlatformDependent.newMpscQueue();
+        return PlatformDependent.newMpscQueue(maxPendingTasks);
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/package-info.java
Patch:
@@ -31,6 +31,8 @@
  */
 
 /**
- * <a href="http://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>
+ * <a href="http://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>.
+ * Please note this implementation is only compliant when used with HTTP/2 and so not meant to be used outside of
+ * this scope.
  */
 package io.netty.handler.codec.http2.internal.hpack;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.util.concurrent;
 
 import io.netty.util.Signal;
-import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.InternalThreadLocalMap;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.ThrowableUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -39,15 +39,15 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
     private static final AtomicReferenceFieldUpdater<DefaultPromise, Object> RESULT_UPDATER;
     private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, "SUCCESS");
     private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, "UNCANCELLABLE");
-    private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(new CancellationException());
+    private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(ThrowableUtil.unknownStackTrace(
+            new CancellationException(), DefaultPromise.class, "cancel(...)"));
 
     static {
         @SuppressWarnings("rawtypes")
         AtomicReferenceFieldUpdater<DefaultPromise, Object> updater =
                 PlatformDependent.newAtomicReferenceFieldUpdater(DefaultPromise.class, "result");
         RESULT_UPDATER = updater == null ? AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class,
                                                                                   Object.class, "result") : updater;
-        CANCELLATION_CAUSE_HOLDER.cause.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
     }
 
     private volatile Object result;

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.util.CharsetUtil;
 import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.ResourceLeakDetector;
+import io.netty.util.ResourceLeakDetectorFactory;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.SystemPropertyUtil;
@@ -52,7 +53,8 @@ public abstract class AbstractByteBuf extends ByteBuf {
         }
     }
 
-    static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);
+    static final ResourceLeakDetector<ByteBuf> leakDetector =
+            ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);
 
     int readerIndex;
     int writerIndex;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.util.ReferenceCounted;
 import io.netty.util.ResourceLeak;
 import io.netty.util.ResourceLeakDetector;
+import io.netty.util.ResourceLeakDetectorFactory;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.UnstableApi;
 
@@ -35,7 +36,7 @@
 public abstract class AbstractDnsMessage extends AbstractReferenceCounted implements DnsMessage {
 
     private static final ResourceLeakDetector<DnsMessage> leakDetector =
-            new ResourceLeakDetector<DnsMessage>(DnsMessage.class);
+            ResourceLeakDetectorFactory.instance().newResourceLeakDetector(DnsMessage.class);
 
     private static final int SECTION_QUESTION = DnsSection.QUESTION.ordinal();
     private static final int SECTION_COUNT = 4;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -99,6 +99,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
             // If buffering is not an issue, add HttpObjectAggregator down the chain, it will set the header.
             // Otherwise, rely on LastHttpContent message.
             headers.remove(HttpHeaderNames.CONTENT_LENGTH);
+            headers.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
 
             // set new content encoding,
             CharSequence targetContentEncoding = getTargetContentEncoding(contentEncoding);

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -264,7 +264,7 @@ public OpenSslClientContext(File trustCertCollectionFile, TrustManagerFactory tr
                     throw new SSLException("unable to setup trustmanager", e);
                 }
             }
-            sessionContext = new OpenSslClientSessionContext(ctx);
+            sessionContext = new OpenSslClientSessionContext(this);
             success = true;
         } finally {
             if (!success) {
@@ -280,7 +280,7 @@ public OpenSslSessionContext sessionContext() {
 
     // No cache is currently supported for client side mode.
     private static final class OpenSslClientSessionContext extends OpenSslSessionContext {
-        private OpenSslClientSessionContext(long context) {
+        private OpenSslClientSessionContext(OpenSslContext context) {
             super(context);
         }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
Patch:
@@ -433,7 +433,7 @@ private OpenSslServerContext(
                     throw new SSLException("unable to setup trustmanager", e);
                 }
             }
-            sessionContext = new OpenSslServerSessionContext(ctx);
+            sessionContext = new OpenSslServerSessionContext(this);
             sessionContext.setSessionIdContext(ID);
             success = true;
         } finally {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java
Patch:
@@ -100,6 +100,9 @@ public HttpContent readChunk(ByteBufAllocator allocator) throws Exception {
             }
         } else {
             ByteBuf buf = input.readChunk(allocator);
+            if (buf == null) {
+                return null;
+            }
             return new DefaultHttpContent(buf);
         }
     }

File: common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java
Patch:
@@ -34,7 +34,7 @@ public class DefaultThreadFactory implements ThreadFactory {
     private final String prefix;
     private final boolean daemon;
     private final int priority;
-    private final ThreadGroup threadGroup;
+    protected final ThreadGroup threadGroup;
 
     public DefaultThreadFactory(Class<?> poolType) {
         this(poolType, false, Thread.NORM_PRIORITY);

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -689,7 +689,7 @@ private static void safeFail(ChannelPromise promise, Throwable cause) {
                 logger.warn("Failed to mark a promise as failure because it has succeeded already: {}", promise, cause);
             } else {
                 logger.warn(
-                        "Failed to mark a promise as failure because it hass failed already: {}, unnotified cause {}",
+                        "Failed to mark a promise as failure because it has failed already: {}, unnotified cause {}",
                         promise, ThrowableUtils.stackTraceToString(err), cause);
             }
         }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java
Patch:
@@ -547,7 +547,7 @@ private static long toBIO(ByteBufAllocator allocator, PemEncoded pem) throws Exc
 
             ByteBuf buffer = allocator.directBuffer(content.readableBytes());
             try {
-                buffer.writeBytes(content);
+                buffer.writeBytes(content, content.readerIndex(), content.readableBytes());
                 return newBIO(buffer.retainedSlice());
             } finally {
                 try {

File: common/src/main/java/io/netty/util/concurrent/Future.java
Patch:
@@ -63,7 +63,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
     Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     /**
-     * Removes the specified listener from this future.
+     * Removes the first occurrence of the specified listener from this future.
      * The specified listener is no longer notified when this
      * future is {@linkplain #isDone() done}.  If the specified
      * listener is not associated with this future, this method
@@ -72,7 +72,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
     Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     /**
-     * Removes the specified listeners from this future.
+     * Removes the first occurrence for each of the listeners from this future.
      * The specified listeners are no longer notified when this
      * future is {@linkplain #isDone() done}.  If the specified
      * listeners are not associated with this future, this method

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -48,7 +48,7 @@ public final class DnsNameResolverBuilder {
     private long queryTimeoutMillis = 5000;
     private InternetProtocolFamily[] resolvedAddressTypes = DnsNameResolver.DEFAULT_RESOLVE_ADDRESS_TYPES;
     private boolean recursionDesired = true;
-    private int maxQueriesPerResolve = 3;
+    private int maxQueriesPerResolve = 16;
     private boolean traceEnabled;
     private int maxPayloadSize = 4096;
     private boolean optResourceEnabled = true;

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -858,8 +858,8 @@ private void destroyDown(Thread currentThread, AbstractChannelHandlerContext ctx
             if (inEventLoop || executor.inEventLoop(currentThread)) {
                 synchronized (this) {
                     remove0(ctx);
-                    callHandlerRemoved0(ctx);
                 }
+                callHandlerRemoved0(ctx);
             } else {
                 final AbstractChannelHandlerContext finalCtx = ctx;
                 executor.execute(new OneTimeTask() {

File: codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java
Patch:
@@ -899,8 +899,8 @@ public String toString() {
             for (int i = 0; i < values.size(); ++i) {
                 builder.append(separator);
                 builder.append(name).append(": ").append(values.get(i));
+                separator = ", ";
             }
-            separator = ", ";
         }
         return builder.append(']').toString();
     }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketRstTest.java
Patch:
@@ -35,7 +35,8 @@
 public class SocketRstTest extends AbstractSocketTest {
     protected void assertRstOnCloseException(IOException cause, Channel clientChannel) {
         if (Locale.getDefault() == Locale.US || Locale.getDefault() == Locale.UK) {
-            assertTrue("actual message: " + cause.getMessage(), cause.getMessage().contains("reset"));
+            assertTrue("actual message: " + cause.getMessage(),
+                       cause.getMessage().contains("reset") || cause.getMessage().contains("closed"));
         }
     }
 

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -340,6 +340,7 @@ DefaultHandle<T> pop() {
             }
             size --;
             DefaultHandle ret = elements[size];
+            elements[size] = null;
             if (ret.lastRecycledId != ret.recycleId) {
                 throw new IllegalStateException("recycled multiple times");
             }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
Patch:
@@ -36,6 +36,7 @@
  * A server-side {@link SslContext} which uses OpenSSL's SSL/TLS implementation.
  */
 public final class OpenSslServerContext extends OpenSslContext {
+    private static final byte[] ID = new byte[] {'n', 'e', 't', 't', 'y'};
     private final OpenSslServerSessionContext sessionContext;
 
     /**
@@ -439,6 +440,7 @@ void verify(OpenSslEngine engine, X509Certificate[] peerCerts, String auth)
                 }
             }
             sessionContext = new OpenSslServerSessionContext(ctx);
+            sessionContext.setSessionIdContext(ID);
             success = true;
         } finally {
             if (!success) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -641,7 +641,7 @@ public boolean visit(Http2Stream stream) throws Http2Exception {
                 }
             });
 
-            if (delta > 0) {
+            if (delta > 0 && isChannelWritable()) {
                 // The window size increased, send any pending frames for all streams.
                 writePendingBytes();
             }

File: transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
Patch:
@@ -1011,7 +1011,7 @@ protected static void init(AbstractWriteTask task, AbstractChannelHandlerContext
 
                 // Check for null as it may be set to null if the channel is closed already
                 if (buffer != null) {
-                    task.size = ((AbstractChannel) ctx.channel()).estimatorHandle().size(msg) + WRITE_TASK_OVERHEAD;
+                    task.size = ctx.pipeline.estimatorHandle().size(msg) + WRITE_TASK_OVERHEAD;
                     buffer.incrementPendingOutboundBytes(task.size);
                 } else {
                     task.size = 0;

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ReferenceCounted;
-import io.netty.util.internal.RecyclableArrayList;
 import io.netty.util.internal.TypeParameterMatcher;
 
 import java.util.List;
@@ -80,7 +79,7 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
 
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        RecyclableArrayList out = RecyclableArrayList.newInstance();
+        CodecOutputList out = CodecOutputList.newInstance();
         try {
             if (acceptInboundMessage(msg)) {
                 @SuppressWarnings("unchecked")
@@ -100,7 +99,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         } finally {
             int size = out.size();
             for (int i = 0; i < size; i ++) {
-                ctx.fireChannelRead(out.get(i));
+                ctx.fireChannelRead(out.getUnsafe(i));
             }
             out.recycle();
         }

File: common/src/main/java/io/netty/util/DomainNameMapping.java
Patch:
@@ -68,7 +68,8 @@ public DomainNameMapping(int initialCapacity, V defaultValue) {
     DomainNameMapping(Map<String, V> map, V defaultValue) {
         this.defaultValue = checkNotNull(defaultValue, "defaultValue");
         this.map = map;
-        unmodifiableMap = Collections.unmodifiableMap(map);
+        unmodifiableMap = map != null ? Collections.unmodifiableMap(map)
+                                      : null;
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
Patch:
@@ -53,6 +53,9 @@ public boolean process(byte value) throws Exception {
     static final NameValidator<CharSequence> HttpNameValidator = new NameValidator<CharSequence>() {
         @Override
         public void validateName(CharSequence name) {
+            if (name == null || name.length() == 0) {
+                throw new IllegalArgumentException("empty headers are not allowed [" + name + "]");
+            }
             if (name instanceof AsciiString) {
                 try {
                     ((AsciiString) name).forEachByte(HEADER_NAME_VALIDATOR);

File: transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
Patch:
@@ -220,7 +220,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
     }
 
-    @Test(expected = ChannelException.class, timeout = 10000)
+    @Test(expected = ConnectException.class, timeout = 10000)
     public void testLateRegistrationConnect() throws Exception {
         EventLoopGroup group = new DelayedEventLoopGroup();
         try {

File: transport/src/test/java/io/netty/channel/pool/AbstractChannelPoolMapTest.java
Patch:
@@ -25,12 +25,14 @@
 import io.netty.channel.local.LocalEventLoopGroup;
 import org.junit.Test;
 
+import java.net.ConnectException;
+
 import static org.junit.Assert.*;
 
 public class AbstractChannelPoolMapTest {
     private static final String LOCAL_ADDR_ID = "test.id";
 
-    @Test(expected = ChannelException.class)
+    @Test(expected = ConnectException.class)
     public void testMap() throws Exception {
         EventLoopGroup group = new LocalEventLoopGroup();
         LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
Patch:
@@ -106,7 +106,7 @@ public EpollEventLoopGroup(int nThreads, Executor executor, SelectStrategyFactor
      * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
      */
     public void setIoRatio(int ioRatio) {
-        for (EventExecutor e: children()) {
+        for (EventExecutor e: this) {
             ((EpollEventLoop) e).setIoRatio(ioRatio);
         }
     }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
Patch:
@@ -89,7 +89,7 @@ public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider
      * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
      */
     public void setIoRatio(int ioRatio) {
-        for (EventExecutor e: children()) {
+        for (EventExecutor e: this) {
             ((NioEventLoop) e).setIoRatio(ioRatio);
         }
     }
@@ -99,7 +99,7 @@ public void setIoRatio(int ioRatio) {
      * around the  infamous epoll 100% CPU bug.
      */
     public void rebuildSelectors() {
-        for (EventExecutor e: children()) {
+        for (EventExecutor e: this) {
             ((NioEventLoop) e).rebuildSelector();
         }
     }

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1286,7 +1286,7 @@ private EventExecutor executorSafe(ChannelHandlerInvoker invoker) {
             // We check for channel().isRegistered and handlerAdded because even if isRegistered() is false we
             // can safely access the invoker() if handlerAdded is true. This is because in this case the Channel
             // was previously registered and so we can still access the old EventLoop to dispatch things.
-            return channel.isRegistered() || registered ? channel.unsafe().invoker().executor() : null;
+            return channel.isRegistered() || registered ? channel.eventLoop() : null;
         }
         return invoker.executor();
     }

File: resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.resolver;
 
 import java.net.InetAddress;
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -27,6 +28,6 @@ public final class DefaultHostsFileEntriesResolver implements HostsFileEntriesRe
 
     @Override
     public InetAddress address(String inetHost) {
-        return entries.get(inetHost);
+        return entries.get(inetHost.toLowerCase(Locale.ENGLISH));
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -284,7 +284,6 @@ private FlowState connectionState() {
     }
 
     private FlowState state(Http2Stream stream) {
-        checkNotNull(stream, "stream");
         return stream.getProperty(stateKey);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -152,7 +152,7 @@ protected void fireChannelRead(ChannelHandlerContext ctx, FullHttpMessage msg, b
     protected FullHttpMessage newMessage(Http2Stream stream, Http2Headers headers, boolean validateHttpHeaders,
                                          ByteBufAllocator alloc)
             throws Http2Exception {
-        return connection.isServer() ? HttpConversionUtil.toHttpRequest(stream.id(), headers, alloc,
+        return connection.isServer() ? HttpConversionUtil.toFullHttpRequest(stream.id(), headers, alloc,
                 validateHttpHeaders) : HttpConversionUtil.toHttpResponse(stream.id(), headers, alloc,
                                                                          validateHttpHeaders);
     }

File: common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
Patch:
@@ -84,7 +84,7 @@ public void testNoStackOverflowErrorWithImmediateEventExecutorB() throws Excepti
             p[i].addListener(new FutureListener<Void>() {
                 @Override
                 public void operationComplete(Future<Void> future) throws Exception {
-                    DefaultPromise.notifyListener(ImmediateEventExecutor.INSTANCE, future, new FutureListener<Void>() {
+                    future.addListener(new FutureListener<Void>() {
                         @Override
                         public void operationComplete(Future<Void> future) throws Exception {
                             if (finalI + 1 < p.length) {
@@ -192,8 +192,8 @@ public void testLateListenerIsOrderedCorrectlyFailure() throws InterruptedExcept
      * <ol>
      * <li>A write is done</li>
      * <li>The write operation completes, and the promise state is changed to done</li>
-     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete()} updates
-     * state which must be invoked before the response to the previous write is read.</li>
+     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete(Future)}
+     * updates state which must be invoked before the response to the previous write is read.</li>
      * <li>The write operation</li>
      * </ol>
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
Patch:
@@ -99,7 +99,7 @@ public static CorsConfigBuilder forOrigins(final String... origins) {
     /**
      * Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
      * from the local file system. Calling this method will enable a successful CORS response
-     * with a wildcard for the the CORS response header 'Access-Control-Allow-Origin'.
+     * with a 'null' value for the the CORS response header 'Access-Control-Allow-Origin'.
      *
      * @return {@link CorsConfigBuilder} to support method chaining.
      */

File: example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
Patch:
@@ -80,7 +80,7 @@ public HttpCorsServerInitializer(SslContext sslCtx) {
 
     @Override
     public void initChannel(SocketChannel ch) {
-        CorsConfig corsConfig = CorsConfigBuilder.forAnyOrigin().build();
+        CorsConfig corsConfig = CorsConfigBuilder.forAnyOrigin().allowNullOrigin().allowCredentials().build();
         ChannelPipeline pipeline = ch.pipeline();
         if (sslCtx != null) {
             pipeline.addLast(sslCtx.newHandler(ch.alloc()));

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
Patch:
@@ -45,7 +45,6 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             @SuppressWarnings({ "unchecked", "CastConflictsWithInstanceof" })
             final M m = (M) msg;
             out.add(encodeMessage(ctx, m));
-            return;
         }
 
         if (msg instanceof MemcacheContent || msg instanceof ByteBuf || msg instanceof FileRegion) {

File: codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java
Patch:
@@ -28,6 +28,9 @@ public class BulkStringHeaderRedisMessage implements RedisMessage {
      * @param bulkStringLength follow content length.
      */
     public BulkStringHeaderRedisMessage(int bulkStringLength) {
+        if (bulkStringLength <= 0) {
+            throw new RedisCodecException("bulkStringLength: " + bulkStringLength + " (expected: > 0)");
+        }
         this.bulkStringLength = bulkStringLength;
     }
 

File: codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
Patch:
@@ -43,7 +43,7 @@ public void testLineProtocol() {
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'C' }));
         assertNull(ch.readInbound());
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { '\n' }));
-        assertEquals(Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' }), ch.readInbound());
+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' }), releaseLater(ch.readInbound()));
 
         // Truncated input
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'A' }));

File: buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
Patch:
@@ -49,7 +49,7 @@ final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf {
             order = ByteOrder.BIG_ENDIAN;
             nioBufferCount = 1;
             capacity = 0;
-            direct = buffers[0].isDirect();
+            direct = false;
         } else {
             ByteBuf b = buffers[0];
             this.buffers = new Object[buffers.length];

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -209,7 +209,7 @@ private static <T> PoolArena<T>[] newArenaArray(int size) {
 
     private static int validateAndCalculatePageShifts(int pageSize) {
         if (pageSize < MIN_PAGE_SIZE) {
-            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: " + MIN_PAGE_SIZE + "+)");
+            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: " + MIN_PAGE_SIZE + ")");
         }
 
         if ((pageSize & pageSize - 1) != 0) {

File: buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
Patch:
@@ -21,7 +21,10 @@
 /**
  * Abstract base class for {@link ByteBuf} implementations that wrap another
  * {@link ByteBuf}.
+ *
+ * @deprecated Do not use.
  */
+@Deprecated
 public abstract class AbstractDerivedByteBuf extends AbstractByteBuf {
 
     protected AbstractDerivedByteBuf(int maxCapacity) {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -86,7 +86,7 @@ private static void testDecodeWholeRequestAtOnce(byte[] content) {
         assertEquals(CONTENT_LENGTH, c.content().readableBytes());
         assertEquals(
                 Unpooled.wrappedBuffer(content, content.length - CONTENT_LENGTH, CONTENT_LENGTH),
-                c.content().readBytes(CONTENT_LENGTH));
+                c.content().readSlice(CONTENT_LENGTH));
         c.release();
 
         assertFalse(channel.finish());

File: transport/src/main/java/io/netty/channel/PendingWriteQueue.java
Patch:
@@ -94,7 +94,7 @@ public void add(Object msg, ChannelPromise promise) {
         // if the channel was already closed when constructing the PendingWriteQueue.
         // See https://github.com/netty/netty/issues/3967
         if (buffer != null) {
-            buffer.incrementPendingOutboundBytes(write.size, true);
+            buffer.incrementPendingOutboundBytes(write.size);
         }
     }
 
@@ -264,7 +264,7 @@ private void recycle(PendingWrite write, boolean update) {
         // if the channel was already closed when constructing the PendingWriteQueue.
         // See https://github.com/netty/netty/issues/3967
         if (buffer != null) {
-            buffer.decrementPendingOutboundBytes(writeSize, true);
+            buffer.decrementPendingOutboundBytes(writeSize);
         }
     }
 

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -178,7 +178,7 @@ protected final void clearReadPending() {
             // Best effort if we are not registered yet clear readPending. This happens during channel initialization.
             // NB: We only set the boolean field instead of calling clearReadPending0(), because the SelectionKey is
             // not set yet so it would produce an assertion failure.
-readPending = false;
+            readPending = false;
         }
     }
 

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -176,7 +176,9 @@ protected final void clearReadPending() {
             }
         } else {
             // Best effort if we are not registered yet clear readPending. This happens during channel initialization.
-            clearReadPending0();
+            // NB: We only set the boolean field instead of calling clearReadPending0(), because the SelectionKey is
+            // not set yet so it would produce an assertion failure.
+readPending = false;
         }
     }
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
Patch:
@@ -55,7 +55,7 @@ protected FullMemcacheMessage beginAggregation(BinaryMemcacheMessage start, Byte
     private static FullBinaryMemcacheRequest toFullRequest(BinaryMemcacheRequest request, ByteBuf content) {
         ByteBuf key = request.key() == null ? null : request.key().retain();
         ByteBuf extras = request.extras() == null ? null : request.extras().retain();
-        FullBinaryMemcacheRequest fullRequest =
+        DefaultFullBinaryMemcacheRequest fullRequest =
                 new DefaultFullBinaryMemcacheRequest(key, extras, content);
 
         fullRequest.setMagic(request.magic());
@@ -74,7 +74,7 @@ private static FullBinaryMemcacheRequest toFullRequest(BinaryMemcacheRequest req
     private static FullBinaryMemcacheResponse toFullResponse(BinaryMemcacheResponse response, ByteBuf content) {
         ByteBuf key = response.key() == null ? null : response.key().retain();
         ByteBuf extras = response.extras() == null ? null : response.extras().retain();
-        FullBinaryMemcacheResponse fullResponse =
+        DefaultFullBinaryMemcacheResponse fullResponse =
                 new DefaultFullBinaryMemcacheResponse(key, extras, content);
 
         fullResponse.setMagic(response.magic());

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
Patch:
@@ -34,7 +34,7 @@ public BinaryMemcacheRequestDecoder(int chunkSize) {
 
     @Override
     protected BinaryMemcacheRequest decodeHeader(ByteBuf in) {
-        BinaryMemcacheRequest header = new DefaultBinaryMemcacheRequest();
+        DefaultBinaryMemcacheRequest header = new DefaultBinaryMemcacheRequest();
         header.setMagic(in.readByte());
         header.setOpcode(in.readByte());
         header.setKeyLength(in.readShort());

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
Patch:
@@ -34,7 +34,7 @@ public BinaryMemcacheResponseDecoder(int chunkSize) {
 
     @Override
     protected BinaryMemcacheResponse decodeHeader(ByteBuf in) {
-        BinaryMemcacheResponse header = new DefaultBinaryMemcacheResponse();
+        DefaultBinaryMemcacheResponse header = new DefaultBinaryMemcacheResponse();
         header.setMagic(in.readByte());
         header.setOpcode(in.readByte());
         header.setKeyLength(in.readShort());

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java
Patch:
@@ -51,6 +51,7 @@ public DefaultFullBinaryMemcacheRequest(ByteBuf key, ByteBuf extras,
         }
 
         this.content = content;
+        setTotalBodyLength(keyLength() + extrasLength() + content.readableBytes());
     }
 
     @Override

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java
Patch:
@@ -51,6 +51,7 @@ public DefaultFullBinaryMemcacheResponse(ByteBuf key, ByteBuf extras,
         }
 
         this.content = content;
+        setTotalBodyLength(keyLength() + extrasLength() + content.readableBytes());
     }
 
     @Override

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java
Patch:
@@ -259,8 +259,6 @@ public void shouldRetainCurrentMessageWhenSendingItOut() {
         ByteBuf key = Unpooled.copiedBuffer("Netty", CharsetUtil.UTF_8);
         ByteBuf extras = Unpooled.copiedBuffer("extras", CharsetUtil.UTF_8);
         BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key, extras);
-        request.setKeyLength((short) key.readableBytes());
-        request.setExtrasLength((byte) extras.readableBytes());
 
         assertTrue(channel.writeOutbound(request));
         assertTrue(channel.writeInbound(channel.outboundMessages().toArray()));

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java
Patch:
@@ -86,7 +86,6 @@ public void shouldEncodeExtras() {
         int extrasLength = extras.readableBytes();
 
         BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(Unpooled.EMPTY_BUFFER, extras);
-        request.setExtrasLength((byte) extrasLength);
 
         boolean result = channel.writeOutbound(request);
         assertThat(result, is(true));
@@ -104,7 +103,6 @@ public void shouldEncodeKey() {
         int keyLength = key.readableBytes();
 
         BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key);
-        request.setKeyLength((byte) keyLength);
 
         boolean result = channel.writeOutbound(request);
         assertThat(result, is(true));

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -89,8 +89,6 @@ public void shouldRetainByteBufWhenAggregating() {
         ByteBuf key = Unpooled.copiedBuffer("Netty", CharsetUtil.UTF_8);
         ByteBuf extras = Unpooled.copiedBuffer("extras", CharsetUtil.UTF_8);
         BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key, extras);
-        request.setKeyLength((short) key.readableBytes());
-        request.setExtrasLength((byte) extras.readableBytes());
 
         DefaultMemcacheContent content1 =
                 new DefaultMemcacheContent(Unpooled.copiedBuffer("Netty", CharsetUtil.UTF_8));

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
Patch:
@@ -52,7 +52,7 @@ public class SocketStringEchoTest extends AbstractSocketTest {
         }
     }
 
-    @Test
+    @Test(timeout = 30000)
     public void testStringEcho() throws Throwable {
         run();
     }
@@ -61,7 +61,7 @@ public void testStringEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         testStringEcho(sb, cb, true);
     }
 
-    @Test
+    @Test(timeout = 30000)
     public void testStringEchoNotAutoRead() throws Throwable {
         run();
     }

File: transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
Patch:
@@ -398,7 +398,7 @@ private NioSctpChannelConfig(NioSctpChannel channel, SctpChannel javaChannel) {
 
         @Override
         protected void autoReadCleared() {
-            setReadPending(false);
+            clearReadPending();
         }
     }
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
Patch:
@@ -234,7 +234,7 @@ private NioSctpServerChannelConfig(NioSctpServerChannel channel, SctpServerChann
 
         @Override
         protected void autoReadCleared() {
-            setReadPending(false);
+            clearReadPending();
         }
     }
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
Patch:
@@ -464,7 +464,7 @@ private OioSctpChannelConfig(OioSctpChannel channel, SctpChannel javaChannel) {
 
         @Override
         protected void autoReadCleared() {
-            setReadPending(false);
+            clearReadPending();
         }
     }
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
Patch:
@@ -303,7 +303,7 @@ private OioSctpServerChannelConfig(OioSctpServerChannel channel, SctpServerChann
 
         @Override
         protected void autoReadCleared() {
-            setReadPending(false);
+            clearReadPending();
         }
     }
 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
Patch:
@@ -169,7 +169,7 @@ public DatagramChannelConfig setAutoRead(boolean autoRead) {
 
     @Override
     protected void autoReadCleared() {
-        ((NioDatagramChannel) channel).setReadPending(false);
+        ((NioDatagramChannel) channel).clearReadPending0();
     }
 
     private Object getOption0(Object option) {

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -191,7 +191,7 @@ private NioServerSocketChannelConfig(NioServerSocketChannel channel, ServerSocke
 
         @Override
         protected void autoReadCleared() {
-            setReadPending(false);
+            clearReadPending();
         }
     }
 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -361,7 +361,7 @@ private NioSocketChannelConfig(NioSocketChannel channel, Socket javaSocket) {
 
         @Override
         protected void autoReadCleared() {
-            setReadPending(false);
+            clearReadPending();
         }
     }
 }

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
Patch:
@@ -155,7 +155,7 @@ public OioServerSocketChannelConfig setAutoRead(boolean autoRead) {
     @Override
     protected void autoReadCleared() {
         if (channel instanceof OioServerSocketChannel) {
-            ((OioServerSocketChannel) channel).setReadPending(false);
+            ((OioServerSocketChannel) channel).clearReadPending0();
         }
     }
 

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
Patch:
@@ -183,7 +183,7 @@ public OioSocketChannelConfig setAutoRead(boolean autoRead) {
     @Override
     protected void autoReadCleared() {
         if (channel instanceof OioSocketChannel) {
-            ((OioSocketChannel) channel).setReadPending(false);
+            ((OioSocketChannel) channel).clearReadPending0();
         }
     }
 

File: transport/src/main/java/io/netty/channel/PendingWriteQueue.java
Patch:
@@ -94,7 +94,7 @@ public void add(Object msg, ChannelPromise promise) {
         // if the channel was already closed when constructing the PendingWriteQueue.
         // See https://github.com/netty/netty/issues/3967
         if (buffer != null) {
-            buffer.incrementPendingOutboundBytes(write.size);
+            buffer.incrementPendingOutboundBytes(write.size, true);
         }
     }
 
@@ -264,7 +264,7 @@ private void recycle(PendingWrite write, boolean update) {
         // if the channel was already closed when constructing the PendingWriteQueue.
         // See https://github.com/netty/netty/issues/3967
         if (buffer != null) {
-            buffer.decrementPendingOutboundBytes(writeSize);
+            buffer.decrementPendingOutboundBytes(writeSize, true);
         }
     }
 

File: buffer/src/main/java/io/netty/buffer/PoolChunkList.java
Patch:
@@ -122,12 +122,12 @@ private void remove(PoolChunk<T> cur) {
 
     @Override
     public int minUsage() {
-        return minUsage;
+        return minUsage == Integer.MIN_VALUE ? 1 : minUsage;
     }
 
     @Override
     public int maxUsage() {
-        return maxUsage;
+        return maxUsage == Integer.MAX_VALUE ? 100 : maxUsage;
     }
 
     @Override

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
Patch:
@@ -318,9 +318,7 @@ protected abstract class AbstractEpollUnsafe extends AbstractUnsafe {
          */
         abstract void epollInReady();
 
-        final void epollInReadAttempted() {
-            readPending = maybeMoreDataToRead = false;
-        }
+        final void epollInBefore() { maybeMoreDataToRead = false; }
 
         final void epollInFinally(ChannelConfig config) {
             maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();
@@ -452,6 +450,7 @@ void epollOutReady() {
         protected final void clearEpollIn0() {
             assert eventLoop().inEventLoop();
             try {
+                readPending = false;
                 clearFlag(readFlag);
             } catch (IOException e) {
                 // When this happens there is something completely wrong with either the filedescriptor or epoll,

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -364,7 +364,7 @@ private boolean writeBytesMultiple(
     private boolean writeFileRegion(
             ChannelOutboundBuffer in, DefaultFileRegion region, int writeSpinCount) throws Exception {
         final long regionCount = region.count();
-        if (region.transfered() >= regionCount) {
+        if (region.transferred() >= regionCount) {
             in.remove();
             return true;
         }
@@ -374,7 +374,7 @@ private boolean writeFileRegion(
         long flushedAmount = 0;
 
         for (int i = writeSpinCount - 1; i >= 0; i--) {
-            final long offset = region.transfered();
+            final long offset = region.transferred();
             final long localFlushedAmount =
                     Native.sendfile(fd().intValue(), region, baseOffset, offset, regionCount - offset);
             if (localFlushedAmount == 0) {

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -201,7 +201,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                 }
             } else if (msg instanceof FileRegion) {
                 FileRegion region = (FileRegion) msg;
-                boolean done = region.transfered() >= region.count();
+                boolean done = region.transferred() >= region.count();
 
                 if (!done) {
                     long flushedAmount = 0;
@@ -217,7 +217,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                         }
 
                         flushedAmount += localFlushedAmount;
-                        if (region.transfered() >= region.count()) {
+                        if (region.transferred() >= region.count()) {
                             done = true;
                             break;
                         }

File: transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
Patch:
@@ -208,9 +208,9 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                 in.remove();
             } else if (msg instanceof FileRegion) {
                 FileRegion region = (FileRegion) msg;
-                long transfered = region.transfered();
+                long transferred = region.transferred();
                 doWriteFileRegion(region);
-                in.progress(region.transfered() - transfered);
+                in.progress(region.transferred() - transferred);
                 in.remove();
             } else {
                 in.remove(new UnsupportedOperationException(

File: transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
Patch:
@@ -144,9 +144,9 @@ protected void doWriteFileRegion(FileRegion region) throws Exception {
     }
 
     private static void checkEOF(FileRegion region) throws IOException {
-        if (region.transfered() < region.count()) {
+        if (region.transferred() < region.count()) {
             throw new EOFException("Expected to be able to write " + region.count() + " bytes, " +
-                                   "but only wrote " + region.transfered());
+                                   "but only wrote " + region.transferred());
         }
     }
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -253,7 +253,7 @@ protected int doWriteBytes(ByteBuf buf) throws Exception {
 
     @Override
     protected long doWriteFileRegion(FileRegion region) throws Exception {
-        final long position = region.transfered();
+        final long position = region.transferred();
         return region.transferTo(javaChannel(), position);
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java
Patch:
@@ -35,7 +35,7 @@ public InboundHttpToHttp2Adapter(Http2Connection connection, Http2FrameListener
 
     private int getStreamId(HttpHeaders httpHeaders) {
         return httpHeaders.getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(),
-            connection.remote().nextStreamId());
+                                  connection.remote().incrementAndGetNextStreamId());
     }
 
     @Override

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -884,7 +884,6 @@ void epollInReady() {
 
                 if (close) {
                     shutdownInput();
-                    close = false;
                 }
             } catch (Throwable t) {
                 handleReadException(pipeline, byteBuf, t, close, allocHandle);

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java
Patch:
@@ -42,7 +42,8 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {
         if (mqttVersion == MqttVersion.MQTT_3_1) {
             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&
                 clientId.length() <= MAX_CLIENT_ID_LENGTH;
-        } else if (mqttVersion == MqttVersion.MQTT_3_1_1) {
+        }
+        if (mqttVersion == MqttVersion.MQTT_3_1_1) {
             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientIds
             // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId.
             return clientId != null;

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Variable header of {@link MqttConnectMessage}
  */
-public class MqttConnAckVariableHeader {
+public final class MqttConnAckVariableHeader {
 
     private final MqttConnectReturnCode connectReturnCode;
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Payload of {@link MqttConnectMessage}
  */
-public class MqttConnectPayload {
+public final class MqttConnectPayload {
 
     private final String clientIdentifier;
     private final String willTopic;

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Map;
 
 /**
- * Return Code of {@link io.netty.handler.codec.mqtt.MqttConnAckMessage}
+ * Return Code of {@link MqttConnAckMessage}
  */
 public enum MqttConnectReturnCode {
     CONNECTION_ACCEPTED((byte) 0x00),

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Variable Header for the {@link MqttConnectMessage}
  */
-public class MqttConnectVariableHeader {
+public final class MqttConnectVariableHeader {
 
     private final String name;
     private final int version;

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -33,7 +33,7 @@
  * <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html">
  *     the MQTT protocl specification v3.1</a>
  */
-public class MqttDecoder extends ReplayingDecoder<DecoderState> {
+public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
 
     private static final int DEFAULT_MAX_BYTES_IN_MESSAGE = 8092;
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttIdentifierRejectedException.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * A {@link MqttIdentifierRejectedException} which is thrown when a CONNECT request contains invalid client identifier.
  */
-public class MqttIdentifierRejectedException extends DecoderException {
+public final class MqttIdentifierRejectedException extends DecoderException {
 
     private static final long serialVersionUID = -1323503322689614981L;
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#puback">MQTTV3.1/puback</a>
  */
-public class MqttPubAckMessage extends MqttMessage {
+public final class MqttPubAckMessage extends MqttMessage {
 
     public MqttPubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {
         super(mqttFixedHeader, variableHeader);

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Variable Header of the {@link MqttPublishMessage}
  */
-public class MqttPublishVariableHeader {
+public final class MqttPublishVariableHeader {
 
     private final String topicName;
     private final int messageId;

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#suback">MQTTV3.1/suback</a>
  */
-public class MqttSubAckMessage extends MqttMessage {
+public final class MqttSubAckMessage extends MqttMessage {
 
     public MqttSubAckMessage(
             MqttFixedHeader mqttFixedHeader,

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java
Patch:
@@ -20,7 +20,7 @@
  * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe">
  *     MQTTV3.1/subscribe</a>
  */
-public class MqttSubscribeMessage extends MqttMessage {
+public final class MqttSubscribeMessage extends MqttMessage {
 
     public MqttSubscribeMessage(
             MqttFixedHeader mqttFixedHeader,

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribePayload.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Payload of the {@link MqttSubscribeMessage}
  */
-public class MqttSubscribePayload {
+public final class MqttSubscribePayload {
 
     private final List<MqttTopicSubscription> topicSubscriptions;
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttTopicSubscription.java
Patch:
@@ -22,7 +22,7 @@
  * Contains a topic name and Qos Level.
  * This is part of the {@link MqttSubscribePayload}
  */
-public class MqttTopicSubscription {
+public final class MqttTopicSubscription {
 
     private final String topicFilter;
     private final MqttQoS qualityOfService;

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnacceptableProtocolVersionException.java
Patch:
@@ -21,7 +21,7 @@
  * A {@link MqttUnacceptableProtocolVersionException} which is thrown when
  * a CONNECT request contains unacceptable protocol version.
  */
-public class MqttUnacceptableProtocolVersionException extends DecoderException {
+public final class MqttUnacceptableProtocolVersionException extends DecoderException {
 
     private static final long serialVersionUID = 4914652213232455749L;
 

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsuback">MQTTV3.1/unsuback</a>
  */
-public class MqttUnsubAckMessage extends MqttMessage {
+public final class MqttUnsubAckMessage extends MqttMessage {
 
     public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {
         super(mqttFixedHeader, variableHeader, null);

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java
Patch:
@@ -20,7 +20,7 @@
  * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe">
  *     MQTTV3.1/unsubscribe</a>
  */
-public class MqttUnsubscribeMessage extends MqttMessage {
+public final class MqttUnsubscribeMessage extends MqttMessage {
 
     public MqttUnsubscribeMessage(
             MqttFixedHeader mqttFixedHeader,

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribePayload.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Pyaload of the {@link MqttUnsubscribeMessage}
  */
-public class MqttUnsubscribePayload {
+public final class MqttUnsubscribePayload {
 
     private final List<String> topics;
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
Patch:
@@ -35,7 +35,7 @@ public final class EpollChannelOption<T> extends ChannelOption<T> {
     public static final ChannelOption<Boolean> IP_FREEBIND = ChannelOption.valueOf("IP_FREEBIND");
     public static final ChannelOption<Integer> TCP_FASTOPEN = valueOf(T, "TCP_FASTOPEN");
     public static final ChannelOption<Integer> TCP_DEFER_ACCEPT = ChannelOption.valueOf(T, "TCP_DEFER_ACCEPT");
-    public static final ChannelOption<Integer> TCP_QUICKACK = ChannelOption.valueOf(T, "TCP_QUICKACK");
+    public static final ChannelOption<Boolean> TCP_QUICKACK = ChannelOption.valueOf(T, "TCP_QUICKACK");
 
     public static final ChannelOption<DomainSocketReadMode> DOMAIN_SOCKET_READ_MODE =
             ChannelOption.valueOf(T, "DOMAIN_SOCKET_READ_MODE");

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessageUtil.java
Patch:
@@ -173,7 +173,7 @@ private static void appendRecords(StringBuilder buf, DnsMessage message, DnsSect
         for (int i = 0; i < count; i ++) {
             buf.append(StringUtil.NEWLINE)
                .append(StringUtil.TAB)
-               .append(message.recordAt(section, i));
+               .append(message.<DnsRecord>recordAt(section, i));
         }
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Encoder.java
Patch:
@@ -454,6 +454,9 @@ private static class HeaderEntry extends HeaderField {
         private void remove() {
             before.after = after;
             after.before = before;
+            before = null; // null references to prevent nepotism in generational GC.
+            after = null;
+            next = null;
         }
 
         /**

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
Patch:
@@ -94,7 +94,7 @@ public boolean release(int decrement) {
 
     @Override
     public String toString() {
-        return "DefaultFullStompFrame{" +
+        return "DefaultStompFrame{" +
             "command=" + command +
             ", headers=" + headers +
             ", content=" + content.toString(CharsetUtil.UTF_8) +

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
Patch:
@@ -66,7 +66,7 @@ public StompFrame retain() {
 
     @Override
     public StompFrame retain(int increment) {
-        content.retain();
+        content.retain(increment);
         return this;
     }
 

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
Patch:
@@ -28,8 +28,6 @@ public interface DnsCache {
     /**
      * Clears all the resolved addresses cached by this resolver.
      *
-     * @return {@code this}
-     *
      * @see #clear(String)
      */
     void clear();

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -38,7 +38,7 @@ public final class DnsNameResolverBuilder {
     private final EventLoop eventLoop;
     private ChannelFactory<? extends DatagramChannel> channelFactory;
     private InetSocketAddress localAddress = DnsNameResolver.ANY_LOCAL_ADDR;
-    private DnsServerAddresses nameServerAddresses = DefaultDnsServerAddresses.defaultAddresses();
+    private DnsServerAddresses nameServerAddresses = DnsServerAddresses.defaultAddresses();
     private DnsCache resolveCache;
     private Integer minTtl;
     private Integer maxTtl;
@@ -77,7 +77,7 @@ public DnsNameResolverBuilder channelFactory(ChannelFactory<? extends DatagramCh
      * Sets the {@link ChannelFactory} as a {@link ReflectiveChannelFactory} of this type.
      * Use as an alternative to {@link #channelFactory(ChannelFactory)}.
      *
-     * @param channelType
+     * @param channelType the type
      * @return {@code this}
      */
     public DnsNameResolverBuilder channelType(Class<? extends DatagramChannel> channelType) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java
Patch:
@@ -23,7 +23,6 @@
 import java.lang.reflect.Method;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.SocketAddress;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -262,7 +261,7 @@ private static InetSocketAddress[] sanitize(InetSocketAddress[] addresses) {
 
     /**
      * Starts a new infinite stream of DNS server addresses. This method is invoked by {@link DnsNameResolver} on every
-     * uncached {@link DnsNameResolver#resolve(SocketAddress)} or {@link DnsNameResolver#resolveAll(SocketAddress)}.
+     * uncached {@link DnsNameResolver#resolve(String)}or {@link DnsNameResolver#resolveAll(String)}.
      */
     public abstract DnsServerAddressStream stream();
 }

File: buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java
Patch:
@@ -580,7 +580,7 @@ static void setBytes(AbstractByteBuf buf, long addr, int index, ByteBuffer src)
             try {
                 byte[] tmp = tmpBuf.array();
                 src.get(tmp, tmpBuf.arrayOffset(), length); // moves the src position too
-                PlatformDependent.copyMemory(tmp, 0, addr, length);
+                PlatformDependent.copyMemory(tmp, tmpBuf.arrayOffset(), addr, length);
             } finally {
                 tmpBuf.release();
             }

File: handler/src/main/java/io/netty/handler/ssl/SslUtils.java
Patch:
@@ -118,6 +118,9 @@ static int getEncryptedPacketLength(ByteBuf buffer, int offset) {
     }
 
     static void notifyHandshakeFailure(ChannelHandlerContext ctx, Throwable cause) {
+        // We have may haven written some parts of data before an exception was thrown so ensure we always flush.
+        // See https://github.com/netty/netty/issues/3900#issuecomment-172481830
+        ctx.flush();
         ctx.fireUserEventTriggered(new SslHandshakeCompletionEvent(cause));
         ctx.close();
     }

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -63,9 +63,9 @@ public void recycle(Object object) {
         DEFAULT_MAX_CAPACITY = maxCapacity;
         if (logger.isDebugEnabled()) {
             if (DEFAULT_MAX_CAPACITY == 0) {
-                logger.debug("-Dio.netty.recycler.maxCapacity.maxCapacity: disabled");
+                logger.debug("-Dio.netty.recycler.maxCapacity: disabled");
             } else {
-                logger.debug("-Dio.netty.recycler.maxCapacity.maxCapacity: {}", DEFAULT_MAX_CAPACITY);
+                logger.debug("-Dio.netty.recycler.maxCapacity: {}", DEFAULT_MAX_CAPACITY);
             }
         }
 

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -187,6 +187,7 @@ public OpenSslClientContext(File trustCertChainFile, TrustManagerFactory trustMa
                 ClientAuth.NONE);
         boolean success = false;
         try {
+            checkKeyManagerFactory(keyManagerFactory);
             if (key == null && keyCertChain != null || key != null && keyCertChain == null) {
                 throw new IllegalArgumentException(
                         "Either both keyCertChain and key needs to be null or none of them");

File: codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
Patch:
@@ -146,7 +146,8 @@ private final class State {
         }
 
         void updateStreamableBytes(int newStreamableBytes, boolean hasFrame, int windowSize) {
-            assert hasFrame || newStreamableBytes == 0;
+            assert hasFrame || newStreamableBytes == 0 :
+                "hasFrame: " + hasFrame + " newStreamableBytes: " + newStreamableBytes;
 
             int delta = newStreamableBytes - streamableBytes;
             if (delta != 0) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java
Patch:
@@ -52,7 +52,7 @@ protected AbstractEpollServerChannel(FileDescriptor fd) {
      */
     @Deprecated
     protected AbstractEpollServerChannel(Socket fd) {
-        this(fd, fd.getSoError() == 0);
+        this(fd, isSoErrorZero(fd));
     }
 
     protected AbstractEpollServerChannel(Socket fd, boolean active) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
Patch:
@@ -106,7 +106,7 @@ protected AbstractEpollStreamChannel(FileDescriptor fd) {
      */
     @Deprecated
     protected AbstractEpollStreamChannel(Socket fd) {
-        this(fd, fd.getSoError() == 0);
+        this(fd, isSoErrorZero(fd));
     }
 
     protected AbstractEpollStreamChannel(Channel parent, Socket fd) {

File: testsuite/src/main/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java
Patch:
@@ -24,8 +24,8 @@
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 
 /**
- * A Web Socket echo server for running the <a href="http://www.tavendo.de/autobahn/testsuite.html">autobahn</a> test
- * suite
+ * A Web Socket echo server for running the
+ * <a href="http://autobahn.ws/testsuite/">autobahn test suite</a>
  */
 public class AutobahnServer {
 

File: transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
Patch:
@@ -35,7 +35,7 @@
  *     }
  * </pre>
  *
- * Be aware that depending of the constructor parameters it will release all handled messages by pass them to
+ * Be aware that depending of the constructor parameters it will release all handled messages by passing them to
  * {@link ReferenceCountUtil#release(Object)}. In this case you may need to use
  * {@link ReferenceCountUtil#retain(Object)} if you pass the object to the next handler in the {@link ChannelPipeline}.
  *
@@ -60,7 +60,7 @@ protected SimpleChannelInboundHandler() {
     /**
      * Create a new instance which will try to detect the types to match out of the type parameter of the class.
      *
-     * @param autoRelease   {@code true} if handled messages should be released automatically by pass them to
+     * @param autoRelease   {@code true} if handled messages should be released automatically by passing them to
      *                      {@link ReferenceCountUtil#release(Object)}.
      */
     protected SimpleChannelInboundHandler(boolean autoRelease) {
@@ -79,7 +79,7 @@ protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType) {
      * Create a new instance
      *
      * @param inboundMessageType    The type of messages to match
-     * @param autoRelease           {@code true} if handled messages should be released automatically by pass them to
+     * @param autoRelease           {@code true} if handled messages should be released automatically by passing them to
      *                              {@link ReferenceCountUtil#release(Object)}.
      */
     protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType, boolean autoRelease) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.channel.unix.FileDescriptor;
 import io.netty.channel.unix.Socket;
 
+import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
@@ -125,7 +126,7 @@ Collection<InetAddress> tcpMd5SigAddresses() {
         return tcpMd5SigAddresses;
     }
 
-    void setTcpMd5Sig(Map<InetAddress, byte[]> keys) {
+    void setTcpMd5Sig(Map<InetAddress, byte[]> keys) throws IOException {
         this.tcpMd5SigAddresses = TcpMd5Util.newTcpMd5Sigs(this, tcpMd5SigAddresses, keys);
     }
 }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/TcpMd5Util.java
Patch:
@@ -16,6 +16,8 @@
 package io.netty.channel.epoll;
 
 import io.netty.util.internal.ObjectUtil;
+
+import java.io.IOException;
 import java.net.InetAddress;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -26,7 +28,7 @@
 final class TcpMd5Util {
 
     static Collection<InetAddress> newTcpMd5Sigs(AbstractEpollChannel channel, Collection<InetAddress> current,
-                                         Map<InetAddress, byte[]> newKeys) {
+                                         Map<InetAddress, byte[]> newKeys) throws IOException {
         ObjectUtil.checkNotNull(channel, "channel");
         ObjectUtil.checkNotNull(current, "current");
         ObjectUtil.checkNotNull(newKeys, "newKeys");

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -105,14 +105,13 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
                     encoder.writeHeaders(ctx, currentStreamId, trailers, 0, true, promiseAggregator.newPromise());
                 }
             }
-
-            promiseAggregator.doneAllocatingPromises();
         } catch (Throwable t) {
             promiseAggregator.setFailure(t);
         } finally {
             if (release) {
                 ReferenceCountUtil.release(msg);
             }
+            promiseAggregator.doneAllocatingPromises();
         }
     }
 }

File: common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java
Patch:
@@ -20,13 +20,16 @@
 import java.util.Set;
 
 /**
+ * @deprecated Use {@link PromiseCombiner}
+ *
  * {@link GenericFutureListener} implementation which consolidates multiple {@link Future}s
  * into one, by listening to individual {@link Future}s and producing an aggregated result
  * (success/failure) when all {@link Future}s have completed.
  *
  * @param <V> the type of value returned by the {@link Future}
  * @param <F> the type of {@link Future}
  */
+@Deprecated
 public class PromiseAggregator<V, F extends Future<V>> implements GenericFutureListener<F> {
 
     private final Promise<?> aggregatePromise;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java
Patch:
@@ -127,7 +127,7 @@ public boolean remoteSideOpen() {
     <V> V removeProperty(Http2Connection.PropertyKey key);
 
     /**
-     * Updates an priority for this stream. Calling this method may affect the straucture of the
+     * Updates an priority for this stream. Calling this method may affect the structure of the
      * priority tree.
      *
      * @param parentStreamId the parent stream that given stream should depend on. May be {@code 0},

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -61,7 +61,7 @@ protected CharBuffer initialValue() throws Exception {
     private static final int MAX_CHAR_BUFFER_SIZE;
     private static final int THREAD_LOCAL_BUFFER_SIZE;
     private static final int MAX_BYTES_PER_CHAR_UTF8 =
-            (int) CharsetUtil.getEncoder(CharsetUtil.UTF_8).maxBytesPerChar();
+            (int) CharsetUtil.encoder(CharsetUtil.UTF_8).maxBytesPerChar();
 
     static final ByteBufAllocator DEFAULT_ALLOCATOR;
 
@@ -511,7 +511,7 @@ public static ByteBuf encodeString(ByteBufAllocator alloc, CharBuffer src, Chars
     }
 
     static ByteBuf encodeString0(ByteBufAllocator alloc, boolean enforceHeap, CharBuffer src, Charset charset) {
-        final CharsetEncoder encoder = CharsetUtil.getEncoder(charset);
+        final CharsetEncoder encoder = CharsetUtil.encoder(charset);
         int length = (int) ((double) src.remaining() * encoder.maxBytesPerChar());
         boolean release = true;
         final ByteBuf dst;
@@ -547,7 +547,7 @@ static String decodeString(ByteBuf src, int readerIndex, int len, Charset charse
         if (len == 0) {
             return StringUtil.EMPTY_STRING;
         }
-        final CharsetDecoder decoder = CharsetUtil.getDecoder(charset);
+        final CharsetDecoder decoder = CharsetUtil.decoder(charset);
         final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());
         CharBuffer dst = CHAR_BUFFERS.get();
         if (dst.length() < maxLength) {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequest.java
Patch:
@@ -27,7 +27,7 @@
  * @see SocksAuthRequestDecoder
  */
 public final class SocksAuthRequest extends SocksRequest {
-    private static final CharsetEncoder asciiEncoder = CharsetUtil.getEncoder(CharsetUtil.US_ASCII);
+    private static final CharsetEncoder asciiEncoder = CharsetUtil.encoder(CharsetUtil.US_ASCII);
     private static final SocksSubnegotiationVersion SUBNEGOTIATION_VERSION = SocksSubnegotiationVersion.AUTH_PASSWORD;
     private final String username;
     private final String password;

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -194,7 +194,7 @@ public AsciiString(char[] value, Charset charset) {
      */
     public AsciiString(char[] value, Charset charset, int start, int length) {
         CharBuffer cbuf = CharBuffer.wrap(value, start, length);
-        CharsetEncoder encoder = CharsetUtil.getEncoder(charset);
+        CharsetEncoder encoder = CharsetUtil.encoder(charset);
         ByteBuffer nativeBuffer = ByteBuffer.allocate((int) (encoder.maxBytesPerChar() * length));
         encoder.encode(cbuf, nativeBuffer, true);
         final int bufferOffset = nativeBuffer.arrayOffset();
@@ -241,7 +241,7 @@ public AsciiString(CharSequence value, Charset charset) {
      */
     public AsciiString(CharSequence value, Charset charset, int start, int length) {
         CharBuffer cbuf = CharBuffer.wrap(value, start, start + length);
-        CharsetEncoder encoder = CharsetUtil.getEncoder(charset);
+        CharsetEncoder encoder = CharsetUtil.encoder(charset);
         ByteBuffer nativeBuffer = ByteBuffer.allocate((int) (encoder.maxBytesPerChar() * length));
         encoder.encode(cbuf, nativeBuffer, true);
         final int offset = nativeBuffer.arrayOffset();

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTcpMd5Test.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.ConnectTimeoutException;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.CharsetUtil;
@@ -94,6 +95,7 @@ public void testKeyMismatch() throws Exception {
                 .handler(new ChannelInboundHandlerAdapter())
                 .option(EpollChannelOption.TCP_MD5SIG,
                         Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, BAD_KEY))
+                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 1000)
                 .connect(server.localAddress()).syncUninterruptibly().channel();
         client.close().syncUninterruptibly();
     }

File: handler/src/main/java/io/netty/handler/ssl/SslContext.java
Patch:
@@ -67,7 +67,7 @@
  * // In your {@link ChannelInitializer}:
  * {@link ChannelPipeline} p = channel.pipeline();
  * {@link SslContext} sslCtx = {@link SslContextBuilder#forServer(File, File) SslContextBuilder.forServer(...)}.build();
- * p.addLast("ssl", {@link #newEngine(ByteBufAllocator) sslCtx.newEngine(channel.alloc())});
+ * p.addLast("ssl", {@link #newHandler(ByteBufAllocator) sslCtx.newHandler(channel.alloc())});
  * ...
  * </pre>
  *
@@ -76,7 +76,7 @@
  * // In your {@link ChannelInitializer}:
  * {@link ChannelPipeline} p = channel.pipeline();
  * {@link SslContext} sslCtx = {@link SslContextBuilder#forClient() SslContextBuilder.forClient()}.build();
- * p.addLast("ssl", {@link #newEngine(ByteBufAllocator, String, int) sslCtx.newEngine(channel.alloc(), host, port)});
+ * p.addLast("ssl", {@link #newHandler(ByteBufAllocator, String, int) sslCtx.newHandler(channel.alloc(), host, port)});
  * ...
  * </pre>
  */

File: handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java
Patch:
@@ -53,7 +53,7 @@ public static SslContextBuilder forServer(File keyCertChainFile, File keyFile) {
      * Creates a builder for new server-side {@link SslContext}.
      *
      * @param keyCertChainInputStream an input stream for an X.509 certificate chain in PEM format
-     * @param keyFile an input stream for a PKCS#8 private key in PEM format
+     * @param keyInputStream an input stream for a PKCS#8 private key in PEM format
      * @see #keyManager(InputStream, InputStream)
      */
     public static SslContextBuilder forServer(InputStream keyCertChainInputStream, InputStream keyInputStream) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -735,8 +735,8 @@ private static void processGoAwayWriteResult(final ChannelHandlerContext ctx, fi
                     ctx.close();
                 }
             } else {
-                if (logger.isWarnEnabled()) {
-                    logger.warn("{} Sending GOAWAY failed: lastStreamId '{}', errorCode '{}', " +
+                if (logger.isDebugEnabled()) {
+                    logger.debug("{} Sending GOAWAY failed: lastStreamId '{}', errorCode '{}', " +
                                  "debugData '{}'. Forcing shutdown of the connection.",
                                  ctx.channel(), lastStreamId, errorCode, debugData.toString(UTF_8), future.cause());
                 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -33,7 +33,7 @@
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 
 public class DefaultHttp2HeadersDecoder implements Http2HeadersDecoder, Http2HeadersDecoder.Configuration {
-    private static final float HEADERS_COUNT_WEIGHT_NEW = 1 / 5;
+    private static final float HEADERS_COUNT_WEIGHT_NEW = 1 / 5f;
     private static final float HEADERS_COUNT_WEIGHT_HISTORICAL = 1 - HEADERS_COUNT_WEIGHT_NEW;
 
     private final int maxHeaderSize;
@@ -109,8 +109,8 @@ public void addHeader(byte[] key, byte[] value, boolean sensitive) {
                         headers.size(), headerTable.maxHeaderListSize());
             }
 
-            headerArraySizeAccumulator =  HEADERS_COUNT_WEIGHT_NEW * headers.size() +
-                                          HEADERS_COUNT_WEIGHT_HISTORICAL * headerArraySizeAccumulator;
+            headerArraySizeAccumulator = HEADERS_COUNT_WEIGHT_NEW * headers.size() +
+                                         HEADERS_COUNT_WEIGHT_HISTORICAL * headerArraySizeAccumulator;
             return headers;
         } catch (IOException e) {
             throw connectionError(COMPRESSION_ERROR, e, e.getMessage());

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -207,7 +207,7 @@ public boolean prefaceSent() {
         @Override
         public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
             try {
-                if (readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {
+                if (ctx.channel().isActive() && readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {
                     // After the preface is read, it is time to hand over control to the post initialized decoder.
                     byteDecoder = new FrameDecoder();
                     byteDecoder.decode(ctx, in, out);
@@ -735,8 +735,8 @@ private static void processGoAwayWriteResult(final ChannelHandlerContext ctx, fi
                     ctx.close();
                 }
             } else {
-                if (logger.isErrorEnabled()) {
-                    logger.error("{} Sending GOAWAY failed: lastStreamId '{}', errorCode '{}', " +
+                if (logger.isWarnEnabled()) {
+                    logger.warn("{} Sending GOAWAY failed: lastStreamId '{}', errorCode '{}', " +
                                  "debugData '{}'. Forcing shutdown of the connection.",
                                  ctx.channel(), lastStreamId, errorCode, debugData.toString(UTF_8), future.cause());
                 }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -121,7 +121,7 @@ public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)
                     composite = (CompositeByteBuf) cumulation;
                 } else {
                     int readable = cumulation.readableBytes();
-                    composite = alloc.compositeBuffer();
+                    composite = alloc.compositeBuffer(Integer.MAX_VALUE);
                     composite.addComponent(cumulation).writerIndex(readable);
                 }
                 composite.addComponent(in).writerIndex(composite.writerIndex() + in.readableBytes());

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompHeadersTest.java
Patch:
@@ -23,7 +23,7 @@
 
 public class StompHeadersTest {
     @Test
-    public void testHeadersCaseSensative() {
+    public void testHeadersCaseSensitive() {
         DefaultStompHeaders headers = new DefaultStompHeaders();
         AsciiString foo = new AsciiString("foo");
         AsciiString value = new AsciiString("value");

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.channel.DefaultChannelPromise;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.Promise;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -269,11 +270,12 @@ public void verifyChannelHandlerCanBeReusedInPipeline() throws Exception {
         verify(decoder, atLeastOnce()).decodeFrame(eq(ctx), any(ByteBuf.class), Matchers.<List<Object>>any());
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void channelInactiveShouldCloseStreams() throws Exception {
         handler = newHandler();
         handler.channelInactive(ctx);
-        verify(stream).close();
+        verify(connection).close(any(Promise.class));
     }
 
     @Test

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
Patch:
@@ -64,12 +64,12 @@ private static void encodeExtras(ByteBuf buf, ByteBuf extras) {
      * @param buf the {@link ByteBuf} to write into.
      * @param key the key to encode.
      */
-    private static void encodeKey(ByteBuf buf, String key) {
-        if (key == null || key.isEmpty()) {
+    private static void encodeKey(ByteBuf buf, ByteBuf key) {
+        if (key == null || !key.isReadable()) {
             return;
         }
 
-        buf.writeBytes(key.getBytes(CharsetUtil.UTF_8));
+        buf.writeBytes(key);
     }
 
     /**

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
Patch:
@@ -49,6 +49,6 @@ protected BinaryMemcacheRequest decodeHeader(ByteBuf in) {
 
     @Override
     protected BinaryMemcacheRequest buildInvalidMessage() {
-        return new DefaultBinaryMemcacheRequest("", Unpooled.EMPTY_BUFFER);
+        return new DefaultBinaryMemcacheRequest(Unpooled.EMPTY_BUFFER, Unpooled.EMPTY_BUFFER);
     }
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
Patch:
@@ -49,6 +49,6 @@ protected BinaryMemcacheResponse decodeHeader(ByteBuf in) {
 
     @Override
     protected BinaryMemcacheResponse buildInvalidMessage() {
-        return new DefaultBinaryMemcacheResponse("", Unpooled.EMPTY_BUFFER);
+        return new DefaultBinaryMemcacheResponse(Unpooled.EMPTY_BUFFER, Unpooled.EMPTY_BUFFER);
     }
 }

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java
Patch:
@@ -256,10 +256,10 @@ public void shouldRetainCurrentMessageWhenSendingItOut() {
                 new BinaryMemcacheRequestEncoder(),
                 new BinaryMemcacheRequestDecoder());
 
-        String key = "Netty";
+        ByteBuf key = Unpooled.copiedBuffer("Netty", CharsetUtil.UTF_8);
         ByteBuf extras = Unpooled.copiedBuffer("extras", CharsetUtil.UTF_8);
         BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key, extras);
-        request.setKeyLength((short) key.length());
+        request.setKeyLength((short) key.readableBytes());
         request.setExtrasLength((byte) extras.readableBytes());
 
         assertTrue(channel.writeOutbound(request));

File: resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java
Patch:
@@ -73,7 +73,9 @@ public AddressResolver<T> getResolver(final EventExecutor executor) {
                 executor.terminationFuture().addListener(new FutureListener<Object>() {
                     @Override
                     public void operationComplete(Future<Object> future) throws Exception {
-                        resolvers.remove(executor);
+                        synchronized (resolvers) {
+                            resolvers.remove(executor);
+                        }
                         newResolver.close();
                     }
                 });

File: buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java
Patch:
@@ -251,7 +251,8 @@ static short getShort(byte[] array, int index) {
             short v = PlatformDependent.getShort(array, index);
             return BIG_ENDIAN_NATIVE_ORDER ? v : Short.reverseBytes(v);
         }
-        return (short) (PlatformDependent.getByte(index) << 8 | PlatformDependent.getByte(index + 1) & 0xff);
+        return (short) (PlatformDependent.getByte(array, index) << 8 |
+                PlatformDependent.getByte(array, index + 1) & 0xff);
     }
 
     static short getShortLE(byte[] array, int index) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java
Patch:
@@ -17,6 +17,8 @@
 
 import static io.netty.handler.codec.http.websocketx.extensions.compression.
         PerMessageDeflateServerExtensionHandshaker.*;
+
+import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtension;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandshaker;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionData;
@@ -43,7 +45,7 @@ public final class PerMessageDeflateClientExtensionHandshaker implements WebSock
      * Constructor with default configuration.
      */
     public PerMessageDeflateClientExtensionHandshaker() {
-        this(6, false, MAX_WINDOW_SIZE, false, false);
+        this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx.extensions.compression;
 
+import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionData;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionDecoder;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionEncoder;
@@ -50,7 +51,7 @@ public final class PerMessageDeflateServerExtensionHandshaker implements WebSock
      * Constructor with default configuration.
      */
     public PerMessageDeflateServerExtensionHandshaker() {
-        this(6, false, MAX_WINDOW_SIZE, false, false);
+        this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);
     }
 
     /**

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java
Patch:
@@ -18,6 +18,8 @@
 import static io.netty.handler.codec.http.websocketx.extensions.compression.
         PerMessageDeflateServerExtensionHandshaker.*;
 import static org.junit.Assert.*;
+
+import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtension;
 import io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionData;
 
@@ -37,7 +39,7 @@ public void testNormalData() {
         WebSocketExtensionData data = handshaker.newRequestData();
 
         assertEquals(PERMESSAGE_DEFLATE_EXTENSION, data.name());
-        assertTrue(data.parameters().isEmpty());
+        assertEquals(ZlibCodecFactory.isSupportingWindowSizeAndMemLevel() ? 1 : 0, data.parameters().size());
     }
 
     @Test

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollReuseAddrTest.java
Patch:
@@ -48,7 +48,7 @@ public class EpollReuseAddrTest {
     private static final int MINOR;
     private static final int BUGFIX;
     static {
-        String kernelVersion = Native.kernelVersion();
+        String kernelVersion = Native.KERNEL_VERSION;
         int index = kernelVersion.indexOf('-');
         if (index > -1) {
             kernelVersion = kernelVersion.substring(0, index);

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -366,7 +366,7 @@ protected void testEnablingAnAlreadyDisabledSslProtocol(String[] protocols1, Str
         }
     }
 
-    private static void handshake(SSLEngine clientEngine, SSLEngine serverEngine) throws SSLException {
+    protected static void handshake(SSLEngine clientEngine, SSLEngine serverEngine) throws SSLException {
         int netBufferSize = 17 * 1024;
         ByteBuffer cTOs = ByteBuffer.allocateDirect(netBufferSize);
         ByteBuffer sTOc = ByteBuffer.allocateDirect(netBufferSize);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -616,7 +616,7 @@ public ChannelFuture resetStream(final ChannelHandlerContext ctx, int streamId,
         }
 
         final ChannelFuture future;
-        if (stream.state() == IDLE || (connection().local().created(stream) && !stream.isHeaderSent())) {
+        if (stream.state() == IDLE || connection().local().created(stream)) {
             // The other endpoint doesn't know about the stream yet, so we can't actually send
             // the RST_STREAM frame. The HTTP/2 spec also disallows sending RST_STREAM for IDLE streams.
             future = promise.setSuccess();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java
Patch:
@@ -265,8 +265,9 @@ public void dataFramesShouldMergeUseVoidPromise() throws Exception {
     public void dataFramesDontMergeWithHeaders() throws Exception {
         createStream(STREAM_ID, false);
         final ByteBuf data = dummyData().retain();
-        encoder.writeData(ctx, STREAM_ID, data, 0, true, newPromise());
-        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, newPromise());
+        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
+        when(remoteFlow.hasFlowControlled(any(Http2Stream.class))).thenReturn(true);
+        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newPromise());
         List<FlowControlled> capturedWrites = payloadCaptor.getAllValues();
         assertFalse(capturedWrites.get(0).merge(ctx, capturedWrites.get(1)));
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -315,7 +315,6 @@ public void writeRstOnClosedStreamShouldSucceed() throws Exception {
         when(frameWriter.writeRstStream(eq(ctx), eq(STREAM_ID),
                 anyLong(), any(ChannelPromise.class))).thenReturn(future);
         when(stream.state()).thenReturn(CLOSED);
-        when(stream.isHeaderSent()).thenReturn(true);
         // The stream is "closed" but is still known about by the connection (connection().stream(..)
         // will return the stream). We should still write a RST_STREAM frame in this scenario.
         handler.resetStream(ctx, STREAM_ID, STREAM_CLOSED.code(), promise);

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
Patch:
@@ -16,11 +16,12 @@
 package io.netty.handler.codec.memcache;
 
 import io.netty.handler.codec.DecoderResult;
+import io.netty.util.AbstractReferenceCounted;
 
 /**
  * The default {@link MemcacheObject} implementation.
  */
-public abstract class AbstractMemcacheObject implements MemcacheObject {
+public abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject {
 
     private DecoderResult decoderResult = DecoderResult.SUCCESS;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -82,7 +82,7 @@ public class WebSocket08FrameEncoder extends MessageToMessageEncoder<WebSocketFr
     private static final byte OPCODE_PONG = 0xA;
 
     /**
-     * The size thsreshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as
+     * The size threshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as
      * a header and a content ByteBuf whereas messages smaller than the size will be merged into a single buffer and
      * sent at once.<br>
      * Masked messages will always be sent at once.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -51,7 +51,7 @@ protected HttpToHttp2ConnectionHandler(Http2ConnectionDecoder decoder, Http2Conn
      */
     private int getStreamId(HttpHeaders httpHeaders) throws Exception {
         return httpHeaders.getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(),
-                                  connection().local().nextStreamId());
+                                  connection().local().incrementAndGetNextStreamId());
     }
 
     /**

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
Patch:
@@ -54,7 +54,7 @@ public class OioSctpServerChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSctpServerChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 1);
 
     private static SctpServerChannel newServerSocket() {
         try {

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -44,7 +44,7 @@ public class OioServerSocketChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(OioServerSocketChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 1);
 
     private static ServerSocket newServerSocket() {
         try {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -357,10 +357,11 @@ public void write(ChannelHandlerContext ctx, int allowedBytes) {
 
         @Override
         public boolean merge(ChannelHandlerContext ctx, Http2RemoteFlowController.FlowControlled next) {
-            if (FlowControlledData.class != next.getClass()) {
+            FlowControlledData nextData;
+            if (FlowControlledData.class != next.getClass() ||
+                Integer.MAX_VALUE - (nextData = (FlowControlledData) next).size() < size()) {
                 return false;
             }
-            FlowControlledData nextData = (FlowControlledData) next;
             nextData.queue.copyTo(queue);
             // Given that we're merging data into a frame it doesn't really make sense to accumulate padding.
             padding = Math.max(padding, nextData.padding);

File: handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java
Patch:
@@ -397,7 +397,7 @@ private static void handshake(SSLEngine clientEngine, SSLEngine serverEngine) th
             runDelegatedTasks(serverResult, serverEngine);
             cTOs.compact();
             sTOc.compact();
-        } while (isHandshaking(clientResult) && isHandshaking(serverResult));
+        } while (isHandshaking(clientResult) || isHandshaking(serverResult));
     }
 
     private static boolean isHandshaking(SSLEngineResult result) {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
Patch:
@@ -30,11 +30,12 @@ public abstract class AbstractBinaryMemcacheEncoder<M extends BinaryMemcacheMess
     /**
      * Every binary memcache message has at least a 24 bytes header.
      */
-    private static final int DEFAULT_BUFFER_SIZE = 24;
+    private static final int MINIMUM_HEADER_SIZE = 24;
 
     @Override
     protected ByteBuf encodeMessage(ChannelHandlerContext ctx, M msg) {
-        ByteBuf buf = ctx.alloc().buffer(DEFAULT_BUFFER_SIZE);
+        ByteBuf buf = ctx.alloc().buffer(MINIMUM_HEADER_SIZE + msg.extrasLength()
+            + msg.keyLength());
 
         encodeHeader(buf, msg);
         encodeExtras(buf, msg.extras());

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
Patch:
@@ -18,7 +18,7 @@
 import java.net.SocketAddress;
 
 /**
- * Skelton implementation of a {@link ChannelOutboundHandler}. This implementation just forwards each method call via
+ * Skeleton implementation of a {@link ChannelOutboundHandler}. This implementation just forwards each method call via
  * the {@link ChannelHandlerContext}.
  */
 public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {
@@ -72,7 +72,7 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise)
     }
 
     /**
-     * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward
+     * Calls {@link ChannelHandlerContext#deregister(ChannelPromise)} to forward
      * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
@@ -94,7 +94,7 @@ public void read(ChannelHandlerContext ctx) throws Exception {
     }
 
     /**
-     * Calls {@link ChannelHandlerContext#write(Object)} to forward
+     * Calls {@link ChannelHandlerContext#write(Object, ChannelPromise)} to forward
      * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.

File: testsuite-osgi/src/test/java/io/netty/osgitests/OsgiBundleTest.java
Patch:
@@ -90,7 +90,6 @@ public final Option[] config() {
         options.addAll(Arrays.asList(junitBundles()));
 
         options.add(mavenBundle("com.barchart.udt", "barchart-udt-bundle").versionAsInProject());
-        options.add(mavenBundle("com.twitter", "hpack").versionAsInProject());
         options.add(wrappedBundle(mavenBundle("org.rxtx", "rxtx").versionAsInProject()));
 
         for (String name : BUNDLES) {

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -983,7 +983,7 @@ public AsciiString toUpperCase() {
      * @return a new string with characters {@code <= \\u0020} removed from the beginning and the end.
      */
     public AsciiString trim() {
-        int start = arrayOffset(), last = arrayOffset() + length();
+        int start = arrayOffset(), last = arrayOffset() + length() - 1;
         int end = last;
         while (start <= end && value[start] <= ' ') {
             start++;

File: transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
Patch:
@@ -82,6 +82,7 @@ public EventExecutor executor() {
         return invoker().executor();
     }
 
+    @Override
     public ChannelHandlerInvoker invoker() {
         if (invoker == null) {
             return channel().unsafe().invoker();

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -38,7 +38,7 @@ public final class DnsNameResolverBuilder {
     private final EventLoop eventLoop;
     private ChannelFactory<? extends DatagramChannel> channelFactory;
     private InetSocketAddress localAddress = DnsNameResolver.ANY_LOCAL_ADDR;
-    private DnsServerAddresses nameServerAddresses;
+    private DnsServerAddresses nameServerAddresses = DefaultDnsServerAddresses.defaultAddresses();
     private DnsCache resolveCache;
     private Integer minTtl;
     private Integer maxTtl;

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -499,7 +499,7 @@ public void testResolveIp() {
         try {
             InetAddress address = resolver.resolve("10.0.0.1").syncUninterruptibly().getNow();
 
-            assertEquals("10.0.0.1", address.getHostName());
+            assertEquals("10.0.0.1", address.getHostAddress());
         } finally {
             resolver.close();
         }

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java
Patch:
@@ -33,7 +33,8 @@ public final class ZlibCodecFactory {
     private static final boolean noJdkZlibEncoder;
 
     static {
-        noJdkZlibDecoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder", true);
+        noJdkZlibDecoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder",
+                PlatformDependent.javaVersion() < 7);
         logger.debug("-Dio.netty.noJdkZlibDecoder: {}", noJdkZlibDecoder);
 
         noJdkZlibEncoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibEncoder", false);

File: buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
Patch:
@@ -635,7 +635,6 @@ public int forEachByte(int index, int length, ByteProcessor processor) {
 
     @Override
     public int forEachByteDesc(ByteProcessor processor) {
-                recordLeakNonRefCountingOperation();
         recordLeakNonRefCountingOperation();
         return super.forEachByteDesc(processor);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java
Patch:
@@ -79,10 +79,10 @@ public int hashCode() {
 
     @Override
     public boolean equals(Object o) {
-        if (!(o instanceof Attribute)) {
+        if (!(o instanceof InternalAttribute)) {
             return false;
         }
-        Attribute attribute = (Attribute) o;
+        InternalAttribute attribute = (InternalAttribute) o;
         return getName().equalsIgnoreCase(attribute.getName());
     }
 

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -548,7 +548,7 @@ static String decodeString(ByteBuf src, int readerIndex, int len, Charset charse
             try {
                 buffer.writeBytes(src, readerIndex, len);
                 // Use internalNioBuffer(...) to reduce object creation.
-                decodeString(decoder, buffer.internalNioBuffer(readerIndex, len), dst);
+                decodeString(decoder, buffer.internalNioBuffer(0, len), dst);
             } finally {
                 // Release the temporary buffer again.
                 buffer.release();

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -187,7 +187,7 @@ public <T> T readInbound() {
     }
 
     /**
-     * Read data froum the outbound. This may return {@code null} if nothing is readable.
+     * Read data from the outbound. This may return {@code null} if nothing is readable.
      */
     @SuppressWarnings("unchecked")
     public <T> T readOutbound() {

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -475,11 +475,11 @@ private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
                 // null out entries in the array to allow to have it GC'ed once the Channel close
                 // See https://github.com/netty/netty/issues/2363
                 for (;;) {
+                    i++;
                     if (selectedKeys[i] == null) {
                         break;
                     }
                     selectedKeys[i] = null;
-                    i++;
                 }
 
                 selectAgain();

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -555,7 +555,7 @@ public static int hashCodeAscii(CharSequence bytes) {
      * use {@link AtomicReferenceFieldUpdater#newUpdater(Class, Class, String)} as fallback.
      */
     public static <U, W> AtomicReferenceFieldUpdater<U, W> newAtomicReferenceFieldUpdater(
-            Class<U> tclass, String fieldName) {
+            Class<? super U> tclass, String fieldName) {
         if (hasUnsafe()) {
             try {
                 return PlatformDependent0.newAtomicReferenceFieldUpdater(tclass, fieldName);
@@ -572,7 +572,7 @@ public static <U, W> AtomicReferenceFieldUpdater<U, W> newAtomicReferenceFieldUp
      * use {@link AtomicIntegerFieldUpdater#newUpdater(Class, String)} as fallback.
      */
     public static <T> AtomicIntegerFieldUpdater<T> newAtomicIntegerFieldUpdater(
-            Class<?> tclass, String fieldName) {
+            Class<? super T> tclass, String fieldName) {
         if (hasUnsafe()) {
             try {
                 return PlatformDependent0.newAtomicIntegerFieldUpdater(tclass, fieldName);
@@ -589,7 +589,7 @@ public static <T> AtomicIntegerFieldUpdater<T> newAtomicIntegerFieldUpdater(
      * use {@link AtomicLongFieldUpdater#newUpdater(Class, String)} as fallback.
      */
     public static <T> AtomicLongFieldUpdater<T> newAtomicLongFieldUpdater(
-            Class<?> tclass, String fieldName) {
+            Class<? super T> tclass, String fieldName) {
         if (hasUnsafe()) {
             try {
                 return PlatformDependent0.newAtomicLongFieldUpdater(tclass, fieldName);

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -484,17 +484,17 @@ private static int hashCodeAsciiSanitizeFromChar(short value) {
     }
 
     static <U, W> AtomicReferenceFieldUpdater<U, W> newAtomicReferenceFieldUpdater(
-            Class<U> tclass, String fieldName) throws Exception {
+            Class<? super U> tclass, String fieldName) throws Exception {
         return new UnsafeAtomicReferenceFieldUpdater<U, W>(UNSAFE, tclass, fieldName);
     }
 
     static <T> AtomicIntegerFieldUpdater<T> newAtomicIntegerFieldUpdater(
-            Class<?> tclass, String fieldName) throws Exception {
+            Class<? super T> tclass, String fieldName) throws Exception {
         return new UnsafeAtomicIntegerFieldUpdater<T>(UNSAFE, tclass, fieldName);
     }
 
     static <T> AtomicLongFieldUpdater<T> newAtomicLongFieldUpdater(
-            Class<?> tclass, String fieldName) throws Exception {
+            Class<? super T> tclass, String fieldName) throws Exception {
         return new UnsafeAtomicLongFieldUpdater<T>(UNSAFE, tclass, fieldName);
     }
 

File: common/src/main/java/io/netty/util/internal/UnsafeAtomicIntegerFieldUpdater.java
Patch:
@@ -25,7 +25,8 @@ final class UnsafeAtomicIntegerFieldUpdater<T> extends AtomicIntegerFieldUpdater
     private final long offset;
     private final Unsafe unsafe;
 
-    UnsafeAtomicIntegerFieldUpdater(Unsafe unsafe, Class<?> tClass, String fieldName) throws NoSuchFieldException {
+    UnsafeAtomicIntegerFieldUpdater(Unsafe unsafe, Class<? super T> tClass, String fieldName)
+            throws NoSuchFieldException {
         Field field = tClass.getDeclaredField(fieldName);
         if (!Modifier.isVolatile(field.getModifiers())) {
             throw new IllegalArgumentException("Must be volatile");

File: common/src/main/java/io/netty/util/internal/UnsafeAtomicLongFieldUpdater.java
Patch:
@@ -25,7 +25,8 @@ final class UnsafeAtomicLongFieldUpdater<T> extends AtomicLongFieldUpdater<T> {
     private final long offset;
     private final Unsafe unsafe;
 
-    UnsafeAtomicLongFieldUpdater(Unsafe unsafe, Class<?> tClass, String fieldName) throws NoSuchFieldException {
+    UnsafeAtomicLongFieldUpdater(Unsafe unsafe, Class<? super T> tClass, String fieldName)
+            throws NoSuchFieldException {
         Field field = tClass.getDeclaredField(fieldName);
         if (!Modifier.isVolatile(field.getModifiers())) {
             throw new IllegalArgumentException("Must be volatile");

File: common/src/main/java/io/netty/util/internal/UnsafeAtomicReferenceFieldUpdater.java
Patch:
@@ -25,7 +25,8 @@ final class UnsafeAtomicReferenceFieldUpdater<U, M> extends AtomicReferenceField
     private final long offset;
     private final Unsafe unsafe;
 
-    UnsafeAtomicReferenceFieldUpdater(Unsafe unsafe, Class<U> tClass, String fieldName) throws NoSuchFieldException {
+    UnsafeAtomicReferenceFieldUpdater(Unsafe unsafe, Class<? super U> tClass, String fieldName)
+            throws NoSuchFieldException {
         Field field = tClass.getDeclaredField(fieldName);
         if (!Modifier.isVolatile(field.getModifiers())) {
             throw new IllegalArgumentException("Must be volatile");

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
Patch:
@@ -160,7 +160,7 @@ public SctpMessage duplicate() {
         if (msgInfo == null) {
             return new SctpMessage(protocolIdentifier, streamIdentifier, unordered, content().duplicate());
         } else {
-            return new SctpMessage(msgInfo, content().copy());
+            return new SctpMessage(msgInfo, content().duplicate());
         }
     }
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -79,7 +79,7 @@ private static DatagramChannel newSocket(SelectorProvider provider) {
              *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
              *  {@link SelectorProvider#provider()} which is called by each DatagramChannel.open() otherwise.
              *
-             *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.
+             *  See <a href="https://github.com/netty/netty/issues/2308">#2308</a>.
              */
             return provider.openDatagramChannel();
         } catch (IOException e) {

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -52,7 +52,7 @@ private static ServerSocketChannel newSocket(SelectorProvider provider) {
              *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
              *  {@link SelectorProvider#provider()} which is called by each ServerSocketChannel.open() otherwise.
              *
-             *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.
+             *  See <a href="https://github.com/netty/netty/issues/2308">#2308</a>.
              */
             return provider.openServerSocketChannel();
         } catch (IOException e) {

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -56,7 +56,7 @@ private static SocketChannel newSocket(SelectorProvider provider) {
              *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
              *  {@link SelectorProvider#provider()} which is called by each SocketChannel.open() otherwise.
              *
-             *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.
+             *  See <a href="https://github.com/netty/netty/issues/2308">#2308</a>.
              */
             return provider.openSocketChannel();
         } catch (IOException e) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
Patch:
@@ -323,9 +323,7 @@ void clearPendingWrites(Throwable cause) {
         }
     }
 
-    private final class StreamComparator implements Comparator<Integer>, Serializable {
-
-        private static final long serialVersionUID = 1161471649740544848L;
+    private final class StreamComparator implements Comparator<Integer> {
 
         StreamComparator() { }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
Patch:
@@ -28,7 +28,7 @@ public class DefaultFullHttpRequest extends DefaultHttpRequest implements FullHt
     private final HttpHeaders trailingHeader;
 
     /**
-     * Used to cache the value of the hash code and avoid {@link IllegalRefCountException}.
+     * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}.
      */
     private int hash;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
Patch:
@@ -30,7 +30,7 @@ public class DefaultFullHttpResponse extends DefaultHttpResponse implements Full
     private final HttpHeaders trailingHeaders;
 
     /**
-     * Used to cache the value of the hash code and avoid {@link IllegalRefCountException}.
+     * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}.
      */
     private int hash;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 
 /**
- * Combinate the {@link HttpRequest} and {@link FullHttpMessage}, so the request is a <i>complete</i> HTTP
+ * Combine the {@link HttpRequest} and {@link FullHttpMessage}, so the request is a <i>complete</i> HTTP
  * request.
  */
 public interface FullHttpRequest extends HttpRequest, FullHttpMessage {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -61,7 +61,7 @@ public class HttpPostRequestEncoder implements ChunkedInput<HttpContent> {
     public enum EncoderMode {
         /**
          * Legacy mode which should work for most. It is known to not work with OAUTH. For OAUTH use
-         * {@link EncoderMode#RFC3986}. The W3C form recommentations this for submitting post form data.
+         * {@link EncoderMode#RFC3986}. The W3C form recommendations this for submitting post form data.
          */
         RFC1738,
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
Patch:
@@ -323,7 +323,9 @@ void clearPendingWrites(Throwable cause) {
         }
     }
 
-    private final class StreamComparator implements Comparator<Integer> {
+    private final class StreamComparator implements Comparator<Integer>, Serializable {
+
+        private static final long serialVersionUID = 1161471649740544848L;
 
         StreamComparator() { }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -94,7 +94,7 @@ public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2Conne
     // * OK to use with server() and connection()
     private Http2FrameLogger frameLogger;
     private SensitivityDetector headerSensitivityDetector;
-    private boolean encoderEnforceMaxConcurrentStreams;
+    private Boolean encoderEnforceMaxConcurrentStreams;
 
     /**
      * Returns if HTTP headers should be validated according to
@@ -268,7 +268,7 @@ protected B frameLogger(Http2FrameLogger frameLogger) {
      * would otherwise be exceeded.
      */
     protected boolean encoderEnforceMaxConcurrentStreams() {
-        return encoderEnforceMaxConcurrentStreams;
+        return encoderEnforceMaxConcurrentStreams != null ? encoderEnforceMaxConcurrentStreams : false;
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
Patch:
@@ -323,9 +323,7 @@ void clearPendingWrites(Throwable cause) {
         }
     }
 
-    private final class StreamComparator implements Comparator<Integer>, Serializable {
-
-        private static final long serialVersionUID = 1161471649740544848L;
+    private final class StreamComparator implements Comparator<Integer> {
 
         StreamComparator() { }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
Patch:
@@ -94,7 +94,7 @@ public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2Conne
     // * OK to use with server() and connection()
     private Http2FrameLogger frameLogger;
     private SensitivityDetector headerSensitivityDetector;
-    private Boolean encoderEnforceMaxConcurrentStreams;
+    private boolean encoderEnforceMaxConcurrentStreams;
 
     /**
      * Returns if HTTP headers should be validated according to
@@ -268,7 +268,7 @@ protected B frameLogger(Http2FrameLogger frameLogger) {
      * would otherwise be exceeded.
      */
     protected boolean encoderEnforceMaxConcurrentStreams() {
-        return encoderEnforceMaxConcurrentStreams != null ? encoderEnforceMaxConcurrentStreams : false;
+        return encoderEnforceMaxConcurrentStreams;
     }
 
     /**

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateDecoderTest.java
Patch:
@@ -143,9 +143,7 @@ public void testFramementedFrame() {
         byte[] finalPayload = new byte[300];
         finalPayloadWrapped.readBytes(finalPayload);
         assertTrue(Arrays.equals(finalPayload, payload));
-        uncompressedFrame1.release();
-        uncompressedFrame2.release();
-        uncompressedFrame3.release();
+        finalPayloadWrapped.release();
     }
 
     @Test

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -494,7 +494,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      * @param minWritableBytes
      *        the expected minimum number of writable bytes
      * @throws IndexOutOfBoundsException
-     *         if {@link #writerIndex()} + {@code minWritableBytes} > {@link #maxCapacity()}
+     *         if {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}
      */
     public abstract ByteBuf ensureWritable(int minWritableBytes);
 
@@ -506,7 +506,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      * @param minWritableBytes
      *        the expected minimum number of writable bytes
      * @param force
-     *        When {@link #writerIndex()} + {@code minWritableBytes} > {@link #maxCapacity()}:
+     *        When {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}:
      *        <ul>
      *        <li>{@code true} - the capacity of the buffer is expanded to {@link #maxCapacity()}</li>
      *        <li>{@code false} - the capacity of the buffer is unchanged</li>

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java
Patch:
@@ -27,7 +27,7 @@
  * separately via {@link io.netty.handler.codec.http.cookie.ServerCookieDecoder},
  * {@link io.netty.handler.codec.http.cookie.ClientCookieDecoder},
  * {@link io.netty.handler.codec.http.cookie.ServerCookieEncoder},
- * and {@link @io.netty.handler.codec.http.cookie.ClientCookieEncoder}.
+ * and {@link io.netty.handler.codec.http.cookie.ClientCookieEncoder}.
  *
  * @see HttpResponse
  * @see io.netty.handler.codec.http.cookie.ServerCookieDecoder

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java
Patch:
@@ -24,7 +24,7 @@
  * separately via {@link io.netty.handler.codec.http.cookie.ServerCookieDecoder},
  * {@link io.netty.handler.codec.http.cookie.ClientCookieDecoder},
  * {@link io.netty.handler.codec.http.cookie.ServerCookieEncoder},
- * and {@link @io.netty.handler.codec.http.cookie.ClientCookieEncoder}.
+ * and {@link io.netty.handler.codec.http.cookie.ClientCookieEncoder}.
  *
  * @see HttpRequest
  * @see io.netty.handler.codec.http.cookie.ServerCookieDecoder

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
Patch:
@@ -35,7 +35,7 @@ public interface Http2FrameListener {
      * {@code WINDOW_UPDATE}). Returning a value equal to the length of {@code data} + {@code padding} will effectively
      * opt-out of application-level flow control for this frame. Returning a value less than the length of {@code data}
      * + {@code padding} will defer the returning of the processed bytes, which the application must later return via
-     * {@link Http2LocalFlowController#consumeBytes(ChannelHandlerContext, Http2Stream, int)}. The returned value must
+     * {@link Http2LocalFlowController#consumeBytes(Http2Stream, int)}. The returned value must
      * be >= {@code 0} and <= {@code data.readableBytes()} + {@code padding}.
      */
     int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
Patch:
@@ -134,7 +134,7 @@ public boolean distribute(int maxBytes, Writer writer) throws Http2Exception {
 
     /**
      * Sets the amount of bytes that will be allocated to each stream. Defaults to 1KiB.
-     * @param allocationQuantum the amount of bytes that will be allocated to each stream. Must be > 0.
+     * @param allocationQuantum the amount of bytes that will be allocated to each stream. Must be &gt; 0.
      */
     public void allocationQuantum(int allocationQuantum) {
         if (allocationQuantum <= 0) {

File: common/src/main/java/io/netty/util/AttributeKey.java
Patch:
@@ -47,8 +47,8 @@ public static boolean exists(String name) {
     }
 
     /**
-     * Creates a new {@link AttributeKey} for the given {@param name} or fail with an
-     * {@link IllegalArgumentException} if a {@link AttributeKey} for the given {@param name} exists.
+     * Creates a new {@link AttributeKey} for the given {@code name} or fail with an
+     * {@link IllegalArgumentException} if a {@link AttributeKey} for the given {@code name} exists.
      */
     @SuppressWarnings("unchecked")
     public static <T> AttributeKey<T> newInstance(String name) {

File: common/src/main/java/io/netty/util/ConstantPool.java
Patch:
@@ -79,8 +79,8 @@ public boolean exists(String name) {
     }
 
     /**
-     * Creates a new {@link Constant} for the given {@param name} or fail with an
-     * {@link IllegalArgumentException} if a {@link Constant} for the given {@param name} exists.
+     * Creates a new {@link Constant} for the given {@code name} or fail with an
+     * {@link IllegalArgumentException} if a {@link Constant} for the given {@code name} exists.
      */
     @SuppressWarnings("unchecked")
     public T newInstance(String name) {

File: common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java
Patch:
@@ -24,8 +24,8 @@
  * into one, by listening to individual {@link Future}s and producing an aggregated result
  * (success/failure) when all {@link Future}s have completed.
  *
- * @tparam V the type of value returned by the {@link Future}
- * @tparam F the type of {@link Future}
+ * @param <V> the type of value returned by the {@link Future}
+ * @param <F> the type of {@link Future}
  */
 public class PromiseAggregator<V, F extends Future<V>> implements GenericFutureListener<F> {
 

File: common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java
Patch:
@@ -40,7 +40,7 @@
  *     <li>{@link #poll()} and {@link #remove()}</li>
  *     <li>{@link #element()}, {@link #peek()}</li>
  *     <li>{@link #remove(Object)}, {@link #removeAll(Collection)}, and {@link #retainAll(Collection)}</li>
- *     <li>{@link #clear()}</li> {@link #}
+ *     <li>{@link #clear()}</li>
  *     <li>{@link #iterator()}</li>
  *     <li>{@link #toArray()} and {@link #toArray(Object[])}</li>
  *     <li>{@link #contains(Object)} and {@link #containsAll(Collection)}</li>

File: example/src/main/java/io/netty/example/http2/Http2ExampleUtil.java
Patch:
@@ -29,7 +29,7 @@
 public final class Http2ExampleUtil {
 
     /**
-     * Response header sent in response to the http->http2 cleartext upgrade request.
+     * Response header sent in response to the http-&gt;http2 cleartext upgrade request.
      */
     public static final String UPGRADE_RESPONSE_HEADER = "http-to-http2-upgrade";
 

File: example/src/main/java/io/netty/example/http2/helloworld/client/HttpResponseHandler.java
Patch:
@@ -59,7 +59,7 @@ public Entry<ChannelFuture, ChannelPromise> put(int streamId, ChannelFuture writ
      *
      * @param timeout Value of time to wait for each response
      * @param unit Units associated with {@code timeout}
-     * @see HttpResponseHandler#put(int, io.netty.channel.ChannelPromise)
+     * @see HttpResponseHandler#put(int, io.netty.channel.ChannelFuture, io.netty.channel.ChannelPromise)
      */
     public void awaitResponses(long timeout, TimeUnit unit) {
         Iterator<Entry<Integer, Entry<ChannelFuture, ChannelPromise>>> itr = streamidPromiseMap.entrySet().iterator();

File: microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java
Patch:
@@ -71,7 +71,7 @@ public DelegateHarnessExecutor(int maxThreads, String prefix) {
          * Set the executor (in the form of an {@link EventLoop}) which JMH will use.
          * <p>
          * This must be called before JMH requires an executor to execute objects.
-         * @param eventLoop Used as an executor by JMH to run benchmarks.
+         * @param service Used as an executor by JMH to run benchmarks.
          */
         public static void executor(EventLoop service) {
             executor = service;

File: resolver/src/main/java/io/netty/resolver/AddressResolver.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.List;
 
 /**
- * Resolves a possibility unresolved {@link {@link SocketAddress}}.
+ * Resolves a possibility unresolved {@link SocketAddress}.
  */
 public interface AddressResolver<T extends SocketAddress> extends Closeable {
 

File: testsuite/src/main/java/io/netty/testsuite/websockets/autobahn/package-info.java
Patch:
@@ -54,7 +54,7 @@
  * }
  *
  * <p>08. Run the <tt>AutobahnServer</tt> located in this package. If you are in Eclipse IDE, right click on
- * <tt>AutobahnServer.java</tt> and select Run As > Java Application.
+ * <tt>AutobahnServer.java</tt> and select Run As &gt; Java Application.
  *
  * <p>09. Run the Autobahn test <tt>wstest -m fuzzingclient -s fuzzingclient.json</tt>.
  *

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -256,7 +256,7 @@ public static Paritybit valueOf(int value) {
      *
      * @param waitTimeMillis The number of milliseconds to wait, defaulting to 0 (no
      *     wait) if unset
-     * @throws IllegalArgumentException if the supplied value is < 0
+     * @throws IllegalArgumentException if the supplied value is &lt; 0
      */
     RxtxChannelConfig setWaitTimeMillis(int waitTimeMillis);
 

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -63,8 +63,8 @@ public static boolean exists(String name) {
     }
 
     /**
-     * Creates a new {@link ChannelOption} for the given {@param name} or fail with an
-     * {@link IllegalArgumentException} if a {@link ChannelOption} for the given {@param name} exists.
+     * Creates a new {@link ChannelOption} for the given {@code name} or fail with an
+     * {@link IllegalArgumentException} if a {@link ChannelOption} for the given {@code name} exists.
      */
     @SuppressWarnings("unchecked")
     public static <T> ChannelOption<T> newInstance(String name) {

File: transport/src/main/java/io/netty/channel/MaxBytesRecvByteBufAllocator.java
Patch:
@@ -58,8 +58,8 @@ public interface MaxBytesRecvByteBufAllocator extends RecvByteBufAllocator {
     /**
      * Sets the maximum number of bytes to read for a read loop and per individual read operation.
      * If this value is greater than 1, an event loop might attempt to read multiple times to procure bytes.
-     * @param maxBytesPerRead {@see #setMaxBytesPerRead(int)}
-     * @param maxBytesPerIndividualRead {@see #setMaxBytesPerIndividualRead(int)}
+     * @param maxBytesPerRead see {@link #maxBytesPerRead(int)}
+     * @param maxBytesPerIndividualRead see {@link #maxBytesPerIndividualRead(int)}
      */
     MaxBytesRecvByteBufAllocator maxBytesPerReadPair(int maxBytesPerRead, int maxBytesPerIndividualRead);
 }

File: buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java
Patch:
@@ -24,7 +24,7 @@
 public interface ByteBufProcessor extends ByteProcessor {
 
     /**
-     * @deprecated Use {@link ByteProcessor#FIND_NULL}.
+     * @deprecated Use {@link ByteProcessor#FIND_NUL}.
      */
     ByteBufProcessor FIND_NUL = new ByteBufProcessor() {
         @Override

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -590,23 +590,23 @@ public static ByteBuf threadLocalDirectBuffer() {
     }
 
     /**
-     * Create a copy of the underlying storage from {@link value} into a byte array.
+     * Create a copy of the underlying storage from {@code buf} into a byte array.
      * The copy will start at {@link ByteBuf#readerIndex()} and copy {@link ByteBuf#readableBytes()} bytes.
      */
     public static byte[] getBytes(ByteBuf buf) {
         return getBytes(buf,  buf.readerIndex(), buf.readableBytes());
     }
 
     /**
-     * Create a copy of the underlying storage from {@link buf} into a byte array.
+     * Create a copy of the underlying storage from {@code buf} into a byte array.
      * The copy will start at {@code start} and copy {@code length} bytes.
      */
     public static byte[] getBytes(ByteBuf buf, int start, int length) {
         return getBytes(buf, start, length, true);
     }
 
     /**
-     * Return an array of the underlying storage from {@link buf} into a byte array.
+     * Return an array of the underlying storage from {@code buf} into a byte array.
      * The copy will start at {@code start} and copy {@code length} bytes.
      * If {@code copy} is true a copy will be made of the memory.
      * If {@code copy} is false the underlying storage will be shared, if possible.

File: codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
Patch:
@@ -50,7 +50,7 @@ public static String encode(String name, String value) {
     /**
      * Encodes the specified cookie into a Cookie header value.
      *
-     * @param specified the cookie
+     * @param cookie the specified cookie
      * @return a Rfc6265 style Cookie header value
      */
     @Deprecated

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1135,7 +1135,7 @@ public static boolean isContentLengthSet(HttpMessage m) {
     }
 
     /**
-     * @deprecated Use {@link AsciiString#equalsIgnoreCase(CharSequence, CharSequence)} instead.
+     * @deprecated Use {@link AsciiString#contentEqualsIgnoreCase(CharSequence, CharSequence)} instead.
      */
     @Deprecated
     public static boolean equalsIgnoreCase(CharSequence name1, CharSequence name2) {

File: codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java
Patch:
@@ -81,8 +81,7 @@ public String encode(String name, String value) {
     /**
      * Encodes the specified cookie into a Cookie header value.
      *
-     * @param specified
-     *            the cookie
+     * @param cookie the specified cookie
      * @return a Rfc6265 style Cookie header value
      */
     public String encode(Cookie cookie) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
Patch:
@@ -35,7 +35,7 @@ interface StreamState {
          * Get the amount of bytes this stream has pending to send. The actual amount written must not exceed
          * {@link #windowSize()}!
          * @return The amount of bytes this stream has pending to send.
-         * @see {@link #io.netty.handler.codec.http2.Http2CodecUtil.streamableBytes(StreamState)}
+         * @see {@link io.netty.handler.codec.http2.Http2CodecUtil#streamableBytes(StreamState)}
          */
         int pendingBytes();
 
@@ -51,7 +51,7 @@ interface StreamState {
          * an stream has been given a chance to write an empty frame, and also enables optimizations like not writing
          * empty frames in some situations (don't write headers until data can also be written).
          * @return the size of the stream's flow control window.
-         * @see {@link #io.netty.handler.codec.http2.Http2CodecUtil.streamableBytes(StreamState)}
+         * @see {@link io.netty.handler.codec.http2.Http2CodecUtil#streamableBytes(StreamState)}
          */
         int windowSize();
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
Patch:
@@ -134,7 +134,7 @@ public boolean distribute(int maxBytes, Writer writer) throws Http2Exception {
 
     /**
      * Sets the amount of bytes that will be allocated to each stream. Defaults to 1KiB.
-     * @param minAllocationChunk the amount of bytes that will be allocated to each stream. Must be > 0.
+     * @param allocationQuantum the amount of bytes that will be allocated to each stream. Must be > 0.
      */
     public void allocationQuantum(int allocationQuantum) {
         if (allocationQuantum <= 0) {

File: codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
Patch:
@@ -346,7 +346,7 @@ protected abstract Object newContinueResponse(S start, int maxContentLength, Cha
 
     /**
      * Determine if the channel should be closed after the result of {@link #newContinueResponse(Object)} is written.
-     * @param The return value from {@link #newContinueResponse(Object)}.
+     * @param msg The return value from {@link #newContinueResponse(Object)}.
      * @return {@code true} if the channel should be closed after the result of {@link #newContinueResponse(Object)}
      * is written. {@code false} otherwise.
      */
@@ -356,7 +356,7 @@ protected abstract Object newContinueResponse(S start, int maxContentLength, Cha
      * Determine if all objects for the current request/response should be ignored or not.
      * Messages will stop being ignored the next time {@link #isContentMessage(Object)} returns {@code true}.
      *
-     * @param The return value from {@link #newContinueResponse(Object)}.
+     * @param msg The return value from {@link #newContinueResponse(Object)}.
      * @return {@code true} if all objects for the current request/response should be ignored or not.
      * {@code false} otherwise.
      */

File: common/src/main/java/io/netty/util/HashingStrategy.java
Patch:
@@ -57,8 +57,8 @@ public interface HashingStrategy<T> {
     boolean equals(T a, T b);
 
     /**
-     * A {@link HashingStrategy} which delegates to java's {@link ObjectUtil#hashCode(Object)}
-     * and {@link ObjectUtil#equals(Object, Object)}.
+     * A {@link HashingStrategy} which delegates to java's {@link Object#hashCode()}
+     * and {@link Object#equals(Object)}.
      */
     @SuppressWarnings("rawtypes")
     HashingStrategy JAVA_HASHER = new HashingStrategy() {

File: common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java
Patch:
@@ -24,8 +24,8 @@
  * into one, by listening to individual {@link Future}s and producing an aggregated result
  * (success/failure) when all {@link Future}s have completed.
  *
- * @param V the type of value returned by the {@link Future}
- * @param F the type of {@link Future}
+ * @tparam V the type of value returned by the {@link Future}
+ * @tparam F the type of {@link Future}
  */
 public class PromiseAggregator<V, F extends Future<V>> implements GenericFutureListener<F> {
 

File: handler/src/main/java/io/netty/handler/stream/ChunkedInput.java
Patch:
@@ -57,7 +57,7 @@ public interface ChunkedInput<B> {
      * and thus the stream has reached at its end, any subsequent {@link #isEndOfInput()}
      * call must return {@code true}.
      *
-     * @param a {@link ByteBufAllocator} if buffer allocation is necessary.
+     * @param allocator {@link ByteBufAllocator} if buffer allocation is necessary.
      * @return the fetched chunk.
      *         {@code null} if there is no data left in the stream.
      *         Please note that {@code null} does not necessarily mean that the

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
Patch:
@@ -278,7 +278,6 @@ public DnsNameResolverBuilder optResourceEnabled(boolean optResourceEnabled) {
     /**
      * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to first check
      *                                 if the hostname is locally aliased.
-     * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver}
      * @return {@code this}
      */
     public DnsNameResolverBuilder hostsFileEntriesResolver(HostsFileEntriesResolver hostsFileEntriesResolver) {

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -293,7 +293,6 @@ public ChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
      * @param allocator the allocator to set.
      * @param metadata Used to set the {@link ChannelMetadata#defaultMaxMessagesPerRead()} if {@code allocator}
      * is of type {@link MaxMessagesRecvByteBufAllocator}.
-     * @return this
      */
     private void setRecvByteBufAllocator(RecvByteBufAllocator allocator, ChannelMetadata metadata) {
         if (allocator instanceof MaxMessagesRecvByteBufAllocator) {

File: transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java
Patch:
@@ -91,8 +91,6 @@ interface Handle {
 
         /**
          * Determine if the current read loop should should continue.
-         * @param totalMessages The total number of messages read so far by this read loop.
-         * @param lastReadBytes The number of bytes read from the previous read operation.
          * @return {@code true} if the read loop should continue reading. {@code false} if the read loop is complete.
          */
         boolean continueReading();

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.stream;
 
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelDuplexHandler;
@@ -203,6 +204,7 @@ private boolean doFlush(final ChannelHandlerContext ctx) throws Exception {
         }
 
         boolean flushed = false;
+        ByteBufAllocator allocator = ctx.alloc();
         while (channel.isWritable()) {
             if (currentWrite == null) {
                 currentWrite = queue.poll();
@@ -220,7 +222,7 @@ private boolean doFlush(final ChannelHandlerContext ctx) throws Exception {
                 boolean suspend;
                 Object message = null;
                 try {
-                    message = chunks.readChunk(ctx);
+                    message = chunks.readChunk(allocator);
                     endOfInput = chunks.isEndOfInput();
 
                     if (message == null) {

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -741,7 +741,7 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
     ChannelPipeline fireChannelRead(Object msg);
 
     /**
-     * Triggers an {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}
+     * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}
      * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      */
     ChannelPipeline fireChannelReadComplete();

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -101,7 +101,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
 
             // set new content encoding,
             CharSequence targetContentEncoding = getTargetContentEncoding(contentEncoding);
-            if (HttpHeaderValues.IDENTITY.equals(targetContentEncoding)) {
+            if (HttpHeaderValues.IDENTITY.contentEquals(targetContentEncoding)) {
                 // Do NOT set the 'Content-Encoding' header if the target encoding is 'identity'
                 // as per: http://tools.ietf.org/html/rfc2616#section-14.11
                 headers.remove(HttpHeaderNames.CONTENT_ENCODING);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -60,7 +60,7 @@ public DefaultHttp2RemoteFlowController(Http2Connection connection,
     }
 
     public DefaultHttp2RemoteFlowController(Http2Connection connection, final Listener listener) {
-        this(connection, new PriorityStreamByteDistributor(connection), listener);
+        this(connection, new WeightedFairQueueByteDistributor(connection), listener);
     }
 
     public DefaultHttp2RemoteFlowController(Http2Connection connection,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -49,7 +49,6 @@
 import static java.lang.Math.min;
 import static java.lang.String.format;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
  * Provides the default implementation for processing inbound frame events and delegates to a

File: codec-http2/src/main/java/io/netty/handler/codec/http2/PriorityStreamByteDistributor.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.Arrays;
 
+import static io.netty.handler.codec.http2.Http2CodecUtil.streamableBytes;
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
@@ -78,7 +79,7 @@ public void onPriorityTreeParentChanging(Http2Stream stream, Http2Stream newPare
 
     @Override
     public void updateStreamableBytes(StreamState streamState) {
-        state(streamState.stream()).updateStreamableBytes(streamState.streamableBytes(),
+        state(streamState.stream()).updateStreamableBytes(streamableBytes(streamState),
                 streamState.hasFrame());
     }
 

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -94,8 +94,7 @@
  *   // from 1.
  *   {@code @Override}
  *   public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {
- *     {@link Attribute}&lt;{@link Integer}&gt; attr = ctx.getAttr(counter);
- *     Integer a = ctx.getAttr(counter).get();
+ *     Integer a = ctx.attr(counter).get();
  *
  *     if (a == null) {
  *       a = 1;
@@ -152,7 +151,7 @@ public interface ChannelHandlerContext extends AttributeMap {
     ChannelHandler handler();
 
     /**
-     * Return {@code true} if the {@link ChannelHandler} which belongs to this {@link ChannelHandler} was removed
+     * Return {@code true} if the {@link ChannelHandler} which belongs to this context was removed
      * from the {@link ChannelPipeline}. Note that this method is only meant to be called from with in the
      * {@link EventLoop}.
      */

File: example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
 import io.netty.handler.codec.http.cors.CorsConfig;
+import io.netty.handler.codec.http.cors.CorsConfigBuilder;
 import io.netty.handler.codec.http.cors.CorsHandler;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.stream.ChunkedWriteHandler;
@@ -79,7 +80,7 @@ public HttpCorsServerInitializer(SslContext sslCtx) {
 
     @Override
     public void initChannel(SocketChannel ch) {
-        CorsConfig corsConfig = CorsConfig.withAnyOrigin().build();
+        CorsConfig corsConfig = CorsConfigBuilder.forAnyOrigin().build();
         ChannelPipeline pipeline = ch.pipeline();
         if (sslCtx != null) {
             pipeline.addLast(sslCtx.newHandler(ch.alloc()));

File: codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
Patch:
@@ -43,8 +43,6 @@ public final class UniformStreamByteDistributor implements StreamByteDistributor
     private long totalStreamableBytes;
 
     public UniformStreamByteDistributor(Http2Connection connection) {
-        checkNotNull(connection, "connection");
-
         // Add a state for the connection.
         stateKey = connection.newKey();
         Http2Stream connectionStream = connection.connectionStream();

File: microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java
Patch:
@@ -38,8 +38,8 @@ public class AbstractSharedExecutorMicrobenchmark extends AbstractMicrobenchmark
 
     static {
         final String[] customArgs = {
-        "-Xms2g", "-Xmx2g", "-XX:MaxDirectMemorySize=2g", "-Dharness.executor=CUSTOM",
-    "-Dharness.executor.class=AbstractSharedExecutorMicrobenchmark$DelegateHarnessExecutor" };
+        "-Xms2g", "-Xmx2g", "-XX:MaxDirectMemorySize=2g", "-Djmh.executor=CUSTOM",
+        "-Djmh.executor.class=io.netty.microbench.util.AbstractSharedExecutorMicrobenchmark$DelegateHarnessExecutor" };
 
         JVM_ARGS = new String[BASE_JVM_ARGS.length + customArgs.length];
         System.arraycopy(BASE_JVM_ARGS, 0, JVM_ARGS, 0, BASE_JVM_ARGS.length);

File: resolver/src/main/java/io/netty/resolver/DefaultNameResolver.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.util.concurrent.Promise;
 
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.List;

File: resolver/src/main/java/io/netty/resolver/InetNameResolver.java
Patch:
@@ -37,7 +37,8 @@ protected InetNameResolver(EventExecutor executor) {
     }
 
     /**
-     * Creates a new {@link AddressResolver} that will use this name resolver underneath.
+     * Return a {@link AddressResolver} that will use this name resolver underneath.
+     * It's cached internally, so the same instance is always returned.
      */
     public AddressResolver<InetSocketAddress> asAddressResolver() {
         AddressResolver<InetSocketAddress> result = addressResolver;

File: resolver/src/main/java/io/netty/resolver/InetSocketAddressResolver.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.Promise;
 
 import java.net.InetAddress;
@@ -53,7 +53,7 @@ protected void doResolve(final InetSocketAddress unresolvedAddress, final Promis
         // Note that InetSocketAddress.getHostName() will never incur a reverse lookup here,
         // because an unresolved address always has a host name.
         nameResolver.resolve(unresolvedAddress.getHostName())
-                .addListener(new GenericFutureListener<Future<InetAddress>>() {
+                .addListener(new FutureListener<InetAddress>() {
                     @Override
                     public void operationComplete(Future<InetAddress> future) throws Exception {
                         if (future.isSuccess()) {
@@ -71,7 +71,7 @@ protected void doResolveAll(final InetSocketAddress unresolvedAddress,
         // Note that InetSocketAddress.getHostName() will never incur a reverse lookup here,
         // because an unresolved address always has a host name.
         nameResolver.resolveAll(unresolvedAddress.getHostName())
-                .addListener(new GenericFutureListener<Future<List<InetAddress>>>() {
+                .addListener(new FutureListener<List<InetAddress>>() {
                     @Override
                     public void operationComplete(Future<List<InetAddress>> future) throws Exception {
                         if (future.isSuccess()) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
Patch:
@@ -482,7 +482,7 @@ protected void initChannel(Channel ch) throws Exception {
                 serverFrameCountDown =
                         new FrameCountDown(serverListener, serverSettingsAckLatch,
                                 requestLatch, dataLatch, trailersLatch, goAwayLatch);
-                p.addLast(new Http2ConnectionHandler.Builder()
+                p.addLast(new Http2ConnectionHandlerBuilder()
                         .server(true)
                         .frameListener(serverFrameCountDown)
                         .validateHeaders(false)
@@ -496,7 +496,7 @@ protected void initChannel(Channel ch) throws Exception {
             @Override
             protected void initChannel(Channel ch) throws Exception {
                 ChannelPipeline p = ch.pipeline();
-                p.addLast(new Http2ConnectionHandler.Builder()
+                p.addLast(new Http2ConnectionHandlerBuilder()
                         .server(false)
                         .frameListener(clientListener)
                         .validateHeaders(false)

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java
Patch:
@@ -508,7 +508,7 @@ protected void initChannel(Channel ch) throws Exception {
                 ChannelPipeline p = ch.pipeline();
                 serverFrameCountDown =
                         new FrameCountDown(serverListener, serverSettingsAckLatch, requestLatch, null, trailersLatch);
-                p.addLast(new HttpToHttp2ConnectionHandler.Builder()
+                p.addLast(new HttpToHttp2ConnectionHandlerBuilder()
                            .server(true)
                            .frameListener(serverFrameCountDown)
                            .build());
@@ -521,7 +521,7 @@ protected void initChannel(Channel ch) throws Exception {
             @Override
             protected void initChannel(Channel ch) throws Exception {
                 ChannelPipeline p = ch.pipeline();
-                HttpToHttp2ConnectionHandler handler = new HttpToHttp2ConnectionHandler.Builder()
+                HttpToHttp2ConnectionHandler handler = new HttpToHttp2ConnectionHandlerBuilder()
                         .server(false)
                         .frameListener(clientListener)
                         .gracefulShutdownTimeoutMillis(0)

File: codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
Patch:
@@ -115,8 +115,9 @@ public void setup() throws Exception {
         encoder = new StreamBufferingEncoder(defaultEncoder);
         DefaultHttp2ConnectionDecoder decoder =
                 new DefaultHttp2ConnectionDecoder(connection, encoder, mock(Http2FrameReader.class));
-        Http2ConnectionHandler handler = new Http2ConnectionHandler.Builder()
-                .frameListener(mock(Http2FrameListener.class)).build(decoder, encoder);
+        Http2ConnectionHandler handler = new Http2ConnectionHandlerBuilder()
+                .frameListener(mock(Http2FrameListener.class))
+                .codec(decoder, encoder).build();
 
         // Set LifeCycleManager on encoder and decoder
         when(ctx.channel()).thenReturn(channel);

File: example/src/main/java/io/netty/example/http2/helloworld/server/Http2OrHttpHandler.java
Patch:
@@ -35,7 +35,7 @@ protected Http2OrHttpHandler() {
     @Override
     protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {
         if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {
-            ctx.pipeline().addLast(new HelloWorldHttp2Handler.Builder().build());
+            ctx.pipeline().addLast(new HelloWorldHttp2HandlerBuilder().build());
             return;
         }
 

File: example/src/main/java/io/netty/example/http2/helloworld/server/Http2ServerInitializer.java
Patch:
@@ -43,7 +43,7 @@ public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
         @Override
         public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
             if (AsciiString.contentEquals(Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME, protocol)) {
-                return new Http2ServerUpgradeCodec(new HelloWorldHttp2Handler.Builder().build());
+                return new Http2ServerUpgradeCodec(new HelloWorldHttp2HandlerBuilder().build());
             } else {
                 return null;
             }

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -530,7 +530,7 @@ public boolean contentEqualsIgnoreCase(CharSequence string) {
         if (string.getClass() == AsciiString.class) {
             AsciiString rhs = (AsciiString) string;
             for (int i = arrayOffset(), j = rhs.arrayOffset(); i < length(); ++i, ++j) {
-                if (!equalsIgnoreCase(value[i], value[j])) {
+                if (!equalsIgnoreCase(value[i], rhs.value[j])) {
                     return false;
                 }
             }

File: common/src/main/java/io/netty/util/AsciiString.java
Patch:
@@ -276,7 +276,7 @@ public int forEachByte(int index, int length, ByteProcessor visitor) throws Exce
     }
 
     private int forEachByte0(int index, int length, ByteProcessor visitor) throws Exception {
-        final int len = offset + length;
+        final int len = offset + index + length;
         for (int i = offset + index; i < len; ++i) {
             if (!visitor.process(value[i])) {
                 return i - offset;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -100,6 +100,7 @@ protected Promise<T> promise() {
     }
 
     void resolve() {
+        InetSocketAddress nameServerAddrToTry = nameServerAddrs.next();
         for (InternetProtocolFamily f: resolveAddressTypes) {
             final DnsRecordType type;
             switch (f) {
@@ -113,7 +114,7 @@ void resolve() {
                 throw new Error();
             }
 
-            query(nameServerAddrs.next(), new DefaultDnsQuestion(hostname, type));
+            query(nameServerAddrToTry, new DefaultDnsQuestion(hostname, type));
         }
     }
 

File: handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
Patch:
@@ -34,7 +34,7 @@ private static SslContext makeSslContext() throws Exception {
         File keyFile = new File(SniHandlerTest.class.getResource("test_encrypted.pem").getFile());
         File crtFile = new File(SniHandlerTest.class.getResource("test.crt").getFile());
 
-        return new JdkSslServerContext(crtFile, keyFile, "12345");
+        return SslContextBuilder.forServer(crtFile, keyFile, "12345").build();
     }
 
     @Test

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java
Patch:
@@ -261,7 +261,7 @@ private void setUpgradeRequestHeaders(ChannelHandlerContext ctx, HttpRequest req
             builder.append(part);
             builder.append(',');
         }
-        builder.append(HttpHeaderNames.UPGRADE);
+        builder.append(HttpHeaderValues.UPGRADE);
         request.headers().set(HttpHeaderNames.CONNECTION, builder.toString());
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java
Patch:
@@ -193,9 +193,9 @@ public final class HttpHeaderValues {
      */
     public static final AsciiString TRAILERS = new AsciiString("trailers");
     /**
-     * {@code "Upgrade"}
+     * {@code "upgrade"}
      */
-    public static final AsciiString UPGRADE = new AsciiString("Upgrade");
+    public static final AsciiString UPGRADE = new AsciiString("upgrade");
     /**
      * {@code "websocket"}
      */

File: microbench/src/main/java/io/netty/microbench/http2/NoPriorityByteDistributionBenchmark.java
Patch:
@@ -495,6 +495,7 @@ public <T> boolean hasAttr(AttributeKey<T> key) {
     }
 
     private static class TestChannel extends AbstractChannel {
+        private static final ChannelMetadata TEST_METADATA = new ChannelMetadata(false);
         private DefaultChannelConfig config = new DefaultChannelConfig(this);
 
         private class TestUnsafe extends AbstractUnsafe {
@@ -536,7 +537,7 @@ public boolean isActive() {
 
         @Override
         public ChannelMetadata metadata() {
-            return null;
+            return TEST_METADATA;
         }
 
         @Override

File: transport/src/test/java/io/netty/channel/AbstractChannelTest.java
Patch:
@@ -99,7 +99,7 @@ private void checkForHandlerException(Capture<Throwable> throwable) throws Throw
     }
 
     private static class TestChannel extends AbstractChannel {
-
+        private static final ChannelMetadata TEST_METADATA = new ChannelMetadata(false);
         private class TestUnsafe extends AbstractUnsafe {
 
             @Override
@@ -127,7 +127,7 @@ public boolean isActive() {
 
         @Override
         public ChannelMetadata metadata() {
-            return null;
+            return TEST_METADATA;
         }
 
         @Override

File: transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
Patch:
@@ -127,6 +127,7 @@ private static void release(ChannelOutboundBuffer buffer) {
     }
 
     private static final class TestChannel extends AbstractChannel {
+        private static final ChannelMetadata TEST_METADATA = new ChannelMetadata(false);
         private final ChannelConfig config = new DefaultChannelConfig(this);
 
         TestChannel() {
@@ -195,7 +196,7 @@ public boolean isActive() {
 
         @Override
         public ChannelMetadata metadata() {
-            throw new UnsupportedOperationException();
+            return TEST_METADATA;
         }
 
         final class TestUnsafe extends AbstractUnsafe {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -409,7 +409,8 @@ public void write(ChannelHandlerContext ctx, int allowedBytes) {
             }
             promise.addListener(this);
 
-            frameWriter().writeHeaders(ctx, stream.id(), headers, streamDependency, weight, exclusive,
+            stream.headerSent();
+            frameWriter.writeHeaders(ctx, stream.id(), headers, streamDependency, weight, exclusive,
                     padding, endOfStream, promise);
         }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
Patch:
@@ -316,11 +316,11 @@ public void writeRstOnClosedStreamShouldSucceed() throws Exception {
         when(frameWriter.writeRstStream(eq(ctx), eq(STREAM_ID),
                 anyLong(), any(ChannelPromise.class))).thenReturn(future);
         when(stream.state()).thenReturn(CLOSED);
+        when(stream.isHeaderSent()).thenReturn(true);
         // The stream is "closed" but is still known about by the connection (connection().stream(..)
         // will return the stream). We should still write a RST_STREAM frame in this scenario.
         handler.resetStream(ctx, STREAM_ID, STREAM_CLOSED.code(), promise);
-        verify(frameWriter).writeRstStream(eq(ctx), eq(STREAM_ID), anyLong(),
-                any(ChannelPromise.class));
+        verify(frameWriter).writeRstStream(eq(ctx), eq(STREAM_ID), anyLong(), any(ChannelPromise.class));
     }
 
     @SuppressWarnings("unchecked")

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -33,7 +33,6 @@
 public class ChannelOption<T> extends AbstractConstant<ChannelOption<T>> {
 
     private static final ConstantPool<ChannelOption<Object>> pool = new ConstantPool<ChannelOption<Object>>() {
-        @SuppressWarnings("deprecation")
         @Override
         protected ChannelOption<Object> newConstant(int id, String name) {
             return new ChannelOption<Object>(id, name);
@@ -91,8 +90,8 @@ public static <T> ChannelOption<T> newInstance(String name) {
     /**
      * @deprecated From version 5.0, {@link Channel} will not be closed on write failure.
      *
-     * {@code true} if and only if the {@link Channel} is closed automatically and immediately on write failure.
-     * The default is {@code false}.
+     * If {@code true} then the {@link Channel} is closed automatically and immediately on write failure.
+     * The default value is {@code true}.
      */
     @Deprecated
     public static final ChannelOption<Boolean> AUTO_CLOSE = valueOf("AUTO_CLOSE");

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -78,7 +78,6 @@ public DefaultHttp2FrameReader() {
     /**
      * Create a new instance.
      * @param validateHeaders {@code true} to validate headers. {@code false} to not validate headers.
-     * @see #DefaultHttp2HeadersDecoder(boolean)
      */
     public DefaultHttp2FrameReader(boolean validateHeaders) {
         this(new DefaultHttp2HeadersDecoder(validateHeaders));

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java
Patch:
@@ -24,7 +24,8 @@
  */
 public interface Http2DataWriter {
     /**
-     * Writes a {@code DATA} frame to the remote endpoint.
+     * Writes a {@code DATA} frame to the remote endpoint. This will result in one or more
+     * frames being written to the context.
      *
      * @param ctx the context to use for writing.
      * @param streamId the stream for which to send the frame.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapter.java
Patch:
@@ -209,7 +209,7 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe
                 throw connectionError(PROTOCOL_ERROR, "Priority Frame recieved for unknown stream id %d", streamId);
             }
 
-            Http2Headers http2Headers = new DefaultHttp2Headers();
+            Http2Headers http2Headers = new DefaultHttp2Headers(validateHttpHeaders, httpHeaders.size());
             initializePseudoHeaders(http2Headers);
             addHttpHeadersToHttp2Headers(httpHeaders, http2Headers);
             msg = newMessage(streamId, http2Headers, validateHttpHeaders);

File: transport/src/main/java/io/netty/channel/EventLoop.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * Will handle all the I/O operations for a {@link Channel} once registered.
  *
- * One {@link EventLoop} instance will usually handle more then one {@link Channel} but this may depend on
+ * One {@link EventLoop} instance will usually handle more than one {@link Channel} but this may depend on
  * implementation details and internals.
  *
  */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/PriorityStreamByteDistributor.java
Patch:
@@ -346,6 +346,7 @@ void resetAllocated() {
         }
 
         void updateStreamableBytes(int newStreamableBytes, boolean hasFrame) {
+            assert hasFrame || newStreamableBytes == 0;
             this.hasFrame = hasFrame;
 
             int delta = newStreamableBytes - streamableBytes;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/PriorityStreamByteDistributorTest.java
Patch:
@@ -136,10 +136,10 @@ public void connectionErrorForWriterException() throws Http2Exception {
 
         doNothing().when(writer).write(same(stream(STREAM_C)), eq(3));
         write(10);
-        verifyWrite(atMost(1), STREAM_A, 1);
-        verifyWrite(atMost(1), STREAM_B, 2);
+        verifyWrite(STREAM_A, 1);
+        verifyWrite(STREAM_B, 2);
         verifyWrite(times(2), STREAM_C, 3);
-        verifyWrite(atMost(1), STREAM_D, 4);
+        verifyWrite(STREAM_D, 4);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
Patch:
@@ -15,10 +15,10 @@
 
 package io.netty.handler.codec.http2;
 
-import com.twitter.hpack.Decoder;
-import com.twitter.hpack.HeaderListener;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
+import io.netty.handler.codec.http2.hpack.Decoder;
+import io.netty.handler.codec.http2.hpack.HeaderListener;
 import io.netty.util.AsciiString;
 
 import java.io.IOException;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
Patch:
@@ -15,9 +15,9 @@
 
 package io.netty.handler.codec.http2;
 
-import com.twitter.hpack.Encoder;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
+import io.netty.handler.codec.http2.hpack.Encoder;
 import io.netty.util.AsciiString;
 
 import java.io.ByteArrayOutputStream;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
Patch:
@@ -15,9 +15,9 @@
 
 package io.netty.handler.codec.http2;
 
-import com.twitter.hpack.Encoder;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.http2.hpack.Encoder;
 import io.netty.util.AsciiString;
 import org.junit.Before;
 import org.junit.Test;

File: microbench/src/main/java/io/netty/microbench/internal/PlatformDependentBenchmark.java
Patch:
@@ -51,7 +51,7 @@ public void setup() {
     @Benchmark
     @BenchmarkMode(Mode.Throughput)
     public boolean unsafeBytesEqual() {
-        return PlatformDependent.equals(bytes1, 0, bytes1.length, bytes2, 0, bytes2.length);
+        return PlatformDependent.equals(bytes1, 0, bytes2, 0, bytes1.length);
     }
 
     @Benchmark

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -62,9 +62,9 @@ public DefaultHttp2ConnectionDecoder(Http2Connection connection,
         this.encoder = checkNotNull(encoder, "encoder");
         this.requestVerifier = checkNotNull(requestVerifier, "requestVerifier");
         if (connection.local().flowController() == null) {
-            connection.local().flowController(
-                    new DefaultHttp2LocalFlowController(connection, encoder.frameWriter()));
+            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));
         }
+        connection.local().flowController().frameWriter(encoder.frameWriter());
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -772,7 +772,8 @@ protected void onConnectionError(ChannelHandlerContext ctx, Throwable cause, Htt
      * @param cause the exception that was caught
      * @param http2Ex the {@link StreamException} that is embedded in the causality chain.
      */
-    protected void onStreamError(ChannelHandlerContext ctx, Throwable cause, StreamException http2Ex) {
+    protected void onStreamError(ChannelHandlerContext ctx, @SuppressWarnings("unused") Throwable cause,
+                                 StreamException http2Ex) {
         resetStream(ctx, http2Ex.streamId(), http2Ex.error().code(), ctx.newPromise());
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java
Patch:
@@ -221,6 +221,7 @@ public void dataReadForUnknownStreamShouldApplyFlowControlAndFail() throws Excep
                 verify(localFlow)
                         .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));
                 verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));
+                verify(localFlow).frameWriter(any(Http2FrameWriter.class));
                 verifyNoMoreInteractions(localFlow);
                 verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());
             } finally {
@@ -240,6 +241,7 @@ public void dataReadForUnknownStreamShouldApplyFlowControl() throws Exception {
             verify(localFlow)
                     .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));
             verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));
+            verify(localFlow).frameWriter(any(Http2FrameWriter.class));
             verifyNoMoreInteractions(localFlow);
 
             // Verify that the event was absorbed and not propagated to the observer.

File: codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
Patch:
@@ -105,6 +105,8 @@ public void setup() throws Exception {
                 .thenAnswer(successAnswer());
 
         connection = new DefaultHttp2Connection(false);
+        connection.remote().flowController(new DefaultHttp2RemoteFlowController(connection));
+        connection.local().flowController(new DefaultHttp2LocalFlowController(connection).frameWriter(writer));
 
         DefaultHttp2ConnectionEncoder defaultEncoder =
                 new DefaultHttp2ConnectionEncoder(connection, writer);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -738,8 +738,7 @@ protected final void writePendingBytes(Writer writer) throws Http2Exception {
             }
         }
 
-        protected final boolean initialWindowSize(int newWindowSize, Writer writer)
-                throws Http2Exception {
+        protected final boolean initialWindowSize(int newWindowSize, Writer writer) throws Http2Exception {
             if (newWindowSize < 0) {
                 throw new IllegalArgumentException("Invalid initial window size: " + newWindowSize);
             }

File: buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.nio.ByteOrder;
 
+import static io.netty.util.internal.PlatformDependent.BIG_ENDIAN_NATIVE_ORDER;
+
 /**
  * Special {@link SwappedByteBuf} for {@link ByteBuf}s that is using unsafe.
  */
@@ -30,7 +32,7 @@ abstract class AbstractUnsafeSwappedByteBuf extends SwappedByteBuf {
         super(buf);
         assert PlatformDependent.isUnaligned();
         wrapped = buf;
-        nativeByteOrder = UnsafeByteBufUtil.BIG_ENDIAN_NATIVE_ORDER == (order() == ByteOrder.BIG_ENDIAN);
+        nativeByteOrder = BIG_ENDIAN_NATIVE_ORDER == (order() == ByteOrder.BIG_ENDIAN);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java
Patch:
@@ -36,7 +36,8 @@ public CombinedHttpHeaders(boolean validate) {
         super(new CombinedHttpHeadersImpl(CASE_INSENSITIVE_HASHER, valueConverter(validate), nameValidator(validate)));
     }
 
-    private static final class CombinedHttpHeadersImpl extends DefaultHeaders<CharSequence> {
+    private static final class CombinedHttpHeadersImpl
+            extends DefaultHeaders<CharSequence, CharSequence, CombinedHttpHeadersImpl> {
         /**
          * An estimate of the size of a header value.
          */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeaderTableListSize.java
Patch:
@@ -14,9 +14,6 @@
  */
 package io.netty.handler.codec.http2;
 
-import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
-import static io.netty.handler.codec.http2.Http2Exception.connectionError;
-
 /**
  * Provides common functionality for {@link Http2HeaderTable}
  */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.ByteString;
 
 /**
  * Encodes {@link Http2Headers} into HPACK-encoded headers blocks.
@@ -47,7 +46,7 @@ interface SensitivityDetector {
          * <a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-7.1.3">sensitive</a>.
          * {@code false} otherwise.
          */
-        boolean isSensitive(ByteString name, ByteString value);
+        boolean isSensitive(CharSequence name, CharSequence value);
     }
 
     /**
@@ -68,7 +67,7 @@ interface SensitivityDetector {
      */
     SensitivityDetector NEVER_SENSITIVE = new SensitivityDetector() {
         @Override
-        public boolean isSensitive(ByteString name, ByteString value) {
+        public boolean isSensitive(CharSequence name, CharSequence value) {
             return false;
         }
     };

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2FrameIOTest.java
Patch:
@@ -25,7 +25,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.AsciiString;
-import io.netty.util.ByteString;
 import io.netty.util.CharsetUtil;
 import io.netty.util.concurrent.EventExecutor;
 import org.junit.After;
@@ -381,7 +380,7 @@ private static Http2Headers largeHeaders() {
     }
 
     private Http2Headers headersOfSize(final int minSize) {
-        final ByteString singleByte = new ByteString(new byte[]{0});
+        final AsciiString singleByte = new AsciiString(new byte[]{0}, false);
         DefaultHttp2Headers headers = new DefaultHttp2Headers(false);
         for (int size = 0; size < minSize; size += 2) {
             headers.add(singleByte, singleByte);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.util.AsciiString;
-import io.netty.util.ByteString;
 
 import java.util.List;
 import java.util.Random;
@@ -71,8 +70,8 @@ public static byte[] randomBytes(int size) {
     /**
      * Returns an {@link AsciiString} that wraps a randomly-filled byte array.
      */
-    public static ByteString randomString() {
-        return new ByteString(randomBytes());
+    public static AsciiString randomString() {
+        return new AsciiString(randomBytes());
     }
 
     public static CharSequence of(String s) {

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -87,7 +87,7 @@ public final class PlatformDependent {
     private static final int BIT_MODE = bitMode0();
 
     private static final int ADDRESS_SIZE = addressSize0();
-    private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
+    public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
 
     static {
         if (logger.isDebugEnabled()) {

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -133,7 +133,7 @@ private void query(InetSocketAddress nameServerAddr, final DnsQuestion question)
             public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {
                 queriesInProgress.remove(future);
 
-                if (promise.isDone()) {
+                if (promise.isDone() || future.isCancelled()) {
                     return;
                 }
 

File: microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmark.java
Patch:
@@ -36,8 +36,8 @@ public class AbstractMicrobenchmark extends AbstractMicrobenchmarkBase {
 
     static {
         final String[] customArgs = {
-        "-Xms768m", "-Xmx768m", "-XX:MaxDirectMemorySize=768m", "-Dharness.executor=CUSTOM",
-        "-Dharness.executor.class=AbstractMicrobenchmark$HarnessExecutor" };
+        "-Xms768m", "-Xmx768m", "-XX:MaxDirectMemorySize=768m", "-Djmh.executor=CUSTOM",
+        "-Djmh.executor.class=io.netty.microbench.util.AbstractMicrobenchmark$HarnessExecutor" };
 
         JVM_ARGS = new String[BASE_JVM_ARGS.length + customArgs.length];
         System.arraycopy(BASE_JVM_ARGS, 0, JVM_ARGS, 0, BASE_JVM_ARGS.length);
@@ -59,7 +59,6 @@ protected String[] jvmArgs() {
 
     protected ChainedOptionsBuilder newOptionsBuilder() throws Exception {
         ChainedOptionsBuilder runnerOptions = super.newOptionsBuilder();
-
         if (getForks() > 0) {
             runnerOptions.forks(getForks());
         }

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -836,7 +836,8 @@ private final class LateListeners extends ArrayDeque<GenericFutureListener<?>> i
 
         @Override
         public void run() {
-            if (listeners == null) {
+            final EventExecutor executor = executor();
+            if (listeners == null || executor == ImmediateEventExecutor.INSTANCE) {
                 for (;;) {
                     GenericFutureListener<?> l = poll();
                     if (l == null) {
@@ -847,7 +848,7 @@ public void run() {
             } else {
                 // Reschedule until the initial notification is done to avoid the race condition
                 // where the notification is made in an incorrect order.
-                execute(executor(), this);
+                execute(executor, this);
             }
         }
     }

File: transport/src/main/java/io/netty/channel/DefaultMessageSizeEstimator.java
Patch:
@@ -47,9 +47,9 @@ public int size(Object msg) {
     }
 
     /**
-     * Return the default implementation which returns {@code -1} for unknown messages.
+     * Return the default implementation which returns {@code 8} for unknown messages.
      */
-    public static final MessageSizeEstimator DEFAULT = new DefaultMessageSizeEstimator(0);
+    public static final MessageSizeEstimator DEFAULT = new DefaultMessageSizeEstimator(8);
 
     private final Handle handle;
 

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspHeaders.java
Patch:
@@ -24,6 +24,7 @@
  * Standard RTSP header names and values.
  */
 @Deprecated
+@SuppressWarnings("deprecation")
 public final class RtspHeaders {
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspObjectDecoder.java
Patch:
@@ -47,7 +47,10 @@
  *     value, a {@link TooLongFrameException} will be raised.</td>
  * </tr>
  * </table>
+ *
+ * @deprecated Use {@link RtspDecoder} instead.
  */
+@Deprecated
 public abstract class RtspObjectDecoder extends HttpObjectDecoder {
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspObjectEncoder.java
Patch:
@@ -24,8 +24,11 @@
 /**
  * Encodes an RTSP message represented in {@link FullHttpMessage} into
  * a {@link ByteBuf}.
+ *
+ * @deprecated Use {@link RtspEncoder} instead.
  */
 @Sharable
+@Deprecated
 public abstract class RtspObjectEncoder<H extends HttpMessage> extends HttpObjectEncoder<H> {
 
     /**

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -183,8 +183,8 @@ private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int req
             final PoolSubpage<T> head = table[tableIdx];
 
             /**
-             * Synchronize on the head. This is needed as {@link PoolSubpage#allocate()} and
-             * {@link PoolSubpage#free(int)} may modify the doubly linked list as well.
+             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and
+             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.
              */
             synchronized (head) {
                 final PoolSubpage<T> s = head.next;

File: buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java
Patch:
@@ -30,6 +30,7 @@ final class UnsafeDirectSwappedByteBuf extends SwappedByteBuf {
 
     UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {
         super(buf);
+        assert PlatformDependent.isUnaligned();
         wrapped = buf;
         nativeByteOrder = NATIVE_ORDER == (order() == ByteOrder.BIG_ENDIAN);
     }

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -2043,7 +2043,7 @@ public void testGetDoubleAfterRelease() {
 
     @Test(expected = IllegalReferenceCountException.class)
     public void testGetBytesAfterRelease() {
-        releasedBuffer().getBytes(0, releaseLater(buffer()));
+        releasedBuffer().getBytes(0, releaseLater(buffer(8)));
     }
 
     @Test(expected = IllegalReferenceCountException.class)

File: buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
Patch:
@@ -155,9 +155,6 @@ public ByteBuf copy(int index, int length) {
     @Override
     public ByteBuf slice(int index, int length) {
         checkIndex(index, length);
-        if (length == 0) {
-            return Unpooled.EMPTY_BUFFER;
-        }
         return buffer.slice(idx(index), length);
     }
 

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannelId.java
Patch:
@@ -41,7 +41,7 @@ public String asLongText() {
 
     @Override
     public int compareTo(ChannelId o) {
-        if (o == INSTANCE) {
+        if (o instanceof EmbeddedChannelId) {
             return 0;
         }
 
@@ -50,12 +50,12 @@ public int compareTo(ChannelId o) {
 
     @Override
     public int hashCode() {
-        return super.hashCode();
+        return 0;
     }
 
     @Override
     public boolean equals(Object obj) {
-        return super.equals(obj);
+        return obj instanceof EmbeddedChannelId;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -55,7 +55,7 @@ public abstract class AbstractChannel extends DefaultAttributeMap implements Cha
     private final Channel parent;
     private final ChannelId id;
     private final Unsafe unsafe;
-    private final DefaultChannelPipeline pipeline;
+    private final ChannelPipeline pipeline;
     private final ChannelFuture succeededFuture = new SucceededChannelFuture(this, null);
     private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);
     private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -69,7 +69,7 @@ public final class Native {
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xff, (byte) 0xff };
 
     // As all our JNI methods return -errno on error we need to compare with the negative errno codes.
-    private static final int ERRNO_ENOTCONN_NEGATIVE = -errorENOTCONN();
+    private static final int ERRNO_ENOTCONN_NEGATIVE = -errnoENOTCONN();
     private static final int ERRNO_EBADF_NEGATIVE = -errnoEBADF();
     private static final int ERRNO_EPIPE_NEGATIVE = -errnoEPIPE();
     private static final int ERRNO_ECONNRESET_NEGATIVE = -errnoECONNRESET();
@@ -190,7 +190,7 @@ public static void epollCtlDel(int efd, final int fd) throws IOException {
     private static native int errnoEBADF();
     private static native int errnoEPIPE();
     private static native int errnoECONNRESET();
-    private static native int errorENOTCONN();
+    private static native int errnoENOTCONN();
 
     private static native int errnoEAGAIN();
     private static native int errnoEWOULDBLOCK();

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorMessageHandle.java
Patch:
@@ -31,7 +31,9 @@ public boolean continueReading() {
          * If edgeTriggered is used we need to read all bytes/messages as we are not notified again otherwise. For
          * packet oriented descriptors must read until we get a EAGAIN
          * (see Q9 in <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll man</a>).
+         *
+         * If EPOLLRDHUP has been received we must read until we get a read error.
          */
-        return isEdgeTriggered() ? true : super.continueReading();
+        return isEdgeTriggered() || isRdHup() ? true : super.continueReading();
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -442,7 +442,7 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) th
         public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
             // Send an ack back to the remote client.
             // Need to retain the buffer here since it will be released after the write completes.
-            encoder.writePing(ctx, true, data.retain(), ctx.newPromise());
+            encoder.writePing(ctx, true, data.slice().retain(), ctx.newPromise());
 
             listener.onPingRead(ctx, data);
         }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java
Patch:
@@ -1043,8 +1043,8 @@ public SSLSession getSession() {
     public synchronized void beginHandshake() throws SSLException {
         switch (handshakeState) {
             case NOT_STARTED:
-                handshake();
                 handshakeState = HandshakeState.STARTED_EXPLICITLY;
+                handshake();
                 break;
             case STARTED_IMPLICITLY:
                 checkEngineClosed();
@@ -1058,6 +1058,7 @@ public synchronized void beginHandshake() throws SSLException {
                 handshakeState = HandshakeState.STARTED_EXPLICITLY; // Next time this method is invoked by the user,
                                                           // we should raise an exception.
                 break;
+            case FINISHED:
             case STARTED_EXPLICITLY:
                 throw RENEGOTIATION_UNSUPPORTED;
             default:

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -205,15 +205,15 @@ public static void close(int fd) throws IOException {
 
     private static native int close0(int fd);
 
-    public static int splice(int fd, int offIn, int fdOut, int offOut, int len) throws IOException {
+    public static int splice(int fd, long offIn, int fdOut, long offOut, long len) throws IOException {
         int res = splice0(fd, offIn, fdOut, offOut, len);
         if (res >= 0) {
             return res;
         }
         return ioResult("splice", res, CONNECTION_RESET_EXCEPTION_SPLICE);
     }
 
-    private static native int splice0(int fd, int offIn, int fdOut, int offOut, int len);
+    private static native int splice0(int fd, long offIn, int fdOut, long offOut, long len);
 
     public static long pipe() throws IOException {
         long res = pipe0();

File: codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java
Patch:
@@ -540,7 +540,7 @@ public Headers<T> setShort(T name, short value) {
     public Headers<T> set(Headers<? extends T> headers) {
         checkNotNull(headers, "headers");
         if (headers == this) {
-            return this;
+            throw new IllegalArgumentException("can't add to itself.");
         }
         clear();
         if (headers instanceof DefaultHeaders) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
Patch:
@@ -31,7 +31,7 @@ public interface Http2RemoteFlowController extends Http2FlowController {
 
     /**
      * Queues a payload for transmission to the remote endpoint. There is no guarantee as to when the data
-     * will be written or how it will be allocated to frames.
+     * will be written or how it will be assigned to frames.
      * before sending.
      * <p>
      * Writes do not actually occur until {@link #writePendingBytes()} is called.

File: codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java
Patch:
@@ -135,7 +135,7 @@ public void clientRequestSingleHeaderNoDataFrames() throws Exception {
         try {
             HttpHeaders httpHeaders = request.headers();
             httpHeaders.set(HttpConversionUtil.ExtensionHeaderNames.SCHEME.text(), "https");
-            httpHeaders.set(HttpConversionUtil.ExtensionHeaderNames.AUTHORITY.text(), "example.org");
+            httpHeaders.set(HttpHeaderNames.HOST, "example.org");
             httpHeaders.setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(), 3);
             httpHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);
             final Http2Headers http2Headers = new DefaultHttp2Headers().method(new AsciiString("GET")).
@@ -481,7 +481,7 @@ public void serverRequestPushPromise() throws Exception {
             httpHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, text.length());
             HttpHeaders httpHeaders2 = response2.headers();
             httpHeaders2.set(HttpConversionUtil.ExtensionHeaderNames.SCHEME.text(), "https");
-            httpHeaders2.set(HttpConversionUtil.ExtensionHeaderNames.AUTHORITY.text(), "example.org");
+            httpHeaders2.set(HttpHeaderNames.HOST, "example.org");
             httpHeaders2.setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(), 5);
             httpHeaders2.setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_PROMISE_ID.text(), 3);
             httpHeaders2.setInt(HttpHeaderNames.CONTENT_LENGTH, text2.length());

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -171,7 +171,7 @@ public ChannelFuture writeHeaders(final ChannelHandlerContext ctx, final int str
                             endOfStream, promise));
             return promise;
         } catch (Http2NoMoreStreamIdsException e) {
-            lifecycleManager.onException(ctx, e);
+            lifecycleManager.onError(ctx, e);
             return promise.setFailure(e);
         } catch (Throwable e) {
             return promise.setFailure(e);
@@ -332,7 +332,7 @@ public int size() {
         @Override
         public void error(ChannelHandlerContext ctx, Throwable cause) {
             queue.releaseAndFailAll(cause);
-            lifecycleManager.onException(ctx, cause);
+            lifecycleManager.onError(ctx, cause);
             promise.tryFailure(cause);
         }
 
@@ -400,7 +400,7 @@ public int size() {
         @Override
         public void error(ChannelHandlerContext ctx, Throwable cause) {
             if (ctx != null) {
-                lifecycleManager.onException(ctx, cause);
+                lifecycleManager.onError(ctx, cause);
             }
             promise.tryFailure(cause);
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java
Patch:
@@ -85,7 +85,7 @@ ChannelFuture goAway(ChannelHandlerContext ctx, int lastStreamId, long errorCode
             ByteBuf debugData, ChannelPromise promise);
 
     /**
-     * Processes the given exception.
+     * Processes the given error.
      */
-    void onException(ChannelHandlerContext ctx, Throwable cause);
+    void onError(ChannelHandlerContext ctx, Throwable cause);
 }

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java
Patch:
@@ -30,7 +30,7 @@
 
 public class DefaultStompHeaders extends DefaultHeaders<CharSequence> implements StompHeaders {
     public DefaultStompHeaders() {
-        super(CharSequenceValueConverter.INSTANCE);
+        super(CASE_SENSITIVE_HASHER, CharSequenceValueConverter.INSTANCE);
     }
 
     @Override

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslClientRenegotiateTest.java
Patch:
@@ -158,7 +158,7 @@ public void initChannel(Channel sch) throws Exception {
         Future<Channel> clientHandshakeFuture = clientSslHandler.handshakeFuture();
         clientHandshakeFuture.sync();
 
-        String renegotiation = "SSL_RSA_WITH_RC4_128_SHA";
+        String renegotiation = "SSL_RSA_WITH_3DES_EDE_CBC_SHA";
         clientSslHandler.engine().setEnabledCipherSuites(new String[] { renegotiation });
         clientSslHandler.renegotiate().await();
         serverChannel.close().awaitUninterruptibly();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -428,8 +428,6 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         // Call super class first, as this may result in decode being called.
         super.channelInactive(ctx);
         if (byteDecoder != null) {
-            encoder.flowController().channelHandlerContext(null);
-            decoder.flowController().channelHandlerContext(null);
             byteDecoder.channelInactive(ctx);
             byteDecoder = null;
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class Http2ServerUpgradeCodec implements HttpServerUpgradeHandler.UpgradeCodec {
 
-    private static final List<String> REQUIRED_UPGRADE_HEADERS =
+    private static final List<CharSequence> REQUIRED_UPGRADE_HEADERS =
             Collections.singletonList(HTTP_UPGRADE_SETTINGS_HEADER);
 
     private final String handlerName;
@@ -72,7 +72,7 @@ public Http2ServerUpgradeCodec(String handlerName, Http2ConnectionHandler connec
     }
 
     @Override
-    public Collection<String> requiredUpgradeHeaders() {
+    public Collection<CharSequence> requiredUpgradeHeaders() {
         return REQUIRED_UPGRADE_HEADERS;
     }
 

File: example/src/main/java/io/netty/example/http2/helloworld/server/Http2ServerInitializer.java
Patch:
@@ -31,6 +31,7 @@
 import io.netty.handler.codec.http2.Http2CodecUtil;
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec;
 import io.netty.handler.ssl.SslContext;
+import io.netty.util.AsciiString;
 
 /**
  * Sets up the Netty pipeline for the example server. Depending on the endpoint config, sets up the
@@ -40,8 +41,8 @@ public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
 
     private static final UpgradeCodecFactory upgradeCodecFactory = new UpgradeCodecFactory() {
         @Override
-        public UpgradeCodec newUpgradeCodec(String protocol) {
-            if (Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME.equals(protocol)) {
+        public UpgradeCodec newUpgradeCodec(CharSequence protocol) {
+            if (AsciiString.contentEquals(Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME, protocol)) {
                 return new Http2ServerUpgradeCodec(new HelloWorldHttp2Handler());
             } else {
                 return null;

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
Patch:
@@ -65,7 +65,7 @@ public void pseudoHeadersWithRemovePreservesPseudoIterationOrder() {
         }
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test(expected = Http2Exception.class)
     public void testHeaderNameValidation() {
         Http2Headers headers = newHeaders();
 

File: example/src/main/java/io/netty/example/http2/Http2ExampleUtil.java
Patch:
@@ -31,7 +31,7 @@ public final class Http2ExampleUtil {
     /**
      * Response header sent in response to the http->http2 cleartext upgrade request.
      */
-    public static final String UPGRADE_RESPONSE_HEADER = "Http-To-Http2-Upgrade";
+    public static final String UPGRADE_RESPONSE_HEADER = "http-to-http2-upgrade";
 
     /**
      * Size of the block to be read from the input stream.

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java
Patch:
@@ -39,6 +39,7 @@ public DefaultSpdyHeaders() {
         this(true);
     }
 
+    @SuppressWarnings("unchecked")
     public DefaultSpdyHeaders(boolean validate) {
         super(CASE_INSENSITIVE_HASHER,
                 validate ? HeaderValueConverterAndValidator.INSTANCE : HeaderValueConverter.INSTANCE,

File: codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
Patch:
@@ -89,6 +89,7 @@ public interface Cookie extends io.netty.handler.codec.http.cookie.Cookie {
      * @deprecated Not part of RFC6265
      */
     @Deprecated
+    @Override
     long maxAge();
 
     /**
@@ -103,6 +104,7 @@ public interface Cookie extends io.netty.handler.codec.http.cookie.Cookie {
      * @deprecated Not part of RFC6265
      */
     @Deprecated
+    @Override
     void setMaxAge(long maxAge);
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -98,7 +98,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                 assert encoder == null;
 
                 final HttpResponse res = (HttpResponse) msg;
-                final int code = res.getStatus().code();
+                final int code = res.status().code();
                 if (code == CONTINUE_CODE) {
                     // We need to not poll the encoding when response with CONTINUE as another response will follow
                     // for the issued request. See https://github.com/netty/netty/issues/4079

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -232,7 +232,7 @@ private abstract static class AggregatedFullHttpMessage implements ByteBufHolder
         public HttpHeaders trailingHeaders() {
             HttpHeaders trailingHeaders = this.trailingHeaders;
             if (trailingHeaders == null) {
-                return HttpHeaders.EMPTY_HEADERS;
+                return EmptyHttpHeaders.INSTANCE;
             } else {
                 return trailingHeaders;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java
Patch:
@@ -295,7 +295,7 @@ private boolean upgrade(final ChannelHandlerContext ctx, final FullHttpRequest r
         }
 
         // Ensure that all required protocol-specific headers are found in the request.
-        for (String requiredHeader : requiredHeaders) {
+        for (CharSequence requiredHeader : requiredHeaders) {
             if (!request.headers().contains(requiredHeader)) {
                 return false;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
Patch:
@@ -46,7 +46,7 @@ public LastHttpContent duplicate() {
 
         @Override
         public HttpHeaders trailingHeaders() {
-            return HttpHeaders.EMPTY_HEADERS;
+            return EmptyHttpHeaders.INSTANCE;
         }
 
         @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http.cors;
 
 import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
@@ -202,7 +203,7 @@ public Set<String> allowedRequestHeaders() {
      */
     public HttpHeaders preflightResponseHeaders() {
         if (preflightHeaders.isEmpty()) {
-            return HttpHeaders.EMPTY_HEADERS;
+            return EmptyHttpHeaders.INSTANCE;
         }
         final HttpHeaders preflightHeaders = new DefaultHttpHeaders();
         for (Entry<CharSequence, Callable<?>> entry : this.preflightHeaders.entrySet()) {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpContent;
+import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpConstants;
 import io.netty.handler.codec.http.HttpContent;
@@ -1309,7 +1310,7 @@ public HttpHeaders trailingHeaders() {
             if (content instanceof LastHttpContent) {
                 return ((LastHttpContent) content).trailingHeaders();
             } else {
-                return HttpHeaders.EMPTY_HEADERS;
+                return EmptyHttpHeaders.INSTANCE;
             }
         }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/CombinedHttpHeadersTest.java
Patch:
@@ -24,7 +24,7 @@
 import static org.junit.Assert.assertTrue;
 
 public class CombinedHttpHeadersTest {
-    private static final String HEADER_NAME = "testHeader";
+    private static final CharSequence HEADER_NAME = "testHeader";
 
     @Test
     public void addCharSequencesCsv() {

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
Patch:
@@ -40,7 +40,7 @@ public class DefaultHttp2HeadersDecoderTest {
 
     @Before
     public void setup() {
-        decoder = new DefaultHttp2HeadersDecoder();
+        decoder = new DefaultHttp2HeadersDecoder(false);
     }
 
     @Test

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
Patch:
@@ -482,7 +482,7 @@ protected void initChannel(Channel ch) throws Exception {
                 serverFrameCountDown =
                         new FrameCountDown(serverListener, serverSettingsAckLatch,
                                 requestLatch, dataLatch, trailersLatch, goAwayLatch);
-                p.addLast(new Http2ConnectionHandler(true, serverFrameCountDown));
+                p.addLast(new Http2ConnectionHandler(true, serverFrameCountDown, false));
             }
         });
 
@@ -492,7 +492,7 @@ protected void initChannel(Channel ch) throws Exception {
             @Override
             protected void initChannel(Channel ch) throws Exception {
                 ChannelPipeline p = ch.pipeline();
-                p.addLast(new Http2ConnectionHandler(false, clientListener));
+                p.addLast(new Http2ConnectionHandler(false, clientListener, false));
             }
         });
 
@@ -513,7 +513,7 @@ private ChannelPromise newPromise() {
     }
 
     private static Http2Headers dummyHeaders() {
-        return new DefaultHttp2Headers().method(new AsciiString("GET")).scheme(new AsciiString("https"))
+        return new DefaultHttp2Headers(false).method(new AsciiString("GET")).scheme(new AsciiString("https"))
         .authority(new AsciiString("example.org")).path(new AsciiString("/some/path/resource2"))
         .add(randomString(), randomString());
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java
Patch:
@@ -398,7 +398,7 @@ private ChannelPromise newPromise() {
     }
 
     private static Http2Headers headers() {
-        return new DefaultHttp2Headers().method(new AsciiString("GET")).scheme(new AsciiString("https"))
+        return new DefaultHttp2Headers(false).method(new AsciiString("GET")).scheme(new AsciiString("https"))
                 .authority(new AsciiString("example.org")).path(new AsciiString("/some/path/resource2"))
                 .add(randomString(), randomString());
     }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -89,7 +89,7 @@ static class FrameAdapter extends ByteToMessageDecoder {
         }
 
         FrameAdapter(Http2Connection connection, Http2FrameListener listener, CountDownLatch latch) {
-            this(connection, new DefaultHttp2FrameReader(), listener, latch);
+            this(connection, new DefaultHttp2FrameReader(false), listener, latch);
         }
 
         FrameAdapter(Http2Connection connection, DefaultHttp2FrameReader reader, Http2FrameListener listener,

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
Patch:
@@ -186,9 +186,9 @@ public static boolean isPseudoHeader(ByteString header) {
     Http2Headers clear();
 
     /**
-     * Returns an iterator over all HTTP/2 headers from this instance. The iteration order is as follows:
-     *   1. All non-pseudo headers (in no particular order).
-     *   2. Headers with multiple values will have their values appear in insertion order.
+     * Returns an iterator over all HTTP/2 headers. The iteration order is as follows:
+     *   1. All pseudo headers (order not specified).
+     *   2. All non-pseudo headers (in insertion order).
      */
     @Override
     Iterator<Entry<ByteString, ByteString>> iterator();

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java
Patch:
@@ -36,7 +36,9 @@ public MqttConnectReturnCode connectReturnCode() {
         return connectReturnCode;
     }
 
-    public boolean isSessionPresent() { return sessionPresent; }
+    public boolean isSessionPresent() {
+        return sessionPresent;
+    }
 
     @Override
     public String toString() {

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java
Patch:
@@ -136,6 +136,8 @@ public void shouldEncodeContent() {
 
         ByteBuf written = channel.readOutbound();
         assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));
+        written.release();
+
         written = channel.readOutbound();
         assertThat(written.readableBytes(), is(content1.content().readableBytes()));
         assertThat(

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -1153,7 +1153,7 @@ private boolean allowModifications() {
      * Implementation of {@link PropertyKey} that specifies the index position of the property.
      */
     final class DefaultPropertyKey implements PropertyKey {
-        private final int index;
+        final int index;
 
         DefaultPropertyKey(int index) {
             this.index = index;

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java
Patch:
@@ -51,7 +51,7 @@ public void testGetOperations() {
     }
 
     @Test
-    public void testEquansIgnoreCase() {
+    public void testEqualsIgnoreCase() {
         assertThat(AsciiString.contentEqualsIgnoreCase(null, null), is(true));
         assertThat(AsciiString.contentEqualsIgnoreCase(null, "foo"), is(false));
         assertThat(AsciiString.contentEqualsIgnoreCase("bar", null), is(false));

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -77,7 +77,7 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             encodeInitialLine(buf, m);
             encodeHeaders(m.headers(), buf);
             buf.writeBytes(CRLF);
-            state = HttpHeaderUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;
+            state = HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;
         }
 
         // Bypass the encoder in case of an empty buffer, so that the following idiom works:
@@ -220,7 +220,7 @@ private static long contentLength(Object msg) {
 
     @Deprecated
     protected static void encodeAscii(String s, ByteBuf buf) {
-        HttpHeaders.encodeAscii0(s, buf);
+        HttpUtil.encodeAscii0(s, buf);
     }
 
     protected abstract void encodeInitialLine(ByteBuf buf, H message) throws Exception;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java
Patch:
@@ -670,9 +670,9 @@ public String toString() {
 
     void encode(ByteBuf buf) {
         if (bytes == null) {
-            HttpHeaders.encodeAscii0(String.valueOf(code()), buf);
+            HttpUtil.encodeAscii0(String.valueOf(code()), buf);
             buf.writeByte(SP);
-            HttpHeaders.encodeAscii0(String.valueOf(reasonPhrase()), buf);
+            HttpUtil.encodeAscii0(String.valueOf(reasonPhrase()), buf);
         } else {
             buf.writeBytes(bytes);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java
Patch:
@@ -264,7 +264,7 @@ public int compareTo(HttpVersion o) {
 
     void encode(ByteBuf buf) {
         if (bytes == null) {
-            HttpHeaders.encodeAscii0(text, buf);
+            HttpUtil.encodeAscii0(text, buf);
         } else {
             buf.writeBytes(bytes);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -24,7 +24,7 @@
 import io.netty.handler.codec.http.HttpConstants;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
@@ -760,7 +760,7 @@ public HttpRequest finalizeRequest() throws ErrorDataEncoderException {
                     }
                 }
             }
-            HttpHeaderUtil.setTransferEncodingChunked(request, true);
+            HttpUtil.setTransferEncodingChunked(request, true);
 
             // wrap to hide the possible content
             return new WrappedHttpRequest(request);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
@@ -159,7 +159,7 @@ public static ChannelFuture sendUnsupportedVersionResponse(Channel channel, Chan
                 HttpVersion.HTTP_1_1,
                 HttpResponseStatus.UPGRADE_REQUIRED);
         res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, WebSocketVersion.V13.toHttpHeaderValue());
-        HttpHeaderUtil.setContentLength(res, 0);
+        HttpUtil.setContentLength(res, 0);
         return channel.writeAndFlush(res, promise);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -27,7 +27,7 @@
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.ssl.SslHandler;
 
-import static io.netty.handler.codec.http.HttpHeaderUtil.*;
+import static io.netty.handler.codec.http.HttpUtil.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;

File: codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java
Patch:
@@ -105,7 +105,7 @@ public void testRemoveTransferEncodingIgnoreCase() {
         HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         message.headers().set(HttpHeaderNames.TRANSFER_ENCODING, "Chunked");
         assertFalse(message.headers().isEmpty());
-        HttpHeaderUtil.setTransferEncodingChunked(message, false);
+        HttpUtil.setTransferEncodingChunked(message, false);
         assertTrue(message.headers().isEmpty());
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java
Patch:
@@ -31,7 +31,7 @@ public void testRemoveTransferEncodingIgnoreCase() {
         HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         message.headers().set(HttpHeaderNames.TRANSFER_ENCODING, "Chunked");
         assertFalse(message.headers().isEmpty());
-        HttpHeaderUtil.setTransferEncodingChunked(message, false);
+        HttpUtil.setTransferEncodingChunked(message, false);
         assertTrue(message.headers().isEmpty());
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpUtilTest.java
Patch:
@@ -24,14 +24,14 @@
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 
-public class HttpHeaderUtilTest {
+public class HttpUtilTest {
 
     @Test
     public void testRemoveTransferEncodingIgnoreCase() {
         HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         message.headers().set(HttpHeaderNames.TRANSFER_ENCODING, "Chunked");
         assertFalse(message.headers().isEmpty());
-        HttpHeaderUtil.setTransferEncodingChunked(message, false);
+        HttpUtil.setTransferEncodingChunked(message, false);
         assertTrue(message.headers().isEmpty());
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactoryTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.util.ReferenceCountUtil;
 import org.junit.Test;
@@ -43,8 +43,8 @@ public void testUnsupportedVersion() throws Exception {
         assertEquals(HttpResponseStatus.UPGRADE_REQUIRED, response.status());
         assertEquals(WebSocketVersion.V13.toHttpHeaderValue(),
                 response.headers().get(HttpHeaderNames.SEC_WEBSOCKET_VERSION));
-        assertTrue(HttpHeaderUtil.isContentLengthSet(response));
-        assertEquals(0, HttpHeaderUtil.getContentLength(response));
+        assertTrue(HttpUtil.isContentLengthSet(response));
+        assertEquals(0, HttpUtil.getContentLength(response));
 
         ReferenceCountUtil.release(response);
         assertFalse(ch.finish());

File: example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.AsciiString;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
@@ -45,10 +45,10 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) msg;
 
-            if (HttpHeaderUtil.is100ContinueExpected(req)) {
+            if (HttpUtil.is100ContinueExpected(req)) {
                 ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
             }
-            boolean keepAlive = HttpHeaderUtil.isKeepAlive(req);
+            boolean keepAlive = HttpUtil.isKeepAlive(req);
             FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));
             response.headers().set(CONTENT_TYPE, "text/plain");
             response.headers().setInt(CONTENT_LENGTH, response.content().readableBytes());

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -44,7 +44,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
                 System.err.println();
             }
 
-            if (HttpHeaderUtil.isTransferEncodingChunked(response)) {
+            if (HttpUtil.isTransferEncodingChunked(response)) {
                 System.err.println("CHUNKED CONTENT {");
             } else {
                 System.err.println("CONTENT {");

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -25,7 +25,7 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpObject;
@@ -61,7 +61,7 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest request = this.request = (HttpRequest) msg;
 
-            if (HttpHeaderUtil.is100ContinueExpected(request)) {
+            if (HttpUtil.is100ContinueExpected(request)) {
                 send100Continue(ctx);
             }
 
@@ -146,7 +146,7 @@ private static void appendDecoderResult(StringBuilder buf, HttpObject o) {
 
     private boolean writeResponse(HttpObject currentObj, ChannelHandlerContext ctx) {
         // Decide whether to close the connection or not.
-        boolean keepAlive = HttpHeaderUtil.isKeepAlive(request);
+        boolean keepAlive = HttpUtil.isKeepAlive(request);
         // Build the response object.
         FullHttpResponse response = new DefaultFullHttpResponse(
                 HTTP_1_1, currentObj.decoderResult().isSuccess()? OK : BAD_REQUEST,

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -47,7 +47,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
                 }
             }
 
-            if (response.status().code() == 200 && HttpHeaderUtil.isTransferEncodingChunked(response)) {
+            if (response.status().code() == 200 && HttpUtil.isTransferEncodingChunked(response)) {
                 readingChunks = true;
                 System.err.println("CHUNKED CONTENT {");
             } else {

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -25,7 +25,7 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpObject;
@@ -162,7 +162,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 return;
             }
 
-            readingChunks = HttpHeaderUtil.isTransferEncodingChunked(request);
+            readingChunks = HttpUtil.isTransferEncodingChunked(request);
             responseContent.append("Is Chunked: " + readingChunks + "\r\n");
             responseContent.append("IsMultipart: " + decoder.isMultipart() + "\r\n");
             if (readingChunks) {

File: example/src/main/java/io/netty/example/http2/helloworld/client/HttpResponseHandler.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http2.HttpUtil;
+import io.netty.handler.codec.http2.HttpConversionUtil;
 import io.netty.util.CharsetUtil;
 
 import java.util.Iterator;
@@ -76,7 +76,7 @@ public void awaitResponses(long timeout, TimeUnit unit) {
 
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {
-        Integer streamId = msg.headers().getInt(HttpUtil.ExtensionHeaderNames.STREAM_ID.text());
+        Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());
         if (streamId == null) {
             System.err.println("HttpResponseHandler unexpected message received: " + msg);
             return;

File: example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp1Handler.java
Patch:
@@ -31,7 +31,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpHeaderValues;
 
 /**
@@ -46,10 +46,10 @@ public HelloWorldHttp1Handler(String establishApproach) {
 
     @Override
     public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
-        if (HttpHeaderUtil.is100ContinueExpected(req)) {
+        if (HttpUtil.is100ContinueExpected(req)) {
             ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
         }
-        boolean keepAlive = HttpHeaderUtil.isKeepAlive(req);
+        boolean keepAlive = HttpUtil.isKeepAlive(req);
 
         ByteBuf content = ctx.alloc().buffer();
         content.writeBytes(HelloWorldHttp2Handler.RESPONSE_BYTES.duplicate());

File: example/src/main/java/io/netty/example/http2/tiles/FallbackRequestHandler.java
Patch:
@@ -31,7 +31,7 @@
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http2.Http2CodecUtil;
 
@@ -47,7 +47,7 @@ public final class FallbackRequestHandler extends SimpleChannelInboundHandler<Ht
 
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, HttpRequest req) throws Exception {
-        if (HttpHeaderUtil.is100ContinueExpected(req)) {
+        if (HttpUtil.is100ContinueExpected(req)) {
             ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
         }
 

File: example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.example.http.snoop.HttpSnoopClientHandler;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaderUtil;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -55,7 +55,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 System.out.println();
             }
 
-            if (HttpHeaderUtil.isTransferEncodingChunked(response)) {
+            if (HttpUtil.isTransferEncodingChunked(response)) {
                 System.out.println("CHUNKED CONTENT {");
             } else {
                 System.out.println("CONTENT {");

File: example/src/main/java/io/netty/example/spdy/server/SpdyServerHandler.java
Patch:
@@ -29,7 +29,7 @@
 
 import java.util.Date;
 
-import static io.netty.handler.codec.http.HttpHeaderUtil.*;
+import static io.netty.handler.codec.http.HttpUtil.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 

File: testsuite/src/main/java/io/netty/testsuite/websockets/autobahn/AutobahnServerHandler.java
Patch:
@@ -40,7 +40,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import static io.netty.handler.codec.http.HttpHeaderUtil.*;
+import static io.netty.handler.codec.http.HttpUtil.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;

File: common/src/main/java/io/netty/util/internal/MpscLinkedQueueHeadRef.java
Patch:
@@ -38,7 +38,7 @@ abstract class MpscLinkedQueueHeadRef<E> extends MpscLinkedQueuePad0<E> implemen
         UPDATER = updater;
     }
 
-    private transient  volatile MpscLinkedQueueNode<E> headRef;
+    private transient volatile MpscLinkedQueueNode<E> headRef;
 
     protected final MpscLinkedQueueNode<E> headRef() {
         return headRef;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -119,6 +119,7 @@ void resolve() {
 
     private void query(InetSocketAddress nameServerAddr, final DnsQuestion question) {
         if (allowedQueries == 0 || promise.isCancelled()) {
+            tryToFinishResolve();
             return;
         }
 

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -71,9 +71,7 @@ public class DnsNameResolverTest {
             new InetSocketAddress("208.67.222.220", 53),
             new InetSocketAddress("208.67.220.222", 53),
             new InetSocketAddress("37.235.1.174", 53), // FreeDNS
-            new InetSocketAddress("37.235.1.177", 53),
-            new InetSocketAddress("8.26.56.26", 53), // Comodo Secure DNS
-            new InetSocketAddress("8.20.247.20", 53)
+            new InetSocketAddress("37.235.1.177", 53)
     );
 
     // Using the top-100 web sites ranked in Alexa.com (Oct 2014)

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
Patch:
@@ -67,7 +67,7 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
             };
 
     private final DnsNameResolver parent;
-    private final Iterator<InetSocketAddress> nameServerAddrs;
+    private final DnsServerAddressStream nameServerAddrs;
     private final Promise<T> promise;
     private final String hostname;
     private final boolean traceEnabled;
@@ -88,7 +88,7 @@ protected DnsNameResolverContext(DnsNameResolver parent, String hostname, Promis
         this.promise = promise;
         this.hostname = hostname;
 
-        nameServerAddrs = parent.nameServerAddresses.iterator();
+        nameServerAddrs = parent.nameServerAddresses.stream();
         maxAllowedQueries = parent.maxQueriesPerResolve();
         resolveAddressTypes = parent.resolveAddressTypesUnsafe();
         traceEnabled = parent.isTraceEnabled();

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.util.CharsetUtil;
 
 import static io.netty.handler.codec.http.HttpConstants.*;
@@ -36,7 +37,7 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {
-        request.method().encode(buf);
+        ByteBufUtil.writeAscii(buf, request.method().name());
         buf.writeByte(SP);
 
         // Add / as absolute path if no is present.

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketChannelTest.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.ServerChannel;
+import io.netty.util.ReferenceCountUtil;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -182,6 +183,7 @@ protected void initChannel(Channel ch) throws Exception {
     private static class BuggyChannelHandler extends ChannelInboundHandlerAdapter {
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            ReferenceCountUtil.release(msg);
             throw new NullPointerException("I am a bug!");
         }
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2NoMoreStreamIdsException.java
Patch:
@@ -24,10 +24,10 @@ public class Http2NoMoreStreamIdsException extends Http2Exception {
     private static final String ERROR_MESSAGE = "No more streams can be created on this connection";
 
     public Http2NoMoreStreamIdsException() {
-        super(PROTOCOL_ERROR, ERROR_MESSAGE);
+        super(PROTOCOL_ERROR, ERROR_MESSAGE, ShutdownHint.GRACEFUL_SHUTDOWN);
     }
 
     public Http2NoMoreStreamIdsException(Throwable cause) {
-        super(PROTOCOL_ERROR, ERROR_MESSAGE, cause);
+        super(PROTOCOL_ERROR, ERROR_MESSAGE, cause, ShutdownHint.GRACEFUL_SHUTDOWN);
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -315,10 +315,9 @@ private Http2Stream requireStream(int streamId) {
      * </p>
      */
     private final class FlowControlledData extends FlowControlledBase {
-
         private final CoalescingBufferQueue queue;
 
-        private FlowControlledData(Http2Stream stream, ByteBuf buf, int padding, boolean endOfStream,
+        public FlowControlledData(Http2Stream stream, ByteBuf buf, int padding, boolean endOfStream,
                                    ChannelPromise promise) {
             super(stream, padding, endOfStream, promise);
             queue = new CoalescingBufferQueue(promise.channel());
@@ -384,7 +383,7 @@ private final class FlowControlledHeaders extends FlowControlledBase {
         private final short weight;
         private final boolean exclusive;
 
-        private FlowControlledHeaders(Http2Stream stream, Http2Headers headers, int streamDependency, short weight,
+        public FlowControlledHeaders(Http2Stream stream, Http2Headers headers, int streamDependency, short weight,
                 boolean exclusive, int padding, boolean endOfStream, ChannelPromise promise) {
             super(stream, padding, endOfStream, promise);
             this.headers = headers;

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
Patch:
@@ -37,6 +37,8 @@ public interface DnsRecordDecoder {
      * Decodes a DNS record into its object representation.
      *
      * @param in the input buffer which contains a DNS record at its reader index
+     *
+     * @return the decoded record, or {@code null} if there are not enough data in the input buffer
      */
     <T extends DnsRecord> T decodeRecord(ByteBuf in) throws Exception;
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java
Patch:
@@ -220,7 +220,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                 throw new IllegalStateException(
                         "Switching Protocols response missing UPGRADE header");
             }
-            if (!AsciiString.equalsIgnoreCase(upgradeCodec.protocol(), upgradeHeader)) {
+            if (!AsciiString.contentEqualsIgnoreCase(upgradeCodec.protocol(), upgradeHeader)) {
                 throw new IllegalStateException(
                         "Switching Protocols response with unexpected UPGRADE protocol: "
                                 + upgradeHeader);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -96,7 +96,7 @@ public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel)
     protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
         String contentEncoding = headers.headers().get(HttpHeaderNames.CONTENT_ENCODING);
         if (contentEncoding != null &&
-            !HttpHeaderValues.IDENTITY.equalsIgnoreCase(contentEncoding)) {
+            !HttpHeaderValues.IDENTITY.contentEqualsIgnoreCase(contentEncoding)) {
             return null;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -625,9 +625,9 @@ private LastHttpContent readTrailingHeaders(ByteBuf buffer) {
                 } else {
                     splitHeader(line);
                     CharSequence headerName = name;
-                    if (!HttpHeaderNames.CONTENT_LENGTH.equalsIgnoreCase(headerName) &&
-                        !HttpHeaderNames.TRANSFER_ENCODING.equalsIgnoreCase(headerName) &&
-                        !HttpHeaderNames.TRAILER.equalsIgnoreCase(headerName)) {
+                    if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&
+                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&
+                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {
                         trailer.trailingHeaders().add(headerName, value);
                     }
                     lastHeader = name;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -753,7 +753,7 @@ public HttpRequest finalizeRequest() throws ErrorDataEncoderException {
             if (transferEncoding != null) {
                 headers.remove(HttpHeaderNames.TRANSFER_ENCODING);
                 for (CharSequence v : transferEncoding) {
-                    if (HttpHeaderValues.CHUNKED.equalsIgnoreCase(v)) {
+                    if (HttpHeaderValues.CHUNKED.contentEqualsIgnoreCase(v)) {
                         // ignore
                     } else {
                         headers.add(HttpHeaderNames.TRANSFER_ENCODING, v);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -201,13 +201,13 @@ protected void verify(FullHttpResponse response) {
         HttpHeaders headers = response.headers();
 
         CharSequence upgrade = headers.get(HttpHeaderNames.UPGRADE);
-        if (!WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!WEBSOCKET.contentEqualsIgnoreCase(upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: "
                     + upgrade);
         }
 
         CharSequence connection = headers.get(HttpHeaderNames.CONNECTION);
-        if (!HttpHeaderValues.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: "
                     + connection);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -206,12 +206,12 @@ protected void verify(FullHttpResponse response) {
         }
 
         CharSequence upgrade = headers.get(HttpHeaderNames.UPGRADE);
-        if (!HttpHeaderValues.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!HttpHeaderValues.WEBSOCKET.contentEqualsIgnoreCase(upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: " + upgrade);
         }
 
         CharSequence connection = headers.get(HttpHeaderNames.CONNECTION);
-        if (!HttpHeaderValues.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: " + connection);
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -207,12 +207,12 @@ protected void verify(FullHttpResponse response) {
         }
 
         CharSequence upgrade = headers.get(HttpHeaderNames.UPGRADE);
-        if (!HttpHeaderValues.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!HttpHeaderValues.WEBSOCKET.contentEqualsIgnoreCase(upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: " + upgrade);
         }
 
         CharSequence connection = headers.get(HttpHeaderNames.CONNECTION);
-        if (!HttpHeaderValues.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: " + connection);
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -217,12 +217,12 @@ protected void verify(FullHttpResponse response) {
         }
 
         CharSequence upgrade = headers.get(HttpHeaderNames.UPGRADE);
-        if (!HttpHeaderValues.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!HttpHeaderValues.WEBSOCKET.contentEqualsIgnoreCase(upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: " + upgrade);
         }
 
         CharSequence connection = headers.get(HttpHeaderNames.CONNECTION);
-        if (!HttpHeaderValues.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: " + connection);
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -142,6 +142,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
         res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
         res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
+
         String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         if (subprotocols != null) {
             String selectedSubprotocol = selectSubprotocol(subprotocols);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -141,6 +141,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
         res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
         res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
+
         String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         if (subprotocols != null) {
             String selectedSubprotocol = selectSubprotocol(subprotocols);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -139,6 +139,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         res.headers().add(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);
         res.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);
         res.headers().add(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT, accept);
+
         String subprotocols = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         if (subprotocols != null) {
             String selectedSubprotocol = selectSubprotocol(subprotocols);

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
Patch:
@@ -84,7 +84,7 @@ private static void assertHeaders(Object msg, int streamId, boolean last, SpdyHe
         assertEquals(last, spdyHeadersFrame.isLast());
         for (CharSequence name: headers.names()) {
             List<CharSequence> expectedValues = headers.getAll(name);
-            List<CharSequence> receivedValues = new ArrayList<CharSequence>(spdyHeadersFrame.headers().getAll(name));
+            List<CharSequence> receivedValues = spdyHeadersFrame.headers().getAll(name);
             assertTrue(receivedValues.containsAll(expectedValues));
             receivedValues.removeAll(expectedValues);
             assertTrue(receivedValues.isEmpty());

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeaderTableListSizeTest.java
Patch:
@@ -15,12 +15,11 @@
 
 package io.netty.handler.codec.http2;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 /**
  * Tests for {@link DefaultHttp2HeaderTableListSize}.
  */

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompTestConstants.java
Patch:
@@ -18,8 +18,8 @@
 public final class StompTestConstants {
     public static final String CONNECT_FRAME =
         "CONNECT\n" +
-            "accept-version:1.1,1.2\n" +
             "host:stomp.github.org\n" +
+            "accept-version:1.1,1.2\n" +
             '\n' +
             '\0';
     public static final String CONNECTED_FRAME =

File: common/src/main/java/io/netty/util/internal/StringUtil.java
Patch:
@@ -37,7 +37,6 @@ public final class StringUtil {
     public static final char CARRIAGE_RETURN = '\r';
     public static final char TAB = '\t';
 
-    public static final byte UPPER_CASE_TO_LOWER_CASE_ASCII_OFFSET = 'a' - 'A';
     private static final String[] BYTE2HEX_PAD = new String[256];
     private static final String[] BYTE2HEX_NOPAD = new String[256];
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -264,7 +264,7 @@ private static List<InterfaceHttpData> formpost(
      */
     private static void formpostmultipart(
             Bootstrap bootstrap, String host, int port, URI uriFile, HttpDataFactory factory,
-            List<Entry<String, String>> headers, List<InterfaceHttpData> bodylist) throws Exception {
+            Iterable<Entry<String, String>> headers, List<InterfaceHttpData> bodylist) throws Exception {
         // XXX /formpostmultipart
         // Start the connection attempt.
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));

File: example/src/main/java/io/netty/example/http2/tiles/HttpServer.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;

File: example/src/main/java/io/netty/example/stomp/StompClientHandler.java
Patch:
@@ -62,7 +62,7 @@ protected void channelRead0(ChannelHandlerContext ctx, StompFrame frame) throws
                 ctx.writeAndFlush(subscribeFrame);
                 break;
             case RECEIPT:
-                String receiptHeader = frame.headers().getAndConvert(StompHeaders.RECEIPT_ID);
+                String receiptHeader = frame.headers().getAsString(StompHeaders.RECEIPT_ID);
                 if (state == ClientState.AUTHENTICATED && receiptHeader.equals(subscrReceiptId)) {
                     StompFrame msgFrame = new DefaultStompFrame(StompCommand.SEND);
                     msgFrame.headers().set(StompHeaders.DESTINATION, StompClient.TOPIC);

File: microbench/src/main/java/io/netty/microbench/headers/ExampleHeaders.java
Patch:
@@ -80,7 +80,7 @@ public enum HeaderExample {
         header.put("accept-encoding", "gzip, deflate, sdch");
         header.put("accept-language", "en-US,en;q=0.8");
         header.put("cache-control", "max-age=0");
-        header.put("cookie:", "noneofyourbusiness");
+        header.put("cookie", "noneofyourbusiness");
         header.put("user-agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)");
         EXAMPLES.put(HeaderExample.ELEVEN, header);
 

File: transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
@@ -170,7 +171,7 @@ public void testAcquireNewConnectionWhen() throws Exception {
           .childHandler(new ChannelInitializer<LocalChannel>() {
               @Override
               public void initChannel(LocalChannel ch) throws Exception {
-                  ch.pipeline().addLast(new ChannelHandlerAdapter());
+                  ch.pipeline().addLast(new ChannelInboundHandlerAdapter());
               }
           });
 

File: buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
Patch:
@@ -44,6 +44,8 @@ protected static ByteBuf toLeakAwareBuffer(ByteBuf buf) {
                     buf = new AdvancedLeakAwareByteBuf(buf, leak);
                 }
                 break;
+            default:
+                break;
         }
         return buf;
     }

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -16,7 +16,6 @@
 
 package io.netty.buffer;
 
-import io.netty.buffer.PooledByteBufAllocator.PoolThreadLocalCache;
 import io.netty.util.Recycler;
 import io.netty.util.internal.PlatformDependent;
 

File: buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.buffer;
 
-import io.netty.util.IllegalReferenceCountException;
 import org.junit.Test;
 
 import java.io.IOException;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java
Patch:
@@ -65,6 +65,7 @@ public EpollChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
     }
 
     @Override
+    @Deprecated
     public EpollChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java
Patch:
@@ -184,6 +184,7 @@ public EpollDatagramChannelConfig setConnectTimeoutMillis(int connectTimeoutMill
     }
 
     @Override
+    @Deprecated
     public EpollDatagramChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDomainSocketChannelConfig.java
Patch:
@@ -58,7 +58,9 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
 
         return true;
     }
+
     @Override
+    @Deprecated
     public EpollDomainSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerChannelConfig.java
Patch:
@@ -110,6 +110,7 @@ public EpollServerChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis
     }
 
     @Override
+    @Deprecated
     public EpollServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannelConfig.java
Patch:
@@ -97,6 +97,7 @@ public EpollServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeout
     }
 
     @Override
+    @Deprecated
     public EpollServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java
Patch:
@@ -315,6 +315,7 @@ public EpollSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis
     }
 
     @Override
+    @Deprecated
     public EpollSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-native-epoll/src/main/java/io/netty/channel/unix/DomainSocketAddress.java
Patch:
@@ -23,6 +23,7 @@
  * <a href="http://en.wikipedia.org/wiki/Unix_domain_socket">Unix Domain Socket</a>.
  */
 public final class DomainSocketAddress extends SocketAddress {
+    private static final long serialVersionUID = -6934618000832236893L;
     private final String socketPath;
 
     public DomainSocketAddress(String socketPath) {

File: transport-native-epoll/src/main/java/io/netty/channel/unix/DomainSocketChannelConfig.java
Patch:
@@ -26,6 +26,7 @@
 public interface DomainSocketChannelConfig extends ChannelConfig {
 
     @Override
+    @Deprecated
     DomainSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -274,6 +274,7 @@ public static Paritybit valueOf(int value) {
     RxtxChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     RxtxChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
Patch:
@@ -157,6 +157,7 @@ public SctpServerChannelConfig setBacklog(int backlog) {
     }
 
     @Override
+    @Deprecated
     public SctpServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
Patch:
@@ -102,6 +102,7 @@ public interface SctpChannelConfig extends ChannelConfig {
     SctpChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     SctpChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java
Patch:
@@ -20,8 +20,6 @@
 
 import java.net.SocketAddress;
 
-import static io.netty.channel.ChannelOption.*;
-
 /**
  * Option for configuring the SCTP transport
  */

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
Patch:
@@ -94,6 +94,7 @@ public interface SctpServerChannelConfig extends ChannelConfig {
     SctpServerChannelConfig setInitMaxStreams(InitMaxStreams initMaxStreams);
 
     @Override
+    @Deprecated
     SctpServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
Patch:
@@ -46,7 +46,7 @@
  */
 public class NioSctpServerChannel extends AbstractNioMessageChannel
         implements io.netty.channel.sctp.SctpServerChannel {
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
 
     private static SctpServerChannel newSocket() {
         try {

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
Patch:
@@ -53,7 +53,7 @@ public class OioSctpServerChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSctpServerChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
 
     private static SctpServerChannel newServerSocket() {
         try {

File: transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java
Patch:
@@ -24,7 +24,7 @@
 import java.io.IOException;
 import java.util.Map;
 
-import static io.netty.channel.ChannelOption.*;
+import static io.netty.channel.ChannelOption.SO_BACKLOG;
 
 /**
  * The default {@link UdtServerChannelConfig} implementation.
@@ -143,6 +143,7 @@ public UdtServerChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis)
     }
 
     @Override
+    @Deprecated
     public UdtServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
Patch:
@@ -116,6 +116,7 @@ public interface UdtChannelConfig extends ChannelConfig {
     UdtChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     UdtChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
Patch:
@@ -18,8 +18,6 @@
 import com.barchart.udt.OptionUDT;
 import io.netty.channel.ChannelOption;
 
-import static io.netty.channel.ChannelOption.*;
-
 /**
  * Options for the UDT transport
  */

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
Patch:
@@ -50,6 +50,7 @@ public interface UdtServerChannelConfig extends UdtChannelConfig {
     UdtServerChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     UdtServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java
Patch:
@@ -43,7 +43,7 @@ public abstract class NioUdtAcceptorChannel extends AbstractNioMessageChannel im
     protected static final InternalLogger logger =
             InternalLoggerFactory.getInstance(NioUdtAcceptorChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
 
     private final UdtServerChannelConfig config;
 

File: transport/src/main/java/io/netty/channel/AbstractServerChannel.java
Patch:
@@ -29,8 +29,7 @@
  * </ul>
  */
 public abstract class AbstractServerChannel extends AbstractChannel implements ServerChannel {
-
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
 
     /**
      * Creates a new instance.

File: transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.util.internal.InternalThreadLocalMap;
 
 import java.util.Map;
-import java.util.WeakHashMap;
 
 /**
  * Skelton implementation of a {@link ChannelHandler}.

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -77,6 +77,9 @@ public static <T> ChannelOption<T> newInstance(String name) {
     public static final ChannelOption<MessageSizeEstimator> MESSAGE_SIZE_ESTIMATOR = valueOf("MESSAGE_SIZE_ESTIMATOR");
 
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS = valueOf("CONNECT_TIMEOUT_MILLIS");
+    /**
+     * @deprecated Use {@link MaxMessagesRecvByteBufAllocator}
+     */
     public static final ChannelOption<Integer> MAX_MESSAGES_PER_READ = valueOf("MAX_MESSAGES_PER_READ");
     public static final ChannelOption<Integer> WRITE_SPIN_COUNT = valueOf("WRITE_SPIN_COUNT");
     public static final ChannelOption<Integer> WRITE_BUFFER_HIGH_WATER_MARK = valueOf("WRITE_BUFFER_HIGH_WATER_MARK");

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -283,6 +283,8 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
             throw new NotYetConnectedException();
         case CLOSED:
             throw new ClosedChannelException();
+        case CONNECTED:
+            break;
         }
 
         final LocalChannel peer = this.peer;

File: transport/src/main/java/io/netty/channel/pool/ChannelPool.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.util.concurrent.Promise;
 
 import java.io.Closeable;
-import java.io.IOException;
 
 /**
  * Allows to acquire and release {@link Channel} and so act as a pool of these.

File: transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
Patch:
@@ -157,6 +157,7 @@ public interface DatagramChannelConfig extends ChannelConfig {
     DatagramChannelConfig setNetworkInterface(NetworkInterface networkInterface);
 
     @Override
+    @Deprecated
     DatagramChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
Patch:
@@ -373,6 +373,7 @@ public DatagramChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
     }
 
     @Override
+    @Deprecated
     public DatagramChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java
Patch:
@@ -286,6 +286,7 @@ public SocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
     }
 
     @Override
+    @Deprecated
     public SocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
Patch:
@@ -88,6 +88,7 @@ public interface ServerSocketChannelConfig extends ChannelConfig {
     ServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     ServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
Patch:
@@ -161,6 +161,7 @@ public interface SocketChannelConfig extends ChannelConfig {
     SocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     SocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -41,7 +41,7 @@
 public class NioServerSocketChannel extends AbstractNioMessageChannel
                              implements io.netty.channel.socket.ServerSocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
     private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioServerSocketChannel.class);

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
Patch:
@@ -121,6 +121,7 @@ public OioServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMi
     }
 
     @Override
+    @Deprecated
     public OioServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
Patch:
@@ -149,6 +149,7 @@ public OioSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis)
     }
 
     @Override
+    @Deprecated
     public OioSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
         super.setMaxMessagesPerRead(maxMessagesPerRead);
         return this;

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -44,7 +44,7 @@ public class OioServerSocketChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(OioServerSocketChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
 
     private static ServerSocket newServerSocket() {
         try {

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
Patch:
@@ -67,6 +67,7 @@ public interface OioServerSocketChannelConfig extends ServerSocketChannelConfig
     OioServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     OioServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
Patch:
@@ -82,6 +82,7 @@ public interface OioSocketChannelConfig extends SocketChannelConfig {
     OioSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
     @Override
+    @Deprecated
     OioSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
     @Override

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -60,9 +60,9 @@ public static AsciiString as(String value) {
     }
 
     /**
-     * Converts a byte array into an {@link AsciiString}.
+     * Converts a byte array into a {@link ByteString}.
      */
-    public static ByteString as(byte[] value) {
+    public static ByteString bs(byte[] value) {
         return new ByteString(value);
     }
 
@@ -86,7 +86,7 @@ public static byte[] randomBytes(int size) {
      * Returns an {@link AsciiString} that wraps a randomly-filled byte array.
      */
     public static ByteString randomString() {
-        return as(randomBytes());
+        return bs(randomBytes());
     }
 
     private Http2TestUtil() {

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompTestConstants.java
Patch:
@@ -18,8 +18,8 @@
 public final class StompTestConstants {
     public static final String CONNECT_FRAME =
         "CONNECT\n" +
-            "host:stomp.github.org\n" +
             "accept-version:1.1,1.2\n" +
+            "host:stomp.github.org\n" +
             '\n' +
             '\0';
     public static final String CONNECTED_FRAME =

File: codec/src/test/java/io/netty/handler/codec/DefaultTextHeadersTest.java
Patch:
@@ -243,11 +243,11 @@ private static void assertCsvValue(final TextHeaders headers, final HeaderValue
     }
 
     private static TextHeaders newDefaultTextHeaders() {
-        return new DefaultTextHeaders();
+        return new DefaultTextHeaders(false);
     }
 
     private static TextHeaders newCsvTextHeaders() {
-        return new DefaultTextHeaders(true, true);
+        return new DefaultTextHeaders(true);
     }
 
     private static void addValues(final TextHeaders headers, HeaderValue... headerValues) {

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -187,13 +187,13 @@ private static List<Entry<String, String>> formget(
         );
 
         // send request
-        List<Entry<String, String>> entries = headers.entries();
         channel.writeAndFlush(request);
 
         // Wait for the server to close the connection.
         channel.closeFuture().sync();
 
-        return entries;
+        // convert headers to list
+        return headers.entries();
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
Patch:
@@ -305,6 +305,9 @@ static void validateHeaderName(CharSequence name) {
                 throw new IllegalArgumentException(
                         "name contains null character: " + name);
             }
+            if (c >= 'A' && c <= 'Z') {
+                throw new IllegalArgumentException("name must be all lower case.");
+            }
             if (c > 127) {
                 throw new IllegalArgumentException(
                         "name contains non-ascii character: " + name);

File: common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
Patch:
@@ -53,10 +53,10 @@ public final class NativeLibraryLoader {
             }
 
             WORKDIR = f;
-            logger.debug("-Dio.netty.netty.workdir: " + WORKDIR);
+            logger.debug("-Dio.netty.native.workdir: " + WORKDIR);
         } else {
             WORKDIR = tmpdir();
-            logger.debug("-Dio.netty.netty.workdir: " + WORKDIR + " (io.netty.tmpdir)");
+            logger.debug("-Dio.netty.native.workdir: " + WORKDIR + " (io.netty.tmpdir)");
         }
     }
 

File: common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java
Patch:
@@ -75,7 +75,7 @@ public final class ThreadLocalRandom extends Random {
     static {
         if (initialSeedUniquifier == 0) {
             // Try to generate a real random number from /dev/random.
-            // Get from a different thread to avoid blocking indefinitely on a machine without much entrophy.
+            // Get from a different thread to avoid blocking indefinitely on a machine without much entropy.
             seedGeneratorThread = new Thread("initialSeedUniquifierGenerator") {
                 @Override
                 public void run() {
@@ -156,7 +156,7 @@ public static long getInitialSeedUniquifier() {
                     seedGeneratorThread.interrupt();
                     logger.warn(
                             "Failed to generate a seed from SecureRandom within {} seconds. " +
-                            "Not enough entrophy?", timeoutSeconds
+                            "Not enough entropy?", timeoutSeconds
                     );
                     break;
                 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -34,9 +34,9 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http2.Http2Stream.State;
+import io.netty.util.collection.IntCollections;
 import io.netty.util.collection.IntObjectHashMap;
 import io.netty.util.collection.IntObjectMap;
-import io.netty.util.collection.PrimitiveCollections;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
@@ -292,7 +292,7 @@ private class DefaultStream implements Http2Stream {
         private State state;
         private short weight = DEFAULT_PRIORITY_WEIGHT;
         private DefaultStream parent;
-        private IntObjectMap<DefaultStream> children = PrimitiveCollections.emptyIntObjectMap();
+        private IntObjectMap<DefaultStream> children = IntCollections.emptyMap();
         private int totalChildWeights;
         private int prioritizableForTree = 1;
         private boolean resetSent;
@@ -539,7 +539,7 @@ private boolean isPrioritizable() {
         }
 
         private void initChildrenIfEmpty() {
-            if (children == PrimitiveCollections.<DefaultStream>emptyIntObjectMap()) {
+            if (children == IntCollections.<DefaultStream>emptyMap()) {
                 initChildren();
             }
         }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -59,7 +59,6 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;
 import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;
-import io.netty.util.collection.CharObjectMap;
 
 /**
  * A {@link Http2FrameWriter} that supports all frame types defined by the HTTP/2 specification.
@@ -213,7 +212,7 @@ public ChannelFuture writeSettings(ChannelHandlerContext ctx, Http2Settings sett
             int payloadLength = SETTING_ENTRY_LENGTH * settings.size();
             ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH + settings.size() * SETTING_ENTRY_LENGTH);
             writeFrameHeaderInternal(buf, payloadLength, SETTINGS, new Http2Flags(), 0);
-            for (CharObjectMap.PrimitiveEntry<Long> entry : settings.entries()) {
+            for (Http2Settings.PrimitiveEntry<Long> entry : settings.entries()) {
                 writeUnsignedShort(entry.key(), buf);
                 writeUnsignedInt(entry.value(), buf);
             }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -387,8 +387,7 @@ public final int numChildren() {
 
         @Override
         public Http2Stream forEachChild(Http2StreamVisitor visitor) throws Http2Exception {
-            for (IntObjectHashMap.Entry<DefaultStream> entry : children.entries()) {
-                Http2Stream stream = entry.value();
+            for (DefaultStream stream : children.values()) {
                 if (!visitor.visit(stream)) {
                     return stream;
                 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -484,7 +484,7 @@ private void readSettingsFrame(ChannelHandlerContext ctx, ByteBuf payload,
                 char id = (char) payload.readUnsignedShort();
                 long value = payload.readUnsignedInt();
                 try {
-                    settings.put(id, value);
+                    settings.put(id, Long.valueOf(value));
                 } catch (IllegalArgumentException e) {
                     switch(id) {
                     case SETTINGS_MAX_FRAME_SIZE:

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
Patch:
@@ -213,7 +213,7 @@ public ChannelFuture writeSettings(ChannelHandlerContext ctx, Http2Settings sett
             int payloadLength = SETTING_ENTRY_LENGTH * settings.size();
             ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH + settings.size() * SETTING_ENTRY_LENGTH);
             writeFrameHeaderInternal(buf, payloadLength, SETTINGS, new Http2Flags(), 0);
-            for (CharObjectMap.Entry<Long> entry : settings.entries()) {
+            for (CharObjectMap.PrimitiveEntry<Long> entry : settings.entries()) {
                 writeUnsignedShort(entry.key(), buf);
                 writeUnsignedInt(entry.value(), buf);
             }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2SettingsTest.java
Patch:
@@ -65,14 +65,14 @@ public void standardSettingsShouldBeSet() {
     @Test
     public void nonStandardSettingsShouldBeSet() {
         char key = 0;
-        settings.put(key, 123L);
+        settings.put(key, (Long) 123L);
         assertEquals(123L, (long) settings.get(key));
     }
 
     @Test
     public void settingsShouldSupportUnsignedShort() {
         char key = (char) (Short.MAX_VALUE + 1);
-        settings.put(key, 123L);
+        settings.put(key, (Long) 123L);
         assertEquals(123L, (long) settings.get(key));
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
Patch:
@@ -28,6 +28,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Map;
 import java.util.Queue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -289,8 +290,8 @@ private void closeAll() {
         }
         Collection<AbstractEpollChannel> array = new ArrayList<AbstractEpollChannel>(channels.size());
 
-        for (IntObjectMap.Entry<AbstractEpollChannel> entry: channels.entries()) {
-            array.add(entry.value());
+        for (AbstractEpollChannel channel: channels.values()) {
+            array.add(channel);
         }
 
         for (AbstractEpollChannel ch: array) {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java
Patch:
@@ -107,8 +107,7 @@ public SelectedListenerFailureBehavior selectedListenerFailureBehavior() {
                 "AES128-GCM-SHA256",
                 "AES128-SHA",
                 "AES256-SHA",
-                "DES-CBC3-SHA",
-                "RC4-SHA");
+                "DES-CBC3-SHA");
         DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);
 
         if (logger.isDebugEnabled()) {

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -152,7 +152,7 @@ public static Collection<Object[]> data() throws Exception {
                     if (rt == RenegotiationType.NONE) {
                         r = Renegotiation.NONE;
                     } else {
-                        r = new Renegotiation(rt, "SSL_RSA_WITH_RC4_128_SHA");
+                        r = new Renegotiation(rt, "SSL_RSA_WITH_3DES_EDE_CBC_SHA");
                     }
 
                     for (int i = 0; i < 32; i++) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
Patch:
@@ -204,7 +204,7 @@ public void alternatingWritesToActiveAndBufferedStreams() {
     public void bufferingNewStreamFailsAfterGoAwayReceived() {
         encoder.writeSettingsAck(ctx, promise);
         setMaxConcurrentStreams(0);
-        connection.goAwayReceived(1, 8, null);
+        connection.goAwayReceived(1, 8, EMPTY_BUFFER);
 
         promise = mock(ChannelPromise.class);
         encoderWriteHeaders(3, promise);

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -114,7 +114,7 @@ static class FrameAdapter extends ByteToMessageDecoder {
             this.latch = latch;
         }
 
-        public Http2Stream getOrCreateStream(int streamId, boolean halfClosed) throws Http2Exception {
+        private Http2Stream getOrCreateStream(int streamId, boolean halfClosed) throws Http2Exception {
             return getOrCreateStream(connection, streamId, halfClosed);
         }
 

File: transport/src/main/java/io/netty/channel/socket/DatagramChannel.java
Patch:
@@ -24,7 +24,7 @@
 import java.net.NetworkInterface;
 
 /**
- * A UDP/IP {@link Channel}}.
+ * A UDP/IP {@link Channel}.
  */
 public interface DatagramChannel extends Channel {
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -249,9 +249,7 @@ public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf dat
                 throw e;
             } finally {
                 // If appropriate, return the processed bytes to the flow controller.
-                if (bytesToReturn > 0) {
-                    flowController.consumeBytes(ctx, stream, bytesToReturn);
-                }
+                flowController.consumeBytes(ctx, stream, bytesToReturn);
 
                 if (endOfStream) {
                     lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -77,8 +77,9 @@ public void remoteSettings(Http2Settings settings) throws Http2Exception {
         Http2HeaderTable outboundHeaderTable = config.headerTable();
         Http2FrameSizePolicy outboundFrameSizePolicy = config.frameSizePolicy();
         if (pushEnabled != null) {
-            if (!connection.isServer()) {
-                throw connectionError(PROTOCOL_ERROR, "Client received SETTINGS frame with ENABLE_PUSH specified");
+            if (!connection.isServer() && pushEnabled) {
+                throw connectionError(PROTOCOL_ERROR,
+                    "Client received a value of ENABLE_PUSH specified to other than 0");
             }
             connection.remote().allowPushTo(pushEnabled);
         }

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -88,7 +88,7 @@
  * <pre>
  * // Iterates the readable bytes of a buffer.
  * {@link ByteBuf} buffer = ...;
- * while (buffer.readable()) {
+ * while (buffer.isReadable()) {
  *     System.out.println(buffer.readByte());
  * }
  * </pre>

File: transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java
Patch:
@@ -264,7 +264,7 @@ private void decrementAndRunTaskQueue() {
     }
 
     private void runTaskQueue() {
-        while (acquiredChannelCount <= maxConnections) {
+        while (acquiredChannelCount < maxConnections) {
             AcquireTask task = pendingAcquireQueue.poll();
             if (task == null) {
                 break;

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -184,8 +184,8 @@ public OpenSslClientContext(File trustCertChainFile, TrustManagerFactory trustMa
             }
             synchronized (OpenSslContext.class) {
                 if (trustCertChainFile != null) {
-                    /* Load the certificate chain. We must skip the first cert when server mode */
-                    if (!SSLContext.setCertificateChainFile(ctx, trustCertChainFile.getPath(), true)) {
+                    /* Load the certificate chain. We must NOT skip the first cert when client mode */
+                    if (!SSLContext.setCertificateChainFile(ctx, trustCertChainFile.getPath(), false)) {
                         long error = SSL.getLastErrorNumber();
                         if (OpenSsl.isError(error)) {
                             throw new SSLException(

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -320,7 +320,7 @@ public void testOversizedResponse() {
 
     @Test(expected = IllegalArgumentException.class)
     public void testInvalidConstructorUsage() {
-        new HttpObjectAggregator(0);
+        new HttpObjectAggregator(-1);
     }
 
     @Test(expected = IllegalArgumentException.class)

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -419,7 +419,7 @@ protected static void appendHexDump(StringBuilder dump, ByteBuf buf) {
 
         // Dump the rows which have 16 bytes.
         for (int row = 0; row < fullRows; row ++) {
-            int rowStartIndex = row << 4;
+            int rowStartIndex = (row << 4) + startIndex;
 
             // Per-row prefix.
             appendHexDumpRowPrefix(dump, row, rowStartIndex);
@@ -440,7 +440,7 @@ protected static void appendHexDump(StringBuilder dump, ByteBuf buf) {
 
         // Dump the last row which has less than 16 bytes.
         if (remainder != 0) {
-            int rowStartIndex = fullRows << 4;
+            int rowStartIndex = (fullRows << 4) + startIndex;
             appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);
 
             // Hex dump

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -55,6 +55,7 @@ public final class Native {
     public static final int EPOLLOUT = epollout();
     public static final int EPOLLRDHUP = epollrdhup();
     public static final int EPOLLET = epollet();
+    public static final int EPOLLERR = epollerr();
 
     public static final int IOV_MAX = iovMax();
     public static final int UIO_MAX_IOV = uioMaxIov();
@@ -701,6 +702,7 @@ private static class NativeInetAddress {
     private static native int epollout();
     private static native int epollrdhup();
     private static native int epollet();
+    private static native int epollerr();
 
     private static native long ssizeMax();
     private Native() {

File: example/src/main/java/io/netty/example/http2/tiles/Http2Server.java
Patch:
@@ -48,7 +48,6 @@
 public class Http2Server {
 
     public static final int PORT = Integer.parseInt(System.getProperty("http2-port", "8443"));
-    static final int MAX_CONTENT_LENGTH = 1024 * 100;
 
     private final EventLoopGroup group;
 
@@ -63,7 +62,7 @@ public ChannelFuture start() throws Exception {
         b.group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
             protected void initChannel(SocketChannel ch) throws Exception {
-                ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()), new Http2OrHttpHandler(MAX_CONTENT_LENGTH));
+                ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()), new Http2OrHttpHandler());
             }
         });
 

File: handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolUtil.java
Patch:
@@ -22,6 +22,7 @@
  * Utility class for application protocol common operations.
  */
 final class ApplicationProtocolUtil {
+
     private static final int DEFAULT_LIST_SIZE = 2;
 
     private ApplicationProtocolUtil() {

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -61,13 +61,13 @@ public final class WebSocketClient {
 
     public static void main(String[] args) throws Exception {
         URI uri = new URI(URL);
-        String scheme = uri.getScheme() == null? "http" : uri.getScheme();
+        String scheme = uri.getScheme() == null? "ws" : uri.getScheme();
         final String host = uri.getHost() == null? "127.0.0.1" : uri.getHost();
         final int port;
         if (uri.getPort() == -1) {
-            if ("http".equalsIgnoreCase(scheme)) {
+            if ("ws".equalsIgnoreCase(scheme)) {
                 port = 80;
-            } else if ("https".equalsIgnoreCase(scheme)) {
+            } else if ("wss".equalsIgnoreCase(scheme)) {
                 port = 443;
             } else {
                 port = -1;

File: resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java
Patch:
@@ -28,7 +28,6 @@
 import io.netty.handler.codec.dns.DnsRecord;
 import io.netty.handler.codec.dns.DnsRecordType;
 import io.netty.handler.codec.dns.DnsResponse;
-import io.netty.resolver.dns.DnsNameResolver.DnsCacheEntry;
 import io.netty.util.concurrent.Promise;
 import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.OneTimeTask;
@@ -219,6 +218,6 @@ private void cache(final DnsQuestion question, Throwable cause) {
             return;
         }
 
-        parent.cache(question, new DnsCacheEntry(cause), negativeTtl);
+        parent.cacheFailure(question, cause, negativeTtl);
     }
 }

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -72,7 +72,7 @@ public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C ext
     }
 
     /**
-     * The {@link EventLoopGroup} which is used to handle all the events for the to-be-creates
+     * The {@link EventLoopGroup} which is used to handle all the events for the to-be-created
      * {@link Channel}
      */
     @SuppressWarnings("unchecked")

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -300,7 +300,6 @@ public void initChannel(Channel sch) throws Exception {
                 renegoFuture = clientSslHandler.renegotiate();
                 logStats("CLIENT RENEGOTIATES");
                 assertThat(renegoFuture, is(not(sameInstance(clientHandshakeFuture))));
-                assertThat(renegoFuture.isDone(), is(false));
             }
         }
 

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -441,11 +441,12 @@ public final void trim() {
         @SuppressWarnings({ "unchecked", "rawtypes" })
         private  void freeEntry(Entry entry) {
             PoolChunk chunk = entry.chunk;
+            long handle = entry.handle;
 
             // recycle now so PoolChunk can be GC'ed.
             entry.recycle();
 
-            chunk.arena.freeChunk(chunk, entry.handle, sizeClass);
+            chunk.arena.freeChunk(chunk, handle, sizeClass);
         }
 
         static final class Entry<T> {

File: testsuite/src/main/java/io/netty/testsuite/transport/AbstractTestsuiteTest.java
Patch:
@@ -57,7 +57,7 @@ protected void run() throws Throwable {
                         "Running: %s %d of %d with %s",
                         testName.getMethodName(), ++ i, combos.size(), StringUtil.simpleClassName(allocator)));
                 try {
-                    Method m = getClass().getDeclaredMethod(
+                    Method m = getClass().getMethod(
                             TestUtils.testMethodName(testName), clazz);
                     m.invoke(this, cb);
                 } catch (InvocationTargetException ex) {

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -151,8 +151,8 @@ public static boolean hasUnsafe() {
     }
 
     /**
-     * Returns {@code true} if the platform has reliable low-level direct buffer access API and a user specified
-     * {@code -Dio.netty.preferDirect} option.
+     * Returns {@code true} if the platform has reliable low-level direct buffer access API and a user has not specified
+     * {@code -Dio.netty.noPreferDirect} option.
      */
     public static boolean directBufferPreferred() {
         return DIRECT_BUFFER_PREFERRED;

File: example/src/main/java/io/netty/example/http2/server/Http2ServerInitializer.java
Patch:
@@ -70,7 +70,7 @@ private static void configureClearText(SocketChannel ch) {
         ch.pipeline().addLast(upgradeHandler);
         ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpMessage>() {
             @Override
-            protected void messageReceived(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {
+            protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {
                 // If this handler is hit then no upgrade has been attempted and the client is just talking HTTP.
                 System.err.println("Directly talking: " + msg.protocolVersion() + " (no upgrade was attempted)");
                 ctx.pipeline().replace(this, "http-hello-world",

File: handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
Patch:
@@ -40,7 +40,7 @@
  * An {@link TrustManagerFactory} that trusts an X.509 certificate whose SHA1 checksum matches.
  * <p>
  * <strong>NOTE:</strong>
- * Never use this {@link TrustManagerFactory} in production unless you are not sure what you are exactly doing with it.
+ * Never use this {@link TrustManagerFactory} in production unless you are sure exactly what you are doing with it.
  * </p><p>
  * The SHA1 checksum of an X.509 certificate is calculated from its DER encoded format.  You can get the fingerprint of
  * an X.509 certificate using the {@code openssl} command.  For example:

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
Patch:
@@ -137,7 +137,7 @@ public String toString() {
                HttpHeaderValues.FORM_DATA + "; " + HttpHeaderValues.NAME + "=\"" + getName() +
                 "\"; " + HttpHeaderValues.FILENAME + "=\"" + filename + "\"\r\n" +
                 HttpHeaderNames.CONTENT_TYPE + ": " + contentType +
-                (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset() + "\r\n" : "\r\n") +
+                (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset().name() + "\r\n" : "\r\n") +
                 HttpHeaderNames.CONTENT_LENGTH + ": " + length() + "\r\n" +
                 "Completed: " + isCompleted() +
                 "\r\nIsInMemory: " + isInMemory() + "\r\nRealFile: " +

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -512,7 +512,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                 internal.addValue(HttpHeaderNames.CONTENT_TYPE + ": " +
                         HttpPostBodyUtil.DEFAULT_TEXT_CONTENT_TYPE + "; " +
                         HttpHeaderValues.CHARSET + '='
-                        + localcharset + "\r\n");
+                        + localcharset.name() + "\r\n");
             }
             // CRLF between body header and data
             internal.addValue("\r\n");
@@ -664,7 +664,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                 internal.addValue("\r\n" + HttpHeaderNames.CONTENT_TRANSFER_ENCODING + ": "
                         + HttpPostBodyUtil.TransferEncodingMechanism.BINARY.value() + "\r\n\r\n");
             } else if (fileUpload.getCharset() != null) {
-                internal.addValue("; " + HttpHeaderValues.CHARSET + '=' + fileUpload.getCharset() + "\r\n\r\n");
+                internal.addValue("; " + HttpHeaderValues.CHARSET + '=' + fileUpload.getCharset().name() + "\r\n\r\n");
             } else {
                 internal.addValue("\r\n\r\n");
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
Patch:
@@ -124,7 +124,7 @@ public String toString() {
                HttpHeaderValues.FORM_DATA + "; " + HttpHeaderValues.NAME + "=\"" + getName() +
             "\"; " + HttpHeaderValues.FILENAME + "=\"" + filename + "\"\r\n" +
             HttpHeaderNames.CONTENT_TYPE + ": " + contentType +
-            (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset() + "\r\n" : "\r\n") +
+            (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset().name() + "\r\n" : "\r\n") +
             HttpHeaderNames.CONTENT_LENGTH + ": " + length() + "\r\n" +
             "Completed: " + isCompleted() +
             "\r\nIsInMemory: " + isInMemory();

File: transport/src/main/java/io/netty/channel/DefaultChannelId.java
Patch:
@@ -280,7 +280,7 @@ private static int compareAddresses(InetAddress current, InetAddress candidate)
     }
 
     private static int scoreAddress(InetAddress addr) {
-        if (addr.isAnyLocalAddress()) {
+        if (addr.isAnyLocalAddress() || addr.isLoopbackAddress()) {
             return 0;
         }
         if (addr.isMulticastAddress()) {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -529,7 +529,7 @@ public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int stream
 
         /**
          * Helper method for determining whether or not to ignore inbound frames. A stream is considered to be created
-         * after a go away is sent if the following conditions hold:
+         * after a {@code GOAWAY} is sent if the following conditions hold:
          * <p/>
          * <ul>
          *     <li>A {@code GOAWAY} must have been sent by the local endpoint</li>

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -605,8 +605,7 @@ private int write(FlowControlled frame, int allowedBytes) {
                     frame.writeComplete();
                 }
             } catch (Throwable t) {
-                // Mark the state as cancelled, we'll clear the pending queue
-                // via cancel() below.
+                // Mark the state as cancelled, we'll clear the pending queue via cancel() below.
                 cancelled = true;
                 cause = t;
             } finally {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -33,7 +33,7 @@
  * <li>Sun Nov  6 08:49:37 1994: obsolete specification</li>
  * </ul>
  */
-final class HttpHeaderDateFormat extends SimpleDateFormat {
+public final class HttpHeaderDateFormat extends SimpleDateFormat {
     private static final long serialVersionUID = -925286159755905325L;
 
     private final SimpleDateFormat format1 = new HttpHeaderDateFormatObsolete1();
@@ -47,7 +47,7 @@ protected HttpHeaderDateFormat initialValue() {
                 }
             };
 
-    static HttpHeaderDateFormat get() {
+    public static HttpHeaderDateFormat get() {
         return dateFormatThreadLocal.get();
     }
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -20,14 +20,14 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.codec.http.ClientCookieEncoder;
-import io.netty.handler.codec.http.DefaultCookie;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
+import io.netty.handler.codec.http.cookie.DefaultCookie;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
@@ -91,7 +91,7 @@ public static void main(String[] args) throws Exception {
             // Set some example cookies.
             request.headers().set(
                     HttpHeaderNames.COOKIE,
-                    ClientCookieEncoder.encode(
+                    ClientCookieEncoder.STRICT.encode(
                             new DefaultCookie("my-cookie", "foo"),
                             new DefaultCookie("another-cookie", "bar")));
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -21,8 +21,6 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.codec.http.ClientCookieEncoder;
-import io.netty.handler.codec.http.DefaultCookie;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
@@ -31,6 +29,8 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.QueryStringEncoder;
+import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
+import io.netty.handler.codec.http.cookie.DefaultCookie;
 import io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;
 import io.netty.handler.codec.http.multipart.DiskAttribute;
 import io.netty.handler.codec.http.multipart.DiskFileUpload;
@@ -181,7 +181,7 @@ private static List<Entry<String, String>> formget(
         // headers.set("Keep-Alive","300");
 
         headers.set(
-                HttpHeaderNames.COOKIE, ClientCookieEncoder.encode(
+                HttpHeaderNames.COOKIE, ClientCookieEncoder.STRICT.encode(
                         new DefaultCookie("my-cookie", "foo"),
                         new DefaultCookie("another-cookie", "bar"))
         );

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -192,8 +192,8 @@ private void decrementPendingOutboundBytes(long size, boolean invokeLater, boole
         }
 
         long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, -size);
-        if (notifyWritability && newWriteBufferSize == 0
-            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark()) {
+        if (notifyWritability && (newWriteBufferSize == 0
+            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark())) {
             setWritable(invokeLater);
         }
     }

File: transport/src/main/java/io/netty/channel/ChannelPromiseNotifier.java
Patch:
@@ -32,5 +32,4 @@ public final class ChannelPromiseNotifier
     public ChannelPromiseNotifier(ChannelPromise... promises) {
         super(promises);
     }
-
 }

File: common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.RandomAccess;
 
 /**
- * A simple list which is reyclable. This implementation does not allow {@code null} elements to be added.
+ * A simple list which is recyclable. This implementation does not allow {@code null} elements to be added.
  */
 public final class RecyclableArrayList extends ArrayList<Object> {
 

File: testsuite/src/main/java/io/netty/testsuite/util/TestUtils.java
Patch:
@@ -239,7 +239,7 @@ public boolean accept(File dir, String name) {
         });
 
         final byte[] buf = new byte[65536];
-        final LZMA2Options options = new LZMA2Options(9);
+        final LZMA2Options options = new LZMA2Options(LZMA2Options.PRESET_DEFAULT);
 
         for (File file: files) {
             final String filename = file.toString();
@@ -277,8 +277,8 @@ public boolean accept(File dir, String name) {
                 }
                 out.close();
                 in.close();
-            } catch (Exception e) {
-                logger.warn("Failed to compress the heap dump: {}", xzFilename, e);
+            } catch (Throwable t) {
+                logger.warn("Failed to compress the heap dump: {}", xzFilename, t);
             } finally {
                 if (in != null) {
                     try {

File: codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2015 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,7 +15,6 @@
  */
 
 /**
- * DNS codec information for writing to and reading from a DNS server.
- * Includes decoders and classes for representing messages and resources.
+ * DNS codec.
  */
 package io.netty.handler.codec.dns;

File: common/src/main/java/io/netty/util/internal/StringUtil.java
Patch:
@@ -329,7 +329,7 @@ public static String simpleClassName(Class<?> clazz) {
      *
      * @param value The value which will be escaped according to
      *              <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>
-     * @return {@link CharSequence} the escaped value if nesessary, or the value unchanged
+     * @return {@link CharSequence} the escaped value if necessary, or the value unchanged
      */
     public static CharSequence escapeCsv(CharSequence value) {
         int length = checkNotNull(value, "value").length();
@@ -354,7 +354,7 @@ public static CharSequence escapeCsv(CharSequence value) {
                     } else {
                         boolean isNextCharDoubleQuote = isDoubleQuote(value.charAt(i + 1));
                         if (!isDoubleQuote(value.charAt(i - 1)) &&
-                                (!isNextCharDoubleQuote || isNextCharDoubleQuote && i + 1 == last)) {
+                                (!isNextCharDoubleQuote || i + 1 == last)) {
                             escaped.append(DOUBLE_QUOTE);
                             escapedDoubleQuote = true;
                         }

File: transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
Patch:
@@ -315,6 +315,7 @@ protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Ex
         final MessageInfo mi = MessageInfo.createOutgoing(association(), null, packet.streamIdentifier());
         mi.payloadProtocolID(packet.protocolIdentifier());
         mi.streamNumber(packet.streamIdentifier());
+        mi.unordered(packet.isUnordered());
 
         final int writtenBytes = javaChannel().send(nioData, mi);
         return writtenBytes > 0;
@@ -329,7 +330,8 @@ protected final Object filterOutboundMessage(Object msg) throws Exception {
                 return m;
             }
 
-            return new SctpMessage(m.protocolIdentifier(), m.streamIdentifier(), newDirectBuffer(m, buf));
+            return new SctpMessage(m.protocolIdentifier(), m.streamIdentifier(), m.isUnordered(),
+                                   newDirectBuffer(m, buf));
         }
 
         throw new UnsupportedOperationException(

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
Patch:
@@ -258,6 +258,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                 final MessageInfo mi = MessageInfo.createOutgoing(association(), null, packet.streamIdentifier());
                 mi.payloadProtocolID(packet.protocolIdentifier());
                 mi.streamNumber(packet.streamIdentifier());
+                mi.unordered(packet.isUnordered());
 
                 ch.send(nioData, mi);
                 written ++;

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
Patch:
@@ -41,6 +41,7 @@ protected void decode(ChannelHandlerContext ctx, SctpMessage msg, List<Object> o
         final int protocolIdentifier = msg.protocolIdentifier();
         final int streamIdentifier = msg.streamIdentifier();
         final boolean isComplete = msg.isComplete();
+        final boolean isUnordered = msg.isUnordered();
 
         ByteBuf frag;
         if (fragments.containsKey(streamIdentifier)) {
@@ -61,6 +62,7 @@ protected void decode(ChannelHandlerContext ctx, SctpMessage msg, List<Object> o
             SctpMessage assembledMsg = new SctpMessage(
                     protocolIdentifier,
                     streamIdentifier,
+                    isUnordered,
                     Unpooled.wrappedBuffer(frag, byteBuf));
             out.add(assembledMsg);
         } else {

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -233,6 +233,7 @@ protected void doDisconnect() throws Exception {
 
     @Override
     protected void doClose() throws Exception {
+        super.doClose();
         javaChannel().close();
     }
 

File: microbench/src/main/java/io/netty/microbench/http2/Http2PriorityTreeBenchmark.java
Patch:
@@ -53,7 +53,7 @@ public class Http2PriorityTreeBenchmark extends AbstractMicrobenchmark {
     public void setup() throws Http2Exception {
         connection = new DefaultHttp2Connection(false);
         for (int i = 0; i < numStreams; ++i) {
-            connection.local().createStream(toStreamId(i));
+            connection.local().createStream(toStreamId(i), false);
         }
     }
 

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowControllerTest.java
Patch:
@@ -1233,8 +1233,8 @@ private int streamableBytesForTree(Http2Stream stream) {
         return controller.streamableBytesForTree(stream);
     }
 
-    private Http2Stream stream(int streamId) throws Http2Exception {
-        return connection.requireStream(streamId);
+    private Http2Stream stream(int streamId) {
+        return connection.stream(streamId);
     }
 
     private static final class FakeFlowControlled implements Http2RemoteFlowController.FlowControlled {

File: codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
Patch:
@@ -130,7 +130,7 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Except
                     fail(ctx, length);
                 }
             } else {
-                discardedBytes = buffer.readableBytes();
+                discardedBytes += buffer.readableBytes();
                 buffer.readerIndex(buffer.writerIndex());
             }
             return null;

File: handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java
Patch:
@@ -31,7 +31,7 @@ public final class SslContextBuilder {
      * Creates a builder for new client-side {@link SslContext}.
      */
     public static SslContextBuilder forClient() {
-        return new SslContextBuilder(true);
+        return new SslContextBuilder(false);
     }
 
     /**
@@ -41,7 +41,7 @@ public static SslContextBuilder forClient() {
      * @param keyFile a PKCS#8 private key file in PEM format
      */
     public static SslContextBuilder forServer(File keyCertChainFile, File keyFile) {
-        return new SslContextBuilder(false).keyManager(keyCertChainFile, keyFile);
+        return new SslContextBuilder(true).keyManager(keyCertChainFile, keyFile);
     }
 
     /**
@@ -54,7 +54,7 @@ public static SslContextBuilder forServer(File keyCertChainFile, File keyFile) {
      */
     public static SslContextBuilder forServer(
             File keyCertChainFile, File keyFile, String keyPassword) {
-        return new SslContextBuilder(false).keyManager(keyCertChainFile, keyFile, keyPassword);
+        return new SslContextBuilder(true).keyManager(keyCertChainFile, keyFile, keyPassword);
     }
 
     private final boolean forServer;

File: microbench/src/main/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java
Patch:
@@ -22,12 +22,15 @@
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.State;
 
 import java.util.Random;
 
 /**
  * This class benchmarks different allocators with different allocation sizes.
  */
+@State(Scope.Benchmark)
 public class ByteBufAllocatorBenchmark extends AbstractMicrobenchmark {
 
     private static final ByteBufAllocator unpooledAllocator = new UnpooledByteBufAllocator(true);

File: microbench/src/main/java/io/netty/microbench/internal/RecyclableArrayListBenchmark.java
Patch:
@@ -20,11 +20,14 @@
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Threads;
 
 /**
  * This class benchmarks different allocators with different allocation sizes.
  */
+@State(Scope.Benchmark)
 @Threads(4)
 @Measurement(iterations = 10, batchSize = 100)
 public class RecyclableArrayListBenchmark extends AbstractMicrobenchmark {

File: microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmark.java
Patch:
@@ -37,7 +37,7 @@ public class AbstractMicrobenchmark extends AbstractMicrobenchmarkBase {
     static {
         final String[] customArgs = {
         "-Xms768m", "-Xmx768m", "-XX:MaxDirectMemorySize=768m", "-Dharness.executor=CUSTOM",
-        "-Dharness.executor.class=io.netty.microbench.util.AbstractMicrobenchmark$HarnessExecutor" };
+        "-Dharness.executor.class=AbstractMicrobenchmark$HarnessExecutor" };
 
         JVM_ARGS = new String[BASE_JVM_ARGS.length + customArgs.length];
         System.arraycopy(BASE_JVM_ARGS, 0, JVM_ARGS, 0, BASE_JVM_ARGS.length);

File: microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java
Patch:
@@ -39,7 +39,7 @@ public class AbstractSharedExecutorMicrobenchmark extends AbstractMicrobenchmark
     static {
         final String[] customArgs = {
         "-Xms2g", "-Xmx2g", "-XX:MaxDirectMemorySize=2g", "-Dharness.executor=CUSTOM",
-    "-Dharness.executor.class=io.netty.microbench.util.AbstractSharedExecutorMicrobenchmark$DelegateHarnessExecutor" };
+    "-Dharness.executor.class=AbstractSharedExecutorMicrobenchmark$DelegateHarnessExecutor" };
 
         JVM_ARGS = new String[BASE_JVM_ARGS.length + customArgs.length];
         System.arraycopy(BASE_JVM_ARGS, 0, JVM_ARGS, 0, BASE_JVM_ARGS.length);

File: common/src/main/java/io/netty/util/ByteString.java
Patch:
@@ -400,7 +400,7 @@ public int hashCode() {
             for (int i = 0; i < value.length; ++i) {
                 h = h * HASH_CODE_PRIME ^ value[i] & HASH_CODE_PRIME;
             }
-            
+
             hash = h;
         }
         return h;

File: example/src/main/java/io/netty/example/discard/DiscardClient.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
@@ -40,7 +41,8 @@ public static void main(String[] args) throws Exception {
         // Configure SSL.
         final SslContext sslCtx;
         if (SSL) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/discard/DiscardServer.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -41,7 +42,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
@@ -44,7 +45,8 @@ public static void main(String[] args) throws Exception {
         // Configure SSL.git
         final SslContext sslCtx;
         if (SSL) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -42,7 +43,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/factorial/FactorialClient.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
@@ -38,7 +39,8 @@ public static void main(String[] args) throws Exception {
         // Configure SSL.
         final SslContext sslCtx;
         if (SSL) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/factorial/FactorialServer.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -38,7 +39,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/file/FileServer.java
Patch:
@@ -30,6 +30,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.util.CharsetUtil;
@@ -48,7 +49,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/cors/HttpCorsServer.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -80,7 +81,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.SslProvider;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
@@ -36,7 +37,8 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(SslProvider.JDK, ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
+                .sslProvider(SslProvider.JDK).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -40,7 +41,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -29,6 +29,7 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.net.URI;
@@ -63,7 +64,8 @@ public static void main(String[] args) throws Exception {
         final boolean ssl = "https".equalsIgnoreCase(scheme);
         final SslContext sslCtx;
         if (ssl) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -39,7 +40,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -38,6 +38,7 @@
 import io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.io.File;
@@ -87,7 +88,8 @@ public static void main(String[] args) throws Exception {
         final boolean ssl = "https".equalsIgnoreCase(scheme);
         final SslContext sslCtx;
         if (ssl) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -38,7 +39,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/websocketx/benchmarkserver/WebSocketServer.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -43,7 +44,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -34,6 +34,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketVersion;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
@@ -83,7 +84,8 @@ public static void main(String[] args) throws Exception {
         final boolean ssl = "wss".equalsIgnoreCase(scheme);
         final SslContext sslCtx;
         if (ssl) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -54,7 +55,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoClient.java
Patch:
@@ -27,6 +27,7 @@
 import io.netty.handler.codec.serialization.ObjectDecoder;
 import io.netty.handler.codec.serialization.ObjectEncoder;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
@@ -43,7 +44,8 @@ public static void main(String[] args) throws Exception {
         // Configure SSL.
         final SslContext sslCtx;
         if (SSL) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoServer.java
Patch:
@@ -29,6 +29,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -44,7 +45,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/portunification/PortUnificationServer.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -40,7 +41,8 @@ public final class PortUnificationServer {
     public static void main(String[] args) throws Exception {
         // Configure SSL context
         SelfSignedCertificate ssc = new SelfSignedCertificate();
-        final SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        final SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
+            .build();
 
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();

File: example/src/main/java/io/netty/example/securechat/SecureChatClient.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.example.telnet.TelnetClient;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.io.BufferedReader;
@@ -38,7 +39,8 @@ public final class SecureChatClient {
 
     public static void main(String[] args) throws Exception {
         // Configure SSL.
-        final SslContext sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        final SslContext sslCtx = SslContextBuilder.forClient()
+            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
 
         EventLoopGroup group = new NioEventLoopGroup();
         try {

File: example/src/main/java/io/netty/example/securechat/SecureChatServer.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -34,7 +35,8 @@ public final class SecureChatServer {
 
     public static void main(String[] args) throws Exception {
         SelfSignedCertificate ssc = new SelfSignedCertificate();
-        SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
+            .build();
 
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();

File: example/src/main/java/io/netty/example/telnet/TelnetClient.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.io.BufferedReader;
@@ -40,7 +41,8 @@ public static void main(String[] args) throws Exception {
         // Configure SSL.
         final SslContext sslCtx;
         if (SSL) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/telnet/TelnetServer.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -37,7 +38,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/worldclock/WorldClockClient.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.util.Arrays;
@@ -42,7 +43,8 @@ public static void main(String[] args) throws Exception {
         // Configure SSL.
         final SslContext sslCtx;
         if (SSL) {
-            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+            sslCtx = SslContextBuilder.forClient()
+                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/worldclock/WorldClockServer.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
@@ -38,7 +39,7 @@ public static void main(String[] args) throws Exception {
         final SslContext sslCtx;
         if (SSL) {
             SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
         } else {
             sslCtx = null;
         }

File: microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmarkBase.java
Patch:
@@ -42,7 +42,7 @@ public abstract class AbstractMicrobenchmarkBase {
     protected static final int DEFAULT_MEASURE_ITERATIONS = 10;
     protected static final String[] BASE_JVM_ARGS = {
         "-server", "-dsa", "-da", "-ea:io.netty...", "-XX:+AggressiveOpts", "-XX:+UseBiasedLocking",
-        "-XX:+UseFastAccessorMethods", "-XX:+UseStringCache", "-XX:+OptimizeStringConcat",
+        "-XX:+UseFastAccessorMethods", "-XX:+OptimizeStringConcat",
         "-XX:+HeapDumpOnOutOfMemoryError", "-Dio.netty.noResourceLeakDetection"};
 
     static {

File: microbench/src/test/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java
Patch:
@@ -33,13 +33,13 @@
 @Fork(AbstractSharedExecutorMicrobenchmark.DEFAULT_FORKS)
 public class AbstractSharedExecutorMicrobenchmark extends AbstractMicrobenchmarkBase {
 
-    protected static final int DEFAULT_FORKS = 0; // Forks has to be 0 so tasks are run immediately by JMH
+    protected static final int DEFAULT_FORKS = 1;
     protected static final String[] JVM_ARGS;
 
     static {
         final String[] customArgs = {
         "-Xms2g", "-Xmx2g", "-XX:MaxDirectMemorySize=2g", "-Dharness.executor=CUSTOM",
-        "-Dharness.executor.class=io.netty.microbench.util.AbstractExecutorMicrobenchmark$DelegateHarnessExecutor" };
+    "-Dharness.executor.class=io.netty.microbench.util.AbstractSharedExecutorMicrobenchmark$DelegateHarnessExecutor" };
 
         JVM_ARGS = new String[BASE_JVM_ARGS.length + customArgs.length];
         System.arraycopy(BASE_JVM_ARGS, 0, JVM_ARGS, 0, BASE_JVM_ARGS.length);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
Patch:
@@ -53,11 +53,11 @@
  */
 public class Http2ConnectionHandler extends ByteToMessageDecoder implements Http2LifecycleManager,
         ChannelOutboundHandler {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(Http2ConnectionHandler.class);
     private final Http2ConnectionDecoder decoder;
     private final Http2ConnectionEncoder encoder;
     private ChannelFutureListener closeListener;
     private BaseDecoder byteDecoder;
-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(Http2ConnectionHandler.class);
 
     public Http2ConnectionHandler(boolean server, Http2FrameListener listener) {
         this(new DefaultHttp2Connection(server), listener);

File: buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
Patch:
@@ -129,7 +129,7 @@ private static <T> NormalMemoryRegionCache<T>[] createNormalCaches(
             int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {
         if (cacheSize > 0) {
             int max = Math.min(area.chunkSize, maxCachedBufferCapacity);
-            int arraySize = Math.max(1, max / area.pageSize);
+            int arraySize = Math.max(1, log2(max / area.pageSize) + 1);
 
             @SuppressWarnings("unchecked")
             NormalMemoryRegionCache<T>[] cache = new NormalMemoryRegionCache[arraySize];

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -269,7 +269,7 @@ public abstract class ReplayingDecoder<S> extends ByteToMessageDecoder {
 
     static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class, "REPLAY");
 
-    private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer();
+    private final ReplayingDecoderByteBuf replayable = new ReplayingDecoderByteBuf();
     private S state;
     private int checkpoint = -1;
 

File: common/src/main/java/io/netty/util/internal/StringUtil.java
Patch:
@@ -33,9 +33,9 @@ public final class StringUtil {
     public static final char COMMA = ',';
     public static final char LINE_FEED = '\n';
     public static final char CARRIAGE_RETURN = '\r';
+    public static final String EMPTY_STRING = "";
     private static final String[] BYTE2HEX_PAD = new String[256];
     private static final String[] BYTE2HEX_NOPAD = new String[256];
-    private static final String EMPTY_STRING = "";
     /**
      * 2 - Quote character at beginning and end.
      * 5 - Extra allowance for anticipated escape characters that may be added.

File: example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
Patch:
@@ -61,8 +61,8 @@ public static void main(String[] args) throws Exception {
                 null, InsecureTrustManagerFactory.INSTANCE, null, IdentityCipherSuiteFilter.INSTANCE,
                 new ApplicationProtocolConfig(
                         Protocol.NPN,
-                        SelectorFailureBehavior.FATAL_ALERT,
-                        SelectedListenerFailureBehavior.FATAL_ALERT,
+                        SelectorFailureBehavior.CHOOSE_MY_LAST_PROTOCOL,
+                        SelectedListenerFailureBehavior.CHOOSE_MY_LAST_PROTOCOL,
                         SelectedProtocol.SPDY_3_1.protocolName(),
                         SelectedProtocol.HTTP_1_1.protocolName()),
                 0, 0);

File: example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
Patch:
@@ -61,8 +61,8 @@ public static void main(String[] args) throws Exception {
                 ssc.certificate(), ssc.privateKey(), null, null, IdentityCipherSuiteFilter.INSTANCE,
                 new ApplicationProtocolConfig(
                         Protocol.NPN,
-                        SelectorFailureBehavior.FATAL_ALERT,
-                        SelectedListenerFailureBehavior.FATAL_ALERT,
+                        SelectorFailureBehavior.CHOOSE_MY_LAST_PROTOCOL,
+                        SelectedListenerFailureBehavior.CHOOSE_MY_LAST_PROTOCOL,
                         SelectedProtocol.SPDY_3_1.protocolName(),
                         SelectedProtocol.HTTP_1_1.protocolName()),
                 0, 0);

File: handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolConfig.java
Patch:
@@ -79,6 +79,9 @@ private ApplicationProtocolConfig(
         if (protocol == Protocol.NONE) {
             throw new IllegalArgumentException("protocol (" + Protocol.NONE + ") must not be " + Protocol.NONE + '.');
         }
+        if (supportedProtocols.isEmpty()) {
+            throw new IllegalArgumentException("supportedProtocols must be not empty");
+        }
     }
 
     /**

File: handler/src/main/java/io/netty/handler/ssl/SslContext.java
Patch:
@@ -362,7 +362,7 @@ public static SslContext newServerContext(
         case OPENSSL:
             return new OpenSslServerContext(
                     keyCertChainFile, keyFile, keyPassword, trustManagerFactory,
-                    ciphers, apn, sessionCacheSize, sessionTimeout);
+                    ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout);
         default:
             throw new Error(provider.toString());
         }
@@ -655,7 +655,8 @@ public static SslContext newClientContext(
                         keyManagerFactory, ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout);
             case OPENSSL:
                 return new OpenSslClientContext(
-                        trustCertChainFile, trustManagerFactory, ciphers, apn, sessionCacheSize, sessionTimeout);
+                        trustCertChainFile, trustManagerFactory, ciphers, cipherFilter, apn,
+                        sessionCacheSize, sessionTimeout);
         }
         // Should never happen!!
         throw new Error();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
Patch:
@@ -97,7 +97,7 @@ interface Listener {
          * Called when a {@code GOAWAY} was received from the remote endpoint. This event handler duplicates {@link
          * Http2FrameListener#onGoAwayRead(io.netty.channel.ChannelHandlerContext, int, long, io.netty.buffer.ByteBuf)}
          * but is added here in order to simplify application logic for handling {@code GOAWAY} in a uniform way. An
-         * application should generally not handle both events, but if it does this method is called first, before
+         * application should generally not handle both events, but if it does this method is called second, after
          * notifying the {@link Http2FrameListener}.
          *
          * @param lastStreamId the last known stream of the remote endpoint.
@@ -206,9 +206,8 @@ interface Endpoint<F extends Http2FlowController> {
         int lastStreamCreated();
 
         /**
-         * Gets the last stream created by this endpoint that is "known" by the opposite endpoint.
          * If a GOAWAY was received for this endpoint, this will be the last stream ID from the
-         * GOAWAY frame. Otherwise, this will be same as {@link #lastStreamCreated()}.
+         * GOAWAY frame. Otherwise, this will be {@code -1}.
          */
         int lastKnownStream();
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
Patch:
@@ -465,7 +465,7 @@ private void incrementPrioritizableForTree0(int amt, Http2Stream oldParent) {
             assert amt > 0;
             prioritizableForTree += amt;
             if (parent != null && parent != oldParent) {
-                parent.incrementPrioritizableForTree(amt, oldParent);
+                parent.incrementPrioritizableForTree0(amt, oldParent);
             }
         }
 
@@ -487,7 +487,7 @@ private void decrementPrioritizableForTree0(int amt) {
             assert amt > 0;
             prioritizableForTree -= amt;
             if (parent != null) {
-                parent.decrementPrioritizableForTree(amt);
+                parent.decrementPrioritizableForTree0(amt);
             }
         }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
Patch:
@@ -69,6 +69,7 @@ public final class Http2CodecUtil {
     public static final int SETTINGS_INITIAL_WINDOW_SIZE = 4;
     public static final int SETTINGS_MAX_FRAME_SIZE = 5;
     public static final int SETTINGS_MAX_HEADER_LIST_SIZE = 6;
+    public static final int NUM_STANDARD_SETTINGS = 6;
 
     public static final int MAX_HEADER_TABLE_SIZE = Integer.MAX_VALUE; // Size limited by HPACK library
     public static final long MAX_CONCURRENT_STREAMS = MAX_UNSIGNED_INT;

File: common/src/main/java/io/netty/util/collection/IntObjectHashMap.java
Patch:
@@ -33,10 +33,10 @@
 public class IntObjectHashMap<V> implements IntObjectMap<V>, Iterable<IntObjectMap.Entry<V>> {
 
     /** Default initial capacity. Used if not specified in the constructor */
-    private static final int DEFAULT_CAPACITY = 11;
+    public static final int DEFAULT_CAPACITY = 11;
 
     /** Default load factor. Used if not specified in the constructor */
-    private static final float DEFAULT_LOAD_FACTOR = 0.5f;
+    public static final float DEFAULT_LOAD_FACTOR = 0.5f;
 
     /**
      * Placeholder for null values, so we can use the actual null to mean available.

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -957,7 +957,7 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
             ctx.read();
         }
 
-        ctx.fireChannelReadComplete();
+        super.channelReadComplete(ctx);
     }
 
     /**

File: codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
Patch:
@@ -40,7 +40,7 @@
 public class CompressorHttp2ConnectionEncoder extends DecoratingHttp2ConnectionEncoder {
     private static final Http2ConnectionAdapter CLEAN_UP_LISTENER = new Http2ConnectionAdapter() {
         @Override
-        public void streamRemoved(Http2Stream stream) {
+        public void onStreamRemoved(Http2Stream stream) {
             final EmbeddedChannel compressor = stream.getProperty(CompressorHttp2ConnectionEncoder.class);
             if (compressor != null) {
                 cleanup(stream, compressor);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
Patch:
@@ -169,7 +169,7 @@ private int unconsumedBytes(Http2Stream stream) {
     void onGoAwayRead0(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)
             throws Http2Exception {
         // Don't allow any more connections to be created.
-        connection.goAwayReceived(lastStreamId);
+        connection.goAwayReceived(lastStreamId, errorCode, debugData);
 
         listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -64,12 +64,12 @@ public DefaultHttp2LocalFlowController(Http2Connection connection,
         // Register for notification of new streams.
         connection.addListener(new Http2ConnectionAdapter() {
             @Override
-            public void streamAdded(Http2Stream stream) {
+            public void onStreamAdded(Http2Stream stream) {
                 stream.setProperty(FlowState.class, new FlowState(stream, 0));
             }
 
             @Override
-            public void streamActive(Http2Stream stream) {
+            public void onStreamActive(Http2Stream stream) {
                 // Need to be sure the stream's initial window is adjusted for SETTINGS
                 // frames which may have been exchanged while it was in IDLE
                 state(stream).window(initialWindowSize);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
Patch:
@@ -40,7 +40,7 @@
 public class DelegatingDecompressorFrameListener extends Http2FrameListenerDecorator {
     private static final Http2ConnectionAdapter CLEAN_UP_LISTENER = new Http2ConnectionAdapter() {
         @Override
-        public void streamRemoved(Http2Stream stream) {
+        public void onStreamRemoved(Http2Stream stream) {
             final Http2Decompressor decompressor = decompressor(stream);
             if (decompressor != null) {
                 cleanup(stream, decompressor);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -155,7 +155,7 @@ protected void removeMessage(int streamId) {
     }
 
     @Override
-    public void streamRemoved(Http2Stream stream) {
+    public void onStreamRemoved(Http2Stream stream) {
         removeMessage(stream.id());
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapter.java
Patch:
@@ -166,7 +166,7 @@ protected FullHttpMessage processHeadersBegin(ChannelHandlerContext ctx, int str
     }
 
     @Override
-    public void priorityTreeParentChanged(Http2Stream stream, Http2Stream oldParent) {
+    public void onPriorityTreeParentChanged(Http2Stream stream, Http2Stream oldParent) {
         Http2Stream parent = stream.parent();
         FullHttpMessage msg = messageMap.get(stream.id());
         if (msg == null) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java
Patch:
@@ -271,7 +271,7 @@ private void bootstrapEnv(int serverHalfClosedCount, int clientSettingsAckLatchC
 
         serverConnection.addListener(new Http2ConnectionAdapter() {
             @Override
-            public void streamHalfClosed(Http2Stream stream) {
+            public void onStreamHalfClosed(Http2Stream stream) {
                 serverLatch.countDown();
             }
         });

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java
Patch:
@@ -491,7 +491,7 @@ public void settingsReadShouldSetValues() throws Exception {
     @Test
     public void goAwayShouldReadShouldUpdateConnectionState() throws Exception {
         decode().onGoAwayRead(ctx, 1, 2L, EMPTY_BUFFER);
-        verify(connection).goAwayReceived(1);
+        verify(connection).goAwayReceived(eq(1), eq(2L), eq(EMPTY_BUFFER));
         verify(listener).onGoAwayRead(eq(ctx), eq(1), eq(2L), eq(EMPTY_BUFFER));
     }
 

File: codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
Patch:
@@ -40,9 +40,9 @@ public HttpToHttp2ConnectionHandler(Http2Connection connection, Http2FrameReader
         super(connection, frameReader, frameWriter, listener);
     }
 
-    public HttpToHttp2ConnectionHandler(Http2ConnectionDecoder.Builder decoderBuilder,
-            Http2ConnectionEncoder.Builder encoderBuilder) {
-        super(decoderBuilder, encoderBuilder);
+    public HttpToHttp2ConnectionHandler(Http2ConnectionDecoder decoder,
+                                        Http2ConnectionEncoder encoder) {
+        super(decoder, encoder);
     }
 
     /**

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java
Patch:
@@ -139,9 +139,8 @@ public void setup() throws Exception {
         when(ctx.newPromise()).thenReturn(promise);
         when(ctx.write(any())).thenReturn(future);
 
-        decoder = DefaultHttp2ConnectionDecoder.newBuilder().connection(connection)
-                        .frameReader(reader).encoder(encoder)
-                        .listener(listener).lifecycleManager(lifecycleManager).build();
+        decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader, listener);
+        decoder.lifecycleManager(lifecycleManager);
 
         // Simulate receiving the initial settings from the remote endpoint.
         decode().onSettingsRead(ctx, new Http2Settings());

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java
Patch:
@@ -195,8 +195,8 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         when(ctx.newPromise()).thenReturn(promise);
         when(ctx.write(any())).thenReturn(future);
 
-        encoder = DefaultHttp2ConnectionEncoder.newBuilder().connection(connection)
-                        .frameWriter(writer).lifecycleManager(lifecycleManager).build();
+        encoder = new DefaultHttp2ConnectionEncoder(connection, writer);
+        encoder.lifecycleManager(lifecycleManager);
     }
 
     @Test

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
Patch:
@@ -568,7 +568,8 @@ private void readContinuationFrame(ByteBuf payload, Http2FrameListener listener)
                 listener);
     }
 
-    private void readUnknownFrame(ChannelHandlerContext ctx, ByteBuf payload, Http2FrameListener listener) {
+    private void readUnknownFrame(ChannelHandlerContext ctx, ByteBuf payload, Http2FrameListener listener)
+            throws Http2Exception {
         payload = payload.readSlice(payload.readableBytes());
         listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);
     }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
Patch:
@@ -211,5 +211,6 @@ void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeI
      * @param flags the flags in the frame header.
      * @param payload the payload of the frame.
      */
-    void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags, ByteBuf payload);
+    void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags, ByteBuf payload)
+            throws Http2Exception;
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java
Patch:
@@ -97,7 +97,7 @@ public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int wind
 
     @Override
     public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,
-            ByteBuf payload) {
+            ByteBuf payload) throws Http2Exception {
         listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);
     }
 }

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java
Patch:
@@ -126,7 +126,7 @@ public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int wind
 
             @Override
             public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId,
-                    Http2Flags flags, ByteBuf payload) {
+                    Http2Flags flags, ByteBuf payload) throws Http2Exception {
                 logger.logUnknownFrame(INBOUND, frameType, streamId, flags, payload);
                 listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);
             }

File: codec-http2/src/test/java/io/netty/handler/codec/http2/Http2TestUtil.java
Patch:
@@ -247,7 +247,7 @@ public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int wind
 
                 @Override
                 public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,
-                        ByteBuf payload) {
+                        ByteBuf payload) throws Http2Exception {
                     listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);
                     latch.countDown();
                 }
@@ -373,7 +373,7 @@ public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int wind
 
         @Override
         public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,
-                ByteBuf payload) {
+                ByteBuf payload) throws Http2Exception {
             listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);
             messageLatch.countDown();
         }

File: example/src/main/java/io/netty/example/http2/server/HelloWorldHttp2Handler.java
Patch:
@@ -20,7 +20,6 @@
 import static io.netty.example.http2.Http2ExampleUtil.UPGRADE_RESPONSE_HEADER;
 import static io.netty.handler.codec.http.HttpResponseStatus.OK;
 import static io.netty.handler.logging.LogLevel.INFO;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.AsciiString;
@@ -79,7 +78,8 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+        super.exceptionCaught(ctx, cause);
         cause.printStackTrace();
         ctx.close();
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -33,7 +33,7 @@
  * <pre>
  * {@link HttpRequest} req = ...;
  * String value = req.getHeader("Cookie");
- * Set&lt;{@link Cookie}&gt; cookies = new {@link CookieDecoder}().decode(value);
+ * Set&lt;{@link Cookie}&gt; cookies = {@link CookieDecoder}.decode(value);
  * </pre>
  *
  * @see ClientCookieEncoder

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
Patch:
@@ -45,6 +45,7 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             @SuppressWarnings({ "unchecked", "CastConflictsWithInstanceof" })
             final M m = (M) msg;
             out.add(encodeMessage(ctx, m));
+            return;
         }
 
         if (msg instanceof MemcacheContent || msg instanceof ByteBuf || msg instanceof FileRegion) {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
Patch:
@@ -22,7 +22,7 @@
 import io.netty.util.CharsetUtil;
 
 /**
- * A {@link MessageToByteEncoder} that encodes binary memache messages into bytes.
+ * A {@link MessageToByteEncoder} that encodes binary memcache messages into bytes.
  */
 public abstract class AbstractBinaryMemcacheEncoder<M extends BinaryMemcacheMessage>
     extends AbstractMemcacheObjectEncoder<M> {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
Patch:
@@ -137,7 +137,7 @@ public interface BinaryMemcacheMessage extends MemcacheMessage {
     /**
      * Sets the opaque value.
      *
-     * @param opaque the opqaue value to use.
+     * @param opaque the opaque value to use.
      */
     BinaryMemcacheMessage setOpaque(int opaque);
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * The full server codec that combines the correct encoder and decoder.
  * <p/>
- * Use this codec if you need to implement a server that speaks the memache binary protocol.
+ * Use this codec if you need to implement a server that speaks the memcache binary protocol.
  * Internally, it combines the {@link BinaryMemcacheRequestDecoder} and the
  * {@link BinaryMemcacheResponseEncoder} to request decoding and response encoding.
  */

File: transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
Patch:
@@ -40,7 +40,7 @@ public boolean isSharable() {
          * {@link WeakHashMap} instances per {@link Thread} is good enough for us and the number of
          * {@link Thread}s are quite limited anyway.
          *
-         * See <a href="See https://github.com/netty/netty/issues/2289">#2289</a>.
+         * See <a href="https://github.com/netty/netty/issues/2289">#2289</a>.
          */
         Class<?> clazz = getClass();
         Map<Class<?>, Boolean> cache = InternalThreadLocalMap.get().handlerSharableCache();

File: handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelector;
 import io.netty.util.internal.PlatformDependent;
 
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 
 import javax.net.ssl.SSLEngine;
@@ -64,7 +64,8 @@ private static void updateAvailability() {
 
         if (server) {
             final ProtocolSelector protocolSelector = checkNotNull(applicationNegotiator.protocolSelectorFactory()
-                    .newSelector(this, new HashSet<String>(applicationNegotiator.protocols())), "protocolSelector");
+                    .newSelector(this, new LinkedHashSet<String>(applicationNegotiator.protocols())),
+                    "protocolSelector");
             ALPN.put(engine, new ServerProvider() {
                 @Override
                 public String select(List<String> protocols) {

File: handler/src/main/java/io/netty/handler/ssl/JdkBaseApplicationProtocolNegotiator.java
Patch:
@@ -142,9 +142,8 @@ public void unsupported() {
 
         @Override
         public String select(List<String> protocols) throws Exception {
-            for (int i = 0; i < protocols.size(); ++i) {
-                String p = protocols.get(i);
-                if (supportedProtocols.contains(p)) {
+            for (String p : supportedProtocols) {
+                if (protocols.contains(p)) {
                     jettyWrapper.getSession().setApplicationProtocol(p);
                     return p;
                 }

File: handler/src/main/java/io/netty/handler/ssl/JdkNpnSslEngine.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelector;
 import io.netty.util.internal.PlatformDependent;
 
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 
 import javax.net.ssl.SSLEngine;
@@ -88,7 +88,8 @@ public void protocolSelected(String protocol) {
             });
         } else {
             final ProtocolSelector protocolSelector = checkNotNull(applicationNegotiator.protocolSelectorFactory()
-                    .newSelector(this, new HashSet<String>(applicationNegotiator.protocols())), "protocolSelector");
+                    .newSelector(this, new LinkedHashSet<String>(applicationNegotiator.protocols())),
+                    "protocolSelector");
             NextProtoNego.put(engine, new ClientProvider() {
                 @Override
                 public boolean supports() {

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
Patch:
@@ -121,7 +121,7 @@ public void remoteSettings(Http2Settings settings) throws Http2Exception {
 
         Long maxConcurrentStreams = settings.maxConcurrentStreams();
         if (maxConcurrentStreams != null) {
-            connection.local().maxStreams((int) Math.min(maxConcurrentStreams, Integer.MAX_VALUE));
+            connection.local().maxActiveStreams((int) Math.min(maxConcurrentStreams, Integer.MAX_VALUE));
         }
 
         Long headerTableSize = settings.headerTableSize();
@@ -194,7 +194,7 @@ public ChannelFuture writeHeaders(final ChannelHandlerContext ctx, final int str
             }
             Http2Stream stream = connection.stream(streamId);
             if (stream == null) {
-                stream = connection.createLocalStream(streamId);
+                stream = connection.local().createStream(streamId);
             }
 
             switch (stream.state()) {
@@ -235,7 +235,7 @@ public ChannelFuture writePriority(ChannelHandlerContext ctx, int streamId, int
             // Update the priority on this stream.
             Http2Stream stream = connection.stream(streamId);
             if (stream == null) {
-                stream = connection.createLocalStream(streamId);
+                stream = connection.local().createStream(streamId);
             }
 
             stream.setPriority(streamDependency, weight, exclusive);

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
Patch:
@@ -73,7 +73,7 @@ public void streamActive(Http2Stream stream) {
             }
 
             @Override
-            public void streamInactive(Http2Stream stream) {
+            public void streamClosed(Http2Stream stream) {
                 // Any pending frames can never be written, cancel and
                 // write errors for any pending frames.
                 state(stream).cancel();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionAdapter.java
Patch:
@@ -32,7 +32,7 @@ public void streamHalfClosed(Http2Stream stream) {
     }
 
     @Override
-    public void streamInactive(Http2Stream stream) {
+    public void streamClosed(Http2Stream stream) {
     }
 
     @Override

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java
Patch:
@@ -96,7 +96,7 @@ public void streamHalfClosed(Http2Stream stream) {
     }
 
     @Override
-    public void streamInactive(Http2Stream stream) {
+    public void streamClosed(Http2Stream stream) {
     }
 
     @Override

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java
Patch:
@@ -163,7 +163,7 @@ public void newStreamNotForClientShouldThrow() throws Http2Exception {
 
     @Test(expected = Http2Exception.class)
     public void maxAllowedStreamsExceededShouldThrow() throws Http2Exception {
-        server.local().maxStreams(0);
+        server.local().maxActiveStreams(0);
         server.local().createStream(2).open(true);
     }
 
@@ -214,12 +214,12 @@ public void closeOnlyOpenSideShouldClose() throws Http2Exception {
 
     @Test(expected = Http2Exception.class)
     public void localStreamInvalidStreamIdShouldThrow() throws Http2Exception {
-        client.createLocalStream(Integer.MAX_VALUE + 2).open(false);
+        client.local().createStream(Integer.MAX_VALUE + 2).open(false);
     }
 
     @Test(expected = Http2Exception.class)
     public void remoteStreamInvalidStreamIdShouldThrow() throws Http2Exception {
-        client.createRemoteStream(Integer.MAX_VALUE + 1).open(false);
+        client.remote().createStream(Integer.MAX_VALUE + 1).open(false);
     }
 
     @Test

File: codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
Patch:
@@ -135,7 +135,7 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
     protected abstract boolean isAggregated(I msg) throws Exception;
 
     /**
-     * Returns the maximum allowed length of the aggregated message.
+     * Returns the maximum allowed length of the aggregated message in bytes.
      */
     public final int maxContentLength() {
         return maxContentLength;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -65,7 +65,7 @@ public class HttpObjectAggregator
      * Creates a new instance.
      *
      * @param maxContentLength
-     *        the maximum length of the aggregated content.
+     *        the maximum length of the aggregated content in bytes.
      *        If the length of the aggregated content exceeds this value,
      *        {@link #handleOversizedMessage(ChannelHandlerContext, HttpMessage)}
      *        will be called.

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -332,7 +332,7 @@ protected AbstractNioUnsafe newUnsafe() {
     private final class NioSocketChannelUnsafe extends NioByteUnsafe {
         @Override
         protected Executor closeExecutor() {
-            if (config().getSoLinger() > 0) {
+            if (javaChannel().isOpen() && config().getSoLinger() > 0) {
                 return GlobalEventExecutor.INSTANCE;
             }
             return null;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -97,7 +97,7 @@ public ChannelMetadata metadata() {
     @Override
     @SuppressWarnings("deprecation")
     public boolean isActive() {
-        return fd() != FileDescriptor.INVALID &&
+        return fd().isOpen() &&
                 (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()
                         || active);
     }

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -284,7 +284,7 @@ private ChannelFuture doBind(final SocketAddress localAddress) {
         }
 
         if (regFuture.isDone()) {
-            // At this point we know that the registration was complete and succesful.
+            // At this point we know that the registration was complete and successful.
             ChannelPromise promise = channel.newPromise();
             doBind0(regFuture, channel, localAddress, promise);
             return promise;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -473,7 +473,7 @@ public static InetSocketAddress localAddress(int fd) {
 
     static InetSocketAddress address(byte[] addr, int offset, int len) {
         // The last 4 bytes are always the port
-        final int port = decodeInt(addr, len - 4);
+        final int port = decodeInt(addr, offset + len - 4);
         final InetAddress address;
 
         try {
@@ -494,7 +494,7 @@ static InetSocketAddress address(byte[] addr, int offset, int len) {
                 case 24:
                     byte[] ipv6 = new byte[16];
                     System.arraycopy(addr, offset, ipv6, 0, 16);
-                    int scopeId = decodeInt(addr, len  - 8);
+                    int scopeId = decodeInt(addr, offset + len  - 8);
                     address = Inet6Address.getByAddress(null, ipv6, scopeId);
                     break;
                 default:

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandResponseTest.java
Patch:
@@ -57,6 +57,7 @@ public void testEmptyDomain() {
                 0x00
         };
         assertByteBufEquals(expected, buffer);
+        buffer.release();
     }
 
     /**
@@ -83,6 +84,7 @@ public void testIPv4Host() {
                 0x50
                 };
         assertByteBufEquals(expected, buffer);
+        buffer.release();
     }
 
     /**
@@ -106,6 +108,7 @@ public void testEmptyBoundAddress() {
                 0x50
         };
         assertByteBufEquals(expected, buffer);
+        buffer.release();
     }
 
     /**

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -75,7 +75,7 @@ public ServerBootstrap group(EventLoopGroup group) {
 
     /**
      * Set the {@link EventLoopGroup} for the parent (acceptor) and the child (client). These
-     * {@link EventLoopGroup}'s are used to handle all the events and IO for {@link SocketChannel} and
+     * {@link EventLoopGroup}'s are used to handle all the events and IO for {@link ServerChannel} and
      * {@link Channel}'s.
      */
     public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java
Patch:
@@ -70,7 +70,7 @@
  * Testing the {@link HttpToHttp2ConnectionHandler} for {@link FullHttpRequest} objects into HTTP/2 frames
  */
 public class HttpToHttp2ConnectionHandlerTest {
-    private static final int WAIT_TIME_SECONDS = 500;
+    private static final int WAIT_TIME_SECONDS = 5;
 
     @Mock
     private Http2FrameListener clientListener;

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5InitialResponseTest.java
Patch:
@@ -18,11 +18,11 @@
 import org.junit.Test;
 import static org.junit.Assert.assertTrue;
 
-public class Socks5InitResponseTest {
+public class DefaultSocks5InitialResponseTest {
     @Test
     public void testConstructorParamsAreNotNull() {
         try {
-            new Socks5InitResponse(null);
+            new DefaultSocks5InitialResponse(null);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PasswordAuthResponseTest.java
Patch:
@@ -18,14 +18,13 @@
 import org.junit.Test;
 import static org.junit.Assert.assertTrue;
 
-public class Socks5AuthResponseTest {
+public class DefaultSocks5PasswordAuthResponseTest {
     @Test
     public void testConstructorParamsAreNotNull() {
         try {
-            new Socks5AuthResponse(null);
+            new DefaultSocks5PasswordAuthResponse(null);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }
     }
-
 }

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
Patch:
@@ -329,8 +329,7 @@ public int bytesBefore(byte value) {
 
     @Override
     public int bytesBefore(int length, byte value) {
-        final int readerIndex = buffer.readerIndex();
-        return bytesBefore(readerIndex, buffer.writerIndex() - readerIndex, value);
+        return bytesBefore(buffer.readerIndex(), length, value);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -57,7 +57,7 @@ protected AbstractNioUnsafe newUnsafe() {
         return new NioByteUnsafe();
     }
 
-    private final class NioByteUnsafe extends AbstractNioUnsafe {
+    protected class NioByteUnsafe extends AbstractNioUnsafe {
 
         private void closeOnRead(ChannelPipeline pipeline) {
             SelectionKey key = selectionKey();
@@ -90,7 +90,7 @@ private void handleReadException(ChannelPipeline pipeline,
         }
 
         @Override
-        public void read() {
+        public final void read() {
             final ChannelConfig config = config();
             if (!config.isAutoRead() && !isReadPending()) {
                 // ChannelConfig.setAutoRead(false) was called in the meantime

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java
Patch:
@@ -28,7 +28,7 @@ public interface Http2DataWriter {
      *
      * @param ctx the context to use for writing.
      * @param streamId the stream for which to send the frame.
-     * @param data the payload of the frame.
+     * @param data the payload of the frame. This will be released by this method.
      * @param padding the amount of padding to be added to the end of the frame
      * @param endStream indicates if this is the last frame to be sent for the stream.
      * @param promise the promise for the write.

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java
Patch:
@@ -129,7 +129,7 @@ ChannelFuture writeSettings(ChannelHandlerContext ctx, Http2Settings settings,
      * @param ctx the context to use for writing.
      * @param ack indicates whether this is an ack of a PING frame previously received from the
      *            remote endpoint.
-     * @param data the payload of the frame.
+     * @param data the payload of the frame. This will be released by this method.
      * @param promise the promise for the write.
      * @return the future for the write.
      */
@@ -156,7 +156,7 @@ ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId, int prom
      * @param ctx the context to use for writing.
      * @param lastStreamId the last known stream of this endpoint.
      * @param errorCode the error code, if the connection was abnormally terminated.
-     * @param debugData application-defined debug data.
+     * @param debugData application-defined debug data. This will be released by this method.
      * @param promise the promise for the write.
      * @return the future for the write.
      */
@@ -183,7 +183,7 @@ ChannelFuture writeWindowUpdate(ChannelHandlerContext ctx, int streamId,
      * @param frameType the frame type identifier.
      * @param streamId the stream for which to send the frame.
      * @param flags the flags to write for this frame.
-     * @param payload the payload to write for this frame.
+     * @param payload the payload to write for this frame. This will be released by this method.
      * @param promise the promise for the write.
      * @return the future for the write.
      */

File: codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
Patch:
@@ -14,9 +14,10 @@
  */
 package io.netty.handler.codec.http2;
 
-import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
+import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.TooLongFrameException;
@@ -28,7 +29,6 @@
 import io.netty.handler.codec.http.HttpStatusClass;
 import io.netty.util.collection.IntObjectHashMap;
 import io.netty.util.collection.IntObjectMap;
-import static io.netty.util.internal.ObjectUtil.*;
 
 /**
  * This adapter provides just header/data events from the HTTP message flow defined

File: codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java
Patch:
@@ -70,7 +70,7 @@
  * Testing the {@link HttpToHttp2ConnectionHandler} for {@link FullHttpRequest} objects into HTTP/2 frames
  */
 public class HttpToHttp2ConnectionHandlerTest {
-    private static final int WAIT_TIME_SECONDS = 5;
+    private static final int WAIT_TIME_SECONDS = 500;
 
     @Mock
     private Http2FrameListener clientListener;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
Patch:
@@ -27,7 +27,7 @@ public final class EpollChannelOption {
     public static final ChannelOption<Integer> TCP_KEEPCNT = ChannelOption.valueOf(T, "TCP_KEEPCNT");
     public static final ChannelOption<DomainSocketReadMode> DOMAIN_SOCKET_READ_MODE =
             ChannelOption.valueOf(T, "DOMAIN_SOCKET_READ_MODE");
-
+    public static final ChannelOption<EpollMode> EPOLL_MODE =
+            ChannelOption.valueOf(T, "EPOLL_MODE");
     private EpollChannelOption() { }
-
 }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -51,8 +51,9 @@ final class Native {
     // EventLoop operations and constants
     public static final int EPOLLIN = 0x01;
     public static final int EPOLLOUT = 0x02;
-    public static final int EPOLLACCEPT = 0x04;
-    public static final int EPOLLRDHUP = 0x08;
+    public static final int EPOLLRDHUP = 0x04;
+    public static final int EPOLLET = 0x08;
+
     public static final int IOV_MAX = iovMax();
     public static final int UIO_MAX_IOV = uioMaxIov();
     public static final boolean IS_SUPPORTING_SENDMMSG = isSupportingSendmmsg();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java
Patch:
@@ -225,7 +225,7 @@ public void dataReadAfterGoAwayForStreamInInvalidStateShouldIgnore() throws Exce
         final ByteBuf data = dummyData();
         try {
             decode().onDataRead(ctx, STREAM_ID, data, 10, true);
-            verify(localFlow, never()).receiveFlowControlledFrame(eq(ctx), eq(stream), eq(data), eq(10), eq(true));
+            verify(localFlow).receiveFlowControlledFrame(eq(ctx), eq(stream), eq(data), eq(10), eq(true));
             verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());
         } finally {
             data.release();

File: codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowControllerTest.java
Patch:
@@ -273,7 +273,7 @@ private void consumeBytes(int streamId, int numBytes) throws Http2Exception {
         controller.consumeBytes(ctx, stream(streamId), numBytes);
     }
 
-    private void verifyWindowUpdateSent(int streamId, int windowSizeIncrement) throws Http2Exception {
+    private void verifyWindowUpdateSent(int streamId, int windowSizeIncrement) {
         verify(frameWriter).writeWindowUpdate(eq(ctx), eq(streamId), eq(windowSizeIncrement), eq(promise));
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -84,7 +84,7 @@ protected HttpMessage createMessage(String[] initialLine) throws Exception {
 
     @Override
     protected HttpMessage createInvalidMessage() {
-        return new DefaultHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, "/bad-request", validateHeaders);
+        return new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, "/bad-request", validateHeaders);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -115,7 +115,7 @@ protected HttpMessage createMessage(String[] initialLine) {
 
     @Override
     protected HttpMessage createInvalidMessage() {
-        return new DefaultHttpResponse(HttpVersion.HTTP_1_0, UNKNOWN_STATUS, validateHeaders);
+        return new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, UNKNOWN_STATUS, validateHeaders);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestDecoder.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpRequest;
@@ -78,7 +79,7 @@ protected HttpMessage createMessage(String[] initialLine) throws Exception {
 
     @Override
     protected HttpMessage createInvalidMessage() {
-        return new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, "/bad-request", validateHeaders);
+        return new DefaultFullHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, "/bad-request", validateHeaders);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseDecoder.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpResponse;
@@ -83,7 +84,7 @@ protected HttpMessage createMessage(String[] initialLine) throws Exception {
 
     @Override
     protected HttpMessage createInvalidMessage() {
-        return new DefaultHttpResponse(RtspVersions.RTSP_1_0, UNKNOWN_STATUS, validateHeaders);
+        return new DefaultFullHttpResponse(RtspVersions.RTSP_1_0, UNKNOWN_STATUS, validateHeaders);
     }
 
     @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/ServerCookieEncoderTest.java
Patch:
@@ -46,8 +46,8 @@ public void testEncodingSingleCookieV0() throws ParseException {
         assertTrue(matcher.find());
         Date expiresDate = HttpHeaderDateFormat.get().parse(matcher.group(1));
         long diff = (expiresDate.getTime() - System.currentTimeMillis()) / 1000;
-        // 1 sec should be fine
-        assertTrue(Math.abs(diff - maxAge) <= 1);
+        // 2 secs should be fine
+        assertTrue(Math.abs(diff - maxAge) <= 2);
     }
 
     @Test

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java
Patch:
@@ -90,13 +90,13 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             return;
         }
 
-        if (!in.isReadable()) {
+        final int inputLength = in.readableBytes();
+        if (inputLength == 0) {
             return;
         }
 
         try {
             // Configure input.
-            int inputLength = in.readableBytes();
             z.avail_in = inputLength;
             if (in.hasArray()) {
                 z.next_in = in.array();

File: codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
Patch:
@@ -309,7 +309,7 @@ void incrementFlowControlWindows(int delta) throws Http2Exception {
          * @throws Http2Exception If too much data is used relative to how much is available.
          */
         void receiveFlowControlledFrame(int dataLength) throws Http2Exception {
-            assert dataLength > 0;
+            assert dataLength >= 0;
 
             // Apply the delta. Even if we throw an exception we want to have taken this delta into account.
             window -= dataLength;

File: codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java
Patch:
@@ -53,7 +53,7 @@ void receiveFlowControlledFrame(ChannelHandlerContext ctx, Http2Stream stream, B
      * @param stream the stream for which window space should be freed. The connection stream object
      *            must not be used.
      * @param numBytes the number of bytes to be returned to the flow control window.
-     * @throws Http2Exception if the number of bytes returned exceeds the {@link #unconsumedBytes()}
+     * @throws Http2Exception if the number of bytes returned exceeds the {@link #unconsumedBytes}
      *             for the stream.
      */
     void consumeBytes(ChannelHandlerContext ctx, Http2Stream stream, int numBytes) throws Http2Exception;

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -25,6 +25,8 @@
 import java.util.TreeSet;
 
 /**
+ * @deprecated Use {@link ClientCookieDecoder} or {@link ServerCookieDecoder} instead.
+ *
  * Decodes an HTTP header value into {@link Cookie}s.  This decoder can decode
  * the HTTP cookie version 0, 1, and 2.
  *
@@ -37,6 +39,7 @@
  * @see ClientCookieEncoder
  * @see ServerCookieEncoder
  */
+@Deprecated
 public final class CookieDecoder {
 
     private static final char COMMA = ',';

File: codec-http/src/test/java/io/netty/handler/codec/http/ClientCookieEncoderTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import org.junit.Test;
 
-public class Rfc6265ClientCookieEncoderTest {
+public class ClientCookieEncoderTest {
 
     @Test
     public void testEncodingMultipleClientCookies() {
@@ -46,7 +46,7 @@ public void testEncodingMultipleClientCookies() {
         cookie2.setSecure(false);
         Cookie cookie3 = new DefaultCookie("myCookie3", "myValue3");
         cookie3.setVersion(1);
-        String encodedCookie = Rfc6265ClientCookieEncoder.encode(cookie, cookie2, cookie3);
+        String encodedCookie = ClientCookieEncoder.encode(cookie, cookie2, cookie3);
         assertEquals(c1 + c2 + c3, encodedCookie);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
Patch:
@@ -67,7 +67,7 @@ public interface Cookie extends Comparable<Cookie> {
     /**
      * Sets the raw value of this {@link Cookie}.
      *
-     * @param value The raw value to set
+     * @param rawValue The raw value to set
      */
     void setRawValue(String rawValue);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -29,8 +29,8 @@
  * <ul>
  * <li>Sun, 06 Nov 1994 08:49:37 GMT: standard specification, the only one with
  * valid generation</li>
- * <li>Sun, 06 Nov 1994 08:49:37 GMT: obsolete specification</li>
- * <li>Sun Nov 6 08:49:37 1994: obsolete specification</li>
+ * <li>Sunday, 06-Nov-94 08:49:37 GMT: obsolete specification</li>
+ * <li>Sun Nov  6 08:49:37 1994: obsolete specification</li>
  * </ul>
  */
 final class HttpHeaderDateFormat extends SimpleDateFormat {

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
Patch:
@@ -328,7 +328,7 @@ public void testFilenameContainingSemicolon() throws Exception {
         final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";
         final DefaultFullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST,
                 "http://localhost");
-        req.headers().add(HttpHeaders.Names.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);
+        req.headers().add(HttpHeaderNames.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);
         // Force to use memory-based data.
         final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory(false);
         final String data = "asdf";

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -271,9 +271,6 @@ public SslHandler(SSLEngine engine, Executor delegatedTaskExecutor) {
      */
     @Deprecated
     public SslHandler(SSLEngine engine, boolean startTls, Executor delegatedTaskExecutor) {
-        // As SslEngine.unwrap(....) only works with one ByteBuffer we should not try to use a CompositeByteBuf
-        // at the first place to make it as fast as possible.
-        super(false);
         if (engine == null) {
             throw new NullPointerException("engine");
         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -271,6 +271,9 @@ public SslHandler(SSLEngine engine, Executor delegatedTaskExecutor) {
      */
     @Deprecated
     public SslHandler(SSLEngine engine, boolean startTls, Executor delegatedTaskExecutor) {
+        // As SslEngine.unwrap(....) only works with one ByteBuffer we should not try to use a CompositeByteBuf
+        // at the first place to make it as fast as possible.
+        super(false);
         if (engine == null) {
             throw new NullPointerException("engine");
         }
@@ -477,7 +480,6 @@ private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLExcepti
                 }
 
                 SSLEngineResult result = wrap(alloc, engine, buf, out);
-
                 if (!buf.isReadable()) {
                     promise = pendingUnencryptedWrites.remove();
                 } else {

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -62,7 +62,8 @@ public final class OpenSsl {
                 cause = t;
                 logger.debug(
                         "Failed to load netty-tcnative; " +
-                        OpenSslEngine.class.getSimpleName() + " will be unavailable.", t);
+                        OpenSslEngine.class.getSimpleName() + " will be unavailable. " +
+                        "See http://netty.io/wiki/forked-tomcat-native.html for more information.", t);
             }
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -828,6 +828,7 @@ private ByteBuf fillByteBuf() {
         int length = currentBuffer.readableBytes();
         if (length > HttpPostBodyUtil.chunkSize) {
             ByteBuf slice = currentBuffer.slice(currentBuffer.readerIndex(), HttpPostBodyUtil.chunkSize);
+            currentBuffer.retain();
             currentBuffer.skipBytes(HttpPostBodyUtil.chunkSize);
             return slice;
         } else {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -539,8 +539,6 @@ void epollInReady() {
                 if (exception != null) {
                     pipeline.fireExceptionCaught(exception);
                 }
-
-                pipeline.fireChannelReadComplete();
             } finally {
                 // Check if there is a readPending which was not processed yet.
                 // This could be for two reasons:

File: handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
Patch:
@@ -30,7 +30,6 @@ public final class OpenSsl {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSsl.class);
     private static final Throwable UNAVAILABILITY_CAUSE;
-    private static final String IGNORABLE_ERROR_PREFIX = "error:00000000:";
 
     static {
         Throwable cause = null;
@@ -79,8 +78,8 @@ public static Throwable unavailabilityCause() {
         return UNAVAILABILITY_CAUSE;
     }
 
-    static boolean isError(String error) {
-        return error != null && !error.startsWith(IGNORABLE_ERROR_PREFIX);
+    static boolean isError(long errorCode) {
+        return errorCode != SSL.SSL_ERROR_NONE;
     }
 
     private OpenSsl() { }

File: handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java
Patch:
@@ -115,11 +115,11 @@ public OpenSslClientContext(File certChainFile, TrustManagerFactory trustManager
                 if (certChainFile != null) {
                     /* Load the certificate chain. We must skip the first cert when server mode */
                     if (!SSLContext.setCertificateChainFile(ctx, certChainFile.getPath(), true)) {
-                        String error = SSL.getLastError();
+                        long error = SSL.getLastErrorNumber();
                         if (OpenSsl.isError(error)) {
                             throw new SSLException(
                                     "failed to set certificate chain: "
-                                            + certChainFile + " (" + SSL.getLastError() + ')');
+                                            + certChainFile + " (" + SSL.getErrorString(error) + ')');
                         }
                     }
                 }

File: handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
Patch:
@@ -16,7 +16,6 @@
 
 package io.netty.handler.ssl;
 
-
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;

File: handler/src/main/java/io/netty/handler/ssl/util/InsecureTrustManagerFactory.java
Patch:
@@ -28,10 +28,10 @@
 import java.security.cert.X509Certificate;
 
 /**
- * An insecure {@link javax.net.ssl.TrustManagerFactory} that trusts all X.509 certificates without any verification.
+ * An insecure {@link TrustManagerFactory} that trusts all X.509 certificates without any verification.
  * <p>
  * <strong>NOTE:</strong>
- * Never use this {@link javax.net.ssl.TrustManagerFactory} in production.
+ * Never use this {@link TrustManagerFactory} in production.
  * It is purely for testing purposes, and thus it is very insecure.
  * </p>
  */

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
Patch:
@@ -30,6 +30,7 @@
 import io.netty.handler.ssl.JdkSslClientContext;
 import io.netty.handler.ssl.JdkSslServerContext;
 import io.netty.handler.ssl.OpenSsl;
+import io.netty.handler.ssl.OpenSslClientContext;
 import io.netty.handler.ssl.OpenSslServerContext;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
@@ -84,9 +85,7 @@ public static Collection<Object[]> data() throws Exception {
         boolean hasOpenSsl = OpenSsl.isAvailable();
         if (hasOpenSsl) {
             serverContexts.add(new OpenSslServerContext(CERT_FILE, KEY_FILE));
-
-            // TODO: Client mode is not supported yet.
-            // clientContexts.add(new OpenSslContext(CERT_FILE));
+            clientContexts.add(new OpenSslClientContext(CERT_FILE));
         } else {
             logger.warn("OpenSSL is unavailable and thus will not be tested.", OpenSsl.unavailabilityCause());
         }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -32,6 +32,7 @@
 import io.netty.handler.ssl.JdkSslClientContext;
 import io.netty.handler.ssl.JdkSslServerContext;
 import io.netty.handler.ssl.OpenSsl;
+import io.netty.handler.ssl.OpenSslClientContext;
 import io.netty.handler.ssl.OpenSslServerContext;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslHandler;
@@ -91,9 +92,7 @@ public static Collection<Object[]> data() throws Exception {
         boolean hasOpenSsl = OpenSsl.isAvailable();
         if (hasOpenSsl) {
             serverContexts.add(new OpenSslServerContext(CERT_FILE, KEY_FILE));
-
-            // TODO: Client mode is not supported yet.
-            // clientContexts.add(new OpenSslContext(CERT_FILE));
+            clientContexts.add(new OpenSslClientContext(CERT_FILE));
         } else {
             logger.warn("OpenSSL is unavailable and thus will not be tested.", OpenSsl.unavailabilityCause());
         }

File: testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -287,7 +287,6 @@ public void initChannel(SocketChannel sch) throws Exception {
             clientSendCounter.set(clientSendCounterVal += length);
             future.sync();
 
-
             if (needsRenegotiation && clientSendCounterVal >= data.length / 2) {
                 needsRenegotiation = false;
                 clientSslHandler.engine().setEnabledCipherSuites(new String[] { renegotiation.cipherSuite });
@@ -475,7 +474,6 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception
         }
     }
 
-
     private class EchoServerHandler extends EchoHandler {
         volatile Future<Channel> renegoFuture;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java
Patch:
@@ -457,7 +457,7 @@ public static HttpResponseStatus parseLine(CharSequence line) {
                 int code = Integer.parseInt(status.substring(0, space));
                 String reasonPhrase = status.substring(space + 1);
                 HttpResponseStatus responseStatus = valueOf(code);
-                if (responseStatus.reasonPhrase().equals(reasonPhrase)) {
+                if (responseStatus.reasonPhrase().toString().equals(reasonPhrase)) {
                     return responseStatus;
                 } else {
                     return new HttpResponseStatus(code, reasonPhrase);

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -222,7 +222,7 @@ public interface ChannelHandlerContext extends AttributeMap {
     ChannelHandlerContext fireChannelRead(Object msg);
 
     /**
-     * Triggers an {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}
+     * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}
      * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      */
     ChannelHandlerContext fireChannelReadComplete();

File: common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Set;
 
 /**
- * A special variant of {@link ThreadLocal} that yields higher access performan when accessed from a
+ * A special variant of {@link ThreadLocal} that yields higher access performance when accessed from a
  * {@link FastThreadLocalThread}.
  * <p>
  * Internally, a {@link FastThreadLocal} uses a constant index in an array, instead of using hash code and hash table,

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -341,11 +341,11 @@ public boolean renameTo(File dest) throws IOException {
             FileOutputStream outputStream = new FileOutputStream(dest);
             FileChannel in = inputStream.getChannel();
             FileChannel out = outputStream.getChannel();
-            int chunkSize = 8196;
+            long chunkSize = 8196;
             long position = 0;
             while (position < size) {
                 if (chunkSize < size - position) {
-                    chunkSize = (int) (size - position);
+                    chunkSize = size - position;
                 }
                 position += in.transferTo(position, chunkSize , out);
             }

File: example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java
Patch:
@@ -54,6 +54,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
 
             ByteBuf content = Unpooled.wrappedBuffer(value.getBytes(CharsetUtil.UTF_8));
             ByteBuf extras = ctx.alloc().buffer(8);
+            extras.writeZero(8);
 
             BinaryMemcacheRequest req = new DefaultFullBinaryMemcacheRequest(key, extras, content);
             req.setOpcode(BinaryMemcacheOpcodes.SET);

File: common/src/main/java/io/netty/util/DomainNameMapping.java
Patch:
@@ -107,7 +107,6 @@ private static boolean matches(String hostNameTemplate, String hostName) {
     private static String normalizeHostname(String hostname) {
         if (needsNormalization(hostname)) {
             hostname = IDN.toASCII(hostname, IDN.ALLOW_UNASSIGNED);
-
         }
         return hostname.toLowerCase(Locale.US);
     }

File: common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java
Patch:
@@ -58,6 +58,7 @@ public PromiseAggregator(Promise<Void> aggregatePromise) {
     /**
      * Add the given {@link Promise}s to the aggregator.
      */
+    @SafeVarargs
     public final PromiseAggregator<V, F> add(Promise<V>... promises) {
         if (promises == null) {
             throw new NullPointerException("promises");

File: common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java
Patch:
@@ -31,6 +31,7 @@ public class PromiseNotifier<V, F extends Future<V>> implements GenericFutureLis
      *
      * @param promises  the {@link Promise}s to notify once this {@link GenericFutureListener} is notified.
      */
+    @SafeVarargs
     public PromiseNotifier(Promise<? super V>... promises) {
         if (promises == null) {
             throw new NullPointerException("promises");

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -58,6 +58,7 @@ public Bootstrap() { }
 
     private Bootstrap(Bootstrap bootstrap) {
         super(bootstrap);
+        resolver = bootstrap.resolver;
         remoteAddress = bootstrap.remoteAddress;
     }
 

File: common/src/main/java/io/netty/util/collection/IntObjectHashMap.java
Patch:
@@ -191,10 +191,10 @@ public boolean containsKey(int key) {
 
     @Override
     public boolean containsValue(V value) {
-        V v = toInternal(value);
-        for (V value1 : values) {
+        V v1 = toInternal(value);
+        for (V v2 : values) {
             // The map supports null values; this will be matched as NULL_VALUE.equals(NULL_VALUE).
-            if (value1 != null && value1.equals(v)) {
+            if (v2 != null && v2.equals(v1)) {
                 return true;
             }
         }

File: common/src/main/java/io/netty/util/collection/IntObjectMap.java
Patch:
@@ -14,6 +14,8 @@
  */
 package io.netty.util.collection;
 
+import java.util.Collection;
+
 /**
  * Interface for a primitive map that uses {@code int}s as keys.
  *
@@ -112,5 +114,5 @@ interface Entry<V> {
     /**
      * Gets the values contained in this map.
      */
-    V[] values(Class<V> clazz);
+    Collection<V> values();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -60,9 +60,9 @@ protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Except
                     if (uri.lastIndexOf(SLASH, index) <= startIndex) {
                         int len = uri.length();
                         StringBuilder sb = new StringBuilder(len + 1);
-                        sb.append(uri, 0, index);
-                        sb.append(SLASH);
-                        sb.append(uri, index, len);
+                        sb.append(uri, 0, index)
+                          .append(SLASH)
+                          .append(uri, index, len);
                         uri = sb.toString();
                     }
                 }

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribePayload.java
Patch:
@@ -40,10 +40,10 @@ public List<String> topics() {
     public String toString() {
         StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
         for (int i = 0; i < topics.size() - 1; i++) {
-            builder.append("topicName = " + topics.get(i)).append(", ");
+            builder.append("topicName = ").append(topics.get(i)).append(", ");
         }
-        builder.append("topicName = " + topics.get(topics.size() - 1));
-        builder.append(']');
+        builder.append("topicName = ").append(topics.get(topics.size() - 1))
+               .append(']');
         return builder.toString();
     }
 }

File: codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java
Patch:
@@ -111,12 +111,12 @@ public short convertToShort(CharSequence value) {
 
         @Override
         public int convertToInt(CharSequence value) {
-            return Integer.valueOf(value.toString());
+            return Integer.parseInt(value.toString());
         }
 
         @Override
         public long convertToLong(CharSequence value) {
-            return Long.valueOf(value.toString());
+            return Long.parseLong(value.toString());
         }
 
         @Override

File: codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttQoS.java
Patch:
@@ -18,7 +18,8 @@
 public enum MqttQoS {
     AT_MOST_ONCE(0),
     AT_LEAST_ONCE(1),
-    EXACTLY_ONCE(2);
+    EXACTLY_ONCE(2),
+    FAILURE(0x80);
 
     private final int value;
 

File: common/src/test/java/io/netty/util/NetUtilTest.java
Patch:
@@ -62,7 +62,7 @@ private static final class TestMap extends HashMap<String, String> {
             "a.0.1.1",       null,
             ".0.1.1",        null,
             "...",           null);
-    
+
     private static final Map<String, String> validIpV6Hosts = new TestMap(
             "::ffff:5.6.7.8",                            "00000000000000000000ffff05060708",
             "fdf8:f53b:82e4::53",                        "fdf8f53b82e400000000000000000053",

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -68,7 +68,7 @@ public String toString() {
         buf.append("(version: ");
         buf.append(protocolVersion().text());
         buf.append(", keepAlive: ");
-        buf.append(HttpHeaders.isKeepAlive(this));
+        buf.append(HttpHeaderUtil.isKeepAlive(this));
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         appendHeaders(buf);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.http;
 
 import io.netty.channel.embedded.EmbeddedChannel;
-import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.util.internal.StringUtil;
@@ -95,9 +94,9 @@ public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel)
 
     @Override
     protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
-        String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);
+        String contentEncoding = headers.headers().get(HttpHeaderNames.CONTENT_ENCODING);
         if (contentEncoding != null &&
-            !AsciiString.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {
+            !HttpHeaderValues.IDENTITY.equalsIgnoreCase(contentEncoding)) {
             return null;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -72,7 +72,7 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             encodeInitialLine(buf, m);
             HttpHeaders.encode(m.headers(), buf);
             buf.writeBytes(CRLF);
-            state = HttpHeaders.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;
+            state = HttpHeaderUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;
         }
 
         // Bypass the encoder in case of an empty buffer, so that the following idiom works:

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.http.cors;
 
 import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.util.internal.StringUtil;
 
@@ -510,8 +510,8 @@ public Builder noPreflightResponseHeaders() {
          */
         public CorsConfig build() {
             if (preflightHeaders.isEmpty() && !noPreflightHeaders) {
-                preflightHeaders.put(Names.DATE, new DateValueGenerator());
-                preflightHeaders.put(Names.CONTENT_LENGTH, new ConstantValueGenerator("0"));
+                preflightHeaders.put(HttpHeaderNames.DATE, new DateValueGenerator());
+                preflightHeaders.put(HttpHeaderNames.CONTENT_LENGTH, new ConstantValueGenerator("0"));
             }
             return new CorsConfig(this);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpClientCodec;
 import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequestEncoder;
 import io.netty.handler.codec.http.HttpResponseDecoder;
@@ -203,7 +204,7 @@ public final void finishHandshake(Channel channel, FullHttpResponse response) {
 
         // Verify the subprotocol that we received from the server.
         // This must be one of our expected subprotocols - or null/empty if we didn't want to speak a subprotocol
-        String receivedProtocol = response.headers().get(HttpHeaders.Names.SEC_WEBSOCKET_PROTOCOL);
+        String receivedProtocol = response.headers().get(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL);
         receivedProtocol = receivedProtocol != null ? receivedProtocol.trim() : null;
         String expectedProtocol = expectedSubprotocol != null ? expectedSubprotocol : "";
         boolean protocolValid = false;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http.DefaultHttpResponse;
-import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
@@ -112,7 +112,7 @@ public WebSocketServerHandshakerFactory(
      */
     public WebSocketServerHandshaker newHandshaker(HttpRequest req) {
 
-        CharSequence version = req.headers().get(Names.SEC_WEBSOCKET_VERSION);
+        CharSequence version = req.headers().get(HttpHeaderNames.SEC_WEBSOCKET_VERSION);
         if (version != null) {
             if (version.equals(WebSocketVersion.V13.toHttpHeaderValue())) {
                 // Version 13 of the wire protocol - RFC 6455 (version 17 of the draft hybi specification).
@@ -157,7 +157,7 @@ public static ChannelFuture sendUnsupportedVersionResponse(Channel channel, Chan
         HttpResponse res = new DefaultHttpResponse(
                 HttpVersion.HTTP_1_1,
                 HttpResponseStatus.UPGRADE_REQUIRED);
-        res.headers().set(Names.SEC_WEBSOCKET_VERSION, WebSocketVersion.V13.toHttpHeaderValue());
+        res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, WebSocketVersion.V13.toHttpHeaderValue());
         return channel.write(res, promise);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -22,11 +22,12 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.ssl.SslHandler;
 
-import static io.netty.handler.codec.http.HttpHeaders.*;
+import static io.netty.handler.codec.http.HttpHeaderUtil.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
@@ -101,7 +102,6 @@ private static String getWebSocketLocation(ChannelPipeline cp, HttpRequest req,
             // SSL in use so use Secure WebSockets
             protocol = "wss";
         }
-        return protocol + "://" + req.headers().get(Names.HOST) + path;
+        return protocol + "://" + req.headers().get(HttpHeaderNames.HOST) + path;
     }
-
 }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspObjectDecoder.java
Patch:
@@ -79,7 +79,7 @@ protected boolean isContentAlwaysEmpty(HttpMessage msg) {
         if (empty) {
             return true;
         }
-        if (!msg.headers().contains(RtspHeaders.Names.CONTENT_LENGTH)) {
+        if (!msg.headers().contains(RtspHeaderNames.CONTENT_LENGTH)) {
             return true;
         }
         return empty;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageCodec;
-import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.spdy.SpdyHttpHeaders.Names;
 import io.netty.util.ReferenceCountUtil;
@@ -45,7 +44,7 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
     protected void encode(ChannelHandlerContext ctx, HttpMessage msg, List<Object> out) throws Exception {
         Integer id = ids.poll();
         if (id != null && id.intValue() != NO_ID && !msg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
-            HttpHeaders.setIntHeader(msg, Names.STREAM_ID, id);
+            msg.headers().setInt(Names.STREAM_ID, id);
         }
 
         out.add(ReferenceCountUtil.retain(msg));
@@ -58,7 +57,7 @@ protected void decode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             if (!contains) {
                 ids.add(NO_ID);
             } else {
-                ids.add(HttpHeaders.getIntHeader((HttpMessage) msg, Names.STREAM_ID));
+                ids.add(((HttpMessage) msg).headers().getInt(Names.STREAM_ID));
             }
         } else if (msg instanceof SpdyRstStreamFrame) {
             ids.remove(((SpdyRstStreamFrame) msg).streamId());

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java
Patch:
@@ -28,9 +28,9 @@ public class HttpHeadersTest {
     @Test
     public void testRemoveTransferEncodingIgnoreCase() {
         HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
-        message.headers().set(HttpHeaders.Names.TRANSFER_ENCODING, "Chunked");
+        message.headers().set(HttpHeaderNames.TRANSFER_ENCODING, "Chunked");
         assertFalse(message.headers().isEmpty());
-        HttpHeaders.removeTransferEncodingChunked(message);
+        HttpHeaderUtil.setTransferEncodingChunked(message, false);
         assertTrue(message.headers().isEmpty());
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
-import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
@@ -184,7 +183,7 @@ public void testPrematureClosureWithChunkedEncoding1() throws Exception {
         HttpResponse res = ch.readInbound();
         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
         assertThat(res.status(), is(HttpResponseStatus.OK));
-        assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));
+        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is("chunked"));
         assertThat(ch.readInbound(), is(nullValue()));
 
         // Close the connection without sending anything.
@@ -205,7 +204,7 @@ public void testPrematureClosureWithChunkedEncoding2() throws Exception {
         HttpResponse res = ch.readInbound();
         assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
         assertThat(res.status(), is(HttpResponseStatus.OK));
-        assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));
+        assertThat(res.headers().get(HttpHeaderNames.TRANSFER_ENCODING), is("chunked"));
 
         // Read the partial content.
         HttpContent content = ch.readInbound();

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java
Patch:
@@ -36,13 +36,13 @@ public class HttpResponseEncoderTest {
     public void testLargeFileRegionChunked() throws Exception {
         EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseEncoder());
         HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
-        response.headers().set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+        response.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
         assertTrue(channel.writeOutbound(response));
 
         ByteBuf buffer = channel.readOutbound();
 
-        assertEquals("HTTP/1.1 200 OK\r\n" + HttpHeaders.Names.TRANSFER_ENCODING + ": " +
-                HttpHeaders.Values.CHUNKED + "\r\n\r\n", buffer.toString(CharsetUtil.US_ASCII));
+        assertEquals("HTTP/1.1 200 OK\r\n" + HttpHeaderNames.TRANSFER_ENCODING + ": " +
+                HttpHeaderValues.CHUNKED + "\r\n\r\n", buffer.toString(CharsetUtil.US_ASCII));
         buffer.release();
         assertTrue(channel.writeOutbound(FILE_REGION));
         buffer = channel.readOutbound();

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.cors;
 
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.handler.codec.http.HttpMethod;
 import org.junit.Test;
 
@@ -108,8 +108,8 @@ public void preflightResponseHeadersMultipleValues() {
     @Test
     public void defaultPreflightResponseHeaders() {
         final CorsConfig cors = withAnyOrigin().build();
-        assertThat(cors.preflightResponseHeaders().get(Names.DATE), is(notNullValue()));
-        assertThat(cors.preflightResponseHeaders().get(Names.CONTENT_LENGTH), is("0"));
+        assertThat(cors.preflightResponseHeaders().get(HttpHeaderNames.DATE), is(notNullValue()));
+        assertThat(cors.preflightResponseHeaders().get(HttpHeaderNames.CONTENT_LENGTH), is("0"));
     }
 
     @Test

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
Patch:
@@ -28,10 +28,9 @@
 import java.util.Arrays;
 import java.util.concurrent.Callable;
 
-import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.FORBIDDEN;
-import static io.netty.handler.codec.http.HttpResponseStatus.OK;
+import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.*;

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java
Patch:
@@ -18,18 +18,17 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import static io.netty.handler.codec.http.HttpHeaders.Names.*;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.multipart.HttpPostRequestEncoder.EncoderMode;
 import io.netty.util.CharsetUtil;
 import io.netty.util.internal.StringUtil;
-
 import org.junit.Test;
 
 import java.io.File;
 import java.util.List;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
 import static org.junit.Assert.*;
 
 /** {@link HttpPostRequestEncoder} test case. */

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpRequestDecoder;
@@ -35,7 +36,6 @@
 import java.util.ArrayDeque;
 import java.util.Queue;
 
-import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 import static org.junit.Assert.*;
@@ -95,7 +95,7 @@ public void testHttpUpgradeRequestMissingWSKeyHeader() {
                 .uri("/test")
                 .key(null)
                 .connection("Upgrade")
-                .upgrade(WEBSOCKET.toLowerCase().toString())
+                .upgrade(HttpHeaderValues.WEBSOCKET)
                 .version13()
                 .build();
 

File: example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
Patch:
@@ -22,7 +22,7 @@
 import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpHeaderUtil;
 import io.netty.handler.codec.http.HttpRequest;
 
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
@@ -46,10 +46,10 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) msg;
 
-            if (HttpHeaders.is100ContinueExpected(req)) {
+            if (HttpHeaderUtil.is100ContinueExpected(req)) {
                 ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
             }
-            boolean keepAlive = HttpHeaders.isKeepAlive(req);
+            boolean keepAlive = HttpHeaderUtil.isKeepAlive(req);
             FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));
             response.headers().set(CONTENT_TYPE, "text/plain");
             response.headers().setInt(CONTENT_LENGTH, response.content().readableBytes());

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpHeaderUtil;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -44,7 +44,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
                 System.err.println();
             }
 
-            if (HttpHeaders.isTransferEncodingChunked(response)) {
+            if (HttpHeaderUtil.isTransferEncodingChunked(response)) {
                 System.err.println("CHUNKED CONTENT {");
             } else {
                 System.err.println("CONTENT {");

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpHeaderUtil;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -47,7 +47,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
                 }
             }
 
-            if (response.status().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
+            if (response.status().code() == 200 && HttpHeaderUtil.isTransferEncodingChunked(response)) {
                 readingChunks = true;
                 System.err.println("CHUNKED CONTENT {");
             } else {

File: example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.example.http.snoop.HttpSnoopClientHandler;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpHeaderUtil;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -55,7 +55,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 System.out.println();
             }
 
-            if (HttpHeaders.isTransferEncodingChunked(response)) {
+            if (HttpHeaderUtil.isTransferEncodingChunked(response)) {
                 System.out.println("CHUNKED CONTENT {");
             } else {
                 System.out.println("CONTENT {");

File: example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.spdy.SpdyHttpHeaders;
 import io.netty.handler.codec.spdy.SpdyHttpHeaders.Names;
@@ -39,7 +38,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         if (acceptOutboundMessage(msg)) {
             HttpMessage httpMsg = (HttpMessage) msg;
             if (!httpMsg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
-                HttpHeaders.setIntHeader(httpMsg, Names.STREAM_ID, currentStreamId);
+                httpMsg.headers().setInt(Names.STREAM_ID, currentStreamId);
                 // Client stream IDs are always odd
                 currentStreamId += 2;
             }

File: handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java
Patch:
@@ -25,7 +25,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
@@ -127,11 +127,11 @@ protected Object newInitialMessage(ChannelHandlerContext ctx) throws Exception {
         SocketAddress proxyAddress = proxyAddress();
         if (proxyAddress instanceof InetSocketAddress) {
             InetSocketAddress hostAddr = (InetSocketAddress) proxyAddress;
-            req.headers().set(Names.HOST, hostAddr.getHostString() + ':' + hostAddr.getPort());
+            req.headers().set(HttpHeaderNames.HOST, hostAddr.getHostString() + ':' + hostAddr.getPort());
         }
 
         if (authorization != null) {
-            req.headers().set(Names.AUTHORIZATION, authorization);
+            req.headers().set(HttpHeaderNames.AUTHORIZATION, authorization);
         }
 
         return req;

File: testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerHandler.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.ContinuationWebSocketFrame;
@@ -39,7 +40,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import static io.netty.handler.codec.http.HttpHeaders.*;
+import static io.netty.handler.codec.http.HttpHeaderUtil.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
@@ -142,6 +143,6 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     }
 
     private static String getWebSocketLocation(FullHttpRequest req) {
-        return "ws://" + req.headers().get(Names.HOST);
+        return "ws://" + req.headers().get(HttpHeaderNames.HOST);
     }
 }

File: handler/src/main/java/io/netty/handler/ssl/CipherSuiteFilter.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.ssl;
 
+import javax.net.ssl.SSLEngine;
 import java.util.List;
 import java.util.Set;
 

File: handler/src/main/java/io/netty/handler/ssl/SupportedCipherSuiteFilter.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.ssl;
 
+import javax.net.ssl.SSLEngine;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -94,7 +94,7 @@ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) {
 
         // Handshake
         WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(
-                getWebSocketLocation(req), null, false);
+                getWebSocketLocation(req), null, true);
         handshaker = wsFactory.newHandshaker(req);
         if (handshaker == null) {
             WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -161,10 +161,9 @@ public void operationComplete(ChannelFuture future) throws Exception {
             });
 
             // If the client started to send data already, close because it's impossible to recover.
-            // If 'Expect: 100-continue' is missing, close becuase it's impossible to recover.
-            // If keep-alive is off, no need to leave the connection open.
+            // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open.
             if (oversized instanceof FullHttpMessage ||
-                    !HttpHeaders.is100ContinueExpected(oversized) || !HttpHeaders.isKeepAlive(oversized)) {
+                    (!HttpHeaders.is100ContinueExpected(oversized) && !HttpHeaders.isKeepAlive(oversized))) {
                 future.addListener(ChannelFutureListener.CLOSE);
             }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
Patch:
@@ -29,6 +29,7 @@
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
+import static io.netty.util.ReferenceCountUtil.release;
 
 /**
  * Handles <a href="http://www.w3.org/TR/cors/">Cross Origin Resource Sharing</a> (CORS) requests.
@@ -72,6 +73,7 @@ private void handlePreflight(final ChannelHandlerContext ctx, final HttpRequest
             setMaxAge(response);
             setPreflightHeaders(response);
         }
+        release(request);
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
@@ -199,6 +201,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cau
     private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {
         ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN))
                 .addListener(ChannelFutureListener.CLOSE);
+        release(request);
     }
 }
 

File: handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
Patch:
@@ -55,7 +55,7 @@ public abstract class JdkSslContext extends SslContext {
         List<String> protocols = new ArrayList<String>();
         addIfSupported(
                 supportedProtocols, protocols,
-                "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3");
+                "TLSv1.2", "TLSv1.1", "TLSv1");
 
         if (!protocols.isEmpty()) {
             PROTOCOLS = protocols.toArray(new String[protocols.size()]);

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
Patch:
@@ -170,6 +170,7 @@ public OpenSslServerContext(
 
                 SSLContext.setOptions(ctx, SSL.SSL_OP_ALL);
                 SSLContext.setOptions(ctx, SSL.SSL_OP_NO_SSLv2);
+                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_SSLv3);
                 SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
                 SSLContext.setOptions(ctx, SSL.SSL_OP_SINGLE_ECDH_USE);
                 SSLContext.setOptions(ctx, SSL.SSL_OP_SINGLE_DH_USE);

File: resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
Patch:
@@ -30,8 +30,8 @@
 import io.netty.util.internal.ThreadLocalRandom;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.junit.After;
 import org.junit.AfterClass;
-import org.junit.Before;
 import org.junit.Test;
 
 import java.net.Inet4Address;
@@ -253,8 +253,8 @@ public static void destroy() {
         group.shutdownGracefully();
     }
 
-    @Before
-    public void reset() {
+    @After
+    public void reset() throws Exception {
         resolver.clearCache();
     }
 

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4CmdResponseDecoder.java
Patch:
@@ -57,7 +57,6 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
                 msg = new Socks4CmdResponse(cmdStatus, host, port);
             }
         }
-        ctx.pipeline().remove(this);
         out.add(msg);
     }
 

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CmdResponseDecoder.java
Patch:
@@ -83,7 +83,6 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
                 }
             }
         }
-        ctx.pipeline().remove(this);
         out.add(msg);
     }
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -36,7 +36,7 @@
 import io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import io.netty.handler.ssl.SslContext;
-import io.netty.handler.ssl.util.SelfSignedCertificate;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -85,8 +85,7 @@ public static void main(String[] args) throws Exception {
         final boolean ssl = "https".equalsIgnoreCase(scheme);
         final SslContext sslCtx;
         if (ssl) {
-            SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
         } else {
             sslCtx = null;
         }

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -34,6 +34,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketVersion;
 import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 import java.io.BufferedReader;
@@ -82,8 +83,7 @@ public static void main(String[] args) throws Exception {
         final boolean ssl = "wss".equalsIgnoreCase(scheme);
         final SslContext sslCtx;
         if (ssl) {
-            SelfSignedCertificate ssc = new SelfSignedCertificate();
-            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
         } else {
             sslCtx = null;
         }

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -411,9 +411,9 @@ public TrafficCounter trafficCounter() {
 
     @Override
     public String toString() {
-        return "TrafficShaping with Write Limit: " + writeLimit +
-                " Read Limit: " + readLimit + " and Counter: " +
-                (trafficCounter != null? trafficCounter.toString() : "none");
+        return "TrafficShaping with Write Limit: " + writeLimit + " Read Limit: " + readLimit +
+                " CheckInterval: " + checkInterval + " and Counter: "
+                + (trafficCounter != null ? trafficCounter.toString() : "none");
     }
 
     /**

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -117,6 +117,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
                 ctx.channel().hashCode(), checkInterval);
         setTrafficCounter(trafficCounter);
         trafficCounter.start();
+        super.handlerAdded(ctx);
     }
 
     @Override
@@ -130,6 +131,7 @@ public synchronized void handlerRemoved(ChannelHandlerContext ctx) throws Except
             }
         }
         messagesQueue.clear();
+        super.handlerRemoved(ctx);
     }
 
     private static final class ToSend {

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -172,6 +172,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         Integer key = ctx.channel().hashCode();
         List<ToSend> mq = new LinkedList<ToSend>();
         messagesQueues.put(key, mq);
+        super.handlerAdded(ctx);
     }
 
     @Override
@@ -186,6 +187,7 @@ public synchronized void handlerRemoved(ChannelHandlerContext ctx) throws Except
             }
             mq.clear();
         }
+        super.handlerRemoved(ctx);
     }
 
     private static final class ToSend {

File: codec/src/main/java/io/netty/handler/codec/compression/LzmaFrameEncoder.java
Patch:
@@ -144,7 +144,7 @@ public LzmaFrameEncoder(int lc, int lp, int pb, int dictionarySize, boolean endM
         if (pb < 0 || pb > 4) {
             throw new IllegalArgumentException("pb: " + pb + " (expected: 0-4)");
         }
-        if (lc + pb > 4) {
+        if (lc + lp > 4) {
             if (!warningLogged) {
                 logger.warn("The latest versions of LZMA libraries (for example, XZ Utils) " +
                         "has an additional requirement: lc + lp <= 4. Data which don't follow " +

File: handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
Patch:
@@ -190,6 +190,7 @@ private static byte[][] toFingerprintArray(Iterable<String> fingerprints) {
                 int strIdx = i << 1;
                 farr[i] = (byte) Integer.parseInt(f.substring(strIdx, strIdx + 2), 16);
             }
+            list.add(farr);
         }
 
         return list.toArray(new byte[list.size()][]);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -203,10 +203,10 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
     private void cleanup() {
         if (decoder != null) {
-            // Clean-up the previous encoder if not cleaned up correctly.
+            // Clean-up the previous decoder if not cleaned up correctly.
             if (decoder.finish()) {
                 for (;;) {
-                    ByteBuf buf = decoder.readOutbound();
+                    ByteBuf buf = decoder.readInbound();
                     if (buf == null) {
                         break;
                     }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -276,7 +276,7 @@ private boolean writeFileRegion(ChannelOutboundBuffer in, DefaultFileRegion regi
         boolean done = false;
         long flushedAmount = 0;
 
-        for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
+        for (;;) {
             final long offset = region.transfered();
             final long localFlushedAmount = Native.sendfile(fd, region, baseOffset, offset, regionCount - offset);
             if (localFlushedAmount == 0) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 
 abstract class SpdyHeaderBlockDecoder {
 
@@ -28,13 +29,14 @@ static SpdyHeaderBlockDecoder newInstance(SpdyVersion spdyVersion, int maxHeader
      * If the header block is malformed, the Headers frame will be marked as invalid.
      * A stream error with status code PROTOCOL_ERROR must be issued in response to an invalid frame.
      *
+     * @param alloc the {@link ByteBufAllocator} which can be used to allocate new {@link ByteBuf}s
      * @param headerBlock the HeaderBlock to decode
      * @param frame the Headers frame that receives the Name/Value pairs
      * @throws Exception If the header block is malformed in a way that prevents any future
      *                   decoding of any other header blocks, an exception will be thrown.
      *                   A session error with status code PROTOCOL_ERROR must be issued.
      */
-    abstract void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception;
+    abstract void decode(ByteBufAllocator alloc, ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception;
 
     abstract void endHeaderBlock(SpdyHeadersFrame frame) throws Exception;
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockEncoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.util.internal.PlatformDependent;
 
 abstract class SpdyHeaderBlockEncoder {
@@ -32,6 +33,6 @@ static SpdyHeaderBlockEncoder newInstance(
         }
     }
 
-    abstract ByteBuf encode(SpdyHeadersFrame frame) throws Exception;
+    abstract ByteBuf encode(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Exception;
     abstract void end();
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 
@@ -61,7 +62,7 @@ private static int readLengthField(ByteBuf buffer) {
     }
 
     @Override
-    void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
+    void decode(ByteBufAllocator alloc, ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
         if (headerBlock == null) {
             throw new NullPointerException("headerBlock");
         }
@@ -72,7 +73,7 @@ void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
         if (cumulation == null) {
             decodeHeaderBlock(headerBlock, frame);
             if (headerBlock.isReadable()) {
-                cumulation = headerBlock.alloc().buffer(headerBlock.readableBytes());
+                cumulation = alloc.buffer(headerBlock.readableBytes());
                 cumulation.writeBytes(headerBlock);
             }
         } else {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.Unpooled;
 
 import java.util.Set;
@@ -42,7 +43,7 @@ private static void writeLengthField(ByteBuf buffer, int length) {
     }
 
     @Override
-    public ByteBuf encode(SpdyHeadersFrame frame) throws Exception {
+    public ByteBuf encode(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Exception {
         Set<String> names = frame.headers().names();
         int numHeaders = names.size();
         if (numHeaders == 0) {
@@ -52,7 +53,7 @@ public ByteBuf encode(SpdyHeadersFrame frame) throws Exception {
             throw new IllegalArgumentException(
                     "header block contains too many headers");
         }
-        ByteBuf headerBlock = Unpooled.buffer();
+        ByteBuf headerBlock = alloc.heapBuffer();
         writeLengthField(headerBlock, numHeaders);
         for (String name: names) {
             byte[] nameBytes = name.getBytes("UTF-8");

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java
Patch:
@@ -38,12 +38,12 @@ final class SpdyHeaderBlockZlibDecoder extends SpdyHeaderBlockRawDecoder {
     }
 
     @Override
-    void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
+    void decode(ByteBufAllocator alloc, ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
         int len = setInput(headerBlock);
 
         int numBytes;
         do {
-            numBytes = decompress(headerBlock.alloc(), frame);
+            numBytes = decompress(alloc, frame);
         } while (numBytes > 0);
 
         // z_stream has an internal 64-bit hold buffer

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -145,7 +145,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 // GET Method: should not try to create a HttpPostRequestDecoder
                 // So stop here
                 responseContent.append("\r\n\r\nEND OF GET CONTENT\r\n");
-                writeResponse(ctx.channel());
+                // Not now: LastHttpContent will be sent writeResponse(ctx.channel());
                 return;
             }
             try {
@@ -195,6 +195,8 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                     reset();
                 }
             }
+        } else {
+            writeResponse(ctx.channel());
         }
     }
 

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -63,8 +63,8 @@ public final class NetUtil {
     public static final NetworkInterface LOOPBACK_IF;
 
     /**
-     * The SOMAXCONN value of the current machine.  If failed to get the value, 3072 is used as a
-     * default value.
+     * The SOMAXCONN value of the current machine.  If failed to get the value,  {@code 200}  is used as a
+     * default value for Windows or {@code 128} for others.
      */
     public static final int SOMAXCONN;
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java
Patch:
@@ -500,6 +500,7 @@ public void channelRead0(final ChannelHandlerContext ctx, ByteBuf in) throws Exc
                     }
                 }
             }
+            Thread.sleep(10);
             loggerServer.debug("Step: " + step + " Write: " + nb);
             for (int i = 0; i < nb; i++) {
                 channel.write(Unpooled.copyLong(timestamp));

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -88,8 +88,8 @@ public EmbeddedChannel(ChannelHandler... handlers) {
             p.addLast(h);
         }
 
-        p.addLast(new LastInboundHandler());
         loop.register(this);
+        p.addLast(new LastInboundHandler());
     }
 
     @Override

File: codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java
Patch:
@@ -18,4 +18,3 @@
  * Encoder, decoder and their related message types for Socks.
  */
 package io.netty.handler.codec.socks;
-// TODO: Combine decoders into one.

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * Encoder, decoder and their related message types for Socks.
+ * Encoder, decoder and their related message types for SOCKS protocol.
  */
 package io.netty.handler.codec.socksx;

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4CommonUtils.java
Patch:
@@ -16,7 +16,8 @@
 package io.netty.handler.codec.socksx.v4;
 import io.netty.util.internal.StringUtil;
 
-public final class SocksV4CommonUtils {
+final class Socks4CommonUtils {
+
     private static final int SECOND_ADDRESS_OCTET_SHIFT = 16;
     private static final int FIRST_ADDRESS_OCTET_SHIFT = 24;
     private static final int THIRD_ADDRESS_OCTET_SHIFT = 8;
@@ -25,7 +26,7 @@ public final class SocksV4CommonUtils {
     /**
      * A constructor to stop this class being constructed.
      */
-    private SocksV4CommonUtils() {
+    private Socks4CommonUtils() {
         // NOOP
     }
 

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * Encoder, decoder and their related message types for Socks.
+ * Encoder, decoder and their related message types for SOCKSv4 protocol.
  */
 package io.netty.handler.codec.socksx.v4;

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommonUtils.java
Patch:
@@ -16,7 +16,8 @@
 package io.netty.handler.codec.socksx.v5;
 import io.netty.util.internal.StringUtil;
 
-public final class SocksV5CommonUtils {
+final class Socks5CommonUtils {
+
     private static final int SECOND_ADDRESS_OCTET_SHIFT = 16;
     private static final int FIRST_ADDRESS_OCTET_SHIFT = 24;
     private static final int THIRD_ADDRESS_OCTET_SHIFT = 8;
@@ -25,7 +26,7 @@ public final class SocksV5CommonUtils {
     /**
      * A constructor to stop this class being constructed.
      */
-    private SocksV5CommonUtils() {
+    private Socks5CommonUtils() {
         // NOOP
     }
 

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5RequestType.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Type of socks request
  */
-public enum SocksV5RequestType {
+public enum Socks5RequestType {
     INIT,
     AUTH,
     CMD,

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ResponseType.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Type of socks response
  */
-public enum SocksV5ResponseType {
+public enum Socks5ResponseType {
     INIT,
     AUTH,
     CMD,

File: codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/package-info.java
Patch:
@@ -15,7 +15,6 @@
  */
 
 /**
- * Encoder, decoder and their related message types for Socks.
+ * Encoder, decoder and their related message types for SOCKSv5 protocol.
  */
 package io.netty.handler.codec.socksx.v5;
-// TODO: Combine decoders into one.

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v4/Socks4CmdRequestTest.java
Patch:
@@ -18,6 +18,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class SocksV4CmdRequestTest {
-    private static final Logger logger = LoggerFactory.getLogger(SocksV4CmdRequestTest.class);
+public class Socks4CmdRequestTest {
+    private static final Logger logger = LoggerFactory.getLogger(Socks4CmdRequestTest.class);
 }

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v4/Socks4CmdResponseTest.java
Patch:
@@ -18,6 +18,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class SocksV4CmdResponseTest {
-    private static final Logger logger = LoggerFactory.getLogger(SocksV4CmdResponseTest.class);
+public class Socks4CmdResponseTest {
+    private static final Logger logger = LoggerFactory.getLogger(Socks4CmdResponseTest.class);
 }

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5AuthResponseTest.java
Patch:
@@ -18,11 +18,11 @@
 import org.junit.Test;
 import static org.junit.Assert.assertTrue;
 
-public class SocksV5AuthResponseTest {
+public class Socks5AuthResponseTest {
     @Test
     public void testConstructorParamsAreNotNull() {
         try {
-            new SocksV5AuthResponse(null);
+            new Socks5AuthResponse(null);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5InitRequestTest.java
Patch:
@@ -18,11 +18,11 @@
 import org.junit.Test;
 import static org.junit.Assert.assertTrue;
 
-public class SocksV5InitRequestTest {
+public class Socks5InitRequestTest {
     @Test
     public void testConstructorParamsAreNotNull() {
         try {
-            new SocksV5InitRequest(null);
+            new Socks5InitRequest(null);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }

File: codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5InitResponseTest.java
Patch:
@@ -18,11 +18,11 @@
 import org.junit.Test;
 import static org.junit.Assert.assertTrue;
 
-public class SocksV5InitResponseTest {
+public class Socks5InitResponseTest {
     @Test
     public void testConstructorParamsAreNotNull() {
         try {
-            new SocksV5InitResponse(null);
+            new Socks5InitResponse(null);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFrameEncoderTest.java
Patch:
@@ -25,12 +25,12 @@
 import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
 
-public class SnappyFramedEncoderTest {
+public class SnappyFrameEncoderTest {
     private EmbeddedChannel channel;
 
     @Before
     public void setUp() {
-        channel = new EmbeddedChannel(new SnappyFramedEncoder());
+        channel = new EmbeddedChannel(new SnappyFrameEncoder());
     }
 
     @Test

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -33,12 +33,12 @@ public class SnappyIntegrationTest extends IntegrationTest {
 
     @Override
     protected EmbeddedChannel createEncoderEmbeddedChannel() {
-        return new EmbeddedChannel(new SnappyFramedEncoder());
+        return new EmbeddedChannel(new SnappyFrameEncoder());
     }
 
     @Override
     protected EmbeddedChannel createDecoderEmbeddedChannel() {
-        return new EmbeddedChannel(new SnappyFramedDecoder());
+        return new EmbeddedChannel(new SnappyFrameDecoder());
     }
 
     @Test

File: codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java
Patch:
@@ -26,7 +26,7 @@
 import static io.netty.handler.codec.compression.FastLz.*;
 
 /**
- * Uncompresses a {@link ByteBuf} encoded with the Bzip2 format.
+ * Uncompresses a {@link ByteBuf} encoded by {@link FastLzFrameEncoder} using the FastLZ algorithm.
  *
  * See <a href="https://github.com/netty/netty/issues/2750">FastLZ format</a>.
  */

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -283,13 +283,12 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
 
     /**
      * Decode the from one {@link ByteBuf} to an other. This method will be called till either the input
-     * {@link ByteBuf} has nothing to read anymore, till nothing was read from the input {@link ByteBuf} or till
-     * this method returns {@code null}.
+     * {@link ByteBuf} has nothing to read when return from this method or till nothing was read from the input
+     * {@link ByteBuf}.
      *
      * @param ctx           the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to
      * @param in            the {@link ByteBuf} from which to read data
      * @param out           the {@link List} to which decoded messages should be added
-
      * @throws Exception    is thrown if an error accour
      */
     protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -240,7 +240,7 @@
  * public class FirstDecoder extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {
  *
  *     {@code @Override}
- *     protected Object decode({@link ChannelHandlerContext} ctx,
+ *     protected void decode({@link ChannelHandlerContext} ctx,
  *                             {@link ByteBuf} buf, List&lt;Object&gt; out) {
  *         ...
  *         // Decode the first message

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -75,7 +75,8 @@ public static native long writevAddresses(int fd, long memoryAddress, int length
     public static native int read(int fd, ByteBuffer buf, int pos, int limit) throws IOException;
     public static native int readAddress(int fd, long address, int pos, int limit) throws IOException;
 
-    public static native long sendfile(int dest, DefaultFileRegion src, long offset, long length) throws IOException;
+    public static native long sendfile(
+            int dest, DefaultFileRegion src, long baseOffset, long offset, long length) throws IOException;
 
     public static int sendTo(
             int fd, ByteBuffer buf, int pos, int limit, InetAddress addr, int port) throws IOException {

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -53,7 +53,9 @@ public final class ByteBufUtil {
             HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i       & 0x0F];
         }
 
-        String allocType = SystemPropertyUtil.get("io.netty.allocator.type", "unpooled").toLowerCase(Locale.US).trim();
+        String allocType = SystemPropertyUtil.get(
+                "io.netty.allocator.type", PlatformDependent.isAndroid() ? "unpooled" : "pooled");
+        allocType = allocType.toLowerCase(Locale.US).trim();
 
         ByteBufAllocator alloc;
         if ("unpooled".equals(allocType)) {

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -155,7 +155,7 @@ public void addFlush() {
      * Increment the pending bytes which will be written at some point.
      * This method is thread-safe!
      */
-    void incrementPendingOutboundBytes(int size) {
+    void incrementPendingOutboundBytes(long size) {
         if (size == 0) {
             return;
         }
@@ -172,7 +172,7 @@ void incrementPendingOutboundBytes(int size) {
      * Decrement the pending bytes which will be written at some point.
      * This method is thread-safe!
      */
-    void decrementPendingOutboundBytes(int size) {
+    void decrementPendingOutboundBytes(long size) {
         if (size == 0) {
             return;
         }

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java
Patch:
@@ -45,8 +45,8 @@ public void testSingleFrameDecoding() {
         incoming.writeBytes(StompTestConstants.CONNECT_FRAME.getBytes());
         channel.writeInbound(incoming);
 
-        StompHeadersSubframe frame = channel.readInbound();
-        Assert.assertTrue(frame instanceof StompFrame);
+        StompFrame frame = channel.readInbound();
+        frame.release();
 
         Assert.assertNull(channel.readInbound());
     }

File: common/src/test/java/io/netty/util/HashedWheelTimerTest.java
Patch:
@@ -131,7 +131,7 @@ public void run(final Timeout timeout) throws Exception {
     public void testExecutionOnTime() throws InterruptedException {
         int tickDuration = 200;
         int timeout = 125;
-        int maxTimeout = tickDuration + timeout + tickDuration;
+        int maxTimeout = 2 * (tickDuration + timeout);
         final HashedWheelTimer timer = new HashedWheelTimer(tickDuration, TimeUnit.MILLISECONDS);
         final BlockingQueue<Long> queue = new LinkedBlockingQueue<Long>();
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -420,7 +420,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        for (Integer streamId: spdySession.getActiveStreams()) {
+        for (Integer streamId: spdySession.activeStreams().keySet()) {
             removeStream(streamId, ctx.newSucceededFuture());
         }
         ctx.fireChannelInactive();

File: codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java
Patch:
@@ -74,7 +74,6 @@ public void readResponseTest() throws Exception {
             ByteBuf packet = embedder.alloc().buffer(512).writeBytes(p);
             embedder.writeInbound(new DatagramPacket(packet, null, new InetSocketAddress(0)));
             DnsResponse decoded = embedder.readInbound();
-            packet.retain().readerIndex(0);
             ByteBuf raw = Unpooled.wrappedBuffer(p);
             Assert.assertEquals("Invalid id, expected: " + raw.getUnsignedShort(0) + ", actual: "
                     + decoded.header().id(), raw.getUnsignedShort(0), decoded.header().id());

File: transport/src/test/java/io/netty/channel/DefaultChannelIdTest.java
Patch:
@@ -39,7 +39,7 @@ public void testShortText() {
     @Test
     public void testLongText() {
         String text = DefaultChannelId.newInstance().asLongText();
-        assertTrue(text.matches("^[0-9a-f]{16}-[0-9a-f]{4}-[0-9a-f]{8}-[0-9a-f]{16}-[0-9a-f]{8}$"));
+        assertTrue(text.matches("^[0-9a-f]{16}-[0-9a-f]{8}-[0-9a-f]{8}-[0-9a-f]{16}-[0-9a-f]{8}$"));
     }
 
     @Test

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResource.java
Patch:
@@ -74,7 +74,7 @@ public DnsResource copy() {
      * Returns a duplicate of this resource record.
      */
     @Override
-    public ByteBufHolder duplicate() {
+    public DnsResource duplicate() {
         return new DnsResource(name(), type(), dnsClass(), ttl, content.duplicate());
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -116,16 +116,16 @@ private boolean writeBytes(ChannelOutboundBuffer in, ByteBuf buf) throws Excepti
         if (buf.hasMemoryAddress()) {
             long memoryAddress = buf.memoryAddress();
             int readerIndex = buf.readerIndex();
+            int writerIndex = buf.writerIndex();
             for (;;) {
-                int localFlushedAmount = Native.writeAddress(fd, memoryAddress, readerIndex, readableBytes);
+                int localFlushedAmount = Native.writeAddress(fd, memoryAddress, readerIndex, writerIndex);
                 if (localFlushedAmount > 0) {
                     writtenBytes += localFlushedAmount;
                     if (writtenBytes == readableBytes) {
                         done = true;
                         break;
                     }
                     readerIndex += localFlushedAmount;
-                    readableBytes -= localFlushedAmount;
                 } else {
                     // Returned EAGAIN need to set EPOLLOUT
                     setEpollOut();

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryEncoder.java
Patch:
@@ -85,7 +85,7 @@ private static void encodeQuestion(DnsQuestion question, Charset charset, ByteBu
             buf.writeBytes(part.getBytes(charset));
         }
         buf.writeByte(0); // marks end of name field
-        buf.writeShort(question.type().type());
-        buf.writeShort(question.dnsClass().clazz());
+        buf.writeShort(question.type().intValue());
+        buf.writeShort(question.dnsClass().intValue());
     }
 }

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryEncoder.java
Patch:
@@ -85,7 +85,7 @@ private static void encodeQuestion(DnsQuestion question, Charset charset, ByteBu
             buf.writeBytes(part.getBytes(charset));
         }
         buf.writeByte(0); // marks end of name field
-        buf.writeShort(question.type());
-        buf.writeShort(question.dnsClass());
+        buf.writeShort(question.type().type());
+        buf.writeShort(question.dnsClass().clazz());
     }
 }

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResource.java
Patch:
@@ -41,7 +41,7 @@ public final class DnsResource extends DnsEntry implements ByteBufHolder {
      * @param content
      *            the data contained in this record
      */
-    public DnsResource(String name, int type, int aClass, long ttl, ByteBuf content) {
+    public DnsResource(String name, DnsType type, DnsClass aClass, long ttl, ByteBuf content) {
         super(name, type, aClass);
         this.ttl = ttl;
         this.content = content;

File: transport/src/test/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBufferTest.java
Patch:
@@ -36,7 +36,7 @@ public void testEmptyNioBuffers() {
         NioSocketChannelOutboundBuffer buffer = NioSocketChannelOutboundBuffer.newInstance(channel);
         assertEquals(0, buffer.nioBufferCount());
         ByteBuffer[] buffers = buffer.nioBuffers();
-        assertEquals(32, buffers.length);
+        assertNotNull(buffers);
         for (ByteBuffer b: buffers) {
             assertNull(b);
         }
@@ -50,7 +50,7 @@ public void testNioBuffersSingleBacked() {
         NioSocketChannelOutboundBuffer buffer = NioSocketChannelOutboundBuffer.newInstance(channel);
         assertEquals(0, buffer.nioBufferCount());
         ByteBuffer[] buffers = buffer.nioBuffers();
-        assertEquals(32, buffers.length);
+        assertNotNull(buffers);
         for (ByteBuffer b: buffers) {
             assertNull(b);
         }
@@ -66,7 +66,7 @@ public void testNioBuffersSingleBacked() {
         }
         buffer.addFlush();
         buffers = buffer.nioBuffers();
-        assertEquals(32, buffers.length);
+        assertNotNull(buffers);
         assertEquals("Should still be 0 as not flushed yet", 1, buffer.nioBufferCount());
         for (int i = 0;  i < buffers.length; i++) {
             if (i == 0) {

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java
Patch:
@@ -317,9 +317,6 @@ public class DnsEntry {
         if (name == null) {
             throw new NullPointerException("name");
         }
-        if (name.isEmpty()) {
-            throw new IllegalArgumentException("name must not be left blank.");
-        }
         if ((type & 0xffff) != type) {
             throw new IllegalArgumentException("type must be an unsigned short.");
         }

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java
Patch:
@@ -110,8 +110,9 @@ private static String readName(ByteBuf buf) {
             buf.readerIndex(position);
         }
         if (name.length() == 0) {
-            return null;
+            return "";
         }
+
         return name.substring(0, name.length() - 1);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
Patch:
@@ -140,7 +140,7 @@ public String toString() {
                 HttpHeaders.Names.CONTENT_LENGTH + ": " + length() + "\r\n" +
                 "Completed: " + isCompleted() +
                 "\r\nIsInMemory: " + isInMemory() + "\r\nRealFile: " +
-                file.getAbsolutePath() + " DefaultDeleteAfter: " +
+                (file != null ? file.getAbsolutePath() : "null") + " DefaultDeleteAfter: " +
                 deleteOnExitTemporaryFile;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
Patch:
@@ -54,7 +54,7 @@ public CloseWebSocketFrame(int statusCode, String reasonText) {
      *            reserved bits used for protocol extensions
      */
     public CloseWebSocketFrame(boolean finalFragment, int rsv) {
-        this(finalFragment, rsv, null);
+        this(finalFragment, rsv, Unpooled.buffer(0));
     }
 
     /**

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
Patch:
@@ -28,9 +28,6 @@ public class DefaultStompFrame extends DefaultStompHeadersSubframe implements St
 
     public DefaultStompFrame(StompCommand command) {
         this(command, Unpooled.buffer(0));
-        if (command == null) {
-            throw new NullPointerException("command");
-        }
     }
 
     public DefaultStompFrame(StompCommand command, ByteBuf content) {

File: handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
Patch:
@@ -322,7 +322,7 @@ public SSLEngine newEngine(ByteBufAllocator alloc, String peerHost, int peerPort
      * Sets the SSL session ticket keys of this context.
      */
     public void setTicketKeys(byte[] keys) {
-        if (keys != null) {
+        if (keys == null) {
             throw new NullPointerException("keys");
         }
         SSLContext.setSessionTicketKeys(ctx, keys);

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -209,9 +209,6 @@ protected int doReadMessages(List<Object> buf) throws Exception {
             socket.receive(tmpPacket);
 
             InetSocketAddress remoteAddr = (InetSocketAddress) tmpPacket.getSocketAddress();
-            if (remoteAddr == null) {
-                remoteAddr = remoteAddress();
-            }
 
             int readBytes = tmpPacket.getLength();
             allocHandle.record(readBytes);

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -186,7 +186,7 @@ public final class NetUtil {
             somaxconn = Integer.parseInt(in.readLine());
             logger.debug("/proc/sys/net/core/somaxconn: {}", somaxconn);
         } catch (Exception e) {
-            // Failed to get SOMAXCONN
+            logger.debug("Failed to get SOMAXCONN", e);
         } finally {
             if (in != null) {
                 try {

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -236,7 +236,7 @@ boolean transfer(Stack<?> to) {
             }
             to.size = size;
 
-            if (end == LINK_CAPACITY & head.next != null) {
+            if (end == LINK_CAPACITY && head.next != null) {
                 this.head = head.next;
             }
 

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -163,7 +163,7 @@ public <T> T readOutbound() {
      *
      * @param msgs the messages to be written
      *
-     * @return {@code true} if the write operation did add something to the the inbound buffer
+     * @return {@code true} if the write operation did add something to the inbound buffer
      */
     public boolean writeInbound(Object... msgs) {
         ensureOpen();
@@ -185,7 +185,7 @@ public boolean writeInbound(Object... msgs) {
      * Write messages to the outbound of this {@link Channel}.
      *
      * @param msgs              the messages to be written
-     * @return bufferReadable   returns {@code true} if the write operation did add something to the the outbound buffer
+     * @return bufferReadable   returns {@code true} if the write operation did add something to the outbound buffer
      */
     public boolean writeOutbound(Object... msgs) {
         ensureOpen();

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanAllocator.java
Patch:
@@ -42,7 +42,7 @@ private static int first(final int[] array, int i, final int nodesToMove) {
         i = Math.max(nodesToMove - 1, i);
 
         while (k > i + 1) {
-            int temp = i + k >> 1;
+            int temp = i + k >>> 1;
             if (array[temp] % length > limit) {
                 k = temp;
             } else {

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java
Patch:
@@ -31,7 +31,7 @@ public class JZlibDecoder extends ZlibDecoder {
     /**
      * Creates a new instance with the default wrapper ({@link ZlibWrapper#ZLIB}).
      *
-     * @throws CompressionException if failed to initialize zlib
+     * @throws DecompressionException if failed to initialize zlib
      */
     public JZlibDecoder() {
         this(ZlibWrapper.ZLIB);
@@ -40,7 +40,7 @@ public JZlibDecoder() {
     /**
      * Creates a new instance with the specified wrapper.
      *
-     * @throws CompressionException if failed to initialize zlib
+     * @throws DecompressionException if failed to initialize zlib
      */
     public JZlibDecoder(ZlibWrapper wrapper) {
         if (wrapper == null) {
@@ -58,7 +58,7 @@ public JZlibDecoder(ZlibWrapper wrapper) {
      * is always {@link ZlibWrapper#ZLIB} because it is the only format that
      * supports the preset dictionary.
      *
-     * @throws CompressionException if failed to initialize zlib
+     * @throws DecompressionException if failed to initialize zlib
      */
     public JZlibDecoder(byte[] dictionary) {
         if (dictionary == null) {

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -29,7 +29,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-
 /**
  * Compresses a {@link ByteBuf} using the deflate algorithm.
  */

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
Patch:
@@ -27,7 +27,6 @@
 import java.util.zip.CRC32;
 import java.util.zip.Deflater;
 
-
 /**
  * Compresses a {@link ByteBuf} using the deflate algorithm.
  */

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -24,7 +24,7 @@
  *
  * See http://code.google.com/p/snappy/source/browse/trunk/format_description.txt
  */
-public class Snappy {
+class Snappy {
 
     private static final int MAX_HT_SIZE = 1 << 14;
     private static final int MIN_COMPRESSIBLE_BYTES = 15;

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibUtil.java
Patch:
@@ -32,8 +32,8 @@ static void fail(Deflater z, String message, int resultCode) {
         throw deflaterException(z, message, resultCode);
     }
 
-    static CompressionException inflaterException(Inflater z, String message, int resultCode) {
-        return new CompressionException(message + " (" + resultCode + ')' + (z.msg != null? ": " + z.msg : ""));
+    static DecompressionException inflaterException(Inflater z, String message, int resultCode) {
+        return new DecompressionException(message + " (" + resultCode + ')' + (z.msg != null? ": " + z.msg : ""));
     }
 
     static CompressionException deflaterException(Deflater z, String message, int resultCode) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -554,6 +554,7 @@ private void fulfillConnectPromise(ChannelPromise promise, boolean wasActive) {
         private void fulfillConnectPromise(ChannelPromise promise, Throwable cause) {
             if (promise == null) {
                 // Closed via cancellation and the promise has been notified already.
+                return;
             }
 
             // Use tryFailure() instead of setFailure() to avoid the race against cancel().

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -268,6 +268,7 @@ private void fulfillConnectPromise(ChannelPromise promise, boolean wasActive) {
         private void fulfillConnectPromise(ChannelPromise promise, Throwable cause) {
             if (promise == null) {
                 // Closed via cancellation and the promise has been notified already.
+                return;
             }
 
             // Use tryFailure() instead of setFailure() to avoid the race against cancel().

File: buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java
Patch:
@@ -129,6 +129,7 @@ public ByteBuf setDouble(int index, double value) {
 
     @Override
     public ByteBuf writeShort(int value) {
+        wrapped.ensureAccessible();
         wrapped.ensureWritable(2);
         _setShort(wrapped.writerIndex, value);
         wrapped.writerIndex += 2;
@@ -137,6 +138,7 @@ public ByteBuf writeShort(int value) {
 
     @Override
     public ByteBuf writeInt(int value) {
+        wrapped.ensureAccessible();
         wrapped.ensureWritable(4);
         _setInt(wrapped.writerIndex, value);
         wrapped.writerIndex += 4;
@@ -145,6 +147,7 @@ public ByteBuf writeInt(int value) {
 
     @Override
     public ByteBuf writeLong(long value) {
+        wrapped.ensureAccessible();
         wrapped.ensureWritable(8);
         _setLong(wrapped.writerIndex, value);
         wrapped.writerIndex += 8;

File: common/src/test/java/io/netty/util/HashedWheelTimerTest.java
Patch:
@@ -131,7 +131,7 @@ public void run(final Timeout timeout) throws Exception {
     public void testExecutionOnTime() throws InterruptedException {
         int tickDuration = 200;
         int timeout = 125;
-        int maxTimeout = tickDuration + timeout;
+        int maxTimeout = tickDuration + timeout + tickDuration;
         final HashedWheelTimer timer = new HashedWheelTimer(tickDuration, TimeUnit.MILLISECONDS);
         final BlockingQueue<Long> queue = new LinkedBlockingQueue<Long>();
 
@@ -148,8 +148,8 @@ public void run(final Timeout timeout) throws Exception {
 
         for (int i = 0; i < scheduledTasks; i++) {
             long delay = queue.take();
-            assertTrue("Timeout + " + scheduledTasks + " delay " + delay + " must be " + timeout + " <= " + maxTimeout,
-                    delay >= timeout && delay <= maxTimeout);
+            assertTrue("Timeout + " + scheduledTasks + " delay " + delay + " must be " + timeout + " < " + maxTimeout,
+                    delay >= timeout && delay < maxTimeout);
         }
 
         timer.stop();

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -100,7 +100,7 @@ public void testAggregateWithTrailer() {
         assertEquals(chunk1.content().readableBytes() + chunk2.content().readableBytes(),
                 HttpHeaders.getContentLength(aggratedMessage));
         assertEquals(aggratedMessage.headers().get("X-Test"), Boolean.TRUE.toString());
-        assertEquals(aggratedMessage.headers().get("X-Trailer"), Boolean.TRUE.toString());
+        assertEquals(aggratedMessage.trailingHeaders().get("X-Trailer"), Boolean.TRUE.toString());
         checkContentBuffer(aggratedMessage);
         assertNull(embedder.readInbound());
     }

File: codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
Patch:
@@ -98,7 +98,6 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             reset();
             throw new TooLongFrameException(
                             "object length exceeds " + maxObjectLength + ": " + wrtIdx + " bytes discarded");
-
         }
 
         for (/* use current idx */; idx < wrtIdx; idx++) {

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -133,7 +133,6 @@ private void writeBytesMultiple(
 
         int nioBufferCnt = in.addressCount();
         long expectedWrittenBytes = in.addressSize();
-
         long localWrittenBytes = Native.writevAddresses(fd, nioBuffers, 0, nioBufferCnt);
 
         if (localWrittenBytes < expectedWrittenBytes) {

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -74,7 +74,7 @@ public EmbeddedChannel() {
      * @param handlers the @link ChannelHandler}s which will be add in the {@link ChannelPipeline}
      */
     public EmbeddedChannel(ChannelHandler... handlers) {
-        super(null);
+        super(null, EmbeddedChannelId.INSTANCE);
 
         if (handlers == null) {
             throw new NullPointerException("handlers");

File: codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
Patch:
@@ -170,6 +170,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
     /**
      * Override this method if you want to filter the json objects/arrays that get passed through the pipeline.
      */
+    @SuppressWarnings("UnusedParameters")
     protected ByteBuf extractObject(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {
         return buffer.slice(index, length).retain();
     }

File: codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
Patch:
@@ -24,8 +24,6 @@
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
-import java.nio.charset.Charset;
-
 import static org.junit.Assert.*;
 
 public class JsonObjectDecoderTest {
@@ -176,6 +174,7 @@ public void testSpecialJsonCharsInString() {
 
         ByteBuf res = ch.readInbound();
         assertEquals(object, res.toString(CharsetUtil.UTF_8));
+        res.release();
 
         assertFalse(ch.finish());
     }

File: buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
Patch:
@@ -37,7 +37,6 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
         refCntUpdater = updater;
     }
 
-    @SuppressWarnings("FieldMayBeFinal")
     private volatile int refCnt = 1;
 
     protected AbstractReferenceCountedByteBuf(int maxCapacity) {

File: buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
Patch:
@@ -189,7 +189,7 @@ public String readLine() throws IOException {
 
         loop: while (true) {
             if (!buffer.isReadable()) {
-                return (lineBuf.length() > 0) ? lineBuf.toString() : null;
+                return lineBuf.length() > 0 ? lineBuf.toString() : null;
             }
 
             int c = buffer.readUnsignedByte();
@@ -198,7 +198,7 @@ public String readLine() throws IOException {
                     break loop;
 
                 case '\r':
-                    if (buffer.isReadable() && buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {
+                    if (buffer.isReadable() && (char) buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {
                         buffer.skipBytes(1);
                     }
                     break loop;

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -289,7 +289,6 @@ private void consolidateIfNeeded() {
             ByteBuf consolidated = allocBuffer(capacity);
 
             // We're not using foreach to avoid creating an iterator.
-            // noinspection ForLoopReplaceableByForEach
             for (int i = 0; i < numComponents; i ++) {
                 Component c = components.get(i);
                 ByteBuf b = c.buf;
@@ -1098,7 +1097,6 @@ public int nioBufferCount() {
         } else {
             int count = 0;
             int componentsCount = components.size();
-            //noinspection ForLoopReplaceableByForEach
             for (int i = 0; i < componentsCount; i++) {
                 Component c = components.get(i);
                 count += c.buf.nioBufferCount();

File: buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
Patch:
@@ -41,7 +41,7 @@ final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf {
     private final Object[] buffers;
     private final boolean direct;
 
-    public FixedCompositeByteBuf(ByteBufAllocator allocator, ByteBuf... buffers) {
+    FixedCompositeByteBuf(ByteBufAllocator allocator, ByteBuf... buffers) {
         super(Integer.MAX_VALUE);
         if (buffers.length == 0) {
             this.buffers = EMPTY;
@@ -204,7 +204,6 @@ public boolean isDirect() {
 
     private Component findComponent(int index) {
         int readable = 0;
-        //noinspection ForLoopReplaceableByForEach
         for (int i = 0 ; i < buffers.length; i++) {
             Component comp = null;
             ByteBuf b;
@@ -545,7 +544,6 @@ public long memoryAddress() {
 
     @Override
     protected void deallocate() {
-        //noinspection ForLoopReplaceableByForEach
         for (int i = 0; i < buffers.length; i++) {
              buffer(i).release();
         }

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -147,7 +147,6 @@ protected final void deallocate() {
         }
     }
 
-    @SuppressWarnings("unchecked")
     private void recycle() {
         recyclerHandle.recycle(this);
     }

File: buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
Patch:
@@ -308,7 +308,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }

File: buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
Patch:
@@ -232,7 +232,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         index = idx(index);
         try {
             return in.read((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length));
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -309,7 +309,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
Patch:
@@ -36,7 +36,7 @@ class ReadOnlyByteBufferBuf extends AbstractReferenceCountedByteBuf {
     private final ByteBufAllocator allocator;
     private ByteBuffer tmpNioBuf;
 
-    public ReadOnlyByteBufferBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
+    ReadOnlyByteBufferBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
         super(buffer.remaining());
         if (!buffer.isReadOnly()) {
             throw new IllegalArgumentException("must be a readonly buffer: " + StringUtil.simpleClassName(buffer));
@@ -276,7 +276,7 @@ public ByteBuf copy(int index, int length) {
         ByteBuffer src;
         try {
             src = (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
-        } catch (IllegalArgumentException e) {
+        } catch (IllegalArgumentException ignored) {
             throw new IndexOutOfBoundsException("Too many bytes to read - Need " + (index + length));
         }
 

File: buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java
Patch:
@@ -30,7 +30,7 @@ final class ReadOnlyUnsafeDirectByteBuf extends ReadOnlyByteBufferBuf {
     private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
     private final long memoryAddress;
 
-    public ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
+    ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
         super(allocator, buffer);
         memoryAddress = PlatformDependent.directBufferAddress(buffer);
     }

File: buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
Patch:
@@ -39,7 +39,7 @@ public class SlicedByteBuf extends AbstractDerivedByteBuf {
     public SlicedByteBuf(ByteBuf buffer, int index, int length) {
         super(length);
         if (index < 0 || index > buffer.capacity() - length) {
-            throw new IndexOutOfBoundsException(buffer.toString() + ".slice(" + index + ", " + length + ')');
+            throw new IndexOutOfBoundsException(buffer + ".slice(" + index + ", " + length + ')');
         }
 
         if (buffer instanceof SlicedByteBuf) {

File: buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
Patch:
@@ -535,7 +535,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpNioBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -556,7 +556,7 @@ public ByteBuf copy(int index, int length) {
         ByteBuffer src;
         try {
             src = (ByteBuffer) buffer.duplicate().clear().position(index).limit(index + length);
-        } catch (IllegalArgumentException e) {
+        } catch (IllegalArgumentException ignored) {
             throw new IndexOutOfBoundsException("Too many bytes to read - Need " + (index + length));
         }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
Patch:
@@ -254,7 +254,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         ensureAccessible();
         try {
             return in.read((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length));
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
Patch:
@@ -444,7 +444,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }

File: buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
Patch:
@@ -773,6 +773,7 @@ public int hashCode() {
     }
 
     @Override
+    @SuppressWarnings("EqualsWhichDoesntCheckParameterClass")
     public boolean equals(Object obj) {
         return buf.equals(obj);
     }

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -71,8 +71,7 @@ protected ByteBuf newBuffer(int length) {
             buffers.add(EMPTY_BUFFER);
         }
 
-        buffer = Unpooled.wrappedBuffer(
-                Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);
+        buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);
 
         // Truncate to the requested capacity.
         buffer.capacity(length);
@@ -802,7 +801,7 @@ public void testDiscardSomeReadBytes() {
         CompositeByteBuf cbuf = releaseLater(compositeBuffer());
         int len = 8 * 4;
         for (int i = 0; i < len; i += 4) {
-            ByteBuf buf = Unpooled.buffer().writeInt(i);
+            ByteBuf buf = buffer().writeInt(i);
             cbuf.capacity(cbuf.writerIndex()).addComponent(buf).writerIndex(i + 4);
         }
         cbuf.writeByte(1);

File: buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
Patch:
@@ -46,15 +46,15 @@ public void testUnmodifiableBuffer() {
     @Test
     public void testUnwrap() {
         ByteBuf buf = buffer(1);
-        assertSame(buf, Unpooled.unmodifiableBuffer(buf).unwrap());
+        assertSame(buf, unmodifiableBuffer(buf).unwrap());
     }
 
     @Test
     public void shouldHaveSameByteOrder() {
         ByteBuf buf = buffer(1);
-        assertSame(BIG_ENDIAN, Unpooled.unmodifiableBuffer(buf).order());
+        assertSame(BIG_ENDIAN, unmodifiableBuffer(buf).order());
         buf = buf.order(LITTLE_ENDIAN);
-        assertSame(LITTLE_ENDIAN, Unpooled.unmodifiableBuffer(buf).order());
+        assertSame(LITTLE_ENDIAN, unmodifiableBuffer(buf).order());
     }
 
     @Test

File: codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseException.java
Patch:
@@ -20,6 +20,8 @@
 
 public final class DnsResponseException extends DecoderException {
 
+    private static final long serialVersionUID = -8519053051363525286L;
+
     private final DnsResponseCode code;
 
     public DnsResponseException(DnsResponseCode code) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -124,6 +124,7 @@ protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws
                         wrapper, compressionLevel, windowBits, memLevel)));
     }
 
+    @SuppressWarnings("FloatingPointEquality")
     protected ZlibWrapper determineWrapper(String acceptEncoding) {
         float starQ = -1.0f;
         float gzipQ = -1.0f;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1203,6 +1203,7 @@ static void encode(HttpHeaders headers, ByteBuf buf) {
         }
     }
 
+    @SuppressWarnings("deprecation")
     private static void encode(CharSequence key, CharSequence value, ByteBuf buf) {
         encodeAscii(key, buf);
         buf.writeBytes(HEADER_SEPERATOR);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.HttpObjectDecoder.State;
 import io.netty.util.internal.AppendableCharSequence;
 
 import java.util.List;
@@ -101,7 +102,7 @@
  * To implement the decoder of such a derived protocol, extend this class and
  * implement all abstract methods properly.
  */
-public abstract class HttpObjectDecoder extends ReplayingDecoder<HttpObjectDecoder.State> {
+public abstract class HttpObjectDecoder extends ReplayingDecoder<State> {
 
     private final int maxInitialLineLength;
     private final int maxHeaderSize;

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
Patch:
@@ -266,7 +266,7 @@ public static Builder withAnyOrigin() {
      * @return {@link Builder} to support method chaining.
      */
     public static Builder withOrigin(final String origin) {
-        if (origin.equals("*")) {
+        if ("*".equals(origin)) {
             return new Builder();
         }
         return new Builder(origin);

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
Patch:
@@ -156,7 +156,8 @@ protected static String[] getMultipartDataBoundary(String contentType) {
         String[] headerContentType = splitHeaderContentType(contentType);
         if (headerContentType[0].toLowerCase().startsWith(
                 HttpHeaders.Values.MULTIPART_FORM_DATA)) {
-            int mrank = 1, crank = 2;
+            int mrank;
+            int crank;
             if (headerContentType[1].toLowerCase().startsWith(
                     HttpHeaders.Values.BOUNDARY)) {
                 mrank = 1;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.ssl.SslHandler;
@@ -100,7 +99,7 @@ private static String getWebSocketLocation(ChannelPipeline cp, HttpRequest req,
             // SSL in use so use Secure WebSockets
             protocol = "wss";
         }
-        return protocol + "://" + req.headers().get(HttpHeaders.Names.HOST) + path;
+        return protocol + "://" + req.headers().get(Names.HOST) + path;
     }
 
 }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
Patch:
@@ -37,8 +37,8 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     }
 
     @Override
-    protected void encodeInitialLine(ByteBuf buf, HttpRequest request)
-            throws Exception {
+    @SuppressWarnings("deprecation")
+    protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {
         HttpHeaders.encodeAscii(request.method().toString(), buf);
         buf.writeByte(SP);
         buf.writeBytes(request.uri().getBytes(CharsetUtil.UTF_8));

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
Patch:
@@ -26,7 +26,6 @@
 /**
  * Encodes an RTSP response represented in {@link FullHttpResponse} into
  * a {@link ByteBuf}.
-
  */
 public class RtspResponseEncoder extends RtspObjectEncoder<HttpResponse> {
     private static final byte[] CRLF = { CR, LF };
@@ -37,8 +36,8 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     }
 
     @Override
-    protected void encodeInitialLine(ByteBuf buf, HttpResponse response)
-            throws Exception {
+    @SuppressWarnings("deprecation")
+    protected void encodeInitialLine(ByteBuf buf, HttpResponse response) throws Exception {
         HttpHeaders.encodeAscii(response.protocolVersion().toString(), buf);
         buf.writeByte(SP);
         buf.writeBytes(String.valueOf(response.status().code()).getBytes(CharsetUtil.US_ASCII));

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
Patch:
@@ -33,11 +33,11 @@ public SpdyHeaderBlockRawEncoder(SpdyVersion version) {
         this.version = version.getVersion();
     }
 
-    private void setLengthField(ByteBuf buffer, int writerIndex, int length) {
+    private static void setLengthField(ByteBuf buffer, int writerIndex, int length) {
         buffer.setInt(writerIndex, length);
     }
 
-    private void writeLengthField(ByteBuf buffer, int length) {
+    private static void writeLengthField(ByteBuf buffer, int length) {
         buffer.writeInt(length);
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java
Patch:
@@ -118,6 +118,6 @@ private static void check(ChunkedInput<?>... inputs) {
         }
 
         assertEquals(BYTES.length * inputs.length, read);
-        assertTrue("Last chunk must be DefaultLastHttpContent", lastHttpContent == LastHttpContent.EMPTY_LAST_CONTENT);
+        assertSame("Last chunk must be DefaultLastHttpContent", LastHttpContent.EMPTY_LAST_CONTENT, lastHttpContent);
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.DecoderResultProvider;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.util.CharsetUtil;
@@ -308,7 +309,7 @@ public void testBadRequest() {
         ch.writeInbound(Unpooled.copiedBuffer("GET / HTTP/1.0 with extra\r\n", CharsetUtil.UTF_8));
         Object inbound = ch.readInbound();
         assertThat(inbound, is(instanceOf(FullHttpRequest.class)));
-        assertTrue(((FullHttpRequest) inbound).getDecoderResult().isFailure());
+        assertTrue(((DecoderResultProvider) inbound).decoderResult().isFailure());
         assertNull(ch.readInbound());
         ch.finish();
     }
@@ -319,7 +320,7 @@ public void testBadResponse() throws Exception {
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.0 BAD_CODE Bad Server\r\n", CharsetUtil.UTF_8));
         Object inbound = ch.readInbound();
         assertThat(inbound, is(instanceOf(FullHttpResponse.class)));
-        assertTrue(((FullHttpResponse) inbound).getDecoderResult().isFailure());
+        assertTrue(((DecoderResultProvider) inbound).decoderResult().isFailure());
         assertNull(ch.readInbound());
         ch.finish();
     }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
Patch:
@@ -136,7 +136,6 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
             }
 
             // if header is done it should produce a HttpRequest
-            boolean headerDone = a + amount == headerLength;
             channel.writeInbound(Unpooled.wrappedBuffer(content, a, amount));
             a += amount;
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java
Patch:
@@ -47,7 +47,7 @@ public void testLargeFileRegionChunked() throws Exception {
         buffer.release();
 
         FileRegion region = channel.readOutbound();
-        assertSame(region, FILE_REGION);
+        assertSame(FILE_REGION, region);
         region.release();
         buffer = channel.readOutbound();
         assertEquals("\r\n", buffer.toString(CharsetUtil.US_ASCII));

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
Patch:
@@ -78,7 +78,7 @@ public void simpleRequestWithNoMatchingOrigin() {
     @Test
     public void preflightDeleteRequestWithCustomHeaders() {
         final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
-                .allowedRequestMethods(HttpMethod.GET, HttpMethod.DELETE)
+                .allowedRequestMethods(GET, DELETE)
                 .build();
         final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is("http://localhost:8888"));
@@ -89,7 +89,7 @@ public void preflightDeleteRequestWithCustomHeaders() {
     @Test
     public void preflightGetRequestWithCustomHeaders() {
         final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
-                .allowedRequestMethods(HttpMethod.OPTIONS, HttpMethod.GET, HttpMethod.DELETE)
+                .allowedRequestMethods(OPTIONS, GET, DELETE)
                 .allowedRequestHeaders("content-type", "xheader1")
                 .build();
         final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
Patch:
@@ -172,7 +172,7 @@ private static void testSpdySessionHandler(SpdyVersion version, boolean server)
         // a RST_STREAM frame for that Stream-ID
         sessionHandler.writeInbound(new DefaultSpdyRstStreamFrame(remoteStreamId, 3));
         assertNull(sessionHandler.readOutbound());
-        remoteStreamId += 2;
+        //remoteStreamId += 2;
 
         // Check if session handler honors UNIDIRECTIONAL streams
         spdySynStreamFrame.setLast(false);

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java
Patch:
@@ -16,8 +16,7 @@
 package io.netty.handler.codec.memcache.binary;
 
 /**
- * Contains all possible status values a
- * {@link BinaryMemcacheResponseHeader} can return.
+ * Contains all possible status values a {@link BinaryMemcacheResponse} can return.
  */
 public final class BinaryMemcacheResponseStatus {
 

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksAuthRequestDecoder.State;
 import io.netty.util.CharsetUtil;
 
 import java.util.List;
@@ -26,7 +27,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksAuthRequest}.
  * Before returning SocksRequest decoder removes itself from pipeline.
  */
-public class SocksAuthRequestDecoder extends ReplayingDecoder<SocksAuthRequestDecoder.State> {
+public class SocksAuthRequestDecoder extends ReplayingDecoder<State> {
 
     private SocksSubnegotiationVersion version;
     private int fieldLength;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
Patch:
@@ -18,14 +18,15 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksAuthResponseDecoder.State;
 
 import java.util.List;
 
 /**
  * Decodes {@link ByteBuf}s into {@link SocksAuthResponse}.
  * Before returning SocksResponse decoder removes itself from pipeline.
  */
-public class SocksAuthResponseDecoder extends ReplayingDecoder<SocksAuthResponseDecoder.State> {
+public class SocksAuthResponseDecoder extends ReplayingDecoder<State> {
 
     private SocksSubnegotiationVersion version;
     private SocksAuthStatus authStatus;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksCmdRequestDecoder.State;
 import io.netty.util.CharsetUtil;
 
 import java.util.List;
@@ -26,12 +27,13 @@
  * Decodes {@link ByteBuf}s into {@link SocksCmdRequest}.
  * Before returning SocksRequest decoder removes itself from pipeline.
  */
-public class SocksCmdRequestDecoder extends ReplayingDecoder<SocksCmdRequestDecoder.State> {
+public class SocksCmdRequestDecoder extends ReplayingDecoder<State> {
 
     private SocksProtocolVersion version;
     private int fieldLength;
     private SocksCmdType cmdType;
     private SocksAddressType addressType;
+    @SuppressWarnings("UnusedDeclaration")
     private byte reserved;
     private String host;
     private int port;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksCmdResponseDecoder.State;
 import io.netty.util.CharsetUtil;
 
 import java.util.List;
@@ -26,7 +27,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksCmdResponse}.
  * Before returning SocksResponse decoder removes itself from pipeline.
  */
-public class SocksCmdResponseDecoder extends ReplayingDecoder<SocksCmdResponseDecoder.State> {
+public class SocksCmdResponseDecoder extends ReplayingDecoder<State> {
 
     private SocksProtocolVersion version;
     private int fieldLength;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksInitRequestDecoder.State;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -26,7 +27,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksInitRequest}.
  * Before returning SocksRequest decoder removes itself from pipeline.
  */
-public class SocksInitRequestDecoder extends ReplayingDecoder<SocksInitRequestDecoder.State> {
+public class SocksInitRequestDecoder extends ReplayingDecoder<State> {
 
     private final List<SocksAuthScheme> authSchemes = new ArrayList<SocksAuthScheme>();
     private SocksProtocolVersion version;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
Patch:
@@ -18,14 +18,15 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksInitResponseDecoder.State;
 
 import java.util.List;
 
 /**
  * Decodes {@link ByteBuf}s into {@link SocksInitResponse}.
  * Before returning SocksResponse decoder removes itself from pipeline.
  */
-public class SocksInitResponseDecoder extends ReplayingDecoder<SocksInitResponseDecoder.State> {
+public class SocksInitResponseDecoder extends ReplayingDecoder<State> {
 
     private SocksProtocolVersion version;
     private SocksAuthScheme authScheme;

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
Patch:
@@ -27,6 +27,7 @@ private SocksCommonTestUtils() {
         //NOOP
     }
 
+    @SuppressWarnings("deprecation")
     public static void writeMessageIntoEmbedder(EmbeddedChannel embedder, SocksMessage msg) {
         ByteBuf buf = Unpooled.buffer();
         msg.encodeAsByteBuf(buf);

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeDecoderTest.java
Patch:
@@ -48,7 +48,7 @@ public void testSingleFrameDecoding() {
         assertNotNull(frame);
         assertEquals(StompCommand.CONNECT, frame.command());
         StompContentSubframe content = channel.readInbound();
-        assertSame(content, LastStompContentSubframe.EMPTY_LAST_CONTENT);
+        assertSame(LastStompContentSubframe.EMPTY_LAST_CONTENT, content);
         Object o = channel.readInbound();
         assertNull(o);
     }
@@ -123,13 +123,13 @@ public void testMultipleFramesDecoding() {
         assertNotNull(frame);
         assertEquals(StompCommand.CONNECT, frame.command());
         StompContentSubframe content = channel.readInbound();
-        assertSame(content, LastStompContentSubframe.EMPTY_LAST_CONTENT);
+        assertSame(LastStompContentSubframe.EMPTY_LAST_CONTENT, content);
 
         StompHeadersSubframe frame2 = channel.readInbound();
         assertNotNull(frame2);
         assertEquals(StompCommand.CONNECTED, frame2.command());
         StompContentSubframe content2 = channel.readInbound();
-        assertSame(content2, LastStompContentSubframe.EMPTY_LAST_CONTENT);
+        assertSame(LastStompContentSubframe.EMPTY_LAST_CONTENT, content2);
         assertNull(channel.readInbound());
     }
 }

File: codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java
Patch:
@@ -45,7 +45,6 @@ private static int index(int hash) {
         return Math.abs(hash % BUCKET_SIZE);
     }
 
-    @SuppressWarnings("unchecked")
     private final HeaderEntry[] entries = new HeaderEntry[BUCKET_SIZE];
     private final HeaderEntry head = new HeaderEntry(this);
     private final boolean ignoreCase;
@@ -71,7 +70,6 @@ protected CharSequence convertName(CharSequence name) {
         return name;
     }
 
-    @SuppressWarnings("unchecked")
     protected CharSequence convertValue(Object value) {
         if (value == null) {
             throw new NullPointerException("value");
@@ -195,7 +193,6 @@ private void add0(TextHeaders headers) {
         }
 
         if (headers instanceof DefaultTextHeaders) {
-            @SuppressWarnings("unchecked")
             DefaultTextHeaders m = (DefaultTextHeaders) headers;
             HeaderEntry e = m.head.after;
             while (e != m.head) {

File: codec/src/main/java/io/netty/handler/codec/base64/Base64.java
Patch:
@@ -286,7 +286,7 @@ private static int decode4to3(
                         (DECODABET[src[srcOffset + 1]] & 0xFF) << 12 |
                         (DECODABET[src[srcOffset + 2]] & 0xFF) <<  6 |
                          DECODABET[src[srcOffset + 3]] & 0xFF;
-            } catch (IndexOutOfBoundsException e) {
+            } catch (IndexOutOfBoundsException ignored) {
                 throw new IllegalArgumentException("not encoded in Base64");
             }
 

File: codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java
Patch:
@@ -157,7 +157,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                     int huffmanSymbolCount = 0;
                     if (bitNumber > 0) {
                         for (int i = 0; i < 16; i++) {
-                            if ((inUse16 & ((1 << 15) >>> i)) != 0) {
+                            if ((inUse16 & 1 << 15 >>> i) != 0) {
                                 for (int j = 0, k = i << 4; j < 16; j++, k++) {
                                     if (readBoolean(in)) {
                                         huffmanSymbolMap[huffmanSymbolCount++] = (byte) k;
@@ -330,7 +330,7 @@ int readBits(ByteBuf in, final int n) {
         }
 
         this.bitCount = bitCount -= n;
-        return (bitBuffer >>> bitCount) & ((1 << n) - 1);
+        return bitBuffer >>> bitCount & (1 << n) - 1;
     }
 
     private boolean readBoolean(ByteBuf in) {

File: codec/src/main/java/io/netty/handler/codec/compression/Crc32c.java
Patch:
@@ -93,7 +93,7 @@ class Crc32c implements Checksum {
             0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
     };
 
-    private static final int LONG_MASK = 0xFFFFFFFF;
+    private static final long LONG_MASK = 0xFFFFFFFFL;
     private static final int BYTE_MASK = 0xFF;
 
     private int crc = ~0;
@@ -121,6 +121,6 @@ public void reset() {
     }
 
     private static int crc32c(int crc, int b) {
-        return (crc >>> 8) ^ CRC_TABLE[(crc ^ (b & BYTE_MASK)) & BYTE_MASK];
+        return crc >>> 8 ^ CRC_TABLE[(crc ^ b & BYTE_MASK) & BYTE_MASK];
     }
 }

File: codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java
Patch:
@@ -27,7 +27,7 @@ class ChannelBufferByteInput implements ByteInput {
 
     private final ByteBuf buffer;
 
-    public ChannelBufferByteInput(ByteBuf buffer) {
+    ChannelBufferByteInput(ByteBuf buffer) {
         this.buffer = buffer;
     }
 

File: codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java
Patch:
@@ -32,7 +32,7 @@ class ChannelBufferByteOutput implements ByteOutput {
     /**
      * Create a new instance which use the given {@link ByteBuf}
      */
-    public ChannelBufferByteOutput(ByteBuf buffer) {
+    ChannelBufferByteOutput(ByteBuf buffer) {
         this.buffer = buffer;
     }
 

File: codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java
Patch:
@@ -32,7 +32,7 @@ class LimitingByteInput implements ByteInput {
     private final long limit;
     private long read;
 
-    public LimitingByteInput(ByteInput input, long limit) {
+    LimitingByteInput(ByteInput input, long limit) {
         if (limit <= 0) {
             throw new IllegalArgumentException("The limit MUST be > 0");
         }

File: codec/src/main/java/io/netty/handler/codec/serialization/ClassLoaderClassResolver.java
Patch:
@@ -27,7 +27,7 @@ class ClassLoaderClassResolver implements ClassResolver {
     public Class<?> resolve(String className) throws ClassNotFoundException {
         try {
             return classLoader.loadClass(className);
-        } catch (ClassNotFoundException e) {
+        } catch (ClassNotFoundException ignored) {
             return Class.forName(className, false, classLoader);
         }
     }

File: codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java
Patch:
@@ -65,7 +65,7 @@ protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, Clas
         Class<?> clazz;
         try {
             clazz = classResolver.resolve(desc.getName());
-        } catch (ClassNotFoundException ex) {
+        } catch (ClassNotFoundException ignored) {
             clazz = super.resolveClass(desc);
         }
 

File: codec/src/main/java/io/netty/handler/codec/serialization/SoftReferenceMap.java
Patch:
@@ -21,7 +21,7 @@
 
 final class SoftReferenceMap<K, V> extends ReferenceMap<K, V> {
 
-    public SoftReferenceMap(Map<K, Reference<V>> delegate) {
+    SoftReferenceMap(Map<K, Reference<V>> delegate) {
         super(delegate);
     }
 

File: codec/src/main/java/io/netty/handler/codec/serialization/WeakReferenceMap.java
Patch:
@@ -21,7 +21,7 @@
 
 final class WeakReferenceMap<K, V> extends ReferenceMap<K, V> {
 
-    public WeakReferenceMap(Map<K, Reference<V>> delegate) {
+    WeakReferenceMap(Map<K, Reference<V>> delegate) {
         super(delegate);
     }
 

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
Patch:
@@ -26,9 +26,6 @@
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
 
-/**
- */
-@SuppressWarnings("ZeroLengthArrayAllocation")
 public class ByteArrayDecoderTest {
 
     private EmbeddedChannel ch;

File: codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java
Patch:
@@ -31,6 +31,7 @@ protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
     }
 
     @Test(expected = DecompressionException.class)
+    @Override
     public void testZLIB_OR_NONE3() throws Exception {
         super.testZLIB_OR_NONE3();
     }

File: codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest2.java
Patch:
@@ -30,6 +30,7 @@ protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
     }
 
     @Test(expected = DecompressionException.class)
+    @Override
     public void testZLIB_OR_NONE3() throws Exception {
         super.testZLIB_OR_NONE3();
     }

File: common/src/main/java/io/netty/util/AbstractReferenceCounted.java
Patch:
@@ -35,7 +35,6 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
         refCntUpdater = updater;
     }
 
-    @SuppressWarnings("FieldMayBeFinal")
     private volatile int refCnt = 1;
 
     @Override

File: common/src/main/java/io/netty/util/DefaultAttributeMap.java
Patch:
@@ -48,7 +48,7 @@ public class DefaultAttributeMap implements AttributeMap {
     @SuppressWarnings("UnusedDeclaration")
     private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings("unchecked")
     @Override
     public <T> Attribute<T> attr(AttributeKey<T> key) {
         if (key == null) {

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -164,7 +164,7 @@ private static final class Link extends AtomicInteger {
         private final WeakReference<Thread> owner;
         private final int id = ID_GENERATOR.getAndIncrement();
 
-        public WeakOrderQueue(Stack<?> stack, Thread thread) {
+        WeakOrderQueue(Stack<?> stack, Thread thread) {
             head = tail = new Link();
             owner = new WeakReference<Thread>(thread);
             synchronized (stack) {
@@ -194,7 +194,7 @@ boolean hasFinalData() {
         }
 
         // transfer as many items as we can from this queue to the stack, returning true if any were transferred
-        @SuppressWarnings({ "unchecked", "rawtypes" })
+        @SuppressWarnings("rawtypes")
         boolean transfer(Stack<?> to) {
 
             Link head = this.head;

File: common/src/main/java/io/netty/util/Version.java
Patch:
@@ -132,7 +132,7 @@ public static Map<String, Version> identify(ClassLoader classLoader) {
     private static long parseIso8601(String value) {
         try {
             return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(value).getTime();
-        } catch (ParseException e) {
+        } catch (ParseException ignored) {
             return 0;
         }
     }

File: common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java
Patch:
@@ -24,7 +24,7 @@ final class DefaultFutureListeners {
     private int progressiveSize; // the number of progressive listeners
 
     @SuppressWarnings("unchecked")
-    public DefaultFutureListeners(
+    DefaultFutureListeners(
             GenericFutureListener<? extends Future<?>> first, GenericFutureListener<? extends Future<?>> second) {
         listeners = new GenericFutureListener[2];
         listeners[0] = first;

File: common/src/main/java/io/netty/util/concurrent/ScheduledFuture.java
Patch:
@@ -18,5 +18,6 @@
 /**
  * The result of an scheduled asynchronous operation.
  */
+@SuppressWarnings("ClassNameSameAsAncestorName")
 public interface ScheduledFuture<V> extends Future<V>, java.util.concurrent.ScheduledFuture<V> {
 }

File: common/src/main/java/io/netty/util/internal/EmptyArrays.java
Patch:
@@ -30,6 +30,7 @@ public final class EmptyArrays {
     public static final short[] EMPTY_SHORTS = new short[0];
     public static final long[] EMPTY_LONGS = new long[0];
     public static final Object[] EMPTY_OBJECTS = new Object[0];
+    public static final Class<?>[] EMPTY_CLASSES = new Class[0];
     public static final String[] EMPTY_STRINGS = new String[0];
     public static final StackTraceElement[] EMPTY_STACK_TRACE = new StackTraceElement[0];
     public static final ByteBuffer[] EMPTY_BYTE_BUFFERS = new ByteBuffer[0];

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -87,8 +87,7 @@ final class PlatformDependent0 {
                 // http://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
                 try {
                     unsafe.getClass().getDeclaredMethod(
-                            "copyMemory",
-                            new Class[] { Object.class, long.class, Object.class, long.class, long.class });
+                            "copyMemory", Object.class, long.class, Object.class, long.class, long.class);
 
                     logger.debug("sun.misc.Unsafe.copyMemory: available");
                 } catch (NoSuchMethodError t) {

File: common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
Patch:
@@ -29,12 +29,12 @@
  */
 public final class SystemPropertyUtil {
 
-    @SuppressWarnings("all")
     private static boolean initializedLogger;
     private static final InternalLogger logger;
     private static boolean loggedException;
 
     static {
+        initializedLogger = false;
         logger = InternalLoggerFactory.getInstance(SystemPropertyUtil.class);
         initializedLogger = true;
     }

File: common/src/main/java/io/netty/util/internal/logging/Log4JLogger.java
Patch:
@@ -72,7 +72,7 @@ private boolean isTraceCapable() {
         try {
             logger.isTraceEnabled();
             return true;
-        } catch (NoSuchMethodError e) {
+        } catch (NoSuchMethodError ignored) {
             return false;
         }
     }

File: common/src/main/java/io/netty/util/internal/logging/Slf4JLoggerFactory.java
Patch:
@@ -54,7 +54,7 @@ public void write(int b) {
             if (LoggerFactory.getILoggerFactory() instanceof NOPLoggerFactory) {
                 throw new NoClassDefFoundError(buf.toString());
             } else {
-                err.print(buf.toString());
+                err.print(buf);
                 err.flush();
             }
         } finally {

File: common/src/test/java/io/netty/util/DefaultAttributeMapTest.java
Patch:
@@ -42,10 +42,10 @@ public void testGetSetString() {
         assertSame(one, map.attr(key));
 
         one.setIfAbsent("Whoohoo");
-        assertSame(one.get(), "Whoohoo");
+        assertSame("Whoohoo", one.get());
 
         one.setIfAbsent("What");
-        assertNotSame(one.get(), "What");
+        assertNotSame("What", one.get());
 
         one.remove();
         assertNull(one.get());
@@ -62,7 +62,7 @@ public void testGetSetInt() {
         assertEquals(one.get(), Integer.valueOf(3653));
 
         one.setIfAbsent(1);
-        assertNotSame(one.get(), 1);
+        assertNotSame(1, one.get());
 
         one.remove();
         assertNull(one.get());

File: common/src/test/java/io/netty/util/RecyclerTest.java
Patch:
@@ -40,14 +40,14 @@ static final class RecyclableObject {
 
         private static final Recycler<RecyclableObject> RECYCLER = new Recycler<RecyclableObject>() {
             @Override
-            protected RecyclableObject newObject(Handle handle) {
+            protected RecyclableObject newObject(Handle<RecyclableObject> handle) {
                 return new RecyclableObject(handle);
             }
         };
 
-        private final Recycler.Handle handle;
+        private final Recycler.Handle<RecyclableObject> handle;
 
-        private RecyclableObject(Recycler.Handle handle) {
+        private RecyclableObject(Recycler.Handle<RecyclableObject> handle) {
             this.handle = handle;
         }
 

File: common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java
Patch:
@@ -61,7 +61,7 @@ public void testAppendStringWithExpand() {
     public void testSubSequence() {
         AppendableCharSequence master = new AppendableCharSequence(26);
         master.append("abcdefghijlkmonpqrstuvwxyz");
-        assertEquals(master.subSequence(0, 10).toString(), "abcdefghij");
+        assertEquals("abcdefghij", master.subSequence(0, 10).toString());
     }
 
     private static void testSimpleAppend0(AppendableCharSequence seq) {

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -24,8 +24,6 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 

File: example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
@@ -27,10 +27,10 @@
  * A simple handler which will simple return a successful Http
  * response for any request.
  */
-public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {
+public class OkResponseHandler extends ChannelInboundHandlerAdapter {
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         final FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         response.headers().set("custom-response-header", "Some value");
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java
Patch:
@@ -26,7 +26,7 @@
 import io.netty.handler.ssl.SslProvider;
 import io.netty.handler.ssl.util.SelfSignedCertificate;
 
-public class HttpStaticFileServer {
+public final class HttpStaticFileServer {
 
     static final boolean SSL = System.getProperty("ssl") != null;
     static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));

File: example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
Patch:
@@ -22,9 +22,9 @@
 import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 
-import static io.netty.handler.codec.http.HttpHeaders.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
@@ -46,10 +46,10 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) msg;
 
-            if (is100ContinueExpected(req)) {
+            if (HttpHeaders.is100ContinueExpected(req)) {
                 ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
             }
-            boolean keepAlive = isKeepAlive(req);
+            boolean keepAlive = HttpHeaders.isKeepAlive(req);
             FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));
             response.headers().set(CONTENT_TYPE, "text/plain");
             response.headers().set(CONTENT_LENGTH, response.content().readableBytes());

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -27,7 +27,7 @@
 public class HttpSnoopClientHandler extends SimpleChannelInboundHandler<HttpObject> {
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
+    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
Patch:
@@ -29,7 +29,7 @@
  * An HTTP server that sends back the content of the received HTTP request
  * in a pretty plaintext form.
  */
-public class HttpSnoopServer {
+public final class HttpSnoopServer {
 
     static final boolean SSL = System.getProperty("ssl") != null;
     static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -32,7 +32,7 @@ public class HttpUploadClientHandler extends SimpleChannelInboundHandler<HttpObj
     private boolean readingChunks;
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
+    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * A HTTP server showing how to use the HTTP multipart package for file uploads and decoding post data.
  */
-public class HttpUploadServer {
+public final class HttpUploadServer {
 
     static final boolean SSL = System.getProperty("ssl") != null;
     static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -75,6 +75,7 @@ public class HttpUploadServerHandler extends SimpleChannelInboundHandler<HttpObj
             new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE); // Disk if size exceed
 
     private HttpPostRequestDecoder decoder;
+
     static {
         DiskFileUpload.deleteOnExitTemporaryFile = true; // should delete file
                                                          // on exit (in normal

File: example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
Patch:
@@ -45,7 +45,7 @@
  *     ./run-example.sh spdy-client
  * </pre>
  */
-public class SpdyClient {
+public final class SpdyClient {
 
     static final boolean SSL = System.getProperty("ssl") != null;
     static final String HOST = System.getProperty("host", "127.0.0.1");

File: example/src/main/java/io/netty/example/telnet/TelnetServer.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Simplistic telnet server.
  */
-public class TelnetServer {
+public final class TelnetServer {
 
     static final boolean SSL = System.getProperty("ssl") != null;
     static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8992" : "8023"));

File: example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java
Patch:
@@ -40,8 +40,8 @@
 public class ByteEchoPeerBase {
 
     protected final int messageSize;
-    protected SocketAddress myAddress;
-    protected SocketAddress peerAddress;
+    protected final SocketAddress myAddress;
+    protected final SocketAddress peerAddress;
 
     public ByteEchoPeerBase(int messageSize, SocketAddress myAddress, SocketAddress peerAddress) {
         this.messageSize = messageSize;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOutboundBuffer.java
Patch:
@@ -61,8 +61,7 @@ protected Object beforeAdd(Object msg) {
         if (msg instanceof ByteBuf) {
             ByteBuf buf = (ByteBuf) msg;
             if (!buf.hasMemoryAddress()) {
-                ByteBuf direct = copyToDirectByteBuf(buf);
-                return direct;
+                return copyToDirectByteBuf(buf);
             }
         }
         return msg;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java
Patch:
@@ -27,10 +27,9 @@
 
 import static io.netty.channel.ChannelOption.*;
 
-public final class EpollSocketChannelConfig extends DefaultChannelConfig
-        implements SocketChannelConfig {
+public final class EpollSocketChannelConfig extends DefaultChannelConfig implements SocketChannelConfig {
 
-    protected final EpollSocketChannel channel;
+    private final EpollSocketChannel channel;
     private volatile boolean allowHalfClosure;
 
     /**

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
Patch:
@@ -39,7 +39,7 @@ final class DefaultRxtxChannelConfig extends DefaultChannelConfig implements Rxt
     private volatile int waitTime;
     private volatile int readTimeout = 1000;
 
-    public DefaultRxtxChannelConfig(RxtxChannel channel) {
+    DefaultRxtxChannelConfig(RxtxChannel channel) {
         super(channel);
     }
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
Patch:
@@ -81,7 +81,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
Patch:
@@ -277,7 +277,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
     public Association association() {
         try {
             return ch.association();
-        } catch (IOException e) {
+        } catch (IOException ignored) {
             return null;
         }
     }
@@ -309,7 +309,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -336,7 +336,7 @@ public Set<InetSocketAddress> allRemoteAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
Patch:
@@ -153,7 +153,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
Patch:
@@ -142,8 +142,7 @@ protected int doReadBytes(final ByteBuf byteBuf) throws Exception {
     @Override
     protected int doWriteBytes(final ByteBuf byteBuf) throws Exception {
         final int expectedWrittenBytes = byteBuf.readableBytes();
-        final int writtenBytes = byteBuf.readBytes(javaChannel(), expectedWrittenBytes);
-        return writtenBytes;
+        return byteBuf.readBytes(javaChannel(), expectedWrittenBytes);
     }
 
     @Override

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
Patch:
@@ -28,6 +28,6 @@ public class NioUdtByteAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtByteAcceptorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtByteAcceptorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.udt.nio.NioUdtByteConnectorChannel;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
 
@@ -28,6 +28,6 @@ public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtByteConnectorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtByteConnectorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
Patch:
@@ -28,6 +28,6 @@ public class NioUdtMessageAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtMessageAcceptorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtMessageAcceptorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
Patch:
@@ -28,6 +28,6 @@ public class NioUdtMessageConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtMessageConnectorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtMessageConnectorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/util/CaliperMeasure.java
Patch:
@@ -139,6 +139,7 @@ private static double filter(final double value) {
     /**
      * Perform measurement; convert from metrics into caliper.
      */
+    @SuppressWarnings("FloatingPointEquality")
     public void mark() {
         final double rateValue = filter(rate.oneMinuteRate());
         final double timeValue = filter(time.mean());
@@ -172,8 +173,7 @@ public Map<String, String> variables() {
 
     private static MeasurementSet measurementSet(final Map<Long, Measurement> map) {
         final Measurement[] array = map.values().toArray(new Measurement[map.size()]);
-        final MeasurementSet set = new MeasurementSet(array);
-        return set;
+        return new MeasurementSet(array);
     }
 
     /**

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -217,7 +217,6 @@ private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapte
         private final Entry<ChannelOption<?>, Object>[] childOptions;
         private final Entry<AttributeKey<?>, Object>[] childAttrs;
 
-        @SuppressWarnings("unchecked")
         ServerBootstrapAcceptor(
                 EventLoopGroup childGroup, ChannelHandler childHandler,
                 Entry<ChannelOption<?>, Object>[] childOptions, Entry<AttributeKey<?>, Object>[] childAttrs) {

File: transport/src/main/java/io/netty/channel/ChannelHandlerAppender.java
Patch:
@@ -132,7 +132,6 @@ protected final ChannelHandlerAppender add(ChannelHandler handler) {
      *
      * @throws IllegalStateException if {@link ChannelHandlerAppender} has been added to the pipeline already
      */
-    @SuppressWarnings("unchecked")
     protected final ChannelHandlerAppender add(Iterable<? extends ChannelHandler> handlers) {
         if (handlers == null) {
             throw new NullPointerException("handlers");

File: transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
Patch:
@@ -55,7 +55,6 @@ protected final void init(I inboundHandler, O outboundHandler) {
         this.outboundHandler = outboundHandler;
     }
 
-    @SuppressWarnings("InstanceofIncompatibleInterface")
     private void validate(I inboundHandler, O outboundHandler) {
         if (this.inboundHandler != null) {
             throw new IllegalStateException(

File: transport/src/main/java/io/netty/channel/FailedChannelFuture.java
Patch:
@@ -33,7 +33,7 @@ final class FailedChannelFuture extends CompleteChannelFuture {
      * @param channel the {@link Channel} associated with this future
      * @param cause   the cause of failure
      */
-    public FailedChannelFuture(Channel channel, EventExecutor executor, Throwable cause) {
+    FailedChannelFuture(Channel channel, EventExecutor executor, Throwable cause) {
         super(channel, executor);
         if (cause == null) {
             throw new NullPointerException("cause");

File: transport/src/main/java/io/netty/channel/SucceededChannelFuture.java
Patch:
@@ -29,7 +29,7 @@ final class SucceededChannelFuture extends CompleteChannelFuture {
      *
      * @param channel the {@link Channel} associated with this future
      */
-    public SucceededChannelFuture(Channel channel, EventExecutor executor) {
+    SucceededChannelFuture(Channel channel, EventExecutor executor) {
         super(channel, executor);
     }
 

File: transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java
Patch:
@@ -51,7 +51,7 @@ private ThreadLocalPooledDirectByteBuf() {
         // utility
     }
 
-    private static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf {
+    static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf {
 
         private static final Recycler<ThreadLocalUnsafeDirectByteBuf> RECYCLER =
                 new Recycler<ThreadLocalUnsafeDirectByteBuf>() {
@@ -85,7 +85,7 @@ protected void deallocate() {
         }
     }
 
-    private static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf {
+    static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf {
 
         private static final Recycler<ThreadLocalDirectByteBuf> RECYCLER = new Recycler<ThreadLocalDirectByteBuf>() {
             @Override

File: transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
Patch:
@@ -34,7 +34,6 @@ public ThreadPerChannelEventLoop(ThreadPerChannelEventLoopGroup parent) {
     public ChannelFuture register(Channel channel, ChannelPromise promise) {
         return super.register(channel, promise).addListener(new ChannelFutureListener() {
             @Override
-            @SuppressWarnings("unchecked")
             public void operationComplete(ChannelFuture future) throws Exception {
                 if (future.isSuccess()) {
                     ch = future.channel();

File: transport/src/main/java/io/netty/channel/VoidChannelPromise.java
Patch:
@@ -31,7 +31,7 @@ final class VoidChannelPromise extends AbstractFuture<Void> implements ChannelPr
      *
      * @param channel the {@link Channel} associated with this future
      */
-    public VoidChannelPromise(Channel channel, boolean fireException) {
+    VoidChannelPromise(Channel channel, boolean fireException) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }

File: transport/src/main/java/io/netty/channel/group/ChannelGroup.java
Patch:
@@ -228,6 +228,7 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
      * @return the {@link ChannelGroupFuture} instance that notifies when
      *         the operation is done for all channels
      */
+    @Deprecated
     ChannelGroupFuture deregister();
 
     /**
@@ -239,5 +240,6 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
      * @return the {@link ChannelGroupFuture} instance that notifies when
      *         the operation is done for all channels
      */
+    @Deprecated
     ChannelGroupFuture deregister(ChannelMatcher matcher);
 }

File: transport/src/main/java/io/netty/channel/group/ChannelMatchers.java
Patch:
@@ -119,8 +119,8 @@ private static final class CompositeMatcher implements ChannelMatcher {
 
         @Override
         public boolean matches(Channel channel) {
-            for (int i = 0; i < matchers.length; i++) {
-                if (!matchers[i].matches(channel)) {
+            for (ChannelMatcher m: matchers) {
+                if (!m.matches(channel)) {
                     return false;
                 }
             }

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -80,7 +80,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     /**
      * Creates a new instance.
      */
-    public DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> futures,  EventExecutor executor) {
+    DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> futures,  EventExecutor executor) {
         super(executor);
         if (group == null) {
             throw new NullPointerException("group");
@@ -241,7 +241,7 @@ private static final class DefaultEntry<K, V> implements Map.Entry<K, V> {
         private final K key;
         private final V value;
 
-        public DefaultEntry(K key, V value) {
+        DefaultEntry(K key, V value) {
             this.key = key;
             this.value = value;
         }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -526,7 +526,7 @@ private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
 
                 unsafe.finishConnect();
             }
-        } catch (CancelledKeyException e) {
+        } catch (CancelledKeyException ignored) {
             unsafe.close(unsafe.voidPromise());
         }
     }
@@ -644,7 +644,7 @@ private void select(boolean oldWakenUp) throws IOException {
                 }
 
                 long time = System.nanoTime();
-                if ((time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis)) >= currentTimeNanos) {
+                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {
                     // timeoutMillis elapsed without anything selected.
                     selectCnt = 1;
                 } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&

File: transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
Patch:
@@ -29,6 +29,7 @@ public final class ChannelInputShutdownEvent {
     /**
      * Instance to use
      */
+    @SuppressWarnings("InstantiationOfUtilityClass")
     public static final ChannelInputShutdownEvent INSTANCE = new ChannelInputShutdownEvent();
 
     private ChannelInputShutdownEvent() { }

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -153,10 +153,11 @@ public DatagramChannelConfig config() {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     public boolean isActive() {
         DatagramChannel ch = javaChannel();
         return ch.isOpen() && (
-                (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
+                config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()
                 || ch.socket().isBound());
     }
 
@@ -291,8 +292,7 @@ protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Ex
             writtenBytes = javaChannel().write(nioData);
         }
 
-        boolean done =  writtenBytes > 0;
-        return done;
+        return writtenBytes > 0;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBuffer.java
Patch:
@@ -54,7 +54,7 @@ public static NioSocketChannelOutboundBuffer newInstance(AbstractChannel channel
         return buffer;
     }
 
-    private NioSocketChannelOutboundBuffer(Recycler.Handle<? extends NioSocketChannelOutboundBuffer> handle) {
+    private NioSocketChannelOutboundBuffer(Recycler.Handle<NioSocketChannelOutboundBuffer> handle) {
         super(handle);
         nioBuffers = new ByteBuffer[INITIAL_CAPACITY];
     }

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -125,9 +125,10 @@ public boolean isOpen() {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     public boolean isActive() {
         return isOpen()
-            && ((config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
+            && (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()
                  || socket.isBound());
     }
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -136,7 +136,7 @@ protected int doReadBytes(ByteBuf buf) throws Exception {
         }
         try {
             return super.doReadBytes(buf);
-        } catch (SocketTimeoutException e) {
+        } catch (SocketTimeoutException ignored) {
             return 0;
         }
     }

File: transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
Patch:
@@ -92,7 +92,7 @@ private static void runTest(ThreadPerChannelEventLoopGroup loopGroup) throws Int
 
     private static class TestEventExecutor extends SingleThreadEventExecutor {
 
-        public TestEventExecutor() {
+        TestEventExecutor() {
             super(null, new DefaultThreadFactory("test"), false);
         }
 

File: transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
Patch:
@@ -250,8 +250,8 @@ protected void initChannel(Channel ch) throws Exception {
 
     @Test
     public void testReRegister() {
-        EventLoopGroup group1 = new LocalEventLoopGroup();
-        EventLoopGroup group2 = new LocalEventLoopGroup();
+        EventLoopGroup group1 = new DefaultEventLoopGroup();
+        EventLoopGroup group2 = new DefaultEventLoopGroup();
         LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);
         Bootstrap cb = new Bootstrap();
         ServerBootstrap sb = new ServerBootstrap();

File: buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
Patch:
@@ -565,6 +565,7 @@ public ByteBuf copy(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
         return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
@@ -578,6 +579,7 @@ private ByteBuffer internalNioBuffer() {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
+        checkIndex(index, length);
         return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();
     }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
Patch:
@@ -277,6 +277,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
         return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
Patch:
@@ -476,6 +476,7 @@ public ByteBuf copy(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
         return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
@@ -489,6 +490,7 @@ private ByteBuffer internalNioBuffer() {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
+        checkIndex(index, length);
         return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();
     }
 

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -190,6 +190,7 @@
  *       ByteBuf frame = buf.readBytes(length);
  *       <strong>checkpoint(MyDecoderState.READ_LENGTH);</strong>
  *       out.add(frame);
+ *       break;
  *     default:
  *       throw new Error("Shouldn't reach here.");
  *     }

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -46,7 +46,7 @@ public abstract class AbstractNioChannel extends AbstractChannel {
 
     private final SelectableChannel ch;
     protected final int readInterestOp;
-    private volatile SelectionKey selectionKey;
+    volatile SelectionKey selectionKey;
     private volatile boolean inputShutdown;
     private volatile boolean readPending;
 

File: codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java
Patch:
@@ -229,9 +229,11 @@ public void testDecompressionOfBatchedFlowOfData() throws Exception {
         ByteBuf msg;
         while ((msg = channel.readInbound()) != null) {
             uncompressed.writeBytes(msg);
+            msg.release();
         }
         final byte[] result = new byte[uncompressed.readableBytes()];
         uncompressed.readBytes(result);
+        uncompressed.release();
 
         assertArrayEquals(BYTES_LARGE, result);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
Patch:
@@ -115,7 +115,7 @@ public FullHttpRequest setUri(String uri) {
     @Override
     public FullHttpRequest copy() {
         DefaultFullHttpRequest copy = new DefaultFullHttpRequest(
-                getProtocolVersion(), getMethod(), getUri(), content().copy(), validateHeaders);
+                protocolVersion(), method(), uri(), content().copy(), validateHeaders);
         copy.headers().set(headers());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;
@@ -124,7 +124,7 @@ public FullHttpRequest copy() {
     @Override
     public FullHttpRequest duplicate() {
         DefaultFullHttpRequest duplicate = new DefaultFullHttpRequest(
-                getProtocolVersion(), getMethod(), getUri(), content().duplicate(), validateHeaders);
+                protocolVersion(), method(), uri(), content().duplicate(), validateHeaders);
         duplicate.headers().set(headers());
         duplicate.trailingHeaders().set(trailingHeaders());
         return duplicate;

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
Patch:
@@ -111,15 +111,15 @@ public FullHttpResponse setStatus(HttpResponseStatus status) {
     @Override
     public FullHttpResponse copy() {
         DefaultFullHttpResponse copy = new DefaultFullHttpResponse(
-                getProtocolVersion(), getStatus(), content().copy(), validateHeaders);
+                protocolVersion(), status(), content().copy(), validateHeaders);
         copy.headers().set(headers());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;
     }
 
     @Override
     public FullHttpResponse duplicate() {
-        DefaultFullHttpResponse duplicate = new DefaultFullHttpResponse(getProtocolVersion(), getStatus(),
+        DefaultFullHttpResponse duplicate = new DefaultFullHttpResponse(protocolVersion(), status(),
                 content().duplicate(), validateHeaders);
         duplicate.headers().set(headers());
         duplicate.trailingHeaders().set(trailingHeaders());

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java
Patch:
@@ -31,6 +31,7 @@ public DecoderResult decoderResult() {
     }
 
     @Override
+    @Deprecated
     public DecoderResult getDecoderResult() {
         return decoderResult();
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -104,7 +104,7 @@ private final class Encoder extends HttpRequestEncoder {
         protected void encode(
                 ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
             if (msg instanceof HttpRequest && !done) {
-                queue.offer(((HttpRequest) msg).getMethod());
+                queue.offer(((HttpRequest) msg).method());
             }
 
             super.encode(ctx, msg, out);
@@ -160,7 +160,7 @@ private void decrement(Object msg) {
 
         @Override
         protected boolean isContentAlwaysEmpty(HttpMessage msg) {
-            final int statusCode = ((HttpResponse) msg).getStatus().code();
+            final int statusCode = ((HttpResponse) msg).status().code();
             if (statusCode == 100) {
                 // 100-continue response should be excluded from paired comparison.
                 return true;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -51,7 +51,7 @@ public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObj
 
     @Override
     protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {
-        if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().code() == 100) {
+        if (msg instanceof HttpResponse && ((HttpResponse) msg).status().code() == 100) {
 
             if (!(msg instanceof LastHttpContent)) {
                 continueResponse = true;
@@ -184,8 +184,8 @@ private void decodeContent(HttpContent c, List<Object> out) {
      * @param contentEncoding the value of the {@code "Content-Encoding"} header
      * @return the expected content encoding of the new content
      */
-    @SuppressWarnings("unused")
-    protected String getTargetContentEncoding(String contentEncoding) throws Exception {
+    protected String getTargetContentEncoding(
+            @SuppressWarnings("UnusedParameters") String contentEncoding) throws Exception {
         return HttpHeaders.Values.IDENTITY;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -89,7 +89,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
 
                 final HttpResponse res = (HttpResponse) msg;
 
-                if (res.getStatus().code() == 100) {
+                if (res.status().code() == 100) {
                     if (isFull) {
                         out.add(ReferenceCountUtil.retain(res));
                     } else {
@@ -142,7 +142,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                 // Output the rewritten response.
                 if (isFull) {
                     // Convert full message into unfull one.
-                    HttpResponse newRes = new DefaultHttpResponse(res.getProtocolVersion(), res.getStatus());
+                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());
                     newRes.headers().set(res.headers());
                     out.add(newRes);
                     // Fall through to encode the content of the full response.

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -121,12 +121,12 @@ protected FullHttpMessage beginAggregation(HttpMessage start, ByteBuf content) t
         FullHttpMessage ret;
         if (start instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) start;
-            ret = new DefaultFullHttpRequest(req.getProtocolVersion(),
-                    req.getMethod(), req.getUri(), content);
+            ret = new DefaultFullHttpRequest(req.protocolVersion(),
+                    req.method(), req.uri(), content);
         } else  if (start instanceof HttpResponse) {
             HttpResponse res = (HttpResponse) start;
             ret = new DefaultFullHttpResponse(
-                    res.getProtocolVersion(), res.getStatus(), content);
+                    res.protocolVersion(), res.status(), content);
         } else {
             throw new Error();
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -410,7 +410,7 @@ protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
     protected boolean isContentAlwaysEmpty(HttpMessage msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse res = (HttpResponse) msg;
-            int code = res.getStatus().code();
+            int code = res.status().code();
 
             // Correctly handle return codes of 1xx.
             //
@@ -444,7 +444,7 @@ private void resetNow() {
         contentLength = Long.MIN_VALUE;
         if (!isDecodingRequest()) {
             HttpResponse res = (HttpResponse) message;
-            if (res != null && res.getStatus().code() == 101) {
+            if (res != null && res.status().code() == 101) {
                 checkpoint(State.UPGRADED);
                 return;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -35,12 +35,12 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {
-        request.getMethod().encode(buf);
+        request.method().encode(buf);
         buf.writeByte(SP);
 
         // Add / as absolute path if no is present.
         // See http://tools.ietf.org/html/rfc2616#section-5.1.2
-        String uri = request.getUri();
+        String uri = request.uri();
 
         if (uri.length() == 0) {
             uri += SLASH;
@@ -57,7 +57,7 @@ protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Except
         buf.writeBytes(uri.getBytes(CharsetUtil.UTF_8));
 
         buf.writeByte(SP);
-        request.getProtocolVersion().encode(buf);
+        request.protocolVersion().encode(buf);
         buf.writeBytes(CRLF);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
Patch:
@@ -33,9 +33,9 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpResponse response) throws Exception {
-        response.getProtocolVersion().encode(buf);
+        response.protocolVersion().encode(buf);
         buf.writeByte(SP);
-        response.getStatus().encode(buf);
+        response.status().encode(buf);
         buf.writeBytes(CRLF);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
Patch:
@@ -55,6 +55,7 @@ public DecoderResult decoderResult() {
         }
 
         @Override
+        @Deprecated
         public DecoderResult getDecoderResult() {
             return decoderResult();
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -301,9 +301,7 @@ public static String decodeComponent(final String s) {
      * @throws IllegalArgumentException if the string contains a malformed
      * escape sequence.
      */
-    @SuppressWarnings("fallthrough")
-    public static String decodeComponent(final String s,
-                                         final Charset charset) {
+    public static String decodeComponent(final String s, final Charset charset) {
         if (s == null) {
             return "";
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -114,7 +114,7 @@ private static String encodeComponent(String s, Charset charset) {
         // TODO: Optimize me.
         try {
             return URLEncoder.encode(s, charset.name()).replace("+", "%20");
-        } catch (UnsupportedEncodingException e) {
+        } catch (UnsupportedEncodingException ignored) {
             throw new UnsupportedCharsetException(charset.name());
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
Patch:
@@ -64,7 +64,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) throw
     }
 
     private void handlePreflight(final ChannelHandlerContext ctx, final HttpRequest request) {
-        final HttpResponse response = new DefaultFullHttpResponse(request.getProtocolVersion(), OK);
+        final HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), OK);
         if (setOrigin(response)) {
             setAllowMethods(response);
             setAllowHeaders(response);
@@ -153,7 +153,7 @@ private void setAllowCredentials(final HttpResponse response) {
 
     private static boolean isPreflightRequest(final HttpRequest request) {
         final HttpHeaders headers = request.headers();
-        return request.getMethod().equals(OPTIONS) &&
+        return request.method().equals(OPTIONS) &&
                 headers.contains(ORIGIN) &&
                 headers.contains(ACCESS_CONTROL_REQUEST_METHOD);
     }
@@ -197,7 +197,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cau
     }
 
     private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {
-        ctx.writeAndFlush(new DefaultFullHttpResponse(request.getProtocolVersion(), FORBIDDEN))
+        ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN))
                 .addListener(ChannelFutureListener.CLOSE);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java
Patch:
@@ -32,7 +32,6 @@ public int compare(String o1, String o2) {
         return o1.compareToIgnoreCase(o2);
     }
 
-    @SuppressWarnings("MethodMayBeStatic")
     private Object readResolve() {
         return INSTANCE;
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -318,7 +318,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
                                 // Check text for UTF8 correctness
                                 if (frameOpcode == OPCODE_TEXT ||
-                                        (utf8Validator != null && utf8Validator.isChecking())) {
+                                        utf8Validator != null && utf8Validator.isChecking()) {
                                     // Check UTF-8 correctness for this payload
                                     checkUTF8String(ctx, payloadBuffer);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -192,8 +192,8 @@ protected FullHttpRequest newHandshakeRequest() {
     protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = new HttpResponseStatus(101, "WebSocket Protocol Handshake");
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         HttpHeaders headers = response.headers();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -169,8 +169,8 @@ protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         String upgrade = headers.get(Names.UPGRADE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -170,8 +170,8 @@ protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         String upgrade = headers.get(Names.UPGRADE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -180,8 +180,8 @@ protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         String upgrade = headers.get(Names.UPGRADE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
Patch:
@@ -91,6 +91,6 @@ public static WebSocketClientHandshaker newHandshaker(
                     webSocketURL, V00, subprotocol, customHeaders, maxFramePayloadLength);
         }
 
-        throw new WebSocketHandshakeException("Protocol version " + version.toString() + " not supported.");
+        throw new WebSocketHandshakeException("Protocol version " + version + " not supported.");
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
Patch:
@@ -24,7 +24,7 @@
 class WebSocketClientProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {
     private final WebSocketClientHandshaker handshaker;
 
-    public WebSocketClientProtocolHandshakeHandler(WebSocketClientHandshaker handshaker) {
+    WebSocketClientProtocolHandshakeHandler(WebSocketClientHandshaker handshaker) {
         this.handshaker = handshaker;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -85,7 +85,7 @@ public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;
-        this.maxFramePayloadLength = maxFrameSize;
+        maxFramePayloadLength = maxFrameSize;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -47,14 +47,14 @@ class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapt
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;
-        this.maxFramePayloadSize = maxFrameSize;
+        maxFramePayloadSize = maxFrameSize;
     }
 
     @Override
     public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
         FullHttpRequest req = (FullHttpRequest) msg;
         try {
-            if (req.getMethod() != GET) {
+            if (req.method() != GET) {
                 sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
                 return;
             }
@@ -89,7 +89,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
     private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpResponse res) {
         ChannelFuture f = ctx.channel().writeAndFlush(res);
-        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
+        if (!isKeepAlive(req) || res.status().code() != 200) {
             f.addListener(ChannelFutureListener.CLOSE);
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
Patch:
@@ -39,11 +39,11 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request)
             throws Exception {
-        HttpHeaders.encodeAscii(request.getMethod().toString(), buf);
+        HttpHeaders.encodeAscii(request.method().toString(), buf);
         buf.writeByte(SP);
-        buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));
+        buf.writeBytes(request.uri().getBytes(CharsetUtil.UTF_8));
         buf.writeByte(SP);
-        HttpHeaders.encodeAscii(request.getProtocolVersion().toString(), buf);
+        HttpHeaders.encodeAscii(request.protocolVersion().toString(), buf);
         buf.writeBytes(CRLF);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
Patch:
@@ -39,11 +39,11 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpResponse response)
             throws Exception {
-        HttpHeaders.encodeAscii(response.getProtocolVersion().toString(), buf);
+        HttpHeaders.encodeAscii(response.protocolVersion().toString(), buf);
         buf.writeByte(SP);
-        buf.writeBytes(String.valueOf(response.getStatus().code()).getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(String.valueOf(response.status().code()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
-        HttpHeaders.encodeAscii(String.valueOf(response.getStatus().reasonPhrase()), buf);
+        HttpHeaders.encodeAscii(String.valueOf(response.status().reasonPhrase()), buf);
         buf.writeBytes(CRLF);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
Patch:
@@ -80,14 +80,14 @@ public ByteBuf content() {
 
     @Override
     public SpdyDataFrame copy() {
-        SpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().copy());
+        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content().copy());
         frame.setLast(isLast());
         return frame;
     }
 
     @Override
     public SpdyDataFrame duplicate() {
-        SpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().duplicate());
+        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content().duplicate());
         frame.setLast(isLast());
         return frame;
     }
@@ -140,7 +140,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Size = ");
         if (refCnt() == 0) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
Patch:
@@ -86,7 +86,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
Patch:
@@ -59,7 +59,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -97,7 +97,7 @@ public ByteBuf encodeRstStreamFrame(ByteBufAllocator allocator, int streamId, in
     }
 
     public ByteBuf encodeSettingsFrame(ByteBufAllocator allocator, SpdySettingsFrame spdySettingsFrame) {
-        Set<Integer> ids = spdySettingsFrame.getIds();
+        Set<Integer> ids = spdySettingsFrame.ids();
         int numSettings = ids.size();
 
         byte flags = spdySettingsFrame.clearPreviouslyPersistedSettings() ?

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java
Patch:
@@ -51,7 +51,7 @@ public SpdyHeaderBlockRawDecoder(SpdyVersion spdyVersion, int maxHeaderSize) {
             throw new NullPointerException("spdyVersion");
         }
         this.maxHeaderSize = maxHeaderSize;
-        this.state = State.READ_NUM_HEADERS;
+        state = State.READ_NUM_HEADERS;
     }
 
     private static int readLengthField(ByteBuf buffer) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java
Patch:
@@ -79,14 +79,14 @@ private int decompress(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Ex
             if (numBytes == 0 && decompressor.needsDictionary()) {
                 try {
                     decompressor.setDictionary(SPDY_DICT);
-                } catch (IllegalArgumentException e) {
+                } catch (IllegalArgumentException ignored) {
                     throw INVALID_HEADER_BLOCK;
                 }
                 numBytes = decompressor.inflate(out, off, decompressed.writableBytes());
             }
             if (frame != null) {
                 decompressed.writerIndex(decompressed.writerIndex() + numBytes);
-                super.decodeHeaderBlock(decompressed, frame);
+                decodeHeaderBlock(decompressed, frame);
                 decompressed.discardReadBytes();
             }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -61,7 +61,7 @@ protected void decode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
                 ids.add(HttpHeaders.getIntHeader((HttpMessage) msg, Names.STREAM_ID));
             }
         } else if (msg instanceof SpdyRstStreamFrame) {
-            ids.remove(((SpdyRstStreamFrame) msg).getStreamId());
+            ids.remove(((SpdyRstStreamFrame) msg).streamId());
         }
 
         out.add(ReferenceCountUtil.retain(msg));

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
Patch:
@@ -37,7 +37,7 @@ final class SpdySession {
     private final AtomicInteger sendWindowSize;
     private final AtomicInteger receiveWindowSize;
 
-    public SpdySession(int sendWindowSize, int receiveWindowSize) {
+    SpdySession(int sendWindowSize, int receiveWindowSize) {
         this.sendWindowSize = new AtomicInteger(sendWindowSize);
         this.receiveWindowSize = new AtomicInteger(receiveWindowSize);
     }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyVersion.java
Patch:
@@ -21,7 +21,7 @@ public enum SpdyVersion {
     private final int version;
     private final int minorVersion;
 
-    private SpdyVersion(int version, int minorVersion) {
+    SpdyVersion(int version, int minorVersion) {
         this.version = version;
         this.minorVersion = minorVersion;
     }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
Patch:
@@ -53,7 +53,7 @@ public void testRequestWithBadHeader() throws Exception {
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
         assertEquals("Good Value", req.headers().get("Good_Name"));
-        assertEquals("/maybe-something", req.getUri());
+        assertEquals("/maybe-something", req.uri());
         ensureInboundTrafficDiscarded(ch);
     }
 
@@ -79,7 +79,7 @@ public void testResponseWithBadHeader() throws Exception {
         DecoderResult dr = res.decoderResult();
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
-        assertEquals("Maybe OK", res.getStatus().reasonPhrase());
+        assertEquals("Maybe OK", res.status().reasonPhrase());
         assertEquals("Good Value", res.headers().get("Good_Name"));
         ensureInboundTrafficDiscarded(ch);
     }

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
Patch:
@@ -371,7 +371,7 @@ public void testReservedSpdySynStreamFrameBits() throws Exception {
         encodeControlFrameHeader(buf, type, flags, length);
         buf.writeInt(streamId | 0x80000000); // should ignore reserved bit
         buf.writeInt(associatedToStreamId | 0x80000000); // should ignore reserved bit
-        buf.writeByte((priority << 5) | 0x1F); // should ignore reserved bits
+        buf.writeByte(priority << 5 | 0x1F); // should ignore reserved bits
         buf.writeByte(0xFF); // should ignore reserved bits
 
         delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -117,12 +117,12 @@ public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) thr
             return;
         }
 
-        if (request.getMethod() != GET) {
+        if (request.method() != GET) {
             sendError(ctx, METHOD_NOT_ALLOWED);
             return;
         }
 
-        final String uri = request.getUri();
+        final String uri = request.uri();
         final String path = sanitizeUri(uri);
         if (path == null) {
             sendError(ctx, FORBIDDEN);

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -31,8 +31,8 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            System.err.println("STATUS: " + response.getStatus());
-            System.err.println("VERSION: " + response.getProtocolVersion());
+            System.err.println("STATUS: " + response.status());
+            System.err.println("VERSION: " + response.protocolVersion());
             System.err.println();
 
             if (!response.headers().isEmpty()) {

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -68,9 +68,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
             buf.append("WELCOME TO THE WILD WILD WEB SERVER\r\n");
             buf.append("===================================\r\n");
 
-            buf.append("VERSION: ").append(request.getProtocolVersion()).append("\r\n");
+            buf.append("VERSION: ").append(request.protocolVersion()).append("\r\n");
             buf.append("HOSTNAME: ").append(getHost(request, "unknown")).append("\r\n");
-            buf.append("REQUEST_URI: ").append(request.getUri()).append("\r\n\r\n");
+            buf.append("REQUEST_URI: ").append(request.uri()).append("\r\n\r\n");
 
             HttpHeaders headers = request.headers();
             if (!headers.isEmpty()) {
@@ -82,7 +82,7 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
                 buf.append("\r\n");
             }
 
-            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.getUri());
+            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.uri());
             Map<String, List<String>> params = queryStringDecoder.parameters();
             if (!params.isEmpty()) {
                 for (Entry<String, List<String>> p: params.entrySet()) {

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -36,8 +36,8 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            System.err.println("STATUS: " + response.getStatus());
-            System.err.println("VERSION: " + response.getProtocolVersion());
+            System.err.println("STATUS: " + response.status());
+            System.err.println("VERSION: " + response.protocolVersion());
 
             if (!response.headers().isEmpty()) {
                 for (String name : response.headers().names()) {
@@ -47,7 +47,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 }
             }
 
-            if (response.getStatus().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
+            if (response.status().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
                 readingChunks = true;
                 System.err.println("CHUNKED CONTENT {");
             } else {

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -91,7 +91,7 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
         if (msg instanceof FullHttpResponse) {
             FullHttpResponse response = (FullHttpResponse) msg;
             throw new IllegalStateException(
-                    "Unexpected FullHttpResponse (getStatus=" + response.getStatus() +
+                    "Unexpected FullHttpResponse (getStatus=" + response.status() +
                             ", content=" + response.content().toString(CharsetUtil.UTF_8) + ')');
         }
 

File: example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
Patch:
@@ -42,8 +42,8 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            System.out.println("STATUS: " + response.getStatus());
-            System.out.println("VERSION: " + response.getProtocolVersion());
+            System.out.println("STATUS: " + response.status());
+            System.out.println("VERSION: " + response.protocolVersion());
             System.out.println();
 
             if (!response.headers().isEmpty()) {

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -314,7 +314,7 @@ final ChannelFuture initAndRegister() {
 
         // If we are here and the promise is not failed, it's one of the following cases:
         // 1) If we attempted registration from the event loop, the registration has been completed at this point.
-        //    i.e. It's safe to attempt bind() or connect() now beause the channel has been registered.
+        //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
         // 2) If we attempted registration from the other thread, the registration request has been successfully
         //    added to the event loop's task queue for later execution.
         //    i.e. It's safe to attempt bind() or connect() now:

File: common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java
Patch:
@@ -149,7 +149,7 @@ public E poll() {
         lazySetHeadRef(next);
 
         // Break the linkage between the old head and the new head.
-        oldHead.setNext(null);
+        oldHead.unlink();
 
         return next.clearMaybe();
     }

File: codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java
Patch:
@@ -186,9 +186,11 @@ private static void testDecompression(final byte[] data) throws Exception {
             ByteBuf msg;
             while ((msg = channel.readInbound()) != null) {
                 uncompressed.writeBytes(msg);
+                msg.release();
             }
             final byte[] result = new byte[uncompressed.readableBytes()];
             uncompressed.readBytes(result);
+            uncompressed.release();
 
             assertArrayEquals(data, result);
         }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
Patch:
@@ -45,7 +45,7 @@ public SocksCmdRequestDecoder() {
     protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksProtocolVersion.fromByte(byteBuf.readByte());
+                version = SocksProtocolVersion.valueOf(byteBuf.readByte());
                 if (version != SocksProtocolVersion.SOCKS5) {
                     break;
                 }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java
Patch:
@@ -55,7 +55,8 @@ public SocksProtocolVersion protocolVersion() {
     }
 
     /**
-     * Encode socks message into its byte representation and write it into byteBuf
+     * @deprecated Do not use; this method was intended for an internal use only.
      */
+    @Deprecated
     public abstract void encodeAsByteBuf(ByteBuf byteBuf);
 }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java
Patch:
@@ -29,6 +29,7 @@
 @ChannelHandler.Sharable
 public class SocksMessageEncoder extends MessageToByteEncoder<SocksMessage> {
     @Override
+    @SuppressWarnings("deprecation")
     protected void encode(ChannelHandlerContext ctx, SocksMessage msg, ByteBuf out) throws Exception {
         msg.encodeAsByteBuf(out);
     }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java
Patch:
@@ -200,8 +200,8 @@ private MemcacheContent invalidChunk(Exception cause) {
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         super.channelInactive(ctx);
 
-        if (currentMessage != null && currentMessage.extras() != null) {
-            currentMessage.extras().release();
+        if (currentMessage != null) {
+            currentMessage.release();
         }
 
         resetDecoder();

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
Patch:
@@ -29,7 +29,7 @@ protected AbstractMemcacheObject() {
     }
 
     @Override
-    public DecoderResult getDecoderResult() {
+    public DecoderResult decoderResult() {
         return decoderResult;
     }
 
@@ -41,5 +41,4 @@ public void setDecoderResult(DecoderResult result) {
 
         decoderResult = result;
     }
-
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java
Patch:
@@ -92,6 +92,6 @@ public boolean release(int decrement) {
     @Override
     public String toString() {
         return StringUtil.simpleClassName(this) +
-               "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';
+               "(data: " + content() + ", decoderResult: " + decoderResult() + ')';
     }
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java
Patch:
@@ -66,7 +66,7 @@ public ByteBuf content() {
         }
 
         @Override
-        public DecoderResult getDecoderResult() {
+        public DecoderResult decoderResult() {
             return DecoderResult.SUCCESS;
         }
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
Patch:
@@ -37,8 +37,8 @@ protected ByteBuf encodeMessage(ChannelHandlerContext ctx, M msg) {
         ByteBuf buf = ctx.alloc().buffer(DEFAULT_BUFFER_SIZE);
 
         encodeHeader(buf, msg);
-        encodeExtras(buf, msg.getExtras());
-        encodeKey(buf, msg.getKey());
+        encodeExtras(buf, msg.extras());
+        encodeKey(buf, msg.key());
 
         return buf;
     }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
Patch:
@@ -25,7 +25,7 @@ public interface BinaryMemcacheRequest extends BinaryMemcacheMessage {
      *
      * @return the reserved field value.
      */
-    short getReserved();
+    short reserved();
 
     /**
      * Sets the reserved field value.

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
Patch:
@@ -43,7 +43,7 @@ protected BinaryMemcacheRequest decodeHeader(ByteBuf in) {
         header.setReserved(in.readShort());
         header.setTotalBodyLength(in.readInt());
         header.setOpaque(in.readInt());
-        header.setCAS(in.readLong());
+        header.setCas(in.readLong());
         return header;
     }
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
Patch:
@@ -25,7 +25,7 @@ public interface BinaryMemcacheResponse extends BinaryMemcacheMessage {
      *
      * @return the status of the response.
      */
-    short getStatus();
+    short status();
 
     /**
      * Sets the status of the response.

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
Patch:
@@ -43,7 +43,7 @@ protected BinaryMemcacheResponse decodeHeader(ByteBuf in) {
         header.setStatus(in.readShort());
         header.setTotalBodyLength(in.readInt());
         header.setOpaque(in.readInt());
-        header.setCAS(in.readLong());
+        header.setCas(in.readLong());
         return header;
     }
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java
Patch:
@@ -66,7 +66,7 @@ public DefaultBinaryMemcacheRequest(String key, ByteBuf extras) {
     }
 
     @Override
-    public short getReserved() {
+    public short reserved() {
         return reserved;
     }
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java
Patch:
@@ -66,7 +66,7 @@ public DefaultBinaryMemcacheResponse(String key, ByteBuf extras) {
     }
 
     @Override
-    public short getStatus() {
+    public short status() {
         return status;
     }
 

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -61,8 +61,8 @@ public void shouldAggregateChunksOnDecode() {
 
         assertThat(request, instanceOf(FullBinaryMemcacheRequest.class));
         assertThat(request, notNullValue());
-        assertThat(request.getKey(), notNullValue());
-        assertThat(request.getExtras(), nullValue());
+        assertThat(request.key(), notNullValue());
+        assertThat(request.extras(), nullValue());
 
         assertThat(request.content().readableBytes(), is(8));
         assertThat(request.content().readByte(), is((byte) 0x01));

File: buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
Patch:
@@ -96,9 +96,9 @@ public ByteBuf buffer(int initialCapacity, int maxCapacity) {
     @Override
     public ByteBuf ioBuffer() {
         if (PlatformDependent.hasUnsafe()) {
-            return directBuffer(0);
+            return directBuffer(DEFAULT_INITIAL_CAPACITY);
         }
-        return heapBuffer(0);
+        return heapBuffer(DEFAULT_INITIAL_CAPACITY);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java
Patch:
@@ -43,7 +43,7 @@ public interface ByteBufAllocator {
     ByteBuf buffer(int initialCapacity, int maxCapacity);
 
     /**
-     * Allocate a {@link ByteBuf} whose initial capacity is 0, preferably a direct buffer which is suitable for I/O.
+     * Allocate a {@link ByteBuf}, preferably a direct buffer which is suitable for I/O.
      */
     ByteBuf ioBuffer();
 

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -1949,9 +1949,7 @@ public void testNioBufferExposeOnlyRegion() {
     @Test
     public void testLittleEndianWithExpand() {
         ByteBuf buffer = releaseLater(newBuffer(0)).order(LITTLE_ENDIAN);
-        System.out.println(buffer.getClass());
         buffer.writeInt(0x12345678);
-        System.out.println(ByteBufUtil.hexDump(buffer));
         assertEquals("78563412", ByteBufUtil.hexDump(buffer));
     }
 

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -384,6 +384,6 @@ private long addr(int index) {
 
     @Override
     protected SwappedByteBuf newSwappedByteBuf() {
-        return new UnsafeDirectSwappedByteBuf(this, memoryAddress);
+        return new UnsafeDirectSwappedByteBuf(this);
     }
 }

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
Patch:
@@ -517,6 +517,6 @@ long addr(int index) {
 
     @Override
     protected SwappedByteBuf newSwappedByteBuf() {
-        return new UnsafeDirectSwappedByteBuf(this, memoryAddress);
+        return new UnsafeDirectSwappedByteBuf(this);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
Patch:
@@ -42,7 +42,7 @@ public static String encode(Cookie cookie) {
             throw new NullPointerException("cookie");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
         encode(buf, cookie);
         return stripTrailingSeparator(buf);
     }
@@ -52,7 +52,7 @@ public static String encode(Cookie... cookies) {
             throw new NullPointerException("cookies");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
         for (Cookie c: cookies) {
             if (c == null) {
                 break;
@@ -68,7 +68,7 @@ public static String encode(Iterable<Cookie> cookies) {
             throw new NullPointerException("cookies");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
         for (Cookie c: cookies) {
             if (c == null) {
                 break;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.util.internal.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocal;
 
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
@@ -39,7 +39,7 @@ final class HttpHeaderDateFormat extends SimpleDateFormat {
     private final SimpleDateFormat format1 = new HttpHeaderDateFormatObsolete1();
     private final SimpleDateFormat format2 = new HttpHeaderDateFormatObsolete2();
 
-    private static final ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
+    private static final FastThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
             new FastThreadLocal<HttpHeaderDateFormat>() {
                 @Override
                 protected HttpHeaderDateFormat initialValue() {

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -47,7 +47,7 @@ public static String encode(Cookie cookie) {
             throw new NullPointerException("cookie");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
 
         add(buf, cookie.getName(), cookie.getValue());
 

File: codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.netty.handler.codec;
 
-import io.netty.util.internal.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.PlatformDependent;
 
 import java.text.DateFormat;
@@ -791,7 +791,7 @@ public void remove() {
     static final class HttpHeaderDateFormat {
 
         private static final ParsePosition parsePos = new ParsePosition(0);
-        private static final ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
+        private static final FastThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
                 new FastThreadLocal<HttpHeaderDateFormat>() {
                     @Override
                     protected HttpHeaderDateFormat initialValue() {

File: codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalMarshallerProvider.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.ChannelHandlerContext;
 
-import io.netty.util.internal.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocal;
 import org.jboss.marshalling.Marshaller;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
@@ -28,7 +28,7 @@
  * many small {@link Object}'s and your actual Thread count is not to big
  */
 public class ThreadLocalMarshallerProvider implements MarshallerProvider {
-    private final ThreadLocal<Marshaller> marshallers = new FastThreadLocal<Marshaller>();
+    private final FastThreadLocal<Marshaller> marshallers = new FastThreadLocal<Marshaller>();
 
     private final MarshallerFactory factory;
     private final MarshallingConfiguration config;

File: codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalUnmarshallerProvider.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.ChannelHandlerContext;
 
-import io.netty.util.internal.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocal;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
 import org.jboss.marshalling.Unmarshaller;
@@ -28,7 +28,7 @@
  * many small {@link Object}'s.
  */
 public class ThreadLocalUnmarshallerProvider implements UnmarshallerProvider {
-    private final ThreadLocal<Unmarshaller> unmarshallers = new FastThreadLocal<Unmarshaller>();
+    private final FastThreadLocal<Unmarshaller> unmarshallers = new FastThreadLocal<Unmarshaller>();
 
     private final MarshallerFactory factory;
     private final MarshallingConfiguration config;

File: handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.EmptyArrays;
-import io.netty.util.internal.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocal;
 
 import javax.net.ssl.ManagerFactoryParameters;
 import javax.net.ssl.TrustManager;
@@ -68,7 +68,7 @@ public final class FingerprintTrustManagerFactory extends SimpleTrustManagerFact
     private static final int SHA1_BYTE_LEN = 20;
     private static final int SHA1_HEX_LEN = SHA1_BYTE_LEN * 2;
 
-    private static final ThreadLocal<MessageDigest> tlmd = new FastThreadLocal<MessageDigest>() {
+    private static final FastThreadLocal<MessageDigest> tlmd = new FastThreadLocal<MessageDigest>() {
         @Override
         protected MessageDigest initialValue() {
             try {

File: handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.netty.handler.ssl.util;
 
-import io.netty.util.internal.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocal;
 
 import javax.net.ssl.ManagerFactoryParameters;
 import javax.net.ssl.TrustManager;
@@ -44,7 +44,7 @@ public abstract class SimpleTrustManagerFactory extends TrustManagerFactory {
      *
      * To work around this issue, we use an ugly hack which uses a {@link ThreadLocal}.
      */
-    private static final ThreadLocal<SimpleTrustManagerFactorySpi> CURRENT_SPI =
+    private static final FastThreadLocal<SimpleTrustManagerFactorySpi> CURRENT_SPI =
             new FastThreadLocal<SimpleTrustManagerFactorySpi>() {
                 @Override
                 protected SimpleTrustManagerFactorySpi initialValue() {

File: microbench/src/test/java/io/netty/microbench/internal/RecyclableArrayListBenchmark.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import io.netty.util.internal.RecyclableArrayList;
-import org.openjdk.jmh.annotations.GenerateMicroBenchmark;
+import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Param;
 import org.openjdk.jmh.annotations.Threads;
@@ -32,7 +32,7 @@ public class RecyclableArrayListBenchmark extends AbstractMicrobenchmark {
     @Param({ "00000", "00256", "01024", "04096", "16384", "65536" })
     public int size;
 
-    @GenerateMicroBenchmark
+    @Benchmark
     public void recycleSameThread() {
         RecyclableArrayList list = RecyclableArrayList.newInstance(size);
         list.recycle();

File: microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmark.java
Patch:
@@ -24,7 +24,7 @@
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Warmup;
-import org.openjdk.jmh.output.results.ResultFormatType;
+import org.openjdk.jmh.results.format.ResultFormatType;
 import org.openjdk.jmh.runner.Runner;
 import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;
 import org.openjdk.jmh.runner.options.OptionsBuilder;

File: common/src/main/java/io/netty/util/ThreadDeathWatcher.java
Patch:
@@ -85,7 +85,7 @@ public static void watch(Thread thread, Runnable task) {
      *
      * @return {@code true} if and only if the watcher thread has been terminated
      */
-    public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
+    public static boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
         if (unit == null) {
             throw new NullPointerException("unit");
         }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
Patch:
@@ -285,11 +285,11 @@ static boolean isServerId(int id) {
     /**
      * Validate a SPDY header name.
      */
-    static void validateHeaderName(String name) {
+    static void validateHeaderName(CharSequence name) {
         if (name == null) {
             throw new NullPointerException("name");
         }
-        if (name.isEmpty()) {
+        if (name.length() == 0) {
             throw new IllegalArgumentException(
                     "name cannot be length zero");
         }
@@ -315,7 +315,7 @@ static void validateHeaderName(String name) {
     /**
      * Validate a SPDY header value. Does not validate max length.
      */
-    static void validateHeaderValue(String value) {
+    static void validateHeaderValue(CharSequence value) {
         if (value == null) {
             throw new NullPointerException("value");
         }

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeadersSubframe.java
Patch:
@@ -24,7 +24,7 @@ public class DefaultStompHeadersSubframe implements StompHeadersSubframe {
 
     protected final StompCommand command;
     protected DecoderResult decoderResult = DecoderResult.SUCCESS;
-    protected final StompHeaders headers = new StompHeaders();
+    protected final StompHeaders headers = new DefaultStompHeaders();
 
     public DefaultStompHeadersSubframe(StompCommand command) {
         if (command == null) {

File: common/src/main/java/io/netty/util/internal/EmptyArrays.java
Patch:
@@ -22,6 +22,7 @@
 public final class EmptyArrays {
 
     public static final byte[] EMPTY_BYTES = new byte[0];
+    public static final char[] EMPTY_CHARS = new char[0];
     public static final boolean[] EMPTY_BOOLEANS = new boolean[0];
     public static final double[] EMPTY_DOUBLES = new double[0];
     public static final float[] EMPTY_FLOATS = new float[0];

File: buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.buffer;
 
 import io.netty.util.ThreadDeathWatcher;
+import io.netty.util.internal.FastThreadLocal;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -28,7 +29,6 @@
 public class PooledByteBufAllocator extends AbstractByteBufAllocator {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(PooledByteBufAllocator.class);
-
     private static final int DEFAULT_NUM_HEAP_ARENA;
     private static final int DEFAULT_NUM_DIRECT_ARENA;
 
@@ -273,7 +273,7 @@ public void freeThreadLocalCache() {
         threadCache.free();
     }
 
-    final class PoolThreadLocalCache extends ThreadLocal<PoolThreadCache> {
+    final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {
         private final AtomicInteger index = new AtomicInteger();
         private boolean initialized;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java
Patch:
@@ -16,9 +16,11 @@
 package io.netty.handler.codec.http;
 
 
+import io.netty.util.internal.FastThreadLocal;
+
 final class CookieEncoderUtil {
 
-    static final ThreadLocal<StringBuilder> buffer = new ThreadLocal<StringBuilder>() {
+    static final ThreadLocal<StringBuilder> buffer = new FastThreadLocal<StringBuilder>() {
         @Override
         public StringBuilder get() {
             StringBuilder buf = super.get();

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http;
 
+import io.netty.util.internal.FastThreadLocal;
+
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -38,7 +40,7 @@ final class HttpHeaderDateFormat extends SimpleDateFormat {
     private final SimpleDateFormat format2 = new HttpHeaderDateFormatObsolete2();
 
     private static final ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
-            new ThreadLocal<HttpHeaderDateFormat>() {
+            new FastThreadLocal<HttpHeaderDateFormat>() {
                 @Override
                 protected HttpHeaderDateFormat initialValue() {
                     return new HttpHeaderDateFormat();

File: codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalMarshallerProvider.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.channel.ChannelHandlerContext;
 
+import io.netty.util.internal.FastThreadLocal;
 import org.jboss.marshalling.Marshaller;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
@@ -27,7 +28,7 @@
  * many small {@link Object}'s and your actual Thread count is not to big
  */
 public class ThreadLocalMarshallerProvider implements MarshallerProvider {
-    private final ThreadLocal<Marshaller> marshallers = new ThreadLocal<Marshaller>();
+    private final ThreadLocal<Marshaller> marshallers = new FastThreadLocal<Marshaller>();
 
     private final MarshallerFactory factory;
     private final MarshallingConfiguration config;

File: codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalUnmarshallerProvider.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.channel.ChannelHandlerContext;
 
+import io.netty.util.internal.FastThreadLocal;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
 import org.jboss.marshalling.Unmarshaller;
@@ -27,7 +28,7 @@
  * many small {@link Object}'s.
  */
 public class ThreadLocalUnmarshallerProvider implements UnmarshallerProvider {
-    private final ThreadLocal<Unmarshaller> unmarshallers = new ThreadLocal<Unmarshaller>();
+    private final ThreadLocal<Unmarshaller> unmarshallers = new FastThreadLocal<Unmarshaller>();
 
     private final MarshallerFactory factory;
     private final MarshallingConfiguration config;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.util.Signal;
 import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.FastThreadLocal;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -35,7 +36,7 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
             InternalLoggerFactory.getInstance(DefaultPromise.class.getName() + ".rejectedExecution");
 
     private static final int MAX_LISTENER_STACK_DEPTH = 8;
-    private static final ThreadLocal<Integer> LISTENER_STACK_DEPTH = new ThreadLocal<Integer>() {
+    private static final ThreadLocal<Integer> LISTENER_STACK_DEPTH = new FastThreadLocal<Integer>() {
         @Override
         protected Integer initialValue() {
             return 0;

File: common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java
Patch:
@@ -31,7 +31,7 @@ public abstract class TypeParameterMatcher {
     private static final Object TEST_OBJECT = new Object();
 
     private static final ThreadLocal<Map<Class<?>, TypeParameterMatcher>> getCache =
-            new ThreadLocal<Map<Class<?>, TypeParameterMatcher>>() {
+            new FastThreadLocal<Map<Class<?>, TypeParameterMatcher>>() {
                 @Override
                 protected Map<Class<?>, TypeParameterMatcher> initialValue() {
                     return new IdentityHashMap<Class<?>, TypeParameterMatcher>();
@@ -69,7 +69,7 @@ public static TypeParameterMatcher get(final Class<?> parameterType) {
     }
 
     private static final ThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>> findCache =
-            new ThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>>() {
+            new FastThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>>() {
                 @Override
                 protected Map<Class<?>, Map<String, TypeParameterMatcher>> initialValue() {
                     return new IdentityHashMap<Class<?>, Map<String, TypeParameterMatcher>>();

File: handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.FastThreadLocal;
 
 import javax.net.ssl.ManagerFactoryParameters;
 import javax.net.ssl.TrustManager;
@@ -67,7 +68,7 @@ public final class FingerprintTrustManagerFactory extends SimpleTrustManagerFact
     private static final int SHA1_BYTE_LEN = 20;
     private static final int SHA1_HEX_LEN = SHA1_BYTE_LEN * 2;
 
-    private static final ThreadLocal<MessageDigest> tlmd = new ThreadLocal<MessageDigest>() {
+    private static final ThreadLocal<MessageDigest> tlmd = new FastThreadLocal<MessageDigest>() {
         @Override
         protected MessageDigest initialValue() {
             try {

File: handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.netty.handler.ssl.util;
 
+import io.netty.util.internal.FastThreadLocal;
+
 import javax.net.ssl.ManagerFactoryParameters;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
@@ -43,7 +45,7 @@ public abstract class SimpleTrustManagerFactory extends TrustManagerFactory {
      * To work around this issue, we use an ugly hack which uses a {@link ThreadLocal}.
      */
     private static final ThreadLocal<SimpleTrustManagerFactorySpi> CURRENT_SPI =
-            new ThreadLocal<SimpleTrustManagerFactorySpi>() {
+            new FastThreadLocal<SimpleTrustManagerFactorySpi>() {
                 @Override
                 protected SimpleTrustManagerFactorySpi initialValue() {
                     return new SimpleTrustManagerFactorySpi();

File: transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.netty.channel;
 
+import io.netty.util.internal.FastThreadLocal;
+
 import java.util.Map;
 import java.util.WeakHashMap;
 
@@ -33,7 +35,7 @@ public abstract class ChannelHandlerAdapter implements ChannelHandler {
      * See <a href="See https://github.com/netty/netty/issues/2289">#2289</a>.
      */
     private static final ThreadLocal<Map<Class<?>, Boolean>> SHARABLE_CACHE =
-            new ThreadLocal<Map<Class<?>, Boolean>>() {
+            new FastThreadLocal<Map<Class<?>, Boolean>>() {
                 @Override
                 protected Map<Class<?>, Boolean> initialValue() {
                     // Start with small capacity to keep memory overhead as low as possible.

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -28,6 +28,7 @@
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
+import io.netty.util.internal.FastThreadLocal;
 
 import java.net.SocketAddress;
 import java.nio.channels.AlreadyConnectedException;
@@ -48,7 +49,7 @@ private enum State { OPEN, BOUND, CONNECTED, CLOSED }
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static final int MAX_READER_STACK_DEPTH = 8;
-    private static final ThreadLocal<Integer> READER_STACK_DEPTH = new ThreadLocal<Integer>() {
+    private static final ThreadLocal<Integer> READER_STACK_DEPTH = new FastThreadLocal<Integer>() {
         @Override
         protected Integer initialValue() {
             return 0;

File: transport/src/main/java/io/netty/channel/ChannelHandlerAppender.java
Patch:
@@ -181,7 +181,7 @@ protected final <T extends ChannelHandler> T handlerAt(int index) {
     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         added = true;
 
-        DefaultChannelHandlerContext dctx = (DefaultChannelHandlerContext) ctx;
+        AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
         DefaultChannelPipeline pipeline = (DefaultChannelPipeline) dctx.pipeline();
         String name = dctx.name();
         try {

File: codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeaders.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -48,7 +48,7 @@ public class StompHeaders {
     public static final String CONTENT_LENGTH = "content-length";
     public static final String CONTENT_TYPE = "content-type";
 
-    private final Map<String, List<String>> headers = new HashMap<String, List<String>>();
+    private final Map<String, List<String>> headers = new LinkedHashMap<String, List<String>>();
 
     public boolean has(String key) {
         List<String> values = headers.get(key);

File: codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeEncoderTest.java
Patch:
@@ -43,8 +43,8 @@ public void teardown() throws Exception {
     public void testFrameAndContentEncoding() {
         StompHeadersSubframe frame = new DefaultStompHeadersSubframe(StompCommand.CONNECT);
         StompHeaders headers = frame.headers();
-        headers.set(StompHeaders.ACCEPT_VERSION, "1.1,1.2");
         headers.set(StompHeaders.HOST, "stomp.github.org");
+        headers.set(StompHeaders.ACCEPT_VERSION, "1.1,1.2");
         channel.writeOutbound(frame);
         channel.writeOutbound(LastStompContentSubframe.EMPTY_LAST_CONTENT);
         ByteBuf aggregatedBuffer = Unpooled.buffer();

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.util;
 
-import io.netty.util.internal.MpscLinkedQueue;
+import io.netty.util.internal.MpscLinkedQueueNode;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -444,7 +444,7 @@ public Set<Timeout> unprocessedTimeouts() {
         }
     }
 
-    private static final class HashedWheelTimeout extends MpscLinkedQueue.Node<Timeout>
+    private static final class HashedWheelTimeout extends MpscLinkedQueueNode<Timeout>
             implements Timeout {
 
         private static final int ST_INIT = 0;

File: common/src/main/java/io/netty/util/ThreadDeathWatcher.java
Patch:
@@ -17,7 +17,7 @@
 package io.netty.util;
 
 import io.netty.util.concurrent.DefaultThreadFactory;
-import io.netty.util.internal.MpscLinkedQueue;
+import io.netty.util.internal.MpscLinkedQueueNode;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -175,7 +175,7 @@ private void notifyWatchees() {
         }
     }
 
-    private static final class Entry extends MpscLinkedQueue.Node<Entry> {
+    private static final class Entry extends MpscLinkedQueueNode<Entry> {
         final Thread thread;
         final Runnable task;
 

File: common/src/main/java/io/netty/util/internal/OneTimeTask.java
Patch:
@@ -23,7 +23,7 @@
  *
  * <strong>It is important this will not be reused. After submitted it is not allowed to get submitted again!</strong>
  */
-public abstract class OneTimeTask extends MpscLinkedQueue.Node<Runnable> implements Runnable {
+public abstract class OneTimeTask extends MpscLinkedQueueNode<Runnable> implements Runnable {
 
     @Override
     public Runnable value() {

File: example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
Patch:
@@ -18,7 +18,8 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 
@@ -30,7 +31,7 @@ public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {
 
     @Override
     public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
-        final DefaultHttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        final FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         response.headers().set("custom-response-header", "Some value");
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }

File: common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
Patch:
@@ -86,7 +86,7 @@ public void testScheduledTasks() throws Exception {
 
         Thread.sleep(1500);
 
-        // Not it should be stopped.
+        // Now it should be stopped.
         assertThat(thread.isAlive(), is(false));
         assertThat(e.thread, sameInstance(thread));
     }

File: common/src/test/java/io/netty/util/ThreadDeathWatcherTest.java
Patch:
@@ -70,4 +70,4 @@ public void run() {
         // The task must be run on termination.
         latch.await();
     }
-}
\ No newline at end of file
+}

File: transport/src/main/java/io/netty/channel/group/ChannelMatchers.java
Patch:
@@ -121,10 +121,10 @@ private static final class CompositeMatcher implements ChannelMatcher {
         public boolean matches(Channel channel) {
             for (int i = 0; i < matchers.length; i++) {
                 if (!matchers[i].matches(channel)) {
-                    return true;
+                    return false;
                 }
             }
-            return false;
+            return true;
         }
     }
 

File: common/src/main/java/io/netty/util/DefaultAttributeMap.java
Patch:
@@ -90,6 +90,9 @@ public <T> Attribute<T> attr(AttributeKey<T> key) {
                     DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);
                     curr.next =  attr;
                     attr.prev = curr;
+                    return attr;
+                } else {
+                    curr = next;
                 }
             }
         }

File: transport/src/main/java/io/netty/channel/DefaultChannelId.java
Patch:
@@ -423,7 +423,7 @@ public String asLongText() {
     }
 
     private String newLongValue() {
-        StringBuilder buf = new StringBuilder(data.length + 4);
+        StringBuilder buf = new StringBuilder(2 * data.length + 5);
         int i = 0;
         i = appendHexDumpField(buf, i, MACHINE_ID_LEN);
         i = appendHexDumpField(buf, i, PROCESS_ID_LEN);

File: example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
Patch:
@@ -44,8 +44,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
         int magicNumber = in.readUnsignedByte();
         if (magicNumber != 'F') {
             in.resetReaderIndex();
-            throw new CorruptedFrameException(
-                    "Invalid magic number: " + magicNumber);
+            throw new CorruptedFrameException("Invalid magic number: " + magicNumber);
         }
 
         // Wait until the whole data is available.

File: example/src/main/java/io/netty/example/factorial/NumberEncoder.java
Patch:
@@ -29,7 +29,7 @@
 public class NumberEncoder extends MessageToByteEncoder<Number> {
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, Number msg, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, Number msg, ByteBuf out) {
         // Convert to a BigInteger first for easier implementation.
         BigInteger v;
         if (msg instanceof BigInteger) {

File: example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
Patch:
@@ -37,7 +37,7 @@ public void channelReadComplete(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) msg;
 
@@ -59,7 +59,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientIntializer.java
Patch:
@@ -32,8 +32,7 @@ public HttpUploadClientIntializer(SslContext sslCtx) {
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        // Create a default pipeline implementation.
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
 
         if (sslCtx != null) {

File: example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
Patch:
@@ -18,17 +18,16 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
-
 public class LocalEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         // Write back as received
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 

File: example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java
Patch:
@@ -33,7 +33,7 @@ public class MemcacheClientHandler extends ChannelDuplexHandler {
      * Transforms basic string requests to binary memcache requests
      */
     @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         String command = (String) msg;
         if (command.startsWith("get ")) {
             String key = command.substring("get ".length());
@@ -68,13 +68,13 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         FullBinaryMemcacheResponse res = (FullBinaryMemcacheResponse) msg;
         System.out.println(res.content().toString(CharsetUtil.UTF_8));
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java
Patch:
@@ -31,7 +31,7 @@ public HexDumpProxyInitializer(String remoteHost, int remotePort) {
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ch.pipeline().addLast(
                 new LoggingHandler(LogLevel.INFO),
                 new HexDumpProxyFrontendHandler(remoteHost, remotePort));

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
Patch:
@@ -32,7 +32,7 @@ public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws E
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
Patch:
@@ -75,7 +75,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         queue.add(ctx.channel().newFailedFuture(cause));
         cause.printStackTrace();
         ctx.close();
@@ -84,5 +84,4 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     public BlockingQueue<ChannelFuture> queue() {
         return queue;
     }
-
 }

File: example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java
Patch:
@@ -29,6 +29,8 @@
 
 public class SpdyClientInitializer extends ChannelInitializer<SocketChannel> {
 
+    private static final int MAX_SPDY_CONTENT_LENGTH = 1024 * 1024; // 1 MB
+
     private final SslContext sslCtx;
     private final HttpResponseClientHandler httpResponseHandler;
 
@@ -37,10 +39,8 @@ public SpdyClientInitializer(SslContext sslCtx, HttpResponseClientHandler httpRe
         this.httpResponseHandler = httpResponseHandler;
     }
 
-    private static final int MAX_SPDY_CONTENT_LENGTH = 1024 * 1024; // 1 MB
-
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
         pipeline.addLast("ssl", sslCtx.newHandler(ch.alloc()));
         pipeline.addLast("spdyFrameCodec", new SpdyFrameCodec(SPDY_3_1));

File: example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java
Patch:
@@ -28,12 +28,12 @@ public class SpdyClientStreamIdHandler extends ChannelOutboundHandlerAdapter {
 
     private int currentStreamId = 1;
 
-    public boolean acceptOutboundMessage(Object msg) throws Exception {
+    public boolean acceptOutboundMessage(Object msg) {
         return msg instanceof HttpMessage;
     }
 
     @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         if (acceptOutboundMessage(msg)) {
             HttpMessage httpMsg = (HttpMessage) msg;
             if (!httpMsg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
@@ -42,6 +42,6 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
                 currentStreamId += 2;
             }
         }
-        super.write(ctx, msg, promise);
+        ctx.write(msg, promise);
     }
 }

File: example/src/main/java/io/netty/example/spdy/server/SpdyServerInitializer.java
Patch:
@@ -32,10 +32,10 @@ public SpdyServerInitializer(SslContext sslCtx) {
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline p = ch.pipeline();
-        p.addLast("ssl", sslCtx.newHandler(ch.alloc()));
+        p.addLast(sslCtx.newHandler(ch.alloc()));
         // Negotiates with the browser if SPDY or HTTP is going to be used
-        p.addLast("handler", new SpdyOrHttpHandler());
+        p.addLast(new SpdyOrHttpHandler());
     }
 }

File: example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerBase.java
Patch:
@@ -21,9 +21,9 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.ThreadFactory;
@@ -48,7 +48,7 @@ protected MsgEchoPeerBase(final InetSocketAddress self, final InetSocketAddress
 
     public void run() throws Exception {
         // Configure the peer.
-        final ThreadFactory connectFactory = new UtilThreadFactory("rendezvous");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("rendezvous");
         final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                 connectFactory, NioUdtProvider.MESSAGE_PROVIDER);
         try {
@@ -73,5 +73,4 @@ public void initChannel(final UdtChannel ch)
             connectGroup.shutdownGracefully();
         }
     }
-
 }

File: example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java
Patch:
@@ -21,9 +21,9 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.net.SocketAddress;
 import java.util.concurrent.ThreadFactory;
@@ -38,6 +38,7 @@
  * <p/>
  */
 public class ByteEchoPeerBase {
+
     protected final int messageSize;
     protected SocketAddress myAddress;
     protected SocketAddress peerAddress;
@@ -49,7 +50,7 @@ public ByteEchoPeerBase(int messageSize, SocketAddress myAddress, SocketAddress
     }
 
     public void run() throws Exception {
-        final ThreadFactory connectFactory = new UtilThreadFactory("rendezvous");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("rendezvous");
         final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                 connectFactory, NioUdtProvider.BYTE_PROVIDER);
         try {

File: example/src/main/java/io/netty/example/spdy/server/SpdyOrHttpHandler.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.channel.ChannelInboundHandler;
 import io.netty.handler.codec.spdy.SpdyOrHttpChooser;
-import org.eclipse.jetty.npn.NextProtoNego;
 
 import javax.net.ssl.SSLEngine;
 import java.util.logging.Logger;
@@ -41,8 +40,8 @@ public SpdyOrHttpHandler(int maxSpdyContentLength, int maxHttpContentLength) {
 
     @Override
     protected SelectedProtocol getProtocol(SSLEngine engine) {
-        SpdyServerProvider provider = (SpdyServerProvider) NextProtoNego.get(engine);
-        SelectedProtocol selectedProtocol = provider.getSelectedProtocol();
+        String[] protocol = engine.getSession().getProtocol().split(":");
+        SelectedProtocol selectedProtocol = SelectedProtocol.protocol(protocol[1]);
 
         logger.info("Selected Protocol is " + selectedProtocol);
         return selectedProtocol;

File: common/src/main/java/io/netty/util/internal/EmptyArrays.java
Patch:
@@ -17,6 +17,7 @@
 package io.netty.util.internal;
 
 import java.nio.ByteBuffer;
+import java.security.cert.X509Certificate;
 
 public final class EmptyArrays {
 
@@ -31,6 +32,7 @@ public final class EmptyArrays {
     public static final String[] EMPTY_STRINGS = new String[0];
     public static final StackTraceElement[] EMPTY_STACK_TRACE = new StackTraceElement[0];
     public static final ByteBuffer[] EMPTY_BYTE_BUFFERS = new ByteBuffer[0];
+    public static final X509Certificate[] EMPTY_X509_CERTIFICATES = new X509Certificate[0];
 
     private EmptyArrays() { }
 }

File: buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
Patch:
@@ -274,7 +274,7 @@ public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
-        checkIndex(index);
+        checkIndex(index, src.remaining());
         ByteBuffer tmpBuf = internalNioBuffer();
         if (src == tmpBuf) {
             src = src.duplicate();

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -278,7 +278,7 @@ public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
-        checkIndex(index);
+        checkIndex(index, src.remaining());
         ByteBuffer tmpBuf = internalNioBuffer();
         if (src == tmpBuf) {
             src = src.duplicate();

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.buffer;
 
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.EmptyArrays;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Assume;
@@ -163,6 +164,8 @@ public void writerIndexBoundaryCheck4() {
         buffer.writerIndex(0);
         buffer.readerIndex(0);
         buffer.writerIndex(CAPACITY);
+
+        buffer.writeBytes(ByteBuffer.wrap(EmptyArrays.EMPTY_BYTES));
     }
 
     @Test(expected = IndexOutOfBoundsException.class)

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -379,11 +379,11 @@ public static <T> AtomicLongFieldUpdater<T> newAtomicLongFieldUpdater(
      * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single
      * consumer (one thread!).
      */
-    public static Queue<Runnable> newMpscQueue() {
+    public static <T> Queue<T> newMpscQueue() {
         if (hasUnsafe()) {
-            return new MpscLinkedQueue();
+            return new MpscLinkedQueue<T>();
         } else {
-            return new ConcurrentLinkedQueue<Runnable>();
+            return new ConcurrentLinkedQueue<T>();
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java
Patch:
@@ -81,7 +81,7 @@ void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
             if (cumulation.isReadable()) {
                 cumulation.discardReadBytes();
             } else {
-                cumulation = null;
+                releaseBuffer();
             }
         }
     }

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -667,7 +667,7 @@ public ChannelHandler first() {
     @Override
     public ChannelHandlerContext firstContext() {
         DefaultChannelHandlerContext first = head.next;
-        if (first == head) {
+        if (first == tail) {
             return null;
         }
         return head.next;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java
Patch:
@@ -63,7 +63,7 @@ public SocksCmdRequest(SocksCmdType cmdType, SocksAddressType addressType, Strin
             case UNKNOWN:
                 break;
         }
-        if (port < 0 && port >= 65536) {
+        if (port <= 0 || port >= 65536) {
             throw new IllegalArgumentException(port + " is not in bounds 0 < x < 65536");
         }
         this.cmdType = cmdType;

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java
Patch:
@@ -90,7 +90,7 @@ public SocksCmdResponse(SocksCmdStatus cmdStatus, SocksAddressType addressType,
             }
             host = IDN.toASCII(host);
         }
-        if (port < 0 && port >= 65535) {
+        if (port <= 0 && port >= 65536) {
             throw new IllegalArgumentException(port + " is not in bounds 0 < x < 65536");
         }
         this.cmdStatus = cmdStatus;

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java
Patch:
@@ -27,4 +27,5 @@ public void testConstructorParamsAreNotNull() {
             assertTrue(e instanceof NullPointerException);
         }
     }
+
 }

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
Patch:
@@ -51,7 +51,7 @@ private static void testSocksCmdRequestDecoderWithDifferentParams(SocksCmdType c
     @Test
     public void testCmdRequestDecoderIPv4() {
         String[] hosts = {"127.0.0.1", };
-        int[] ports = {0, 32769, 65535 };
+        int[] ports = {1, 32769, 65535 };
         for (SocksCmdType cmdType : SocksCmdType.values()) {
             for (String host : hosts) {
                 for (int port : ports) {
@@ -64,7 +64,7 @@ public void testCmdRequestDecoderIPv4() {
     @Test
     public void testCmdRequestDecoderIPv6() {
         String[] hosts = {SocksCommonUtils.ipv6toStr(IPAddressUtil.textToNumericFormatV6("::1"))};
-        int[] ports = {0, 32769, 65535};
+        int[] ports = {1, 32769, 65535};
         for (SocksCmdType cmdType : SocksCmdType.values()) {
             for (String host : hosts) {
                 for (int port : ports) {
@@ -88,7 +88,7 @@ public void testCmdRequestDecoderDomain() {
                           ".",
                           ".",
                           "."};
-        int[] ports = {0, 32769, 65535};
+        int[] ports = {1, 32769, 65535};
         for (SocksCmdType cmdType : SocksCmdType.values()) {
             for (String host : hosts) {
                 for (int port : ports) {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java
Patch:
@@ -63,7 +63,7 @@ public SocksCmdRequest(SocksCmdType cmdType, SocksAddressType addressType, Strin
             case UNKNOWN:
                 break;
         }
-        if (port < 0 && port >= 65535) {
+        if (port < 0 && port >= 65536) {
             throw new IllegalArgumentException(port + " is not in bounds 0 < x < 65536");
         }
         this.cmdType = cmdType;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -96,7 +96,7 @@ public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel)
     protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
         String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);
         if (contentEncoding != null &&
-            !HttpHeaders.Values.IDENTITY.equalsIgnoreCase(contentEncoding)) {
+            !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {
             return null;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -35,8 +35,7 @@
 /**
  * Handles the HTTP handshake (the HTTP Upgrade request) for {@link WebSocketServerProtocolHandler}.
  */
-class WebSocketServerProtocolHandshakeHandler
-        extends ChannelInboundHandlerAdapter {
+class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {
 
     private final String websocketPath;
     private final String subprotocols;

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
Patch:
@@ -116,5 +116,4 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             }
         }
     }
-
 }

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -35,7 +35,7 @@
  * By default, all events are logged at <tt>DEBUG</tt> level.
  */
 @Sharable
-@SuppressWarnings("StringConcatenationInsideStringBufferAppend")
+@SuppressWarnings({ "StringConcatenationInsideStringBufferAppend", "StringBufferReplaceableByString" })
 public class LoggingHandler extends ChannelDuplexHandler {
 
     private static final LogLevel DEFAULT_LEVEL = LogLevel.DEBUG;
@@ -202,7 +202,7 @@ public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
         if (logger.isEnabled(internalLevel)) {
             logger.log(internalLevel, format(ctx, "UNREGISTERED"));
         }
-        super.channelUnregistered(ctx);
+        ctx.fireChannelUnregistered();
     }
 
     @Override
@@ -276,7 +276,7 @@ public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws
         if (logger.isEnabled(internalLevel)) {
             logger.log(internalLevel, format(ctx, "DEREGISTER"));
         }
-        super.deregister(ctx, promise);
+        ctx.deregister(promise);
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -66,8 +66,7 @@
  * transfer.  To resume the transfer when a new chunk is available, you have to
  * call {@link #resumeTransfer()}.
  */
-public class ChunkedWriteHandler
-        extends ChannelDuplexHandler {
+public class ChunkedWriteHandler extends ChannelDuplexHandler {
 
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(ChunkedWriteHandler.class);

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
Patch:
@@ -121,6 +121,7 @@ public ChannelHandlerInvoker asInvoker() {
     public EventExecutor executor() {
         return this;
     }
+
     @Override
     public void invokeChannelRegistered(ChannelHandlerContext ctx) {
         invokeChannelRegisteredNow(ctx);

File: buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
Patch:
@@ -714,7 +714,7 @@ public ByteBuf touch(Object hint) {
 
     @Override
     public boolean release() {
-        boolean deallocated =  super.release();
+        boolean deallocated = super.release();
         if (deallocated) {
             leak.close();
         } else {

File: buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
Patch:
@@ -27,7 +27,7 @@
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
 
-class WrappedByteBuf extends ByteBuf {
+public class WrappedByteBuf extends ByteBuf {
 
     protected final ByteBuf buf;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java
Patch:
@@ -42,7 +42,7 @@ public DefaultHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri
      * @param httpVersion       the HTTP version of the request
      * @param method            the HTTP getMethod of the request
      * @param uri               the URI or path of the request
-     * @param validateHeaders   validate the headers when adding them
+     * @param validateHeaders   validate the header names and values when adding them to the {@link HttpHeaders}
      */
     public DefaultHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri, boolean validateHeaders) {
         super(httpVersion, validateHeaders);

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java
Patch:
@@ -39,7 +39,7 @@ public DefaultHttpResponse(HttpVersion version, HttpResponseStatus status) {
      *
      * @param version           the HTTP version of this response
      * @param status            the getStatus of this response
-     * @param validateHeaders   validate the headers when adding them
+     * @param validateHeaders   validate the header names and values when adding them to the {@link HttpHeaders}
      */
     public DefaultHttpResponse(HttpVersion version, HttpResponseStatus status, boolean validateHeaders) {
         super(version, validateHeaders);

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
Patch:
@@ -114,9 +114,9 @@ private static final class TrailingHeaders extends DefaultHttpHeaders {
         @Override
         void validateHeaderName0(CharSequence name) {
             super.validateHeaderName0(name);
-            if (HttpHeaders.equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||
-                    HttpHeaders.equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||
-                    HttpHeaders.equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {
+            if (equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||
+                    equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||
+                    equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {
                 throw new IllegalArgumentException(
                         "prohibited trailing header: " + name);
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java
Patch:
@@ -149,8 +149,8 @@ private HttpMethod(String name, boolean bytes) {
         }
 
         for (int i = 0; i < name.length(); i ++) {
-            if (Character.isISOControl(name.charAt(i)) ||
-                Character.isWhitespace(name.charAt(i))) {
+            char c = name.charAt(i);
+            if (Character.isISOControl(c) || Character.isWhitespace(c)) {
                 throw new IllegalArgumentException("invalid character in name");
             }
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -198,13 +198,13 @@ protected void verify(FullHttpResponse response) {
         HttpHeaders headers = response.headers();
 
         String upgrade = headers.get(Names.UPGRADE);
-        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!HttpHeaders.equalsIgnoreCase(Values.WEBSOCKET, upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: "
                     + upgrade);
         }
 
         String connection = headers.get(Names.CONNECTION);
-        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!HttpHeaders.equalsIgnoreCase(Values.UPGRADE, connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: "
                     + connection);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -109,8 +109,8 @@ public WebSocketServerHandshaker00(String webSocketURL, String subprotocols, int
     protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
 
         // Serve the WebSocket handshake request.
-        if (!Values.UPGRADE.equalsIgnoreCase(req.headers().get(CONNECTION))
-                || !WEBSOCKET.equalsIgnoreCase(req.headers().get(Names.UPGRADE))) {
+        if (!HttpHeaders.equalsIgnoreCase(Values.UPGRADE, req.headers().get(CONNECTION))
+                || !HttpHeaders.equalsIgnoreCase(WEBSOCKET, req.headers().get(Names.UPGRADE))) {
             throw new WebSocketHandshakeException("not a WebSocket handshake request: missing upgrade");
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.CharsetUtil;
 
@@ -38,11 +39,11 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request)
             throws Exception {
-        encodeAscii(request.getMethod().toString(), buf);
+        HttpHeaders.encodeAscii(request.getMethod().toString(), buf);
         buf.writeByte(SP);
         buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));
         buf.writeByte(SP);
-        encodeAscii(request.getProtocolVersion().toString(), buf);
+        HttpHeaders.encodeAscii(request.getProtocolVersion().toString(), buf);
         buf.writeBytes(CRLF);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.util.CharsetUtil;
 
@@ -38,11 +39,11 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpResponse response)
             throws Exception {
-        encodeAscii(response.getProtocolVersion().toString(), buf);
+        HttpHeaders.encodeAscii(response.getProtocolVersion().toString(), buf);
         buf.writeByte(SP);
         buf.writeBytes(String.valueOf(response.getStatus().code()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
-        encodeAscii(String.valueOf(response.getStatus().reasonPhrase()), buf);
+        HttpHeaders.encodeAscii(String.valueOf(response.getStatus().reasonPhrase()), buf);
         buf.writeBytes(CRLF);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.CharsetUtil;
 
 final class SpdyCodecUtil {
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -24,13 +24,12 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static io.netty.handler.codec.spdy.SpdyCodecUtil.SPDY_SESSION_STREAM_ID;
+import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 
 /**
  * Manages streams within a SPDY session.
  */
-public class SpdySessionHandler
-        extends ChannelDuplexHandler {
+public class SpdySessionHandler extends ChannelDuplexHandler {
 
     private static final SpdyProtocolException PROTOCOL_EXCEPTION = new SpdyProtocolException();
     private static final SpdyProtocolException STREAM_CLOSED = new SpdyProtocolException("Stream closed");

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
Patch:
@@ -240,11 +240,9 @@ private static FullHttpRequest createHttpRequest(HttpMethod method) {
     }
 
     private static class EchoHandler extends SimpleChannelInboundHandler<Object> {
-
         @Override
         public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
             ctx.writeAndFlush(new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.OK));
         }
     }
-
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -75,6 +75,7 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
         HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals("ws://example.com/chat", res.headers().get(Names.SEC_WEBSOCKET_LOCATION));
+
         if (subProtocol) {
             Assert.assertEquals("chat", res.headers().get(Names.SEC_WEBSOCKET_PROTOCOL));
         } else {

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 
-import java.nio.ByteOrder;
 import java.util.List;
 import java.util.zip.CRC32;
 import java.util.zip.DataFormatException;

File: common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
Patch:
@@ -30,7 +30,6 @@
  * Abstract base class for {@link EventExecutorGroup} implementations.
  */
 public abstract class AbstractEventExecutorGroup implements EventExecutorGroup {
-
     @Override
     public Future<?> submit(Runnable task) {
         return next().submit(task);

File: common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * Default {@link SingleThreadEventExecutor} implementation which just execute all submitted task in a
- * serial fashion
+ * serial fashion.
  */
 public final class DefaultEventExecutor extends SingleThreadEventExecutor {
 

File: common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
Patch:
@@ -21,13 +21,14 @@
  * {@link AbstractEventExecutor} which execute tasks in the callers thread.
  */
 public final class ImmediateEventExecutor extends AbstractEventExecutor {
+
     public static final ImmediateEventExecutor INSTANCE = new ImmediateEventExecutor();
 
     private final Future<?> terminationFuture = new FailedFuture<Object>(
             GlobalEventExecutor.INSTANCE, new UnsupportedOperationException());
 
     private ImmediateEventExecutor() {
-        // use static instance
+        // Singleton
     }
 
     @Override

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -88,7 +88,7 @@ public class HttpUploadServerHandler extends SimpleChannelInboundHandler<HttpObj
     }
 
     @Override
-    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         if (decoder != null) {
             decoder.cleanFiles();
         }
@@ -286,9 +286,9 @@ private void writeResponse(Channel channel) {
         responseContent.setLength(0);
 
         // Decide whether to close the connection or not.
-        boolean close = HttpHeaders.Values.CLOSE.equalsIgnoreCase(request.headers().get(CONNECTION))
+        boolean close = request.headers().contains(CONNECTION, HttpHeaders.Values.CLOSE, true)
                 || request.getProtocolVersion().equals(HttpVersion.HTTP_1_0)
-                && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(request.headers().get(CONNECTION));
+                && !request.headers().contains(CONNECTION, HttpHeaders.Values.KEEP_ALIVE, true);
 
         // Build the response object.
         FullHttpResponse response = new DefaultFullHttpResponse(

File: handler/src/main/java/io/netty/handler/logging/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * Logs a {@link io.netty.channel.ChannelEvent} for debugging purpose.
+ * Logs the I/O events for debugging purpose.
  */
 package io.netty.handler.logging;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
Patch:
@@ -43,7 +43,6 @@ public void testWriteBeforeConnect(Bootstrap cb) throws Throwable {
     }
 
     private static class TestHandler extends ChannelInboundHandlerAdapter {
-
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
             cause.printStackTrace();

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
Patch:
@@ -33,11 +33,11 @@
  * <tr>
  * <th>Name</th><th>Associated setter method</th>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SCTP_NODELAY}</td><td>{@link #setSctpNoDelay(boolean)}}</td>
+ * <td>{@link io.netty.channel.ChannelOption#SO_RCVBUF}</td><td>{@link #setReceiveBufferSize(int)}</td>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_RCVBUF}</td><td>{@link #setReceiveBufferSize(int)}</td>
+ * <td>{@link io.netty.channel.ChannelOption#SO_SNDBUF}</td><td>{@link #setSendBufferSize(int)}</td>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_SNDBUF}</td><td>{@link #setSendBufferSize(int)}</td>
+ * <td>{@link SctpChannelOption#SCTP_NODELAY}</td><td>{@link #setSctpNoDelay(boolean)}}</td>
  * </tr><tr>
  * <td>{@link SctpChannelOption#SCTP_INIT_MAXSTREAMS}</td><td>{@link #setInitMaxStreams(InitMaxStreams)}</td>
  * </tr>

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -277,7 +277,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
                 ctx.channel().eventLoop().schedule(new Runnable() {
                     @Override
                     public void run() {
-                       config.setAutoRead(true);
+                        config.setAutoRead(true);
                     }
                 }, 1, TimeUnit.SECONDS);
             }

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -459,7 +459,7 @@ interface Unsafe {
         SocketAddress remoteAddress();
 
         /**
-         * Register the {@link Channel} of the {@link ChannelPromise} with the {@link EventLoop} and notify
+         * Register the {@link Channel} of the {@link ChannelPromise} and notify
          * the {@link ChannelFuture} once the registration was complete.
          */
         void register(EventLoop eventLoop, ChannelPromise promise);

File: transport/src/main/java/io/netty/channel/ChannelFuture.java
Patch:
@@ -50,8 +50,8 @@
  * +--------------------------+    |    | Completed with failure    |
  * |      isDone() = <b>false</b>    |    |    +---------------------------+
  * |   isSuccess() = false    |----+---->   isDone() = <b>true</b>         |
- * | isCancelled() = false    |    |    | cause() = <b>non-null</b>     |
- * |    cause() = null     |    |    +===========================+
+ * | isCancelled() = false    |    |    |    cause() = <b>non-null</b>     |
+ * |       cause() = null     |    |    +===========================+
  * +--------------------------+    |    | Completed by cancellation |
  *                                 |    +---------------------------+
  *                                 +---->      isDone() = <b>true</b>      |

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -56,7 +56,7 @@
  * {@link ChannelPipeline} it belongs to via a context object.  Using the
  * context object, the {@link ChannelHandler} can pass events upstream or
  * downstream, modify the pipeline dynamically, or store the information
- *  (using {@link AttributeKey}s) which is specific to the handler.
+ * (using {@link AttributeKey}s) which is specific to the handler.
  *
  * <h3>State management</h3>
  *
@@ -104,7 +104,7 @@
  *
  * </pre>
  *
- * <h4>Using {@link AttributeKey}</h4>
+ * <h4>Using {@link AttributeKey}s</h4>
  *
  * Although it's recommended to use member variables to store the state of a
  * handler, for some reason you might not want to create many handler instances.
@@ -138,7 +138,7 @@
  *     ...
  * }
  * </pre>
- * Now that the state of the handler isattached to the {@link ChannelHandlerContext}, you can add the
+ * Now that the state of the handler is attached to the {@link ChannelHandlerContext}, you can add the
  * same handler instance to different pipelines:
  * <pre>
  * public class DataServerInitializer extends {@link ChannelInitializer}&lt{@link Channel}&gt {

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -99,7 +99,7 @@ public static <T> ChannelOption<T> valueOf(Class<?> firstNameComponent, String s
             valueOf("DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION");
 
     /**
-     * Creates a new {@link ChannelOption} with the specified {@code name}.
+     * Creates a new {@link ChannelOption} with the specified unique {@code name}.
      */
     private ChannelOption(int id, String name) {
         super(id, name);

File: transport/src/main/java/io/netty/channel/embedded/package-info.java
Patch:
@@ -15,7 +15,7 @@
  */
 
 /**
- * A virtual {@link Channel} that helps wrapping a series of handlers to
+ * A virtual {@link io.netty.channel.Channel} that helps wrapping a series of handlers to
  * unit test the handlers or use them in non-I/O context.
  */
 package io.netty.channel.embedded;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
Patch:
@@ -22,9 +22,9 @@ public final class EpollChannelOption {
 
     public static final ChannelOption<Boolean> TCP_CORK = ChannelOption.valueOf(T, "TCP_CORK");
     public static final ChannelOption<Boolean> SO_REUSEPORT = ChannelOption.valueOf(T, "SO_REUSEPORT");
-    public static final ChannelOption<Boolean> TCP_KEEPIDLE = ChannelOption.valueOf(T, "TCP_KEEPIDLE");
-    public static final ChannelOption<Boolean> TCP_KEEPINTVL = ChannelOption.valueOf(T, "TCP_KEEPINTVL");
-    public static final ChannelOption<Boolean> TCP_KEEPCNT = ChannelOption.valueOf(T, "TCP_KEEPCNT");
+    public static final ChannelOption<Integer> TCP_KEEPIDLE = ChannelOption.valueOf(T, "TCP_KEEPIDLE");
+    public static final ChannelOption<Integer> TCP_KEEPINTVL = ChannelOption.valueOf(T, "TCP_KEEPINTVL");
+    public static final ChannelOption<Integer> TCP_KEEPCNT = ChannelOption.valueOf(T, "TCP_KEEPCNT");
 
     private EpollChannelOption() { }
 

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
Patch:
@@ -198,7 +198,7 @@ static ChunkType mapChunkType(byte type) {
             return ChunkType.COMPRESSED_DATA;
         } else if (type == 1) {
             return ChunkType.UNCOMPRESSED_DATA;
-        } else if (type == -0x80) {
+        } else if (type == (byte) 0xff) {
             return ChunkType.STREAM_IDENTIFIER;
         } else if ((type & 0x80) == 0x80) {
             return ChunkType.RESERVED_SKIPPABLE;

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
Patch:
@@ -40,7 +40,7 @@ public class SnappyFramedEncoder extends MessageToByteEncoder<ByteBuf> {
      * type 0xff, a length field of 0x6, and 'sNaPpY' in ASCII.
      */
     private static final byte[] STREAM_START = {
-        -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59
+        (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59
     };
 
     private final Snappy snappy = new Snappy();

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
Patch:
@@ -43,7 +43,7 @@ public void testSmallAmountOfDataIsUncompressed() throws Exception {
         assertTrue(channel.finish());
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+            (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
              0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y'
         });
 
@@ -61,7 +61,7 @@ public void testLargeAmountOfDataIsCompressed() throws Exception {
         assertTrue(channel.finish());
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+            (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
              0x00, 0x0E, 0x00, 0x00, 0x3b, 0x36, -0x7f, 0x37,
                    0x14, 0x10,
                    'n', 'e', 't', 't', 'y',
@@ -83,7 +83,7 @@ public void testStreamStartIsOnlyWrittenOnce() throws Exception {
         assertTrue(channel.finish());
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+            (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
              0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',
              0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',
         });

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
Patch:
@@ -301,7 +301,7 @@ private boolean doWriteMessage(Object msg) throws IOException {
         }
 
         if (remoteAddress == null) {
-            remoteAddress = this.remote;
+            remoteAddress = remote;
             if (remoteAddress == null) {
                 throw new NotYetConnectedException();
             }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java
Patch:
@@ -124,7 +124,7 @@ void epollInReady() {
                 //
                 // See https://github.com/netty/netty/issues/2254
                 if (!config.isAutoRead() && !readPending) {
-                    clearEpollIn();
+                    clearEpollIn0();
                 }
             }
         }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -355,7 +355,7 @@ private void closeOnRead(ChannelPipeline pipeline) {
             inputShutdown = true;
             if (isOpen()) {
                 if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
-                    clearEpollIn();
+                    clearEpollIn0();
                     pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
                 } else {
                     close(voidPromise());
@@ -657,7 +657,7 @@ public void run() {
                 //
                 // See https://github.com/netty/netty/issues/2254
                 if (!config.isAutoRead() && !readPending) {
-                    clearEpollIn();
+                    clearEpollIn0();
                 }
             }
         }

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -233,6 +233,7 @@ int normalizeCapacity(int reqCapacity) {
             // Doubled
 
             int normalizedCapacity = reqCapacity;
+            normalizedCapacity --;
             normalizedCapacity |= normalizedCapacity >>>  1;
             normalizedCapacity |= normalizedCapacity >>>  2;
             normalizedCapacity |= normalizedCapacity >>>  4;

File: example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java
Patch:
@@ -29,7 +29,6 @@
 
 public class MemcacheClientHandler extends ChannelDuplexHandler {
 
-
     /**
      * Transforms basic string requests to binary memcache requests
      */

File: example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java
Patch:
@@ -74,7 +74,7 @@ public class HttpServerInitializer extends ChannelInitializer<SocketChannel> {
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
 
-        CorsConfig corsConfig = CorsConfig.anyOrigin().build();
+        CorsConfig corsConfig = CorsConfig.withAnyOrigin().build();
         pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("decoder", new HttpRequestDecoder());
         pipeline.addLast("aggregator", new HttpObjectAggregator(65536));

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.channel.epoll;
 
+import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.MultithreadEventLoopGroup;
 import io.netty.util.concurrent.EventExecutor;
@@ -68,7 +69,7 @@ public void setIoRatio(int ioRatio) {
     }
 
     @Override
-    protected EventExecutor newChild(Executor executor, Object... args) throws Exception {
+    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
         return new EpollEventLoop(this, executor, (Integer) args[0]);
     }
 }

File: transport/src/main/java/io/netty/channel/ChannelHandlerAppender.java
Patch:
@@ -192,7 +192,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
                 } else {
                     name = e.name;
                 }
-                pipeline.addAfter(dctx.executor, oldName, name, e.handler);
+                pipeline.addAfter(dctx.invoker, oldName, name, e.handler);
             }
         } finally {
             if (selfRemoval) {

File: transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel.nio;
 
 import io.netty.channel.Channel;
+import io.netty.channel.EventLoop;
 import io.netty.channel.MultithreadEventLoopGroup;
 import io.netty.util.concurrent.EventExecutor;
 
@@ -92,8 +93,7 @@ public void rebuildSelectors() {
     }
 
     @Override
-    protected EventExecutor newChild(
-            Executor executor, Object... args) throws Exception {
+    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
         return new NioEventLoop(this, executor, (SelectorProvider) args[0]);
     }
 }

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -67,6 +67,9 @@ public EventLoop next() {
         return (EventLoop) super.next();
     }
 
+    @Override
+    protected abstract EventLoop newChild(Executor executor, Object... args) throws Exception;
+
     @Override
     public ChannelFuture register(Channel channel) {
         return next().register(channel);

File: example/src/main/java/io/netty/example/localecho/LocalEcho.java
Patch:
@@ -20,10 +20,10 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.handler.logging.LogLevel;
@@ -44,7 +44,7 @@ public void run() throws Exception {
         // Address to bind on / connect to.
         final LocalAddress addr = new LocalAddress(port);
 
-        EventLoopGroup serverGroup = new LocalEventLoopGroup();
+        EventLoopGroup serverGroup = new DefaultEventLoopGroup();
         EventLoopGroup clientGroup = new NioEventLoopGroup(); // NIO event loops are also OK
         try {
             // Note that we can use any event loop to ensure certain local channels

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.util.AbstractReferenceCounted;
 import io.netty.util.ReferenceCountUtil;
@@ -43,7 +42,7 @@
 
 public class DefaultChannelPipelineTest {
 
-    private static final EventLoopGroup group = new LocalEventLoopGroup(1);
+    private static final EventLoopGroup group = new DefaultEventLoopGroup(1);
 
     private Channel self;
     private Channel peer;

File: codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigTest.java
Patch:
@@ -101,7 +101,7 @@ public void emptyPreflightResponseHeaders() {
 
     @Test (expected = IllegalArgumentException.class)
     public void shouldThrowIfValueIsNull() {
-        withOrigin("*").preflightResponseHeader("HeaderName", null).build();
+        withOrigin("*").preflightResponseHeader("HeaderName", new Object[]{null}).build();
     }
 
 }

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -31,7 +31,7 @@ abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
     protected T memory;
     protected int offset;
     protected int length;
-    private int maxLength;
+    int maxLength;
 
     private ByteBuffer tmpNioBuf;
 
@@ -142,7 +142,7 @@ protected final void deallocate() {
             final long handle = this.handle;
             this.handle = -1;
             memory = null;
-            chunk.arena.free(chunk, handle);
+            chunk.arena.free(chunk, handle, maxLength);
             recycle();
         }
     }

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -39,15 +39,15 @@ public abstract class Recycler<T> {
         // In the future, we might have different maxCapacity for different object types.
         // e.g. io.netty.recycler.maxCapacity.writeTask
         //      io.netty.recycler.maxCapacity.outboundBuffer
-        int maxCapacity = SystemPropertyUtil.getInt("io.netty.recycler.maxCapacity.default", 0);
+        int maxCapacity = SystemPropertyUtil.getInt("io.netty.recycler.maxCapacity", 0);
         if (maxCapacity <= 0) {
             // TODO: Some arbitrary large number - should adjust as we get more production experience.
             maxCapacity = 262144;
         }
 
         DEFAULT_MAX_CAPACITY = maxCapacity;
         if (logger.isDebugEnabled()) {
-            logger.debug("-Dio.netty.recycler.maxCapacity.default: {}", DEFAULT_MAX_CAPACITY);
+            logger.debug("-Dio.netty.recycler.maxCapacity: {}", DEFAULT_MAX_CAPACITY);
         }
 
         INITIAL_CAPACITY = Math.min(DEFAULT_MAX_CAPACITY, 256);

File: transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollTestUtils.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.testsuite.transport.TestsuitePermutation;
 import io.netty.util.concurrent.DefaultThreadFactory;
 
@@ -31,9 +30,9 @@ final class EpollTestUtils {
     private static final int WORKERS = 3;
 
     private static final EventLoopGroup epollBossGroup =
-            new NioEventLoopGroup(BOSSES, new DefaultThreadFactory("testsuite-epoll-boss", true));
+            new EpollEventLoopGroup(BOSSES, new DefaultThreadFactory("testsuite-epoll-boss", true));
     private static final EventLoopGroup epollWorkerGroup =
-            new NioEventLoopGroup(WORKERS, new DefaultThreadFactory("testsuite-epoll-worker", true));
+            new EpollEventLoopGroup(WORKERS, new DefaultThreadFactory("testsuite-epoll-worker", true));
 
     static List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
         return Collections.<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>>singletonList(

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -85,7 +85,7 @@ public SocketSslEchoTest(
         this.useCompositeByteBuf = useCompositeByteBuf;
     }
 
-    @Test
+    @Test(timeout = 30000)
     public void testSslEcho() throws Throwable {
         run();
     }
@@ -94,7 +94,7 @@ public void testSslEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         testSslEcho(sb, cb, true);
     }
 
-    @Test
+    @Test(timeout = 30000)
     public void testSslEchoNotAutoRead() throws Throwable {
         run();
     }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java
Patch:
@@ -47,6 +47,7 @@ protected boolean isCompatible(EventLoop loop) {
     @Override
     protected void doBind(SocketAddress localAddress) throws Exception {
         InetSocketAddress addr = (InetSocketAddress) localAddress;
+        checkResolvable(addr);
         Native.bind(fd, addr.getAddress(), addr.getPort());
         local = addr;
         Native.listen(fd, config.getBacklog());

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -41,6 +41,7 @@
 import java.net.ConnectException;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -528,11 +529,13 @@ void epollOutReady() {
          */
         private boolean doConnect(InetSocketAddress remoteAddress, InetSocketAddress localAddress) throws Exception {
             if (localAddress != null) {
+                checkResolvable(localAddress);
                 Native.bind(fd, localAddress.getAddress(), localAddress.getPort());
             }
 
             boolean success = false;
             try {
+                checkResolvable(remoteAddress);
                 boolean connected = Native.connect(fd, remoteAddress.getAddress(),
                         remoteAddress.getPort());
                 if (!connected) {

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
Patch:
@@ -299,7 +299,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
-        return (ByteBuffer) buffer.duplicate().position(index).limit(length);
+        return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);
     }
 
     @Override

File: common/src/main/java/io/netty/util/Recycler.java
Patch:
@@ -35,7 +35,6 @@ public abstract class Recycler<T> {
     private static final int DEFAULT_MAX_CAPACITY;
     private static final int INITIAL_CAPACITY;
 
-
     static {
         // In the future, we might have different maxCapacity for different object types.
         // e.g. io.netty.recycler.maxCapacity.writeTask

File: handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java
Patch:
@@ -19,6 +19,6 @@
  * Used in {@link IpFilterRule} to decide if a matching IP Address should be allowed or denied to connect.
  */
 public enum IpFilterRuleType {
-    ALLOW,
-    DENY
+    ACCEPT,
+    REJECT
 }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
Patch:
@@ -323,15 +323,15 @@ private void processReady(long[] events, int ready) {
                 AbstractEpollChannel ch = ids.get(id);
                 if (ch != null) {
                     AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) ch.unsafe();
-                    if (write) {
+                    if (write && ch.isOpen()) {
                         // force flush of data as the epoll is writable again
                         unsafe.epollOutReady();
                     }
-                    if (read) {
+                    if (read && ch.isOpen()) {
                         // Something is ready to read, so consume it now
                         unsafe.epollInReady();
                     }
-                    if (close) {
+                    if (close && ch.isOpen()) {
                         unsafe.epollRdHupReady();
                     }
                 }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
Patch:
@@ -113,7 +113,7 @@ public static boolean connect(int fd, InetAddress addr, int port) throws IOExcep
         return connect(fd, address, scopeId, port);
     }
     public static native boolean connect(int fd, byte[] address, int scopeId, int port) throws IOException;
-    public static native void finishConnect(int fd) throws IOException;
+    public static native boolean finishConnect(int fd) throws IOException;
 
     public static native InetSocketAddress remoteAddress(int fd);
     public static native InetSocketAddress localAddress(int fd);

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java
Patch:
@@ -385,7 +385,7 @@ private void verifyCrc(ByteBuf in) {
      * You can lookup the details in the ZLIB RFC:
      * <a href="http://tools.ietf.org/html/rfc1950#section-2.2">RFC 1950</a>.
      */
-    private boolean looksLikeZlib(short cmf_flg) {
+    private static boolean looksLikeZlib(short cmf_flg) {
         return (cmf_flg & 0x7800) == 0x7800 &&
                 cmf_flg % 31 == 0;
     }

File: common/src/main/java/io/netty/util/internal/AppendableCharSequence.java
Patch:
@@ -31,6 +31,7 @@ public AppendableCharSequence(int length) {
 
     private AppendableCharSequence(char[] chars) {
         this.chars = chars;
+        pos = chars.length;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -156,7 +156,7 @@ public final ChannelFuture handshake(Channel channel, FullHttpRequest req,
                                             HttpHeaders responseHeaders, final ChannelPromise promise) {
 
         if (logger.isDebugEnabled()) {
-            logger.debug("%s WebSocket version %s server handshake", channel, version());
+            logger.debug("{} WebSocket version {} server handshake", channel, version());
         }
         FullHttpResponse response = newHandshakeResponse(req, responseHeaders);
         ChannelPipeline p = channel.pipeline();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -111,7 +111,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         String accept = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug("WebSocket version 07 server handshake key: {}, response: %s.", key, accept);
+            logger.debug("WebSocket version 07 server handshake key: {}, response: {}.", key, accept);
         }
 
         res.headers().add(Names.UPGRADE, WEBSOCKET.toLowerCase());

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
Patch:
@@ -510,7 +510,6 @@ public void testGarbageHeaders() {
         assertThat(ch.readInbound(), is(nullValue()));
     }
 
-
     /**
      * Tests if the decoder produces one and only {@link LastHttpContent} when an invalid chunk is received and
      * the connection is closed.

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
Patch:
@@ -470,6 +470,7 @@ private HttpContent invalidChunk(Exception cause) {
         checkpoint(State.BAD_MESSAGE);
         HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);
         chunk.setDecoderResult(DecoderResult.failure(cause));
+        message = null;
         return chunk;
     }
 

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java
Patch:
@@ -123,7 +123,7 @@ void epollInReady() {
                 // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                 //
                 // See https://github.com/netty/netty/issues/2254
-                if (config.isAutoRead() && !readPending) {
+                if (!config.isAutoRead() && !readPending) {
                     clearEpollIn();
                 }
             }

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -648,7 +648,7 @@ public void run() {
                 // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                 //
                 // See https://github.com/netty/netty/issues/2254
-                if (config.isAutoRead() && !readPending) {
+                if (!config.isAutoRead() && !readPending) {
                     clearEpollIn();
                 }
             }

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -152,7 +152,7 @@ public void read() {
                 // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                 //
                 // See https://github.com/netty/netty/issues/2254
-                if (config.isAutoRead() && !readPending) {
+                if (!config.isAutoRead() && !readPending) {
                     removeReadOp();
                 }
             }

File: transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
Patch:
@@ -112,7 +112,7 @@ public void read() {
                 // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                 //
                 // See https://github.com/netty/netty/issues/2254
-                if (config.isAutoRead() && !readPending) {
+                if (!config.isAutoRead() && !readPending) {
                     removeReadOp();
                 }
             }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -189,6 +189,7 @@ public void testOversizedRequestWith100Continue() {
 
         assertEquals(HttpHeaders.getContentLength(fullMsg), fullMsg.content().readableBytes());
 
+        fullMsg.release();
         assertFalse(embedder.finish());
     }
 

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -567,9 +567,9 @@ private void notifyListeners() {
                         final GenericFutureListener<? extends Future<V>> l =
                                 (GenericFutureListener<? extends Future<V>>) listeners;
                         notifyListener0(this, l);
-                        this.listeners = null;
                     }
                 } finally {
+                    this.listeners = null;
                     LISTENER_STACK_DEPTH.set(stackDepth);
                 }
                 return;

File: transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
Patch:
@@ -47,6 +47,7 @@
  * maximal performance.
  */
 public final class EpollSocketChannel extends AbstractEpollChannel implements SocketChannel {
+
     private final EpollSocketChannelConfig config;
 
     /**
@@ -61,8 +62,7 @@ public final class EpollSocketChannel extends AbstractEpollChannel implements So
     private volatile boolean outputShutdown;
 
     EpollSocketChannel(Channel parent, int fd) {
-        super(parent, fd, Native.EPOLLIN);
-        active = true;
+        super(parent, fd, Native.EPOLLIN, true);
         config = new EpollSocketChannelConfig(this);
     }
 

File: buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java
Patch:
@@ -21,6 +21,8 @@
  */
 public interface ByteBufAllocator {
 
+    ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;
+
     /**
      * Allocate a {@link ByteBuf}. If it is a direct or heap buffer
      * depends on the actual implementation.

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.channel.nio.AbstractNioByteChannel;
 import io.netty.channel.socket.SocketChannelConfig;
 
@@ -31,15 +30,14 @@
  */
 public class DefaultChannelConfig implements ChannelConfig {
 
-    private static final ByteBufAllocator DEFAULT_ALLOCATOR = UnpooledByteBufAllocator.DEFAULT;
     private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = AdaptiveRecvByteBufAllocator.DEFAULT;
     private static final MessageSizeEstimator DEFAULT_MSG_SIZE_ESTIMATOR = DefaultMessageSizeEstimator.DEFAULT;
 
     private static final int DEFAULT_CONNECT_TIMEOUT = 30000;
 
     protected final Channel channel;
 
-    private volatile ByteBufAllocator allocator = DEFAULT_ALLOCATOR;
+    private volatile ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;
     private volatile RecvByteBufAllocator rcvBufAllocator = DEFAULT_RCVBUF_ALLOCATOR;
     private volatile MessageSizeEstimator msgSizeEstimator = DEFAULT_MSG_SIZE_ESTIMATOR;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerAppender;
 
 
 /**
@@ -24,8 +24,7 @@
  *
  * @see HttpClientCodec
  */
-public final class HttpServerCodec
-        extends CombinedChannelDuplexHandler<HttpRequestDecoder, HttpResponseEncoder> {
+public final class HttpServerCodec extends ChannelHandlerAppender {
 
     /**
      * Creates a new instance with the default decoder options

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
Patch:
@@ -15,12 +15,12 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerAppender;
 
 /**
  * A combination of {@link SpdyFrameDecoder} and {@link SpdyFrameEncoder}.
  */
-public final class SpdyFrameCodec extends CombinedChannelDuplexHandler<SpdyFrameDecoder, SpdyFrameEncoder> {
+public final class SpdyFrameCodec extends ChannelHandlerAppender {
     /**
      * Creates a new instance with the specified {@code version} and
      * the default decoder and encoder options

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
Patch:
@@ -15,13 +15,12 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerAppender;
 
 /**
  * A combination of {@link SpdyHttpDecoder} and {@link SpdyHttpEncoder}
  */
-public final class SpdyHttpCodec
-        extends CombinedChannelDuplexHandler<SpdyHttpDecoder, SpdyHttpEncoder> {
+public final class SpdyHttpCodec extends ChannelHandlerAppender {
     /**
      * Creates a new instance with the specified decoder options.
      */

File: transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
Patch:
@@ -18,9 +18,9 @@
 import java.net.SocketAddress;
 
 /**
- *  Combines a {@link ChannelInboundHandler} and a {@link ChannelOutboundHandler} into one {@link ChannelHandler}.
- *
+ * @deprecated Use {@link ChannelHandlerAppender} instead.
  */
+@Deprecated
 public class CombinedChannelDuplexHandler<I extends ChannelInboundHandler, O extends ChannelOutboundHandler>
         extends ChannelDuplexHandler {
 

File: buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
Patch:
@@ -717,7 +717,7 @@ public boolean release() {
         boolean deallocated =  super.release();
         if (deallocated) {
             leak.close();
-        } else{
+        } else {
             leak.record();
         }
         return deallocated;

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -1880,4 +1880,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
 
     @Override
     public abstract ByteBuf touch();
+
+    @Override
+    public abstract ByteBuf touch(Object hint);
 }

File: buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
Patch:
@@ -45,4 +45,7 @@ public interface ByteBufHolder extends ReferenceCounted {
 
     @Override
     ByteBufHolder touch();
+
+    @Override
+    ByteBufHolder touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
Patch:
@@ -32,6 +32,9 @@ public interface FullHttpMessage extends HttpMessage, LastHttpContent {
     @Override
     FullHttpMessage touch();
 
+    @Override
+    FullHttpMessage touch(Object hint);
+
     @Override
     FullHttpMessage duplicate();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
Patch:
@@ -32,6 +32,9 @@ public interface FullHttpRequest extends HttpRequest, FullHttpMessage {
     @Override
     FullHttpRequest touch();
 
+    @Override
+    FullHttpRequest touch(Object hint);
+
     @Override
     FullHttpRequest duplicate();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
Patch:
@@ -32,6 +32,9 @@ public interface FullHttpResponse extends HttpResponse, FullHttpMessage {
     @Override
     FullHttpResponse touch();
 
+    @Override
+    FullHttpResponse touch(Object hint);
+
     @Override
     FullHttpResponse duplicate();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
Patch:
@@ -41,4 +41,7 @@ public interface HttpContent extends HttpObject, ByteBufHolder {
 
     @Override
     HttpContent touch();
+
+    @Override
+    HttpContent touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
Patch:
@@ -133,4 +133,7 @@ public HttpData retain(int increment) {
 
     @Override
     public abstract HttpData touch();
+
+    @Override
+    public abstract HttpData touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
Patch:
@@ -45,4 +45,7 @@ public interface Attribute extends HttpData {
 
     @Override
     Attribute touch();
+
+    @Override
+    Attribute touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
Patch:
@@ -70,4 +70,7 @@ public interface FileUpload extends HttpData {
 
     @Override
     FileUpload touch();
+
+    @Override
+    FileUpload touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
Patch:
@@ -211,4 +211,7 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
 
     @Override
     HttpData touch();
+
+    @Override
+    HttpData touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpData.java
Patch:
@@ -44,4 +44,7 @@ enum HttpDataType {
 
     @Override
     InterfaceHttpData touch();
+
+    @Override
+    InterfaceHttpData touch(Object hint);
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
Patch:
@@ -53,4 +53,7 @@ public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
 
     @Override
     SpdyDataFrame touch();
+
+    @Override
+    SpdyDataFrame touch(Object hint);
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
Patch:
@@ -33,6 +33,9 @@ public interface FullMemcacheMessage extends MemcacheMessage, LastMemcacheConten
     @Override
     FullMemcacheMessage touch();
 
+    @Override
+    FullMemcacheMessage touch(Object hint);
+
     @Override
     FullMemcacheMessage duplicate();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
Patch:
@@ -42,4 +42,7 @@ public interface MemcacheContent extends MemcacheObject, ByteBufHolder {
 
     @Override
     MemcacheContent touch();
+
+    @Override
+    MemcacheContent touch(Object hint);
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
Patch:
@@ -36,4 +36,7 @@ public interface MemcacheMessage extends MemcacheObject, ReferenceCounted {
 
     @Override
     MemcacheMessage touch();
+
+    @Override
+    MemcacheMessage touch(Object hint);
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
Patch:
@@ -66,4 +66,7 @@ public interface BinaryMemcacheMessage<H extends BinaryMemcacheMessageHeader> ex
 
     @Override
     BinaryMemcacheMessage<H> touch();
+
+    @Override
+    BinaryMemcacheMessage<H> touch(Object hint);
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
Patch:
@@ -36,4 +36,7 @@ public interface BinaryMemcacheRequest extends BinaryMemcacheMessage<BinaryMemca
 
     @Override
     BinaryMemcacheRequest touch();
+
+    @Override
+    BinaryMemcacheRequest touch(Object hint);
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
Patch:
@@ -36,4 +36,7 @@ public interface BinaryMemcacheResponse extends BinaryMemcacheMessage<BinaryMemc
 
     @Override
     BinaryMemcacheResponse touch();
+
+    @Override
+    BinaryMemcacheResponse touch(Object hint);
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
Patch:
@@ -34,6 +34,9 @@ public interface FullBinaryMemcacheRequest extends BinaryMemcacheRequest, FullMe
     @Override
     FullBinaryMemcacheRequest touch();
 
+    @Override
+    FullBinaryMemcacheRequest touch(Object hint);
+
     @Override
     FullBinaryMemcacheRequest duplicate();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
Patch:
@@ -34,6 +34,9 @@ public interface FullBinaryMemcacheResponse extends BinaryMemcacheResponse, Full
     @Override
     FullBinaryMemcacheResponse touch();
 
+    @Override
+    FullBinaryMemcacheResponse touch(Object hint);
+
     @Override
     FullBinaryMemcacheResponse duplicate();
 }

File: transport/src/main/java/io/netty/channel/FileRegion.java
Patch:
@@ -89,4 +89,7 @@ public interface FileRegion extends ReferenceCounted {
 
     @Override
     FileRegion touch();
+
+    @Override
+    FileRegion touch(Object hint);
 }

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -108,7 +108,7 @@ protected void deallocate() {
             }
 
             @Override
-            public ReferenceCounted touch() {
+            public ReferenceCounted touch(Object hint) {
                 return this;
             }
         };

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -1877,4 +1877,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
 
     @Override
     public abstract ByteBuf retain();
+
+    @Override
+    public abstract ByteBuf touch();
 }

File: buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
Patch:
@@ -42,4 +42,7 @@ public interface ByteBufHolder extends ReferenceCounted {
 
     @Override
     ByteBufHolder retain(int increment);
+
+    @Override
+    ByteBufHolder touch();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
Patch:
@@ -29,6 +29,9 @@ public interface FullHttpMessage extends HttpMessage, LastHttpContent {
     @Override
     FullHttpMessage retain();
 
+    @Override
+    FullHttpMessage touch();
+
     @Override
     FullHttpMessage duplicate();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
Patch:
@@ -29,6 +29,9 @@ public interface FullHttpRequest extends HttpRequest, FullHttpMessage {
     @Override
     FullHttpRequest retain();
 
+    @Override
+    FullHttpRequest touch();
+
     @Override
     FullHttpRequest duplicate();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
Patch:
@@ -29,6 +29,9 @@ public interface FullHttpResponse extends HttpResponse, FullHttpMessage {
     @Override
     FullHttpResponse retain();
 
+    @Override
+    FullHttpResponse touch();
+
     @Override
     FullHttpResponse duplicate();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
Patch:
@@ -38,4 +38,7 @@ public interface HttpContent extends HttpObject, ByteBufHolder {
 
     @Override
     HttpContent retain(int increment);
+
+    @Override
+    HttpContent touch();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
Patch:
@@ -130,4 +130,7 @@ public HttpData retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public abstract HttpData touch();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
Patch:
@@ -42,4 +42,7 @@ public interface Attribute extends HttpData {
 
     @Override
     Attribute retain(int increment);
+
+    @Override
+    Attribute touch();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
Patch:
@@ -67,4 +67,7 @@ public interface FileUpload extends HttpData {
 
     @Override
     FileUpload retain(int increment);
+
+    @Override
+    FileUpload touch();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
Patch:
@@ -208,4 +208,7 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
 
     @Override
     HttpData retain(int increment);
+
+    @Override
+    HttpData touch();
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
Patch:
@@ -50,4 +50,7 @@ public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
 
     @Override
     SpdyDataFrame retain(int increment);
+
+    @Override
+    SpdyDataFrame touch();
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
Patch:
@@ -68,7 +68,7 @@ private static final class TestHttpData extends AbstractMemoryHttpData {
          * @param charset Used charset for data decoding.
          * @param size    Expected data block size.
          */
-        protected TestHttpData(String name, Charset charset, long size) {
+        private TestHttpData(String name, Charset charset, long size) {
             super(name, charset, size);
         }
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
Patch:
@@ -31,6 +31,8 @@ public interface FullMemcacheMessage extends MemcacheMessage, LastMemcacheConten
     FullMemcacheMessage retain();
 
     @Override
-    FullMemcacheMessage duplicate();
+    FullMemcacheMessage touch();
 
+    @Override
+    FullMemcacheMessage duplicate();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
Patch:
@@ -40,4 +40,6 @@ public interface MemcacheContent extends MemcacheObject, ByteBufHolder {
     @Override
     MemcacheContent retain(int increment);
 
+    @Override
+    MemcacheContent touch();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
Patch:
@@ -34,4 +34,6 @@ public interface MemcacheMessage extends MemcacheObject, ReferenceCounted {
     @Override
     MemcacheMessage retain(int increment);
 
+    @Override
+    MemcacheMessage touch();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
Patch:
@@ -64,4 +64,6 @@ public interface BinaryMemcacheMessage<H extends BinaryMemcacheMessageHeader> ex
     @Override
     BinaryMemcacheMessage<H> retain(int increment);
 
+    @Override
+    BinaryMemcacheMessage<H> touch();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
Patch:
@@ -32,6 +32,8 @@ public interface FullBinaryMemcacheRequest extends BinaryMemcacheRequest, FullMe
     FullBinaryMemcacheRequest retain();
 
     @Override
-    FullBinaryMemcacheRequest duplicate();
+    FullBinaryMemcacheRequest touch();
 
+    @Override
+    FullBinaryMemcacheRequest duplicate();
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
Patch:
@@ -32,6 +32,8 @@ public interface FullBinaryMemcacheResponse extends BinaryMemcacheResponse, Full
     FullBinaryMemcacheResponse retain();
 
     @Override
-    FullBinaryMemcacheResponse duplicate();
+    FullBinaryMemcacheResponse touch();
 
+    @Override
+    FullBinaryMemcacheResponse duplicate();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
Patch:
@@ -914,7 +914,7 @@ public void destroy() {
     public void cleanFiles() {
         checkDestroyed();
 
-        factory.cleanRequestHttpDatas(request);
+        factory.cleanRequestHttpData(request);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -213,7 +213,7 @@ public HttpPostRequestEncoder(
      * Clean all HttpDatas (on Disk) for the current request.
      */
     public void cleanFiles() {
-        factory.cleanRequestHttpDatas(request);
+        factory.cleanRequestHttpData(request);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
Patch:
@@ -718,7 +718,7 @@ public void destroy() {
     public void cleanFiles() {
         checkDestroyed();
 
-        factory.cleanRequestHttpDatas(request);
+        factory.cleanRequestHttpData(request);
     }
 
     /**

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -130,14 +130,14 @@ public void run() throws Exception {
             // Simple Get form: no factory used (not usable)
             List<Entry<String, String>> headers = formGet(b, host, port, get, uriSimple);
             if (headers == null) {
-                factory.cleanAllHttpDatas();
+                factory.cleanAllHttpData();
                 return;
             }
 
             // Simple Post form: factory used for big attributes
             List<InterfaceHttpData> bodylist = formPost(b, host, port, uriSimple, file, factory, headers);
             if (bodylist == null) {
-                factory.cleanAllHttpDatas();
+                factory.cleanAllHttpData();
                 return;
             }
 
@@ -148,7 +148,7 @@ public void run() throws Exception {
             group.shutdownGracefully();
 
             // Really clean all temporary files if they still exist
-            factory.cleanAllHttpDatas();
+            factory.cleanAllHttpData();
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -206,7 +206,7 @@ private void cleanup() {
             // Clean-up the previous encoder if not cleaned up correctly.
             if (decoder.finish()) {
                 for (;;) {
-                    ByteBuf buf = (ByteBuf) decoder.readOutbound();
+                    ByteBuf buf = decoder.readOutbound();
                     if (buf == null) {
                         break;
                     }
@@ -234,7 +234,7 @@ private void finishDecode(List<Object> out) {
 
     private void fetchDecoderOutput(List<Object> out) {
         for (;;) {
-            ByteBuf buf = (ByteBuf) decoder.readInbound();
+            ByteBuf buf = decoder.readInbound();
             if (buf == null) {
                 break;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -247,7 +247,7 @@ private void cleanup() {
             // Clean-up the previous encoder if not cleaned up correctly.
             if (encoder.finish()) {
                 for (;;) {
-                    ByteBuf buf = (ByteBuf) encoder.readOutbound();
+                    ByteBuf buf = encoder.readOutbound();
                     if (buf == null) {
                         break;
                     }
@@ -275,7 +275,7 @@ private void finishEncode(List<Object> out) {
 
     private void fetchEncoderOutput(List<Object> out) {
         for (;;) {
-            ByteBuf buf = (ByteBuf) encoder.readOutbound();
+            ByteBuf buf = encoder.readOutbound();
             if (buf == null) {
                 break;
             }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
Patch:
@@ -70,7 +70,7 @@ public void testEmptyContentCompression() throws Exception {
 
         ch.writeOutbound(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK));
 
-        HttpResponse res = (HttpResponse) ch.readOutbound();
+        HttpResponse res = ch.readOutbound();
         assertThat(res, is(not(instanceOf(FullHttpResponse.class))));
         assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));
         assertThat(res.headers().get(Names.CONTENT_LENGTH), is(nullValue()));
@@ -79,12 +79,12 @@ public void testEmptyContentCompression() throws Exception {
         ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);
 
         HttpContent chunk;
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk, is(instanceOf(HttpContent.class)));
         assertThat(chunk.content().isReadable(), is(true));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         assertThat(chunk.content().isReadable(), is(false));
         chunk.release();

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -72,15 +72,15 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(ch.readOutbound());
-        HttpResponse res = (HttpResponse) ch2.readInbound();
+        HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals("ws://example.com/chat", res.headers().get(Names.SEC_WEBSOCKET_LOCATION));
         if (subProtocol) {
             Assert.assertEquals("chat", res.headers().get(Names.SEC_WEBSOCKET_PROTOCOL));
         } else {
             Assert.assertNull(res.headers().get(Names.SEC_WEBSOCKET_PROTOCOL));
         }
-        LastHttpContent content = (LastHttpContent) ch2.readInbound();
+        LastHttpContent content = ch2.readInbound();
 
         Assert.assertEquals("8jKS'y:G*Co,Wxa-", content.content().toString(CharsetUtil.US_ASCII));
         content.release();

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
Patch:
@@ -67,11 +67,11 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
                     "ws://example.com/chat", null, false, Integer.MAX_VALUE).handshake(ch, req);
         }
 
-        ByteBuf resBuf = (ByteBuf) ch.readOutbound();
+        ByteBuf resBuf = ch.readOutbound();
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(resBuf);
-        HttpResponse res = (HttpResponse) ch2.readInbound();
+        HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals(
                 "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.headers().get(Names.SEC_WEBSOCKET_ACCEPT));

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
Patch:
@@ -67,11 +67,11 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
                     "ws://example.com/chat", null, false, Integer.MAX_VALUE).handshake(ch, req);
         }
 
-        ByteBuf resBuf = (ByteBuf) ch.readOutbound();
+        ByteBuf resBuf = ch.readOutbound();
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(resBuf);
-        HttpResponse res = (HttpResponse) ch2.readInbound();
+        HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals(
                 "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.headers().get(Names.SEC_WEBSOCKET_ACCEPT));

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -57,7 +57,7 @@ public void shouldAggregateChunksOnDecode() {
         incoming.writeBytes(SET_REQUEST_WITH_CONTENT);
         channel.writeInbound(incoming);
 
-        FullBinaryMemcacheRequest request = (FullBinaryMemcacheRequest) channel.readInbound();
+        FullBinaryMemcacheRequest request = channel.readInbound();
 
         assertThat(request, instanceOf(FullBinaryMemcacheRequest.class));
         assertThat(request, notNullValue());

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
Patch:
@@ -30,7 +30,7 @@ public void testAuthRequestDecoder() {
         SocksAuthRequestDecoder decoder = new SocksAuthRequestDecoder();
         EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
-        msg = (SocksAuthRequest) embedder.readInbound();
+        msg = embedder.readInbound();
         assertEquals(msg.username(), username);
         assertEquals(msg.username(), password);
         assertNull(embedder.readInbound());

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
Patch:
@@ -31,7 +31,7 @@ private static void testSocksAuthResponseDecoderWithDifferentParams(SocksAuthSta
         SocksAuthResponseDecoder decoder = new SocksAuthResponseDecoder();
         EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
-        msg = (SocksAuthResponse) embedder.readInbound();
+        msg = embedder.readInbound();
         assertSame(msg.authStatus(), authStatus);
         assertNull(embedder.readInbound());
     }

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
Patch:
@@ -39,7 +39,7 @@ private static void testSocksCmdRequestDecoderWithDifferentParams(SocksCmdType c
         if (msg.addressType() == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksRequest);
         } else {
-            msg = (SocksCmdRequest) embedder.readInbound();
+            msg = embedder.readInbound();
             assertSame(msg.cmdType(), cmdType);
             assertSame(msg.addressType(), addressType);
             assertEquals(msg.host(), host);

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
Patch:
@@ -35,7 +35,7 @@ private static void testSocksCmdResponseDecoderWithDifferentParams(
         if (addressType == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksResponse);
         } else {
-            msg = (SocksResponse) embedder.readInbound();
+            msg = embedder.readInbound();
             assertEquals(((SocksCmdResponse) msg).cmdStatus(), cmdStatus);
             if (host != null) {
                 assertEquals(((SocksCmdResponse) msg).host(), host);

File: codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java
Patch:
@@ -43,7 +43,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] {'a', 'b', 'c'});
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(b, buf.skipBytes(1));
         b.release();
         buf.release();
@@ -68,7 +68,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         });
 
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(b, Unpooled.wrappedBuffer(new byte[] { 'b', 'c'}));
         buf.release();
         b.release();

File: codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 
 public class LengthFieldBasedFrameDecoderTest {
 
@@ -43,7 +43,7 @@ public void testDiscardTooLongFrame1() {
         }
         Assert.assertTrue(channel.finish());
 
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(5, b.readableBytes());
         Assert.assertEquals(1, b.readInt());
         Assert.assertEquals('a', b.readByte());
@@ -73,7 +73,7 @@ public void testDiscardTooLongFrame2() {
 
         Assert.assertTrue(channel.finish());
 
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(5, b.readableBytes());
         Assert.assertEquals(1, b.readInt());
         Assert.assertEquals('a', b.readByte());

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.EmptyArrays;
 import org.junit.Before;
@@ -50,7 +49,7 @@ public void testEncode() {
     @Test
     public void testEncodeEmpty() {
         ch.writeOutbound(EmptyArrays.EMPTY_BYTES);
-        assertThat((ByteBuf) ch.readOutbound(), is(Unpooled.EMPTY_BUFFER));
+        assertThat((ByteBuf) ch.readOutbound(), is(EMPTY_BUFFER));
     }
 
     @Test

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
 
 public class SnappyFramedEncoderTest {
@@ -90,7 +90,7 @@ public void testStreamStartIsOnlyWrittenOnce() throws Exception {
 
         CompositeByteBuf actual = Unpooled.compositeBuffer();
         for (;;) {
-            ByteBuf m = (ByteBuf) channel.readOutbound();
+            ByteBuf m = channel.readOutbound();
             if (m == null) {
                 break;
             }
@@ -145,7 +145,7 @@ public void testInputBufferOverseek() throws Exception {
 
         channel.writeOutbound(in);
         assertTrue(channel.finish());
-        ByteBuf out = (ByteBuf) channel.readOutbound();
+        ByteBuf out = channel.readOutbound();
         out.release();
     }
 }

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -122,7 +122,7 @@ private static void testIdentity(ByteBuf in) {
         EmbeddedChannel decoder = new EmbeddedChannel(new SnappyFramedDecoder());
         try {
             encoder.writeOutbound(in.copy());
-            ByteBuf compressed = (ByteBuf) encoder.readOutbound();
+            ByteBuf compressed = encoder.readOutbound();
             assertThat(compressed, is(notNullValue()));
             assertThat(compressed, is(not(in)));
             decoder.writeInbound(compressed.retain());

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
Patch:
@@ -53,7 +53,7 @@ public void testSimpleUnmarshalling() throws IOException {
         ch.writeInbound(input(testBytes));
         assertTrue(ch.finish());
 
-        String unmarshalled = (String) ch.readInbound();
+        String unmarshalled = ch.readInbound();
 
         assertEquals(testObject, unmarshalled);
 
@@ -87,7 +87,7 @@ public void testFragmentedUnmarshalling() throws IOException {
         ch.writeInbound(buffer);
         assertTrue(ch.finish());
 
-        String unmarshalled = (String) ch.readInbound();
+        String unmarshalled = ch.readInbound();
 
         assertEquals(testObject, unmarshalled);
 

File: codec/src/test/java/io/netty/handler/codec/string/StringEncoderTest.java
Patch:
@@ -29,7 +29,7 @@ public void testEncode() {
         EmbeddedChannel channel = new EmbeddedChannel(new StringEncoder());
         Assert.assertTrue(channel.writeOutbound(msg));
         Assert.assertTrue(channel.finish());
-        ByteBuf buf = (ByteBuf) channel.readOutbound();
+        ByteBuf buf = channel.readOutbound();
         byte[] data = new byte[buf.readableBytes()];
         buf.readBytes(data);
         Assert.assertArrayEquals(msg.getBytes(CharsetUtil.UTF_8), data);

File: codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java
Patch:
@@ -150,7 +150,7 @@ private static void testDecodeWithXml(String xml, Object... expected) {
         }
         List<Object> actual = new ArrayList<Object>();
         for (;;) {
-            ByteBuf buf = (ByteBuf) ch.readInbound();
+            ByteBuf buf = ch.readInbound();
             if (buf == null) {
                 break;
             }

File: handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
Patch:
@@ -23,14 +23,15 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
+
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.nio.channels.Channels;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
 
 public class ChunkedWriteHandlerTest {
@@ -193,7 +194,7 @@ private static void check(ChunkedInput<?>... inputs) {
         int i = 0;
         int read = 0;
         for (;;) {
-            ByteBuf buffer = (ByteBuf) ch.readOutbound();
+            ByteBuf buffer = ch.readOutbound();
             if (buffer == null) {
                 break;
             }

File: codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java
Patch:
@@ -155,6 +155,7 @@ private static void testDecodeWithXml(String xml, Object... expected) {
                 break;
             }
             actual.add(buf.toString(CharsetUtil.UTF_8));
+            buf.release();
         }
 
         if (cause != null) {
@@ -175,5 +176,4 @@ private String sample(String number) throws IOException, URISyntaxException {
         byte[] buf = Files.readAllBytes(Paths.get(url.toURI()));
         return StandardCharsets.UTF_8.decode(ByteBuffer.wrap(buf)).toString();
     }
-
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java
Patch:
@@ -23,5 +23,5 @@
  * Currently it just acts as a common denominator, but will certainly include methods once the ascii protocol
  * is implemented.
  */
-public abstract class MemcacheObjectDecoder extends ByteToMessageDecoder {
+public abstract class AbstractMemcacheObjectDecoder extends ByteToMessageDecoder {
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
Patch:
@@ -25,13 +25,13 @@
 import java.util.List;
 
 /**
- * A general purpose {@link MemcacheObjectEncoder} that encodes {@link MemcacheMessage}s.
+ * A general purpose {@link AbstractMemcacheObjectEncoder} that encodes {@link MemcacheMessage}s.
  * <p/>
  * <p>Note that this class is designed to be extended, especially because both the binary and ascii protocol
  * require different treatment of their messages. Since the content chunk writing is the same for both, the encoder
  * abstracts this right away.</p>
  */
-public abstract class MemcacheObjectEncoder<M extends MemcacheMessage> extends MessageToMessageEncoder<Object> {
+public abstract class AbstractMemcacheObjectEncoder<M extends MemcacheMessage> extends MessageToMessageEncoder<Object> {
 
     private boolean expectingMoreContent;
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessageHeader.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * The default implementation of a {@link BinaryMemcacheMessageHeader}.
  */
-public abstract class DefaultBinaryMemcacheMessageHeader implements BinaryMemcacheMessageHeader {
+public abstract class AbstractBinaryMemcacheMessageHeader implements BinaryMemcacheMessageHeader {
 
     private byte magic;
     private byte opcode;

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
Patch:
@@ -45,7 +45,7 @@ public final class BinaryMemcacheClientCodec
      * Create a new {@link BinaryMemcacheClientCodec} with the default settings applied.
      */
     public BinaryMemcacheClientCodec() {
-        this(BinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
+        this(AbstractBinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
     }
 
     /**

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
Patch:
@@ -20,20 +20,20 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.memcache.AbstractMemcacheObjectAggregator;
 import io.netty.handler.codec.memcache.FullMemcacheMessage;
 import io.netty.handler.codec.memcache.LastMemcacheContent;
 import io.netty.handler.codec.memcache.MemcacheContent;
 import io.netty.handler.codec.memcache.MemcacheMessage;
 import io.netty.handler.codec.memcache.MemcacheObject;
-import io.netty.handler.codec.memcache.MemcacheObjectAggregator;
 import io.netty.util.ReferenceCountUtil;
 
 import java.util.List;
 
 /**
- * A {@link MemcacheObjectAggregator} for the binary protocol.
+ * A memcache object aggregator for the binary protocol.
  */
-public class BinaryMemcacheObjectAggregator extends MemcacheObjectAggregator {
+public class BinaryMemcacheObjectAggregator extends AbstractMemcacheObjectAggregator {
 
     private boolean tooLongFrameFound;
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
Patch:
@@ -21,7 +21,7 @@
  * The decoder part which takes care of decoding the request-specific headers.
  */
 public class BinaryMemcacheRequestDecoder
-    extends BinaryMemcacheDecoder<BinaryMemcacheRequest, BinaryMemcacheRequestHeader> {
+    extends AbstractBinaryMemcacheDecoder<BinaryMemcacheRequest, BinaryMemcacheRequestHeader> {
 
     public BinaryMemcacheRequestDecoder() {
         this(DEFAULT_MAX_CHUNK_SIZE);

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java
Patch:
@@ -21,7 +21,7 @@
  * The encoder part which takes care of encoding the request headers.
  */
 public class BinaryMemcacheRequestEncoder
-    extends BinaryMemcacheEncoder<BinaryMemcacheRequest, BinaryMemcacheRequestHeader> {
+    extends AbstractBinaryMemcacheEncoder<BinaryMemcacheRequest, BinaryMemcacheRequestHeader> {
 
     @Override
     protected void encodeHeader(ByteBuf buf, BinaryMemcacheRequestHeader header) {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
Patch:
@@ -21,7 +21,7 @@
  * The decoder which takes care of decoding the response headers.
  */
 public class BinaryMemcacheResponseDecoder
-    extends BinaryMemcacheDecoder<BinaryMemcacheResponse, BinaryMemcacheResponseHeader> {
+    extends AbstractBinaryMemcacheDecoder<BinaryMemcacheResponse, BinaryMemcacheResponseHeader> {
 
     public BinaryMemcacheResponseDecoder() {
         this(DEFAULT_MAX_CHUNK_SIZE);

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java
Patch:
@@ -21,7 +21,7 @@
  * The encoder which takes care of encoding the response headers.
  */
 public class BinaryMemcacheResponseEncoder
-    extends BinaryMemcacheEncoder<BinaryMemcacheResponse, BinaryMemcacheResponseHeader> {
+    extends AbstractBinaryMemcacheEncoder<BinaryMemcacheResponse, BinaryMemcacheResponseHeader> {
 
     @Override
     protected void encodeHeader(ByteBuf buf, BinaryMemcacheResponseHeader header) {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
Patch:
@@ -28,7 +28,7 @@ public class BinaryMemcacheServerCodec
     extends CombinedChannelDuplexHandler<BinaryMemcacheRequestDecoder, BinaryMemcacheResponseEncoder> {
 
     public BinaryMemcacheServerCodec() {
-        this(BinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
+        this(AbstractBinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
     }
 
     public BinaryMemcacheServerCodec(int decodeChunkSize) {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequestHeader.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * The default implementation of a {@link BinaryMemcacheRequestHeader}.
  */
-public class DefaultBinaryMemcacheRequestHeader extends DefaultBinaryMemcacheMessageHeader
+public class DefaultBinaryMemcacheRequestHeader extends AbstractBinaryMemcacheMessageHeader
     implements BinaryMemcacheRequestHeader {
 
     /**

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponseHeader.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * The default implementation of a {@link BinaryMemcacheResponseHeader}.
  */
-public class DefaultBinaryMemcacheResponseHeader extends DefaultBinaryMemcacheMessageHeader
+public class DefaultBinaryMemcacheResponseHeader extends AbstractBinaryMemcacheMessageHeader
     implements BinaryMemcacheResponseHeader {
 
     /**

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java
Patch:
@@ -32,7 +32,7 @@
 import static org.hamcrest.core.IsNull.nullValue;
 
 /**
- * Verifies the correct functionality of the {@link BinaryMemcacheDecoder}.
+ * Verifies the correct functionality of the {@link AbstractBinaryMemcacheDecoder}.
  * <p/>
  * While technically there are both a {@link BinaryMemcacheRequestDecoder} and a {@link BinaryMemcacheResponseDecoder}
  * they implement the same basics and just differ in the type of headers returned.

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java
Patch:
@@ -31,7 +31,7 @@
 import static org.junit.Assert.*;
 
 /**
- * Verifies the correct functionality of the {@link BinaryMemcacheEncoder}.
+ * Verifies the correct functionality of the {@link AbstractBinaryMemcacheEncoder}.
  */
 public class BinaryMemcacheEncoderTest {
 

File: common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java
Patch:
@@ -79,7 +79,6 @@ public void debug(Throwable t) {
     @Override
     public void info(Throwable t) {
         info(EXCEPTION_MESSAGE, t);
-
     }
 
     @Override

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java
Patch:
@@ -127,6 +127,8 @@ public void shouldDecodeRequestWithChunkedContent() {
         assertThat(header.getExtrasLength(), is((byte) 0));
         assertThat(header.getTotalBodyLength(), is(11));
 
+        request.release();
+
         int expectedContentChunks = 4;
         for (int i = 1; i <= expectedContentChunks; i++) {
             MemcacheContent content = (MemcacheContent) channel.readInbound();
@@ -136,6 +138,7 @@ public void shouldDecodeRequestWithChunkedContent() {
                 assertThat(content, instanceOf(LastMemcacheContent.class));
             }
             assertThat(content.content().readableBytes(), is(2));
+            content.release();
         }
         assertThat(channel.readInbound(), nullValue());
     }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoder.java
Patch:
@@ -96,7 +96,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         return;
                     }
 
-                    currentKey = readBytes(ctx.alloc(), in, keyLength).toString(CharsetUtil.UTF_8);
+                    currentKey = in.toString(in.readerIndex(), keyLength, CharsetUtil.UTF_8);
+                    in.skipBytes(keyLength);
                 }
 
                 out.add(buildMessage(currentHeader, currentExtras, currentKey));

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -71,5 +71,7 @@ public void shouldAggregateChunksOnDecode() {
         request.release();
 
         assertThat(channel.readInbound(), nullValue());
+
+        channel.finish();
     }
 }

File: codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
Patch:
@@ -68,8 +68,8 @@ public void shouldAggregateChunksOnDecode() {
         assertThat(request.content().readableBytes(), is(8));
         assertThat(request.content().readByte(), is((byte) 0x01));
         assertThat(request.content().readByte(), is((byte) 0x02));
+        request.release();
 
         assertThat(channel.readInbound(), nullValue());
     }
-
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
Patch:
@@ -45,6 +45,7 @@
  *
  */
 public class HttpPostStandardRequestDecoder implements InterfaceHttpPostRequestDecoder {
+
     /**
      * Factory used to create InterfaceHttpData
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
Patch:
@@ -123,7 +123,7 @@ public String toString() {
             HttpPostBodyUtil.FORM_DATA + "; " + HttpPostBodyUtil.NAME + "=\"" + getName() +
             "\"; " + HttpPostBodyUtil.FILENAME + "=\"" + filename + "\"\r\n" +
             HttpHeaders.Names.CONTENT_TYPE + ": " + contentType +
-            (charset != null? "; " + HttpHeaders.Values.CHARSET + '=' + charset + "\r\n" : "\r\n") +
+            (getCharset() != null? "; " + HttpHeaders.Values.CHARSET + '=' + getCharset() + "\r\n" : "\r\n") +
             HttpHeaders.Names.CONTENT_LENGTH + ": " + length() + "\r\n" +
             "Completed: " + isCompleted() +
             "\r\nIsInMemory: " + isInMemory();

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheObject.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.memcache;
 
 import io.netty.handler.codec.DecoderResult;
-import io.netty.util.AbstractReferenceCounted;
 
 /**
  * The default {@link MemcacheObject} implementation.

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
Patch:
@@ -16,14 +16,15 @@
 package io.netty.handler.codec.memcache;
 
 import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.ChannelPipeline;
 
 /**
  * An Memcache content chunk.
  * <p/>
  * A MemcacheObjectDecoder generates {@link MemcacheContent} after
  * {@link MemcacheMessage} when the content is large. If you prefer not to
  * receive {@link MemcacheContent} in your handler, place a aggregator
- * after MemcacheObjectDecoder in the {@link io.netty.channel.ChannelPipeline}.
+ * after MemcacheObjectDecoder in the {@link ChannelPipeline}.
  */
 public interface MemcacheContent extends MemcacheObject, ByteBufHolder {
 

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
Patch:
@@ -25,6 +25,7 @@ public interface BinaryMemcacheRequest extends BinaryMemcacheMessage<BinaryMemca
      *
      * @return the required request header.
      */
+    @Override
     BinaryMemcacheRequestHeader getHeader();
 
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestHeader.java
Patch:
@@ -21,7 +21,7 @@
  * <p/>
  * <p>Note that while the additional field in the request is called "reserved", it can still be used for a custom
  * memcached implementation. It will not be mirrored back like the
- * {@link io.netty.handler.codec.memcache.binary.BinaryMemcacheRequestHeader#getOpaque()} field, because in the
+ * {@link BinaryMemcacheRequestHeader#getOpaque()} field, because in the
  * {@link BinaryMemcacheResponseHeader}, the status field is set there instead.</p>
  */
 public interface BinaryMemcacheRequestHeader extends BinaryMemcacheMessageHeader {

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
Patch:
@@ -25,6 +25,7 @@ public interface BinaryMemcacheResponse extends BinaryMemcacheMessage<BinaryMemc
      *
      * @return the required response header.
      */
+    @Override
     BinaryMemcacheResponseHeader getHeader();
 
 }

File: codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
Patch:
@@ -28,7 +28,7 @@ public class BinaryMemcacheServerCodec
     extends CombinedChannelDuplexHandler<BinaryMemcacheRequestDecoder, BinaryMemcacheResponseEncoder> {
 
     public BinaryMemcacheServerCodec() {
-        this(BinaryMemcacheRequestDecoder.DEFAULT_MAX_CHUNK_SIZE);
+        this(BinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
     }
 
     public BinaryMemcacheServerCodec(int decodeChunkSize) {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
Patch:
@@ -64,6 +64,7 @@ public void setValue(String value) throws IOException {
             throw new NullPointerException("value");
         }
         byte [] bytes = value.getBytes(charset.name());
+        checkSize(bytes.length);
         ByteBuf buffer = wrappedBuffer(bytes);
         if (definedSize > 0) {
             definedSize = buffer.readableBytes();
@@ -74,6 +75,7 @@ public void setValue(String value) throws IOException {
     @Override
     public void addContent(ByteBuf buffer, boolean last) throws IOException {
         int localsize = buffer.readableBytes();
+        checkSize(size + localsize);
         if (definedSize > 0 && definedSize < size + localsize) {
             definedSize = size + localsize;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -188,7 +188,9 @@ public HttpPostRequestEncoder(
         if (charset == null) {
             throw new NullPointerException("charset");
         }
-        if (request.getMethod() != HttpMethod.POST) {
+        HttpMethod method = request.getMethod();
+        if (!(method.equals(HttpMethod.POST) || method.equals(HttpMethod.PUT)
+                || method.equals(HttpMethod.PATCH) || method.equals(HttpMethod.OPTIONS))) {
             throw new ErrorDataEncoderException("Cannot create a Encoder if not a POST");
         }
         this.request = request;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
Patch:
@@ -53,6 +53,7 @@ public void setValue(String value) throws IOException {
             throw new NullPointerException("value");
         }
         byte [] bytes = value.getBytes(charset.name());
+        checkSize(bytes.length);
         ByteBuf buffer = wrappedBuffer(bytes);
         if (definedSize > 0) {
             definedSize = buffer.readableBytes();
@@ -63,6 +64,7 @@ public void setValue(String value) throws IOException {
     @Override
     public void addContent(ByteBuf buffer, boolean last) throws IOException {
         int localsize = buffer.readableBytes();
+        checkSize(size + localsize);
         if (definedSize > 0 && definedSize < size + localsize) {
             definedSize = size + localsize;
         }

File: transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
Patch:
@@ -29,6 +29,7 @@
 import java.io.IOException;
 import java.util.Map;
 
+import static io.netty.channel.ChannelOption.*;
 import static io.netty.channel.sctp.SctpChannelOption.*;
 
 /**

File: transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
Patch:
@@ -27,6 +27,7 @@
 import java.io.IOException;
 import java.util.Map;
 
+import static io.netty.channel.ChannelOption.*;
 import static io.netty.channel.udt.UdtChannelOption.*;
 
 /**

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -79,7 +79,6 @@ public void run() {
         }
     };
 
-
     private volatile State state;
     private volatile LocalChannel peer;
     private volatile LocalAddress localAddress;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -461,14 +461,14 @@ public boolean cancel(boolean mayInterruptIfRunning) {
     public boolean setUncancellable() {
         Object result = this.result;
         if (isDone0(result)) {
-            return isCancelled0(result);
+            return !isCancelled0(result);
         }
 
         synchronized (this) {
             // Allow only once.
             result = this.result;
             if (isDone0(result)) {
-                return isCancelled0(result);
+                return !isCancelled0(result);
             }
 
             this.result = UNCANCELLABLE;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -461,14 +461,14 @@ public boolean cancel(boolean mayInterruptIfRunning) {
     public boolean setUncancellable() {
         Object result = this.result;
         if (isDone0(result)) {
-            return false;
+            return isCancelled0(result);
         }
 
         synchronized (this) {
             // Allow only once.
             result = this.result;
             if (isDone0(result)) {
-                return false;
+                return isCancelled0(result);
             }
 
             this.result = UNCANCELLABLE;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -40,10 +40,10 @@
  * <pre>
  * {@link ChannelPipeline} p = ...;
  * ...
+ * p.addLast("encoder", new {@link HttpResponseEncoder}());
  * p.addLast("decoder", new {@link HttpRequestDecoder}());
  * p.addLast("aggregator", <b>new {@link HttpObjectAggregator}(1048576)</b>);
  * ...
- * p.addLast("encoder", new {@link HttpResponseEncoder}());
  * p.addLast("handler", new HttpRequestHandler());
  * </pre>
  */

File: common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java
Patch:
@@ -4406,7 +4406,7 @@ public boolean equals(Object o) {
                             (containsAll(c) && c.containsAll(this))));
         }
 
-        public ConcurrentHashMapSpliterator<K> spliterator() {
+        public ConcurrentHashMapSpliterator<K> spliterator166() {
             Node<K,V>[] t;
             ConcurrentHashMapV8<K,V> m = map;
             long n = m.sumCount();
@@ -4464,7 +4464,7 @@ public final boolean addAll(Collection<? extends V> c) {
             throw new UnsupportedOperationException();
         }
 
-        public ConcurrentHashMapSpliterator<V> spliterator() {
+        public ConcurrentHashMapSpliterator<V> spliterator166() {
             Node<K,V>[] t;
             ConcurrentHashMapV8<K,V> m = map;
             long n = m.sumCount();
@@ -4552,7 +4552,7 @@ public final boolean equals(Object o) {
                             (containsAll(c) && c.containsAll(this))));
         }
 
-        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> spliterator() {
+        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> spliterator166() {
             Node<K,V>[] t;
             ConcurrentHashMapV8<K,V> m = map;
             long n = m.sumCount();

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java
Patch:
@@ -22,7 +22,7 @@
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.ConcurrentMap;
+import java.util.Map;
 
 /**
  * Default factory giving Attribute and FileUpload according to constructor
@@ -47,8 +47,7 @@ public class DefaultHttpDataFactory implements HttpDataFactory {
     /**
      * Keep all HttpDatas until cleanAllHttpDatas() is called.
      */
-    private final ConcurrentMap<HttpRequest, List<HttpData>> requestFileDeleteMap =
-            PlatformDependent.newConcurrentHashMap();
+    private final Map<HttpRequest, List<HttpData>> requestFileDeleteMap = PlatformDependent.newConcurrentHashMap();
 
     /**
      * HttpData will be in memory if less than default size (16KB).

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -140,18 +140,18 @@ protected void addSpdyHandlers(ChannelHandlerContext ctx, SpdyVersion version) {
         pipeline.addLast("spdyHttpEncoder", new SpdyHttpEncoder(version));
         pipeline.addLast("spdyHttpDecoder", new SpdyHttpDecoder(version, maxSpdyContentLength));
         pipeline.addLast("spdyStreamIdHandler", new SpdyHttpResponseStreamIdHandler());
-        pipeline.addLast("httpRquestHandler", createHttpRequestHandlerForSpdy());
+        pipeline.addLast("httpRequestHandler", createHttpRequestHandlerForSpdy());
     }
 
     /**
      * Add all {@link ChannelHandler}'s that are needed for HTTP.
      */
     protected void addHttpHandlers(ChannelHandlerContext ctx) {
         ChannelPipeline pipeline = ctx.pipeline();
-        pipeline.addLast("httpRquestDecoder", new HttpRequestDecoder());
+        pipeline.addLast("httpRequestDecoder", new HttpRequestDecoder());
         pipeline.addLast("httpResponseEncoder", new HttpResponseEncoder());
         pipeline.addLast("httpChunkAggregator", new HttpObjectAggregator(maxHttpContentLength));
-        pipeline.addLast("httpRquestHandler", createHttpRequestHandlerForHttp());
+        pipeline.addLast("httpRequestHandler", createHttpRequestHandlerForHttp());
     }
 
     /**

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
Patch:
@@ -77,7 +77,8 @@ public void testSocksCmdResponseDecoderIncludingHost() {
                     "testDomain.com", 80);
             testSocksCmdResponseDecoderWithDifferentParams(cmdStatus, SocksAddressType.IPv6,
                     "2001:db8:85a3:42:1000:8a2e:370:7334", 80);
+            testSocksCmdResponseDecoderWithDifferentParams(cmdStatus, SocksAddressType.IPv6,
+                    "1111:111:11:1:0:0:0:1", 80);
         }
     }
-
 }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -108,6 +108,8 @@ public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
             ByteBuf bytes = buf.readBytes(readable);
             buf.release();
             ctx.fireChannelRead(bytes);
+        } else {
+            buf.release();
         }
         cumulation = null;
         ctx.fireChannelReadComplete();

File: example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java
Patch:
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.example.spdyclient;
+package io.netty.example.spdy.client;
 
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
@@ -37,7 +37,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         if (acceptOutboundMessage(msg)) {
             HttpMessage httpMsg = (HttpMessage) msg;
             if (!httpMsg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
-                SpdyHttpHeaders.setStreamId(httpMsg, this.currentStreamId);
+                SpdyHttpHeaders.setStreamId(httpMsg, currentStreamId);
                 // Client stream IDs are always odd
                 currentStreamId += 2;
             }

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -115,13 +115,13 @@
  * {@code @Sharable}
  * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {
  *   private final {@link AttributeKey}&lt{@link Boolean}&gt auth =
- *           new {@link AttributeKey}&lt{@link Boolean}&gt("auth");
+ *           {@link AttributeKey#valueOf(String) AttributeKey.valueOf("auth")};
  *
  *   // This handler will receive a sequence of increasing integers starting
  *   // from 1.
  *   {@code @Override}
  *   public void channelRead({@link ChannelHandlerContext} ctx, {@link Integer} integer) {
- *     {@link Attribute}&lt{@link Boolean}&gt attr = ctx.getAttr(auth);
+ *     {@link Attribute}&lt{@link Boolean}&gt attr = ctx.attr(auth);
  *
  *     {@code @Override}
  *     public void channelRead({@link ChannelHandlerContext} ctx, Message message) {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
Patch:
@@ -206,7 +206,7 @@ public ByteBuf getChunk(int length) throws IOException {
         if (sizeLeft < length) {
             sliceLength = sizeLeft;
         }
-        ByteBuf chunk = byteBuf.slice(chunkPosition, sliceLength);
+        ByteBuf chunk = byteBuf.slice(chunkPosition, sliceLength).retain();
         chunkPosition += sliceLength;
         return chunk;
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java
Patch:
@@ -31,7 +31,8 @@ final class InternalAttribute extends AbstractReferenceCounted implements Interf
     private final List<ByteBuf> value = new ArrayList<ByteBuf>();
     private final Charset charset;
     private int size;
-    public InternalAttribute(Charset charset) {
+
+    InternalAttribute(Charset charset) {
         this.charset = charset;
     }
 
@@ -66,6 +67,7 @@ public void setValue(String value, int rank) {
         ByteBuf old = this.value.set(rank, buf);
         if (old != null) {
             size -= old.readableBytes();
+            old.release();
         }
         size += buf.readableBytes();
     }

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -126,8 +126,9 @@ public boolean isOpen() {
 
     @Override
     public boolean isActive() {
-        return isOpen() && (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
-                || socket.isBound();
+        return isOpen()
+            && ((config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
+                 || socket.isBound());
     }
 
     @Override

File: example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.example.http.cors;
 
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
@@ -26,10 +26,10 @@
  * A simple handler which will simple return a successful Http
  * response for any request.
  */
-public class OkResponseHandler extends ChannelHandlerAdapter {
+public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
         final DefaultHttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         response.headers().set("custom-response-header", "Some value");
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java
Patch:
@@ -41,17 +41,17 @@
  */
 public class HttpChunkedInput implements ChunkedInput<HttpContent> {
 
-    private ChunkedInput<ByteBuf> input;
+    private final ChunkedInput<ByteBuf> input;
+    private final LastHttpContent lastHttpContent;
     private boolean sentLastChunk;
-    private LastHttpContent lastHttpContent;
 
     /**
      * Creates a new instance using the specified input.
      * @param input {@link ChunkedInput} containing data to write
      */
     public HttpChunkedInput(ChunkedInput<ByteBuf> input) {
         this.input = input;
-        this.lastHttpContent = LastHttpContent.EMPTY_LAST_CONTENT;
+        lastHttpContent = LastHttpContent.EMPTY_LAST_CONTENT;
     }
 
     /**

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -190,9 +190,8 @@ public void testChannelHandlerContextNavigation() {
 
     @Test
     public void testFireChannelRegistered() throws Exception {
-        ChannelPipeline pipeline = new LocalChannel().pipeline();
-        group.register(pipeline.channel());
         final CountDownLatch latch = new CountDownLatch(1);
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
         pipeline.addLast(new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {
@@ -204,7 +203,7 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
                 });
             }
         });
-        pipeline.fireChannelRegistered();
+        group.register(pipeline.channel());
         assertTrue(latch.await(2, TimeUnit.SECONDS));
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
Patch:
@@ -106,7 +106,6 @@ protected void initChannel(SocketChannel ch) throws Exception {
         }
     }
 
-
     @Test
     public void testLargeHeaderNameOnSynStreamRequest() throws Exception {
         testLargeHeaderNameOnSynStreamRequest(SpdyVersion.SPDY_3);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -85,7 +85,7 @@ protected void encode(ChannelHandlerContext ctx, SpdyFrame msg, ByteBuf out) thr
         } else if (msg instanceof SpdySynStreamFrame) {
 
             SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            ByteBuf data = headerBlockEncoder.encode(ctx, spdySynStreamFrame);
+            ByteBuf data = headerBlockEncoder.encode(spdySynStreamFrame);
             try {
                 byte flags = spdySynStreamFrame.isLast() ? SPDY_FLAG_FIN : 0;
                 if (spdySynStreamFrame.isUnidirectional()) {
@@ -109,7 +109,7 @@ protected void encode(ChannelHandlerContext ctx, SpdyFrame msg, ByteBuf out) thr
         } else if (msg instanceof SpdySynReplyFrame) {
 
             SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            ByteBuf data = headerBlockEncoder.encode(ctx, spdySynReplyFrame);
+            ByteBuf data = headerBlockEncoder.encode(spdySynReplyFrame);
             try {
                 byte flags = spdySynReplyFrame.isLast() ? SPDY_FLAG_FIN : 0;
                 int headerBlockLength = data.readableBytes();
@@ -184,7 +184,7 @@ protected void encode(ChannelHandlerContext ctx, SpdyFrame msg, ByteBuf out) thr
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            ByteBuf data = headerBlockEncoder.encode(ctx, spdyHeadersFrame);
+            ByteBuf data = headerBlockEncoder.encode(spdyHeadersFrame);
             try {
                 byte flags = spdyHeadersFrame.isLast() ? SPDY_FLAG_FIN : 0;
                 int headerBlockLength = data.readableBytes();

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockEncoder.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerContext;
 import io.netty.util.internal.PlatformDependent;
 
 abstract class SpdyHeaderBlockEncoder {
@@ -33,6 +32,6 @@ static SpdyHeaderBlockEncoder newInstance(
         }
     }
 
-    abstract ByteBuf encode(ChannelHandlerContext ctx, SpdyHeadersFrame frame) throws Exception;
+    abstract ByteBuf encode(SpdyHeadersFrame frame) throws Exception;
     abstract void end();
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelHandlerContext;
 
 import java.util.Set;
 
@@ -51,7 +50,7 @@ private void writeLengthField(ByteBuf buffer, int length) {
     }
 
     @Override
-    public ByteBuf encode(ChannelHandlerContext ctx, SpdyHeadersFrame frame) throws Exception {
+    public ByteBuf encode(SpdyHeadersFrame frame) throws Exception {
         Set<String> names = frame.headers().names();
         int numHeaders = names.size();
         if (numHeaders == 0) {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
Patch:
@@ -468,7 +468,7 @@ public void testGarbageHeaders() {
         ch.writeInbound(Unpooled.wrappedBuffer(data));
 
         // Garbage input should generate the 999 Unknown response.
-        HttpResponse res = ch.readInbound();
+        HttpResponse res = (HttpResponse) ch.readInbound();
         assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_0));
         assertThat(res.getStatus().code(), is(999));
         assertThat(res.getDecoderResult().isFailure(), is(true));

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java
Patch:
@@ -94,7 +94,7 @@ public HttpRequest setProtocolVersion(HttpVersion version) {
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(StringUtil.simpleClassName(this));
-        buf.append(", decodeResult: ");
+        buf.append("(decodeResult: ");
         buf.append(getDecoderResult());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -52,7 +52,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     };
 
     /**
-     * Creates a new group with a generated name amd the provided {@link EventExecutor} to notify the
+     * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the
      * {@link ChannelGroupFuture}s.
      */
     public DefaultChannelGroup(EventExecutor executor) {

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -252,7 +252,9 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {
                 childGroup.register(child).addListener(new ChannelFutureListener() {
                     @Override
                     public void operationComplete(ChannelFuture future) throws Exception {
-                        forceClose(child, future.cause());
+                        if (!future.isSuccess()) {
+                            forceClose(child, future.cause());
+                        }
                     }
                 });
             } catch (Throwable t) {

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -45,7 +45,7 @@ public EventLoop next() {
 
     @Override
     public ChannelFuture register(Channel channel) {
-        return register(channel, channel.newPromise());
+        return register(channel, new DefaultChannelPromise(channel, this));
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
Patch:
@@ -256,9 +256,10 @@ public ChannelFuture register(Channel channel) {
             throw new NullPointerException("channel");
         }
         try {
-            return nextChild().register(channel);
+            EventLoop l = nextChild();
+            return l.register(channel, new DefaultChannelPromise(channel, l));
         } catch (Throwable t) {
-            return channel.newFailedFuture(t);
+            return new FailedChannelFuture(channel, GlobalEventExecutor.INSTANCE, t);
         }
     }
 

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultChannelPromise;
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.concurrent.AbstractEventExecutor;
@@ -90,7 +91,7 @@ public boolean awaitTermination(long timeout, TimeUnit unit)
 
     @Override
     public ChannelFuture register(Channel channel) {
-        return register(channel, channel.newPromise());
+        return register(channel, new DefaultChannelPromise(channel, this));
     }
 
     @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
Patch:
@@ -94,6 +94,7 @@ public void testResponseChunkedExceedMaxChunkSize() {
             HttpContent content = (HttpContent) ch.readInbound();
             assertEquals(32, content.content().readableBytes());
             content.content().readBytes(decodedData, 0, 32);
+            content.release();
 
             content = (HttpContent) ch.readInbound();
             assertEquals(32, content.content().readableBytes());

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -1532,7 +1532,7 @@ public void testCompareTo() {
     @Test
     public void testToString() {
         buffer.clear();
-        buffer.writeBytes(copiedBuffer("Hello, World!", CharsetUtil.ISO_8859_1));
+        buffer.writeBytes(releaseLater(copiedBuffer("Hello, World!", CharsetUtil.ISO_8859_1)));
         assertEquals("Hello, World!", buffer.toString(CharsetUtil.ISO_8859_1));
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
Patch:
@@ -393,7 +393,7 @@ public HttpPostRequestDecoder offer(HttpContent content) throws ErrorDataDecoder
         checkDestroyed();
 
         // Maybe we should better not copy here for performance reasons but this will need
-        // more care by teh caller to release the content in a correct manner later
+        // more care by the caller to release the content in a correct manner later
         // So maybe something to optimize on a later stage
         ByteBuf buf = content.content();
         if (undecodedChunk == null) {

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static io.netty.util.ReferenceCountUtil.releaseLater;
 import static org.junit.Assert.*;
 
 public class SnappyFramedDecoderTest {
@@ -108,7 +109,7 @@ public void testUncompressedDataAppendsToOut() throws Exception {
         channel.writeInbound(in);
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] { 'n', 'e', 't', 't', 'y' });
-        assertEquals(expected, channel.readInbound());
+        assertEquals(releaseLater(expected), releaseLater(channel.readInbound()));
     }
 
     @Test
@@ -124,7 +125,7 @@ public void testCompressedDataDecodesAndAppendsToOut() throws Exception {
         channel.writeInbound(in);
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] { 'n', 'e', 't', 't', 'y' });
-        assertEquals(expected, channel.readInbound());
+        assertEquals(releaseLater(expected), releaseLater(channel.readInbound()));
     }
 
     // The following two tests differ in only the checksum provided for the literal

File: codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
+import static io.netty.util.ReferenceCountUtil.releaseLater;
 import static org.junit.Assert.*;
 
 public class DelimiterBasedFrameDecoderTest {
@@ -44,7 +45,7 @@ public void testFailSlowTooLongFrameRecovery() throws Exception {
             }
 
             ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'A', 0 }));
-            ByteBuf buf = (ByteBuf) ch.readInbound();
+            ByteBuf buf = releaseLater((ByteBuf) ch.readInbound());
             assertEquals("A", buf.toString(CharsetUtil.ISO_8859_1));
         }
     }
@@ -63,7 +64,7 @@ public void testFailFastTooLongFrameRecovery() throws Exception {
             }
 
             ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 0, 'A', 0 }));
-            ByteBuf buf = (ByteBuf) ch.readInbound();
+            ByteBuf buf = releaseLater((ByteBuf) ch.readInbound());
             assertEquals("A", buf.toString(CharsetUtil.ISO_8859_1));
         }
     }

File: codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
+import static io.netty.util.ReferenceCountUtil.releaseLater;
 import static org.junit.Assert.*;
 
 public class LengthFieldBasedFrameDecoderTest {
@@ -42,7 +43,7 @@ public void testFailSlowTooLongFrameRecovery() throws Exception {
             }
 
             ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 1, 'A' }));
-            ByteBuf buf = (ByteBuf) ch.readInbound();
+            ByteBuf buf = releaseLater((ByteBuf) ch.readInbound());
             assertEquals("A", buf.toString(CharsetUtil.ISO_8859_1));
             buf.release();
         }
@@ -62,7 +63,7 @@ public void testFailFastTooLongFrameRecovery() throws Exception {
             }
 
             ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 0, 0, 1, 'A' }));
-            ByteBuf buf = (ByteBuf) ch.readInbound();
+            ByteBuf buf = releaseLater((ByteBuf) ch.readInbound());
             assertEquals("A", buf.toString(CharsetUtil.ISO_8859_1));
             buf.release();
         }

File: codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Test;
 
 import static io.netty.buffer.Unpooled.*;
+import static io.netty.util.ReferenceCountUtil.releaseLater;
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
 
@@ -37,7 +38,7 @@ public void setUp() {
     public void testTinyEncode() {
         byte[] b = { 4, 1, 1, 1, 1 };
         ch.writeOutbound(wrappedBuffer(b, 1, b.length - 1));
-        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(b)));
+        assertThat(releaseLater((ByteBuf) ch.readOutbound()), is(releaseLater(wrappedBuffer(b))));
     }
 
     @Test
@@ -49,6 +50,6 @@ public void testRegularDecode() {
         b[0] = -2;
         b[1] = 15;
         ch.writeOutbound(wrappedBuffer(b, 2, b.length - 2));
-        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(b)));
+        assertThat(releaseLater((ByteBuf) ch.readOutbound()), is(releaseLater(wrappedBuffer(b))));
     }
 }

File: codec/src/test/java/io/netty/handler/codec/string/StringEncoderTest.java
Patch:
@@ -34,5 +34,6 @@ public void testEncode() {
         buf.readBytes(data);
         Assert.assertArrayEquals(msg.getBytes(CharsetUtil.UTF_8), data);
         Assert.assertNull(channel.readOutbound());
+        buf.release();
     }
 }

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -155,7 +155,7 @@ void free(PoolChunk<T> chunk, long handle) {
         if (chunk.unpooled) {
             destroyChunk(chunk);
         } else {
-            synchronized(this) {
+            synchronized (this) {
                 chunk.parent.free(chunk, handle);
             }
         }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -57,7 +57,6 @@ public void testPerformOpeningHandshake() {
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(ch.readOutbound());
-        ch2.writeInbound(ch.readOutbound());
         HttpResponse res = (HttpResponse) ch2.readInbound();
 
         Assert.assertEquals("ws://example.com/chat", res.headers().get(Names.SEC_WEBSOCKET_LOCATION));

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
Patch:
@@ -294,7 +294,7 @@ public boolean contains(String name, String value, boolean ignoreCaseValue) {
         while (e != null) {
             if (e.hash == h && equalsIgnoreCase(name, e.key)) {
                 if (ignoreCaseValue) {
-                    if (e.value.equalsIgnoreCase(value)) {
+                    if (equalsIgnoreCase(e.value, value)) {
                         return true;
                     }
                 } else {

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -237,7 +237,8 @@ public void finishConnect() {
                     t = newT;
                 }
 
-                connectPromise.setFailure(t);
+                // Use tryFailure() instead of setFailure() to avoid the race against cancel().
+                connectPromise.tryFailure(t);
                 closeIfClosed();
             } finally {
                 // Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis > 0 is used

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1257,9 +1257,10 @@ public CompositeByteBuf discardReadComponents() {
 
         // Update indexes and markers.
         Component first = components.get(0);
+        int offset = first.offset;
         updateComponentOffsets(0);
-        setIndex(readerIndex - first.offset, writerIndex - first.offset);
-        adjustMarkers(first.offset);
+        setIndex(readerIndex - offset, writerIndex - offset);
+        adjustMarkers(offset);
         return this;
     }
 

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -114,6 +114,8 @@ public void read() {
                     byteBuf = allocHandle.allocate(allocator);
                     int localReadAmount = doReadBytes(byteBuf);
                     if (localReadAmount <= 0) {
+                        // not was read release the buffer
+                        byteBuf.release();
                         close = localReadAmount < 0;
                         break;
                     }

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -50,9 +50,12 @@ public class ChannelOption<T> extends UniqueName {
     public static final ChannelOption<Boolean> AUTO_READ = valueOf("AUTO_READ");
 
     /**
+     * @deprecated From version 5.0, {@link Channel} will not be closed on write failure.
+     *
      * {@code true} if and only if the {@link Channel} is closed automatically and immediately on write failure.
      * The default is {@code false}.
      */
+    @Deprecated
     public static final ChannelOption<Boolean> AUTO_CLOSE = valueOf("AUTO_CLOSE");
 
     public static final ChannelOption<Boolean> SO_BROADCAST = valueOf("SO_BROADCAST");

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -288,6 +288,9 @@ public static Paritybit valueOf(int value) {
     @Override
     RxtxChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    RxtxChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     RxtxChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
Patch:
@@ -115,6 +115,9 @@ public interface SctpChannelConfig extends ChannelConfig {
     @Override
     SctpChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    SctpChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     SctpChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
Patch:
@@ -110,6 +110,9 @@ public interface SctpServerChannelConfig extends ChannelConfig {
     @Override
     SctpServerChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    SctpServerChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     SctpServerChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
 

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
Patch:
@@ -130,6 +130,9 @@ public interface UdtChannelConfig extends ChannelConfig {
     @Override
     UdtChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    UdtChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     UdtChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
 

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
Patch:
@@ -64,6 +64,9 @@ public interface UdtServerChannelConfig extends UdtChannelConfig {
     @Override
     UdtServerChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    UdtServerChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     UdtServerChannelConfig setProtocolReceiveBufferSize(int size);
 

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -682,7 +682,7 @@ protected void flush0() {
                 doWrite(outboundBuffer);
             } catch (Throwable t) {
                 outboundBuffer.failFlushed(t);
-                if (t instanceof IOException) {
+                if (t instanceof IOException && config().isAutoClose()) {
                     close(voidPromise());
                 }
             } finally {

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -86,6 +86,7 @@ private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Thro
                 }
             }
             pipeline.fireChannelReadComplete();
+            pipeline.fireExceptionCaught(cause);
             if (close || cause instanceof IOException) {
                 closeOnRead(pipeline);
             }

File: transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
Patch:
@@ -174,6 +174,9 @@ public interface DatagramChannelConfig extends ChannelConfig {
     @Override
     DatagramChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    DatagramChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     DatagramChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator);
 }

File: transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
Patch:
@@ -175,6 +175,9 @@ public interface SocketChannelConfig extends ChannelConfig {
     @Override
     SocketChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    SocketChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     SocketChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator);
 }

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
Patch:
@@ -81,6 +81,9 @@ public interface OioServerSocketChannelConfig extends ServerSocketChannelConfig
     @Override
     OioServerSocketChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    OioServerSocketChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     OioServerSocketChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
Patch:
@@ -96,6 +96,9 @@ public interface OioSocketChannelConfig extends SocketChannelConfig {
     @Override
     OioSocketChannelConfig setAutoRead(boolean autoRead);
 
+    @Override
+    OioSocketChannelConfig setAutoClose(boolean autoClose);
+
     @Override
     OioSocketChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
Patch:
@@ -79,6 +79,7 @@ public boolean release(int decrement) {
 
     @Override
     public String toString() {
-        return StringUtil.simpleClassName(this) + "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';
+        return StringUtil.simpleClassName(this) +
+               "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';
     }
 }

File: common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
Patch:
@@ -38,11 +38,11 @@ public final class JavassistTypeParameterMatcherGenerator {
         classPool.appendClassPath(new ClassClassPath(NoOpTypeParameterMatcher.class));
     }
 
-    public void appendClassPath(ClassPath classpath) {
+    public static void appendClassPath(ClassPath classpath) {
         classPool.appendClassPath(classpath);
     }
 
-    public void appendClassPath(String pathname) throws NotFoundException {
+    public static void appendClassPath(String pathname) throws NotFoundException {
         classPool.appendClassPath(pathname);
     }
 

File: transport/src/main/java/io/netty/channel/DefaultFileRegion.java
Patch:
@@ -25,6 +25,9 @@
 
 /**
  * Default {@link FileRegion} implementation which transfer data from a {@link FileChannel}.
+ *
+ * Be aware that the {@link FileChannel} will be automatically closed once {@link #refCnt()} returns
+ * {@code 0}.
  */
 public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion {
 

File: example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
Patch:
@@ -43,7 +43,7 @@ public static String getName() {
 
     @Override
     public void channelRead0(final ChannelHandlerContext ctx, final SocksCmdRequest request) throws Exception {
-        Promise promise = ctx.executor().newPromise();
+        Promise<Channel> promise = ctx.executor().newPromise();
         promise.addListener(
             new GenericFutureListener<Future<Channel>>() {
             @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -69,6 +69,7 @@ public void testSimpleSendWithoutBind() throws Throwable {
         run();
     }
 
+    @SuppressWarnings("deprecation")
     public void testSimpleSendWithoutBind(Bootstrap sb, Bootstrap cb) throws Throwable {
         final CountDownLatch latch = new CountDownLatch(1);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -47,7 +47,7 @@ public static String encode(Cookie cookie) {
             throw new NullPointerException("cookie");
         }
 
-        StringBuilder buf = new StringBuilder(estimateServerLength(cookie));
+        StringBuilder buf = buffer.get();
 
         add(buf, cookie.getName(), cookie.getValue());
 

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -47,7 +47,7 @@ public static String encode(Cookie cookie) {
             throw new NullPointerException("cookie");
         }
 
-        StringBuilder buf = new StringBuilder();
+        StringBuilder buf = new StringBuilder(estimateServerLength(cookie));
 
         add(buf, cookie.getName(), cookie.getValue());
 

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -485,9 +485,10 @@ private final class HashedWheelTimeout implements Timeout {
             this.task = task;
             this.deadline = deadline;
 
-            final long ticks = Math.max(deadline / tickDuration, tick); // Ensure we don't schedule for past.
+            long calculated = deadline / tickDuration;
+            final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past.
             stopIndex = (int) (ticks & mask);
-            remainingRounds = ticks / wheel.length;
+            remainingRounds = (calculated - tick) / wheel.length;
         }
 
         @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -61,7 +61,7 @@ public enum ServerHandshakeStateEvent {
     }
 
     private static final AttributeKey<WebSocketServerHandshaker> HANDSHAKER_ATTR_KEY =
-            new AttributeKey<WebSocketServerHandshaker>(WebSocketServerHandshaker.class.getName());
+            AttributeKey.valueOf(WebSocketServerHandshaker.class.getName() + ".HANDSHAKER");
 
     private final String websocketPath;
     private final String subprotocols;

File: codec/src/main/java/io/netty/handler/codec/DecoderResult.java
Patch:
@@ -19,8 +19,8 @@
 
 public class DecoderResult {
 
-    protected static final Signal SIGNAL_UNFINISHED = new Signal(DecoderResult.class.getName() + ".UNFINISHED");
-    protected static final Signal SIGNAL_SUCCESS = new Signal(DecoderResult.class.getName() + ".SUCCESS");
+    protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class.getName() + ".UNFINISHED");
+    protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class.getName() + ".SUCCESS");
 
     public static final DecoderResult UNFINISHED = new DecoderResult(SIGNAL_UNFINISHED);
     public static final DecoderResult SUCCESS = new DecoderResult(SIGNAL_SUCCESS);

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -266,7 +266,7 @@
  */
 public abstract class ReplayingDecoder<S> extends ByteToMessageDecoder {
 
-    static final Signal REPLAY = new Signal(ReplayingDecoder.class.getName() + ".REPLAY");
+    static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class.getName() + ".REPLAY");
 
     private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer();
     private S state;

File: codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
-
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
 import org.jboss.marshalling.Unmarshaller;
@@ -35,8 +34,8 @@
  */
 public class ContextBoundUnmarshallerProvider extends DefaultUnmarshallerProvider {
 
-    private static final AttributeKey<Unmarshaller> UNMARSHALLER = new AttributeKey<Unmarshaller>(
-            ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");
+    private static final AttributeKey<Unmarshaller> UNMARSHALLER = AttributeKey.valueOf(
+            ContextBoundUnmarshallerProvider.class.getName() + ".UNMARSHALLER");
 
     public ContextBoundUnmarshallerProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         super(factory, config);

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -37,7 +37,7 @@
 public class CompatibleObjectEncoder extends MessageToByteEncoder<Serializable> {
 
     private static final AttributeKey<ObjectOutputStream> OOS =
-            new AttributeKey<ObjectOutputStream>(CompatibleObjectEncoder.class.getName() + ".oos");
+            AttributeKey.valueOf(CompatibleObjectEncoder.class.getName() + ".OOS");
 
     private final int resetInterval;
     private int writtenObjects;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -39,8 +39,8 @@ protected Integer initialValue() {
             return 0;
         }
     };
-    private static final Signal SUCCESS = new Signal(DefaultPromise.class.getName() + ".SUCCESS");
-    private static final Signal UNCANCELLABLE = new Signal(DefaultPromise.class.getName() + ".UNCANCELLABLE");
+    private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class.getName() + ".SUCCESS");
+    private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class.getName() + ".UNCANCELLABLE");
     private final EventExecutor executor;
 
     private volatile Object result;

File: common/src/main/java/io/netty/util/UniqueName.java
Patch:
@@ -19,8 +19,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
+ * @deprecated Known to have problems with class loaders.
+ *
  * Defines a name that must be unique in the map that is provided during construction.
  */
+@Deprecated
 public class UniqueName implements Comparable<UniqueName> {
 
     private static final AtomicInteger nextId = new AtomicInteger();

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
Patch:
@@ -48,6 +48,7 @@ public final class RxtxChannelOption<T> extends ChannelOption<T> {
     public static final RxtxChannelOption<Integer> READ_TIMEOUT =
             new RxtxChannelOption<Integer>("READ_TIMEOUT");
 
+    @SuppressWarnings("deprecation")
     private RxtxChannelOption(String name) {
         super(name);
     }

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
Patch:
@@ -47,6 +47,7 @@ public final class UdtChannelOption<T> extends ChannelOption<T> {
     public static final UdtChannelOption<Integer> SYSTEM_SEND_BUFFER_SIZE = new UdtChannelOption<Integer>(
             "SYSTEM_SEND_BUFFER_SIZE");
 
+    @SuppressWarnings("deprecation")
     private UdtChannelOption(String name) {
         super(name);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -40,11 +40,11 @@ public abstract class WebSocketClientHandshaker {
 
     private final WebSocketVersion version;
 
-    private boolean handshakeComplete;
+    private volatile boolean handshakeComplete;
 
     private final String expectedSubprotocol;
 
-    private String actualSubprotocol;
+    private volatile String actualSubprotocol;
 
     protected final HttpHeaders customHeaders;
 

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -76,9 +76,9 @@
  *     public void userEventTriggered({@link ChannelHandlerContext} ctx, {@link Object} evt) throws {@link Exception} {
  *         if (evt instanceof {@link IdleState}} {
  *             {@link IdleState} e = ({@link IdleState}) evt;
- *             if (e.getState() == {@link IdleState}.READER_IDLE) {
+ *             if (e.state() == {@link IdleState}.READER_IDLE) {
  *                 ctx.close();
- *             } else if (e.getState() == {@link IdleState}.WRITER_IDLE) {
+ *             } else if (e.state() == {@link IdleState}.WRITER_IDLE) {
  *                 ctx.writeAndFlush(new PingMessage());
  *             }
  *         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1025,7 +1025,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
                 @Override
                 public void operationComplete(Future<Channel> future) throws Exception {
                     if (!future.isSuccess()) {
-                        future.cause().printStackTrace();
+                        logger.debug("Failed to complete handshake", future.cause());
                         ctx.close();
                     }
                 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -204,14 +204,14 @@ protected int doReadMessages(List<Object> buf) throws Exception {
         ByteBuf data = allocHandle.allocate(config.getAllocator());
         boolean free = true;
         try {
-            ByteBuffer nioData = data.nioBuffer(data.writerIndex(), data.writableBytes());
-
+            ByteBuffer nioData = data.internalNioBuffer(data.writerIndex(), data.writableBytes());
+            int pos = nioData.position();
             InetSocketAddress remoteAddress = (InetSocketAddress) ch.receive(nioData);
             if (remoteAddress == null) {
                 return 0;
             }
 
-            int readBytes = nioData.position();
+            int readBytes = nioData.position() - pos;
             data.writerIndex(data.writerIndex() + readBytes);
             allocHandle.record(readBytes);
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
Patch:
@@ -98,7 +98,7 @@ public String toString() {
     }
 
     protected void appendHeaders(StringBuilder buf) {
-        for (Map.Entry<String, String> e: headers().entries()) {
+        for (Map.Entry<String, String> e: headers()) {
             buf.append("    ");
             buf.append(e.getKey());
             buf.append(": ");

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -242,7 +242,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
 
             // Ignore trailers in a truncated HEADERS frame.
             if (!spdyHeadersFrame.isTruncated()) {
-                for (Map.Entry<String, String> e: spdyHeadersFrame.headers().entries()) {
+                for (Map.Entry<String, String> e: spdyHeadersFrame.headers()) {
                     fullHttpMessage.headers().add(e.getKey(), e.getValue());
                 }
             }
@@ -311,7 +311,7 @@ private static FullHttpRequest createHttpRequest(int spdyVersion, SpdyHeadersFra
             HttpHeaders.setHost(req, host);
         }
 
-        for (Map.Entry<String, String> e: requestFrame.headers().entries()) {
+        for (Map.Entry<String, String> e: requestFrame.headers()) {
             req.headers().add(e.getKey(), e.getValue());
         }
 
@@ -333,7 +333,7 @@ private static FullHttpResponse createHttpResponse(int spdyVersion, SpdyHeadersF
         SpdyHeaders.removeVersion(spdyVersion, responseFrame);
 
         FullHttpResponse res = new DefaultFullHttpResponse(version, status);
-        for (Map.Entry<String, String> e: responseFrame.headers().entries()) {
+        for (Map.Entry<String, String> e: responseFrame.headers()) {
             res.headers().add(e.getKey(), e.getValue());
         }
 

File: codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
Patch:
@@ -89,7 +89,7 @@ private static void assertHeaders(Object msg, int streamId, boolean last, SpdyHe
             assertTrue(receivedValues.isEmpty());
             spdyHeadersFrame.headers().remove(name);
         }
-        assertTrue(spdyHeadersFrame.headers().entries().isEmpty());
+        assertTrue(spdyHeadersFrame.headers().isEmpty());
     }
 
     private static void testSpdySessionHandler(int version, boolean server) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -177,7 +177,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
             spdyDataFrame.setLast(chunk instanceof LastHttpContent);
             if (chunk instanceof LastHttpContent) {
                 LastHttpContent trailer = (LastHttpContent) chunk;
-                List<Map.Entry<String, String>> trailers = trailer.trailingHeaders().entries();
+                HttpHeaders trailers = trailer.trailingHeaders();
                 if (trailers.isEmpty()) {
                     out.add(spdyDataFrame);
                 } else {

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -71,9 +71,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
             buf.append("HOSTNAME: ").append(getHost(request, "unknown")).append("\r\n");
             buf.append("REQUEST_URI: ").append(request.getUri()).append("\r\n\r\n");
 
-            List<Map.Entry<String, String>> headers = request.headers().entries();
+            HttpHeaders headers = request.headers();
             if (!headers.isEmpty()) {
-                for (Map.Entry<String, String> h: request.headers().entries()) {
+                for (Map.Entry<String, String> h: headers) {
                     String key = h.getKey();
                     String value = h.getValue();
                     buf.append("HEADER: ").append(key).append(" = ").append(value).append("\r\n");

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -114,8 +114,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
             responseContent.append("\r\n\r\n");
 
             // new getMethod
-            List<Entry<String, String>> headers = request.headers().entries();
-            for (Entry<String, String> entry : headers) {
+            for (Entry<String, String> entry : request.headers()) {
                 responseContent.append("HEADER: " + entry.getKey() + '=' + entry.getValue() + "\r\n");
             }
             responseContent.append("\r\n\r\n");

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -351,7 +351,7 @@ private static final class PendingWrite {
         void fail(Throwable cause) {
             ReferenceCountUtil.release(msg);
             if (promise != null) {
-                promise.setFailure(cause);
+                promise.tryFailure(cause);
             }
         }
 

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -477,8 +477,8 @@ public final void bind(final SocketAddress localAddress, final ChannelPromise pr
             try {
                 doBind(localAddress);
             } catch (Throwable t) {
-                closeIfClosed();
                 promise.setFailure(t);
+                closeIfClosed();
                 return;
             }
             if (!wasActive && isActive()) {
@@ -498,8 +498,8 @@ public final void disconnect(final ChannelPromise promise) {
             try {
                 doDisconnect();
             } catch (Throwable t) {
-                closeIfClosed();
                 promise.setFailure(t);
+                closeIfClosed();
                 return;
             }
             if (wasActive && !isActive()) {
@@ -510,8 +510,8 @@ public void run() {
                     }
                 });
             }
-            closeIfClosed(); // doDisconnect() might have closed the channel
             promise.setSuccess();
+            closeIfClosed(); // doDisconnect() might have closed the channel
         }
 
         @Override

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -210,8 +210,8 @@ public void operationComplete(ChannelFuture future) throws Exception {
                     newT.setStackTrace(t.getStackTrace());
                     t = newT;
                 }
-                closeIfClosed();
                 promise.tryFailure(t);
+                closeIfClosed();
             }
         }
 

File: transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
Patch:
@@ -80,8 +80,8 @@ public void connect(
                     newT.setStackTrace(t.getStackTrace());
                     t = newT;
                 }
-                closeIfClosed();
                 promise.setFailure(t);
+                closeIfClosed();
             }
         }
     }

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -733,7 +733,6 @@ private static void testGatheringWritesPartial(ByteBuf buf1, ByteBuf buf2, boole
         TestGatheringByteChannel channel = new TestGatheringByteChannel(1);
 
         while (buf.isReadable()) {
-            System.out.println(buf.nioBuffers().length);
             buf.readBytes(channel, buf.readableBytes());
         }
 

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -36,7 +36,7 @@ public abstract class AbstractByteBuf extends ByteBuf {
 
     static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);
 
-    private int readerIndex;
+    int readerIndex;
     private int writerIndex;
     private int markedReaderIndex;
     private int markedWriterIndex;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.DatagramPacket;
 import org.junit.Test;
@@ -65,7 +66,7 @@ public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exceptio
 
     @Test
     public void testSimpleSendWithoutBind() throws Throwable {
-        //run();
+        run();
     }
 
     public void testSimpleSendWithoutBind(Bootstrap sb, Bootstrap cb) throws Throwable {
@@ -85,6 +86,7 @@ public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exceptio
                 // Nothing will be sent.
             }
         });
+        cb.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);
 
         Channel sc = sb.bind().sync().channel();
         Channel cc = cb.register().sync().channel();

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -96,6 +96,9 @@ public class ChannelOption<T> extends UniqueName {
     public static final ChannelOption<Long> AIO_WRITE_TIMEOUT =
             new ChannelOption<Long>("AIO_WRITE_TIMEOUT");
 
+    @Deprecated
+    public static final ChannelOption<Boolean> DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION =
+            new ChannelOption<Boolean>("DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION");
     /**
      * Create a new {@link ChannelOption} with the given name. The name needs to be
      * unique.

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelOutboundBuffer;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.RecvByteBufAllocator;
@@ -125,7 +126,8 @@ public boolean isOpen() {
 
     @Override
     public boolean isActive() {
-        return isOpen() && socket.isBound();
+        return isOpen() && (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
+                || socket.isBound();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
Patch:
@@ -134,7 +134,7 @@ public OioSocketChannelConfig setPerformancePreferences(int connectionTime, int
 
     @Override
     public OioSocketChannelConfig setAllowHalfClosure(boolean allowHalfClosure) {
-        super.setAllowHalfClosure(true);
+        super.setAllowHalfClosure(allowHalfClosure);
         return this;
     }
 

File: buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
Patch:
@@ -506,7 +506,7 @@ private ByteBuffer internalNioBuffer() {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
-        return (ByteBuffer) buffer.duplicate().position(index).position(index + length);
+        return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1122,7 +1122,7 @@ public ByteBuffer nioBuffer(int index, int length) {
 
         //noinspection ForLoopReplaceableByForEach
         for (int i = 0; i < buffers.length; i++) {
-            merged.put(buffers[0]);
+            merged.put(buffers[i]);
         }
 
         merged.flip();

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -128,7 +128,7 @@ public DatagramChannelConfig config() {
     @Override
     public boolean isActive() {
         DatagramChannel ch = javaChannel();
-        return ch.isOpen() && ch.socket().isBound();
+        return ch.isOpen();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -125,7 +125,7 @@ public boolean isOpen() {
 
     @Override
     public boolean isActive() {
-        return isOpen() && socket.isBound();
+        return isOpen();
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -323,7 +323,8 @@ private void checkComponentIndex(int cIndex, int numComponents) {
     }
 
     private void updateComponentOffsets(int cIndex) {
-        if (components.isEmpty()) {
+        int size = components.size();
+        if (size <= cIndex) {
             return;
         }
 
@@ -334,7 +335,7 @@ private void updateComponentOffsets(int cIndex) {
             cIndex ++;
         }
 
-        for (int i = cIndex; i < components.size(); i ++) {
+        for (int i = cIndex; i < size; i ++) {
             Component prev = components.get(i - 1);
             Component cur = components.get(i);
             cur.offset = prev.endOffset;

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -279,13 +279,15 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                     final int readableBytes = buf.writerIndex() - readerIndex;
 
                     if (readableBytes < writtenBytes) {
+                        in.progress(readableBytes);
                         in.remove();
                         writtenBytes -= readableBytes;
                     } else if (readableBytes > writtenBytes) {
                         buf.readerIndex(readerIndex + (int) writtenBytes);
                         in.progress(writtenBytes);
                         break;
-                    } else { // readable == writtenBytes
+                    } else { // readableBytes == writtenBytes
+                        in.progress(readableBytes);
                         in.remove();
                         break;
                     }

File: transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
Patch:
@@ -28,7 +28,7 @@
  *             {@link SimpleChannelInboundHandler}&lt;{@link String}&gt; {
  *
  *         {@code @Override}
- *         public void messageReceived({@link ChannelHandlerContext} ctx, {@link String} message)
+ *         protected void channelRead0({@link ChannelHandlerContext} ctx, {@link String} message)
  *                 throws {@link Exception} {
  *             System.out.println(message);
  *         }

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java
Patch:
@@ -29,7 +29,7 @@ public final class ZlibCodecFactory {
     private static final boolean noJdkZlibDecoder;
 
     static {
-        noJdkZlibDecoder = !SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder", true);
+        noJdkZlibDecoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder", true);
         logger.debug("-Dio.netty.noJdkZlibDecoder: {}", noJdkZlibDecoder);
     }
 

File: transport/src/main/java/io/netty/channel/ChannelFuture.java
Patch:
@@ -146,7 +146,7 @@
  * // GOOD
  * {@link Bootstrap} b = ...;
  * // Configure the connect timeout option.
- * <b>b.setOption({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>
+ * <b>b.option({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>
  * {@link ChannelFuture} f = b.connect(...);
  * f.awaitUninterruptibly();
  *

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -336,7 +336,7 @@ public ByteBuffer[] nioBuffers() {
                         nioBuffers[nioBufferCount ++] = buf.internalNioBuffer(readerIndex, readableBytes);
                     } else {
                         ByteBuffer[] nioBufs = buf.nioBuffers();
-                        if (nioBufferCount + nioBufs.length == nioBuffers.length + 1) {
+                        if (nioBufferCount + nioBufs.length > nioBuffers.length) {
                             this.nioBuffers = nioBuffers = doubleNioBufferArray(nioBuffers, nioBufferCount);
                         }
                         for (ByteBuffer nioBuf: nioBufs) {

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -39,7 +39,7 @@
  * <p>When not used in a {@link ServerBootstrap} context, the {@link #bind()} methods are useful for connectionless
  * transports such as datagram (UDP).</p>
  */
-abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> implements Cloneable {
+public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> implements Cloneable {
 
     private volatile EventLoopGroup group;
     private volatile ChannelFactory<? extends C> channelFactory;

File: transport/src/test/java/io/netty/channel/ReentrantChannelTest.java
Patch:
@@ -82,7 +82,7 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio
 
         assertTrue(clientChannel.isWritable());
         clientChannel.write(createTestBuf(2000)).sync();
-        assertTrue(clientChannel.isWritable());
+        clientChannel.close().sync();
 
         assertLog(
             "WRITE\n" +

File: transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
Patch:
@@ -98,7 +98,7 @@ public TestEventExecutor() {
 
         @Override
         protected void run() {
-            for (; ; ) {
+            for (;;) {
                 Runnable task = takeTask();
                 if (task != null) {
                     task.run();

File: transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
Patch:
@@ -57,7 +57,7 @@ public class ThreadPerChannelEventLoopGroup extends AbstractEventExecutorGroup i
         public void operationComplete(Future<Object> future) throws Exception {
             // Inefficient, but works.
             if (isTerminated()) {
-                terminationFuture.setSuccess(null);
+                terminationFuture.trySuccess(null);
             }
         }
     };

File: buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
Patch:
@@ -289,7 +289,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
-        return buffer.internalNioBuffer(index, length);
+        return buffer.internalNioBuffer(index, length).duplicate();
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
Patch:
@@ -292,7 +292,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
-        return buffer.internalNioBuffer(index, length);
+        return buffer.internalNioBuffer(index, length).duplicate();
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
Patch:
@@ -271,7 +271,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
         checkIndex(index, length);
-        return buffer.internalNioBuffer(index + adjustment, length);
+        return buffer.internalNioBuffer(index + adjustment, length).duplicate();
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
Patch:
@@ -741,8 +741,7 @@ public ByteBuffer nioBuffer(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
-        // Do not mess with the internal buffer's byte order.
-        return buf.nioBuffer(index, length).order(order);
+        return buf.internalNioBuffer(index, length).duplicate().order(order);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -55,7 +55,7 @@ final class DefaultChannelPipeline implements ChannelPipeline {
         }
     }
 
-    final Channel channel;
+    final AbstractChannel channel;
 
     final DefaultChannelHandlerContext head;
     final DefaultChannelHandlerContext tail;
@@ -66,7 +66,7 @@ final class DefaultChannelPipeline implements ChannelPipeline {
     final Map<EventExecutorGroup, EventExecutor> childExecutors =
             new IdentityHashMap<EventExecutorGroup, EventExecutor>();
 
-    public DefaultChannelPipeline(Channel channel) {
+    public DefaultChannelPipeline(AbstractChannel channel) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -86,7 +86,7 @@ private final class Encoder extends HttpRequestEncoder {
 
         @Override
         protected void encode(
-                ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {
+                ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
             if (msg instanceof HttpRequest && !done) {
                 queue.offer(((HttpRequest) msg).getMethod());
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
+import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Iterator;
@@ -206,9 +207,7 @@ public HttpHeaders set(final String name, final Iterable<?> values) {
 
     @Override
     public HttpHeaders clear() {
-        for (int i = 0; i < entries.length; i ++) {
-            entries[i] = null;
-        }
+        Arrays.fill(entries, null);
         head.before = head.after = head;
         return this;
     }

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -239,7 +239,6 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
      */
     protected abstract int doWriteBytes(ByteBuf buf) throws Exception;
 
-
     protected final void setOpWrite() {
         final SelectionKey key = selectionKey();
         final int interestOps = key.interestOps();

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -271,9 +271,8 @@ protected SocketAddress remoteAddress0() {
     }
 
     @Override
-    protected Runnable doRegister() throws Exception {
+    protected void doRegister() throws Exception {
         state = 1;
-        return null;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -277,12 +277,12 @@ private boolean isFlushPending() {
     }
 
     @Override
-    protected Runnable doRegister() throws Exception {
+    protected void doRegister() throws Exception {
         boolean selected = false;
         for (;;) {
             try {
                 selectionKey = javaChannel().register(eventLoop().selector, 0, this);
-                return null;
+                return;
             } catch (CancelledKeyException e) {
                 if (!selected) {
                     // Force the Selector to select now  as the "canceled" SelectionKey may still be

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -219,12 +219,11 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected Runnable doDeregister() throws Exception {
+    protected void doDeregister() throws Exception {
         if (isOpen()) {
             unsafe().close(unsafe().voidPromise());
         }
         ((SingleThreadEventExecutor) eventLoop()).removeShutdownHook(shutdownHook);
-        return null;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
Patch:
@@ -104,9 +104,8 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected Runnable doDeregister() throws Exception {
+    protected void doDeregister() throws Exception {
         ((SingleThreadEventExecutor) eventLoop()).removeShutdownHook(shutdownHook);
-        return null;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -299,9 +299,8 @@ protected Runnable doRegister() throws Exception {
     }
 
     @Override
-    protected Runnable doDeregister() throws Exception {
+    protected void doDeregister() throws Exception {
         eventLoop().cancel(selectionKey());
-        return null;
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -205,7 +205,7 @@ private static long getTimeToWait(long limit, long bytes, long lastTime, long cu
             // Time is too short, so just lets continue
             return 0;
         }
-        return (bytes * 1000 / limit - interval / 10) * 10;
+        return (bytes * 1000 / limit - interval) / 10 * 10;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -153,8 +153,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
                 Object frame = readControlFrame(buffer);
                 if (frame != null) {
                     state = State.READ_COMMON_HEADER;
+                    out.add(frame);
                 }
-                out.add(frame);
                 return;
             } catch (IllegalArgumentException e) {
                 state = State.FRAME_ERROR;

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -1568,7 +1568,9 @@ protected void deallocate() {
             c.freeIfNecessary();
         }
 
-        leak.close();
+        if (leak != null) {
+            leak.close();
+        }
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -18,7 +18,6 @@
 
 import io.netty.util.Recycler;
 import io.netty.util.ResourceLeak;
-import io.netty.util.ResourceLeakDetector;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -145,7 +144,7 @@ protected final void deallocate() {
             this.handle = -1;
             memory = null;
             chunk.arena.free(chunk, handle);
-            if (ResourceLeakDetector.isEnabled()) {
+            if (leak != null) {
                 leak.close();
             } else {
                 recycle();
@@ -157,7 +156,6 @@ protected final void deallocate() {
     private void recycle() {
         Recycler.Handle recyclerHandle = this.recyclerHandle;
         if (recyclerHandle != null) {
-            setRefCnt(1);
             ((Recycler<Object>) recycler()).recycle(this, recyclerHandle);
         }
     }

File: buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
Patch:
@@ -37,6 +37,7 @@ protected PooledDirectByteBuf newObject(Handle handle) {
 
     static PooledDirectByteBuf newInstance(int maxCapacity) {
         PooledDirectByteBuf buf = RECYCLER.get();
+        buf.setRefCnt(1);
         buf.maxCapacity(maxCapacity);
         return buf;
     }

File: buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
Patch:
@@ -36,6 +36,7 @@ protected PooledHeapByteBuf newObject(Handle handle) {
 
     static PooledHeapByteBuf newInstance(int maxCapacity) {
         PooledHeapByteBuf buf = RECYCLER.get();
+        buf.setRefCnt(1);
         buf.maxCapacity(maxCapacity);
         return buf;
     }

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -41,6 +41,7 @@ protected PooledUnsafeDirectByteBuf newObject(Handle handle) {
 
     static PooledUnsafeDirectByteBuf newInstance(int maxCapacity) {
         PooledUnsafeDirectByteBuf buf = RECYCLER.get();
+        buf.setRefCnt(1);
         buf.maxCapacity(maxCapacity);
         return buf;
     }

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
Patch:
@@ -51,7 +51,9 @@ public ReadOnlyByteBufferBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
 
     @Override
     protected void deallocate() {
-        leak.close();
+        if (leak != null) {
+            leak.close();
+        }
     }
 
     @Override

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -290,7 +290,9 @@ public Set<Timeout> stop() {
             Thread.currentThread().interrupt();
         }
 
-        leak.close();
+        if (leak != null) {
+            leak.close();
+        }
 
         Set<Timeout> unprocessedTimeouts = new HashSet<Timeout>();
         for (Set<HashedWheelTimeout> bucket: wheel) {

File: buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
Patch:
@@ -145,7 +145,7 @@ protected final void deallocate() {
             this.handle = -1;
             memory = null;
             chunk.arena.free(chunk, handle);
-            if (ResourceLeakDetector.ENABLED) {
+            if (ResourceLeakDetector.isEnabled()) {
                 leak.close();
             } else {
                 recycle();

File: buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.util.internal.PlatformDependent;
 
 /**
- * Skeltal {@link ByteBufAllocator} implementation to extend.
+ * Skeletal {@link ByteBufAllocator} implementation to extend.
  */
 public abstract class AbstractByteBufAllocator implements ByteBufAllocator {
     private static final int DEFAULT_INITIAL_CAPACITY = 256;

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -1687,7 +1687,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      * or {@link #nioBuffers(int, int)} might return a less number of {@link ByteBuffer}s.
      *
      * @return {@code -1} if this buffer has no underlying {@link ByteBuffer}.
-     *         the number of the underlying {@link ByteBuffer}s if this buffer has at least one undelying
+     *         the number of the underlying {@link ByteBuffer}s if this buffer has at least one underlying
      *         {@link ByteBuffer}.  Note that this method does not return {@code 0} to avoid confusion.
      *
      * @see #nioBuffer()

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -102,7 +102,7 @@ public static ByteBuf buffer() {
     }
 
     /**
-     * Creates a new big-endian direct buffer with resaonably small initial capacity, which
+     * Creates a new big-endian direct buffer with reasonably small initial capacity, which
      * expands its capacity boundlessly on demand.
      */
     public static ByteBuf directBuffer() {

File: common/src/main/java/io/netty/util/concurrent/Future.java
Patch:
@@ -162,7 +162,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
     /**
      * {@inheritDoc}
      *
-     * If the cancelation was successful it will fail the future with an {@link CancellationException}.
+     * If the cancellation was successful it will fail the future with an {@link CancellationException}.
      */
     @Override
     boolean cancel(boolean mayInterruptIfRunning);

File: common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
Patch:
@@ -126,7 +126,7 @@ protected Set<EventExecutor> children() {
     }
 
     /**
-     * Create a new EventExecutor which will later then accessable via the {@link #next()}  method. This method will be
+     * Create a new EventExecutor which will later then accessible via the {@link #next()}  method. This method will be
      * called for each thread that will serve this {@link MultithreadEventExecutorGroup}.
      *
      */

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -379,7 +379,7 @@ protected boolean runAllTasks(long timeoutNanos) {
     }
 
     /**
-     * Returns the ammount of time left until the scheduled task with the closest dead line is executed.
+     * Returns the amount of time left until the scheduled task with the closest dead line is executed.
      */
     protected long delayNanos(long currentTimeNanos) {
         ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -615,7 +615,7 @@ public void run() {
         @Override
         public void write(Object msg, ChannelPromise promise) {
             if (!isActive()) {
-                // Mark the write request as failure if the channl is inactive.
+                // Mark the write request as failure if the channel is inactive.
                 if (isOpen()) {
                     promise.tryFailure(NOT_YET_CONNECTED_EXCEPTION);
                 } else {

File: transport/src/main/java/io/netty/channel/ChannelConfig.java
Patch:
@@ -121,13 +121,13 @@ public interface ChannelConfig {
     /**
      * Returns the maximum number of messages to read per read loop.
      * a {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object) channelRead()} event.
-     * If this value is greater than 1, an event loop might attempt to read multiple times to procude multiple messages.
+     * If this value is greater than 1, an event loop might attempt to read multiple times to procure multiple messages.
      */
     int getMaxMessagesPerRead();
 
     /**
      * Sets the maximum number of messages to read per read loop.
-     * If this value is greater than 1, an event loop might attempt to read multiple times toprocude multiple messages.
+     * If this value is greater than 1, an event loop might attempt to read multiple times to procure multiple messages.
      */
     ChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
 
@@ -215,7 +215,7 @@ public interface ChannelConfig {
      * Sets the low water mark of the write buffer.  Once the number of bytes
      * queued in the write buffer exceeded the
      * {@linkplain #setWriteBufferHighWaterMark(int) high water mark} and then
-     * dropped down below this value, {@link Channel#isWritable()} will start toreturn
+     * dropped down below this value, {@link Channel#isWritable()} will start to return
      * {@code true} again.
      */
     ChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark);

File: transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
Patch:
@@ -93,7 +93,7 @@ public long writeCounter() {
      * their pendingDatasize is smaller after the the current writeCounter returned by {@link #writeCounter()}.
      *
      * After a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and
-     * so not receive anymore notificiation.
+     * so not receive anymore notification.
      */
     public ChannelFlushPromiseNotifier notifyFlushFutures() {
         notifyFlushFutures0(null);
@@ -105,7 +105,7 @@ public ChannelFlushPromiseNotifier notifyFlushFutures() {
      * their pendingDatasize isis smaller then the current writeCounter returned by {@link #writeCounter()}.
      *
      * After a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and
-     * so not receive anymore notificiation.
+     * so not receive anymore notification.
      *
      * The rest of the remaining {@link ChannelFuture}s will be failed with the given {@link Throwable}.
      *
@@ -133,7 +133,7 @@ public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause) {
      * the given cause1.
      *
      * After a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and
-     * so not receive anymore notificiation.
+     * so not receive anymore notification.
      *
      * The rest of the remaining {@link ChannelFuture}s will be failed with the given {@link Throwable}.
      *

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -133,8 +133,8 @@ public interface ChannelHandlerContext
 
     /**
      * The {@link EventExecutor} that is used to dispatch the events. This can also be used to directly
-     * submit tasks that get executed in the event loop. For more informations please refer to the
-     * {@link EventExecutor} javadocs.
+     * submit tasks that get executed in the event loop. For more information please refer to the
+     * {@link EventExecutor} javadoc.
      */
     EventExecutor executor();
 

File: transport/src/main/java/io/netty/channel/ChannelInitializer.java
Patch:
@@ -56,7 +56,7 @@ public abstract class ChannelInitializer<C extends Channel> extends ChannelInbou
      * will be removed from the {@link ChannelPipeline} of the {@link Channel}.
      *
      * @param ch            the {@link Channel} which was registered.
-     * @throws Exception    is thrown if an error occours. In that case the {@link Channel} will be closed.
+     * @throws Exception    is thrown if an error occurs. In that case the {@link Channel} will be closed.
      */
     protected abstract void initChannel(C ch) throws Exception;
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
Patch:
@@ -64,7 +64,7 @@ interface ChannelOutboundInvoker {
     ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
 
     /**
-     * Request to discconect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
+     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
      * either because the operation was successful or because of an error.
      * <p>
      * This will result in having the
@@ -146,7 +146,7 @@ interface ChannelOutboundInvoker {
     ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
 
     /**
-     * Request to discconect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
+     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
      * either because the operation was successful or because of an error.
      *
      * The given {@link ChannelPromise} will be notified.

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -29,7 +29,7 @@
 
 
 /**
- * A list of {@link ChannelHandler}s which handles or intercepts inbound events and outbount operations of a
+ * A list of {@link ChannelHandler}s which handles or intercepts inbound events and outbound operations of a
  * {@link Channel}.  {@link ChannelPipeline} implements an advanced form of the
  * <a href="http://www.oracle.com/technetwork/java/interceptingfilter-142169.html">Intercepting Filter</a> pattern
  * to give a user full control over how an event is handled and how the {@link ChannelHandler}s in a pipeline

File: transport/src/main/java/io/netty/channel/EventLoopException.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * Special {@link ChannelException} which will be thrown by {@link EventLoop} and {@link EventLoopGroup}
- * implementations when an error accours.
+ * implementations when an error occurs.
  */
 public class EventLoopException extends ChannelException {
 

File: transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
Patch:
@@ -113,7 +113,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
      * @param ctx           the {@link ChannelHandlerContext} which this {@link SimpleChannelInboundHandler}
      *                      belongs to
      * @param msg           the message to handle
-     * @throws Exception    is thrown if an error accour
+     * @throws Exception    is thrown if an error occurred
      */
     protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
Patch:
@@ -187,23 +187,23 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
      * @param buf           the {@link ByteBuf} into which the read bytes will be written
      * @return amount       the number of bytes read. This may return a negative amount if the underlying
      *                      Socket was closed
-     * @throws Exception    is thrown if an error accoured
+     * @throws Exception    is thrown if an error occurred
      */
     protected abstract int doReadBytes(ByteBuf buf) throws Exception;
 
     /**
      * Write the data which is hold by the {@link ByteBuf} to the underlying Socket.
      *
      * @param buf           the {@link ByteBuf} which holds the data to transfer
-     * @throws Exception    is thrown if an error accoured
+     * @throws Exception    is thrown if an error occurred
      */
     protected abstract void doWriteBytes(ByteBuf buf) throws Exception;
 
     /**
      * Write the data which is hold by the {@link FileRegion} to the underlying Socket.
      *
      * @param region        the {@link FileRegion} which holds the data to transfer
-     * @throws Exception    is thrown if an error accoured
+     * @throws Exception    is thrown if an error occurred
      */
     protected abstract void doWriteFileRegion(FileRegion region) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.util.DefaultAttributeMap;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ThreadLocalRandom;
@@ -620,6 +621,8 @@ public void write(Object msg, ChannelPromise promise) {
                 } else {
                     promise.tryFailure(CLOSED_CHANNEL_EXCEPTION);
                 }
+                // release message now to prevent resource-leak
+                ReferenceCountUtil.release(msg);
             } else {
                 outboundBuffer.addMessage(msg, promise);
             }

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -117,7 +117,7 @@
  * <ul>
  * <li>3 and 4 don't implement {@link ChannelInboundHandler}, and therefore the actual evaluation order of an inbound
  *     event will be: 1, 2, and 5.</li>
- * <li>1 and 2 implement {@link ChannelOutboundHandler}, and therefore the actual evaluation order of a
+ * <li>1 and 2 don't implement {@link ChannelOutboundHandler}, and therefore the actual evaluation order of a
  *     outbound event will be: 5, 4, and 3.</li>
  * <li>If 5 implements both {@link ChannelInboundHandler} and {@link ChannelOutboundHandler}, the evaluation order of
  *     an inbound and a outbound event could be 125 and 543 respectively.</li>

File: transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java
Patch:
@@ -67,8 +67,8 @@ interface ChannelPropertyAccess {
      * </p>
      * <p>
      * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used
-     * if you want to save an object allocation for every write operation. You will not be able to detect if the operation
-     * was complete, only if it failed as the implementation will call
+     * if you want to save an object allocation for every write operation. You will not be able to detect if the
+     * operation  was complete, only if it failed as the implementation will call
      * {@link ChannelPipeline#fireExceptionCaught(Throwable)} in this case.
      * </p>
      * <strong>Be aware this is an expert feature and should be used with care!</strong>

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -350,7 +350,7 @@ void fail(Throwable cause) {
         void progress() {
             progress ++;
             if (promise instanceof ChannelProgressivePromise) {
-                ((ChannelProgressivePromise) promise).setProgress(progress, -1);
+                ((ChannelProgressivePromise) promise).tryProgress(progress, -1);
             }
         }
     }

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java
Patch:
@@ -39,6 +39,6 @@ public void initChannel(SocketChannel ch) throws Exception {
         pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
 
-        pipeline.addLast("handler", new HttpStaticFileServerHandler());
+        pipeline.addLast("handler", new HttpStaticFileServerHandler(true)); // Specify false if SSL.
     }
 }

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -296,11 +296,11 @@ public void operationComplete(ChannelFuture future) throws Exception {
                             if (!future.isSuccess()) {
                                 closeInput((ChunkedInput<?>) pendingMessage);
                                 currentWrite.fail(future.cause());
-                            } else if (isWritable()) {
-                                currentWrite.progress();
-                                resumeTransfer();
                             } else {
                                 currentWrite.progress();
+                                if (isWritable()) {
+                                    resumeTransfer();
+                                }
                             }
                         }
                     });

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -145,7 +145,7 @@ void addMessage(Object msg, ChannelPromise promise) {
             unflushed = this.unflushed;
         }
 
-        final int size = channel.calculateMessageSize(msg);
+        final long size = channel.calculateMessageSize(msg);
         incrementPendingOutboundBytes(size);
 
         unflushed[unflushedCount] = msg;
@@ -249,7 +249,7 @@ private void doubleFlushedCapacity() {
         tail = n;
     }
 
-    private void incrementPendingOutboundBytes(int size) {
+    private void incrementPendingOutboundBytes(long size) {
         if (size == 0) {
             return;
         }

File: codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
Patch:
@@ -64,6 +64,7 @@ public void testFailFastTooLongFrameRecovery() throws Exception {
             ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 0, 0, 1, 'A' }));
             ByteBuf buf = (ByteBuf) ch.readInbound();
             assertEquals("A", buf.toString(CharsetUtil.ISO_8859_1));
+            buf.release();
         }
     }
 }

File: codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
Patch:
@@ -44,6 +44,7 @@ public void testFailSlowTooLongFrameRecovery() throws Exception {
             ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 1, 'A' }));
             ByteBuf buf = (ByteBuf) ch.readInbound();
             assertEquals("A", buf.toString(CharsetUtil.ISO_8859_1));
+            buf.release();
         }
     }
 

File: common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
Patch:
@@ -204,8 +204,8 @@ public void execute(Runnable task) {
         if (inEventLoop) {
             addTask(task);
         } else {
-            startThread();
             addTask(task);
+            startThread();
         }
     }
 

File: common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
Patch:
@@ -64,7 +64,6 @@ public void operationComplete(Future<Void> future) throws Exception {
                             }
                         }
                     });
-
                 }
             });
         }

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -142,7 +142,7 @@ private void reportLeak() {
                 logger.warn(
                         "LEAK: " + resourceType + " was GC'd before being released correctly.  " +
                         "The following stack trace shows where the leaked object was created, " +
-                        "rather than who failed to release it where.", ref.exception);
+                        "rather than where you failed to release it.", ref.exception);
             }
         }
     }

File: transport/src/test/java/io/netty/channel/nio/NioSocketChannelTest.java
Patch:
@@ -51,8 +51,8 @@ public void testFlushCloseReentrance() throws Exception {
                 @Override
                 public void channelActive(ChannelHandlerContext ctx) throws Exception {
                     // Write a large enough data so that it is split into two loops.
-                    futures.add(
-                            ctx.write(ctx.alloc().buffer().writeZero(1048576)).addListener(ChannelFutureListener.CLOSE));
+                    futures.add(ctx.write(
+                            ctx.alloc().buffer().writeZero(1048576)).addListener(ChannelFutureListener.CLOSE));
                     futures.add(ctx.write(ctx.alloc().buffer().writeZero(1048576)));
                     ctx.flush();
                     futures.add(ctx.write(ctx.alloc().buffer().writeZero(1048576)));

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -862,8 +862,7 @@ public int writeBytes(InputStream in, int length)
     }
 
     @Override
-    public int writeBytes(ScatteringByteChannel in, int length)
-            throws IOException {
+    public int writeBytes(ScatteringByteChannel in, int length) throws IOException {
         ensureWritable(length);
         int writtenBytes = setBytes(writerIndex, in, length);
         if (writtenBytes > 0) {
@@ -878,6 +877,7 @@ public ByteBuf writeZero(int length) {
             return this;
         }
 
+        ensureWritable(length);
         checkIndex(writerIndex, length);
 
         int nLong = length >>> 3;

File: transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
Patch:
@@ -131,7 +131,8 @@ public void initChannel(LocalChannel ch) throws Exception {
             // Ensure that the actual write attempt on a closed channel was never made by asserting that
             // the ClosedChannelException has been created by AbstractUnsafe rather than transport implementations.
             if (e.getStackTrace().length > 0) {
-                assertThat(e.getStackTrace()[0].getClassName(), is(AbstractChannel.class.getName() + "$AbstractUnsafe"));
+                assertThat(
+                        e.getStackTrace()[0].getClassName(), is(AbstractChannel.class.getName() + "$AbstractUnsafe"));
                 e.printStackTrace();
             }
         }

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.channel.socket.SocketChannelConfig;
 
 import java.util.IdentityHashMap;
@@ -30,7 +30,7 @@
  */
 public class DefaultChannelConfig implements ChannelConfig {
 
-    private static final ByteBufAllocator DEFAULT_ALLOCATOR = PooledByteBufAllocator.DEFAULT;
+    private static final ByteBufAllocator DEFAULT_ALLOCATOR = UnpooledByteBufAllocator.DEFAULT;
     private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = AdaptiveRecvByteBufAllocator.DEFAULT;
     private static final int DEFAULT_CONNECT_TIMEOUT = 30000;
 

File: common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.Arrays;
 
-public final class DefaultFutureListeners {
+final class DefaultFutureListeners {
 
     private GenericFutureListener<? extends Future<?>>[] listeners;
     private int size;

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -135,7 +135,9 @@ private static void sendHttpResponse(
             ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
         // Generate an error page if response getStatus code is not OK (200).
         if (res.getStatus().code() != 200) {
-            res.content().writeBytes(Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
+            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
+            res.content().writeBytes(buf);
+            buf.release();
             setContentLength(res, res.content().readableBytes());
         }
 

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
Patch:
@@ -132,7 +132,9 @@ private static void sendHttpResponse(
             ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
         // Generate an error page if response getStatus code is not OK (200).
         if (res.getStatus().code() != 200) {
-            res.content().writeBytes(Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
+            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
+            res.content().writeBytes(buf);
+            buf.release();
             setContentLength(res, res.content().readableBytes());
         }
 

File: transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java
Patch:
@@ -30,7 +30,6 @@ public final class ChannelPromiseAggregator implements ChannelFutureListener {
     private final ChannelPromise aggregatePromise;
     private Set<ChannelPromise> pendingPromises;
 
-
     /**
      * Instance an new {@link ChannelPromiseAggregator}
      *

File: transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java
Patch:
@@ -28,7 +28,6 @@
 public final class ChannelPromiseAggregator implements ChannelFutureListener {
 
     private final ChannelPromise aggregatePromise;
-
     private Set<ChannelPromise> pendingPromises;
 
 

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -42,6 +42,9 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
         }
     }
 
+    /**
+     * @see {@link MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, ThreadFactory, Object...)}
+     */
     protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
         super(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
     }

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
Patch:
@@ -243,6 +243,9 @@ public void checkException() {
         PlatformDependent.throwException(t);
     }
 
+    /**
+     * Ensure the {@link Channel} is open and of not throw an exception.
+     */
     protected final void ensureOpen() {
         if (!isOpen()) {
             recordException(new ClosedChannelException());

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -529,7 +529,7 @@ private static void processWritable(AbstractNioChannel ch) {
         }
 
         // Call flushNow which will also take care of clear the OP_WRITE once there is nothing left to write
-        ch.unsafe().flushNow();
+        ch.unsafe().flush();
     }
 
     private static void unregisterWritableTasks(AbstractNioChannel ch) {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
Patch:
@@ -1204,9 +1204,9 @@ protected InterfaceHttpData getFileUpload(String delimiter) throws ErrorDataDeco
      */
     public void destroy() {
         checkDestroyed();
+        cleanFiles();
         destroyed = true;
 
-        cleanFiles();
         if (undecodedChunk != null && undecodedChunk.refCnt() > 0) {
             undecodedChunk.release();
             undecodedChunk = null;

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -87,7 +87,7 @@ public void run() throws Exception {
                             new DefaultCookie("another-cookie", "bar")));
 
             // Send the HTTP request.
-            ch.write(request);
+            ch.writeAndFlush(request);
 
             // Wait for the server to close the connection.
             ch.closeFuture().sync();

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -401,7 +401,7 @@ private void writeMenu(ChannelHandlerContext ctx) {
         response.headers().set(CONTENT_LENGTH, buf.readableBytes());
 
         // Write the response.
-        ctx.channel().write(response);
+        ctx.channel().writeAndFlush(response);
     }
 
     @Override

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -104,16 +104,16 @@ public void initChannel(SocketChannel ch) throws Exception {
             // Send 10 messages and wait for responses
             System.out.println("WebSocket Client sending message");
             for (int i = 0; i < 10; i++) {
-                ch.write(new TextWebSocketFrame("Message #" + i));
+                ch.writeAndFlush(new TextWebSocketFrame("Message #" + i));
             }
 
             // Ping
             System.out.println("WebSocket Client sending ping");
-            ch.write(new PingWebSocketFrame(Unpooled.copiedBuffer(new byte[]{1, 2, 3, 4, 5, 6})));
+            ch.writeAndFlush(new PingWebSocketFrame(Unpooled.copiedBuffer(new byte[]{1, 2, 3, 4, 5, 6})));
 
             // Close
             System.out.println("WebSocket Client sending close");
-            ch.write(new CloseWebSocketFrame());
+            ch.writeAndFlush(new CloseWebSocketFrame());
 
             // WebSocketClientHandler will close the connection when the server
             // responds to the CloseWebSocketFrame.

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
Patch:
@@ -52,7 +52,7 @@ public ObjectEchoClientHandler(int firstMessageSize) {
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         // Send the first message if this handler is a client-side handler.
-        ctx.write(firstMessage);
+        ctx.writeAndFlush(firstMessage);
     }
 
     @Override

File: example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java
Patch:
@@ -22,7 +22,7 @@ public class RxtxClientHandler extends SimpleChannelInboundHandler<String> {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) {
-        ctx.write("AT\n");
+        ctx.writeAndFlush("AT\n");
     }
 
     @Override

File: example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
Patch:
@@ -51,7 +51,7 @@ public SctpEchoClientHandler(int firstMessageSize) {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) {
-        ctx.write(new SctpMessage(0, 0, firstMessage));
+        ctx.writeAndFlush(new SctpMessage(0, 0, firstMessage));
     }
 
     @Override

File: example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
Patch:
@@ -37,7 +37,7 @@ public RelayHandler(Channel relayChannel) {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
-        ctx.write(Unpooled.EMPTY_BUFFER);
+        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);
     }
 
     @Override

File: example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
Patch:
@@ -56,7 +56,7 @@ public void operationComplete(ChannelFuture channelFuture) throws Exception {
 
             @Override
             public void onFailure(ChannelHandlerContext outboundCtx, Throwable cause) {
-                ctx.channel().write(new SocksCmdResponse(SocksCmdStatus.FAILURE, request.addressType()));
+                ctx.channel().writeAndFlush(new SocksCmdResponse(SocksCmdStatus.FAILURE, request.addressType()));
                 SocksServerUtils.closeOnFlush(ctx.channel());
             }
         };

File: example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
Patch:
@@ -54,7 +54,7 @@ public ByteEchoClientHandler(final int messageSize) {
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-        ctx.write(message);
+        ctx.writeAndFlush(message);
     }
 
     @Override

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
Patch:
@@ -54,7 +54,7 @@ public MsgEchoClientHandler(final int messageSize) {
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-        ctx.write(message);
+        ctx.writeAndFlush(message);
     }
 
     @Override

File: example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
Patch:
@@ -55,7 +55,7 @@ public MsgEchoPeerHandler(final int messageSize) {
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-        ctx.write(message);
+        ctx.writeAndFlush(message);
     }
 
     @Override

File: example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
Patch:
@@ -50,7 +50,7 @@ public ByteEchoPeerHandler(final int messageSize) {
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-        ctx.write(message);
+        ctx.writeAndFlush(message);
     }
 
     @Override

File: example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
Patch:
@@ -59,7 +59,7 @@ public List<String> getLocalTimes(Collection<String> cities) {
                 setCity(components[1]).build());
         }
 
-        channel.write(builder.build());
+        channel.writeAndFlush(builder.build());
 
         LocalTimes localTimes;
         boolean interrupted = false;

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -70,12 +70,14 @@ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req)
         // Handle a bad request.
         if (!req.getDecoderResult().isSuccess()) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
+            req.release();
             return;
         }
 
         // Allow only GET methods.
         if (req.getMethod() != GET) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
+            req.release();
             return;
         }
 
@@ -88,6 +90,7 @@ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req)
         } else {
             handshaker.handshake(ctx.channel(), req);
         }
+        req.release();
     }
 
     private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -276,6 +276,7 @@ private void fetchEncoderOutput(List<Object> out) {
                 break;
             }
             if (!buf.isReadable()) {
+                buf.release();
                 continue;
             }
             out.add(new DefaultHttpContent(buf));

File: transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
Patch:
@@ -26,7 +26,6 @@
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
-import java.util.List;
 import java.util.Map;
 
 import static io.netty.channel.sctp.SctpChannelOption.*;
@@ -88,8 +87,7 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
         } else if (option == SCTP_NODELAY) {
             setSctpNoDelay((Boolean) value);
         } else if (option == SCTP_INIT_MAXSTREAMS) {
-            List<Integer> minMax = (List<Integer>) value;
-            setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams.create(minMax.get(0), minMax.get(1)));
+            setInitMaxStreams((SctpStandardSocketOptions.InitMaxStreams) value);
         } else {
             return super.setOption(option, value);
         }

File: transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
Patch:
@@ -26,6 +26,7 @@
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.Map;
 
 import static io.netty.channel.sctp.SctpChannelOption.*;
@@ -87,7 +88,8 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
         } else if (option == SCTP_NODELAY) {
             setSctpNoDelay((Boolean) value);
         } else if (option == SCTP_INIT_MAXSTREAMS) {
-            setInitMaxStreams((SctpStandardSocketOptions.InitMaxStreams) value);
+            List<Integer> minMax = (List<Integer>) value;
+            setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams.create(minMax.get(0), minMax.get(1)));
         } else {
             return super.setOption(option, value);
         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -808,7 +808,6 @@ private static int getEncryptedPacketLength(ByteBuf buffer) {
         return packetLength;
     }
 
-    @Override
     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws SSLException {
         int packetLength = this.packetLength;
         if (packetLength == 0) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -155,7 +155,7 @@ public final ChannelFuture handshake(Channel channel, FullHttpRequest req,
                                             HttpHeaders responseHeaders, final ChannelPromise promise) {
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("Channel %s WS Version %s server handshake", version(), channel.id()));
+            logger.debug(String.format("Channel %s WS Version %s server handshake", version(), channel.hashCode()));
         }
         FullHttpResponse response = newHandshakeResponse(req, responseHeaders);
         channel.write(response).addListener(new ChannelFutureListener() {

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -95,7 +95,7 @@ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req)
     private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame, MessageList<Object> out) {
         if (logger.isLoggable(Level.FINE)) {
             logger.fine(String.format(
-                    "Channel %s received %s", ctx.channel().id(), frame.getClass().getSimpleName()));
+                    "Channel %s received %s", ctx.channel().hashCode(), frame.getClass().getSimpleName()));
         }
 
         if (frame instanceof CloseWebSocketFrame) {

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -121,7 +121,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
         // Send the uppercase string back.
         String request = ((TextWebSocketFrame) frame).text();
         if (logger.isLoggable(Level.FINE)) {
-            logger.fine(String.format("Channel %s received %s", ctx.channel().id(), request));
+            logger.fine(String.format("Channel %s received %s", ctx.channel().hashCode(), request));
         }
         ctx.channel().write(new TextWebSocketFrame(request.toUpperCase()));
     }

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
Patch:
@@ -123,7 +123,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
         // Send the uppercase string back.
         String request = ((TextWebSocketFrame) frame).text();
         if (logger.isLoggable(Level.FINE)) {
-            logger.fine(String.format("Channel %s received %s", ctx.channel().id(), request));
+            logger.fine(String.format("Channel %s received %s", ctx.channel().hashCode(), request));
         }
         ctx.channel().write(new TextWebSocketFrame(request.toUpperCase()));
     }

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -87,7 +87,7 @@ public ChannelTrafficShapingHandler(long checkInterval) {
     @Override
     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         TrafficCounter trafficCounter = new TrafficCounter(this, ctx.executor(), "ChannelTC" +
-                ctx.channel().id(), checkInterval);
+                ctx.channel().hashCode(), checkInterval);
         setTrafficCounter(trafficCounter);
         trafficCounter.start();
     }

File: transport/src/main/java/io/netty/channel/local/LocalAddress.java
Patch:
@@ -40,7 +40,7 @@ public final class LocalAddress extends SocketAddress implements Comparable<Loca
     LocalAddress(Channel channel) {
         StringBuilder buf = new StringBuilder(16);
         buf.append("local:E");
-        buf.append(Long.toHexString(channel.id().intValue() & 0xFFFFFFFFL | 0x100000000L));
+        buf.append(Long.toHexString(channel.hashCode() & 0xFFFFFFFFL | 0x100000000L));
         buf.setCharAt(7, ':');
         id = buf.substring(6);
         strVal = buf.toString();

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -186,7 +186,7 @@ public ChannelGroupFuture close() {
             new LinkedHashMap<Integer, ChannelFuture>(size());
 
         for (Channel c: serverChannels.values()) {
-            futures.put(c.id(), c.close().awaitUninterruptibly());
+            futures.put(c.id(), c.close());
         }
         for (Channel c: nonServerChannels.values()) {
             futures.put(c.id(), c.close());

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * A skeletal implementation of a buffer.
  */
-public abstract class AbstractByteBuf implements ByteBuf {
+public abstract class AbstractByteBuf extends ByteBuf {
 
     static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);
 

File: buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
Patch:
@@ -153,7 +153,7 @@ public CompositeByteBuf compositeHeapBuffer() {
 
     @Override
     public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {
-        return new DefaultCompositeByteBuf(this, false, maxNumComponents);
+        return new CompositeByteBuf(this, false, maxNumComponents);
     }
 
     @Override
@@ -163,7 +163,7 @@ public CompositeByteBuf compositeDirectBuffer() {
 
     @Override
     public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {
-        return new DefaultCompositeByteBuf(this, true, maxNumComponents);
+        return new CompositeByteBuf(this, true, maxNumComponents);
     }
 
     private static void validate(int initialCapacity, int maxCapacity) {

File: buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * An empty {@link ByteBuf} whose capacity and maximum capacity are all {@code 0}.
  */
-public final class EmptyByteBuf implements ByteBuf {
+public final class EmptyByteBuf extends ByteBuf {
 
     private static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.allocateDirect(0);
     private static final long EMPTY_BYTE_BUFFER_ADDRESS;

File: buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
Patch:
@@ -24,7 +24,7 @@
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
 
-public final class SwappedByteBuf implements ByteBuf {
+public final class SwappedByteBuf extends ByteBuf {
 
     private final ByteBuf buf;
     private final ByteOrder order;

File: buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
Patch:
@@ -30,7 +30,7 @@
  * A {@link ByteBuf} implementation that wraps another buffer to prevent a user from increasing or decreasing the
  * wrapped buffer's reference count.
  */
-final class UnreleasableByteBuf implements ByteBuf {
+final class UnreleasableByteBuf extends ByteBuf {
 
     private final ByteBuf buf;
     private SwappedByteBuf swappedBuf;

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
Patch:
@@ -33,7 +33,7 @@
 /**
  * Special {@link ByteBuf} implementation which is used by the {@link ReplayingDecoder}
  */
-final class ReplayingDecoderBuffer implements ByteBuf {
+final class ReplayingDecoderBuffer extends ByteBuf {
 
     private static final Signal REPLAY = ReplayingDecoder.REPLAY;
 

File: common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java
Patch:
@@ -45,8 +45,8 @@
  * <p>This class also provides additional commonly used bounded random
  * generation methods.
  *
- * //@since 1.7
- * //@author Doug Lea
+ * //since 1.7
+ * //author Doug Lea
  */
 @SuppressWarnings("all")
 public class ThreadLocalRandom extends Random {

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -248,7 +248,7 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Obj
                     break;
                 }
             }
-        } catch (CodecException e) {
+        } catch (DecoderException e) {
             throw e;
         } catch (Throwable cause) {
             throw new DecoderException(cause);

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -956,7 +956,7 @@ private void setHandshakeFailure(Throwable cause) {
     private void notifyHandshakeFailure(Throwable cause) {
         if (handshakePromise.tryFailure(cause)) {
             ctx.fireUserEventTriggered(new SslHandshakeCompletionEvent(cause));
-            ctx.pipeline().fireExceptionCaught(cause);
+            ctx.close();
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
Patch:
@@ -30,6 +30,9 @@ public interface HttpContent extends HttpObject, ByteBufHolder {
     @Override
     HttpContent copy();
 
+    @Override
+    HttpContent duplicate();
+
     @Override
     HttpContent retain();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
Patch:
@@ -34,6 +34,9 @@ public interface Attribute extends HttpData {
     @Override
     Attribute copy();
 
+    @Override
+    Attribute duplicate();
+
     @Override
     Attribute retain();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
Patch:
@@ -59,6 +59,9 @@ public interface FileUpload extends HttpData {
     @Override
     FileUpload copy();
 
+    @Override
+    FileUpload duplicate();
+
     @Override
     FileUpload retain();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
Patch:
@@ -180,6 +180,9 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
     @Override
     HttpData copy();
 
+    @Override
+    HttpData duplicate();
+
     @Override
     HttpData retain();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
Patch:
@@ -62,6 +62,9 @@ public int rsv() {
     @Override
     public abstract WebSocketFrame copy();
 
+    @Override
+    public abstract WebSocketFrame duplicate();
+
     @Override
     public String toString() {
         return getClass().getSimpleName() + "(data: " + content().toString() + ')';

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
Patch:
@@ -42,6 +42,9 @@ public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
     @Override
     SpdyDataFrame copy();
 
+    @Override
+    SpdyDataFrame duplicate();
+
     @Override
     SpdyDataFrame retain();
 

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -251,7 +251,7 @@ private static Object safeDuplicate(Object message) {
         if (message instanceof ByteBuf) {
             return ((ByteBuf) message).duplicate().retain();
         } else if (message instanceof ByteBufHolder) {
-            return ((ByteBufHolder) message).copy();
+            return ((ByteBufHolder) message).duplicate().retain();
         } else {
             return ReferenceCountUtil.retain(message);
         }

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -78,7 +78,7 @@
  * current {@link #readerIndex() readerIndex} and increase it by the number of
  * read bytes.  If the argument of the read operation is also a
  * {@link ByteBuf} and no destination index is specified, the specified
- * buffer's {@link #readerIndex() readerIndex} is increased together.
+ * buffer's {@link #writerIndex() writerIndex} is increased together.
  * <p>
  * If there's not enough content left, {@link IndexOutOfBoundsException} is
  * raised.  The default value of newly allocated, wrapped or copied buffer's
@@ -181,7 +181,7 @@
  * For complicated searches, use {@link #forEachByte(int, int, ByteBufProcessor)} with a {@link ByteBufProcessor}
  * implementation.
  *
- *  <h3>Mark and reset</h3>
+ * <h3>Mark and reset</h3>
  *
  * There are two marker indexes in every buffer. One is for storing
  * {@link #readerIndex() readerIndex} and the other is for storing

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -163,7 +163,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Obj
             case AWAIT_CONTENT: {
                 ensureContent(msg);
                 encodeContent((HttpContent) msg, out);
-                if (out.get(out.size() - 1)  instanceof LastHttpContent) {
+                if (out.last()  instanceof LastHttpContent) {
                     state = State.AWAIT_HEADERS;
                 }
                 break;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
Patch:
@@ -103,7 +103,7 @@ public void addContent(ByteBuf buffer, boolean last)
                 cbb.addComponent(buffer);
                 cbb.writerIndex(cbb.writerIndex() + buffer.readableBytes());
             } else {
-                CompositeByteBuf cbb = compositeBuffer();
+                CompositeByteBuf cbb = compositeBuffer(Integer.MAX_VALUE);
                 cbb.addComponents(byteBuf, buffer);
                 cbb.writerIndex(byteBuf.readableBytes() + buffer.readableBytes());
                 byteBuf = cbb;
@@ -142,7 +142,7 @@ public void setContent(File file) throws IOException {
         if (byteBuf != null) {
             byteBuf.release();
         }
-        byteBuf = wrappedBuffer(byteBuffer);
+        byteBuf = wrappedBuffer(Integer.MAX_VALUE, byteBuffer);
         size = newsize;
         completed = true;
     }

File: transport/src/main/java/io/netty/channel/VoidChannelPromise.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 
-import java.util.concurrent.CancellationException;
 import java.util.concurrent.TimeUnit;
 
 final class VoidChannelPromise extends AbstractFuture<Void> implements ChannelPromise {
@@ -167,7 +166,6 @@ public boolean tryFailure(Throwable cause) {
 
     @Override
     public boolean cancel(boolean mayInterruptIfRunning) {
-        fireException(new CancellationException());
         return false;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -288,6 +288,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object>
                         framePayload = payloadBuffer;
                     } else if (payloadBuffer != null) {
                         framePayload.writeBytes(payloadBuffer);
+                        payloadBuffer.release();
                     }
 
                     // Unmask data if needed

File: transport/src/main/java/io/netty/channel/MessageList.java
Patch:
@@ -268,7 +268,7 @@ public MessageList<T> add(T[] src, int srcIdx, int srcLen) {
         try {
             if (byteBufsOnly) {
                 while (i < srcEndIdx) {
-                    T m = src[srcIdx];
+                    T m = src[i];
                     if (m == null) {
                         throw new NullPointerException("src[" + srcIdx + ']');
                     }
@@ -284,7 +284,7 @@ public MessageList<T> add(T[] src, int srcIdx, int srcLen) {
             }
 
             for (; i < srcEndIdx; i ++) {
-                T m = src[srcIdx];
+                T m = src[i];
                 if (m == null) {
                     throw new NullPointerException("src[" + srcIdx + ']');
                 }

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -35,7 +35,7 @@ public final class ResourceLeakDetector<T> {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ResourceLeakDetector.class);
 
     static {
-        logger.debug("io.netty.noResourceLeakDetection: {}", DISABLED);
+        logger.debug("-Dio.netty.noResourceLeakDetection: {}", DISABLED);
     }
 
     private static final int DEFAULT_SAMPLING_INTERVAL = 113;

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -38,7 +38,7 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
                 "io.netty.eventLoopThreads", Runtime.getRuntime().availableProcessors() * 2));
 
         if (logger.isDebugEnabled()) {
-            logger.debug("io.netty.eventLoopThreads: {}", DEFAULT_EVENT_LOOP_THREADS);
+            logger.debug("-Dio.netty.eventLoopThreads: {}", DEFAULT_EVENT_LOOP_THREADS);
         }
     }
 

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -84,8 +84,8 @@ public final class NioEventLoop extends SingleThreadEventLoop {
         SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold;
 
         if (logger.isDebugEnabled()) {
-            logger.debug("io.netty.noKeySetOptimization: {}", DISABLE_KEYSET_OPTIMIZATION);
-            logger.debug("io.netty.selectorAutoRebuildThreshold: {}", SELECTOR_AUTO_REBUILD_THRESHOLD);
+            logger.debug("-Dio.netty.noKeySetOptimization: {}", DISABLE_KEYSET_OPTIMIZATION);
+            logger.debug("-Dio.netty.selectorAutoRebuildThreshold: {}", SELECTOR_AUTO_REBUILD_THRESHOLD);
         }
     }
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -561,7 +561,7 @@ private static boolean hasJavassist0() {
             return true;
         } catch (Throwable t) {
             logger.debug("Javassist: unavailable");
-            logger.info(
+            logger.debug(
                     "You don't have Javassist in your class path or you don't have enough permission " +
                     "to load dynamically generated classes.  Please check the configuration for better performance.");
             return false;

File: transport/src/main/java/io/netty/channel/MessageList.java
Patch:
@@ -267,13 +267,14 @@ public MessageList<T> add(T[] src, int srcIdx, int srcLen) {
         int i = srcIdx;
         try {
             if (byteBufsOnly) {
-                for (; i < srcEndIdx; i ++) {
+                while (i < srcEndIdx) {
                     T m = src[srcIdx];
                     if (m == null) {
                         throw new NullPointerException("src[" + srcIdx + ']');
                     }
 
                     elements[dstIdx ++] = m;
+                    i ++;
 
                     if (!(m instanceof ByteBuf)) {
                         byteBufsOnly = false;
@@ -297,7 +298,7 @@ public MessageList<T> add(T[] src, int srcIdx, int srcLen) {
             }
         }
 
-        assert dstIdx == newSize;
+        assert dstIdx == newSize : String.format("dstIdx(%d) != newSize(%d)", dstIdx, newSize);
         size = newSize;
 
         return this;

File: buffer/src/test/java/io/netty/buffer/ByteBufIndexFinderTest.java
Patch:
@@ -15,15 +15,16 @@
  */
 package io.netty.buffer;
 
-import static org.junit.Assert.*;
 import io.netty.util.CharsetUtil;
-
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 
 /**
  * Tests the index-finding capabilities of channel buffers
  */
+@SuppressWarnings("deprecation")
 public class ByteBufIndexFinderTest {
 
     @Test

File: codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
Patch:
@@ -16,11 +16,11 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.TypeParameterMatcher;
 
 
@@ -99,7 +99,7 @@ public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPr
                     try {
                         encode(ctx, cast, buf);
                     } finally {
-                        ByteBufUtil.release(cast);
+                        ReferenceCountUtil.release(cast);
                     }
                 } else {
                     if (buf != null && buf.isReadable()) {

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.TypeParameterMatcher;
 
@@ -81,7 +81,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs)
                     try {
                         decode(ctx, cast, out);
                     } finally {
-                        ByteBufUtil.release(cast);
+                        ReferenceCountUtil.release(cast);
                     }
                 } else {
                     out.add(m);

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
Patch:
@@ -15,11 +15,11 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.TypeParameterMatcher;
 
@@ -79,7 +79,7 @@ public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPr
                     try {
                         encode(ctx, cast, out);
                     } finally {
-                        ByteBufUtil.release(cast);
+                        ReferenceCountUtil.release(cast);
                     }
                 } else {
                     out.add(m);

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -18,8 +18,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.buffer.ByteBufUtil;
 import io.netty.util.DefaultAttributeMap;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -715,7 +715,7 @@ public final void flushNow() {
                     if (promise.isCancelled()) {
                         // If cancelled, release all unwritten messages and recycle.
                         for (int i = messageIndex; i < messageCount; i ++) {
-                            ByteBufUtil.release(messages.get(i));
+                            ReferenceCountUtil.release(messages.get(i));
                         }
                         messages.recycle();
                         if (!outboundBuffer.next()) {

File: transport/src/main/java/io/netty/channel/AbstractServerChannel.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ByteBufUtil;
+import io.netty.util.ReferenceCountUtil;
 
 import java.net.SocketAddress;
 
@@ -81,7 +81,7 @@ public void write(MessageList<?> msgs, ChannelPromise promise) {
             reject(promise);
             int size = msgs.size();
             for (int i = 0; i < size; i ++) {
-                ByteBufUtil.release(msgs.get(i));
+                ReferenceCountUtil.release(msgs.get(i));
             }
         }
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
Patch:
@@ -19,7 +19,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ByteBufUtil;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -228,7 +228,7 @@ void fail(Throwable cause) {
             try {
                 for (int i = currentMessageIndex; i < currentMessages.size(); i++) {
                     Object msg = currentMessages.get(i);
-                    ByteBufUtil.release(msg);
+                    ReferenceCountUtil.release(msg);
                 }
             } finally {
                 currentMessages.recycle();

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.Channel.Unsafe;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.internal.PlatformDependent;
@@ -970,7 +970,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs)
                         "Discarded inbound message {} that reached at the tail of the pipeline. " +
                                 "Please check your pipeline configuration.", m);
 
-                ByteBufUtil.release(m);
+                ReferenceCountUtil.release(m);
             }
 
             if (length != 1) {

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -31,7 +31,7 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(MultithreadEventLoopGroup.class);
 
-    public static final int DEFAULT_EVENT_LOOP_THREADS;
+    private static final int DEFAULT_EVENT_LOOP_THREADS;
 
     static {
         DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
@@ -43,7 +43,7 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
     }
 
     protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
-        super(nThreads, threadFactory, args);
+        super(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalEventLoopGroup.java
Patch:
@@ -26,10 +26,10 @@
 public class LocalEventLoopGroup extends MultithreadEventLoopGroup {
 
     /**
-     * Create a new instance which used {@link #DEFAULT_EVENT_LOOP_THREADS} number of Threads
+     * Create a new instance with the default number of threads.
      */
     public LocalEventLoopGroup() {
-        this(DEFAULT_EVENT_LOOP_THREADS);
+        this(0);
     }
 
     /**

File: example/src/main/java/io/netty/example/filetransfer/FileServer.java
Patch:
@@ -101,11 +101,12 @@ public void messageReceived(ChannelHandlerContext ctx, String msg) throws Except
                     ctx.write("Not a file: " + file + '\n');
                     return;
                 }
-                MessageList<Object> out = MessageList.newInstance();
                 ctx.write(file + " " + file.length() + '\n');
+                MessageList<Object> out = MessageList.newInstance();
                 FileRegion region = new DefaultFileRegion(new FileInputStream(file).getChannel(), 0, file.length());
                 out.add(region);
                 out.add("\n");
+                ctx.write(out);
             } else {
                 ctx.write("File not found: " + file + '\n');
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -217,6 +217,9 @@ public ChannelFuture close(Channel channel, CloseWebSocketFrame frame) {
      *            the {@link ChannelPromise} to be notified when the closing handshake is done
      */
     public ChannelFuture close(Channel channel, CloseWebSocketFrame frame, ChannelPromise promise) {
+        if (channel == null) {
+            throw new NullPointerException("channel");
+        }
         return channel.write(frame, promise).addListener(ChannelFutureListener.CLOSE);
     }
 

File: example/src/main/java/io/netty/example/telnet/TelnetServer.java
Patch:
@@ -38,7 +38,7 @@ public void run() throws Exception {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new TelnetServerPipelineFactory());
+             .childHandler(new TelnetServerInitializer());
 
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {

File: example/src/main/java/io/netty/example/telnet/TelnetServerInitializer.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Creates a newly configured {@link ChannelPipeline} for a new channel.
  */
-public class TelnetServerPipelineFactory extends ChannelInitializer<SocketChannel> {
+public class TelnetServerInitializer extends ChannelInitializer<SocketChannel> {
     private static final StringDecoder DECODER = new StringDecoder();
     private static final StringEncoder ENCODER = new StringEncoder();
     private static final TelnetServerHandler SERVERHANDLER = new TelnetServerHandler();

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -39,7 +39,7 @@ public class DefaultChannelConfig implements ChannelConfig {
     private volatile ByteBufAllocator allocator = DEFAULT_ALLOCATOR;
     private volatile RecvByteBufAllocator rcvBufAllocator = DEFAULT_RCVBUF_ALLOCATOR;
     private volatile int connectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT;
-    private volatile int maxMessagesPerRead = 16;
+    private volatile int maxMessagesPerRead = 1;
     private volatile int writeSpinCount = 16;
     private volatile boolean autoRead = true;
     private volatile int writeBufferHighWaterMark = 64 * 1024;

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -272,6 +272,9 @@ public static Paritybit valueOf(int value) {
     @Override
     RxtxChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    RxtxChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     RxtxChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
Patch:
@@ -99,6 +99,9 @@ public interface SctpChannelConfig extends ChannelConfig {
     @Override
     SctpChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    SctpChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     SctpChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
Patch:
@@ -91,6 +91,9 @@ public interface SctpServerChannelConfig extends ChannelConfig {
      */
     SctpServerChannelConfig setInitMaxStreams(InitMaxStreams initMaxStreams);
 
+    @Override
+    SctpServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     SctpServerChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
Patch:
@@ -114,6 +114,9 @@ public interface UdtChannelConfig extends ChannelConfig {
     @Override
     UdtChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    UdtChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     UdtChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
Patch:
@@ -48,6 +48,9 @@ public interface UdtServerChannelConfig extends UdtChannelConfig {
     @Override
     UdtServerChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    UdtServerChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     UdtServerChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -42,6 +42,8 @@ public class ChannelOption<T> extends UniqueName {
 
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS =
             new ChannelOption<Integer>("CONNECT_TIMEOUT_MILLIS");
+    public static final ChannelOption<Integer> MAX_MESSAGES_PER_READ =
+            new ChannelOption<Integer>("MAX_MESSAGES_PER_READ");
     public static final ChannelOption<Integer> WRITE_SPIN_COUNT =
             new ChannelOption<Integer>("WRITE_SPIN_COUNT");
     public static final ChannelOption<Integer> WRITE_BUFFER_HIGH_WATER_MARK =

File: transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
Patch:
@@ -155,6 +155,9 @@ public interface DatagramChannelConfig extends ChannelConfig {
      */
     DatagramChannelConfig setNetworkInterface(NetworkInterface networkInterface);
 
+    @Override
+    DatagramChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     DatagramChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
Patch:
@@ -86,6 +86,9 @@ public interface ServerSocketChannelConfig extends ChannelConfig {
     @Override
     ServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    ServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     ServerSocketChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
Patch:
@@ -159,6 +159,9 @@ public interface SocketChannelConfig extends ChannelConfig {
     @Override
     SocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    SocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     SocketChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
Patch:
@@ -65,6 +65,9 @@ public interface OioServerSocketChannelConfig extends ServerSocketChannelConfig
     @Override
     OioServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    OioServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     OioServerSocketChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
Patch:
@@ -80,6 +80,9 @@ public interface OioSocketChannelConfig extends SocketChannelConfig {
     @Override
     OioSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
+    @Override
+    OioSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead);
+
     @Override
     OioSocketChannelConfig setWriteSpinCount(int writeSpinCount);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
Patch:
@@ -98,8 +98,8 @@ public void addContent(ByteBuf buffer, boolean last)
                 cbb.writerIndex(cbb.writerIndex() + buffer.readableBytes());
             } else {
                 CompositeByteBuf cbb = compositeBuffer();
-                cbb.addComponent(buffer);
-                cbb.writerIndex(buffer.readableBytes());
+                cbb.addComponents(byteBuf, buffer);
+                cbb.writerIndex(byteBuf.readableBytes() + buffer.readableBytes());
                 byteBuf = cbb;
             }
         }

File: transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
Patch:
@@ -63,7 +63,7 @@ public class AdaptiveRecvByteBufAllocator implements RecvByteBufAllocator {
     private static int getSizeTableIndex(final int size) {
         for (int low = 0, high = SIZE_TABLE.length - 1;;) {
             if (high < low) {
-                return 0;
+                return low;
             }
             if (high == low) {
                 return high;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -117,15 +117,15 @@ protected FullHttpRequest newHandshakeRequest() {
         }
 
         // Format request
+        int wsPort = wsURL.getPort();
         FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);
         HttpHeaders headers = request.headers();
 
         headers.add(Names.UPGRADE, Values.WEBSOCKET.toLowerCase())
                .add(Names.CONNECTION, Values.UPGRADE)
                .add(Names.SEC_WEBSOCKET_KEY, key)
-               .add(Names.HOST, wsURL.getHost());
+               .add(Names.HOST, wsURL.getHost() + ':' + wsPort);
 
-        int wsPort = wsURL.getPort();
         String originValue = "http://" + wsURL.getHost();
         if (wsPort != 80 && wsPort != 443) {
             // if the port is not standard (80/443) its needed to add the port to the header.

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
Patch:
@@ -48,7 +48,6 @@ public void operationComplete(ChannelFuture future) throws Exception {
     protected void messageReceived(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {
         if (!handshaker.isHandshakeComplete()) {
             handshaker.finishHandshake(ctx.channel(), msg);
-            msg.release();
             ctx.fireUserEventTriggered(
                     WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HANDSHAKE_COMPLETE);
             ctx.pipeline().remove(this);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandler;
-import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.MessageList;
 import io.netty.channel.SimpleChannelInboundHandler;
@@ -125,7 +124,6 @@ static ChannelHandler forbiddenHttpRequestResponder() {
         return new SimpleChannelInboundHandler<FullHttpRequest>() {
             @Override
             protected void messageReceived(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {
-                msg.release();
                 FullHttpResponse response =
                         new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.FORBIDDEN);
                 ctx.channel().write(response);

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -17,10 +17,10 @@
 
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -156,11 +156,11 @@ public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPr
         }
     }
 
-    private static class CustomTextFrameHandler extends ChannelInboundConsumingHandler<TextWebSocketFrame> {
+    private static class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
         private String content;
 
         @Override
-        public void consume(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
             assertNull(content);
             content = "processed: " + msg.text();
         }

File: example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
Patch:
@@ -19,9 +19,9 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -72,10 +72,10 @@ public void destroy() {
         }
     }
 
-    private static final class DiscardServerHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static final class DiscardServerHandler extends SimpleChannelInboundHandler<ByteBuf> {
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
             System.out.println("Received: " + msg.toString(CharsetUtil.UTF_8));
         }
 

File: example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
Patch:
@@ -71,8 +71,7 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void messageReceived(
-            ChannelHandlerContext ctx, final BigInteger msg) {
+    public void messageReceived(ChannelHandlerContext ctx, final BigInteger msg) {
         receivedMessages ++;
         if (receivedMessages == count) {
             // Offer the answer after closing the connection.

File: example/src/main/java/io/netty/example/filetransfer/FileServer.java
Patch:
@@ -18,13 +18,13 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultFileRegion;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.FileRegion;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -92,9 +92,9 @@ public static void main(String[] args) throws Exception {
         new FileServer(port).run();
     }
 
-    private static final class FileHandler extends ChannelInboundConsumingHandler<String> {
+    private static final class FileHandler extends SimpleChannelInboundHandler<String> {
         @Override
-        public void consume(ChannelHandlerContext ctx, String msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
             File file = new File(msg);
             if (file.exists()) {
                 if (!file.isFile()) {

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -19,8 +19,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -98,14 +98,14 @@
  *
  * </pre>
  */
-public class HttpStaticFileServerHandler extends ChannelInboundConsumingHandler<FullHttpRequest> {
+public class HttpStaticFileServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {
 
     public static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
     public static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
     public static final int HTTP_CACHE_SECONDS = 60;
 
     @Override
-    public void consume(
+    public void messageReceived(
             ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
         if (!request.getDecoderResult().isSuccess()) {
             sendError(ctx, BAD_REQUEST);

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -16,18 +16,18 @@
 package io.netty.example.http.snoop;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.util.CharsetUtil;
 
-public class HttpSnoopClientHandler extends ChannelInboundConsumingHandler<HttpObject> {
+public class HttpSnoopClientHandler extends SimpleChannelInboundHandler<HttpObject> {
 
     @Override
-    public void consume(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.http.upload;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpObject;
@@ -29,14 +29,14 @@
 /**
  * Handler that just dumps the contents of the response from the server
  */
-public class HttpUploadClientHandler extends ChannelInboundConsumingHandler<HttpObject> {
+public class HttpUploadClientHandler extends SimpleChannelInboundHandler<HttpObject> {
 
     private static final Logger logger = Logger.getLogger(HttpUploadClientHandler.class.getName());
 
     private boolean readingChunks;
 
     @Override
-    public void consume(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -40,8 +40,8 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
@@ -50,7 +50,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.util.CharsetUtil;
 
-public class WebSocketClientHandler extends ChannelInboundConsumingHandler<Object> {
+public class WebSocketClientHandler extends SimpleChannelInboundHandler<Object> {
 
     private final WebSocketClientHandshaker handshaker;
     private ChannelPromise handshakeFuture;
@@ -79,7 +79,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void consume(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         Channel ch = ctx.channel();
         if (!handshaker.isHandshakeComplete()) {
             handshaker.finishHandshake(ch, (FullHttpResponse) msg);

File: example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
Patch:
@@ -20,11 +20,9 @@
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 
 public class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
-
     @Override
     public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame frame) throws Exception {
         String request = frame.text();
         ctx.channel().write(new TextWebSocketFrame(request.toUpperCase()));
     }
-
 }

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -45,15 +45,15 @@
 /**
  * Handles handshakes and messages
  */
-public class WebSocketServerHandler extends ChannelInboundConsumingHandler<Object> {
+public class WebSocketServerHandler extends SimpleChannelInboundHandler<Object> {
     private static final Logger logger = Logger.getLogger(WebSocketServerHandler.class.getName());
 
     private static final String WEBSOCKET_PATH = "/websocket";
 
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void consume(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof FullHttpRequest) {
             handleHttpRequest(ctx, (FullHttpRequest) msg);
         } else if (msg instanceof WebSocketFrame) {

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.example.http.websocketx.server.WebSocketServerIndexPage;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -46,15 +46,15 @@
 /**
  * Handles handshakes and messages
  */
-public class WebSocketSslServerHandler extends ChannelInboundConsumingHandler<Object> {
+public class WebSocketSslServerHandler extends SimpleChannelInboundHandler<Object> {
     private static final Logger logger = Logger.getLogger(WebSocketSslServerHandler.class.getName());
 
     private static final String WEBSOCKET_PATH = "/websocket";
 
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void consume(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof FullHttpRequest) {
             handleHttpRequest(ctx, (FullHttpRequest) msg);
         } else if (msg instanceof WebSocketFrame) {

File: example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java
Patch:
@@ -16,12 +16,12 @@
 package io.netty.example.localecho;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 
-public class LocalEchoClientHandler extends ChannelInboundConsumingHandler<Object> {
+public class LocalEchoClientHandler extends SimpleChannelInboundHandler<Object> {
 
     @Override
-    public void consume(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         // Print as received
         System.out.println(msg);
     }

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
Patch:
@@ -16,14 +16,14 @@
 package io.netty.example.qotm;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.util.CharsetUtil;
 
-public class QuoteOfTheMomentClientHandler extends ChannelInboundConsumingHandler<DatagramPacket> {
+public class QuoteOfTheMomentClientHandler extends SimpleChannelInboundHandler<DatagramPacket> {
 
     @Override
-    public void consume(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
         String response = msg.content().toString(CharsetUtil.UTF_8);
         if (response.startsWith("QOTM: ")) {
             System.out.println("Quote of the Moment: " + response.substring(6));

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
Patch:
@@ -17,13 +17,13 @@
 
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.util.CharsetUtil;
 
 import java.util.Random;
 
-public class QuoteOfTheMomentServerHandler extends ChannelInboundConsumingHandler<DatagramPacket> {
+public class QuoteOfTheMomentServerHandler extends SimpleChannelInboundHandler<DatagramPacket> {
 
     private static final Random random = new Random();
 
@@ -44,7 +44,7 @@ private static String nextQuote() {
     }
 
     @Override
-    public void consume(ChannelHandlerContext ctx, DatagramPacket packet) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, DatagramPacket packet) throws Exception {
         System.err.println(packet);
         if ("QOTM?".equals(packet.content().toString(CharsetUtil.UTF_8))) {
             ctx.write(new DatagramPacket(

File: example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java
Patch:
@@ -16,17 +16,17 @@
 package io.netty.example.rxtx;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 
-public class RxtxClientHandler extends ChannelInboundConsumingHandler<String> {
+public class RxtxClientHandler extends SimpleChannelInboundHandler<String> {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) {
         ctx.write("AT\n");
     }
 
     @Override
-    public void consume(ChannelHandlerContext ctx,  String msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
         if ("OK".equals(msg)) {
             System.out.println("Serial port responded to AT");
         } else {

File: example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
Patch:
@@ -16,21 +16,21 @@
 package io.netty.example.securechat;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
  * Handles a client-side channel.
  */
-public class SecureChatClientHandler extends ChannelInboundConsumingHandler<String> {
+public class SecureChatClientHandler extends SimpleChannelInboundHandler<String> {
 
     private static final Logger logger = Logger.getLogger(
             SecureChatClientHandler.class.getName());
 
     @Override
-    public void consume(ChannelHandlerContext ctx, String msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
         System.err.println(msg);
     }
 

File: example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.handler.ssl.SslHandler;
@@ -32,7 +32,7 @@
 /**
  * Handles a server-side channel.
  */
-public class SecureChatServerHandler extends ChannelInboundConsumingHandler<String> {
+public class SecureChatServerHandler extends SimpleChannelInboundHandler<String> {
 
     private static final Logger logger = Logger.getLogger(
             SecureChatServerHandler.class.getName());
@@ -61,7 +61,7 @@ public void operationComplete(Future<Channel> future) throws Exception {
     }
 
     @Override
-    public void consume(ChannelHandlerContext ctx, String msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
         // Send the received message to all channels but the current one.
         for (Channel c: channels) {
             if (c != ctx.channel()) {

File: example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
Patch:
@@ -28,8 +28,7 @@
 @Sharable
 public class TelnetClientHandler extends SimpleChannelInboundHandler<String> {
 
-    private static final Logger logger = Logger.getLogger(
-            TelnetClientHandler.class.getName());
+    private static final Logger logger = Logger.getLogger(TelnetClientHandler.class.getName());
 
     @Override
     protected void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {

File: example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 
 import java.net.InetAddress;
 import java.util.Date;
@@ -30,7 +30,7 @@
  * Handles a server-side channel.
  */
 @Sharable
-public class TelnetServerHandler extends ChannelInboundConsumingHandler<String> {
+public class TelnetServerHandler extends SimpleChannelInboundHandler<String> {
 
     private static final Logger logger = Logger.getLogger(TelnetServerHandler.class.getName());
 
@@ -43,7 +43,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void consume(ChannelHandlerContext ctx, String request) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, String request) throws Exception {
 
         // Generate and write a response.
         String response;

File: testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
Patch:
@@ -21,8 +21,8 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.sctp.SctpChannel;
 import io.netty.handler.codec.sctp.SctpInboundByteStreamHandler;
 import io.netty.handler.codec.sctp.SctpMessageCompletionHandler;
@@ -138,7 +138,7 @@ public void initChannel(SctpChannel c) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -149,7 +149,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -19,10 +19,10 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.socket.oio.OioDatagramChannel;
@@ -93,14 +93,14 @@ public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs)
         cc.close().awaitUninterruptibly();
     }
 
-    private static final class MulticastTestHandler extends ChannelInboundConsumingHandler<DatagramPacket> {
+    private static final class MulticastTestHandler extends SimpleChannelInboundHandler<DatagramPacket> {
         private final CountDownLatch latch = new CountDownLatch(1);
 
         private boolean done;
         private volatile boolean fail;
 
         @Override
-        protected void consume(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
+        protected void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
             if (done) {
                 fail = true;
             }

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -19,9 +19,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.DatagramPacket;
 import org.junit.Test;
 
@@ -40,9 +40,9 @@ public void testSimpleSend() throws Throwable {
     public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {
         final CountDownLatch latch = new CountDownLatch(1);
 
-        sb.handler(new ChannelInboundConsumingHandler<DatagramPacket>() {
+        sb.handler(new SimpleChannelInboundHandler<DatagramPacket>() {
             @Override
-            public void consume(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
+            public void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
                 assertEquals(1, msg.content().readInt());
                 latch.countDown();
             }

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -21,8 +21,8 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
 import io.netty.util.concurrent.EventExecutorGroup;
@@ -180,7 +180,7 @@ protected void initChannel(SocketChannel c) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -192,7 +192,7 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
Patch:
@@ -20,12 +20,12 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInboundHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.DefaultFileRegion;
 import io.netty.channel.FileRegion;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import org.junit.Test;
 
 import java.io.File;
@@ -122,7 +122,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         }
     }
 
-    private static class TestHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -134,7 +134,7 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
Patch:
@@ -21,8 +21,8 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.FixedLengthFrameDecoder;
 import org.junit.Test;
@@ -123,7 +123,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -134,7 +134,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
             assertEquals(1024, msg.readableBytes());
 
             byte[] actual = new byte[msg.readableBytes()];

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
Patch:
@@ -18,8 +18,8 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.ChannelInputShutdownEvent;
 import io.netty.channel.socket.SocketChannel;
 import org.junit.Test;
@@ -109,7 +109,7 @@ public void testShutdownOutputWithoutOption(ServerBootstrap sb) throws Throwable
         }
     }
 
-    private static class TestHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile SocketChannel ch;
         final BlockingQueue<Byte> queue = new LinkedBlockingQueue<Byte>();
         final CountDownLatch halfClosure = new CountDownLatch(1);
@@ -127,7 +127,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
             queue.offer(msg.readByte());
         }
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import org.junit.Test;
 
@@ -76,7 +76,7 @@ public void testShutdownOutput(Bootstrap cb) throws Throwable {
         }
     }
 
-    private static class TestHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile SocketChannel ch;
         final BlockingQueue<Byte> queue = new LinkedBlockingQueue<Byte>();
 
@@ -86,7 +86,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
             queue.offer(msg.readByte());
         }
     }

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
Patch:
@@ -21,10 +21,10 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.spdy.SpdyConstants;
 import io.netty.handler.codec.spdy.SpdyFrameDecoder;
@@ -246,7 +246,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         }
     }
 
-    private static class SpdyEchoTestClientHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private static class SpdyEchoTestClientHandler extends SimpleChannelInboundHandler<ByteBuf> {
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         final ByteBuf frames;
         volatile int counter;
@@ -256,7 +256,7 @@ private static class SpdyEchoTestClientHandler extends ChannelInboundConsumingHa
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -21,8 +21,8 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
@@ -161,7 +161,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private class EchoHandler extends ChannelInboundConsumingHandler<ByteBuf> {
+    private class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -178,7 +178,7 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
Patch:
@@ -19,8 +19,8 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -135,7 +135,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    static class StringEchoHandler extends ChannelInboundConsumingHandler<String> {
+    static class StringEchoHandler extends SimpleChannelInboundHandler<String> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -146,7 +146,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, String msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
             assertEquals(data[counter], msg);
 
             if (channel.parent() != null) {

File: testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java
Patch:
@@ -19,11 +19,11 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
@@ -139,7 +139,7 @@ private void waitForShutdown() throws Exception {
         }
     }
 
-    static class ClientHandler extends ChannelInboundConsumingHandler<Object> {
+    static class ClientHandler extends SimpleChannelInboundHandler<Object> {
 
         static final Logger log = LoggerFactory.getLogger(ClientHandler.class);
 
@@ -169,7 +169,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
         }
 
         @Override
-        public void consume(ChannelHandlerContext ctx, Object msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
             log.info("Client received: " + msg);
         }
     }

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -19,12 +19,12 @@
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.ServerChannel;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.util.AttributeKey;
 import io.netty.util.internal.logging.InternalLogger;
@@ -217,7 +217,7 @@ private static Entry<AttributeKey<?>, Object>[] newAttrArray(int size) {
         return new Entry[size];
     }
 
-    private static class ServerBootstrapAcceptor extends ChannelInboundConsumingHandler<Channel> {
+    private static class ServerBootstrapAcceptor extends SimpleChannelInboundHandler<Channel> {
 
         private final EventLoopGroup childGroup;
         private final ChannelHandler childHandler;
@@ -236,7 +236,7 @@ private static class ServerBootstrapAcceptor extends ChannelInboundConsumingHand
 
         @Override
         @SuppressWarnings("unchecked")
-        public void consume(ChannelHandlerContext ctx, Channel child) {
+        public void messageReceived(ChannelHandlerContext ctx, Channel child) {
             child.pipeline().addLast(childHandler);
 
             for (Entry<ChannelOption<?>, Object> e: childOptions) {

File: transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
Patch:
@@ -27,7 +27,7 @@
  * Be aware that messages are not released after the {@link #messageReceived(ChannelHandlerContext, MessageList)}
  * method returns automatically. This is done for make it as flexible as possible and get the most out of
  * performance. Because of this you need to explicit call {@link MessageList#releaseAllAndRecycle()} if you
- * consumed all the messages. Because this is such a common need {@link ChannelInboundConsumingHandler} is provided ,
+ * consumed all the messages. Because this is such a common need {@link SimpleChannelInboundHandler} is provided ,
  * which will automatically release messages and the {@link MessageList} after processing is done.
  * </p>
  */

File: transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
Patch:
@@ -20,9 +20,9 @@
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundConsumingHandler;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -140,9 +140,9 @@ public void initChannel(LocalChannel ch) throws Exception {
         clientGroup.terminationFuture().sync();
     }
 
-    static class TestHandler extends ChannelInboundConsumingHandler<Object> {
+    static class TestHandler extends SimpleChannelInboundHandler<Object> {
         @Override
-        public void consume(ChannelHandlerContext ctx, Object msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
             logger.info(String.format("Received mesage: %s", msg));
         }
     }

File: transport/src/main/java/io/netty/channel/DefaultFileRegion.java
Patch:
@@ -49,7 +49,7 @@ public DefaultFileRegion(FileChannel file, long position, long count) {
         if (position < 0) {
             throw new IllegalArgumentException("position must be >= 0 but was " + position);
         }
-        if (count <= 0) {
+        if (count < 0) {
             throw new IllegalArgumentException("count must be >= 0 but was " + count);
         }
         this.file = file;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -27,8 +27,8 @@
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
-import io.netty.handler.logging.ByteLoggingHandler;
 import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.testsuite.util.BogusSslContextFactory;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
@@ -76,7 +76,7 @@ public void testStartTls(ServerBootstrap sb, Bootstrap cb) throws Throwable {
             @Override
             public void initChannel(SocketChannel sch) throws Exception {
                 ChannelPipeline p = sch.pipeline();
-                p.addLast("logger", new ByteLoggingHandler(LOG_LEVEL));
+                p.addLast("logger", new LoggingHandler(LOG_LEVEL));
                 p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder());
                 p.addLast(executor, sh);
             }
@@ -86,7 +86,7 @@ public void initChannel(SocketChannel sch) throws Exception {
             @Override
             public void initChannel(SocketChannel sch) throws Exception {
                 ChannelPipeline p = sch.pipeline();
-                p.addLast("logger", new ByteLoggingHandler(LOG_LEVEL));
+                p.addLast("logger", new LoggingHandler(LOG_LEVEL));
                 p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder());
                 p.addLast(executor, ch);
             }

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -310,9 +310,7 @@ private void logMessages(ChannelHandlerContext ctx, String eventName, MessageLis
                 logger.log(internalLevel, format(ctx, formatEmptyMessageList(eventName)));
             } else {
                 for (int i = 0; i < size; i ++) {
-                    Object msg = msgs.get(i);
-                    logger.log(internalLevel, format(ctx, formatMessage(eventName, i + 1, size, msg)));
-
+                    logger.log(internalLevel, format(ctx, formatMessage(eventName, i + 1, size, msgs.get(i))));
                 }
             }
         }

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -287,6 +287,7 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
 
                 // Configure output.
                 int maxOutputLength = (int) Math.ceil(inputLength * 1.001) + 12;
+                out.ensureWritable(maxOutputLength);
                 z.avail_out = maxOutputLength;
                 z.next_out = out.array();
                 z.next_out_index = out.arrayOffset() + out.writerIndex();

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.handler.logging.ByteLoggingHandler;
 import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
 
 public class HexDumpProxyInitializer extends ChannelInitializer<SocketChannel> {
 
@@ -33,7 +33,7 @@ public HexDumpProxyInitializer(String remoteHost, int remotePort) {
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ch.pipeline().addLast(
-                new ByteLoggingHandler(LogLevel.INFO),
+                new LoggingHandler(LogLevel.INFO),
                 new HexDumpProxyFrontendHandler(remoteHost, remotePort));
     }
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpServerChannel;
-import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
@@ -26,6 +25,7 @@
 import io.netty.channel.oio.AbstractOioMessageChannel;
 import io.netty.channel.sctp.DefaultSctpServerChannelConfig;
 import io.netty.channel.sctp.SctpServerChannelConfig;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -299,7 +299,7 @@ protected void doDisconnect() throws Exception {
     protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
         int size = msgs.size();
         for (int i = index; i < size; i ++) {
-            ByteBufUtil.release(msgs.get(i));
+            ReferenceCountUtil.release(msgs.get(i));
         }
         throw new UnsupportedOperationException();
     }

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -64,7 +64,7 @@
  *     // your methods here
  * }
  *
- * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {
+ * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {
  *
  *     <b>private boolean loggedIn;</b>
  *
@@ -113,7 +113,7 @@
  * }
  *
  * {@code @Sharable}
- * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {
+ * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {
  *   private final {@link AttributeKey}&lt{@link Boolean}&gt auth =
  *           new {@link AttributeKey}&lt{@link Boolean}&gt("auth");
  *

File: transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java
Patch:
@@ -63,9 +63,8 @@ interface ChannelPropertyAccess {
      * Return a special ChannelPromise which can be reused for different operations.
      * <p>
      * It's only supported to use
-     * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)} ,
-     * {@link ChannelOutboundInvoker#flush(ChannelPromise)} and
-     * {@link ChannelOutboundInvoker#sendFile(FileRegion, ChannelPromise)}.
+     * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)} and,
+     * {@link ChannelOutboundInvoker#write(MessageList, ChannelPromise)}.
      * </p>
      * <p>
      * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used

File: transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java
Patch:
@@ -30,7 +30,7 @@ public interface RecvByteBufAllocator {
      */
     Handle newHandle();
 
-    public interface Handle {
+    interface Handle {
         /**
          * Creates a new receive buffer whose capacity is probably large enough to read all inbound data and small
          * enough not to waste its space.

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
Patch:
@@ -142,5 +142,7 @@ public void testInputBufferOverseek() throws Exception {
 
         channel.writeOutbound(in);
         assertTrue(channel.finish());
+        ByteBuf out = (ByteBuf) channel.readOutbound();
+        out.release();
     }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -263,8 +263,7 @@ public boolean isClosed() {
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx,
-            ByteBuf in, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
         if (finished.get()) {
             return;
         }
@@ -288,7 +287,6 @@ protected void encode(ChannelHandlerContext ctx,
 
                 // Configure output.
                 int maxOutputLength = (int) Math.ceil(inputLength * 1.001) + 12;
-                ByteBuf compressed = ctx.alloc().heapBuffer(maxOutputLength);
                 z.avail_out = maxOutputLength;
                 z.next_out = out.array();
                 z.next_out_index = out.arrayOffset() + out.writerIndex();

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
@@ -128,7 +127,7 @@ private static void testIdentity(ByteBuf in) {
             decoder.writeInbound(compressed.retain());
             assertFalse(compressed.isReadable());
             compressed.release();
-            CompositeByteBuf decompressed = Unpooled.compositeBuffer();
+            CompositeByteBuf decompressed = compositeBuffer();
             for (;;) {
                 Object o = decoder.readInbound();
                 if (o == null) {
@@ -138,6 +137,7 @@ private static void testIdentity(ByteBuf in) {
                 decompressed.writerIndex(decompressed.writerIndex() + ((ByteBuf) o).readableBytes());
             }
             assertEquals(in, decompressed);
+            decompressed.release();
         } finally {
             // Avoids memory leak through AbstractChannel.allChannels
             encoder.close();

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
Patch:
@@ -56,7 +56,9 @@ public void testMarshalling() throws IOException, ClassNotFoundException {
 
         unmarshaller.finish();
         unmarshaller.close();
+        buffer.release();
     }
+
     protected ByteBuf truncate(ByteBuf buf) {
         return buf;
     }

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -58,7 +58,7 @@ public final class PlatformDependent {
     private static final boolean HAS_UNSAFE = hasUnsafe0();
     private static final boolean CAN_USE_CHM_V8 = HAS_UNSAFE && JAVA_VERSION < 8;
     private static final boolean DIRECT_BUFFER_PREFERRED =
-            HAS_UNSAFE && SystemPropertyUtil.getBoolean("io.netty.preferDirect", false);
+            HAS_UNSAFE && !SystemPropertyUtil.getBoolean("io.netty.noPreferDirect", false);
 
     private static final long ARRAY_BASE_OFFSET = arrayBaseOffset0();
 

File: buffer/src/test/java/io/netty/buffer/UnpooledTest.java
Patch:
@@ -584,5 +584,6 @@ public void wrappedReadOnlyDirectBuffer() {
         for (int i = 0; i < 12; i++) {
             assertEquals((byte) i, wrapped.readByte());
         }
+        wrapped.release();
     }
 }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -100,14 +100,14 @@ public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
             }
             buf.clear();
         }
-        handlerRemoved0();
+        handlerRemoved0(ctx);
     }
 
     /**
      * Gets called after the {@link ByteToMessageDecoder} was removed from the actual context and it doesn't handle
      * events anymore.
      */
-    protected void  handlerRemoved0() throws Exception { }
+    protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception { }
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.ReferenceCountException;
 import io.netty.util.ResourceLeakDetector;
 
 import java.io.IOException;
@@ -1133,7 +1134,7 @@ protected final void checkReadableBytes(int minimumReadableBytes) {
      */
     protected final void ensureAccessible() {
         if (refCnt() == 0) {
-            throw new IllegalBufferAccessException();
+            throw new ReferenceCountException(0);
         }
     }
 }

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.ReferenceCounted;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;

File: buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.ReferenceCounted;
+
 /**
  * A packet which is send or receive.
  */

File: buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.buffer;
 
 import io.netty.util.CharsetUtil;
+import io.netty.util.ReferenceCounted;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;

File: buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.ReferenceCountException;
+
 /**
  * Default implementation of a {@link ByteBufHolder} that holds it's data in a {@link ByteBuf}.
  *
@@ -33,7 +35,7 @@ public DefaultByteBufHolder(ByteBuf data) {
     @Override
     public ByteBuf content() {
         if (data.refCnt() <= 0) {
-            throw new IllegalBufferAccessException();
+            throw new ReferenceCountException(data.refCnt());
         }
         return data;
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec.http.multipart;
 
-import io.netty.buffer.AbstractReferenceCounted;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelException;
 import io.netty.handler.codec.http.HttpConstants;
+import io.netty.util.AbstractReferenceCounted;
 
 import java.io.IOException;
 import java.nio.charset.Charset;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.IllegalBufferAccessException;
 import io.netty.buffer.Unpooled;
+import io.netty.util.ReferenceCountException;
 import io.netty.util.internal.StringUtil;
 
 /**
@@ -73,7 +73,7 @@ public SpdyDataFrame setLast(boolean last) {
     @Override
     public ByteBuf content() {
         if (data.refCnt() <= 0) {
-            throw new IllegalBufferAccessException();
+            throw new ReferenceCountException(data.refCnt());
         }
         return data;
     }

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -15,11 +15,11 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.ReferenceCounted;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.TypeParameterMatcher;
 
 /**

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBufUtil;
-import io.netty.buffer.ReferenceCounted;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.TypeParameterMatcher;
 
 /**

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
Patch:
@@ -16,11 +16,11 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBufUtil;
-import io.netty.buffer.ReferenceCounted;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.TypeParameterMatcher;
 
 /**

File: transport/src/main/java/io/netty/channel/AddressedEnvelope.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.netty.channel;
 
-import io.netty.buffer.ReferenceCounted;
+import io.netty.util.ReferenceCounted;
 
 import java.net.SocketAddress;
 

File: transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
Patch:
@@ -17,7 +17,7 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufUtil;
-import io.netty.buffer.ReferenceCounted;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.StringUtil;
 
 import java.net.SocketAddress;

File: transport/src/main/java/io/netty/channel/DefaultFileRegion.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.AbstractReferenceCounted;
+import io.netty.util.AbstractReferenceCounted;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 

File: transport/src/main/java/io/netty/channel/FileRegion.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ReferenceCounted;
+import io.netty.util.ReferenceCounted;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -18,12 +18,12 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.ReferenceCounted;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
+import io.netty.util.ReferenceCounted;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Test;

File: common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
Patch:
@@ -35,7 +35,7 @@ public final class JavassistTypeParameterMatcherGenerator {
     private static final ClassPool classPool = new ClassPool(true);
 
     static {
-        classPool.appendClassPath(new ClassClassPath(JavassistTypeParameterMatcherGenerator.class));
+        classPool.appendClassPath(new ClassClassPath(NoOpTypeParameterMatcher.class));
     }
 
     public void appendClassPath(ClassPath classpath) {

File: common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
Patch:
@@ -46,15 +46,15 @@ public void appendClassPath(String pathname) throws NotFoundException {
         classPool.appendClassPath(pathname);
     }
 
-    static TypeParameterMatcher generate(Class<?> type) {
+    public static TypeParameterMatcher generate(Class<?> type) {
         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
         if (classLoader == null) {
             classLoader = ClassLoader.getSystemClassLoader();
         }
         return generate(type, classLoader);
     }
 
-    static TypeParameterMatcher generate(Class<?> type, ClassLoader classLoader) {
+    public static TypeParameterMatcher generate(Class<?> type, ClassLoader classLoader) {
         final String typeName = typeName(type);
         final String className = "io.netty.util.internal.__matchers__." + typeName + "Matcher";
         try {

File: common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
Patch:
@@ -45,8 +45,8 @@ public Iterator<EventExecutor> iterator() {
     }
 
     @Override
-    public void shutdownGracefully() {
-        shutdownGracefully(2, 15, TimeUnit.SECONDS);
+    public Future<?> shutdownGracefully() {
+        return shutdownGracefully(2, 15, TimeUnit.SECONDS);
     }
 
     /**

File: common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
Patch:
@@ -65,8 +65,8 @@ public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialD
     }
 
     @Override
-    public void shutdownGracefully() {
-        shutdownGracefully(2, 15, TimeUnit.SECONDS);
+    public Future<?> shutdownGracefully() {
+        return shutdownGracefully(2, 15, TimeUnit.SECONDS);
     }
 
     /**

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -54,8 +54,8 @@ public static void createGroup() {
     }
 
     @AfterClass
-    public static void destroyGroup() {
-        group.shutdownGracefully();
+    public static void destroyGroup() throws Exception {
+        group.shutdownGracefully().sync();
     }
 
     @Test(timeout = 30000)

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -55,8 +55,8 @@ public static void createExecutor() {
     }
 
     @AfterClass
-    public static void shutdownExecutor() {
-        executor.shutdownGracefully();
+    public static void shutdownExecutor() throws Exception {
+        executor.shutdownGracefully().sync();
     }
 
     @Test(timeout = 30000)

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -45,8 +45,8 @@ public class DefaultChannelPipelineTest {
     private Channel peer;
 
     @AfterClass
-    public static void afterClass() {
-        group.shutdownGracefully();
+    public static void afterClass() throws Exception {
+        group.shutdownGracefully().sync();
     }
 
     private void setUp(final ChannelHandler... handlers) throws Exception {

File: transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
Patch:
@@ -29,7 +29,7 @@ public class DefaultChannnelGroupTest {
 
     // Test for #1183
     @Test
-    public void testNotThrowBlockingOperationException() {
+    public void testNotThrowBlockingOperationException() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup();
         EventLoopGroup workerGroup = new NioEventLoopGroup();
 
@@ -54,5 +54,7 @@ public void channelActive(ChannelHandlerContext ctx) {
 
         bossGroup.shutdownGracefully();
         workerGroup.shutdownGracefully();
+        bossGroup.terminationFuture().sync();
+        workerGroup.terminationFuture().sync();
     }
 }

File: transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
Patch:
@@ -88,6 +88,9 @@ public void run() {
             assertNull(String.format(
                     "Expected null, got channel '%s' for local address '%s'",
                     LocalChannelRegistry.get(addr), addr), LocalChannelRegistry.get(addr));
+
+            serverGroup.terminationFuture().sync();
+            clientGroup.terminationFuture().sync();
         }
     }
 

File: transport/src/test/java/io/netty/channel/nio/NioDatagramChannelTest.java
Patch:
@@ -36,7 +36,7 @@ public class NioDatagramChannelTest {
      * Test try to reproduce issue #1335
      */
     @Test
-    public void testBindMultiple() {
+    public void testBindMultiple() throws Exception {
         DefaultChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
         NioEventLoopGroup group = new NioEventLoopGroup();
         try {
@@ -57,8 +57,8 @@ public void messageReceived(
             }
             Assert.assertEquals(100, channelGroup.size());
         } finally {
-            channelGroup.close().syncUninterruptibly();
-            group.shutdownGracefully();
+            channelGroup.close().sync();
+            group.shutdownGracefully().sync();
         }
     }
 }

File: common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
Patch:
@@ -23,7 +23,7 @@
 public final class ImmediateEventExecutor extends AbstractEventExecutor {
     public static final ImmediateEventExecutor INSTANCE = new ImmediateEventExecutor();
 
-    private  ImmediateEventExecutor() {
+    private ImmediateEventExecutor() {
         // use static instance
     }
 

File: example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.ssl.SslHandler;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.GlobalEventExecutor;
 
 import java.net.InetAddress;
 import java.util.logging.Level;
@@ -37,7 +38,7 @@ public class SecureChatServerHandler extends ChannelInboundHandlerAdapter {
     private static final Logger logger = Logger.getLogger(
             SecureChatServerHandler.class.getName());
 
-    static final ChannelGroup channels = new DefaultChannelGroup();
+    static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
 
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -236,7 +236,7 @@ public boolean tryFailure(Throwable cause) {
     @Override
     protected void checkDeadLock() {
         EventExecutor e = executor();
-        if (e != null && !(e instanceof ImmediateEventExecutor) && e.inEventLoop()) {
+        if (e != null && e != ImmediateEventExecutor.INSTANCE && e.inEventLoop()) {
             throw new BlockingOperationException();
         }
     }

File: transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.util.concurrent.GlobalEventExecutor;
 import org.junit.Test;
 
 public class DefaultChannnelGroupTest {
@@ -32,7 +33,7 @@ public void testNotThrowBlockingOperationException() {
         EventLoopGroup bossGroup = new NioEventLoopGroup();
         EventLoopGroup workerGroup = new NioEventLoopGroup();
 
-        final ChannelGroup allChannels = new DefaultChannelGroup();
+        final ChannelGroup allChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
 
         ServerBootstrap b = new ServerBootstrap();
         b.group(bossGroup, workerGroup);

File: transport/src/test/java/io/netty/channel/nio/NioDatagramChannelTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.nio.NioDatagramChannel;
+import io.netty.util.concurrent.GlobalEventExecutor;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -36,7 +37,7 @@ public class NioDatagramChannelTest {
      */
     @Test
     public void testBindMultiple() {
-        DefaultChannelGroup channelGroup = new DefaultChannelGroup();
+        DefaultChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
         NioEventLoopGroup group = new NioEventLoopGroup();
         try {
             for (int i = 0; i < 100; i++) {

File: buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
Patch:
@@ -982,7 +982,7 @@ public int nioBufferCount() {
             int count = 0;
             for (int i = 0; i <  components.size(); i++) {
                 Component c = components.get(i);
-                count+=  c.buf.nioBufferCount();
+                count +=  c.buf.nioBufferCount();
             }
             return count;
         }

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -428,6 +428,8 @@ public boolean cancel(boolean mayInterruptIfRunning) {
                 notifyAll();
             }
         }
+
+        notifyListeners();
         return true;
     }
 

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -71,7 +71,7 @@ private void initMemoryAddress() {
 
     @Override
     protected ByteBuffer newInternalNioBuffer(ByteBuffer memory) {
-        return memory;
+        return memory.duplicate();
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -345,7 +345,7 @@ protected void destroyChunk(PoolChunk<byte[]> chunk) {
 
         @Override
         protected PooledByteBuf<byte[]> newByteBuf(int maxCapacity) {
-            return new PooledHeapByteBuf(maxCapacity);
+            return PooledHeapByteBuf.newInstance(maxCapacity);
         }
 
         @Override
@@ -385,9 +385,9 @@ protected void destroyChunk(PoolChunk<ByteBuffer> chunk) {
         @Override
         protected PooledByteBuf<ByteBuffer> newByteBuf(int maxCapacity) {
             if (HAS_UNSAFE) {
-                return new PooledUnsafeDirectByteBuf(maxCapacity);
+                return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);
             } else {
-                return new PooledDirectByteBuf(maxCapacity);
+                return PooledDirectByteBuf.newInstance(maxCapacity);
             }
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -516,7 +516,7 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, Messag
                         //    }
                         //});
 
-                        ctx.nextOutboundMessageBuffer().add(partialDataFrame);
+                        ctx.write(partialDataFrame);
                         return;
                     } else {
                         // Window size is large enough to send entire data frame

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.util.internal.StringUtil;
@@ -119,7 +119,7 @@ protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws
 
         return new Result(
                 targetContentEncoding,
-                new EmbeddedByteChannel(ZlibCodecFactory.newZlibEncoder(
+                new EmbeddedChannel(ZlibCodecFactory.newZlibEncoder(
                         wrapper, compressionLevel, windowBits, memLevel)));
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -40,7 +40,7 @@
  */
 public abstract class HttpObjectEncoder<H extends HttpMessage> extends MessageToByteEncoder<HttpObject> {
     private static final byte[] CRLF = { CR, LF };
-    private static final byte[] CRLF_END = { CR, LF, 0 };
+    private static final byte[] ZERO_CRLF = { '0', CR, LF };
     private static final byte[] HEADER_SEPARATOR = { COLON , SP };
     private static final int ST_INIT = 0;
     private static final int ST_CONTENT_NON_CHUNK = 1;
@@ -93,7 +93,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) th
                 }
 
                 if (chunk instanceof LastHttpContent) {
-                    out.writeBytes(CRLF_END);
+                    out.writeBytes(ZERO_CRLF);
                     encodeTrailingHeaders(out, (LastHttpContent) chunk);
                     out.writeBytes(CRLF);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.http.multipart;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.http.HttpConstants;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.multipart;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpContent;
@@ -943,7 +943,7 @@ public void close() throws Exception {
      *             if the encoding is in error
      */
     @Override
-    public boolean readChunk(MessageBuf<HttpContent> buffer) throws ErrorDataEncoderException {
+    public boolean readChunk(MessageList<HttpContent> buffer) throws ErrorDataEncoderException {
         if (isLastChunkSent) {
             return false;
         } else {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -50,7 +50,7 @@ public WebSocket00FrameDecoder(int maxFrameSize) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         // Discard all data received if closing handshake was received before.
         if (receivedClosingHandshake) {
             in.skipBytes(actualReadableBytes());

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -47,7 +47,7 @@ public WebSocketFrameAggregator(int maxFrameSize) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, MessageList<Object> out) throws Exception {
         if (currentFrame == null) {
             tooLongFrameFound = false;
             if (msg.isFinalFragment()) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -94,7 +94,7 @@ public SpdyFrameDecoder(int version, int maxChunkSize, int maxHeaderSize) {
     }
 
     @Override
-    public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         try {
             decode(ctx, in, out);
         } finally {
@@ -103,7 +103,7 @@ public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object>
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         switch(state) {
         case READ_COMMON_HEADER:
             state = readCommonHeader(buffer);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -91,7 +91,7 @@ protected FullHttpMessage removeMessage(int streamId) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, MessageBuf<Object> out)
+    protected void decode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, MessageList<Object> out)
             throws Exception {
         if (msg instanceof SpdySynStreamFrame) {
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageEncoder;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -139,7 +139,7 @@ public SpdyHttpEncoder(int version) {
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Object> out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
 
         boolean valid = false;
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.handler.codec.http.HttpHeaders.Names;
 import org.junit.Test;
@@ -63,7 +63,7 @@ public void testGetTargetContentEncoding() throws Exception {
 
     @Test
     public void testEmptyContentCompression() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new HttpContentCompressor());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpContentCompressor());
         FullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
         req.headers().set(Names.ACCEPT_ENCODING, "deflate");
         ch.writeInbound(req);

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
 
@@ -43,7 +43,7 @@ public SocksAuthRequestDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksSubnegotiationVersion.fromByte(byteBuf.readByte());

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 
 /**
@@ -40,7 +40,7 @@ public SocksAuthResponseDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, MessageBuf<Object> out)
+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, MessageList<Object> out)
             throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
 
@@ -46,7 +46,7 @@ public SocksCmdRequestDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
 
@@ -46,7 +46,7 @@ public SocksCmdResponseDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 
 import java.util.ArrayList;
@@ -44,7 +44,7 @@ public SocksInitRequestDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 
 /**
@@ -41,7 +41,7 @@ public SocksInitResponseDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -28,7 +28,7 @@ public void testAuthRequestDecoder() {
         String password = "test";
         SocksAuthRequest msg = new SocksAuthRequest(username, password);
         SocksAuthRequestDecoder decoder = new SocksAuthRequestDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         msg = (SocksAuthRequest) embedder.readInbound();
         assertEquals(msg.username(), username);

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -29,7 +29,7 @@ private static void testSocksAuthResponseDecoderWithDifferentParams(SocksAuthSta
         logger.debug("Testing SocksAuthResponseDecoder with authStatus: " + authStatus);
         SocksAuthResponse msg = new SocksAuthResponse(authStatus);
         SocksAuthResponseDecoder decoder = new SocksAuthResponseDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         msg = (SocksAuthResponse) embedder.readInbound();
         assertSame(msg.authStatus(), authStatus);

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -34,7 +34,7 @@ private static void testSocksCmdRequestDecoderWithDifferentParams(SocksCmdType c
                 " port: " + port);
         SocksCmdRequest msg = new SocksCmdRequest(cmdType, addressType, host, port);
         SocksCmdRequestDecoder decoder = new SocksCmdRequestDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         if (msg.addressType() == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksRequest);

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 
 final class SocksCommonTestUtils {
     /**
@@ -27,7 +27,7 @@ private SocksCommonTestUtils() {
         //NOOP
     }
 
-    public static void writeMessageIntoEmbedder(EmbeddedByteChannel embedder, SocksMessage msg) {
+    public static void writeMessageIntoEmbedder(EmbeddedChannel embedder, SocksMessage msg) {
         ByteBuf buf = Unpooled.buffer();
         msg.encodeAsByteBuf(buf);
         embedder.writeInbound(buf);

File: codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 
 /**
  * A decoder that splits the received {@link ByteBuf}s by one or more
@@ -211,7 +211,7 @@ private boolean isSubclass() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);

File: codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 
 import java.nio.ByteOrder;
@@ -348,7 +348,7 @@ public LengthFieldBasedFrameDecoder(
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);

File: codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 
 /**
  * A decoder that splits the received {@link ByteBuf}s on line endings.
@@ -69,7 +69,7 @@ public LineBasedFrameDecoder(final int maxLength, final boolean stripDelimiter,
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);

File: codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.handler.codec.base64;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -59,7 +59,7 @@ public Base64Decoder(Base64Dialect dialect) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         out.add(Base64.decode(msg, msg.readerIndex(), msg.readableBytes(), dialect));
     }
 }

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
 import io.netty.handler.codec.MessageToMessageDecoder;
@@ -48,9 +48,8 @@
  * </pre>
  */
 public class ByteArrayDecoder extends MessageToMessageDecoder<ByteBuf> {
-
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         byte[] array;
         if (msg.hasArray()) {
             if (msg.arrayOffset() == 0 && msg.readableBytes() == msg.capacity()) {

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
Patch:
@@ -16,12 +16,12 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.handler.codec.ByteToByteDecoder;
+import io.netty.handler.codec.ByteToMessageDecoder;
 
 /**
  * Decompresses a {@link ByteBuf} using the deflate algorithm.
  */
-public abstract class ZlibDecoder extends ByteToByteDecoder {
+public abstract class ZlibDecoder extends ByteToMessageDecoder {
 
     /**
      * Returns {@code true} if and only if the end of the compressed stream

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -18,12 +18,12 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.ByteToByteEncoder;
+import io.netty.handler.codec.MessageToByteEncoder;
 
 /**
  * Compresses a {@link ByteBuf} using the deflate algorithm.
  */
-public abstract class ZlibEncoder extends ByteToByteEncoder {
+public abstract class ZlibEncoder extends MessageToByteEncoder<ByteBuf> {
 
     /**
      * Returns {@code true} if and only if the end of the compressed stream

File: codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.marshalling;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import org.jboss.marshalling.ByteInput;
@@ -55,7 +55,7 @@ public CompatibleMarshallingDecoder(UnmarshallerProvider provider, int maxObject
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         if (discardingTooLongFrame) {
             buffer.skipBytes(actualReadableBytes());
             checkpoint();
@@ -83,7 +83,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
     }
 
     @Override
-    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         switch (buffer.readableBytes()) {
         case 0:
             return;

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
Patch:
@@ -19,10 +19,10 @@
 import com.google.protobuf.Message;
 import com.google.protobuf.MessageLite;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
@@ -95,7 +95,7 @@ public ProtobufDecoder(MessageLite prototype, ExtensionRegistry extensionRegistr
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         final byte[] array;
         final int offset;
         final int length = msg.readableBytes();

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
Patch:
@@ -17,8 +17,8 @@
 
 import com.google.protobuf.CodedInputStream;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
 
@@ -43,7 +43,7 @@ public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {
     //      (just like LengthFieldBasedFrameDecoder)
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         in.markReaderIndex();
         final byte[] buf = new byte[5];
         for (int i = 0; i < buf.length; i ++) {

File: codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.handler.codec.string;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.LineBasedFrameDecoder;
@@ -75,7 +75,7 @@ public StringDecoder(Charset charset) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         out.add(msg.toString(charset));
     }
 }

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.bytes;
 
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.EmptyArrays;
 import org.junit.Before;
 import org.junit.Test;
@@ -31,11 +31,11 @@
 @SuppressWarnings("ZeroLengthArrayAllocation")
 public class ByteArrayDecoderTest {
 
-    private EmbeddedMessageChannel ch;
+    private EmbeddedChannel ch;
 
     @Before
     public void setUp() {
-        ch = new EmbeddedMessageChannel(new ByteArrayDecoder());
+        ch = new EmbeddedChannel(new ByteArrayDecoder());
     }
 
     @Test

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.Marshalling;
 import org.jboss.marshalling.MarshallingConfiguration;
@@ -38,12 +38,12 @@ public void testMarshalling() throws IOException, ClassNotFoundException {
         final MarshallerFactory marshallerFactory = createMarshallerFactory();
         final MarshallingConfiguration configuration = createMarshallingConfig();
 
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(createEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(createEncoder());
 
         ch.writeOutbound(testObject);
         assertTrue(ch.finish());
 
-        ByteBuf buffer = ch.readOutbound();
+        ByteBuf buffer = (ByteBuf) ch.readOutbound();
 
         Unmarshaller unmarshaller = marshallerFactory.createUnmarshaller(configuration);
         unmarshaller.start(Marshalling.createByteInput(truncate(buffer).nioBuffer()));

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -40,7 +40,7 @@ protected ChannelHandler createDecoder(int maxObjectSize) {
     }
 
     @Override
-    protected void onTooBigFrame(EmbeddedByteChannel ch, ByteBuf input) {
+    protected void onTooBigFrame(EmbeddedChannel ch, ByteBuf input) {
         try {
             ch.writeInbound(input);
             fail();

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -40,7 +40,7 @@ protected ChannelHandler createDecoder(int maxObjectSize) {
     }
 
     @Override
-    protected void onTooBigFrame(EmbeddedByteChannel ch, ByteBuf input) {
+    protected void onTooBigFrame(EmbeddedChannel ch, ByteBuf input) {
         try {
             ch.writeInbound(input);
             fail();

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -28,12 +28,12 @@
 
 public final class ResourceLeakDetector<T> {
 
-    private static final boolean ENABLED = SystemPropertyUtil.getBoolean("io.netty.resourceLeakDetection", false);
+    private static final boolean DISABLED = SystemPropertyUtil.getBoolean("io.netty.noResourceLeakDetection", false);
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ResourceLeakDetector.class);
 
     static {
-        logger.debug("io.netty.resourceLeakDetection: {}", ENABLED);
+        logger.debug("io.netty.noResourceLeakDetection: {}", DISABLED);
     }
 
     private static final int DEFAULT_SAMPLING_INTERVAL = 113;
@@ -92,7 +92,7 @@ public ResourceLeakDetector(String resourceType, int samplingInterval, long maxA
     }
 
     public ResourceLeak open(T obj) {
-        if (!ENABLED || leakCheckCnt ++ % samplingInterval != 0) {
+        if (DISABLED || leakCheckCnt ++ % samplingInterval != 0) {
             return NOOP;
         }
 

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -23,8 +23,6 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
 
 /**
  * Sends one message when a connection is open and echoes back any received
@@ -56,7 +54,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new EchoClientHandler(firstMessageSize));
                  }
              });

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -51,7 +51,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new EchoServerHandler());
                  }
              });

File: example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.example.factorial;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
 
@@ -32,7 +32,7 @@
 public class BigIntegerDecoder extends ByteToMessageDecoder {
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) {
         // Wait until the length prefix is available.
         if (in.readableBytes() < 5) {
             return;

File: example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
Patch:
@@ -16,10 +16,10 @@
 package io.netty.example.http.websocketx.html5;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 
-public class CustomTextFrameHandler extends ChannelInboundMessageHandlerAdapter<TextWebSocketFrame> {
+public class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame frame) throws Exception {

File: example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
Patch:
@@ -21,15 +21,15 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.socks.SocksCmdRequest;
 import io.netty.handler.codec.socks.SocksCmdResponse;
 import io.netty.handler.codec.socks.SocksCmdStatus;
 
 @ChannelHandler.Sharable
-public final class SocksServerConnectHandler extends ChannelInboundMessageHandlerAdapter<SocksCmdRequest> {
+public final class SocksServerConnectHandler extends SimpleChannelInboundHandler<SocksCmdRequest> {
     private static final String name = "SOCKS_SERVER_CONNECT_HANDLER";
 
     public static String getName() {

File: example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.socksproxy;
 
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFutureListener;
 
@@ -29,7 +30,7 @@ private SocksServerUtils() {
      */
     public static void closeOnFlush(Channel ch) {
         if (ch.isActive()) {
-            ch.flush().addListener(ChannelFutureListener.CLOSE);
+            ch.write(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
     }
 }

File: handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java
Patch:
@@ -15,14 +15,14 @@
  */
 package io.netty.handler.stream;
 
-import io.netty.buffer.MessageBuf;
+import io.netty.channel.MessageList;
 
 import java.util.Queue;
 
 /**
  * {@link ChunkedInput} which reads its chunks and transfer it to a {@link Queue}
  *
  */
-public interface ChunkedMessageInput<T> extends ChunkedInput<MessageBuf<T>> {
+public interface ChunkedMessageInput<T> extends ChunkedInput<MessageList<T>> {
 
 }

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -18,6 +18,7 @@
 import gnu.io.SerialPort;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 
 /**
  * A configuration class for RXTX device connections.
@@ -268,8 +269,8 @@ public static Paritybit valueOf(int value) {
     RxtxChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    RxtxChannelConfig setAutoRead(boolean autoRead);
+    RxtxChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    RxtxChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    RxtxChannelConfig setAutoRead(boolean autoRead);
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.channel.sctp;
 
 import com.sun.nio.sctp.MessageInfo;
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.DefaultByteBufHolder;
 
 /**
@@ -156,6 +156,6 @@ public String toString() {
         }
         return "SctpFrame{" +
                 "streamIdentifier=" + streamIdentifier + ", protocolIdentifier=" + protocolIdentifier +
-                ", data=" + BufUtil.hexDump(content()) + '}';
+                ", data=" + ByteBufUtil.hexDump(content()) + '}';
     }
 }

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java
Patch:
@@ -17,8 +17,8 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.ServerSocketChannelUDT;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.udt.DefaultUdtServerChannelConfig;
 import io.netty.channel.udt.UdtServerChannel;
@@ -95,8 +95,7 @@ protected void doFinishConnect() throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(final MessageBuf<Object> buf,
-            final boolean lastSpin) throws Exception {
+    protected int doWriteMessages(MessageList<Object> msg, int index, boolean lastSpin) throws Exception {
         throw new UnsupportedOperationException();
     }
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtByteAcceptorChannel;
 import org.junit.Test;
 
@@ -29,6 +28,6 @@ public class NioUdtByteAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.BYTE, new NioUdtByteAcceptorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtByteAcceptorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
Patch:
@@ -16,11 +16,10 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtByteConnectorChannel;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
 
@@ -29,6 +28,6 @@ public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.BYTE, new NioUdtByteConnectorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtByteConnectorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java
Patch:
@@ -19,7 +19,6 @@
 import com.yammer.metrics.Metrics;
 import com.yammer.metrics.core.Meter;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.nio.NioUdtByteRendezvousChannel;
@@ -45,7 +44,7 @@ public class NioUdtByteRendezvousChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.BYTE, new NioUdtByteRendezvousChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtByteRendezvousChannel().metadata().hasDisconnect());
     }
 
     /**

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtMessageAcceptorChannel;
 import org.junit.Test;
 
@@ -29,6 +28,6 @@ public class NioUdtMessageAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.MESSAGE, new NioUdtMessageAcceptorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtMessageAcceptorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtMessageConnectorChannel;
 import org.junit.Test;
 
@@ -29,6 +28,6 @@ public class NioUdtMessageConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.MESSAGE, new NioUdtMessageConnectorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtMessageConnectorChannel().metadata().hasDisconnect());
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java
Patch:
@@ -19,7 +19,6 @@
 import com.yammer.metrics.Metrics;
 import com.yammer.metrics.core.Meter;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.nio.NioUdtMessageRendezvousChannel;
@@ -45,7 +44,7 @@ public class NioUdtMessageRendezvousChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.MESSAGE, new NioUdtMessageRendezvousChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtMessageRendezvousChannel().metadata().hasDisconnect());
     }
 
     /**

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -267,7 +267,7 @@ public void setHandshakeTimeoutMillis(long handshakeTimeoutMillis) {
     }
 
     public long getCloseNotifyTimeoutMillis() {
-        return handshakeTimeoutMillis;
+        return closeNotifyTimeoutMillis;
     }
 
     public void setCloseNotifyTimeout(long closeNotifyTimeout, TimeUnit unit) {

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -153,7 +153,6 @@
  * <li>Protocol Decoder - translates binary data (e.g. {@link ByteBuf})
  *                        into a Java object.</li>
  * <li>Protocol Encoder - translates a Java object into binary data.</li>
- * <li><tt>ExecutionHandler</tt> - applies a thread model.</li>
  * <li>Business Logic Handler - performs the actual business logic
  *                              (e.g. database access).</li>
  * </ol>
@@ -164,14 +163,13 @@
  * {@link ChannelPipeline} pipeline = ...;
  * pipeline.addLast("decoder", new MyProtocolDecoder());
  * pipeline.addLast("encoder", new MyProtocolEncoder());
- * pipeline.addLast("executor", new ExecutionHandler(...));
  * pipeline.addLast("handler", new MyBusinessLogicHandler());
  * </pre>
  *
  * <h3>Thread safety</h3>
  * <p>
  * A {@link ChannelHandler} can be added or removed at any time because a
- * {@link ChannelPipeline} is thread safe.  For example, you can insert an
+ * {@link ChannelPipeline} is thread safe. For example, you can insert an
  * encryption handler when sensitive information is about to be exchanged,
  * and remove it after the exchange.
  */

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -58,7 +58,7 @@ public abstract class WebSocketServerHandshaker {
     /**
      * Use this as wildcard to support all requested sub-protocols
      */
-    public final static String SUB_PROTOCOL_WILDCARD = "*";
+    public static final String SUB_PROTOCOL_WILDCARD = "*";
 
     /**
      * Constructor specifying the destination web socket location

File: common/src/main/java/io/netty/util/concurrent/ImmediateExecutor.java
Patch:
@@ -29,6 +29,9 @@ private  ImmediateExecutor() {
 
     @Override
     public void execute(Runnable command) {
+        if (command == null) {
+            throw new NullPointerException("command");
+        }
         command.run();
     }
 }

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.FileRegion;
 import io.netty.channel.ServerChannel;
 import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.internal.PlatformDependent;
 
 import java.util.AbstractSet;
@@ -39,7 +40,6 @@
 public class DefaultChannelGroup extends AbstractSet<Channel> implements ChannelGroup {
 
     private static final AtomicInteger nextId = new AtomicInteger();
-    private static final ImmediateEventExecutor DEFAULT_EXECUTOR = new ImmediateEventExecutor();
     private final String name;
     private final EventExecutor executor;
     private final ConcurrentMap<Integer, Channel> serverChannels = PlatformDependent.newConcurrentHashMap();
@@ -72,7 +72,7 @@ public DefaultChannelGroup(EventExecutor executor) {
      * is done against group names.
      */
     public DefaultChannelGroup(String name) {
-        this(name, DEFAULT_EXECUTOR);
+        this(name, ImmediateEventExecutor.INSTANCE);
     }
 
     /**

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
Patch:
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.channel.group;
+package io.netty.util.concurrent;
 
 import io.netty.util.concurrent.AbstractEventExecutor;
 import io.netty.util.concurrent.DefaultPromise;

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
Patch:
@@ -166,7 +166,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                         } finally {
                             in.writerIndex(oldWriterIndex);
                         }
-                        int uncompressedLength = in.writerIndex() - uncompressedStart;
+                        int uncompressedLength = out.writerIndex() - uncompressedStart;
                         validateChecksum(checksum, out, uncompressedStart, uncompressedLength);
                     } else {
                         snappy.decode(in.readSlice(chunkLength - 4), out);

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -782,7 +782,7 @@ public ChannelPipeline fireChannelUnregistered() {
 
         // Free all buffers if channel is closed and unregistered.
         if (!channel.isOpen()) {
-            head.invokeFreeInboundBuffer();
+            head.freeInbound();
         }
         return this;
     }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -24,13 +24,11 @@
 import io.netty.handler.codec.http.Cookie;
 import io.netty.handler.codec.http.CookieDecoder;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http.QueryStringDecoder;
 import io.netty.handler.codec.http.ServerCookieEncoder;
@@ -181,7 +179,7 @@ private void writeResponse(ChannelHandlerContext ctx, HttpObject currentObj) {
     }
 
     private static void send100Continue(ChannelHandlerContext ctx) {
-        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);
+        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, CONTINUE);
         ctx.nextOutboundMessageBuffer().add(response);
     }
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.http.upload;
 
+import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
@@ -297,6 +298,7 @@ private void writeHttpData(InterfaceHttpData data) {
                 }
             }
         }
+        //BufUtil.release(data);
     }
 
     private void writeResponse(Channel channel) {

File: example/src/main/java/io/netty/example/filetransfer/FileServer.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.example.filetransfer;
 
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -66,7 +65,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new StringEncoder(BufType.BYTE, CharsetUtil.UTF_8),
+                             new StringEncoder(CharsetUtil.UTF_8),
                              new LineBasedFrameDecoder(8192),
                              new StringDecoder(CharsetUtil.UTF_8),
                              new FileHandler());

File: example/src/main/java/io/netty/example/rxtx/RxtxClient.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.example.rxtx;
 
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.EventLoopGroup;
@@ -43,7 +42,7 @@ public static void main(String[] args) throws Exception {
                  public void initChannel(RxtxChannel ch) throws Exception {
                      ch.pipeline().addLast(
                          new LineBasedFrameDecoder(32768),
-                         new StringEncoder(BufType.BYTE),
+                         new StringEncoder(),
                          new StringDecoder(),
                          new RxtxClientHandler()
                      );

File: example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.example.securechat;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -52,7 +51,7 @@ public void initChannel(SocketChannel ch) throws Exception {
         pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
                 8192, Delimiters.lineDelimiter()));
         pipeline.addLast("decoder", new StringDecoder());
-        pipeline.addLast("encoder", new StringEncoder(BufType.BYTE));
+        pipeline.addLast("encoder", new StringEncoder());
 
         // and then business logic.
         pipeline.addLast("handler", new SecureChatClientHandler());

File: example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.example.securechat;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -55,7 +54,7 @@ public void initChannel(SocketChannel ch) throws Exception {
         pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
                 8192, Delimiters.lineDelimiter()));
         pipeline.addLast("decoder", new StringDecoder());
-        pipeline.addLast("encoder", new StringEncoder(BufType.BYTE));
+        pipeline.addLast("encoder", new StringEncoder());
 
         // and then business logic.
         pipeline.addLast("handler", new SecureChatServerHandler());

File: example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.example.telnet;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -29,7 +28,7 @@
  */
 public class TelnetClientInitializer extends ChannelInitializer<SocketChannel> {
     private static final StringDecoder DECODER = new StringDecoder();
-    private static final StringEncoder ENCODER = new StringEncoder(BufType.BYTE);
+    private static final StringEncoder ENCODER = new StringEncoder();
     private static final TelnetClientHandler CLIENTHANDLER = new TelnetClientHandler();
     @Override
     public void initChannel(SocketChannel ch) throws Exception {

File: example/src/main/java/io/netty/example/telnet/TelnetServerPipelineFactory.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.example.telnet;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -29,7 +28,7 @@
  */
 public class TelnetServerPipelineFactory extends ChannelInitializer<SocketChannel> {
     private static final StringDecoder DECODER = new StringDecoder();
-    private static final StringEncoder ENCODER = new StringEncoder(BufType.BYTE);
+    private static final StringEncoder ENCODER = new StringEncoder();
     private static final TelnetServerHandler SERVERHANDLER = new TelnetServerHandler();
 
     @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -77,7 +76,7 @@ public void testStartTls(ServerBootstrap sb, Bootstrap cb) throws Throwable {
             public void initChannel(SocketChannel sch) throws Exception {
                 ChannelPipeline p = sch.pipeline();
                 p.addLast("logger", new ByteLoggingHandler(LOG_LEVEL));
-                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder(BufType.BYTE));
+                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder());
                 p.addLast(executor, sh);
             }
         });
@@ -87,7 +86,7 @@ public void initChannel(SocketChannel sch) throws Exception {
             public void initChannel(SocketChannel sch) throws Exception {
                 ChannelPipeline p = sch.pipeline();
                 p.addLast("logger", new ByteLoggingHandler(LOG_LEVEL));
-                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder(BufType.BYTE));
+                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder());
                 p.addLast(executor, ch);
             }
         });

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
Patch:
@@ -67,7 +67,7 @@ public void testStringEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
             public void initChannel(SocketChannel sch) throws Exception {
                 sch.pipeline().addLast("framer", new DelimiterBasedFrameDecoder(512, Delimiters.lineDelimiter()));
                 sch.pipeline().addLast("decoder", new StringDecoder(CharsetUtil.ISO_8859_1));
-                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(BufType.BYTE, CharsetUtil.ISO_8859_1));
+                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(CharsetUtil.ISO_8859_1));
                 sch.pipeline().addAfter("decoder", "handler", sh);
             }
         });
@@ -77,7 +77,7 @@ public void initChannel(SocketChannel sch) throws Exception {
             public void initChannel(SocketChannel sch) throws Exception {
                 sch.pipeline().addLast("framer", new DelimiterBasedFrameDecoder(512, Delimiters.lineDelimiter()));
                 sch.pipeline().addLast("decoder", new StringDecoder(CharsetUtil.ISO_8859_1));
-                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(BufType.BYTE, CharsetUtil.ISO_8859_1));
+                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(CharsetUtil.ISO_8859_1));
                 sch.pipeline().addAfter("decoder", "handler", ch);
             }
         });

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -486,7 +486,9 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
             Charset localcharset = attribute.getCharset();
             if (localcharset != null) {
                 // Content-Type: charset=charset
-                internal.addValue(HttpHeaders.Names.CONTENT_TYPE + ": " + HttpHeaders.Values.CHARSET + '='
+                internal.addValue(HttpHeaders.Names.CONTENT_TYPE + ": " +
+                        HttpPostBodyUtil.DEFAULT_TEXT_CONTENT_TYPE + "; " +
+                        HttpHeaders.Values.CHARSET + '='
                         + localcharset + "\r\n");
             }
             // CRLF between body header and data

File: buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
Patch:
@@ -22,9 +22,8 @@ public interface ByteBufHolder extends ReferenceCounted {
 
     /**
      * Return the data which is held by this {@link ByteBufHolder}.
-     *
      */
-    ByteBuf data();
+    ByteBuf content();
 
     /**
      * Create a deep copy of this {@link ByteBufHolder}.

File: buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
Patch:
@@ -31,7 +31,7 @@ public DefaultByteBufHolder(ByteBuf data) {
     }
 
     @Override
-    public ByteBuf data() {
+    public ByteBuf content() {
         if (data.refCnt() <= 0) {
             throw new IllegalBufferAccessException();
         }
@@ -72,6 +72,6 @@ public boolean release(int decrement) {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + '(' + data().toString() + ')';
+        return getClass().getSimpleName() + '(' + content().toString() + ')';
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
Patch:
@@ -43,7 +43,7 @@ public HttpHeaders trailingHeaders() {
     }
 
     @Override
-    public ByteBuf data() {
+    public ByteBuf content() {
         return content;
     }
 
@@ -95,7 +95,7 @@ public FullHttpRequest setUri(String uri) {
     @Override
     public FullHttpRequest copy() {
         DefaultFullHttpRequest copy = new DefaultFullHttpRequest(
-                getProtocolVersion(), getMethod(), getUri(), data().copy());
+                getProtocolVersion(), getMethod(), getUri(), content().copy());
         copy.headers().set(headers());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
Patch:
@@ -45,7 +45,7 @@ public HttpHeaders trailingHeaders() {
     }
 
     @Override
-    public ByteBuf data() {
+    public ByteBuf content() {
         return content;
     }
 
@@ -90,7 +90,7 @@ public FullHttpResponse setStatus(HttpResponseStatus status) {
 
     @Override
     public FullHttpResponse copy() {
-        DefaultFullHttpResponse copy = new DefaultFullHttpResponse(getProtocolVersion(), getStatus(), data().copy());
+        DefaultFullHttpResponse copy = new DefaultFullHttpResponse(getProtocolVersion(), getStatus(), content().copy());
         copy.headers().set(headers());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
Patch:
@@ -35,7 +35,7 @@ public DefaultHttpContent(ByteBuf content) {
     }
 
     @Override
-    public ByteBuf data() {
+    public ByteBuf content() {
         return content;
     }
 
@@ -73,6 +73,6 @@ public boolean release(int decrement) {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + "(data: " + data() + ", getDecoderResult: " + getDecoderResult() + ')';
+        return getClass().getSimpleName() + "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
Patch:
@@ -49,7 +49,7 @@ public DefaultLastHttpContent(ByteBuf content) {
 
     @Override
     public LastHttpContent copy() {
-        DefaultLastHttpContent copy = new DefaultLastHttpContent(data().copy());
+        DefaultLastHttpContent copy = new DefaultLastHttpContent(content().copy());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -110,7 +110,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
 
                 if (isFull) {
                     // Pass through the full response with empty content and continue waiting for the the next resp.
-                    if (!((ByteBufHolder) res).data().isReadable()) {
+                    if (!((ByteBufHolder) res).content().isReadable()) {
                         // Set the content length to 0.
                         res.headers().remove(Names.TRANSFER_ENCODING);
                         res.headers().set(Names.CONTENT_LENGTH, "0");
@@ -127,7 +127,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
                     if (isFull) {
                         // As an unchunked response
                         res.headers().remove(Names.TRANSFER_ENCODING);
-                        res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).data().readableBytes());
+                        res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).content().readableBytes());
                         out.add(BufUtil.retain(res));
                     } else {
                         // As a chunked response
@@ -201,7 +201,7 @@ private static void ensureContent(HttpObject msg) {
 
     private HttpContent[] encodeContent(HttpContent c) {
         ByteBuf newContent = Unpooled.buffer();
-        ByteBuf content = c.data();
+        ByteBuf content = c.content();
 
         encode(content, newContent);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -809,7 +809,7 @@ public static void addDateHeader(HttpMessage message, String name, Date value) {
 
     /**
      * Returns the length of the content.  Please note that this value is
-     * not retrieved from {@link HttpContent#data()} but from the
+     * not retrieved from {@link HttpContent#content()} but from the
      * {@code "Content-Length"} header, and thus they are independent from each
      * other.
      *
@@ -838,7 +838,7 @@ public static long getContentLength(HttpMessage message) {
 
     /**
      * Returns the length of the content.  Please note that this value is
-     * not retrieved from {@link HttpContent#data()} but from the
+     * not retrieved from {@link HttpContent#content()} but from the
      * {@code "Content-Length"} header, and thus they are independent from each
      * other.
      *

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
Patch:
@@ -72,7 +72,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) th
             }
 
             HttpContent chunk = (HttpContent) msg;
-            ByteBuf content = chunk.data();
+            ByteBuf content = chunk.content();
             int contentLength = content.readableBytes();
 
             if (state == ST_CONTENT_NON_CHUNK) {

File: codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
Patch:
@@ -30,7 +30,7 @@ public interface LastHttpContent extends HttpContent {
     LastHttpContent EMPTY_LAST_CONTENT = new LastHttpContent() {
 
         @Override
-        public ByteBuf data() {
+        public ByteBuf content() {
             return Unpooled.EMPTY_BUFFER;
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
Patch:
@@ -86,7 +86,7 @@ public long length() {
     }
 
     @Override
-    public ByteBuf data() {
+    public ByteBuf content() {
         try {
             return getByteBuf();
         } catch (IOException e) {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
Patch:
@@ -144,7 +144,7 @@ protected String getPrefix() {
     public Attribute copy() {
         DiskAttribute attr = new DiskAttribute(getName());
         attr.setCharset(getCharset());
-        ByteBuf content = data();
+        ByteBuf content = content();
         if (content != null) {
             try {
                 attr.setContent(content.copy());

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
Patch:
@@ -167,7 +167,7 @@ protected String getPrefix() {
     public FileUpload copy() {
         DiskFileUpload upload = new DiskFileUpload(getName(),
                 getFilename(), getContentType(), getContentTransferEncoding(), getCharset(), size);
-        ByteBuf buf = data();
+        ByteBuf buf = content();
         if (buf != null) {
             try {
                 upload.setContent(buf.copy());

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
Patch:
@@ -348,7 +348,7 @@ public InterfaceHttpData getBodyHttpData(String name) throws NotEnoughDataDecode
      *             errors
      */
     public void offer(HttpContent content) throws ErrorDataDecoderException {
-        ByteBuf chunked = content.data();
+        ByteBuf chunked = content.content();
         if (undecodedChunk == null) {
             undecodedChunk = chunked;
         } else {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -699,11 +699,11 @@ public FullHttpRequest finalizeRequest() throws ErrorDataEncoderException {
                 }
             }
             HttpHeaders.setTransferEncodingChunked(request);
-            request.data().clear();
+            request.content().clear();
         } else {
             // get the only one body and set it to the request
             HttpContent chunk = nextChunk();
-            request.data().clear().writeBytes(chunk.data());
+            request.content().clear().writeBytes(chunk.content());
         }
         return request;
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
Patch:
@@ -105,7 +105,7 @@ public String toString() {
     public Attribute copy() {
         MemoryAttribute attr = new MemoryAttribute(getName());
         attr.setCharset(getCharset());
-        ByteBuf content = data();
+        ByteBuf content = content();
         if (content != null) {
             try {
                 attr.setContent(content.copy());

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
Patch:
@@ -133,7 +133,7 @@ public String toString() {
     public FileUpload copy() {
         MemoryFileUpload upload = new MemoryFileUpload(getName(), getFilename(), getContentType(),
                 getContentTransferEncoding(), getCharset(), size);
-        ByteBuf buf = data();
+        ByteBuf buf = content();
         if (buf != null) {
             try {
                 upload.setContent(buf.copy());

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
Patch:
@@ -205,8 +205,8 @@ public Attribute copy() {
     }
 
     @Override
-    public ByteBuf data() {
-        return attribute.data();
+    public ByteBuf content() {
+        return attribute.content();
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
Patch:
@@ -231,8 +231,8 @@ public FileUpload copy() {
     }
 
     @Override
-    public ByteBuf data() {
-        return fileUpload.data();
+    public ByteBuf content() {
+        return fileUpload.content();
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
Patch:
@@ -56,7 +56,7 @@ public BinaryWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData)
 
     @Override
     public BinaryWebSocketFrame copy() {
-        return new BinaryWebSocketFrame(isFinalFragment(), rsv(), data().copy());
+        return new BinaryWebSocketFrame(isFinalFragment(), rsv(), content().copy());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
Patch:
@@ -109,7 +109,7 @@ public CloseWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
      * a getStatus code is set, -1 is returned.
      */
     public int statusCode() {
-        ByteBuf binaryData = data();
+        ByteBuf binaryData = content();
         if (binaryData == null || binaryData.capacity() == 0) {
             return -1;
         }
@@ -126,7 +126,7 @@ public int statusCode() {
      * text is not supplied, an empty string is returned.
      */
     public String reasonText() {
-        ByteBuf binaryData = data();
+        ByteBuf binaryData = content();
         if (binaryData == null || binaryData.capacity() <= 2) {
             return "";
         }
@@ -140,7 +140,7 @@ public String reasonText() {
 
     @Override
     public CloseWebSocketFrame copy() {
-        return new CloseWebSocketFrame(isFinalFragment(), rsv(), data().copy());
+        return new CloseWebSocketFrame(isFinalFragment(), rsv(), content().copy());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
Patch:
@@ -95,7 +95,7 @@ public ContinuationWebSocketFrame(boolean finalFragment, int rsv, String text) {
      * Returns the text data in this frame
      */
     public String text() {
-        return data().toString(CharsetUtil.UTF_8);
+        return content().toString(CharsetUtil.UTF_8);
     }
 
     /**
@@ -121,7 +121,7 @@ public String aggregatedText() {
 
     @Override
     public ContinuationWebSocketFrame copy() {
-        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), data().copy(), aggregatedText());
+        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy(), aggregatedText());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
Patch:
@@ -56,7 +56,7 @@ public PingWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
 
     @Override
     public PingWebSocketFrame copy() {
-        return new PingWebSocketFrame(isFinalFragment(), rsv(), data().copy());
+        return new PingWebSocketFrame(isFinalFragment(), rsv(), content().copy());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
Patch:
@@ -56,7 +56,7 @@ public PongWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
 
     @Override
     public PongWebSocketFrame copy() {
-        return new PongWebSocketFrame(isFinalFragment(), rsv(), data().copy());
+        return new PongWebSocketFrame(isFinalFragment(), rsv(), content().copy());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
Patch:
@@ -91,12 +91,12 @@ public TextWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
      * Returns the text data in this frame
      */
     public String text() {
-        return data().toString(CharsetUtil.UTF_8);
+        return content().toString(CharsetUtil.UTF_8);
     }
 
     @Override
     public TextWebSocketFrame copy() {
-        return new TextWebSocketFrame(isFinalFragment(), rsv(), data().copy());
+        return new TextWebSocketFrame(isFinalFragment(), rsv(), content().copy());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java
Patch:
@@ -33,7 +33,7 @@ public class WebSocket00FrameEncoder extends MessageToByteEncoder<WebSocketFrame
     protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, ByteBuf out) throws Exception {
         if (msg instanceof TextWebSocketFrame) {
             // Text frame
-            ByteBuf data = msg.data();
+            ByteBuf data = msg.content();
             out.writeByte((byte) 0x00);
             out.writeBytes(data, data.readerIndex(), data.readableBytes());
             out.writeByte((byte) 0xFF);
@@ -43,7 +43,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, ByteBuf out
             out.writeByte((byte) 0x00);
         } else {
             // Binary frame
-            ByteBuf data = msg.data();
+            ByteBuf data = msg.content();
             int dataLen = data.readableBytes();
             out.ensureWritable(dataLen + 5);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -98,7 +98,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, ByteBuf out
 
         byte[] mask;
 
-        ByteBuf data = msg.data();
+        ByteBuf data = msg.content();
         if (data == null) {
             data = Unpooled.EMPTY_BUFFER;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -165,7 +165,7 @@ protected FullHttpRequest newHandshakeRequest() {
         // Set Content-Length to workaround some known defect.
         // See also: http://www.ietf.org/mail-archive/web/hybi/current/msg02149.html
         headers.set(Names.CONTENT_LENGTH, key3.length);
-        request.data().writeBytes(key3);
+        request.content().writeBytes(key3);
         return request;
     }
 
@@ -211,7 +211,7 @@ protected void verify(FullHttpResponse response) {
                     + connection);
         }
 
-        ByteBuf challenge = response.data();
+        ByteBuf challenge = response.content();
         if (!challenge.equals(expectedChallengeResponseBytes)) {
             throw new WebSocketHandshakeException("Invalid challenge");
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
Patch:
@@ -64,7 +64,7 @@ public int rsv() {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + "(data: " + data().toString() + ')';
+        return getClass().getSimpleName() + "(data: " + content().toString() + ')';
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java
Patch:
@@ -24,8 +24,8 @@ abstract class WebSocketProtocolHandler  extends ChannelInboundMessageHandlerAda
     @Override
     public void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
         if (frame instanceof PingWebSocketFrame) {
-            frame.data().retain();
-            ctx.channel().write(new PongWebSocketFrame(frame.data()));
+            frame.content().retain();
+            ctx.channel().write(new PongWebSocketFrame(frame.content()));
             return;
         }
         if (frame instanceof PongWebSocketFrame) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -152,12 +152,12 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
                            BEGINNING_SPACE.matcher(key1).replaceAll("").length());
             int b = (int) (Long.parseLong(BEGINNING_DIGIT.matcher(key2).replaceAll("")) /
                            BEGINNING_SPACE.matcher(key2).replaceAll("").length());
-            long c = req.data().readLong();
+            long c = req.content().readLong();
             ByteBuf input = Unpooled.buffer(16);
             input.writeInt(a);
             input.writeInt(b);
             input.writeLong(c);
-            res.data().writeBytes(WebSocketUtil.md5(input.array()));
+            res.content().writeBytes(WebSocketUtil.md5(input.array()));
         } else {
             // Old Hixie 75 handshake getMethod with no challenge:
             res.headers().add(WEBSOCKET_ORIGIN, req.headers().get(ORIGIN));

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
Patch:
@@ -84,7 +84,7 @@ public SpdyDataFrame setLast(boolean last) {
 
     @Override
     public DefaultSpdyDataFrame copy() {
-        DefaultSpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), data().copy());
+        DefaultSpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().copy());
         frame.setLast(isLast());
         return frame;
     }
@@ -116,7 +116,7 @@ public String toString() {
         if (refCnt() == 0) {
             buf.append("(freed)");
         } else {
-            buf.append(data().readableBytes());
+            buf.append(content().readableBytes());
         }
         return buf.toString();
     }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
Patch:
@@ -37,7 +37,7 @@ public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame, SpdyDataO
      * The data payload cannot exceed 16777215 bytes.
      */
     @Override
-    ByteBuf data();
+    ByteBuf content();
 
     @Override
     SpdyDataFrame copy();

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -80,7 +80,7 @@ protected void encode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, Byt
         if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            ByteBuf data = spdyDataFrame.data();
+            ByteBuf data = spdyDataFrame.content();
             byte flags = spdyDataFrame.isLast() ? SPDY_DATA_FLAG_FIN : 0;
             out.ensureWritable(SPDY_HEADER_SIZE + data.readableBytes());
             out.writeInt(spdyDataFrame.getStreamId() & 0x7FFFFFFF);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -201,14 +201,14 @@ protected void decode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, Mes
                 return;
             }
 
-            ByteBuf content = fullHttpMessage.data();
-            if (content.readableBytes() > maxContentLength - spdyDataFrame.data().readableBytes()) {
+            ByteBuf content = fullHttpMessage.content();
+            if (content.readableBytes() > maxContentLength - spdyDataFrame.content().readableBytes()) {
                 messageMap.remove(streamID);
                 throw new TooLongFrameException(
                         "HTTP content length exceeded " + maxContentLength + " bytes.");
             }
 
-            ByteBuf spdyDataFrameData = spdyDataFrame.data();
+            ByteBuf spdyDataFrameData = spdyDataFrame.content();
             int spdyDataFrameDataLen = spdyDataFrameData.readableBytes();
             content.writeBytes(spdyDataFrameData, spdyDataFrameData.readerIndex(), spdyDataFrameDataLen);
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -168,8 +168,8 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
 
             HttpContent chunk = (HttpContent) msg;
 
-            chunk.data().retain();
-            SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(currentStreamId, chunk.data());
+            chunk.content().retain();
+            SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(currentStreamId, chunk.content());
             spdyDataFrame.setLast(chunk instanceof LastHttpContent);
             if (chunk instanceof LastHttpContent) {
                 LastHttpContent trailer = (LastHttpContent) chunk;

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
Patch:
@@ -81,7 +81,7 @@ public void testEmptyContentCompression() throws Exception {
         HttpContent chunk;
         chunk = (HttpContent) ch.readOutbound();
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
-        assertThat(chunk.data().isReadable(), is(true));
+        assertThat(chunk.content().isReadable(), is(true));
 
         assertThat(ch.readOutbound(), is(nullValue()));
     }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
Patch:
@@ -54,7 +54,7 @@ public void testUnfinishedChunkedHttpRequestIsLastFlag() throws Exception {
                 break;
             }
             empty = false;
-            totalBytesPolled += httpChunk.data().readableBytes();
+            totalBytesPolled += httpChunk.content().readableBytes();
             Assert.assertFalse(httpChunk instanceof LastHttpContent);
         }
         Assert.assertFalse(empty);

File: codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
Patch:
@@ -97,7 +97,7 @@ public void testFullHttpRequestUpload() throws Exception {
                             data + "\r\n" +
                             "--" + boundary + "--\r\n";
 
-            req.data().writeBytes(body.getBytes(CharsetUtil.UTF_8));
+            req.content().writeBytes(body.getBytes(CharsetUtil.UTF_8));
         }
         // Create decoder instance to test.
         final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(inMemoryFactory, req);

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -66,6 +66,6 @@ public void testPerformOpeningHandshake() {
         Assert.assertEquals("chat", res.headers().get(Names.SEC_WEBSOCKET_PROTOCOL));
         LastHttpContent content = (LastHttpContent) ch2.readInbound();
 
-        Assert.assertEquals("8jKS'y:G*Co,Wxa-", content.data().toString(CharsetUtil.US_ASCII));
+        Assert.assertEquals("8jKS'y:G*Co,Wxa-", content.content().toString(CharsetUtil.US_ASCII));
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -129,7 +129,7 @@ private static void writeUpgradeRequest(EmbeddedMessageChannel ch) {
     }
 
     private static String getResponseMessage(FullHttpResponse response) {
-        return new String(response.data().array());
+        return new String(response.content().array());
     }
 
     private static FullHttpResponse getHttpResponse(EmbeddedMessageChannel ch) {

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -272,7 +272,7 @@ private static void sendListing(ChannelHandlerContext ctx, File dir) {
 
         buf.append("</ul></body></html>\r\n");
 
-        response.data().writeBytes(Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8));
+        response.content().writeBytes(Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8));
 
         // Close the connection as soon as the error message is sent.
         ctx.write(response).addListener(ChannelFutureListener.CLOSE);

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -52,7 +52,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
         if (msg instanceof HttpContent) {
             HttpContent content = (HttpContent) msg;
 
-            System.out.print(content.data().toString(CharsetUtil.UTF_8));
+            System.out.print(content.content().toString(CharsetUtil.UTF_8));
             System.out.flush();
 
             if (content instanceof LastHttpContent) {

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -98,7 +98,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
         if (msg instanceof HttpContent) {
             HttpContent httpContent = (HttpContent) msg;
 
-            ByteBuf content = httpContent.data();
+            ByteBuf content = httpContent.content();
             if (content.isReadable()) {
                 buf.append("CONTENT: ");
                 buf.append(content.toString(CharsetUtil.UTF_8));
@@ -149,7 +149,7 @@ private void writeResponse(ChannelHandlerContext ctx, HttpObject currentObj) {
 
         if (keepAlive) {
             // Add 'Content-Length' header only for a keep-alive connection.
-            response.headers().set(CONTENT_LENGTH, response.data().readableBytes());
+            response.headers().set(CONTENT_LENGTH, response.content().readableBytes());
             // Add keep alive header as per:
             // - http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01.html#Connection
             response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -59,7 +59,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
         }
         if (msg instanceof HttpContent) {
             HttpContent chunk = (HttpContent) msg;
-            logger.info(chunk.data().toString(CharsetUtil.UTF_8));
+            logger.info(chunk.content().toString(CharsetUtil.UTF_8));
 
             if (chunk instanceof LastHttpContent) {
                 if (readingChunks) {
@@ -69,7 +69,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
                 }
                 readingChunks = false;
             } else {
-                logger.info(chunk.data().toString(CharsetUtil.UTF_8));
+                logger.info(chunk.content().toString(CharsetUtil.UTF_8));
             }
         }
     }

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -94,7 +94,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
             handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
         } else if (frame instanceof PingWebSocketFrame) {
             ctx.nextOutboundMessageBuffer().add(
-                    new PongWebSocketFrame(frame.isFinalFragment(), frame.rsv(), frame.data().retain()));
+                    new PongWebSocketFrame(frame.isFinalFragment(), frame.rsv(), frame.content().retain()));
         } else if (frame instanceof TextWebSocketFrame) {
             ctx.nextOutboundMessageBuffer().add(frame.retain());
         } else if (frame instanceof BinaryWebSocketFrame) {
@@ -120,8 +120,8 @@ private static void sendHttpResponse(
             ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
         // Generate an error page if response getStatus code is not OK (200).
         if (res.getStatus().code() != 200) {
-            res.data().writeBytes(Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
-            setContentLength(res, res.data().readableBytes());
+            res.content().writeBytes(Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
+            setContentLength(res, res.content().readableBytes());
         }
 
         // Send the response and close the connection if necessary.

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -91,7 +91,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
         if (msg instanceof FullHttpResponse) {
             FullHttpResponse response = (FullHttpResponse) msg;
             throw new Exception("Unexpected FullHttpResponse (getStatus=" + response.getStatus() + ", content="
-                    + response.data().toString(CharsetUtil.UTF_8) + ')');
+                    + response.content().toString(CharsetUtil.UTF_8) + ')');
         }
 
         WebSocketFrame frame = (WebSocketFrame) msg;

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
Patch:
@@ -55,7 +55,7 @@ public void run() throws Exception {
             // Broadcast the QOTM request to port 8080.
             ch.write(new DatagramPacket(
                     Unpooled.copiedBuffer("QOTM?", CharsetUtil.UTF_8),
-                    new InetSocketAddress("255.255.255.255", port)));
+                    new InetSocketAddress("255.255.255.255", port))).sync();
 
             // QuoteOfTheMomentClientHandler will close the DatagramChannel when a
             // response is received.  If the channel is not closed within 5 seconds,

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
Patch:
@@ -26,7 +26,7 @@ public class QuoteOfTheMomentClientHandler extends ChannelInboundMessageHandlerA
     public void messageReceived(
             ChannelHandlerContext ctx, DatagramPacket msg)
             throws Exception {
-        String response = msg.data().toString(CharsetUtil.UTF_8);
+        String response = msg.content().toString(CharsetUtil.UTF_8);
         if (response.startsWith("QOTM: ")) {
             System.out.println("Quote of the Moment: " + response.substring(6));
             ctx.close();

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
Patch:
@@ -70,7 +70,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     @Override
     public void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
-        final ByteBuf byteBuf = message.data();
+        final ByteBuf byteBuf = message.content();
         meter.mark(byteBuf.readableBytes());
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
         out.add(message.retain());

File: example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
Patch:
@@ -70,7 +70,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     @Override
     public void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
-        final ByteBuf byteBuf = message.data();
+        final ByteBuf byteBuf = message.content();
         meter.mark(byteBuf.readableBytes());
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
         out.add(message.retain());

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -43,7 +43,7 @@ public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {
             public void messageReceived(
                     ChannelHandlerContext ctx,
                     DatagramPacket msg) throws Exception {
-                assertEquals(1, msg.data().readInt());
+                assertEquals(1, msg.content().readInt());
                 latch.countDown();
             }
         });

File: transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
Patch:
@@ -289,7 +289,7 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
     @Override
     protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws Exception {
         SctpMessage packet = (SctpMessage) buf.peek();
-        ByteBuf data = packet.data();
+        ByteBuf data = packet.content();
         int dataLen = data.readableBytes();
         ByteBuffer nioData;
         if (data.nioBufferCount() == 1) {

File: transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
Patch:
@@ -226,7 +226,7 @@ protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
                     return;
                 }
                 try {
-                    ByteBuf data = packet.data();
+                    ByteBuf data = packet.content();
                     int dataLen = data.readableBytes();
                     ByteBuffer nioData;
 

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
Patch:
@@ -58,7 +58,7 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
                     "pipeline before this handler", SctpMessageCompletionHandler.class.getSimpleName()));
         }
 
-        ctx.nextInboundByteBuffer().writeBytes(msg.data());
+        ctx.nextInboundByteBuffer().writeBytes(msg.content());
         ctx.fireInboundBufferUpdated();
     }
 }

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
Patch:
@@ -53,7 +53,7 @@ public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
     @Override
     public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
 
-        final ByteBuf byteBuf = msg.data();
+        final ByteBuf byteBuf = msg.content();
         final int protocolIdentifier = msg.protocolIdentifier();
         final int streamIdentifier = msg.streamIdentifier();
         final boolean isComplete = msg.isComplete();

File: transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
Patch:
@@ -15,12 +15,11 @@
  */
 package io.netty.channel.udt;
 
+import com.barchart.udt.TypeUDT;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import com.barchart.udt.TypeUDT;
-
 /**
  * The message container that is used for {@link TypeUDT#DATAGRAM} messages.
  * @see {@link NioUdtProvider#MESSAGE_CONNECTOR}
@@ -34,7 +33,7 @@ public UdtMessage(final ByteBuf data) {
 
     @Override
     public UdtMessage copy() {
-        return new UdtMessage(data().copy());
+        return new UdtMessage(content().copy());
     }
 
     @Override

File: transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java
Patch:
@@ -177,7 +177,7 @@ protected int doWriteMessages(final MessageBuf<Object> messageQueue,
         // expects a message
         final UdtMessage message = (UdtMessage) messageQueue.peek();
 
-        final ByteBuf byteBuf = message.data();
+        final ByteBuf byteBuf = message.content();
 
         final int messageSize = byteBuf.readableBytes();
 

File: transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java
Patch:
@@ -77,7 +77,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable e)
     @Override
     public void messageReceived(final ChannelHandlerContext ctx, final UdtMessage message) throws Exception {
 
-        final ByteBuf byteBuf = message.data();
+        final ByteBuf byteBuf = message.content();
 
         if (meter != null) {
             meter.mark(byteBuf.readableBytes());

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -135,13 +135,13 @@ public void run() {
                                 break;
                             }
                         }
-                        synchronized (stateLock) {
-                            state = ST_TERMINATED;
-                        }
                     } finally {
                         try {
                             cleanup();
                         } finally {
+                            synchronized (stateLock) {
+                                state = ST_TERMINATED;
+                            }
                             threadLock.release();
                             if (!taskQueue.isEmpty()) {
                                 logger.warn(

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -507,7 +507,7 @@ public void run() {
                     });
                 }
             } catch (Throwable t) {
-                logger.error("Failed to notify listener(s). Event loop terminated?", t);
+                logger.error("Failed to notify listener(s). Event loop shut down?", t);
             }
         }
     }
@@ -544,7 +544,7 @@ public void run() {
                 }
             });
         } catch (Throwable t) {
-            logger.error("Failed to notify a listener. Event loop terminated?", t);
+            logger.error("Failed to notify a listener. Event loop shut down?", t);
         }
     }
 
@@ -644,7 +644,7 @@ public void run() {
                     });
                 }
             } catch (Throwable t) {
-                logger.error("Failed to notify listener(s). Event loop terminated?", t);
+                logger.error("Failed to notify listener(s). Event loop shut down?", t);
             }
         }
     }

File: example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
Patch:
@@ -65,10 +65,10 @@ public void initChannel(SocketChannel ch) throws Exception {
     public void destroy() {
         super.destroy();
         if (bossGroup != null) {
-            bossGroup.shutdown();
+            bossGroup.shutdownGracefully();
         }
         if (workerGroup != null) {
-            workerGroup.shutdown();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/discard/DiscardClient.java
Patch:
@@ -50,7 +50,7 @@ public void run() throws Exception {
             // Wait until the connection is closed.
             f.channel().closeFuture().sync();
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/discard/DiscardServer.java
Patch:
@@ -56,8 +56,8 @@ public void initChannel(SocketChannel ch) throws Exception {
             // shut down your server.
             f.channel().closeFuture().sync();
         } finally {
-            workerGroup.shutdown();
-            bossGroup.shutdown();
+            workerGroup.shutdownGracefully();
+            bossGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -68,7 +68,7 @@ public void initChannel(SocketChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down the event loop to terminate all threads.
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -63,8 +63,8 @@ public void initChannel(SocketChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down all event loops to terminate all threads.
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/factorial/FactorialClient.java
Patch:
@@ -56,7 +56,7 @@ public void run() throws Exception {
             System.err.format(
                     "Factorial of %,d is: %,d", count, handler.getFactorial());
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/factorial/FactorialServer.java
Patch:
@@ -43,8 +43,8 @@ public void run() throws Exception {
 
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/filetransfer/FileServer.java
Patch:
@@ -80,8 +80,8 @@ public void initChannel(SocketChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down all event loops to terminate all threads.
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java
Patch:
@@ -39,8 +39,8 @@ public void run() throws Exception {
 
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -93,7 +93,7 @@ public void run() throws Exception {
             ch.closeFuture().sync();
         } finally {
             // Shut down executor threads to exit.
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
Patch:
@@ -46,8 +46,8 @@ public void run() throws Exception {
             Channel ch = b.bind(port).sync().channel();
             ch.closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -143,7 +143,7 @@ public void run() throws Exception {
             formPostMultipart(b, host, port, uriFile, factory, headers, bodylist);
         } finally {
             // Shut down executor threads to exit.
-            group.shutdown();
+            group.shutdownGracefully();
 
             // Really clean all temporary files if they still exist
             factory.cleanAllHttpDatas();

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
Patch:
@@ -47,8 +47,8 @@ public void run() throws Exception {
 
             ch.closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java
Patch:
@@ -46,8 +46,8 @@ public void run() throws Exception {
             System.out.println("Web Socket Server started at port " + port);
             f.channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -119,7 +119,7 @@ public void initChannel(SocketChannel ch) throws Exception {
             // responds to the CloseWebSocketFrame.
             ch.closeFuture().sync();
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java
Patch:
@@ -81,8 +81,8 @@ public void initChannel(final SocketChannel ch) throws Exception {
 
             ch.closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
Patch:
@@ -63,8 +63,8 @@ public void run() throws Exception {
 
             ch.closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java
Patch:
@@ -61,8 +61,8 @@ public void run() throws Exception {
             System.out.println("Open your browser and navigate to https://localhost:" + port + '/');
             ch.closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/localecho/LocalEcho.java
Patch:
@@ -105,8 +105,8 @@ public void initChannel(LocalChannel ch) throws Exception {
                 lastWriteFuture.awaitUninterruptibly();
             }
         } finally {
-            serverGroup.shutdown();
-            clientGroup.shutdown();
+            serverGroup.shutdownGracefully();
+            clientGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoClient.java
Patch:
@@ -60,7 +60,7 @@ public void initChannel(SocketChannel ch) throws Exception {
             // Start the connection attempt.
             b.connect(host, port).sync().channel().closeFuture().sync();
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoServer.java
Patch:
@@ -57,8 +57,8 @@ public void initChannel(SocketChannel ch) throws Exception {
             // Bind and start to accept incoming connections.
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/portunification/PortUnificationServer.java
Patch:
@@ -54,8 +54,8 @@ public void initChannel(SocketChannel ch) throws Exception {
             // Bind and start to accept incoming connections.
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/proxy/HexDumpProxy.java
Patch:
@@ -49,8 +49,8 @@ public void run() throws Exception {
              .childOption(ChannelOption.AUTO_READ, false)
              .bind(localPort).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
Patch:
@@ -64,7 +64,7 @@ public void run() throws Exception {
                 System.err.println("QOTM request timed out.");
             }
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServer.java
Patch:
@@ -46,7 +46,7 @@ public void run() throws Exception {
 
             b.bind(port).sync().channel().closeFuture().await();
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/rxtx/RxtxClient.java
Patch:
@@ -54,7 +54,7 @@ public void initChannel(RxtxChannel ch) throws Exception {
 
             f.channel().closeFuture().sync();
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java
Patch:
@@ -70,7 +70,7 @@ public void initChannel(SctpChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down the event loop to terminate all threads.
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java
Patch:
@@ -63,8 +63,8 @@ public void initChannel(SctpChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down all event loops to terminate all threads.
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java
Patch:
@@ -70,7 +70,7 @@ public void initChannel(SctpChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down the event loop to terminate all threads.
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java
Patch:
@@ -63,8 +63,8 @@ public void initChannel(SctpChannel ch) throws Exception {
             f.channel().closeFuture().sync();
         } finally {
             // Shut down all event loops to terminate all threads.
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/securechat/SecureChatClient.java
Patch:
@@ -76,7 +76,7 @@ public void run() throws Exception {
             }
         } finally {
             // The connection is closed automatically on shutdown.
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/securechat/SecureChatServer.java
Patch:
@@ -43,8 +43,8 @@ public void run() throws InterruptedException {
 
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/socksproxy/SocksServer.java
Patch:
@@ -39,8 +39,8 @@ public void run() throws Exception {
              .childHandler(new SocksServerInitializer());
             b.bind(localPort).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/telnet/TelnetClient.java
Patch:
@@ -74,7 +74,7 @@ public void run() throws Exception {
                 lastWriteFuture.sync();
             }
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/telnet/TelnetServer.java
Patch:
@@ -42,8 +42,8 @@ public void run() throws Exception {
 
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java
Patch:
@@ -77,7 +77,7 @@ public void initChannel(final UdtChannel ch)
             f.channel().closeFuture().sync();
         } finally {
             // Shut down the event loop to terminate all threads.
-            connectGroup.shutdown();
+            connectGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java
Patch:
@@ -73,8 +73,8 @@ public void initChannel(final UdtChannel ch)
             future.channel().closeFuture().sync();
         } finally {
             // Shut down all event loops to terminate all threads.
-            acceptGroup.shutdown();
-            connectGroup.shutdown();
+            acceptGroup.shutdownGracefully();
+            connectGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java
Patch:
@@ -77,7 +77,7 @@ public void initChannel(final UdtChannel ch)
             f.channel().closeFuture().sync();
         } finally {
             // Shut down the event loop to terminate all threads.
-            connectGroup.shutdown();
+            connectGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServer.java
Patch:
@@ -73,8 +73,8 @@ public void initChannel(final UdtChannel ch)
             future.channel().closeFuture().sync();
         } finally {
             // Shut down all event loops to terminate all threads.
-            acceptGroup.shutdown();
-            connectGroup.shutdown();
+            acceptGroup.shutdownGracefully();
+            connectGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerBase.java
Patch:
@@ -70,7 +70,7 @@ public void initChannel(final UdtChannel ch)
             f.channel().closeFuture().sync();
         } finally {
             // Shut down the event loop to terminate all threads.
-            connectGroup.shutdown();
+            connectGroup.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java
Patch:
@@ -67,7 +67,7 @@ protected void initChannel(UdtChannel ch) throws Exception {
             final ChannelFuture future = bootstrap.connect(peerAddress, myAddress).sync();
             future.channel().closeFuture().sync();
         } finally {
-            connectGroup.shutdown();
+            connectGroup.shutdownGracefully();
         }
     }
 }

File: example/src/main/java/io/netty/example/worldclock/WorldClockClient.java
Patch:
@@ -72,7 +72,7 @@ public void run() throws Exception {
                 System.out.format("%28s: %s%n", i1.next(), i2.next());
             }
         } finally {
-            group.shutdown();
+            group.shutdownGracefully();
         }
     }
 

File: example/src/main/java/io/netty/example/worldclock/WorldClockServer.java
Patch:
@@ -43,8 +43,8 @@ public void run() throws Exception {
 
             b.bind(port).sync().channel().closeFuture().sync();
         } finally {
-            bossGroup.shutdown();
-            workerGroup.shutdown();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -55,7 +55,7 @@ public static void createGroup() {
 
     @AfterClass
     public static void destroyGroup() {
-        group.shutdown();
+        group.shutdownGracefully();
     }
 
     @Test(timeout = 30000)

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -23,8 +23,6 @@
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
-import io.netty.util.concurrent.DefaultEventExecutorGroup;
-import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.handler.codec.string.StringDecoder;
@@ -33,6 +31,8 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.testsuite.util.BogusSslContextFactory;
+import io.netty.util.concurrent.DefaultEventExecutorGroup;
+import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.concurrent.Future;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -56,7 +56,7 @@ public static void createExecutor() {
 
     @AfterClass
     public static void shutdownExecutor() {
-        executor.shutdown();
+        executor.shutdownGracefully();
     }
 
     @Test(timeout = 30000)

File: transport-udt/src/test/java/io/netty/test/udt/bench/xfer/UdtNetty.java
Patch:
@@ -123,8 +123,8 @@ public static void main(final String[] args) throws Exception {
 
         Thread.sleep(1000);
 
-        group1.shutdown();
-        group2.shutdown();
+        group1.shutdownGracefully();
+        group2.shutdownGracefully();
 
         Metrics.defaultRegistry().shutdown();
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java
Patch:
@@ -113,7 +113,7 @@ public void basicEcho() throws Exception {
 
         assertEquals(handler1.meter().count(), handler2.meter().count());
 
-        group1.shutdown();
-        group2.shutdown();
+        group1.shutdownGracefully();
+        group2.shutdownGracefully();
     }
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java
Patch:
@@ -107,7 +107,7 @@ public void basicEcho() throws Exception {
 
         assertEquals(handler1.meter().count(), handler2.meter().count());
 
-        group1.shutdown();
-        group2.shutdown();
+        group1.shutdownGracefully();
+        group2.shutdownGracefully();
     }
 }

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -25,9 +25,8 @@
  */
 public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
 
-    protected SingleThreadEventLoop(
-            EventLoopGroup parent, ThreadFactory threadFactory) {
-        super(parent, threadFactory);
+    protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
+        super(parent, threadFactory, addTaskWakesUp);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/aio/AioEventLoopGroup.java
Patch:
@@ -73,6 +73,8 @@ public AioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
     }
 
     @Override
+    @Deprecated
+    @SuppressWarnings("deprecation")
     public void shutdown() {
         boolean interrupted = false;
 

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -235,7 +235,7 @@ public boolean tryFailure(Throwable cause) {
     @Override
     protected void checkDeadLock() {
         EventExecutor e = executor();
-        if (e != null && !(e instanceof DefaultChannelGroup.ImmediateEventExecutor) && e.inEventLoop()) {
+        if (e != null && !(e instanceof ImmediateEventExecutor) && e.inEventLoop()) {
             throw new BlockingOperationException();
         }
     }

File: transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
Patch:
@@ -55,7 +55,7 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) {
             allChannels.close().awaitUninterruptibly();
         }
 
-        bossGroup.shutdown();
-        workerGroup.shutdown();
+        bossGroup.shutdownGracefully();
+        workerGroup.shutdownGracefully();
     }
 }

File: transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
Patch:
@@ -80,8 +80,8 @@ public void run() {
             // Close the channel
             cc.close().sync();
 
-            serverGroup.shutdown();
-            clientGroup.shutdown();
+            serverGroup.shutdownGracefully();
+            clientGroup.shutdownGracefully();
 
             sc.closeFuture().sync();
 

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -158,7 +158,8 @@ public void testAggregateTransferEncodingChunked() {
         FullHttpRequest aggratedMessage = (FullHttpRequest) embedder.readInbound();
         assertNotNull(aggratedMessage);
 
-        assertEquals(chunk1.data().readableBytes() + chunk2.data().readableBytes(), HttpHeaders.getContentLength(aggratedMessage));
+        assertEquals(chunk1.data().readableBytes() + chunk2.data().readableBytes(),
+                HttpHeaders.getContentLength(aggratedMessage));
         assertEquals(aggratedMessage.headers().get("X-Test"), Boolean.TRUE.toString());
         checkContentBuffer(aggratedMessage);
         assertNull(embedder.readInbound());

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1145,7 +1145,7 @@ public static void removeTransferEncodingChunked(HttpMessage m) {
             return;
         }
         Iterator<String> valuesIt = values.iterator();
-        while(valuesIt.hasNext()) {
+        while (valuesIt.hasNext()) {
             String value = valuesIt.next();
             if (value.equalsIgnoreCase(Values.CHUNKED)) {
                 valuesIt.remove();

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
Patch:
@@ -29,7 +29,7 @@
 
 import static org.junit.Assert.*;
 
-public class HttpObjecctAggregatorTest {
+public class HttpObjectAggregatorTest {
 
     @Test
     public void testAggregate() {

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -948,6 +948,7 @@ private void invokeInboundBufferUpdated() {
                     }
                 } catch (Throwable t) {
                     notifyHandlerException(t);
+                    break;
                 } finally {
                     if (handler instanceof ChannelInboundByteHandler && !isInboundFreed()) {
                         try {

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -123,7 +123,8 @@ public final class NetUtil {
         // Create IPv6 loopback address.
         Inet6Address localhost6 = null;
         try {
-            localhost6 = (Inet6Address) InetAddress.getByAddress(new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});
+            localhost6 = (Inet6Address) InetAddress.getByAddress(
+                    new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});
         } catch (Exception e) {
             // We should not get here as long as the length of the address is correct.
             PlatformDependent.throwException(e);

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java
Patch:
@@ -49,7 +49,7 @@ protected void run() throws Throwable {
             sb = e.getKey().newInstance();
             cb = e.getValue().newInstance();
             addr = new InetSocketAddress(
-                    NetUtil.LOCALHOST, TestUtils.getFreePort());
+                    NetUtil.LOCALHOST4, TestUtils.getFreePort());
             sb.localAddress(addr);
             cb.localAddress(0).remoteAddress(addr);
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -161,8 +161,7 @@ public class SslHandler
     private static final Pattern IGNORABLE_CLASS_IN_STACK = Pattern.compile(
             "^.*(?:Socket|Datagram|Sctp)Channel.*$");
     private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
-            "^.*(?:connection.*reset|connection.*closed|broken.*pipe).*$",
-            Pattern.CASE_INSENSITIVE);
+            "^.*(?:connection.*(?:reset|closed|abort)|broken.*pipe).*$", Pattern.CASE_INSENSITIVE);
 
     private static final SSLException SSLENGINE_CLOSED = new SSLException("SSLEngine closed already");
     private static final SSLException HANDSHAKE_TIMED_OUT = new SSLException("handshake timed out");

File: common/src/main/java/io/netty/util/NetUtil.java
Patch:
@@ -120,7 +120,7 @@ public final class NetUtil {
                 }
             } catch (SocketException e) {
                 //Nope. Can't do anything else, sorry!
-                logger.error("Failed to enumerate network interfaces", e);
+                logger.warn("Failed to enumerate network interfaces", e);
             }
         }
 

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -1348,7 +1348,7 @@ public void testDiscardReadBytes2() {
         for (int i = 0; i < buffer.capacity(); i ++) {
             buffer.writeByte((byte) i);
         }
-        ByteBuf copy = copiedBuffer(buffer);
+        ByteBuf copy = freeLater(copiedBuffer(buffer));
 
         // Discard the first (CAPACITY / 2 - 1) bytes.
         buffer.setIndex(CAPACITY / 2 - 1, CAPACITY - 1);

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
Patch:
@@ -227,7 +227,8 @@ private static LinkedList<EventType> events(boolean inbound, int size) {
         EventType[] events;
         if (inbound) {
             events = new EventType[] {
-                    EventType.USER_EVENT, EventType.INBOUND_BUFFER_UPDATED, EventType.READ_SUSPEND, EventType.EXCEPTION_CAUGHT};
+                    EventType.USER_EVENT, EventType.INBOUND_BUFFER_UPDATED, EventType.READ_SUSPEND,
+                    EventType.EXCEPTION_CAUGHT};
         } else {
             events = new EventType[] {
                     EventType.READ, EventType.FLUSH, EventType.EXCEPTION_CAUGHT };

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -202,9 +202,9 @@ protected String getTargetContentEncoding(String contentEncoding) throws Excepti
     }
 
     @Override
-    public void afterRemove(ChannelHandlerContext ctx) throws Exception {
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         cleanup();
-        super.afterRemove(ctx);
+        super.handlerRemoved(ctx);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -228,9 +228,9 @@ private HttpContent[] encodeContent(HttpContent c) {
     protected abstract Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception;
 
     @Override
-    public void afterRemove(ChannelHandlerContext ctx) throws Exception {
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         cleanup();
-        super.afterRemove(ctx);
+        super.handlerRemoved(ctx);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -203,7 +203,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
Patch:
@@ -137,7 +137,7 @@ public void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) thr
     }
 
     @Override
-    public void afterAdd(ChannelHandlerContext ctx) {
+    public void handlerAdded(ChannelHandlerContext ctx) {
         ChannelPipeline cp = ctx.pipeline();
         if (cp.get(WebSocketClientProtocolHandshakeHandler.class) == null) {
             // Add the WebSocketClientProtocolHandshakeHandler before this one.

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -80,7 +80,7 @@ public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,
     }
 
     @Override
-    public void afterAdd(ChannelHandlerContext ctx) {
+    public void handlerAdded(ChannelHandlerContext ctx) {
         ChannelPipeline cp = ctx.pipeline();
         if (cp.get(WebSocketServerProtocolHandshakeHandler.class) == null) {
             // Add the WebSocketHandshakeHandler before this one.

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -60,7 +60,7 @@ public SpdyFrameEncoder(int version, int compressionLevel, int windowBits, int m
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         ctx.channel().closeFuture().addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) throws Exception {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjecctAggregatorTest.java
Patch:
@@ -132,7 +132,7 @@ public void testSetMaxCumulationBufferComponentsAfterInit() throws Exception {
         HttpObjectAggregator aggr = new HttpObjectAggregator(Integer.MAX_VALUE);
         ChannelHandlerContext ctx = EasyMock.createMock(ChannelHandlerContext.class);
         EasyMock.replay(ctx);
-        aggr.beforeAdd(ctx);
+        aggr.handlerAdded(ctx);
         aggr.setMaxCumulationBufferComponents(10);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -404,7 +404,7 @@ private ChannelFuture finishEncode(ChannelHandlerContext ctx, ChannelPromise fut
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
     }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
Patch:
@@ -262,7 +262,7 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromi
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
     }
 }

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -64,7 +64,7 @@ public ChannelFuture handshakeFuture() {
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         handshakeFuture = ctx.newPromise();
     }
 

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -210,7 +210,7 @@ public long getAllIdleTimeInMillis() {
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         if (ctx.channel().isActive() & ctx.channel().isRegistered()) {
             // channelActvie() event has been fired already, which means this.channelActive() will
             // not be invoked. We have to initialize here instead.
@@ -222,7 +222,7 @@ public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void beforeRemove(ChannelHandlerContext ctx) throws Exception {
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         destroy();
     }
 

File: handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -103,7 +103,7 @@ public ReadTimeoutHandler(long timeout, TimeUnit unit) {
     }
 
     @Override
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         if (ctx.channel().isActive() && ctx.channel().isRegistered()) {
             // channelActvie() event has been fired already, which means this.channelActive() will
             // not be invoked. We have to initialize here instead.
@@ -115,7 +115,7 @@ public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void beforeRemove(ChannelHandlerContext ctx) throws Exception {
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         destroy();
     }
 

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -313,7 +313,7 @@ public TrafficCounter trafficCounter() {
     }
 
     @Override
-    public void beforeRemove(ChannelHandlerContext ctx) {
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         if (trafficCounter != null) {
             trafficCounter.stop();
         }

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.BufType;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
@@ -34,6 +33,7 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.testsuite.util.BogusSslContextFactory;
+import io.netty.util.concurrent.Future;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -145,7 +145,7 @@ public void initChannel(SocketChannel sch) throws Exception {
 
     private class StartTlsClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
         private final SslHandler sslHandler;
-        private ChannelFuture handshakeFuture;
+        private Future<Channel> handshakeFuture;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
         StartTlsClientHandler(SSLEngine engine) {
@@ -163,7 +163,7 @@ public void channelActive(ChannelHandlerContext ctx)
         public void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
             if ("StartTlsResponse".equals(msg)) {
                 ctx.pipeline().addAfter("logger", "ssl", sslHandler);
-                handshakeFuture = sslHandler.handshake();
+                handshakeFuture = sslHandler.handshakeFuture();
                 ctx.write("EncryptedRequest\n");
                 return;
             }

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -880,12 +880,12 @@ public void run() {
                             if (pipeline.isInboundShutdown()) {
                                 return;
                             }
-
-                            if (findContextInbound() == next) {
+                            DefaultChannelHandlerContext nextInbound = findContextInbound();
+                            if (nextInbound == next) {
                                 next.invokeInboundBufferUpdated();
                             } else {
                                 // Pipeline changed since the task was submitted; try again.
-                                fireInboundBufferUpdated0(next);
+                                fireInboundBufferUpdated0(nextInbound);
                             }
                         }
                     };

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -489,7 +489,6 @@ public void testReferenceCounts2() {
         assertThat(c1.refCnt(), is(1));
         assertThat(c2.refCnt(), is(2));
         assertThat(c3.refCnt(), is(3));
-
     }
 
     @Test

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -93,8 +93,8 @@ public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel)
     }
 
     @Override
-    protected Result beginEncode(HttpMessage header, HttpContent msg, String acceptEncoding) throws Exception {
-        String contentEncoding = header.headers().get(HttpHeaders.Names.CONTENT_ENCODING);
+    protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
+        String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);
         if (contentEncoding != null &&
             !HttpHeaders.Values.IDENTITY.equalsIgnoreCase(contentEncoding)) {
             return null;

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -283,7 +283,7 @@ public ByteBuf outboundByteBuffer() {
     @Override
     @SuppressWarnings("unchecked")
     public <T> MessageBuf<T> outboundMessageBuffer() {
-        return (MessageBuf<T>) pipeline.outboundMessageBuffer();
+        return pipeline.outboundMessageBuffer();
     }
 
     @Override
@@ -307,8 +307,8 @@ public ChannelPromise newPromise() {
     }
 
     @Override
-    public ChannelTransferPromise newTransferPromise(long total) {
-        return new DefaultChannelTransferPromise(this, total);
+    public ChannelProgressivePromise newProgressivePromise(long total) {
+        return new DefaultChannelProgressivePromise(this, total);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/ChannelFutureListener.java
Patch:
@@ -70,4 +70,6 @@ public void operationComplete(ChannelFuture future) {
             }
         }
     };
+
+    // Just a type alias
 }

File: transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java
Patch:
@@ -41,9 +41,9 @@ interface ChannelPropertyAccess {
     ChannelPromise newPromise();
 
     /**
-     * Return an new {@link ChannelTransferPromise}
+     * Return an new {@link ChannelProgressivePromise}
      */
-    ChannelTransferPromise newTransferPromise(long total);
+    ChannelProgressivePromise newProgressivePromise(long total);
 
     /**
      * Create a new {@link ChannelFuture} which is marked as successes already. So {@link ChannelFuture#isSuccess()}

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1558,8 +1558,8 @@ public ChannelPromise newPromise() {
     }
 
     @Override
-    public ChannelTransferPromise newTransferPromise(long  total) {
-        return new DefaultChannelTransferPromise(channel(), executor(), total);
+    public ChannelProgressivePromise newProgressivePromise(long total) {
+        return new DefaultChannelProgressivePromise(channel(), executor(), total);
     }
 
     @Override

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -81,7 +81,7 @@ public static void destroy() {
     }
 
     @Test(timeout = 30000)
-    @Ignore
+    @Ignore("regression test")
     public void testStagedExecutionMultiple() throws Throwable {
         for (int i = 0; i < 10; i ++) {
             testStagedExecution();
@@ -206,7 +206,7 @@ public void testStagedExecution() throws Throwable {
     }
 
     @Test(timeout = 30000)
-    @Ignore
+    @Ignore("regression test")
     public void testConcurrentMessageBufferAccess() throws Throwable {
         EventLoopGroup l = new LocalEventLoopGroup(4, new PrefixThreadFactory("l"));
         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new PrefixThreadFactory("e1"));

File: common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java
Patch:
@@ -131,7 +131,7 @@ public void testInnerClass() throws Exception {
         assertTrue(m.match(new Object()));
     }
 
-    private static abstract class W<E> {
+    private abstract static class W<E> {
         E e;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java
Patch:
@@ -59,7 +59,7 @@ public HttpResponse setProtocolVersion(HttpVersion version) {
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(getClass().getSimpleName());
-        buf.append(", decodeResult: ");
+        buf.append("(decodeResult: ");
         buf.append(getDecoderResult());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);

File: transport/src/main/java/io/netty/channel/ChannelInitializer.java
Patch:
@@ -56,7 +56,7 @@ public abstract class ChannelInitializer<C extends Channel> extends ChannelState
      * will be removed from the {@link ChannelPipeline} of the {@link Channel}.
      *
      * @param ch            the {@link Channel} which was registered.
-     * @throws Exception    is thrown if an error accours. In that case the {@link Channel} will be closed.
+     * @throws Exception    is thrown if an error occours. In that case the {@link Channel} will be closed.
      */
     protected abstract void initChannel(C ch) throws Exception;
 

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -296,7 +296,7 @@ protected void doBeginRead() throws Exception {
     }
 
     /**
-     * Conect to the remote peer
+     * Connect to the remote peer
      */
     protected abstract boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception;
 

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -98,7 +98,7 @@ public final class NioEventLoop extends SingleThreadEventLoop {
 
     /**
      * Boolean that controls determines if a blocked Selector.select should
-     * break out of its selection process. In our case we use a timeone for
+     * break out of its selection process. In our case we use a timeout for
      * the select method and the select method will block for that time unless
      * waken up.
      */

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -287,7 +287,9 @@ private static boolean isAndroid0() {
             android = false;
         }
 
-        logger.debug("Platform: Android");
+        if (android) {
+            logger.debug("Platform: Android");
+        }
         return android;
     }
 

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -698,7 +698,7 @@ public final void close(final ChannelPromise promise) {
                         promise.setFailure(t);
                     }
 
-                    if (closedChannelException != null) {
+                    if (closedChannelException == null) {
                         closedChannelException = new ClosedChannelException();
                     }
 

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -99,7 +99,7 @@ public Throwable cause() {
 
     @Override
     @SuppressWarnings("unchecked")
-    public Promise<V> addListener(GenericFutureListener <? extends Future<V>> listener) {
+    public Promise<V> addListener(GenericFutureListener<? extends Future<V>> listener) {
         if (listener == null) {
             throw new NullPointerException("listener");
         }

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -15,14 +15,14 @@
  */
 package io.netty.handler.codec.compression;
 
+import com.jcraft.jzlib.Deflater;
+import com.jcraft.jzlib.JZlib;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import com.jcraft.jzlib.JZlib;
-import com.jcraft.jzlib.Deflater;
 
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -380,7 +380,7 @@ private ChannelFuture finishEncode(ChannelHandlerContext ctx, ChannelPromise fut
                 // Write the ADLER32 checksum (stream footer).
                 int resultCode = z.deflate(JZlib.Z_FINISH);
                 if (resultCode != JZlib.Z_OK && resultCode != JZlib.Z_STREAM_END) {
-                    future.setFailure(ZlibUtil.exception(z, "compression failure", resultCode));
+                    future.setFailure(ZlibUtil.deflaterException(z, "compression failure", resultCode));
                     return future;
                 } else if (z.next_out_index != 0) {
                     footer = Unpooled.wrappedBuffer(out, 0, z.next_out_index);

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -98,7 +98,8 @@ public Throwable cause() {
     }
 
     @Override
-    public Promise<V> addListener(GenericFutureListener<? extends Future<V>> listener) {
+    @SuppressWarnings("unchecked")
+    public Promise<V> addListener(GenericFutureListener <? extends Future<V>> listener) {
         if (listener == null) {
             throw new NullPointerException("listener");
         }
@@ -459,6 +460,7 @@ private void decWaiters() {
         state -= 0x10000000000L;
     }
 
+    @SuppressWarnings("unchecked")
     private void notifyListeners() {
         // This method doesn't need synchronization because:
         // 1) This method is always called after synchronized (this) block.

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -108,7 +108,7 @@
  * <pre>
  * // Fills the writable bytes of a buffer with random integers.
  * {@link ByteBuf} buffer = ...;
- * while (buffer.writableBytes() >= 4) {
+ * while (buffer.maxWritableBytes() >= 4) {
  *     buffer.writeInt(random.nextInt());
  * }
  * </pre>

File: buffer/src/main/java/io/netty/buffer/MessageBuf.java
Patch:
@@ -26,15 +26,15 @@
 public interface MessageBuf<T> extends Buf, Queue<T> {
 
     /**
-     * Drain the content of te {@link MessageBuf} to the given {@link Collection}.
+     * Drain the content of the {@link MessageBuf} to the given {@link Collection}.
      *
      * @param c         the {@link Collection} to drain the content to
      * @return number   the number of objects which was transfered
      */
     int drainTo(Collection<? super T> c);
 
     /**
-     * Drain the content of te {@link MessageBuf} to the given {@link Collection}.
+     * Drain the content of the {@link MessageBuf} to the given {@link Collection}.
      *
      * @param c             the {@link Collection} to drain the content to
      * @param maxElements   the max number of elements to drain

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
@@ -42,7 +43,7 @@ public SocksAuthRequestDecoder() {
     }
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksSubnegotiationVersion.fromByte(byteBuf.readByte());
@@ -63,7 +64,7 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Excep
             }
         }
         ctx.pipeline().remove(this);
-        return msg;
+        out.add(msg);
     }
 
     enum State {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
@@ -45,7 +46,7 @@ public SocksCmdRequestDecoder() {
     }
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
@@ -87,7 +88,7 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Excep
             }
         }
         ctx.pipeline().remove(this);
-        return msg;
+        out.add(msg);
     }
 
     enum State {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
@@ -45,7 +46,7 @@ public SocksCmdResponseDecoder() {
     }
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
@@ -87,7 +88,7 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Excep
             }
         }
         ctx.pipeline().remove(this);
-        return msg;
+        out.add(msg);
     }
 
     enum State {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 
@@ -43,7 +44,7 @@ public SocksInitRequestDecoder() {
     }
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
@@ -63,7 +64,7 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Excep
             }
         }
         ctx.pipeline().remove(this);
-        return msg;
+        out.add(msg);
     }
 
     enum State {

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 
@@ -40,7 +41,7 @@ public SocksInitResponseDecoder() {
     }
 
     @Override
-    protected SocksResponse decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
@@ -56,7 +57,7 @@ protected SocksResponse decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throw
             }
         }
         ctx.pipeline().remove(this);
-        return msg;
+        out.add(msg);
     }
 
     enum State {

File: codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.base64;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
@@ -58,7 +59,7 @@ public Base64Decoder(Base64Dialect dialect) {
     }
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
-        return Base64.decode(msg, msg.readerIndex(), msg.readableBytes(), dialect);
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+        out.add(Base64.decode(msg, msg.readerIndex(), msg.readableBytes(), dialect));
     }
 }

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
@@ -49,7 +50,7 @@
 public class ByteArrayDecoder extends MessageToMessageDecoder<ByteBuf> {
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
         byte[] array;
         if (msg.hasArray()) {
             if (msg.arrayOffset() == 0 && msg.readableBytes() == msg.capacity()) {
@@ -67,6 +68,6 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf msg) throws Exception
             msg.getBytes(0, array);
         }
 
-        return array;
+        out.add(array);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.string;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
@@ -74,7 +75,7 @@ public StringDecoder(Charset charset) {
     }
 
     @Override
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
-        return msg.toString(charset);
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+        out.add(msg.toString(charset));
     }
 }

File: codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufIndexFinder;
+import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedByteChannel;
@@ -53,10 +54,10 @@ private static final class LineDecoder extends ReplayingDecoder<Void> {
         }
 
         @Override
-        protected ByteBuf decode(ChannelHandlerContext ctx, ByteBuf in) {
+        protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) {
             ByteBuf msg = in.readBytes(in.bytesBefore(ByteBufIndexFinder.LF));
             in.skipBytes(1);
-            return msg;
+            out.add(msg);
         }
     }
 }

File: transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java
Patch:
@@ -221,7 +221,7 @@ public static boolean addToNextOutboundBuffer(ChannelHandlerContext ctx, Object
                 return true;
             }
         }
-        return ctx.nextOutboundMessageBuffer().unfoldAndAdd(msg);
+        return ctx.nextOutboundMessageBuffer().add(msg);
     }
 
     /**
@@ -235,7 +235,7 @@ public static boolean addToNextInboundBuffer(ChannelHandlerContext ctx, Object m
                 return true;
             }
         }
-        return ctx.nextInboundMessageBuffer().unfoldAndAdd(msg);
+        return ctx.nextInboundMessageBuffer().add(msg);
     }
 
     private ChannelHandlerUtil() { }

File: transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
Patch:
@@ -29,11 +29,11 @@
 public class NioEventLoopGroup extends MultithreadEventLoopGroup {
 
     /**
-     * Create a new instance using {@link #DEFAULT_POOL_SIZE} number of threads, the default {@link ThreadFactory} and
-     * the  {@link SelectorProvider} which is returned by {@link SelectorProvider#provider()}.
+     * Create a new instance using {@link #DEFAULT_EVENT_LOOP_THREADS} number of threads, the default
+     * {@link ThreadFactory} and  the {@link SelectorProvider} which is returned by {@link SelectorProvider#provider()}.
      */
     public NioEventLoopGroup() {
-        this(0);
+        this(DEFAULT_EVENT_LOOP_THREADS);
     }
 
     /**

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -28,8 +28,7 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
     /**
      * @see {@link MultithreadEventExecutorGroup##MultithreadEventLoopGroup(int,ThreadFactory, Object...)}
      */
-    protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory,
-            Object... args) {
+    protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
         super(nThreads, threadFactory, args);
     }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -751,7 +751,7 @@ private static void waitForFuture(Future<?> future) {
     @Override
     public ChannelHandler first() {
         DefaultChannelHandlerContext first = head.next;
-        if (first == null) {
+        if (first == head) {
             return null;
         }
         return first.handler();

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -482,7 +482,7 @@ private static boolean hasJavassist0() {
             logger.debug("Javassist: unavailable");
             logger.warn(
                     "You don't have Javassist in your class path or you don't have enough permission " +
-                            "to load dynamically generated classes.  Please check the configuration for better performance.");
+                    "to load dynamically generated classes.  Please check the configuration for better performance.");
             return false;
         }
     }

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -90,9 +90,9 @@ final class PlatformDependent0 {
                             "copyMemory",
                             new Class[] { Object.class, long.class, Object.class, long.class, long.class });
 
-                    logger.debug("sun.misc.Unsafe.copyMemory(Object, long, Object, long, long): available");
+                    logger.debug("sun.misc.Unsafe.copyMemory: available");
                 } catch (NoSuchMethodError t) {
-                    logger.debug("sun.misc.Unsafe.copyMemory(Object, long, Object, long, long): unavailable");
+                    logger.debug("sun.misc.Unsafe.copyMemory: unavailable");
                     throw t;
                 }
             } catch (Throwable cause) {

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -1519,7 +1519,6 @@ public void testCompareTo() {
         buffer.setIndex(0, value.length);
         buffer.setBytes(0, value);
 
-
         assertEquals(0, buffer.compareTo(wrappedBuffer(value)));
         assertEquals(0, buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)));
 

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -99,7 +99,8 @@ protected boolean discardReadBytesDoesNotMoveWritableBytes() {
      */
     @Test
     public void testComponentAtOffset() {
-        CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5}, new byte[]{4, 5, 6, 7, 8, 9, 26});
+        CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},
+                new byte[]{4, 5, 6, 7, 8, 9, 26});
 
         //Ensure that a random place will be fine
         assertEquals(5, buf.componentAtOffset(2).capacity());
@@ -412,7 +413,7 @@ public void testWrittenBuffersEquals() {
         assertFalse(BufUtil.equals(a, b));
     }
 
-    @Test 
+    @Test
     public void testEmptyBuffer() {
         ByteBuf b = freeLater(wrappedBuffer(new byte[]{1, 2}, new byte[]{3, 4}));
         b.readBytes(new byte[4]);

File: buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java
Patch:
@@ -105,8 +105,6 @@ public void testReadOnly() throws Exception {
 
         ro.setIndex(2, 6);
         assertThat(buf.readerIndex(), is(1));
-        assertThat(buf.writerIndex(), is(7));
-
     }
 
     @Test

File: buffer/src/test/java/io/netty/buffer/ConsolidationTest.java
Patch:
@@ -41,7 +41,7 @@ public void shouldWrapInSequence() {
     public void shouldConsolidationInSequence() {
         ByteBuf currentBuffer = wrappedBuffer(wrappedBuffer("a".getBytes()), wrappedBuffer("=".getBytes()));
         currentBuffer = wrappedBuffer(currentBuffer, wrappedBuffer("1".getBytes()), wrappedBuffer("&".getBytes()));
-        
+
         currentBuffer = wrappedBuffer(currentBuffer, wrappedBuffer("b".getBytes()), wrappedBuffer("=".getBytes()));
         currentBuffer = wrappedBuffer(currentBuffer, wrappedBuffer("2".getBytes()), wrappedBuffer("&".getBytes()));
 
@@ -60,5 +60,5 @@ public void shouldConsolidationInSequence() {
 
         currentBuffer.release();
         copy.release();
-    }    
+    }
 }

File: buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java
Patch:
@@ -44,7 +44,6 @@ public void testSetByte() {
         buf.setByte(0, 1);
     }
 
-
     @Test(expected = ReadOnlyBufferException.class)
     public void testSetInt() {
         ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());
@@ -109,10 +108,10 @@ public void testGetReadInt() {
         Assert.assertFalse(buf.isReadable());
     }
 
-
     @Test
     public void testGetReadShort() {
-        ByteBuf buf = buffer(((ByteBuffer) allocate(8).putShort((short) 1).putShort((short) 2).flip()).asReadOnlyBuffer());
+        ByteBuf buf = buffer(((ByteBuffer) allocate(8).putShort((short) 1)
+                .putShort((short) 2).flip()).asReadOnlyBuffer());
         Assert.assertEquals(1, buf.getShort(0));
         Assert.assertEquals(2, buf.getShort(2));
 

File: buffer/src/test/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBufferBufTest.java
Patch:
@@ -28,7 +28,7 @@ public class ReadOnlyUnsafeDirectByteBufferBufTest extends ReadOnlyDirectByteBuf
      * Needs unsafe to run
      */
     @BeforeClass
-    public static void assumeConditions(){
+    public static void assumeConditions() {
         assumeTrue(PlatformDependent.hasUnsafe());
     }
 

File: buffer/src/test/java/io/netty/buffer/UnpooledTest.java
Patch:
@@ -568,7 +568,6 @@ public void testWrapBoolean() {
 
         assertEquals(0, Unpooled.copyBoolean(null).capacity());
         assertEquals(0, Unpooled.copyBoolean(new boolean[0]).capacity());
-
     }
 
     @Test

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestEncoderTest.java
Patch:
@@ -37,7 +37,6 @@ public void testUriWithoutPath() throws Exception {
         assertEquals("GET http://localhost/ HTTP/1.1\r\n", req);
     }
 
-
     @Test
     public void testUriWithPath() throws Exception {
         HttpRequestEncoder encoder = new HttpRequestEncoder();
@@ -47,4 +46,4 @@ public void testUriWithPath() throws Exception {
         String req = buffer.toString(Charset.forName("US-ASCII"));
         assertEquals("GET http://localhost/ HTTP/1.1\r\n", req);
     }
-}
\ No newline at end of file
+}

File: codec-http/src/test/java/io/netty/handler/codec/http/QueryStringDecoderTest.java
Patch:
@@ -184,7 +184,6 @@ public void testURI() {
         Assert.assertEquals(1, entry.getValue().size());
         Assert.assertEquals("value1", entry.getValue().get(0));
 
-
         entry = entries.next();
         Assert.assertEquals("param2", entry.getKey());
         Assert.assertEquals(1, entry.getValue().size());
@@ -213,7 +212,6 @@ public void testURISlashPath() {
         Assert.assertEquals(1, entry.getValue().size());
         Assert.assertEquals("value1", entry.getValue().get(0));
 
-
         entry = entries.next();
         Assert.assertEquals("param2", entry.getKey());
         Assert.assertEquals(1, entry.getValue().size());
@@ -242,7 +240,6 @@ public void testURINoPath() {
         Assert.assertEquals(1, entry.getValue().size());
         Assert.assertEquals("value1", entry.getValue().get(0));
 
-
         entry = entries.next();
         Assert.assertEquals("param2", entry.getKey());
         Assert.assertEquals(1, entry.getValue().size());

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksInitRequestTest.java
Patch:
@@ -20,10 +20,10 @@
 
 public class SocksInitRequestTest {
     @Test
-    public void testConstructorParamsAreNotNull(){
+    public void testConstructorParamsAreNotNull() {
         try {
             new SocksInitRequest(null);
-        } catch (Exception e){
+        } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }
     }

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
Patch:
@@ -25,7 +25,7 @@
 
 public class SnappyFramedEncoderTest {
     private EmbeddedByteChannel channel;
-    
+
     @Before
     public void setUp() {
         channel = new EmbeddedByteChannel(new SnappyFramedEncoder());
@@ -85,7 +85,7 @@ public void testStreamStartIsOnlyWrittenOnce() throws Exception {
         });
         assertEquals(expected, channel.readOutbound());
     }
-    
+
     /**
      * This test asserts that if we have a remainder after emitting a copy that
      * is less than 4 bytes (ie. the minimum required for a copy), we should
@@ -127,7 +127,7 @@ public void testInputBufferOverseek() throws Exception {
              -1,   -1,   -1, // copy
              -1,   1 // remainder
         });
-        
+
         channel.writeOutbound(in);
         assertTrue(channel.finish());
     }

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -70,12 +70,11 @@ public void test1002() throws Throwable {
         }));
     }
 
-
     // These tests were found using testRandom() with large RANDOM_RUNS.
 
     // Tests that copies do not attempt to overrun into a previous frame chunk
     @Test
-    public void test5323211032315942961(){
+    public void test5323211032315942961() {
         testWithSeed(5323211032315942961L);
     }
 

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
Patch:
@@ -121,12 +121,12 @@ public void testTooBigObject() throws IOException {
     }
 
     protected ChannelHandler createDecoder(int maxObjectSize) {
-        return new CompatibleMarshallingDecoder(createProvider(createMarshallerFactory(), createMarshallingConfig()), maxObjectSize);
+        return new CompatibleMarshallingDecoder(createProvider(createMarshallerFactory(),
+                createMarshallingConfig()), maxObjectSize);
     }
 
     protected UnmarshallerProvider createProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         return new DefaultUnmarshallerProvider(factory, config);
-
     }
 
     protected abstract MarshallerFactory createMarshallerFactory();

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverCompatibleMarshallingEncoderTest.java
Patch:
@@ -21,7 +21,6 @@
 
 public class RiverCompatibleMarshallingEncoderTest extends AbstractCompatibleMarshallingEncoderTest {
 
-
     @Override
     protected MarshallerFactory createMarshallerFactory() {
         return Marshalling.getProvidedMarshallerFactory("river");

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverContextBoundCompatibleMarshallingDecoderTest.java
Patch:
@@ -25,5 +25,4 @@ protected UnmarshallerProvider createProvider(MarshallerFactory factory, Marshal
         return new ContextBoundUnmarshallerProvider(factory, config);
     }
 
-
 }

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverContextBoundMarshallingDecoderTest.java
Patch:
@@ -25,5 +25,4 @@ protected UnmarshallerProvider createProvider(MarshallerFactory factory, Marshal
         return new ContextBoundUnmarshallerProvider(factory, config);
     }
 
-
 }

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
Patch:
@@ -30,8 +30,8 @@ protected ByteBuf input(byte[] input) {
 
     @Override
     protected ChannelHandler createDecoder(int maxObjectSize) {
-        return new MarshallingDecoder(createProvider(createMarshallerFactory(), createMarshallingConfig()), maxObjectSize);
+        return new MarshallingDecoder(createProvider(createMarshallerFactory(),
+                createMarshallingConfig()), maxObjectSize);
     }
 
-
 }

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverThreadLocalCompatibleMarshallingDecoderTest.java
Patch:
@@ -25,5 +25,4 @@ protected UnmarshallerProvider createProvider(MarshallerFactory factory, Marshal
         return new ThreadLocalUnmarshallerProvider(factory, config);
     }
 
-
 }

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverThreadLocalMarshallingDecoderTest.java
Patch:
@@ -25,5 +25,4 @@ protected UnmarshallerProvider createProvider(MarshallerFactory factory, Marshal
         return new ThreadLocalUnmarshallerProvider(factory, config);
     }
 
-
 }

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialCompatibleMarshallingEncoderTest.java
Patch:
@@ -21,7 +21,6 @@
 
 public class SerialCompatibleMarshallingEncoderTest extends AbstractCompatibleMarshallingEncoderTest {
 
-
     @Override
     protected MarshallerFactory createMarshallerFactory() {
         return Marshalling.getProvidedMarshallerFactory("serial");

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialContextBoundCompatibleMarshallingDecoderTest.java
Patch:
@@ -20,7 +20,6 @@
 
 public class SerialContextBoundCompatibleMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest {
 
-
     @Override
     protected UnmarshallerProvider createProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         return new ContextBoundUnmarshallerProvider(factory, config);

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialContextBoundMarshallingDecoderTest.java
Patch:
@@ -20,7 +20,6 @@
 
 public class SerialContextBoundMarshallingDecoderTest extends SerialMarshallingDecoderTest {
 
-
     @Override
     protected UnmarshallerProvider createProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         return new ContextBoundUnmarshallerProvider(factory, config);

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
Patch:
@@ -30,7 +30,8 @@ protected ByteBuf input(byte[] input) {
 
     @Override
     protected ChannelHandler createDecoder(int maxObjectSize) {
-        return new MarshallingDecoder(createProvider(createMarshallerFactory(), createMarshallingConfig()), maxObjectSize);
+        return new MarshallingDecoder(createProvider(createMarshallerFactory(),
+                createMarshallingConfig()), maxObjectSize);
     }
 
 }

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingEncoderTest.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler;
 
-public class SerialMarshallingEncoderTest extends SerialCompatibleMarshallingEncoderTest{
+public class SerialMarshallingEncoderTest extends SerialCompatibleMarshallingEncoderTest {
 
     @Override
     protected ByteBuf truncate(ByteBuf buf) {

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialThreadLocalCompatibleMarshallingDecoderTest.java
Patch:
@@ -20,7 +20,6 @@
 
 public class SerialThreadLocalCompatibleMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest {
 
-
     @Override
     protected UnmarshallerProvider createProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         return new ThreadLocalUnmarshallerProvider(factory, config);

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialThreadLocalMarshallingDecoderTest.java
Patch:
@@ -20,7 +20,6 @@
 
 public class SerialThreadLocalMarshallingDecoderTest extends SerialMarshallingDecoderTest {
 
-
     @Override
     protected UnmarshallerProvider createProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         return new ThreadLocalUnmarshallerProvider(factory, config);

File: common/src/test/java/io/netty/util/UniqueNameTest.java
Patch:
@@ -47,12 +47,12 @@ public void initializeTest() {
         names = PlatformDependent.newConcurrentHashMap();
     }
 
-    @Test(expected=NullPointerException.class)
+    @Test(expected = NullPointerException.class)
     public void testCannnotProvideNullMap() {
         new UniqueName(null, "Nothing");
     }
 
-    @Test(expected=NullPointerException.class)
+    @Test(expected = NullPointerException.class)
     public void testCannotProvideNullName() {
         new UniqueName(names, null);
     }

File: common/src/test/java/io/netty/util/internal/StringUtilTest.java
Patch:
@@ -20,7 +20,7 @@
 import static org.junit.Assert.*;
 
 public class StringUtilTest {
-    
+
     @Test
     public void ensureNewlineExists() {
         assertNotNull(StringUtil.NEWLINE);

File: common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java
Patch:
@@ -77,7 +77,7 @@ public static class TypeX<A, B, C> {
 
     public static class TypeY<D extends C, E extends A, F extends B> extends TypeX<E, F, D> { }
 
-    public static abstract class TypeZ<G extends AA, H extends BB> extends TypeY<CC, G, H> { }
+    public abstract static class TypeZ<G extends AA, H extends BB> extends TypeY<CC, G, H> { }
 
     public static class TypeQ<I extends BBB> extends TypeZ<AAA, I> { }
 

File: microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java
Patch:
@@ -33,7 +33,7 @@ public class ByteBufAllocatorBenchmark extends DefaultBenchmark {
     private static final ByteBufAllocator POOLED_ALLOCATOR_HEAP = new PooledByteBufAllocator(false);
     private static final ByteBufAllocator POOLED_ALLOCATOR_DIRECT = new PooledByteBufAllocator(true);
 
-    @Param({"0", "256", "1024", "4096", "16384", "65536"})
+    @Param({ "0", "256", "1024", "4096", "16384", "65536" })
     private int size;
 
     @Param

File: microbench/src/test/java/io/netty/microbench/util/DefaultBenchmark.java
Patch:
@@ -118,7 +118,8 @@ private boolean deleteOldReports(File reportDir) {
                         deleted = true;
                         System.out.println();
                     }
-                    System.out.println(" Deleted old report: " + name.substring(prefix.length(), name.length() - suffix.length()));
+                    System.out.println(" Deleted old report: " +
+                            name.substring(prefix.length(), name.length() - suffix.length()));
                 }
             }
         }

File: testsuite-osgi/testsuite-osgi-deps/src/test/java/io/netty/verify/osgi/DependencyIT.java
Patch:
@@ -49,7 +49,5 @@ public void verifyKarafFeatureHasNoWrapProtocol() throws Exception {
         } else {
             System.out.println("all transitive dependencies are osgi bundles");
         }
-
     }
-
 }

File: testsuite-osgi/testsuite-osgi-exam/src/test/java/io/netty/verify/osgi/UnitHelp.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * Unit Test Utilities.
  */
-public class UnitHelp {
+public final class UnitHelp {
 
     private UnitHelp() {
     }
@@ -106,7 +106,6 @@ public static Option[] config() {
 
                 /** install java unit bundles */
                 junitBundles());
-
     }
 
     /**

File: testsuite/src/test/java/io/netty/testsuite/transport/sctp/AbstractSctpTest.java
Patch:
@@ -45,7 +45,7 @@ public abstract class AbstractSctpTest {
     protected volatile Bootstrap cb;
     protected volatile InetSocketAddress addr;
     protected volatile Factory<Bootstrap> currentBootstrap;
-    
+
     protected void run() throws Throwable {
         int i = 0;
         for (Entry<Factory<ServerBootstrap>, Factory<Bootstrap>> e: COMBO) {

File: testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
Patch:
@@ -41,7 +41,7 @@
 public class SctpEchoTest extends AbstractSctpTest {
 
     private static final Random random = new Random();
-    static final byte[] data = new byte[4096];//could not test ultra jumbo frames
+    static final byte[] data = new byte[4096]; //could not test ultra jumbo frames
 
     static {
         random.nextBytes(data);
@@ -95,7 +95,7 @@ public void initChannel(SctpChannel c) throws Exception {
         Channel sc = sb.bind().sync().channel();
         Channel cc = cb.connect().sync().channel();
 
-        for (int i = 0; i < data.length; ) {
+        for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);
             cc.write(Unpooled.wrappedBuffer(data, i, length));
             i += length;

File: testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpTestPermutation.java
Patch:
@@ -117,8 +117,7 @@ public Factory<Bootstrap> setValue(Factory<Bootstrap> value) {
         return list;
     }
 
-
-    private SctpTestPermutation() {}
+    private SctpTestPermutation() { }
 
     interface Factory<T> {
         T newInstance();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java
Patch:
@@ -45,8 +45,7 @@ protected void run() throws Throwable {
         int i = 0;
         for (Factory<Bootstrap> e: COMBO) {
             cb = e.newInstance();
-            addr = new InetSocketAddress(
-                    NetUtil.LOCALHOST, TestUtils.getFreePort());
+            addr = new InetSocketAddress(NetUtil.LOCALHOST, TestUtils.getFreePort());
             cb.remoteAddress(addr);
 
             logger.info(String.format(

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java
Patch:
@@ -45,7 +45,7 @@ public abstract class AbstractSocketTest {
     protected volatile Bootstrap cb;
     protected volatile InetSocketAddress addr;
     protected volatile Factory<Bootstrap> currentBootstrap;
-    
+
     protected void run() throws Throwable {
         int i = 0;
         for (Entry<Factory<ServerBootstrap>, Factory<Bootstrap>> e: COMBO) {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -92,7 +92,6 @@ public void messageReceived(
 
         sc.close().awaitUninterruptibly();
         cc.close().awaitUninterruptibly();
-
     }
 
     private static final class MulticastTestHandler extends ChannelInboundMessageHandlerAdapter<DatagramPacket> {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
Patch:
@@ -68,7 +68,6 @@ public void testShutdownOutput(Bootstrap cb) throws Throwable {
             // If half-closed, the peer should be able to write something.
             s.getOutputStream().write(1);
             assertEquals(1, (int) h.queue.take());
-
         } finally {
             if (s != null) {
                 s.close();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -63,7 +63,6 @@ public void testSslEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         testSslEcho0(sb, cb, false);
     }
 
-
     @Test
     public void testSslEchoWithChunkHandler() throws Throwable {
         run();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
Patch:
@@ -200,7 +200,7 @@ public Bootstrap newInstance() {
         return list;
     }
 
-    private SocketTestPermutation() {}
+    private SocketTestPermutation() { }
 
     interface Factory<T> {
         T newInstance();

File: transport-udt/src/test/java/io/netty/test/udt/nio/AbstractUdtTest.java
Patch:
@@ -30,7 +30,7 @@ public abstract class AbstractUdtTest {
      * UDT test assumptions.
      */
     @BeforeClass
-    public static void assumeConditions(){
+    public static void assumeConditions() {
         assumeTrue(UnitHelp.canLoadAndInitClass("com.barchart.udt.SocketUDT"));
     }
 

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java
Patch:
@@ -82,7 +82,6 @@ public void basicEcho() throws Exception {
                     .meter().count());
 
             Thread.sleep(1000);
-
         }
 
         connectFuture1.channel().close().sync();
@@ -98,7 +97,6 @@ public void basicEcho() throws Exception {
 
         boot1.shutdown();
         boot2.shutdown();
-
     }
 
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java
Patch:
@@ -44,7 +44,6 @@ public class NioUdtMessageRendezvousChannelTest extends AbstractUdtTest {
     @Test
     public void metadata() throws Exception {
         assertEquals(BufType.MESSAGE, new NioUdtMessageRendezvousChannel().metadata().bufferType());
-
     }
 
     /**
@@ -87,7 +86,6 @@ public void basicEcho() throws Exception {
                     .meter().count());
 
             Thread.sleep(1000);
-
         }
 
         connectFuture1.channel().close().sync();
@@ -103,7 +101,6 @@ public void basicEcho() throws Exception {
 
         boot1.shutdown();
         boot2.shutdown();
-
     }
 
 }

File: transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtProviderTest.java
Patch:
@@ -38,7 +38,7 @@ public void provideFactory() {
         assertNotNull(NioUdtProvider.MESSAGE_ACCEPTOR.newChannel());
         assertNotNull(NioUdtProvider.MESSAGE_CONNECTOR.newChannel());
         assertNotNull(NioUdtProvider.MESSAGE_RENDEZVOUS.newChannel());
-        
+
         // acceptor types
         assertTrue(NioUdtProvider.BYTE_ACCEPTOR.newChannel() instanceof UdtServerChannel);
         assertTrue(NioUdtProvider.MESSAGE_ACCEPTOR.newChannel() instanceof UdtServerChannel);

File: transport-udt/src/test/java/io/netty/test/udt/util/BootHelp.java
Patch:
@@ -46,7 +46,6 @@ public static Bootstrap bytePeerBoot(final InetSocketAddress self,
                 .localAddress(self).remoteAddress(peer).handler(handler);
 
         return boot;
-
     }
 
     /**
@@ -67,7 +66,6 @@ public static Bootstrap messagePeerBoot(final InetSocketAddress self,
                 .localAddress(self).remoteAddress(peer).handler(handler);
 
         return boot;
-
     }
 
     private BootHelp() { }

File: transport-udt/src/test/java/io/netty/test/udt/util/CaliperBench.java
Patch:
@@ -94,7 +94,6 @@ protected void markWait(final long time) throws Exception {
                 continue;
             }
         }
-
     }
 
 }

File: transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java
Patch:
@@ -50,7 +50,7 @@
  */
 public final class CaliperRunner {
 
-    private final static InternalLogger log = InternalLoggerFactory.getInstance(CaliperRunner.class);
+    private static final InternalLogger log = InternalLoggerFactory.getInstance(CaliperRunner.class);
 
     private CaliperRunner() {
     }

File: transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java
Patch:
@@ -44,16 +44,16 @@ public final class UnitHelp {
      * Verify class loading with class initialization.
      */
     public static boolean canLoadAndInitClass(String name) {
-        try{
+        try {
             Class.forName(name, true, UnitHelp.class.getClassLoader());
             log.info("Class load and init success.");
             return true;
-        } catch(Throwable e){
+        } catch (Throwable e) {
             log.warn("Class load or init failure.", e);
             return false;
         }
     }
-    
+
     /**
      * Zero out buffer.
      */

File: transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java
Patch:
@@ -48,7 +48,6 @@ public void initChannel(SocketChannel ch) throws Exception {
                     public void initChannel(ServerSocketChannel ch) throws Exception {
                         ch.pipeline().addLast(new TestChannelHandler());
                         ch.pipeline().addLast(eventExecutorGroup, new TestChannelHandler2());
-
                     }
                 })
                 .bind(0).awaitUninterruptibly();

File: transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
Patch:
@@ -25,7 +25,6 @@
 
 public class DefaultChannnelGroupTest {
 
-
     // Test for #1183
     @Test
     public void testNotThrowBlockingOperationException() {

File: transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
Patch:
@@ -57,7 +57,6 @@ public void initChannel(LocalChannel ch) throws Exception {
                   }
               });
 
-
             // Start server
             Channel sc = sb.bind(addr).sync().channel();
 

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -319,7 +319,6 @@ public void run() {
             }
 
             ch.close().sync();
-
         } finally {
             l.shutdown();
             e1.shutdown();

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
Patch:
@@ -110,7 +110,6 @@ public void run() {
 
         // Wait until the connection is closed or the connection attempt fails.
         localChannel.closeFuture().awaitUninterruptibly();
-
     }
 
     @Sharable
@@ -123,7 +122,6 @@ static class LocalHander extends ChannelInboundMessageHandlerAdapter<Object> {
 
         public LocalHander(String name) {
             this.name = name;
-
         }
 
         @Override

File: buffer/src/main/java/io/netty/buffer/BufType.java
Patch:
@@ -20,7 +20,7 @@
  */
 public enum BufType {
     /**
-     * Operates one bytes.
+     * Operates on bytes.
      */
     BYTE,
 

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -64,7 +64,7 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
     // 'bridge' so that the two handlers access each other's buffer only via the bridges.
     // The content written into a bridge is flushed into the actual buffer by flushBridge().
     //
-    // Note we use an AtomicReferenceFieldUpdater for atomic operations on these to safe memory. This will safe us
+    // Note we use an AtomicReferenceFieldUpdater for atomic operations on these to save memory. This will save us
     // 64 bytes per Bridge.
     @SuppressWarnings("UnusedDeclaration")
     private volatile MessageBridge inMsgBridge;

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -214,7 +214,7 @@
  *
  * If a {@link ByteBuf} can be converted into an NIO {@link ByteBuffer} which shares its
  * content (i.e. view buffer), you can get it via the {@link #nioBuffer()} method.  To determine
- * if a buffer can be converted into an NIO buffer, use {@link #nioBuffer()}.
+ * if a buffer can be converted into an NIO buffer, use {@link #nioBufferCount()}.
  *
  * <h4>Strings</h4>
  *

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -208,7 +208,7 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
                 if (newWindowSize < 0) {
                     while (spdyDataFrame.data().readableBytes() > initialReceiveWindowSize) {
                         SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamID,
-                                spdyDataFrame.data().readSlice(initialReceiveWindowSize));
+                                spdyDataFrame.data().readSlice(initialReceiveWindowSize).retain());
                         ctx.nextOutboundMessageBuffer().add(partialDataFrame);
                         ctx.flush();
                     }
@@ -525,7 +525,7 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg)
 
                         // Create a partial data frame whose length is the current window size
                         SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamID,
-                                spdyDataFrame.data().readSlice(sendWindowSize));
+                                spdyDataFrame.data().readSlice(sendWindowSize).retain());
 
                         // Enqueue the remaining data (will be the first frame queued)
                         spdySession.putPendingWrite(streamID, spdyDataFrame);
@@ -849,7 +849,7 @@ private void updateSendWindowSize(ChannelHandlerContext ctx, final int streamID,
 
                     // Create a partial data frame whose length is the current window size
                     SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamID,
-                            spdyDataFrame.data().readSlice(newWindowSize));
+                            spdyDataFrame.data().readSlice(newWindowSize).retain());
 
                     // The transfer window size is pre-decremented when sending a data frame downstream.
                     // Close the stream on write failures that leaves the transfer window in a corrupt state.

File: buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Read-only ByteBuf which wraps a read-only direct ByteBuffer and use unsafe for best performance.
  */
-final class ReadOnlyUnsafeDirectByteBuf extends ReadOnlyDirectByteBuf {
+final class ReadOnlyUnsafeDirectByteBuf extends ReadOnlyByteBufferBuf {
     private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
     private final long memoryAddress;
 

File: buffer/src/test/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBufferBufTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import static org.junit.Assume.assumeTrue;
 
-public class ReadOnlyUnsafeDirectByteBufTest extends ReadOnlyDirectByteBufTest {
+public class ReadOnlyUnsafeDirectByteBufferBufTest extends ReadOnlyDirectByteBufferBufTest {
 
     /**
      * Needs unsafe to run

File: buffer/src/main/java/io/netty/buffer/ReadOnlyDirectByteBuf.java
Patch:
@@ -40,8 +40,9 @@ class ReadOnlyDirectByteBuf extends AbstractReferenceCountedByteBuf {
     public ReadOnlyDirectByteBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
         super(buffer.remaining());
         if (!buffer.isDirect()) {
-            throw new IllegalArgumentException("buffer must be readOnly");
+            throw new IllegalArgumentException("must be a direct buffer: " + buffer.getClass().getSimpleName());
         }
+
         this.allocator = allocator;
         this.buffer = buffer.slice().order(ByteOrder.BIG_ENDIAN);
         writerIndex(buffer.limit());

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -121,9 +121,9 @@ public void testComponentAtOffset() {
     public void testDiscardReadBytes3() {
         ByteBuf a, b;
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order);
-        b = wrappedBuffer(
+        b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 0, 5).order(order),
-                wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 5, 5).order(order));
+                wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 5, 5).order(order)));
         a.skipBytes(6);
         a.markReaderIndex();
         b.skipBytes(6);

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -43,7 +43,7 @@
  * Abstract base class for {@link EventExecutor}'s that execute all its submitted tasks in a single thread.
  *
  */
-public abstract class SingleThreadEventExecutor extends AbstractEventExecutorWithoutScheduler {
+public abstract class SingleThreadEventExecutor extends AbstractEventExecutor {
 
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(SingleThreadEventExecutor.class);

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
Patch:
@@ -20,15 +20,15 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
-import io.netty.util.concurrent.AbstractEventExecutorWithoutScheduler;
+import io.netty.util.concurrent.AbstractEventExecutor;
 
 import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.TimeUnit;
 
-final class EmbeddedEventLoop extends AbstractEventExecutorWithoutScheduler implements EventLoop {
+final class EmbeddedEventLoop extends AbstractEventExecutor implements EventLoop {
 
     private final Queue<Runnable> tasks = new ArrayDeque<Runnable>(2);
 

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.FileRegion;
 import io.netty.channel.ServerChannel;
-import io.netty.util.concurrent.AbstractEventExecutorWithoutScheduler;
+import io.netty.util.concurrent.AbstractEventExecutor;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.internal.PlatformDependent;
@@ -313,7 +313,7 @@ public String toString() {
                "(name: " + name() + ", size: " + size() + ')';
     }
 
-    static final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {
+    static final class ImmediateEventExecutor extends AbstractEventExecutor {
 
         @Override
         public EventExecutorGroup parent() {

File: transport/src/main/java/io/netty/channel/group/ImmediateEventExecutor.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel.group;
 
-import io.netty.util.concurrent.AbstractEventExecutorWithoutScheduler;
+import io.netty.util.concurrent.AbstractEventExecutor;
 import io.netty.util.concurrent.DefaultPromise;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
@@ -25,7 +25,7 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {
+final class ImmediateEventExecutor extends AbstractEventExecutor {
 
     @Override
     public EventExecutorGroup parent() {

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
Patch:
@@ -176,7 +176,7 @@ public void testAutoConsolidation() {
 
     @Test
     public void testFullConsolidation() {
-        CompositeByteBuf buf = compositeBuffer(Integer.MAX_VALUE);
+        CompositeByteBuf buf = freeLater(compositeBuffer(Integer.MAX_VALUE));
         buf.addComponent(wrappedBuffer(new byte[] { 1 }));
         buf.addComponent(wrappedBuffer(new byte[] { 2, 3 }));
         buf.addComponent(wrappedBuffer(new byte[] { 4, 5, 6 }));

File: transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
Patch:
@@ -26,7 +26,7 @@ public class ThreadPerChannelEventLoop extends SingleThreadEventLoop {
     private Channel ch;
 
     public ThreadPerChannelEventLoop(ThreadPerChannelEventLoopGroup parent) {
-        super(parent, parent.threadFactory, parent.scheduler);
+        super(parent, parent.threadFactory);
         this.parent = parent;
     }
 

File: transport/src/main/java/io/netty/channel/aio/AioEventLoop.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelPromise;
-import io.netty.util.concurrent.TaskScheduler;
 import io.netty.channel.SingleThreadEventLoop;
 
 import java.util.ArrayList;
@@ -59,8 +58,8 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
     };
 
-    AioEventLoop(AioEventLoopGroup parent, ThreadFactory threadFactory, TaskScheduler scheduler) {
-        super(parent, threadFactory, scheduler);
+    AioEventLoop(AioEventLoopGroup parent, ThreadFactory threadFactory) {
+        super(parent, threadFactory);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.Channel;
 import io.netty.channel.MultithreadEventLoopGroup;
 import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.concurrent.TaskScheduler;
 
 import java.nio.channels.Selector;
 import java.nio.channels.spi.SelectorProvider;
@@ -84,7 +83,7 @@ public void rebuildSelectors() {
 
     @Override
     protected EventExecutor newChild(
-            ThreadFactory threadFactory, TaskScheduler scheduler, Object... args) throws Exception {
-        return new NioEventLoop(this, threadFactory, scheduler, (SelectorProvider) args[0]);
+            ThreadFactory threadFactory, Object... args) throws Exception {
+        return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0]);
     }
 }

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -99,7 +99,9 @@ public void operationComplete(ChannelFuture future) throws Exception {
         return promise;
     }
 
-    private static void doBind0(ChannelFuture initFuture, Channel channel, SocketAddress localAddress, ChannelPromise promise) {
+    private static void doBind0(
+            ChannelFuture initFuture, Channel channel, SocketAddress localAddress, ChannelPromise promise) {
+
         if (initFuture.isSuccess()) {
             channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
         } else {

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -510,7 +510,6 @@ private static final class ConnectHandler extends AioCompletionHandler<Void, Aio
         @Override
         protected void completed0(Void result, AioSocketChannel channel) {
             ((DefaultAioUnsafe) channel.unsafe()).connectSuccess();
-            channel.pipeline().fireChannelActive();
         }
 
         @Override

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -313,10 +313,8 @@ public void connect(final SocketAddress remoteAddress,
 
                 Channel boundChannel = LocalChannelRegistry.get(remoteAddress);
                 if (!(boundChannel instanceof LocalServerChannel)) {
-                    Exception cause =
-                            new ChannelException("connection refused");
+                    Exception cause = new ChannelException("connection refused");
                     promise.setFailure(cause);
-                    pipeline().fireExceptionCaught(cause);
                     close(voidFuture());
                     return;
                 }

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -568,7 +568,9 @@ public final void register(EventLoop eventLoop, final ChannelPromise promise) {
                 return;
             }
             if (!isCompatible(eventLoop)) {
-                promise.setFailure(new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
+                promise.setFailure(
+                        new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
+                return;
             }
 
             AbstractChannel.this.eventLoop = eventLoop;

File: common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
Patch:
@@ -488,7 +488,8 @@ public void run() {
                         if (listeners instanceof DefaultPromiseListeners) {
                             notifyListeners0(DefaultPromise.this, (DefaultPromiseListeners) listeners);
                         } else {
-                            notifyListener0(DefaultPromise.this, (GenericFutureListener<? extends Future<V>>) listeners);
+                            notifyListener0(
+                                    DefaultPromise.this, (GenericFutureListener<? extends Future<V>>) listeners);
                         }
                     }
                 });

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -313,7 +313,7 @@ public String toString() {
                "(name: " + name() + ", size: " + size() + ')';
     }
 
-    private static final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {
+    static final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {
 
         @Override
         public EventExecutorGroup parent() {

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
Patch:
@@ -73,7 +73,7 @@ public void messageReceived(final ChannelHandlerContext ctx,
         final ByteBuf byteBuf = message.data();
         meter.mark(byteBuf.readableBytes());
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message);
+        out.add(message.retain());
         ctx.flush();
     }
 

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
Patch:
@@ -50,7 +50,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
     public void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message);
+        out.add(message.retain());
         ctx.flush();
     }
 }

File: example/src/main/java/io/netty/example/udt/echo/rendevous/MsgEchoPeerHandler.java
Patch:
@@ -73,7 +73,7 @@ public void messageReceived(final ChannelHandlerContext ctx,
         final ByteBuf byteBuf = message.data();
         meter.mark(byteBuf.readableBytes());
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message);
+        out.add(message.retain());
         ctx.flush();
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
Patch:
@@ -67,7 +67,7 @@ public void setContent(InputStream inputStream) throws IOException {
         int read = inputStream.read(bytes);
         int written = 0;
         while (read > 0) {
-            buffer.writeBytes(bytes);
+            buffer.writeBytes(bytes, 0, read);
             written += read;
             read = inputStream.read(bytes);
         }

File: codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * A Codec for on-the-fly encoding/decoding of bytes.
  *
- * This can be though of an combination of {@link ByteToByteDecoder} and {@link ByteToByteEncoder}.
+ * This can be thought of as a combination of {@link ByteToByteDecoder} and {@link ByteToByteEncoder}.
  *
  * Here is an example of a {@link ByteToByteCodec} which just square {@link Integer} read from a {@link ByteBuf}.
  * <pre>

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * A Codec for on-the-fly encoding/decoding of message.
  *
- * This can be though of an combination of {@link MessageToMessageDecoder} and {@link MessageToMessageEncoder}.
+ * This can be thought of as a combination of {@link MessageToMessageDecoder} and {@link MessageToMessageEncoder}.
  *
  * Here is an example of a {@link MessageToMessageCodec} which just decode from {@link Integer} to {@link Long}
  * and encode from {@link Long} to {@link Integer}.

File: buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
Patch:
@@ -46,7 +46,7 @@ public abstract class AbstractByteBufTest {
 
     private static final Queue<ByteBuf> freeLaterQueue = new ArrayDeque<ByteBuf>();
 
-    protected ByteBuf freeLater(ByteBuf buf) {
+    protected static <T extends ByteBuf> T freeLater(T buf) {
         freeLaterQueue.add(buf);
         return buf;
     }

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -26,8 +26,8 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
-import io.netty.util.concurrent.SingleThreadEventExecutor;
 import io.netty.channel.SingleThreadEventLoop;
+import io.netty.util.concurrent.SingleThreadEventExecutor;
 
 import java.net.SocketAddress;
 import java.nio.channels.AlreadyConnectedException;
@@ -201,11 +201,12 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected void doDeregister() throws Exception {
+    protected Runnable doDeregister() throws Exception {
         if (isOpen()) {
             unsafe().close(unsafe().voidFuture());
         }
         ((SingleThreadEventExecutor) eventLoop()).removeShutdownHook(shutdownHook);
+        return null;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
Patch:
@@ -22,8 +22,8 @@
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
 import io.netty.channel.ServerChannel;
-import io.netty.util.concurrent.SingleThreadEventExecutor;
 import io.netty.channel.SingleThreadEventLoop;
+import io.netty.util.concurrent.SingleThreadEventExecutor;
 
 import java.net.SocketAddress;
 
@@ -126,8 +126,9 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected void doDeregister() throws Exception {
+    protected Runnable doDeregister() throws Exception {
         ((SingleThreadEventExecutor) eventLoop()).removeShutdownHook(shutdownHook);
+        return null;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
Patch:
@@ -273,8 +273,9 @@ protected Runnable doRegister() throws Exception {
     }
 
     @Override
-    protected void doDeregister() throws Exception {
+    protected Runnable doDeregister() throws Exception {
         eventLoop().cancel(selectionKey());
+        return null;
     }
 
     @Override

File: common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
Patch:
@@ -282,7 +282,7 @@ protected boolean runAllTasks(long timeoutNanos) {
 
             // Check timeout every 64 tasks because System.nanoTime() is relatively expensive.
             // XXX: Hard-coded value - will make it configurable if it is really a problem.
-            if ((runTasks & 0x40) == 0) {
+            if ((runTasks & 0x3F) == 0) {
                 if (System.nanoTime() >= deadline) {
                     break;
                 }

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -331,7 +331,7 @@ public ByteBuf order(ByteOrder endianness) {
         if (endianness == null) {
             throw new NullPointerException("endianness");
         }
-        if (endianness == order() || capacity() == 0) {
+        if (endianness == order()) {
             return this;
         }
 

File: codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
Patch:
@@ -69,7 +69,7 @@ protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promi
                     cause = new EncoderException(t);
                 }
                 if (encoded) {
-                    cause = new IncompleteFlushException("Unable to encoded all bytes", cause);
+                    cause = new IncompleteFlushException("unable to encode all bytes", cause);
                 }
                 in.discardSomeReadBytes();
                 promise.setFailure(cause);

File: transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
+import io.netty.channel.ThreadPerChannelEventLoop;
 
 import java.net.ConnectException;
 import java.net.SocketAddress;
@@ -91,7 +92,7 @@ public void run() {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof OioEventLoop;
+        return loop instanceof ThreadPerChannelEventLoop;
     }
 
     @Override

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
Patch:
@@ -37,7 +37,7 @@ public void testRequestWithBadInitialLine() throws Exception {
         HttpRequest req = (HttpRequest) ch.readInbound();
         DecoderResult dr = req.getDecoderResult();
         assertFalse(dr.isSuccess());
-        assertFalse(dr.isFailure());
+        assertTrue(dr.isFailure());
         ensureInboundTrafficDiscarded(ch);
     }
 
@@ -64,7 +64,7 @@ public void testResponseWithBadInitialLine() throws Exception {
         HttpResponse res = (HttpResponse) ch.readInbound();
         DecoderResult dr = res.getDecoderResult();
         assertFalse(dr.isSuccess());
-        assertFalse(dr.isFailure());
+        assertTrue(dr.isFailure());
         ensureInboundTrafficDiscarded(ch);
     }
 
@@ -97,7 +97,7 @@ public void testBadChunk() throws Exception {
         HttpContent chunk = (HttpContent) ch.readInbound();
         DecoderResult dr = chunk.getDecoderResult();
         assertFalse(dr.isSuccess());
-        assertFalse(dr.isFailure());
+        assertTrue(dr.isFailure());
         ensureInboundTrafficDiscarded(ch);
     }
 

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.bytes;
 
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.embedded.EmbeddedMessageChannel;
 import org.junit.Before;
@@ -35,7 +34,7 @@ public class ByteArrayEncoderTest {
 
     @Before
     public void setUp() {
-        ch = new EmbeddedMessageChannel(new ByteArrayEncoder(BufType.MESSAGE));
+        ch = new EmbeddedMessageChannel(new ByteArrayEncoder());
     }
 
     @Test

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
@@ -308,7 +309,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                     });
                 }
             } else {
-                ctx.nextOutboundMessageBuffer().add(currentEvent);
+                ChannelHandlerUtil.addToNextOutboundBuffer(ctx, currentEvent);
                 this.currentEvent = null;
             }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -99,6 +99,7 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
     private Runnable fireInboundBufferUpdated0Task;
     private Runnable invokeChannelReadSuspendedTask;
     private Runnable invokeRead0Task;
+    private boolean freed;
     boolean removed;
 
     @SuppressWarnings("unchecked")
@@ -350,9 +351,10 @@ private boolean flushOutboundBridge() {
     }
 
     void freeHandlerBuffersAfterRemoval() {
-        if (!removed) {
+        if (!removed || freed) {
             return;
         }
+        freed = true;
         final ChannelHandler handler = handler();
 
         if (handler instanceof ChannelInboundHandler) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelInboundMessageHandler;
 import io.netty.channel.ChannelPipeline;
@@ -63,7 +64,7 @@ protected SpdyOrHttpChooser(int maxSpdyContentLength, int maxHttpContentLength)
 
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 
 /**
  * A decoder that splits the received {@link ByteBuf}s by the fixed number
@@ -67,7 +68,7 @@ public FixedLengthFrameDecoder(int frameLength, boolean allocateFullBuffer) {
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
         if (allocateFullBuffer) {
-            return ctx.alloc().ioBuffer(frameLength);
+            return ChannelHandlerUtil.allocate(ctx, frameLength);
         } else {
             return super.newInboundBuffer(ctx);
         }

File: example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.udt.nio.NioUdtProvider;
@@ -76,7 +77,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     @Override
     public ByteBuf newInboundBuffer(final ChannelHandlerContext ctx)
             throws Exception {
-        return ctx.alloc().ioBuffer(
+        return ChannelHandlerUtil.allocate(ctx,
                 ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
     }
 

File: example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.udt.nio.NioUdtProvider;
@@ -57,7 +58,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
     @Override
     public ByteBuf newInboundBuffer(final ChannelHandlerContext ctx)
             throws Exception {
-        return ctx.alloc().ioBuffer(
+        return ChannelHandlerUtil.allocate(ctx,
                 ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
     }
 

File: handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelOutboundByteHandler;
 import io.netty.channel.ChannelPromise;
@@ -108,7 +109,7 @@ public ByteLoggingHandler(String name) {
 
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override
@@ -123,7 +124,7 @@ public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelOutboundByteHandler;
 import io.netty.channel.ChannelPipeline;
@@ -380,7 +381,7 @@ public ChannelFuture sslCloseFuture() {
 
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override
@@ -395,7 +396,7 @@ public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.sctp.SctpChannel;
@@ -160,7 +161,7 @@ private static class EchoHandler extends ChannelInboundByteHandlerAdapter {
 
         @Override
         public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ctx.alloc().ioBuffer(0, maxInboundBufferSize);
+            return ChannelHandlerUtil.allocate(ctx, 0, maxInboundBufferSize);
         }
 
         @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -21,6 +21,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.socket.SocketChannel;
@@ -186,7 +187,7 @@ private static class EchoHandler extends ChannelInboundByteHandlerAdapter {
 
         @Override
         public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ctx.alloc().ioBuffer(0, maxInboundBufferSize);
+            return ChannelHandlerUtil.allocate(ctx, 0, maxInboundBufferSize);
         }
 
         @Override

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
Patch:
@@ -269,4 +269,7 @@ public static Paritybit valueOf(int value) {
 
     @Override
     RxtxChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    RxtxChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
Patch:
@@ -107,4 +107,7 @@ public interface SctpChannelConfig extends ChannelConfig {
 
     @Override
     SctpChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    SctpChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
Patch:
@@ -102,4 +102,7 @@ public interface SctpServerChannelConfig extends ChannelConfig {
 
     @Override
     SctpServerChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    SctpServerChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
Patch:
@@ -162,4 +162,6 @@ public interface UdtChannelConfig extends ChannelConfig {
      */
     UdtChannelConfig setSystemSendBufferSize(int size);
 
+    @Override
+    UdtChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
Patch:
@@ -80,4 +80,6 @@ public interface UdtServerChannelConfig extends UdtChannelConfig {
     @Override
     UdtServerChannelConfig setSystemSendBufferSize(int size);
 
+    @Override
+    UdtServerChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport-udt/src/test/java/io/netty/test/udt/util/EchoByteHandler.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.udt.nio.NioUdtProvider;
@@ -97,7 +98,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
 
     @Override
     public ByteBuf newInboundBuffer(final ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer(
+        return ChannelHandlerUtil.allocate(ctx,
                 ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
     }
 }

File: transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java
Patch:
@@ -33,7 +33,7 @@ public abstract class ChannelInboundByteHandlerAdapter
      */
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -44,7 +44,8 @@ public class ChannelOption<T> extends UniqueName {
             new ChannelOption<Boolean>("ALLOW_HALF_CLOSURE");
     public static final ChannelOption<Boolean> AUTO_READ =
             new ChannelOption<Boolean>("AUTO_READ");
-
+    public static final ChannelOption<ChannelConfig.ChannelHandlerByteBufType> DEFAULT_HANDLER_BYTEBUF_TYPE =
+            new ChannelOption<ChannelConfig.ChannelHandlerByteBufType>("DEFAULT_HANDLER_BYTEBUF_TYPE");
     public static final ChannelOption<Boolean> SO_BROADCAST =
             new ChannelOption<Boolean>("SO_BROADCAST");
     public static final ChannelOption<Boolean> SO_KEEPALIVE =

File: transport/src/main/java/io/netty/channel/ChannelOutboundByteHandlerAdapter.java
Patch:
@@ -24,7 +24,7 @@ public abstract class ChannelOutboundByteHandlerAdapter
         extends ChannelOperationHandlerAdapter implements ChannelOutboundByteHandler {
     @Override
     public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ctx.alloc().ioBuffer();
+        return ChannelHandlerUtil.allocate(ctx);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
Patch:
@@ -179,4 +179,7 @@ public interface DatagramChannelConfig extends ChannelConfig {
 
     @Override
     DatagramChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    DatagramChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
Patch:
@@ -93,4 +93,7 @@ public interface ServerSocketChannelConfig extends ChannelConfig {
 
     @Override
     ServerSocketChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    ServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannelConfig.java
Patch:
@@ -111,4 +111,7 @@ public interface AioSocketChannelConfig extends SocketChannelConfig {
 
     @Override
     AioSocketChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    AioSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
Patch:
@@ -72,4 +72,7 @@ public interface OioServerSocketChannelConfig extends ServerSocketChannelConfig
 
     @Override
     OioServerSocketChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    OioServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
Patch:
@@ -87,4 +87,7 @@ public interface OioSocketChannelConfig extends SocketChannelConfig {
 
     @Override
     OioSocketChannelConfig setAutoRead(boolean autoRead);
+
+    @Override
+    OioSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelInboundMessageHandler;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -413,7 +414,7 @@ public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
 
         @Override
         public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ctx.alloc().ioBuffer();
+            return ChannelHandlerUtil.allocate(ctx);
         }
 
         @Override

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -835,7 +835,7 @@ public void run() {
     }
 
     private void invokeExceptionCaught0(Throwable cause) {
-        ChannelStateHandler handler = (ChannelStateHandler) handler();
+        ChannelHandler handler = handler();
         try {
             handler.exceptionCaught(this, cause);
         } catch (Throwable t) {

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -58,7 +58,6 @@ final class DefaultChannelPipeline implements ChannelPipeline {
         }
     }
 
-
     final Channel channel;
 
     final DefaultChannelHandlerContext head;

File: buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
Patch:
@@ -81,7 +81,7 @@ public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
         checkDstIndex(index, length, dstIndex, dst.capacity());
         if (dst.hasMemoryAddress()) {
             PlatformDependent.copyMemory(memory, idx(index), dst.memoryAddress() + dstIndex, length);
-        } if (dst.hasArray()) {
+        } else if (dst.hasArray()) {
             getBytes(index, dst.array(), dst.arrayOffset() + dstIndex, length);
         } else {
             dst.setBytes(dstIndex, memory, idx(index), length);

File: buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
Patch:
@@ -408,7 +408,8 @@ public ByteBuffer[] nioBuffers(int index, int length) {
     @Override
     public ByteBuf copy(int index, int length) {
         checkIndex(index, length);
-        UnpooledUnsafeDirectByteBuf copy = (UnpooledUnsafeDirectByteBuf) alloc().directBuffer(capacity(), maxCapacity());
+        UnpooledUnsafeDirectByteBuf copy =
+                (UnpooledUnsafeDirectByteBuf) alloc().directBuffer(capacity(), maxCapacity());
         if (length != 0) {
             PlatformDependent.copyMemory(addr(index), copy.addr(index), length);
             copy.setIndex(index, index + length);

File: buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
Patch:
@@ -51,7 +51,7 @@ final class UnpooledDirectByteBuf extends AbstractReferenceCountedByteBuf {
      * @param initialCapacity the initial capacity of the underlying direct buffer
      * @param maxCapacity     the maximum capacity of the underlying direct buffer
      */
-    public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
+    UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
         super(maxCapacity);
         if (alloc == null) {
             throw new NullPointerException("alloc");
@@ -76,7 +76,7 @@ public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int ma
      *
      * @param maxCapacity the maximum capacity of the underlying direct buffer
      */
-    public UnpooledDirectByteBuf(ByteBufAllocator alloc, ByteBuffer initialBuffer, int maxCapacity) {
+    UnpooledDirectByteBuf(ByteBufAllocator alloc, ByteBuffer initialBuffer, int maxCapacity) {
         super(maxCapacity);
         if (alloc == null) {
             throw new NullPointerException("alloc");

File: buffer/src/main/java/io/netty/buffer/PoolChunk.java
Patch:
@@ -214,7 +214,6 @@ private long allocateSubpageSimple(int normCapacity, int curIdx, int val) {
                 } else {
                     subpage.init(normCapacity);
                 }
-                arena.addSubpage(subpage);
                 return subpage.allocate();
             }
 

File: buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
Patch:
@@ -55,7 +55,7 @@ public ByteBuf capacity(int newCapacity) {
 
     @Override
     public ByteBufAllocator alloc() {
-        return UnpooledByteBufAllocator.HEAP_BY_DEFAULT;
+        return UnpooledByteBufAllocator.DEFAULT;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -75,7 +75,7 @@
  */
 public final class Unpooled {
 
-    private static final ByteBufAllocator ALLOC = UnpooledByteBufAllocator.HEAP_BY_DEFAULT;
+    private static final ByteBufAllocator ALLOC = UnpooledByteBufAllocator.DEFAULT;
 
     /**
      * Big endian byte order.

File: buffer/src/test/java/io/netty/buffer/BigEndianHeapByteBufTest.java
Patch:
@@ -45,6 +45,6 @@ public void shouldNotAllowNullInConstructor1() {
 
     @Test(expected = NullPointerException.class)
     public void shouldNotAllowNullInConstructor2() {
-        new UnpooledHeapByteBuf(UnpooledByteBufAllocator.HEAP_BY_DEFAULT, null, 0);
+        new UnpooledHeapByteBuf(UnpooledByteBufAllocator.DEFAULT, null, 0);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -28,7 +28,7 @@ public class HttpRequestEncoder extends HttpObjectEncoder<HttpRequest> {
     private static final char SLASH = '/';
 
     @Override
-    protected boolean acceptOutboundMessage(Object msg) throws Exception {
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
         return super.acceptOutboundMessage(msg) && !(msg instanceof HttpResponse);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
Patch:
@@ -27,7 +27,7 @@
 public class HttpResponseEncoder extends HttpObjectEncoder<HttpResponse> {
 
     @Override
-    protected boolean acceptOutboundMessage(Object msg) throws Exception {
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
         return super.acceptOutboundMessage(msg) && !(msg instanceof HttpRequest);
     }
 

File: codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
Patch:
@@ -41,7 +41,7 @@
 public abstract class MessageToByteEncoder<I> extends ChannelOutboundMessageHandlerAdapter<I> {
 
     @Override
-    protected void flush(ChannelHandlerContext ctx, I msg) throws Exception {
+    public void flush(ChannelHandlerContext ctx, I msg) throws Exception {
         try {
             encode(ctx, msg, ctx.nextOutboundByteBuffer());
         } catch (CodecException e) {

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -45,7 +45,7 @@
 public abstract class MessageToMessageDecoder<I> extends ChannelInboundMessageHandlerAdapter<I> {
 
     @Override
-    protected final void messageReceived(ChannelHandlerContext ctx, I msg) throws Exception {
+    public final void messageReceived(ChannelHandlerContext ctx, I msg) throws Exception {
         ctx.nextInboundMessageBuffer().unfoldAndAdd(decode(ctx, msg));
     }
 

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
Patch:
@@ -43,7 +43,7 @@
 public abstract class MessageToMessageEncoder<I> extends ChannelOutboundMessageHandlerAdapter<I> {
 
     @Override
-    protected final void flush(ChannelHandlerContext ctx, I msg) throws Exception {
+    public final void flush(ChannelHandlerContext ctx, I msg) throws Exception {
         try {
             ctx.nextOutboundMessageBuffer().unfoldAndAdd(encode(ctx, msg));
         } catch (CodecException e) {

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
Patch:
@@ -60,7 +60,7 @@ public ByteArrayEncoder(BufType nextBufferType) {
     }
 
     @Override
-    protected void flush(ChannelHandlerContext ctx, byte[] msg) throws Exception {
+    public void flush(ChannelHandlerContext ctx, byte[] msg) throws Exception {
         if (msg.length == 0) {
             return;
         }

File: codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
Patch:
@@ -76,7 +76,7 @@ public StringEncoder(BufType nextBufferType, Charset charset) {
     }
 
     @Override
-    protected void flush(ChannelHandlerContext ctx, CharSequence msg) throws Exception {
+    public void flush(ChannelHandlerContext ctx, CharSequence msg) throws Exception {
         ByteBuf encoded = Unpooled.copiedBuffer(msg, charset);
 
         switch (nextBufferType) {

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -190,7 +190,7 @@ private static void send100Continue(ChannelHandlerContext ctx) {
     }
 
     @Override
-    protected void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
+    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
         ctx.flush();
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -110,7 +110,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
     }
 
     @Override
-    protected void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
+    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
         if (handshaker != null) {
             ctx.flush().addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
         }

File: example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java
Patch:
@@ -26,7 +26,7 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    protected void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
         if ("OK".equals(msg)) {
             System.out.println("Serial port responded to AT");
         } else {

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
Patch:
@@ -68,7 +68,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     }
 
     @Override
-    protected void messageReceived(final ChannelHandlerContext ctx,
+    public void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
         final ByteBuf byteBuf = message.data();
         meter.mark(byteBuf.readableBytes());

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
Patch:
@@ -47,7 +47,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    protected void messageReceived(final ChannelHandlerContext ctx,
+    public void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
         out.add(message);

File: example/src/main/java/io/netty/example/udt/echo/rendevous/MsgEchoPeerHandler.java
Patch:
@@ -68,7 +68,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     }
 
     @Override
-    protected void messageReceived(final ChannelHandlerContext ctx,
+    public void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
         final ByteBuf byteBuf = message.data();
         meter.mark(byteBuf.readableBytes());

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -160,7 +160,7 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        protected void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
+        public void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
             if ("StartTlsResponse".equals(msg)) {
                 ctx.pipeline().addAfter("logger", "ssl", sslHandler);
                 handshakeFuture = sslHandler.handshake();
@@ -202,7 +202,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        protected void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
+        public void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
             if ("StartTlsRequest".equals(msg)) {
                 ctx.pipeline().addAfter("logger", "ssl", sslHandler);
                 ctx.write("StartTlsResponse\n");

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
Patch:
@@ -40,7 +40,7 @@ public SctpInboundByteStreamHandler(int protocolIdentifier, int streamIdentifier
     }
 
     @Override
-    protected final boolean acceptInboundMessage(Object msg) throws Exception {
+    public final boolean acceptInboundMessage(Object msg) throws Exception {
         if (super.acceptInboundMessage(msg)) {
             return acceptInboundMessage((SctpMessage) msg);
         }
@@ -52,7 +52,7 @@ protected boolean acceptInboundMessage(SctpMessage msg) {
     }
 
     @Override
-    protected void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
         if (!msg.isComplete()) {
             throw new CodecException(String.format("Received SctpMessage is not complete, please add %s in the " +
                     "pipeline before this handler", SctpMessageCompletionHandler.class.getSimpleName()));

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
Patch:
@@ -36,13 +36,13 @@ public class SctpMessageCompletionHandler extends ChannelInboundMessageHandlerAd
     private boolean assembled;
 
     @Override
-    protected boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception {
+    public boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception {
         assembled = false;
         return super.beginMessageReceived(ctx);
     }
 
     @Override
-    protected void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
+    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
         if (assembled) {
             assembled = false;
             ctx.fireInboundBufferUpdated();
@@ -51,7 +51,7 @@ protected void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    protected void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
 
         final ByteBuf byteBuf = msg.data();
         final int protocolIdentifier = msg.protocolIdentifier();

File: transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java
Patch:
@@ -75,7 +75,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable e)
     }
 
     @Override
-    protected void messageReceived(final ChannelHandlerContext ctx, final UdtMessage message) throws Exception {
+    public void messageReceived(final ChannelHandlerContext ctx, final UdtMessage message) throws Exception {
 
         final ByteBuf byteBuf = message.data();
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -166,7 +166,7 @@ static short getShort(long address) {
         if (UNALIGNED) {
             return UNSAFE.getShort(address);
         } else {
-            return (short)(getByte(address) << 8 | getByte(address + 1) & 0xff);
+            return (short) (getByte(address) << 8 | getByte(address + 1) & 0xff);
         }
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -92,7 +92,7 @@ public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exc
 
     @Override
     public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        ctx.inboundByteBuffer().release();
+         ctx.inboundMessageBuffer().release();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java
Patch:
@@ -475,7 +475,7 @@ public void execute(Runnable task) {
         }
     }
 
-    private static void reject() {
+    protected static void reject() {
         throw new RejectedExecutionException("event executor terminated");
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
Patch:
@@ -15,19 +15,19 @@
  */
 package io.netty.handler.codec.spdy;
 
+import io.netty.util.internal.PlatformDependent;
+
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 final class SpdySession {
 
-    private final Map<Integer, StreamState> activeStreams =
-        new ConcurrentHashMap<Integer, StreamState>();
+    private final Map<Integer, StreamState> activeStreams = PlatformDependent.newConcurrentHashMap();
 
     int numActiveStreams() {
         return activeStreams.size();

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
@@ -222,7 +221,7 @@ private static Set<HashedWheelTimeout>[] createWheel(int ticksPerWheel) {
         Set<HashedWheelTimeout>[] wheel = new Set[ticksPerWheel];
         for (int i = 0; i < wheel.length; i ++) {
             wheel[i] = Collections.newSetFromMap(
-                    new ConcurrentHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));
+                    PlatformDependent.<HashedWheelTimeout, Boolean>newConcurrentHashMap());
         }
         return wheel;
     }

File: common/src/main/java/io/netty/util/ResourceLeakDetector.java
Patch:
@@ -16,13 +16,13 @@
 
 package io.netty.util;
 
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.lang.ref.PhantomReference;
 import java.lang.ref.ReferenceQueue;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -51,7 +51,7 @@ public boolean close() {
     private final DefaultResourceLeak tail = new DefaultResourceLeak(null);
 
     private final ReferenceQueue<Object> refQueue = new ReferenceQueue<Object>();
-    private final ConcurrentMap<Exception, Boolean> reportedLeaks = new ConcurrentHashMap<Exception, Boolean>();
+    private final ConcurrentMap<Exception, Boolean> reportedLeaks = PlatformDependent.newConcurrentHashMap();
 
     private final String resourceType;
     private final int samplingInterval;

File: common/src/main/java/io/netty/util/Signal.java
Patch:
@@ -16,7 +16,8 @@
 package io.netty.util;
 
 
-import java.util.concurrent.ConcurrentHashMap;
+import io.netty.util.internal.PlatformDependent;
+
 import java.util.concurrent.ConcurrentMap;
 
 /**
@@ -27,8 +28,7 @@ public final class Signal extends Error {
 
     private static final long serialVersionUID = -221145131122459977L;
 
-    private static final ConcurrentMap<String, Boolean> map =
-            new ConcurrentHashMap<String, Boolean>();
+    private static final ConcurrentMap<String, Boolean> map = PlatformDependent.newConcurrentHashMap();
 
     private final UniqueName uname;
 

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -30,7 +30,6 @@
 import java.net.SocketAddress;
 import java.nio.channels.ClosedChannelException;
 import java.util.Random;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 /**
@@ -40,7 +39,7 @@ public abstract class AbstractChannel extends DefaultAttributeMap implements Cha
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannel.class);
 
-    static final ConcurrentMap<Integer, Channel> allChannels = new ConcurrentHashMap<Integer, Channel>();
+    static final ConcurrentMap<Integer, Channel> allChannels = PlatformDependent.newConcurrentHashMap();
 
     private static final Random random = new Random();
 

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -17,10 +17,10 @@
 
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.util.UniqueName;
+import io.netty.util.internal.PlatformDependent;
 
 import java.net.InetAddress;
 import java.net.NetworkInterface;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 /**
@@ -33,7 +33,7 @@
  */
 public class ChannelOption<T> extends UniqueName {
 
-    private static final ConcurrentMap<String, Boolean> names = new ConcurrentHashMap<String, Boolean>();
+    private static final ConcurrentMap<String, Boolean> names = PlatformDependent.newConcurrentHashMap();
 
     public static final ChannelOption<ByteBufAllocator> ALLOCATOR = new ChannelOption<ByteBufAllocator>("ALLOCATOR");
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS =

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -21,14 +21,14 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.FileRegion;
 import io.netty.channel.ServerChannel;
+import io.netty.util.internal.PlatformDependent;
 
 import java.util.AbstractSet;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -40,8 +40,8 @@ public class DefaultChannelGroup extends AbstractSet<Channel> implements Channel
     private static final AtomicInteger nextId = new AtomicInteger();
 
     private final String name;
-    private final ConcurrentMap<Integer, Channel> serverChannels = new ConcurrentHashMap<Integer, Channel>();
-    private final ConcurrentMap<Integer, Channel> nonServerChannels = new ConcurrentHashMap<Integer, Channel>();
+    private final ConcurrentMap<Integer, Channel> serverChannels = PlatformDependent.newConcurrentHashMap();
+    private final ConcurrentMap<Integer, Channel> nonServerChannels = PlatformDependent.newConcurrentHashMap();
     private final ChannelFutureListener remover = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {

File: transport/src/main/java/io/netty/channel/local/LocalChannelRegistry.java
Patch:
@@ -17,15 +17,14 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
+import io.netty.util.internal.PlatformDependent;
 
 import java.net.SocketAddress;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 final class LocalChannelRegistry {
 
-    private static final ConcurrentMap<LocalAddress, Channel> boundChannels =
-            new ConcurrentHashMap<LocalAddress, Channel>();
+    private static final ConcurrentMap<LocalAddress, Channel> boundChannels = PlatformDependent.newConcurrentHashMap();
 
     static LocalAddress register(
             Channel channel, LocalAddress oldLocalAddress, SocketAddress localAddress) {

File: transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
Patch:
@@ -23,11 +23,11 @@
 import io.netty.channel.ChannelTaskScheduler;
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
+import io.netty.util.internal.PlatformDependent;
 
 import java.util.Collections;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
@@ -44,7 +44,7 @@ public class OioEventLoopGroup implements EventLoopGroup {
     final ChannelTaskScheduler scheduler;
     final ThreadFactory threadFactory;
     final Set<OioEventLoop> activeChildren = Collections.newSetFromMap(
-            new ConcurrentHashMap<OioEventLoop, Boolean>());
+            PlatformDependent.<OioEventLoop, Boolean>newConcurrentHashMap());
     final Queue<OioEventLoop> idleChildren = new ConcurrentLinkedQueue<OioEventLoop>();
     private final ChannelException tooManyChannels;
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java
Patch:
@@ -21,13 +21,13 @@
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.socket.ServerSocketChannelConfig;
 import io.netty.util.NetUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
 import java.net.SocketOption;
 import java.net.StandardSocketOptions;
 import java.nio.channels.AsynchronousServerSocketChannel;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static io.netty.channel.ChannelOption.*;
@@ -40,7 +40,7 @@ final class AioServerSocketChannelConfig extends DefaultChannelConfig implements
     private final AtomicReference<AsynchronousServerSocketChannel> javaChannel
             = new AtomicReference<AsynchronousServerSocketChannel>();
     private volatile int backlog = NetUtil.SOMAXCONN;
-    private Map<SocketOption<?>, Object> options = new ConcurrentHashMap<SocketOption<?>, Object>();
+    private Map<SocketOption<?>, Object> options = PlatformDependent.newConcurrentHashMap();
     private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;
     private static final boolean DEFAULT_SO_REUSEADDR = false;
 

File: transport/src/main/java/io/netty/channel/socket/aio/DefaultAioSocketChannelConfig.java
Patch:
@@ -26,7 +26,6 @@
 import java.net.StandardSocketOptions;
 import java.nio.channels.NetworkChannel;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static io.netty.channel.ChannelOption.*;
@@ -41,7 +40,7 @@ final class DefaultAioSocketChannelConfig extends DefaultChannelConfig
     private volatile boolean allowHalfClosure;
     private volatile long readTimeoutInMillis;
     private volatile long writeTimeoutInMillis;
-    private Map<SocketOption<?>, Object> options = new ConcurrentHashMap<SocketOption<?>, Object>();
+    private Map<SocketOption<?>, Object> options = PlatformDependent.newConcurrentHashMap();
     private static final int DEFAULT_RCV_BUF_SIZE = 32 * 1024;
     private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;
     private static final int DEFAULT_SO_LINGER = -1;

File: transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
Patch:
@@ -200,7 +200,7 @@ private void notifyFlushFutures0(Throwable cause) {
 
         // Avoid overflow
         final long newWriteCounter = this.writeCounter;
-        if (newWriteCounter >= 0x1000000000000000L) {
+        if (newWriteCounter >= 0x8000000000L) {
             // Reset the counter only when the counter grew pretty large
             // so that we can reduce the cost of updating all entries in the notification list.
             this.writeCounter = 0;

File: example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
Patch:
@@ -57,6 +57,7 @@ public void messageReceived(ChannelHandlerContext ctx, SocksRequest socksRequest
                     ctx.pipeline().addLast(SocksServerConnectHandler.getName(), new SocksServerConnectHandler());
                     ctx.pipeline().remove(this);
                     ctx.nextInboundMessageBuffer().add(socksRequest);
+                    ctx.fireInboundBufferUpdated();
                 } else {
                     ctx.close();
                 }

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1555,11 +1555,11 @@ public boolean isWritable() {
         DefaultChannelHandlerContext ctx = prev;
         for (;;) {
             if (ctx.hasOutboundByteBuffer()) {
-                return ctx.outboundByteBuffer().isWritable();
+                return ctx.isWritable();
             }
 
             if (ctx.hasOutboundMessageBuffer()) {
-                return ctx.outboundMessageBuffer().isWritable();
+                return ctx.isWritable();
             }
             ctx = ctx.prev;
         }

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1559,11 +1559,11 @@ public boolean isWritable() {
         DefaultChannelHandlerContext ctx = prev;
         for (;;) {
             if (ctx.hasOutboundByteBuffer()) {
-                return ctx.isWritable();
+                return ctx.outboundByteBuffer().isWritable();
             }
 
             if (ctx.hasOutboundMessageBuffer()) {
-                return ctx.isWritable();
+                return ctx.outboundMessageBuffer().isWritable();
             }
             ctx = ctx.prev;
         }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
Patch:
@@ -34,7 +34,7 @@ public void initChannel(SocketChannel ch) throws Exception {
 
         p.addLast("decoder", new HttpRequestDecoder());
         // Uncomment the following line if you don't want to handle HttpChunks.
-        //pipeline.addLast("aggregator", new HttpObjectAggregator(1048576));
+        //p.addLast("aggregator", new HttpObjectAggregator(1048576));
         p.addLast("encoder", new HttpResponseEncoder());
         // Remove the following line if you don't want automatic content compression.
         //p.addLast("deflater", new HttpContentCompressor());

File: buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
Patch:
@@ -451,7 +451,7 @@ public CompositeByteBuf capacity(int newCapacity) {
             if (nComponents < maxNumComponents) {
                 padding = allocBuffer(paddingLength);
                 padding.setIndex(0, paddingLength);
-                addComponent0(0, padding);
+                addComponent0(components.size(), padding);
             } else {
                 padding = allocBuffer(paddingLength);
                 padding.setIndex(0, paddingLength);

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
Patch:
@@ -39,8 +39,6 @@ public HexDumpProxyFrontendHandler(String remoteHost, int remotePort) {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
-        // TODO: Suspend incoming traffic until connected to the remote host.
-        //       Currently, we just keep the inbound traffic in the client channel's outbound buffer.
         final Channel inboundChannel = ctx.channel();
 
         // Start the connection attempt.

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1315,7 +1315,7 @@ private void invokeFlush0(ChannelPromise promise) {
         }
 
         ChannelOperationHandler handler = (ChannelOperationHandler) handler();
-        if (handler instanceof ChannelInboundHandler) {
+        if (handler instanceof ChannelOutboundHandler) {
             flushOutboundBridge();
         }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1651,7 +1651,7 @@ private void fill() {
         }
 
         private void flush(ByteBuf out) {
-            while (out.isWritable()) {
+            while (out.maxCapacity() != out.writerIndex()) {
                 ByteBuf data = exchangeBuf.peek();
                 if (data == null) {
                     break;

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
Patch:
@@ -466,7 +466,9 @@ public ByteBuf readBytes(ByteBuf dst, int length) {
 
     @Override
     public ByteBuf readBytes(ByteBuf dst) {
-        throw new UnreplayableOperationException();
+        checkReadableBytes(dst.writableBytes());
+        buffer.readBytes(dst);
+        return this;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1295,7 +1295,7 @@ public void run() {
     private void invokeFlush0(ChannelPromise promise) {
         Channel channel = channel();
         if (!channel.isRegistered() && !channel.isActive()) {
-            promise.tryFailure(new ClosedChannelException());
+            promise.setFailure(new ClosedChannelException());
             return;
         }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
Patch:
@@ -378,7 +378,7 @@ public boolean tryFailure(Throwable cause) {
 
     private synchronized boolean failure0(Throwable cause) {
         // Allow only once.
-        if (cause != null) {
+        if (this.cause != null) {
             return false;
         }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1295,7 +1295,7 @@ public void run() {
     private void invokeFlush0(ChannelPromise promise) {
         Channel channel = channel();
         if (!channel.isRegistered() && !channel.isActive()) {
-            promise.setFailure(new ClosedChannelException());
+            promise.tryFailure(new ClosedChannelException());
             return;
         }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -637,7 +637,7 @@ private static void callBeforeRemove(ChannelHandlerContext ctx) {
         }
     }
 
-        private void callAfterRemove(final DefaultChannelHandlerContext ctx, boolean forward) {
+    private void callAfterRemove(final DefaultChannelHandlerContext ctx, boolean forward) {
         final ChannelHandler handler = ctx.handler();
 
         // Notify the complete removal.

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -101,7 +101,7 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
     private Runnable invokeFreeInboundBuffer0Task;
     private Runnable invokeFreeOutboundBuffer0Task;
     private Runnable invokeRead0Task;
-    volatile boolean removed;
+    boolean removed;
 
     @SuppressWarnings("unchecked")
     DefaultChannelHandlerContext(

File: buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java
Patch:
@@ -90,7 +90,7 @@ protected void deallocate() {
             } while (i != tail);
         }
 
-        elements = null;
+        elements =  cast(new Object[2]);
         this.head = 0;
         this.tail = 0;
     }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
Patch:
@@ -34,7 +34,7 @@ public void initChannel(SocketChannel ch) throws Exception {
 
         p.addLast("decoder", new HttpRequestDecoder());
         // Uncomment the following line if you don't want to handle HttpChunks.
-        //pipeline.addLast("aggregator", new HttpChunkAggregator(1048576));
+        //pipeline.addLast("aggregator", new HttpObjectAggregator(1048576));
         p.addLast("encoder", new HttpResponseEncoder());
         // Remove the following line if you don't want automatic content compression.
         //p.addLast("deflater", new HttpContentCompressor());

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
Patch:
@@ -170,11 +170,11 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                     if (validateChecksums) {
                         // TODO: Optimize me.
                         ByteBuf uncompressed = ctx.alloc().buffer();
-                        snappy.decode(in.readSlice(chunkLength - 4), uncompressed, chunkLength);
+                        snappy.decode(in.readSlice(chunkLength - 4), uncompressed);
                         validateChecksum(uncompressed, checksum);
                         out.writeBytes(uncompressed);
                     } else {
-                        snappy.decode(in.readSlice(chunkLength - 4), out, chunkLength);
+                        snappy.decode(in.readSlice(chunkLength - 4), out);
                     }
                     snappy.reset();
                     break;

File: codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import io.netty.util.CharsetUtil;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.Random;
@@ -37,7 +36,6 @@ public void testText() throws Exception {
     }
 
     @Test
-    @Ignore // FIXME: Make it pass.
     public void test1002() throws Exception {
         // Data from https://github.com/netty/netty/issues/1002
         testIdentity(wrappedBuffer(new byte[] {
@@ -63,7 +61,6 @@ public void test1002() throws Exception {
     }
 
     @Test
-    @Ignore // FIXME: Make it pass.
     public void testRandom() throws Exception {
         byte[] data = new byte[16 * 1048576];
         new Random().nextBytes(data);

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
Patch:
@@ -27,7 +27,7 @@
 import java.net.Socket;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.junit.Assert.*;
@@ -111,7 +111,7 @@ public void testShutdownOutputWithoutOption(ServerBootstrap sb) throws Throwable
 
     private static class TestHandler extends ChannelInboundByteHandlerAdapter {
         volatile SocketChannel ch;
-        final BlockingQueue<Byte> queue = new SynchronousQueue<Byte>();
+        final BlockingQueue<Byte> queue = new LinkedBlockingQueue<Byte>();
         final CountDownLatch halfClosure = new CountDownLatch(1);
         final CountDownLatch closure = new CountDownLatch(1);
         final AtomicInteger halfClosureCount = new AtomicInteger();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
Patch:
@@ -26,7 +26,7 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.LinkedBlockingQueue;
 
 import static org.junit.Assert.*;
 
@@ -79,7 +79,7 @@ public void testShutdownOutput(Bootstrap cb) throws Throwable {
 
     private static class TestHandler extends ChannelInboundByteHandlerAdapter {
         volatile SocketChannel ch;
-        final BlockingQueue<Byte> queue = new SynchronousQueue<Byte>();
+        final BlockingQueue<Byte> queue = new LinkedBlockingQueue<Byte>();
 
         @Override
         public void channelActive(ChannelHandlerContext ctx) throws Exception {

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -72,7 +72,7 @@
  *     // your methods here
  * }
  *
- * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&ltMessage&gt {
+ * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {
  *
  *     <b>private boolean loggedIn;</b>
  *
@@ -121,7 +121,7 @@
  * }
  *
  * {@code @Sharable}
- * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&ltMessage&gt {
+ * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {
  *   private final {@link AttributeKey}&lt{@link Boolean}&gt auth =
  *           new {@link AttributeKey}&lt{@link Boolean}&gt("auth");
  *

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -72,7 +72,7 @@
  *     // your methods here
  * }
  *
- * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&ltMessage&gt {
+ * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {
  *
  *     <b>private boolean loggedIn;</b>
  *
@@ -121,7 +121,7 @@
  * }
  *
  * {@code @Sharable}
- * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&ltMessage&gt {
+ * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {
  *   private final {@link AttributeKey}&lt{@link Boolean}&gt auth =
  *           new {@link AttributeKey}&lt{@link Boolean}&gt("auth");
  *

File: buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * An {@link IllegalStateException} raised when a user attempts to access a {@link Buf} which was freed by
- * {@link Buf#free()} already.
+ * {@link Buf#release()} } already.
  */
 public class IllegalBufferAccessException extends IllegalStateException {
 

File: example/src/main/java/io/netty/example/udt/util/UtilThreadFactory.java
Patch:
@@ -34,6 +34,6 @@ public UtilThreadFactory(final String name) {
 
     @Override
     public Thread newThread(final Runnable runnable) {
-        return new Thread(runnable, name + "-" + counter.getAndIncrement());
+        return new Thread(runnable, name + '-' + counter.getAndIncrement());
     }
 }

File: testsuite/src/test/java/io/netty/testsuite/transport/sctp/AbstractSctpTest.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import io.netty.testsuite.transport.sctp.SctpTestPermutation;
 import io.netty.testsuite.transport.sctp.SctpTestPermutation.Factory;
 import io.netty.testsuite.util.TestUtils;
 import io.netty.util.NetUtil;

File: transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannel.java
Patch:
@@ -18,8 +18,6 @@
 import io.netty.channel.ServerChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.net.InetSocketAddress;
-
 /**
  * UDT {@link ServerChannel}.
  * <p>

File: transport-udt/src/test/java/io/netty/test/udt/nio/AbstractUdtTest.java
Patch:
@@ -16,12 +16,10 @@
 
 package io.netty.test.udt.nio;
 
-import static org.junit.Assume.*;
 import io.netty.test.udt.util.UnitHelp;
-
 import org.junit.BeforeClass;
 
-import com.barchart.udt.SocketUDT;
+import static org.junit.Assume.*;
 
 /**
  * Base for UDT tests.

File: transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java
Patch:
@@ -17,9 +17,8 @@
 
 import io.netty.channel.AbstractEventLoopTest;
 import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.ServerSocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
 
 public class NioEventLoopTest extends AbstractEventLoopTest {
 

File: buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
Patch:
@@ -138,6 +138,7 @@ public boolean isReadable() {
     }
 
     @Override
+    @Deprecated
     public boolean readable() {
         return false;
     }
@@ -148,6 +149,7 @@ public boolean isWritable() {
     }
 
     @Override
+    @Deprecated
     public boolean writable() {
         return false;
     }
@@ -199,6 +201,7 @@ public ByteBuf ensureWritable(int minWritableBytes) {
     }
 
     @Override
+    @Deprecated
     public ByteBuf ensureWritableBytes(int minWritableBytes) {
         return ensureWritable(minWritableBytes);
     }

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -35,7 +35,7 @@
  * method-chaining to provide an easy way to configure the {@link AbstractBootstrap}.
  *
  */
-abstract class AbstractBootstrap<B extends AbstractBootstrap<?, C>, C extends Channel> implements Cloneable {
+abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> implements Cloneable {
 
     private volatile EventLoopGroup group;
     private volatile ChannelFactory<? extends C> channelFactory;

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -77,7 +77,7 @@
 public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelPropertyAccess, Comparable<Channel> {
 
     /**
-     * Returns the unique integer ID of this channel.
+     * Returns the unique integer ID of this channel. The returned value MUST be non {@code null}.
      */
     Integer id();
 
@@ -266,7 +266,7 @@ interface Unsafe {
         /**
          * Send a {@link FileRegion} to the remote peer and notify the {@link ChannelPromise} once it completes
          * or an error was detected. Once the {@link FileRegion} was transfered or an error was thrown it will
-         * automaticly closed via {@link FileRegion#close()}.
+         * automaticly call {@link FileRegion#release()}.
          */
         void sendFile(FileRegion region, ChannelPromise promise);
     }

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -1032,7 +1032,7 @@ protected final void checkReadableBytes(int minimumReadableBytes) {
     }
 
     protected final void ensureAccessible() {
-        if (refCnt() <= 0) {
+        if (refCnt() == 0) {
             throw new IllegalBufferAccessException();
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
Patch:
@@ -101,7 +101,7 @@ public String toString() {
         buf.append(streamId);
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Size = ");
-        if (refCnt() <= 0) {
+        if (refCnt() == 0) {
             buf.append("(freed)");
         } else {
             buf.append(data().readableBytes());

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
Patch:
@@ -137,7 +137,7 @@ public SctpMessage copy() {
 
     @Override
     public String toString() {
-        if (refCnt() <= 0) {
+        if (refCnt() == 0) {
             return "SctpFrame{" +
                     "streamIdentifier=" + streamIdentifier + ", protocolIdentifier=" + protocolIdentifier +
                     ", data=(FREED)}";

File: transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
Patch:
@@ -57,7 +57,7 @@ public DatagramPacket copy() {
 
     @Override
     public String toString() {
-        if (refCnt() <= 0) {
+        if (refCnt() == 0) {
             return "DatagramPacket{remoteAddress=" + remoteAddress().toString() +
                     ", data=(FREED)}";
         }

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -254,7 +254,7 @@ protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
         try {
             if (buf.isReadable()) {
                 for (;;) {
-                    if (buf.refCnt() <= 0) {
+                    if (buf.refCnt() == 0) {
                         break;
                     }
                     // Ensure the readerIndex of the buffer is 0 before beginning an async write.
@@ -370,7 +370,7 @@ protected void completed0(T result, AioSocketChannel channel) {
             channel.writeInProgress = false;
 
             ByteBuf buf = channel.unsafe().directOutboundContext().outboundByteBuffer();
-            if (buf.refCnt() <= 0) {
+            if (buf.refCnt() == 0) {
                 return;
             }
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java
Patch:
@@ -56,7 +56,7 @@ public void initChannel(SocketChannel ch) throws Exception {
         p.addLast("inflater", new HttpContentDecompressor());
 
         // Uncomment the following line if you don't want to handle HttpChunks.
-        //pipeline.addLast("aggregator", new HttpChunkAggregator(1048576));
+        //p.addLast("aggregator", new HttpObjectAggregator(1048576));
 
         p.addLast("handler", new HttpSnoopClientHandler());
     }

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
Patch:
@@ -114,8 +114,8 @@ private static void writeChunkLength(ByteBuf out, int chunkLength) {
     private static void calculateAndWriteChecksum(ByteBuf slice, ByteBuf out) {
         int checksum = calculateChecksum(slice);
         out.writeByte(checksum & 0x0ff);
-        out.writeByte(checksum >> 8 & 0x0ff);
-        out.writeByte(checksum >> 16 & 0x0ff);
-        out.writeByte(checksum >> 24 & 0x0ff);
+        out.writeByte(checksum >>> 8 & 0x0ff);
+        out.writeByte(checksum >>> 16 & 0x0ff);
+        out.writeByte(checksum >>> 24);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
Patch:
@@ -102,6 +102,7 @@ private static void setChunkLength(ByteBuf out, int lengthIdx) {
     private static void writeChunkLength(ByteBuf out, int chunkLength) {
         out.writeByte(chunkLength & 0xff);
         out.writeByte(chunkLength >>> 8 & 0xff);
+        out.writeByte(chunkLength >>> 16 & 0xff);
     }
 
     /**

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -24,7 +24,7 @@
 import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.embedded.EmbeddedMessageChannel;
-import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpMethod;
@@ -59,7 +59,7 @@ public void testSubsequentHttpRequestsAfterUpgradeShouldReturn403() throws Excep
         writeUpgradeRequest(ch);
         assertEquals(SWITCHING_PROTOCOLS, ((HttpResponse) ch.outboundMessageBuffer().poll()).getStatus());
         
-        ch.writeInbound(new DefaultHttpRequest(HTTP_1_1, HttpMethod.GET, "/test"));
+        ch.writeInbound(new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/test"));
         assertEquals(FORBIDDEN, ((HttpResponse) ch.outboundMessageBuffer().poll()).getStatus());
     }
     

File: example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
Patch:
@@ -55,7 +55,6 @@ public void messageReceived(ChannelHandlerContext ctx, SocksRequest socksRequest
                     ctx.pipeline().addLast(SocksServerConnectHandler.getName(), new SocksServerConnectHandler());
                     ctx.pipeline().remove(this);
                     ctx.nextInboundMessageBuffer().add(socksRequest);
-                    ctx.fireInboundBufferUpdated();
                 } else {
                     ctx.close();
                 }

File: common/src/main/java/io/netty/util/internal/PlatformDependent.java
Patch:
@@ -51,7 +51,6 @@ public final class PlatformDependent {
 
     private static final boolean HAS_JAVASSIST = hasJavassist0();
 
-
     /**
      * Returns {@code true} if and only if the current platform is Android
      */

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1023,7 +1023,7 @@ private void invokeInboundBufferUpdated() {
     public void fireChannelReadSuspended() {
         final DefaultChannelHandlerContext next = findContextInbound();
         EventExecutor executor = next.executor();
-        if (prev != null && executor.inEventLoop()) {
+        if (executor.inEventLoop()) {
             next.invokeChannelReadSuspended();
         } else {
             Runnable task = next.invokeChannelReadSuspendedTask;

File: transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
Patch:
@@ -295,10 +295,10 @@ protected void run() {
 
                 cancelledKeys = 0;
 
-                runAllTasks();
+                processSelectedKeys();
                 selector = this.selector;
 
-                processSelectedKeys();
+                runAllTasks();
                 selector = this.selector;
 
                 if (isShutdown()) {
@@ -502,7 +502,7 @@ private static void invokeChannelUnregistered(NioTask<SelectableChannel> task, S
 
     @Override
     protected void wakeup(boolean inEventLoop) {
-        if (wakenUp.compareAndSet(false, true)) {
+        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {
             selector.wakeup();
         }
     }

File: common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java
Patch:
@@ -50,12 +50,12 @@ public static TypeParameterMatcher find(
             for (;;) {
                 if (currentClass.getSuperclass() == parameterizedSuperClass) {
                     Type[] types = ((ParameterizedType) currentClass.getGenericSuperclass()).getActualTypeArguments();
-                    if (types.length - 1 < typeParamIndex || !(types[0] instanceof Class)) {
+                    if (types.length - 1 < typeParamIndex || !(types[typeParamIndex] instanceof Class)) {
                         throw new IllegalStateException(
                                 "cannot determine the type of the type parameter of " + thisClass.getSimpleName());
                     }
 
-                    Class<?> messageType = (Class<?>) types[0];
+                    Class<?> messageType = (Class<?>) types[typeParamIndex];
                     if (messageType == Object.class) {
                         matcher = NOOP;
                     } else {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * A SPDY Protocol Control Frame
  */
-public interface SpdyControlFrame {
+public interface SpdyControlFrame extends SpdyDataOrControlFrame {
     // Tag interface
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * A SPDY Protocol Data Frame
  */
-public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
+public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame, SpdyDataOrControlFrame {
 
     @Override
     SpdyDataFrame setStreamId(int streamID);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
Patch:
@@ -31,7 +31,7 @@
  */
 public final class SpdyFrameCodec
         extends CombinedChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<Object> {
+        implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<SpdyDataOrControlFrame> {
 
     /**
      * Creates a new instance with the specified {@code version} and
@@ -79,7 +79,7 @@ public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
+    public MessageBuf<SpdyDataOrControlFrame> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
         return encoder().newOutboundBuffer(ctx);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
Patch:
@@ -30,7 +30,7 @@
  */
 public final class SpdyHttpCodec
         extends CombinedChannelDuplexHandler
-        implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<HttpObject> {
+        implements ChannelInboundMessageHandler<SpdyDataOrControlFrame>, ChannelOutboundMessageHandler<HttpObject> {
 
     /**
      * Creates a new instance with the specified decoder options.
@@ -48,7 +48,7 @@ private SpdyHttpEncoder encoder() {
     }
 
     @Override
-    public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
+    public MessageBuf<SpdyDataOrControlFrame> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
         return decoder().newInboundBuffer(ctx);
     }
 

File: common/src/main/java/io/netty/util/internal/TypeParameterFinder.java
Patch:
@@ -42,7 +42,7 @@ public static Class<?> findActualTypeParameter(
                     Type[] types = ((ParameterizedType) currentClass.getGenericSuperclass()).getActualTypeArguments();
                     if (types.length - 1 < typeParamIndex || !(types[0] instanceof Class)) {
                         throw new IllegalStateException(
-                                "cannot determine the inbound message type of " + thisClass.getSimpleName());
+                                "cannot determine the type of the type parameter of " + thisClass.getSimpleName());
                     }
 
                     messageType = (Class<?>) types[0];

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
Patch:
@@ -40,14 +40,14 @@ public SctpInboundByteStreamHandler(int protocolIdentifier, int streamIdentifier
     }
 
     @Override
-    public boolean acceptInboundMessage(Object msg) throws Exception {
+    public final boolean acceptInboundMessage(Object msg) throws Exception {
         if (super.acceptInboundMessage(msg)) {
-            return isDecodable((SctpMessage) msg);
+            return acceptInboundMessage((SctpMessage) msg);
         }
         return false;
     }
 
-    protected boolean isDecodable(SctpMessage msg) {
+    protected boolean acceptInboundMessage(SctpMessage msg) {
         return msg.protocolIdentifier() == protocolIdentifier && msg.streamIdentifier() == streamIdentifier;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -32,8 +32,9 @@ public class SpdyHttpResponseStreamIdHandler extends
     private static final Integer NO_ID = -1;
     private final Queue<Integer> ids = new LinkedList<Integer>();
 
-    public SpdyHttpResponseStreamIdHandler() {
-        super(new Class<?>[] { HttpMessage.class, SpdyRstStreamFrame.class }, new Class<?>[] { HttpMessage.class });
+    @Override
+    public boolean acceptInboundMessage(Object msg) throws Exception {
+        return msg instanceof HttpMessage || msg instanceof SpdyRstStreamFrame;
     }
 
     @Override

File: common/src/main/java/io/netty/util/internal/TypeParameterFinder.java
Patch:
@@ -52,6 +52,5 @@ public static Class<?> findActualTypeParameter(
         return messageType;
     }
 
-
     private TypeParameterFinder() { }
 }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -1,4 +1,4 @@
-io.netty.channel.DefaultChannelPromise.setFailure/*
+/*
  * Copyright 2012 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -66,8 +66,6 @@ public class HttpObjectAggregator extends MessageToMessageDecoder<HttpObject> {
      *        a {@link TooLongFrameException} will be raised.
      */
     public HttpObjectAggregator(int maxContentLength) {
-        super(HttpObject.class);
-
         if (maxContentLength <= 0) {
             throw new IllegalArgumentException(
                     "maxContentLength must be a positive integer: " +

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -73,9 +73,10 @@ protected void freeOutboundMessage(OUTBOUND_IN msg) throws Exception {
 
     private final MessageToMessageDecoder<INBOUND_IN> decoder =
             new MessageToMessageDecoder<INBOUND_IN>() {
+
         @Override
-        public boolean isDecodable(Object msg) throws Exception {
-            return MessageToMessageCodec.this.isDecodable(msg);
+        public boolean acceptInboundMessage(Object msg) throws Exception {
+            return isDecodable(msg);
         }
 
         @Override

File: codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
Patch:
@@ -53,8 +53,6 @@ public Base64Decoder() {
     }
 
     public Base64Decoder(Base64Dialect dialect) {
-        super(ByteBuf.class);
-
         if (dialect == null) {
             throw new NullPointerException("dialect");
         }

File: codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
Patch:
@@ -68,8 +68,6 @@ public StringDecoder() {
      * Creates a new instance with the specified character set.
      */
     public StringDecoder(Charset charset) {
-        super(ByteBuf.class);
-
         if (charset == null) {
             throw new NullPointerException("charset");
         }

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
Patch:
@@ -40,8 +40,8 @@ public SctpInboundByteStreamHandler(int protocolIdentifier, int streamIdentifier
     }
 
     @Override
-    public boolean isSupported(Object msg) throws Exception {
-        if (super.isSupported(msg)) {
+    public boolean acceptInboundMessage(Object msg) throws Exception {
+        if (super.acceptInboundMessage(msg)) {
             return isDecodable((SctpMessage) msg);
         }
         return false;

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageToMessageDecoder.java
Patch:
@@ -23,7 +23,7 @@
 public abstract class SctpMessageToMessageDecoder extends MessageToMessageDecoder<SctpMessage> {
 
     @Override
-    public boolean isDecodable(Object msg) throws Exception {
+    public boolean acceptInboundMessage(Object msg) throws Exception {
         if (msg instanceof SctpMessage) {
             SctpMessage sctpMsg = (SctpMessage) msg;
             if (sctpMsg.isComplete()) {

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -156,9 +156,9 @@ private static final class StringInboundHandler extends ChannelInboundMessageHan
         boolean called;
 
         @Override
-        public boolean isSupported(Object msg) throws Exception {
+        public boolean acceptInboundMessage(Object msg) throws Exception {
             called = true;
-            return super.isSupported(msg);
+            return super.acceptInboundMessage(msg);
         }
 
         @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
Patch:
@@ -58,7 +58,6 @@ public WebSocketServerProtocolHandler(String websocketPath, String subprotocols)
     }
 
     public WebSocketServerProtocolHandler(String websocketPath, String subprotocols, boolean allowExtensions) {
-        super(WebSocketFrame.class);
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -44,7 +44,6 @@ public class WebSocketServerProtocolHandshakeHandler
 
     public WebSocketServerProtocolHandshakeHandler(String websocketPath, String subprotocols,
             boolean allowExtensions) {
-        super(FullHttpRequest.class);
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
Patch:
@@ -35,7 +35,6 @@ public class SctpInboundByteStreamHandler extends ChannelInboundMessageHandlerAd
      * @param protocolIdentifier supported application protocol.
      */
     public SctpInboundByteStreamHandler(int protocolIdentifier, int streamIdentifier) {
-        super(SctpMessage.class);
         this.protocolIdentifier = protocolIdentifier;
         this.streamIdentifier = streamIdentifier;
     }

File: transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java
Patch:
@@ -46,9 +46,6 @@ public Meter meter() {
     }
 
     public EchoMessageHandler(final Meter meter, final int messageSize) {
-
-        super(UdtMessage.class);
-
         this.meter = meter;
 
         final ByteBuf byteBuf = Unpooled.buffer(messageSize);

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
Patch:
@@ -32,7 +32,7 @@ public abstract class ByteToMessageCodec<I> extends ChannelDuplexHandler
     private final ByteToMessageDecoder decoder;
 
     protected ByteToMessageCodec(Class<?>... encodableMessageTypes) {
-        this.encodableMessageTypes = encodableMessageTypes;
+        this.encodableMessageTypes = ChannelHandlerUtil.acceptedMessageTypes(encodableMessageTypes);
         encoder = new MessageToByteEncoder<I>() {
             @Override
             public boolean isEncodable(Object msg) throws Exception {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
Patch:
@@ -64,6 +64,7 @@ public void testShutdownOutput(ServerBootstrap sb) throws Throwable {
             assertTrue(h.ch.isInputShutdown());
             assertFalse(h.ch.isOutputShutdown());
             assertEquals(1, h.closure.getCount());
+            Thread.sleep(100);
             assertEquals(1, h.halfClosureCount.intValue());
         } finally {
             s.close();
@@ -101,6 +102,7 @@ public void testShutdownOutputWithoutOption(ServerBootstrap sb) throws Throwable
             assertTrue(h.ch.isOutputShutdown());
 
             assertEquals(1, h.halfClosure.getCount());
+            Thread.sleep(100);
             assertEquals(0, h.halfClosureCount.intValue());
         } finally {
             s.close();

File: transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
Patch:
@@ -119,6 +119,7 @@ public void read() {
                     setInputShutdown();
                     if (isOpen()) {
                         if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
+                            key.interestOps(key.interestOps() & ~readInterestOp);
                             pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
                         } else {
                             close(voidFuture());

File: example/src/main/java/io/netty/example/filetransfer/FileServer.java
Patch:
@@ -16,14 +16,15 @@
 package io.netty.example.filetransfer;
 
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultFileRegion;
-import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.handler.codec.string.StringDecoder;
@@ -58,7 +59,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new StringEncoder(CharsetUtil.UTF_8),
+                             new StringEncoder(BufType.BYTE, CharsetUtil.UTF_8),
                              new LineBasedFrameDecoder(8192),
                              new StringDecoder(CharsetUtil.UTF_8),
                              new FileHandler());

File: example/src/main/java/io/netty/example/rxtx/RxtxClient.java
Patch:
@@ -16,11 +16,12 @@
 package io.netty.example.rxtx;
 
 import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.oio.OioEventLoopGroup;
 import io.netty.channel.rxtx.RxtxChannel;
 import io.netty.channel.rxtx.RxtxDeviceAddress;
-import io.netty.channel.oio.OioEventLoopGroup;
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
@@ -40,7 +41,7 @@ public static void main(String[] args) throws Exception {
                  public void initChannel(RxtxChannel ch) throws Exception {
                      ch.pipeline().addLast(
                          new LineBasedFrameDecoder(32768),
-                         new StringEncoder(),
+                         new StringEncoder(BufType.BYTE),
                          new StringDecoder(),
                          new RxtxClientHandler()
                      );

File: example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.securechat;
 
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -51,7 +52,7 @@ public void initChannel(SocketChannel ch) throws Exception {
         pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
                 8192, Delimiters.lineDelimiter()));
         pipeline.addLast("decoder", new StringDecoder());
-        pipeline.addLast("encoder", new StringEncoder());
+        pipeline.addLast("encoder", new StringEncoder(BufType.BYTE));
 
         // and then business logic.
         pipeline.addLast("handler", new SecureChatClientHandler());

File: example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.securechat;
 
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -54,7 +55,7 @@ public void initChannel(SocketChannel ch) throws Exception {
         pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
                 8192, Delimiters.lineDelimiter()));
         pipeline.addLast("decoder", new StringDecoder());
-        pipeline.addLast("encoder", new StringEncoder());
+        pipeline.addLast("encoder", new StringEncoder(BufType.BYTE));
 
         // and then business logic.
         pipeline.addLast("handler", new SecureChatServerHandler());

File: example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.telnet;
 
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -28,7 +29,7 @@
  */
 public class TelnetClientInitializer extends ChannelInitializer<SocketChannel> {
     private static final StringDecoder DECODER = new StringDecoder();
-    private static final StringEncoder ENCODER = new StringEncoder();
+    private static final StringEncoder ENCODER = new StringEncoder(BufType.BYTE);
     private static final TelnetClientHandler CLIENTHANDLER = new TelnetClientHandler();
     @Override
     public void initChannel(SocketChannel ch) throws Exception {

File: example/src/main/java/io/netty/example/telnet/TelnetServerPipelineFactory.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.example.telnet;
 
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
@@ -28,7 +29,7 @@
  */
 public class TelnetServerPipelineFactory extends ChannelInitializer<SocketChannel> {
     private static final StringDecoder DECODER = new StringDecoder();
-    private static final StringEncoder ENCODER = new StringEncoder();
+    private static final StringEncoder ENCODER = new StringEncoder(BufType.BYTE);
     private static final TelnetServerHandler SERVERHANDLER = new TelnetServerHandler();
 
     @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.BufType;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
@@ -76,7 +77,7 @@ public void testStartTls(ServerBootstrap sb, Bootstrap cb) throws Throwable {
             public void initChannel(SocketChannel sch) throws Exception {
                 ChannelPipeline p = sch.pipeline();
                 p.addLast("logger", new ByteLoggingHandler(LOG_LEVEL));
-                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder());
+                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder(BufType.BYTE));
                 p.addLast(executor, sh);
             }
         });
@@ -86,7 +87,7 @@ public void initChannel(SocketChannel sch) throws Exception {
             public void initChannel(SocketChannel sch) throws Exception {
                 ChannelPipeline p = sch.pipeline();
                 p.addLast("logger", new ByteLoggingHandler(LOG_LEVEL));
-                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder());
+                p.addLast(new LineBasedFrameDecoder(64), new StringDecoder(), new StringEncoder(BufType.BYTE));
                 p.addLast(executor, ch);
             }
         });

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.BufType;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -66,7 +67,7 @@ public void testStringEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
             public void initChannel(SocketChannel sch) throws Exception {
                 sch.pipeline().addLast("framer", new DelimiterBasedFrameDecoder(512, Delimiters.lineDelimiter()));
                 sch.pipeline().addLast("decoder", new StringDecoder(CharsetUtil.ISO_8859_1));
-                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(CharsetUtil.ISO_8859_1));
+                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(BufType.BYTE, CharsetUtil.ISO_8859_1));
                 sch.pipeline().addAfter("decoder", "handler", sh);
             }
         });
@@ -76,7 +77,7 @@ public void initChannel(SocketChannel sch) throws Exception {
             public void initChannel(SocketChannel sch) throws Exception {
                 sch.pipeline().addLast("framer", new DelimiterBasedFrameDecoder(512, Delimiters.lineDelimiter()));
                 sch.pipeline().addLast("decoder", new StringDecoder(CharsetUtil.ISO_8859_1));
-                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(CharsetUtil.ISO_8859_1));
+                sch.pipeline().addBefore("decoder", "encoder", new StringEncoder(BufType.BYTE, CharsetUtil.ISO_8859_1));
                 sch.pipeline().addAfter("decoder", "handler", ch);
             }
         });

File: transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java
Patch:
@@ -82,7 +82,7 @@ public final void inboundBufferUpdated(ChannelHandlerContext ctx) throws Excepti
                 try {
                     if (!isSupported(msg)) {
                         if (out == null) {
-                            out = ctx.nextOutboundMessageBuffer();
+                            out = ctx.nextInboundMessageBuffer();
                         }
                         out.add(msg);
                         unsupportedFound = true;

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1158,7 +1158,7 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
         }
     }
 
-    static abstract class HeadHandler implements ChannelOutboundHandler {
+    abstract static class HeadHandler implements ChannelOutboundHandler {
 
         protected final Unsafe unsafe;
         ByteBuf byteSink;

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.DefaultChannelPipeline.*;
 import io.netty.util.DefaultAttributeMap;
 
 import java.net.SocketAddress;

File: buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java
Patch:
@@ -33,6 +33,9 @@ final class QueueBackedMessageBuf<T> extends AbstractMessageBuf<T> {
 
     @Override
     public boolean offer(T e) {
+        if (e == null) {
+            throw new NullPointerException("e");
+        }
         checkUnfreed();
         return isWritable() && queue.offer(e);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/package-info.java
Patch:
@@ -18,7 +18,6 @@
  * Encoder, decoder and their related message types for HTTP.
  *
  * @apiviz.exclude ^java\.lang\.
- * @apiviz.exclude OneToOne(Encoder|Decoder)$
  * @apiviz.exclude \.HttpHeaders\.
  * @apiviz.exclude \.codec\.replay\.
  * @apiviz.exclude \.(Simple)?Channel[A-Za-z]*Handler$

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -120,7 +120,7 @@
  * All pushed resources should be sent before sending the response
  * that corresponds to the initial request.
  */
-public class SpdyHttpEncoder extends MessageToMessageEncoder<Object> {
+public class SpdyHttpEncoder extends MessageToMessageEncoder<HttpObject> {
 
     private final int spdyVersion;
     private volatile int currentStreamId;
@@ -141,7 +141,7 @@ public SpdyHttpEncoder(int version) {
     }
 
     @Override
-    public Object encode(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public Object encode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
 
         List<Object> out = new ArrayList<Object>();
         if (msg instanceof HttpRequest) {
@@ -288,7 +288,7 @@ private SpdySynReplyFrame createSynReplyFrame(HttpResponse httpResponse)
     }
 
     @Override
-    protected void freeOutboundMessage(Object msg) throws Exception {
+    protected void freeOutboundMessage(HttpObject msg) throws Exception {
         if (msg instanceof HttpContent) {
             // Will be freed later as the content of them is just reused here
             return;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelInboundMessageHandler;
@@ -35,7 +35,7 @@
  * much about the low-level details.
  *
  */
-public abstract class SpdyOrHttpChooser extends ChannelHandlerAdapter implements ChannelInboundByteHandler {
+public abstract class SpdyOrHttpChooser extends ChannelDuplexHandler implements ChannelInboundByteHandler {
 
     public enum SelectedProtocol {
         SpdyVersion2,

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -17,9 +17,9 @@
 
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandler;
 import io.netty.channel.ChannelOutboundMessageHandler;
@@ -31,7 +31,7 @@
  * Manages streams within a SPDY session.
  */
 public class SpdySessionHandler
-        extends ChannelHandlerAdapter
+        extends ChannelDuplexHandler
         implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {
 
     private static final SpdyProtocolException PROTOCOL_EXCEPTION = new SpdyProtocolException();

File: codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelOutboundByteHandler;
@@ -53,7 +53,7 @@
  * </pre>
  */
 public abstract class ByteToByteCodec
-        extends ChannelHandlerAdapter
+        extends ChannelDuplexHandler
         implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
 
     private final ByteToByteEncoder encoder = new ByteToByteEncoder() {

File: codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
Patch:
@@ -47,8 +47,7 @@
 public abstract class ByteToByteEncoder extends ChannelOutboundByteHandlerAdapter {
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        ByteBuf in = ctx.outboundByteBuffer();
+    protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception {
         ByteBuf out = ctx.nextOutboundByteBuffer();
         boolean encoded = false;
 

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
Patch:
@@ -17,14 +17,14 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
 
-public abstract class ByteToMessageCodec<I> extends ChannelHandlerAdapter
+public abstract class ByteToMessageCodec<I> extends ChannelDuplexHandler
         implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<I> {
 
     private final Class<?>[] encodableMessageTypes;

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelHandlerUtil;
 import io.netty.channel.ChannelInboundMessageHandler;
@@ -49,7 +49,7 @@
  * </pre>
  */
 public abstract class MessageToMessageCodec<INBOUND_IN, OUTBOUND_IN>
-        extends ChannelHandlerAdapter
+        extends ChannelDuplexHandler
         implements ChannelInboundMessageHandler<INBOUND_IN>,
                    ChannelOutboundMessageHandler<OUTBOUND_IN> {
 

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -67,6 +67,7 @@ public MessageBuf<I> newInboundBuffer(ChannelHandlerContext ctx) throws Exceptio
     public void inboundBufferUpdated(ChannelHandlerContext ctx)
             throws Exception {
         MessageBuf<I> in = ctx.inboundMessageBuffer();
+        MessageBuf<Object> out = ctx.nextInboundMessageBuffer();
         boolean notify = false;
         for (;;) {
             try {
@@ -75,7 +76,7 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx)
                     break;
                 }
                 if (!isDecodable(msg)) {
-                    ChannelHandlerUtil.addToNextInboundBuffer(ctx, msg);
+                    out.add(msg);
                     notify = true;
                     continue;
                 }

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.handler.logging;
 
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.logging.InternalLogLevel;
@@ -32,7 +32,7 @@
  * @apiviz.landmark
  */
 @Sharable
-public class LoggingHandler extends ChannelHandlerAdapter {
+public class LoggingHandler extends ChannelDuplexHandler {
 
     private static final LogLevel DEFAULT_LEVEL = LogLevel.DEBUG;
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -18,10 +18,10 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFlushPromiseNotifier;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelOutboundByteHandler;
@@ -142,7 +142,7 @@
  * @apiviz.uses io.netty.handler.ssl.SslBufferPool
  */
 public class SslHandler
-        extends ChannelHandlerAdapter
+        extends ChannelDuplexHandler
         implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
 
     private static final InternalLogger logger =

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -18,11 +18,11 @@
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPipeline;
@@ -67,7 +67,7 @@
  * @apiviz.has io.netty.handler.stream.ChunkedInput oneway - - reads from
  */
 public class ChunkedWriteHandler
-        extends ChannelHandlerAdapter implements ChannelOutboundMessageHandler<Object> {
+        extends ChannelDuplexHandler implements ChannelOutboundMessageHandler<Object> {
 
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(ChunkedWriteHandler.class);

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -17,9 +17,9 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOperationHandler;
@@ -75,7 +75,7 @@
  * }
  *
  * // Handler should handle the {@link IdleStateEvent} triggered by {@link IdleStateHandler}.
- * public class MyHandler extends {@link ChannelHandlerAdapter} {
+ * public class MyHandler extends {@link ChannelDuplexHandler} {
  *     {@code @Override}
  *     public void userEventTriggered({@link ChannelHandlerContext} ctx, {@link Object} evt) throws {@link Exception} {
  *         if (evt instanceof {@link IdleState}} {

File: handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelStateHandlerAdapter;
@@ -41,7 +41,7 @@
  * }
  *
  * // Handler should handle the {@link ReadTimeoutException}.
- * public class MyHandler extends {@link ChannelHandlerAdapter} {
+ * public class MyHandler extends {@link ChannelDuplexHandler} {
  *     {@code @Override}
  *     public void exceptionCaught({@link ChannelHandlerContext} ctx, {@link Throwable} cause)
  *             throws {@link Exception} {

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -17,9 +17,9 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOperationHandlerAdapter;
@@ -45,7 +45,7 @@
  * }
  *
  * // Handler should handle the {@link WriteTimeoutException}.
- * public class MyHandler extends {@link ChannelHandlerAdapter} {
+ * public class MyHandler extends {@link ChannelDuplexHandler} {
  *     {@code @Override}
  *     public void exceptionCaught({@link ChannelHandlerContext} ctx, {@link Throwable} cause)
  *             throws {@link Exception} {

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.traffic;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandler;
 import io.netty.channel.ChannelOutboundByteHandler;
@@ -43,7 +43,7 @@
  * or start the monitoring, to change the checkInterval directly, or to have access to its values.</li>
  * </ul>
  */
-public abstract class AbstractTrafficShapingHandler extends ChannelHandlerAdapter
+public abstract class AbstractTrafficShapingHandler extends ChannelDuplexHandler
         implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
 
     /**

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java
Patch:
@@ -43,9 +43,7 @@ public SctpOutboundByteStreamHandler(int streamIdentifier, int protocolIdentifie
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        ByteBuf in = ctx.outboundByteBuffer();
-
+    protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception {
         try {
             MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
             ByteBuf payload = Unpooled.buffer(in.readableBytes());

File: transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java
Patch:
@@ -19,13 +19,13 @@
 
 
 /**
- * Abstract base class for {@link ChannelInboundHandlerAdapter} which should be extended by the user to
+ * Abstract base class for {@link ChannelInboundByteHandler} which should be extended by the user to
  * get notified once more data is ready to get consumed from the inbound {@link ByteBuf}.
  *
  * This implementation is a good starting point for most users.
  */
 public abstract class ChannelInboundByteHandlerAdapter
-        extends ChannelInboundHandlerAdapter implements ChannelInboundByteHandler {
+        extends ChannelStateHandlerAdapter implements ChannelInboundByteHandler {
 
     /**
      * Create a new unpooled {@link ByteBuf} by default. Sub-classes may override this to offer a more

File: transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
Patch:
@@ -85,8 +85,8 @@ public interface ChannelInboundInvoker {
     void fireInboundBufferUpdated();
 
     /**
-     * Triggers an {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) inboundBufferSuspended}
+     * Triggers an {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) channelReadSuspended}
      * event to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
      */
-    void fireInboundBufferSuspended();
+    void fireChannelReadSuspended();
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
Patch:
@@ -157,7 +157,7 @@ public interface ChannelOutboundInvoker {
      * Reads data from the {@link Channel} into the first inbound buffer, triggers an
      * {@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext) inboundBufferUpdated} event if data was
      * read, and triggers an
-     * {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) inboundBufferSuspended} event so the
+     * {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) channelReadSuspended} event so the
      * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
      */
     void read();

File: transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java
Patch:
@@ -24,7 +24,7 @@
  * @param <I>   The type of the messages to handle
  */
 public abstract class ChannelOutboundMessageHandlerAdapter<I>
-        extends ChannelOutboundHandlerAdapter implements ChannelOutboundMessageHandler<I> {
+        extends ChannelOperationHandlerAdapter implements ChannelOutboundMessageHandler<I> {
 
     @Override
     public MessageBuf<I> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -222,7 +222,7 @@ protected void doBeginRead() throws Exception {
         }
 
         pipeline.fireInboundBufferUpdated();
-        pipeline.fireInboundBufferSuspended();
+        pipeline.fireChannelReadSuspended();
     }
 
     @Override
@@ -259,7 +259,7 @@ private static void finishPeerRead(LocalChannel peer, ChannelPipeline peerPipeli
         if (peer.readInProgress) {
             peer.readInProgress = false;
             peerPipeline.fireInboundBufferUpdated();
-            peerPipeline.fireInboundBufferSuspended();
+            peerPipeline.fireChannelReadSuspended();
         }
     }
 

File: transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
Patch:
@@ -144,7 +144,7 @@ protected void doBeginRead() throws Exception {
         }
 
         pipeline.fireInboundBufferUpdated();
-        pipeline.fireInboundBufferSuspended();
+        pipeline.fireChannelReadSuspended();
     }
 
     LocalChannel serve(final LocalChannel peer) {
@@ -160,7 +160,7 @@ private void serve0(final LocalChannel child) {
             if (acceptInProgress) {
                 acceptInProgress = false;
                 pipeline.fireInboundBufferUpdated();
-                pipeline.fireInboundBufferSuspended();
+                pipeline.fireChannelReadSuspended();
             }
         } else {
             eventLoop().execute(new Runnable() {

File: transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
Patch:
@@ -126,7 +126,7 @@ protected void doRead() {
                 pipeline.fireExceptionCaught(t);
             } else {
                 firedInboundBufferSuspeneded = true;
-                pipeline.fireInboundBufferSuspended();
+                pipeline.fireChannelReadSuspended();
                 pipeline.fireExceptionCaught(t);
                 unsafe().close(unsafe().voidFuture());
             }
@@ -144,7 +144,7 @@ protected void doRead() {
                     }
                 }
             } else if (!firedInboundBufferSuspeneded) {
-                pipeline.fireInboundBufferSuspended();
+                pipeline.fireChannelReadSuspended();
             }
         }
     }

File: transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java
Patch:
@@ -185,7 +185,7 @@ protected void completed0(AsynchronousSocketChannel ch, AioServerSocketChannel c
             channel.pipeline().inboundMessageBuffer().add(
                     new AioSocketChannel(channel, null, ch));
             channel.pipeline().fireInboundBufferUpdated();
-            channel.pipeline().fireInboundBufferSuspended();
+            channel.pipeline().fireChannelReadSuspended();
         }
 
         @Override

File: transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java
Patch:
@@ -59,11 +59,11 @@ public void initChannel(ServerSocketChannel ch) throws Exception {
         assertSame(executor, future.channel().pipeline().context(TestChannelHandler2.class).executor());
     }
 
-    private static final class TestChannelHandler extends ChannelHandlerAdapter {
+    private static final class TestChannelHandler extends ChannelDuplexHandler {
 
     }
 
-    private static final class TestChannelHandler2 extends ChannelHandlerAdapter {
+    private static final class TestChannelHandler2 extends ChannelDuplexHandler {
 
     }
 

File: transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
Patch:
@@ -137,7 +137,7 @@ public void run() {
                 timestamps.add(System.nanoTime());
                 if (empty) {
                     try {
-                        Thread.sleep(400);
+                        Thread.sleep(401);
                     } catch (InterruptedException e) {
                         // Ignore
                     }
@@ -176,7 +176,7 @@ public void scheduleTaskWithFixedDelay() throws Exception {
             public void run() {
                 timestamps.add(System.nanoTime());
                 try {
-                    Thread.sleep(50);
+                    Thread.sleep(51);
                 } catch (InterruptedException e) {
                     // Ignore
                 }

File: buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
Patch:
@@ -103,7 +103,7 @@ public boolean markSupported() {
 
     @Override
     public int read() throws IOException {
-        if (!buffer.readable()) {
+        if (!buffer.isReadable()) {
             return -1;
         }
         return buffer.readByte() & 0xff;
@@ -143,7 +143,7 @@ public boolean readBoolean() throws IOException {
 
     @Override
     public byte readByte() throws IOException {
-        if (!buffer.readable()) {
+        if (!buffer.isReadable()) {
             throw new EOFException();
         }
         return buffer.readByte();

File: buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
Patch:
@@ -197,7 +197,7 @@ private int addComponents0(int cIndex, ByteBuf... buffers) {
             if (b == null) {
                 break;
             }
-            if (b.readable()) {
+            if (b.isReadable()) {
                 cIndex = addComponent0(cIndex, b, false) + 1;
                 int size = components.size();
                 if (cIndex > size) {
@@ -1341,8 +1341,8 @@ public CompositeByteBuf resetWriterIndex() {
     }
 
     @Override
-    public CompositeByteBuf ensureWritableBytes(int minWritableBytes) {
-        return (CompositeByteBuf) super.ensureWritableBytes(minWritableBytes);
+    public CompositeByteBuf ensureWritable(int minWritableBytes) {
+        return (CompositeByteBuf) super.ensureWritable(minWritableBytes);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java
Patch:
@@ -54,7 +54,7 @@ public void encode(
             // Binary frame
             ByteBuf data = msg.data();
             int dataLen = data.readableBytes();
-            out.ensureWritableBytes(dataLen + 5);
+            out.ensureWritable(dataLen + 5);
 
             // Encode type.
             out.writeByte((byte) 0x80);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -142,18 +142,18 @@ public void encode(
 
         int maskLength = maskPayload ? 4 : 0;
         if (length <= 125) {
-            out.ensureWritableBytes(2 + maskLength + length);
+            out.ensureWritable(2 + maskLength + length);
             out.writeByte(b0);
             byte b = (byte) (maskPayload ? 0x80 | (byte) length : (byte) length);
             out.writeByte(b);
         } else if (length <= 0xFFFF) {
-            out.ensureWritableBytes(4 + maskLength + length);
+            out.ensureWritable(4 + maskLength + length);
             out.writeByte(b0);
             out.writeByte(maskPayload ? 0xFE : 126);
             out.writeByte(length >>> 8 & 0xFF);
             out.writeByte(length & 0xFF);
         } else {
-            out.ensureWritableBytes(10 + maskLength + length);
+            out.ensureWritable(10 + maskLength + length);
             out.writeByte(b0);
             out.writeByte(maskPayload ? 0xFF : 127);
             out.writeLong(length);

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java
Patch:
@@ -85,7 +85,7 @@ protected void decode(
             ChannelHandlerContext ctx,
             ByteBuf in, ByteBuf out) throws Exception {
 
-        if (!in.readable()) {
+        if (!in.isReadable()) {
             return;
         }
 
@@ -116,7 +116,7 @@ protected void decode(
                 loop: for (;;) {
                     z.avail_out = maxOutputLength;
                     if (outHasArray) {
-                        out.ensureWritableBytes(maxOutputLength);
+                        out.ensureWritable(maxOutputLength);
                         z.next_out = out.array();
                         z.next_out_index = out.arrayOffset() + out.writerIndex();
                     } else {

File: codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
Patch:
@@ -294,7 +294,7 @@ protected void encode(ChannelHandlerContext ctx,
                 boolean outHasArray = out.hasArray();
                 z.avail_out = maxOutputLength;
                 if (outHasArray) {
-                    out.ensureWritableBytes(maxOutputLength);
+                    out.ensureWritable(maxOutputLength);
                     z.next_out = out.array();
                     z.next_out_index = out.arrayOffset() + out.writerIndex();
                 } else {

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
Patch:
@@ -189,7 +189,7 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
         uncompressed.readBytes(inAry);
 
         int sizeEstimate = (int) Math.ceil(inAry.length * 1.001) + 12;
-        out.ensureWritableBytes(sizeEstimate);
+        out.ensureWritable(sizeEstimate);
 
         synchronized (deflater) {
             if (gzip) {

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -268,9 +268,9 @@ public void decode(ByteBuf in, ByteBuf out, int maxLength) {
             return;
         }
 
-        out.ensureWritableBytes(inputLength);
+        out.ensureWritable(inputLength);
 
-        while (in.readable() && in.readerIndex() - inIndex < maxLength) {
+        while (in.isReadable() && in.readerIndex() - inIndex < maxLength) {
             byte tag = in.readByte();
             switch (tag & 0x03) {
             case LITERAL:

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
Patch:
@@ -15,14 +15,13 @@
  */
 package io.netty.handler.codec.protobuf;
 
+import com.google.protobuf.CodedOutputStream;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToByteEncoder;
 
-import com.google.protobuf.CodedOutputStream;
-
 /**
  * An encoder that prepends the the Google Protocol Buffers
  * <a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints">Base
@@ -52,7 +51,7 @@ protected void encode(
             ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {
         int bodyLen = msg.readableBytes();
         int headerLen = CodedOutputStream.computeRawVarint32Size(bodyLen);
-        out.ensureWritableBytes(headerLen + bodyLen);
+        out.ensureWritable(headerLen + bodyLen);
 
         CodedOutputStream headerOut =
                 CodedOutputStream.newInstance(new ByteBufOutputStream(out));

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -100,7 +100,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
             HttpContent httpContent = (HttpContent) msg;
 
             ByteBuf content = httpContent.data();
-            if (content.readable()) {
+            if (content.isReadable()) {
                 buf.append("CONTENT: ");
                 buf.append(content.toString(CharsetUtil.UTF_8));
                 buf.append("\r\n");

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -361,7 +361,7 @@ protected static int expandReadBuffer(ByteBuf byteBuf) {
             byteBuf.capacity(maxCapacity);
         } else {
             // Expand by the increment.
-            byteBuf.ensureWritableBytes(increment);
+            byteBuf.ensureWritable(increment);
         }
 
         return 1;

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -43,7 +43,6 @@ public void run() throws Exception {
             b.group(new NioEventLoopGroup(), new NioEventLoopGroup())
              .channel(NioServerSocketChannel.class)
              .option(ChannelOption.SO_BACKLOG, 100)
-             .childOption(ChannelOption.TCP_NODELAY, true)
              .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SocketChannel>() {
                  @Override

File: example/src/main/java/io/netty/example/filetransfer/FileServer.java
Patch:
@@ -53,7 +53,6 @@ public void run() throws Exception {
             b.group(new NioEventLoopGroup(), new NioEventLoopGroup())
              .channel(NioServerSocketChannel.class)
              .option(ChannelOption.SO_BACKLOG, 100)
-             .childOption(ChannelOption.TCP_NODELAY, true)
              .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SocketChannel>() {
                  @Override

File: example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.sctp.SctpChannel;
-import io.netty.channel.sctp.SctpChannelOption;
 import io.netty.channel.sctp.nio.NioSctpServerChannel;
 import io.netty.channel.socket.nio.NioEventLoopGroup;
 import io.netty.handler.logging.LogLevel;
@@ -44,7 +43,6 @@ public void run() throws Exception {
             b.group(new NioEventLoopGroup(), new NioEventLoopGroup())
              .channel(NioSctpServerChannel.class)
              .option(ChannelOption.SO_BACKLOG, 100)
-             .childOption(SctpChannelOption.SCTP_NODELAY, true)
              .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SctpChannel>() {
                  @Override

File: example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.sctp.SctpChannel;
-import io.netty.channel.sctp.SctpChannelOption;
 import io.netty.channel.sctp.oio.OioSctpServerChannel;
 import io.netty.channel.socket.oio.OioEventLoopGroup;
 import io.netty.handler.logging.LogLevel;
@@ -44,7 +43,6 @@ public void run() throws Exception {
             b.group(new OioEventLoopGroup(), new OioEventLoopGroup())
              .channel(OioSctpServerChannel.class)
              .option(ChannelOption.SO_BACKLOG, 100)
-             .childOption(SctpChannelOption.SCTP_NODELAY, true)
              .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SctpChannel>() {
                  @Override

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -43,7 +43,7 @@
  * {@link Bootstrap} sub-class which allows easy bootstrap of {@link ServerChannel}
  *
  */
-public final class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, Channel> {
+public final class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ServerBootstrap.class);
 

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -43,7 +43,7 @@
  * {@link Bootstrap} sub-class which allows easy bootstrap of {@link ServerChannel}
  *
  */
-public final class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> {
+public final class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, Channel> {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ServerBootstrap.class);
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
Patch:
@@ -88,7 +88,7 @@ static List<Entry<Factory<Bootstrap>, Factory<Bootstrap>>> datagram() {
         bfs.add(new Factory<Bootstrap>() {
             @Override
             public Bootstrap newInstance() {
-                return new Bootstrap().group(new NioEventLoopGroup()).channelFactory(new ChannelFactory() {
+                return new Bootstrap().group(new NioEventLoopGroup()).channelFactory(new ChannelFactory<Channel>() {
                     @Override
                     public Channel newChannel() {
                        return new NioDatagramChannel(InternetProtocolFamily.IPv4);

File: transport/src/main/java/io/netty/bootstrap/ChannelFactory.java
Patch:
@@ -26,4 +26,4 @@ public interface ChannelFactory<T extends Channel> {
      * Creates a new channel.
      */
     T newChannel();
-}
\ No newline at end of file
+}

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java
Patch:
@@ -15,14 +15,12 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import io.netty.bootstrap.AbstractBootstrap;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
 import io.netty.testsuite.transport.socket.SocketTestPermutation.Factory;
 import io.netty.testsuite.util.TestUtils;
 import io.netty.util.NetUtil;
-
 import org.junit.Rule;
 import org.junit.rules.TestName;
 
@@ -60,7 +58,7 @@ protected void run() throws Throwable {
                     "Running: %s %d of %d (%s + %s)", testName.getMethodName(), ++ i, COMBO.size(), sb, cb));
             try {
                 Method m = getClass().getDeclaredMethod(
-                        testName.getMethodName(), AbstractBootstrap.class, AbstractBootstrap.class);
+                        testName.getMethodName(), Bootstrap.class, Bootstrap.class);
                 m.invoke(this, sb, cb);
             } catch (InvocationTargetException ex) {
                 throw ex.getCause();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import io.netty.bootstrap.AbstractBootstrap;
+import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
@@ -42,7 +42,7 @@ public void testMulticast() throws Throwable {
         run();
     }
 
-    public void testMulticast(AbstractBootstrap<?> sb, AbstractBootstrap<?> cb) throws Throwable {
+    public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {
         MulticastTestHandler mhandler = new MulticastTestHandler();
 
         sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import io.netty.bootstrap.AbstractBootstrap;
+import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
@@ -35,7 +35,7 @@ public void testSimpleSend() throws Throwable {
         run();
     }
 
-    public void testSimpleSend(AbstractBootstrap<?> sb, AbstractBootstrap<?> cb) throws Throwable {
+    public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {
         final CountDownLatch latch = new CountDownLatch(1);
 
         sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import io.netty.bootstrap.AbstractBootstrap.ChannelFactory;
 import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ChannelFactory;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.socket.InternetProtocolFamily;

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -34,7 +34,7 @@
  * for clients.
  *
  */
-public final class Bootstrap extends AbstractBootstrap<Bootstrap> {
+public final class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Bootstrap.class);
 

File: codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
Patch:
@@ -96,7 +96,7 @@ public void encode(ByteBuf in, ByteBuf out, int length) {
                     in.readerIndex(in.readerIndex() + matched);
                     insertTail = inIndex - 1;
                     nextEmit = inIndex;
-                    if (inIndex >= maxIndex) {
+                    if (inIndex >= maxIndex - 4) {
                         break outer;
                     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
Patch:
@@ -126,7 +126,7 @@ public interface Cookie extends Comparable<Cookie> {
     boolean isSecure();
 
     /**
-     * Sets the security status of this {@link Cookie}
+     * Sets the security getStatus of this {@link Cookie}
      *
      * @param secure True if this {@link Cookie} is to be secure, otherwise false
      */

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
Patch:
@@ -56,6 +56,6 @@ public void free() {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + "(data: " + data() + ", decoderResult: " + decoderResult() + ')';
+        return getClass().getSimpleName() + "(data: " + data() + ", getDecoderResult: " + getDecoderResult() + ')';
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java
Patch:
@@ -26,12 +26,12 @@ protected DefaultHttpObject() {
     }
 
     @Override
-    public DecoderResult decoderResult() {
+    public DecoderResult getDecoderResult() {
         return decoderResult;
     }
 
     @Override
-    public void updateDecoderResult(DecoderResult decoderResult) {
+    public void setDecoderResult(DecoderResult decoderResult) {
         if (decoderResult == null) {
             throw new NullPointerException("decoderResult");
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
Patch:
@@ -22,4 +22,5 @@
 public interface FullHttpMessage extends HttpMessage, LastHttpContent {
     @Override
     FullHttpMessage copy();
+
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -56,7 +56,7 @@ protected HttpContentDecoder() {
 
     @Override
     protected Object decode(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof HttpResponse && ((HttpResponse) msg).status().code() == 100) {
+        if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().code() == 100) {
             // 100-continue response must be passed through.
             return msg;
         }
@@ -163,7 +163,7 @@ private Object[] decodeContent(HttpMessage header, HttpContent c) {
 
     /**
      * Returns the expected content encoding of the decoded content.
-     * This method returns {@code "identity"} by default, which is the case for
+     * This getMethod returns {@code "identity"} by default, which is the case for
      * most decoders.
      *
      * @param contentEncoding the value of the {@code "Content-Encoding"} header

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -79,7 +79,7 @@ protected Object decode(ChannelHandlerContext ctx, HttpMessage msg)
     public Object encode(ChannelHandlerContext ctx, Object msg)
             throws Exception {
 
-        if (msg instanceof HttpResponse && ((HttpResponse) msg).status().code() == 100) {
+        if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().code() == 100) {
             // 100-continue response must be passed through.
             return msg;
         }
@@ -91,11 +91,11 @@ public Object encode(ChannelHandlerContext ctx, Object msg)
             if (msg instanceof HttpContent) {
                 if (msg instanceof HttpRequest) {
                     HttpRequest req = (HttpRequest) msg;
-                    message = new DefaultHttpRequest(req.protocolVersion(), req.method(), req.uri());
+                    message = new DefaultHttpRequest(req.getProtocolVersion(), req.getMethod(), req.getUri());
                     message.headers().set(req.headers());
                 } else  if (msg instanceof HttpResponse) {
                     HttpResponse res = (HttpResponse) msg;
-                    message = new DefaultHttpResponse(res.protocolVersion(), res.status());
+                    message = new DefaultHttpResponse(res.getProtocolVersion(), res.getStatus());
                     message.headers().set(res.headers());
                 } else {
                     return msg;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObject.java
Patch:
@@ -21,11 +21,11 @@ public interface HttpObject {
     /**
      * Returns the result of decoding this message.
      */
-    DecoderResult decoderResult();
+    DecoderResult getDecoderResult();
 
     /**
      * Updates the result of decoding this message. This method is supposed to be invoked by {@link HttpObjectDecoder}.
      * Do not call this method unless you know what you are doing.
      */
-    void updateDecoderResult(DecoderResult result);
+    void setDecoderResult(DecoderResult result);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -34,12 +34,12 @@ public boolean isEncodable(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {
-        buf.writeBytes(request.method().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(request.getMethod().toString().getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
 
         // Add / as absolute path if no is present.
         // See http://tools.ietf.org/html/rfc2616#section-5.1.2
-        String uri = request.uri();
+        String uri = request.getUri();
         int start = uri.indexOf("://");
         if (start != -1) {
             int startIndex = start + 3;
@@ -50,7 +50,7 @@ protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Except
         buf.writeBytes(uri.getBytes("UTF-8"));
 
         buf.writeByte(SP);
-        buf.writeBytes(request.protocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(request.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(CR);
         buf.writeByte(LF);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
Patch:
@@ -33,11 +33,11 @@ public boolean isEncodable(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpResponse response) throws Exception {
-        buf.writeBytes(response.protocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
-        buf.writeBytes(String.valueOf(response.status().code()).getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(String.valueOf(response.getStatus().code()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
-        buf.writeBytes(String.valueOf(response.status().reasonPhrase()).getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(String.valueOf(response.getStatus().reasonPhrase()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(CR);
         buf.writeByte(LF);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java
Patch:
@@ -283,7 +283,7 @@ public class HttpResponseStatus implements Comparable<HttpResponseStatus> {
 
     /**
      * Returns the {@link HttpResponseStatus} represented by the specified code.
-     * If the specified code is a standard HTTP status code, a cached instance
+     * If the specified code is a standard HTTP getStatus code, a cached instance
      * will be returned.  Otherwise, a new instance will be returned.
      */
     public static HttpResponseStatus valueOf(int code) {
@@ -445,14 +445,14 @@ public HttpResponseStatus(int code, String reasonPhrase) {
     }
 
     /**
-     * Returns the code of this status.
+     * Returns the code of this getStatus.
      */
     public int code() {
         return code;
     }
 
     /**
-     * Returns the reason phrase of this status.
+     * Returns the reason phrase of this getStatus.
      */
     public String reasonPhrase() {
         return reasonPhrase;

File: codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
Patch:
@@ -45,12 +45,12 @@ public HttpHeaders trailingHeaders() {
         }
 
         @Override
-        public DecoderResult decoderResult() {
+        public DecoderResult getDecoderResult() {
             return DecoderResult.SUCCESS;
         }
 
         @Override
-        public void updateDecoderResult(DecoderResult result) {
+        public void setDecoderResult(DecoderResult result) {
             throw new UnsupportedOperationException("read only");
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -106,7 +106,7 @@ public QueryStringDecoder(String uri, Charset charset, boolean hasPath) {
      */
     public QueryStringDecoder(String uri, Charset charset, boolean hasPath, int maxParams) {
         if (uri == null) {
-            throw new NullPointerException("uri");
+            throw new NullPointerException("getUri");
         }
         if (charset == null) {
             throw new NullPointerException("charset");
@@ -145,7 +145,7 @@ public QueryStringDecoder(URI uri, Charset charset) {
      */
     public QueryStringDecoder(URI uri, Charset charset, int maxParams) {
         if (uri == null) {
-            throw new NullPointerException("uri");
+            throw new NullPointerException("getUri");
         }
         if (charset == null) {
             throw new NullPointerException("charset");

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -58,7 +58,7 @@ public QueryStringEncoder(String uri) {
      */
     public QueryStringEncoder(String uri, Charset charset) {
         if (uri == null) {
-            throw new NullPointerException("uri");
+            throw new NullPointerException("getUri");
         }
         if (charset == null) {
             throw new NullPointerException("charset");
@@ -84,7 +84,7 @@ public void addParam(String name, String value) {
     /**
      * Returns the URL-encoded URI object which was created from the path string
      * specified in the constructor and the parameters added by
-     * {@link #addParam(String, String)} method.
+     * {@link #addParam(String, String)} getMethod.
      */
     public URI toUri() throws URISyntaxException {
         return new URI(toString());
@@ -93,7 +93,7 @@ public URI toUri() throws URISyntaxException {
     /**
      * Returns the URL-encoded URI which was created from the path string
      * specified in the constructor and the parameters added by
-     * {@link #addParam(String, String)} method.
+     * {@link #addParam(String, String)} getMethod.
      */
     @Override
     public String toString() {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
Patch:
@@ -149,8 +149,8 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
     Charset getCharset();
 
     /**
-     * A convenience method to write an uploaded item to disk. If a previous one
-     * exists, it will be deleted. Once this method is called, if successful,
+     * A convenience getMethod to write an uploaded item to disk. If a previous one
+     * exists, it will be deleted. Once this getMethod is called, if successful,
      * the new file will be out of the cleaner of the factory that creates the
      * original InterfaceHttpData object.
      *

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
Patch:
@@ -34,7 +34,7 @@ public CloseWebSocketFrame() {
     }
 
     /**
-     * Creates a new empty close frame with closing status code and reason text
+     * Creates a new empty close frame with closing getStatus code and reason text
      *
      * @param statusCode
      *            Integer status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. For
@@ -47,7 +47,7 @@ public CloseWebSocketFrame(int statusCode, String reasonText) {
     }
 
     /**
-     * Creates a new close frame with no losing status code and no reason text
+     * Creates a new close frame with no losing getStatus code and no reason text
      *
      * @param finalFragment
      *            flag indicating if this frame is the final fragment
@@ -107,7 +107,7 @@ public CloseWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
 
     /**
      * Returns the closing status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. If
-     * a status code is set, -1 is returned.
+     * a getStatus code is set, -1 is returned.
      */
     public int statusCode() {
         ByteBuf binaryData = data();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -178,7 +178,7 @@ public Object decode(
 
                     // close frame : if there is a body, the first two bytes of the
                     // body MUST be a 2-byte unsigned integer (in network byte
-                    // order) representing a status code
+                    // order) representing a getStatus code
                     if (frameOpcode == 8 && framePayloadLen1 == 1) {
                         protocolViolation(ctx, "received close control frame with payload len 1");
                         return null;
@@ -417,7 +417,7 @@ protected void checkCloseFrameBody(
         int statusCode = buffer.readShort();
         if (statusCode >= 0 && statusCode <= 999 || statusCode >= 1004 && statusCode <= 1006
                 || statusCode >= 1012 && statusCode <= 2999) {
-            protocolViolation(ctx, "Invalid close frame status code: " + statusCode);
+            protocolViolation(ctx, "Invalid close frame getStatus code: " + statusCode);
         }
 
         // May have UTF-8 message

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -221,8 +221,8 @@ public void operationComplete(ChannelFuture future) {
     public void finishHandshake(Channel channel, FullHttpResponse response) {
         final HttpResponseStatus status = new HttpResponseStatus(101, "WebSocket Protocol Handshake");
 
-        if (!response.status().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response status: " + response.status());
+        if (!response.getStatus().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
         }
 
         HttpHeaders headers = response.headers();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -198,8 +198,8 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.status().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response status: " + response.status());
+        if (!response.getStatus().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
         }
 
         String upgrade = headers.get(Names.UPGRADE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -198,8 +198,8 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.status().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response status: " + response.status());
+        if (!response.getStatus().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
         }
 
         String upgrade = headers.get(Names.UPGRADE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -197,8 +197,8 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.status().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response status: " + response.status());
+        if (!response.getStatus().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
         }
 
         String upgrade = headers.get(Names.UPGRADE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -140,9 +140,9 @@ public ChannelFuture handshake(Channel channel, FullHttpRequest req, ChannelProm
         res.headers().add(Names.UPGRADE, WEBSOCKET);
         res.headers().add(CONNECTION, Values.UPGRADE);
 
-        // Fill in the headers and contents depending on handshake method.
+        // Fill in the headers and contents depending on handshake getMethod.
         if (isHixie76) {
-            // New handshake method with a challenge:
+            // New handshake getMethod with a challenge:
             res.headers().add(SEC_WEBSOCKET_ORIGIN, req.headers().get(ORIGIN));
             res.headers().add(SEC_WEBSOCKET_LOCATION, uri());
             String subprotocols = req.headers().get(SEC_WEBSOCKET_PROTOCOL);
@@ -170,7 +170,7 @@ public ChannelFuture handshake(Channel channel, FullHttpRequest req, ChannelProm
             input.writeLong(c);
             res.data().writeBytes(WebSocketUtil.md5(input.array()));
         } else {
-            // Old Hixie 75 handshake method with no challenge:
+            // Old Hixie 75 handshake getMethod with no challenge:
             res.headers().add(WEBSOCKET_ORIGIN, req.headers().get(ORIGIN));
             res.headers().add(WEBSOCKET_LOCATION, uri());
             String protocol = req.headers().get(WEBSOCKET_PROTOCOL);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -52,7 +52,7 @@ public WebSocketServerProtocolHandshakeHandler(String websocketPath, String subp
 
     @Override
     public void messageReceived(final ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
-        if (req.method() != GET) {
+        if (req.getMethod() != GET) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
             return;
         }
@@ -80,7 +80,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
     private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpResponse res) {
         ChannelFuture f = ctx.channel().write(res);
-        if (!isKeepAlive(req) || res.status().code() != 200) {
+        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
             f.addListener(ChannelFutureListener.CLOSE);
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
Patch:
@@ -35,11 +35,11 @@ public boolean isEncodable(Object msg) throws Exception {
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request)
             throws Exception {
-        buf.writeBytes(request.method().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(request.getMethod().toString().getBytes(CharsetUtil.US_ASCII));
         buf.writeByte((byte) ' ');
-        buf.writeBytes(request.uri().getBytes(CharsetUtil.UTF_8));
+        buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));
         buf.writeByte((byte) ' ');
-        buf.writeBytes(request.protocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(request.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
         buf.writeByte((byte) '\r');
         buf.writeByte((byte) '\n');
     }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
Patch:
@@ -35,11 +35,11 @@ public boolean isEncodable(Object msg) throws Exception {
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpResponse response)
             throws Exception {
-        buf.writeBytes(response.protocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
         buf.writeByte((byte) ' ');
-        buf.writeBytes(String.valueOf(response.status().code()).getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(String.valueOf(response.getStatus().code()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte((byte) ' ');
-        buf.writeBytes(String.valueOf(response.status().reasonPhrase()).getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(String.valueOf(response.getStatus().reasonPhrase()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte((byte) '\r');
         buf.writeByte((byte) '\n');
     }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseStatuses.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.handler.codec.http.HttpResponseStatus;
 
 /**
- * The status code and its description of a RTSP response.
+ * The getStatus code and its description of a RTSP response.
  * @apiviz.exclude
  */
 public final class RtspResponseStatuses {
@@ -262,7 +262,7 @@ public final class RtspResponseStatuses {
 
     /**
      * Returns the {@link HttpResponseStatus} represented by the specified code.
-     * If the specified code is a standard RTSP status code, a cached instance
+     * If the specified code is a standard RTSP getStatus code, a cached instance
      * will be returned.  Otherwise, a new instance will be returned.
      */
     public static HttpResponseStatus valueOf(int code) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
Patch:
@@ -48,7 +48,7 @@ public DefaultSpdyGoAwayFrame(int lastGoodStreamId, int statusCode) {
      * Creates a new instance.
      *
      * @param lastGoodStreamId the Last-good-stream-ID of this frame
-     * @param status           the status of this frame
+     * @param status           the getStatus of this frame
      */
     public DefaultSpdyGoAwayFrame(int lastGoodStreamId, SpdySessionStatus status) {
         setLastGoodStreamId(lastGoodStreamId);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
Patch:
@@ -39,7 +39,7 @@ public DefaultSpdyRstStreamFrame(int streamId, int statusCode) {
      * Creates a new instance.
      *
      * @param streamId the Stream-ID of this frame
-     * @param status   the status of this frame
+     * @param status   the getStatus of this frame
      */
     public DefaultSpdyRstStreamFrame(int streamId, SpdyStreamStatus status) {
         setStreamId(streamId);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
Patch:
@@ -32,12 +32,12 @@ public interface SpdyGoAwayFrame extends SpdyControlFrame {
     void setLastGoodStreamId(int lastGoodStreamId);
 
     /**
-     * Returns the status of this frame.
+     * Returns the getStatus of this frame.
      */
     SpdySessionStatus getStatus();
 
     /**
-     * Sets the status of this frame.
+     * Sets the getStatus of this frame.
      */
     void setStatus(SpdySessionStatus status);
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -133,7 +133,7 @@ public Object decode(ChannelHandlerContext ctx, Object msg) throws Exception {
                         messageMap.put(Integer.valueOf(streamID), httpRequestWithEntity);
                     }
                 } catch (Exception e) {
-                    // If a client sends a SYN_STREAM without all of the method, url (host and path),
+                    // If a client sends a SYN_STREAM without all of the getMethod, url (host and path),
                     // scheme, and version headers the server must reply with a HTTP 400 BAD REQUEST reply.
                     // Also sends HTTP 400 BAD REQUEST reply if header name/value pairs are invalid
                     SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamID);
@@ -163,7 +163,7 @@ public Object decode(ChannelHandlerContext ctx, Object msg) throws Exception {
                     messageMap.put(Integer.valueOf(streamID), httpResponseWithEntity);
                 }
             } catch (Exception e) {
-                // If a client receives a SYN_REPLY without valid status and version headers
+                // If a client receives a SYN_REPLY without valid getStatus and version headers
                 // the client must reply with a RST_STREAM frame indicating a PROTOCOL_ERROR
                 SpdyRstStreamFrame spdyRstStreamFrame =
                     new DefaultSpdyRstStreamFrame(streamID, SpdyStreamStatus.PROTOCOL_ERROR);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -154,7 +154,7 @@ protected void addHttpHandlers(ChannelHandlerContext ctx) {
      * when the {@link SelectedProtocol} was {@link SelectedProtocol#SpdyVersion2} or
      * {@link SelectedProtocol#SpdyVersion3}.
      *
-     * Bye default this method will just delecate to {@link #createHttpRequestHandlerForHttp()}, but
+     * Bye default this getMethod will just delecate to {@link #createHttpRequestHandlerForHttp()}, but
      * sub-classes may override this to change the behaviour.
      */
     protected ChannelInboundHandler createHttpRequestHandlerForSpdy() {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
Patch:
@@ -31,12 +31,12 @@ public interface SpdyRstStreamFrame extends SpdyControlFrame {
     void setStreamId(int streamID);
 
     /**
-     * Returns the status of this frame.
+     * Returns the getStatus of this frame.
      */
     SpdyStreamStatus getStatus();
 
     /**
-     * Sets the status of this frame.
+     * Sets the getStatus of this frame.
      */
     void setStatus(SpdyStreamStatus status);
 }

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -104,17 +104,17 @@ public class HttpStaticFileServerHandler extends ChannelInboundMessageHandlerAda
     public void messageReceived(
             ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
 
-        if (!request.decoderResult().isSuccess()) {
+        if (!request.getDecoderResult().isSuccess()) {
             sendError(ctx, BAD_REQUEST);
             return;
         }
 
-        if (request.method() != GET) {
+        if (request.getMethod() != GET) {
             sendError(ctx, METHOD_NOT_ALLOWED);
             return;
         }
 
-        final String uri = request.uri();
+        final String uri = request.getUri();
         final String path = sanitizeUri(uri);
         if (path == null) {
             sendError(ctx, FORBIDDEN);

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
Patch:
@@ -30,8 +30,8 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            System.out.println("STATUS: " + response.status());
-            System.out.println("VERSION: " + response.protocolVersion());
+            System.out.println("STATUS: " + response.getStatus());
+            System.out.println("VERSION: " + response.getProtocolVersion());
             System.out.println();
 
             if (!response.headers().isEmpty()) {

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
Patch:
@@ -229,7 +229,7 @@ private static List<InterfaceHttpData> formPost(Bootstrap bootstrap, String host
             // should not be since args are not null
             e.printStackTrace();
         } catch (ErrorDataEncoderException e) {
-            // test if method is a POST method
+            // test if getMethod is a POST getMethod
             e.printStackTrace();
         }
 
@@ -314,7 +314,7 @@ private static void formPostMultipart(Bootstrap bootstrap, String host, int port
             // should not be since no null args
             e.printStackTrace();
         } catch (ErrorDataEncoderException e) {
-            // test if method is a POST method
+            // test if getMethod is a POST getMethod
             e.printStackTrace();
         }
 

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -39,8 +39,8 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            logger.info("STATUS: " + response.status());
-            logger.info("VERSION: " + response.protocolVersion());
+            logger.info("STATUS: " + response.getStatus());
+            logger.info("VERSION: " + response.getProtocolVersion());
 
             if (!response.headers().isEmpty()) {
                 for (String name : response.headers().names()) {
@@ -50,7 +50,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
                 }
             }
 
-            if (response.status().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
+            if (response.getStatus().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
                 readingChunks = true;
                 logger.info("CHUNKED CONTENT {");
             } else {

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -90,7 +90,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
 
         if (msg instanceof FullHttpResponse) {
             FullHttpResponse response = (FullHttpResponse) msg;
-            throw new Exception("Unexpected FullHttpResponse (status=" + response.status() + ", content="
+            throw new Exception("Unexpected FullHttpResponse (getStatus=" + response.getStatus() + ", content="
                     + response.data().toString(CharsetUtil.UTF_8) + ')');
         }
 

File: example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java
Patch:
@@ -45,7 +45,7 @@
  * </pre>
  *
  * The html page is very simple were you simply enter some text and the server
- * will echo the same text back, but in uppercase. You, also see status messages
+ * will echo the same text back, but in uppercase. You, also see getStatus messages
  * in the "Response From Server" area when client has connected, disconnected
  * etc.
  *

File: example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * Keep reconnecting to the server while printing out the current uptime and
- * connection attempt status.
+ * connection attempt getStatus.
  */
 @Sharable
 public class UptimeClientHandler extends ChannelInboundByteHandlerAdapter {

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -134,7 +134,7 @@ public <T> ServerBootstrap childAttr(AttributeKey<T> childKey, T value) {
     }
 
     /**
-     * Set the {@link ChannelHandler} which is used to server the request for the {@link Channel}'s.
+     * Set the {@link ChannelHandler} which is used to serve the request for the {@link Channel}'s.
      */
     public ServerBootstrap childHandler(ChannelHandler childHandler) {
         if (childHandler == null) {

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1028,7 +1028,7 @@ public void run() {
 
     private void invokeUserEventTriggered(Object event) {
         try {
-            handler().userEventTriggered(next, event);
+            handler().userEventTriggered(this, event);
         } catch (Throwable t) {
             pipeline.notifyHandlerException(t);
         }

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -80,6 +80,7 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
     private Runnable invokeFreeInboundBuffer0Task;
     private Runnable invokeFreeOutboundBuffer0Task;
     private Runnable invokeRead0Task;
+    boolean removed;
 
     DefaultChannelHandlerContext(
             DefaultChannelPipeline pipeline, EventExecutorGroup group,
@@ -1084,7 +1085,7 @@ private void invokeInboundBufferUpdated() {
         } catch (Throwable t) {
             pipeline.notifyHandlerException(t);
         } finally {
-            if (handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {
+            if (!removed && handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {
                 try {
                     ((ChannelInboundByteHandler) handler).discardInboundReadBytes(this);
                 } catch (Throwable t) {
@@ -1424,7 +1425,7 @@ private void invokeFlush0(ChannelPromise promise) {
         } catch (Throwable t) {
             pipeline.notifyHandlerException(t);
         } finally {
-            if (handler instanceof ChannelOutboundByteHandler && !isOutboundBufferFreed()) {
+            if (!removed && handler instanceof ChannelOutboundByteHandler && !isOutboundBufferFreed()) {
                 try {
                     ((ChannelOutboundByteHandler) handler).discardOutboundReadBytes(this);
                 } catch (Throwable t) {

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -599,7 +599,7 @@ private static void callBeforeRemove(ChannelHandlerContext ctx) {
         }
     }
 
-    private void callAfterRemove(final ChannelHandlerContext ctx) {
+    private void callAfterRemove(final DefaultChannelHandlerContext ctx) {
         final ChannelHandler handler = ctx.handler();
 
         // Notify the complete removal.
@@ -622,6 +622,7 @@ public void run() {
         } else {
             freeHandlerBuffers(handler, ctx);
         }
+        ctx.removed = true;
     }
 
     private void freeHandlerBuffers(ChannelHandler handler, ChannelHandlerContext ctx) {

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -200,7 +200,7 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
             if (remoteAddress == null) {
                 return 0;
             }
-            buf.add(new DatagramPacket(buffer.writerIndex(buffer.writerIndex() + data.remaining()), remoteAddress));
+            buf.add(new DatagramPacket(buffer.writerIndex(buffer.writerIndex() + data.position()), remoteAddress));
             free = false;
             return 1;
         } catch (Throwable cause) {

File: transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
Patch:
@@ -126,7 +126,7 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
         } else if (option == IP_TOS) {
             setTrafficClass((Integer) value);
         } else if (option == UDP_RECEIVE_PACKET_SIZE) {
-          setReceivePacketSize((Integer) value);
+            setReceivePacketSize((Integer) value);
         } else {
             return super.setOption(option, value);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java
Patch:
@@ -24,7 +24,7 @@
  * @see HttpHeaders
  *
  * @apiviz.landmark
- * @apiviz.has io.netty.handler.codec.http.HttpChunk oneway - - is followed by
+ * @apiviz.has io.netty.handler.codec.http.HttpContent oneway - - is followed by
  */
 public interface HttpMessage extends HttpObject {
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
Patch:
@@ -44,7 +44,7 @@
  * p.addLast("handler", new HttpRequestHandler());
  * </pre>
  * @apiviz.landmark
- * @apiviz.has io.netty.handler.codec.http.HttpChunk oneway - - filters out
+ * @apiviz.has io.netty.handler.codec.http.HttpContent oneway - - filters out
  */
 public class HttpObjectAggregator extends MessageToMessageDecoder<HttpObject> {
     public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024;

File: buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java
Patch:
@@ -33,6 +33,7 @@
 /**
  * Tests channel buffers
  */
+@SuppressWarnings("ZeroLengthArrayAllocation")
 public class ChannelBuffersTest {
 
     @Test
@@ -50,6 +51,8 @@ public void testCompositeWrappedBuffer() {
 
         assertEquals(12 + 512, buffer.readableBytes());
         assertEquals(2, buffer.nioBufferCount());
+
+        buffer.free();
     }
 
     @Test

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Option for configuring a serial port connection
  */
-public class RxtxChannelOption<T> extends ChannelOption<T> {
+public final class RxtxChannelOption<T> extends ChannelOption<T> {
     public static final RxtxChannelOption<Integer> BAUD_RATE =
             new RxtxChannelOption<Integer>("BAUD_RATE");
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java
Patch:
@@ -54,7 +54,7 @@ public void validate(List<Integer> value) {
     public static final SctpChannelOption<SocketAddress> SCTP_SET_PEER_PRIMARY_ADDR =
             new SctpChannelOption<SocketAddress>("SCTP_SET_PEER_PRIMARY_ADDR");
 
-    private SctpChannelOption(String name) {
+    protected SctpChannelOption(String name) {
         super(name);
     }
 }

File: transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Options for the UDT transport
  */
-public class UdtChannelOption<T> extends ChannelOption<T> {
+public final class UdtChannelOption<T> extends ChannelOption<T> {
 
     /**
      * See {@link OptionUDT#Protocol_Receive_Buffer_Size}.

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -130,7 +130,7 @@ public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         expectedChallengeResponseBytes = WebSocketUtil.md5(challenge);
 
         // Get path
-        URI wsURL = getWebSocketUrl();
+        URI wsURL = uri();
         String path = wsURL.getPath();
         if (wsURL.getQuery() != null && !wsURL.getQuery().isEmpty()) {
             path = wsURL.getPath() + '?' + wsURL.getQuery();
@@ -159,7 +159,7 @@ public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
                .add(Names.SEC_WEBSOCKET_KEY1, key1)
                .add(Names.SEC_WEBSOCKET_KEY2, key2);
 
-        String expectedSubprotocol = getExpectedSubprotocol();
+        String expectedSubprotocol = expectedSubprotocol();
         if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {
             headers.add(Names.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
@@ -250,7 +250,7 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         ChannelPipeline p = channel.pipeline();
         p.remove(HttpRequestEncoder.class);
         p.get(HttpResponseDecoder.class).replace(
-                "ws-decoder", new WebSocket00FrameDecoder(getMaxFramePayloadLength()));
+                "ws-decoder", new WebSocket00FrameDecoder(maxFramePayloadLength()));
     }
 
     private static String insertRandomCharacters(String key) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -100,7 +100,7 @@ public WebSocketClientHandshaker07(URI webSocketURL, WebSocketVersion version, S
     @Override
     public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         // Get path
-        URI wsURL = getWebSocketUrl();
+        URI wsURL = uri();
         String path = wsURL.getPath();
         if (wsURL.getQuery() != null && !wsURL.getQuery().isEmpty()) {
             path = wsURL.getPath() + '?' + wsURL.getQuery();
@@ -141,7 +141,7 @@ public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         }
         headers.add(Names.SEC_WEBSOCKET_ORIGIN, originValue);
 
-        String expectedSubprotocol = getExpectedSubprotocol();
+        String expectedSubprotocol = expectedSubprotocol();
         if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {
             headers.add(Names.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
@@ -224,6 +224,6 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         ChannelPipeline p = channel.pipeline();
         p.get(HttpResponseDecoder.class).replace(
                 "ws-decoder",
-                new WebSocket07FrameDecoder(false, allowExtensions, getMaxFramePayloadLength()));
+                new WebSocket07FrameDecoder(false, allowExtensions, maxFramePayloadLength()));
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -100,7 +100,7 @@ public WebSocketClientHandshaker08(URI webSocketURL, WebSocketVersion version, S
     @Override
     public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         // Get path
-        URI wsURL = getWebSocketUrl();
+        URI wsURL = uri();
         String path = wsURL.getPath();
         if (wsURL.getQuery() != null && !wsURL.getQuery().isEmpty()) {
             path = wsURL.getPath() + '?' + wsURL.getQuery();
@@ -141,7 +141,7 @@ public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         }
         headers.add(Names.SEC_WEBSOCKET_ORIGIN, originValue);
 
-        String expectedSubprotocol = getExpectedSubprotocol();
+        String expectedSubprotocol = expectedSubprotocol();
         if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {
             headers.add(Names.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
@@ -225,6 +225,6 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         p.remove(HttpRequestEncoder.class);
         p.get(HttpResponseDecoder.class).replace(
                 "ws-decoder",
-                new WebSocket08FrameDecoder(false, allowExtensions, getMaxFramePayloadLength()));
+                new WebSocket08FrameDecoder(false, allowExtensions, maxFramePayloadLength()));
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -100,7 +100,7 @@ public WebSocketClientHandshaker13(URI webSocketURL, WebSocketVersion version, S
     @Override
     public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         // Get path
-        URI wsURL = getWebSocketUrl();
+        URI wsURL = uri();
         String path = wsURL.getPath();
         if (wsURL.getQuery() != null && !wsURL.getQuery().isEmpty()) {
             path = wsURL.getPath() + '?' + wsURL.getQuery();
@@ -141,7 +141,7 @@ public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {
         }
         headers.add(Names.SEC_WEBSOCKET_ORIGIN, originValue);
 
-        String expectedSubprotocol = getExpectedSubprotocol();
+        String expectedSubprotocol = expectedSubprotocol();
         if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {
             headers.add(Names.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);
         }
@@ -224,6 +224,6 @@ public void finishHandshake(Channel channel, FullHttpResponse response) {
         p.remove(HttpRequestEncoder.class);
         p.get(HttpResponseDecoder.class).replace(
                 "ws-decoder",
-                new WebSocket13FrameDecoder(false, allowExtensions, getMaxFramePayloadLength()));
+                new WebSocket13FrameDecoder(false, allowExtensions, maxFramePayloadLength()));
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -144,7 +144,7 @@ public ChannelFuture handshake(Channel channel, FullHttpRequest req, ChannelProm
         if (isHixie76) {
             // New handshake method with a challenge:
             res.headers().add(SEC_WEBSOCKET_ORIGIN, req.headers().get(ORIGIN));
-            res.headers().add(SEC_WEBSOCKET_LOCATION, getWebSocketUrl());
+            res.headers().add(SEC_WEBSOCKET_LOCATION, uri());
             String subprotocols = req.headers().get(SEC_WEBSOCKET_PROTOCOL);
             if (subprotocols != null) {
                 String selectedSubprotocol = selectSubprotocol(subprotocols);
@@ -172,7 +172,7 @@ public ChannelFuture handshake(Channel channel, FullHttpRequest req, ChannelProm
         } else {
             // Old Hixie 75 handshake method with no challenge:
             res.headers().add(WEBSOCKET_ORIGIN, req.headers().get(ORIGIN));
-            res.headers().add(WEBSOCKET_LOCATION, getWebSocketUrl());
+            res.headers().add(WEBSOCKET_LOCATION, uri());
             String protocol = req.headers().get(WEBSOCKET_PROTOCOL);
             if (protocol != null) {
                 res.headers().add(WEBSOCKET_PROTOCOL, selectSubprotocol(protocol));
@@ -189,7 +189,7 @@ public void operationComplete(ChannelFuture future) {
                     p.remove(HttpObjectAggregator.class);
                 }
                 p.get(HttpRequestDecoder.class).replace("wsdecoder",
-                        new WebSocket00FrameDecoder(getMaxFramePayloadLength()));
+                        new WebSocket00FrameDecoder(maxFramePayloadLength()));
 
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket00FrameEncoder());
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
Patch:
@@ -156,7 +156,7 @@ public void operationComplete(ChannelFuture future) {
                 }
 
                 p.get(HttpRequestDecoder.class).replace("wsdecoder",
-                        new WebSocket07FrameDecoder(true, allowExtensions, getMaxFramePayloadLength()));
+                        new WebSocket07FrameDecoder(true, allowExtensions, maxFramePayloadLength()));
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket07FrameEncoder(false));
             }
         });

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -156,7 +156,7 @@ public void operationComplete(ChannelFuture future) {
                 }
 
                 p.get(HttpRequestDecoder.class).replace("wsdecoder",
-                        new WebSocket08FrameDecoder(true, allowExtensions, getMaxFramePayloadLength()));
+                        new WebSocket08FrameDecoder(true, allowExtensions, maxFramePayloadLength()));
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket08FrameEncoder(false));
             }
         });

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -156,7 +156,7 @@ public void operationComplete(ChannelFuture future) {
                 }
 
                 p.get(HttpRequestDecoder.class).replace("wsdecoder",
-                        new WebSocket13FrameDecoder(true, allowExtensions, getMaxFramePayloadLength()));
+                        new WebSocket13FrameDecoder(true, allowExtensions, maxFramePayloadLength()));
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket13FrameEncoder(false));
             }
         });

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -96,7 +96,7 @@ private boolean initPipeline(ChannelHandlerContext ctx) {
             throw new IllegalStateException("SslHandler is needed for SPDY");
         }
 
-        SelectedProtocol protocol = getProtocol(handler.getEngine());
+        SelectedProtocol protocol = getProtocol(handler.engine());
         switch (protocol) {
         case None:
             // Not done with choosing the protocol, so just return here for now,

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -153,10 +153,8 @@ public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame msg) t
             content = "processed: " + msg.text();
         }
         
-        public String getContent() {
+        String getContent() {
             return content;
         }
-
     }
-    
 }

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequest.java
Patch:
@@ -59,7 +59,7 @@ public SocksAuthRequest(String username, String password) {
      *
      * @return username that needs to be authenticated
      */
-    public String getUsername() {
+    public String username() {
         return username;
     }
 
@@ -68,7 +68,7 @@ public String getUsername() {
      *
      * @return password that needs to be validated
      */
-    public String getPassword() {
+    public String password() {
         return password;
     }
 

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponse.java
Patch:
@@ -40,7 +40,7 @@ public SocksAuthResponse(AuthStatus authStatus) {
      *
      * @return The {@link AuthStatus} of this {@link SocksAuthResponse}
      */
-    public AuthStatus getAuthStatus() {
+    public AuthStatus authStatus() {
         return authStatus;
     }
 

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java
Patch:
@@ -51,7 +51,7 @@ public SocksCmdResponse(CmdStatus cmdStatus, AddressType addressType) {
      *
      * @return The {@link CmdStatus} of this {@link SocksCmdResponse}
      */
-    public CmdStatus getCmdStatus() {
+    public CmdStatus cmdStatus() {
         return cmdStatus;
     }
 
@@ -60,13 +60,13 @@ public CmdStatus getCmdStatus() {
      *
      * @return The {@link AddressType} of this {@link SocksCmdResponse}
      */
-    public AddressType getAddressType() {
+    public AddressType addressType() {
         return addressType;
     }
 
     @Override
     public void encodeAsByteBuf(ByteBuf byteBuf) {
-        byteBuf.writeByte(getProtocolVersion().getByteValue());
+        byteBuf.writeByte(protocolVersion().getByteValue());
         byteBuf.writeByte(cmdStatus.getByteValue());
         byteBuf.writeByte(0x00);
         byteBuf.writeByte(addressType.getByteValue());

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequest.java
Patch:
@@ -42,13 +42,13 @@ public SocksInitRequest(List<AuthScheme> authSchemes) {
      *
      * @return The List<{@link AuthScheme}> of this {@link SocksInitRequest}
      */
-    public List<AuthScheme> getAuthSchemes() {
+    public List<AuthScheme> authSchemes() {
         return Collections.unmodifiableList(authSchemes);
     }
 
     @Override
     public void encodeAsByteBuf(ByteBuf byteBuf) {
-        byteBuf.writeByte(getProtocolVersion().getByteValue());
+        byteBuf.writeByte(protocolVersion().getByteValue());
         byteBuf.writeByte(authSchemes.size());
         for (AuthScheme authScheme : authSchemes) {
             byteBuf.writeByte(authScheme.getByteValue());

File: codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponse.java
Patch:
@@ -39,13 +39,13 @@ public SocksInitResponse(AuthScheme authScheme) {
      *
      * @return The {@link AuthScheme} of this {@link SocksInitResponse}
      */
-    public AuthScheme getAuthScheme() {
+    public AuthScheme authScheme() {
         return authScheme;
     }
 
     @Override
     public void encodeAsByteBuf(ByteBuf byteBuf) {
-        byteBuf.writeByte(getProtocolVersion().getByteValue());
+        byteBuf.writeByte(protocolVersion().getByteValue());
         byteBuf.writeByte(authScheme.getByteValue());
     }
 }

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
Patch:
@@ -31,7 +31,7 @@ private static void testSocksAuthResponseDecoderWithDifferentParams(SocksMessage
         EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         msg = (SocksAuthResponse) embedder.readInbound();
-        assertSame(msg.getAuthStatus(), authStatus);
+        assertSame(msg.authStatus(), authStatus);
         assertNull(embedder.readInbound());
     }
 

File: codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
Patch:
@@ -35,7 +35,7 @@ private static void testSocksCmdResponseDecoderWithDifferentParams(SocksMessage.
             assertTrue(embedder.readInbound() instanceof UnknownSocksResponse);
         } else {
             msg = (SocksResponse) embedder.readInbound();
-            assertEquals(((SocksCmdResponse) msg).getCmdStatus(), cmdStatus);
+            assertEquals(((SocksCmdResponse) msg).cmdStatus(), cmdStatus);
         }
         assertNull(embedder.readInbound());
     }

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerInitializer.java
Patch:
@@ -32,7 +32,7 @@ public class WebSocketSslServerInitializer extends ChannelInitializer<SocketChan
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
 
-        SSLEngine engine = WebSocketSslServerSslContext.getInstance().getServerContext().createSSLEngine();
+        SSLEngine engine = WebSocketSslServerSslContext.getInstance().serverContext().createSSLEngine();
         engine.setUseClientMode(false);
         pipeline.addLast("ssl", new SslHandler(engine));
 

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java
Patch:
@@ -95,7 +95,7 @@ private WebSocketSslServerSslContext() {
     /**
      * Returns the server context with server side key store
      */
-    public SSLContext getServerContext() {
+    public SSLContext serverContext() {
         return _serverContext;
     }
 

File: example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
Patch:
@@ -50,7 +50,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                         " secure chat service!\n");
                 ctx.write(
                         "Your session is protected by " +
-                        ctx.pipeline().get(SslHandler.class).getEngine().getSession().getCipherSuite() +
+                        ctx.pipeline().get(SslHandler.class).engine().getSession().getCipherSuite() +
                         " cipher suite.\n");
 
                 channels.add(ctx.channel());

File: example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
Patch:
@@ -49,7 +49,7 @@ public void messageReceived(final ChannelHandlerContext ctx, final SocksCmdReque
         CallbackNotifier cb = new CallbackNotifier() {
             @Override
             public void onSuccess(final ChannelHandlerContext outboundCtx) {
-                ctx.channel().write(new SocksCmdResponse(SocksMessage.CmdStatus.SUCCESS, request.getAddressType()))
+                ctx.channel().write(new SocksCmdResponse(SocksMessage.CmdStatus.SUCCESS, request.addressType()))
                              .addListener(new ChannelFutureListener() {
                     @Override
                     public void operationComplete(ChannelFuture channelFuture) throws Exception {
@@ -62,7 +62,7 @@ public void operationComplete(ChannelFuture channelFuture) throws Exception {
 
             @Override
             public void onFailure(ChannelHandlerContext outboundCtx, Throwable cause) {
-                ctx.channel().write(new SocksCmdResponse(SocksMessage.CmdStatus.FAILURE, request.getAddressType()));
+                ctx.channel().write(new SocksCmdResponse(SocksMessage.CmdStatus.FAILURE, request.addressType()));
                 SocksServerUtils.closeOnFlush(ctx.channel());
             }
         };
@@ -73,7 +73,7 @@ public void onFailure(ChannelHandlerContext outboundCtx, Throwable cause) {
                 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                 .option(ChannelOption.SO_KEEPALIVE, true)
                 .handler(new DirectClientInitializer(cb))
-                .remoteAddress(request.getHost(), request.getPort());
+                .remoteAddress(request.host(), request.port());
         b.connect();
     }
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -268,7 +268,7 @@ public void setCloseNotifyTimeoutMillis(long closeNotifyTimeoutMillis) {
     /**
      * Returns the {@link SSLEngine} which is used by this handler.
      */
-    public SSLEngine getEngine() {
+    public SSLEngine engine() {
         return engine;
     }
 

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
Patch:
@@ -103,7 +103,7 @@ protected void doWriteBytes(ByteBuf buf) throws Exception {
     @Override
     protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
         RxtxDeviceAddress remote = (RxtxDeviceAddress) remoteAddress;
-        final CommPortIdentifier cpi = CommPortIdentifier.getPortIdentifier(remote.getDeviceAddress());
+        final CommPortIdentifier cpi = CommPortIdentifier.getPortIdentifier(remote.value());
         final CommPort commPort = cpi.open(getClass().getName(), 1000);
 
         deviceAddress = remote;

File: transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java
Patch:
@@ -108,7 +108,7 @@ public interface ChannelGroupFuture extends Iterable<ChannelFuture> {
     /**
      * Returns the {@link ChannelGroup} which is associated with this future.
      */
-    ChannelGroup getGroup();
+    ChannelGroup group();
 
     /**
      * Returns the {@link ChannelFuture} of the individual I/O operation which

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -115,7 +115,7 @@ public DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> f
     }
 
     @Override
-    public ChannelGroup getGroup() {
+    public ChannelGroup group() {
         return group;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -52,7 +52,7 @@ public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(getClass().getSimpleName());
         buf.append("(version: ");
-        buf.append(protocolVersion().getText());
+        buf.append(protocolVersion().text());
         buf.append(", keepAlive: ");
         buf.append(HttpHeaders.isKeepAlive(this));
         buf.append(')');

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java
Patch:
@@ -66,7 +66,7 @@ public String toString() {
         buf.append(' ');
         buf.append(uri());
         buf.append(' ');
-        buf.append(protocolVersion().getText());
+        buf.append(protocolVersion().text());
         buf.append(StringUtil.NEWLINE);
         appendHeaders(buf);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java
Patch:
@@ -51,7 +51,7 @@ public String toString() {
         buf.append(decoderResult());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
-        buf.append(protocolVersion().getText());
+        buf.append(protocolVersion().text());
         buf.append(' ');
         buf.append(status().toString());
         buf.append(StringUtil.NEWLINE);

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -174,7 +174,7 @@ public QueryStringDecoder(URI uri, Charset charset, int maxParams) {
     /**
      * Returns the decoded path string of the URI.
      */
-    public String getPath() {
+    public String path() {
         if (path == null) {
             if (!hasPath) {
                 return path = "";
@@ -193,10 +193,10 @@ public String getPath() {
     /**
      * Returns the decoded key-value parameter pairs of the URI.
      */
-    public Map<String, List<String>> getParameters() {
+    public Map<String, List<String>> parameters() {
         if (params == null) {
             if (hasPath) {
-                int pathLength = getPath().length();
+                int pathLength = path().length();
                 if (uri.length() == pathLength) {
                     return Collections.emptyMap();
                 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
Patch:
@@ -350,9 +350,9 @@ public static HttpVersion getVersion(int spdyVersion, SpdyHeaderBlock block) {
      */
     public static void setVersion(int spdyVersion, SpdyHeaderBlock block, HttpVersion httpVersion) {
         if (spdyVersion < 3) {
-            block.setHeader(Spdy2HttpNames.VERSION, httpVersion.getText());
+            block.setHeader(Spdy2HttpNames.VERSION, httpVersion.text());
         } else {
-            block.setHeader(HttpNames.VERSION, httpVersion.getText());
+            block.setHeader(HttpNames.VERSION, httpVersion.text());
         }
     }
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -81,7 +81,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
             }
 
             QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.uri());
-            Map<String, List<String>> params = queryStringDecoder.getParameters();
+            Map<String, List<String>> params = queryStringDecoder.parameters();
             if (!params.isEmpty()) {
                 for (Entry<String, List<String>> p: params.entrySet()) {
                     String key = p.getKey();

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -113,7 +113,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
             responseContent.append("WELCOME TO THE WILD WILD WEB SERVER\r\n");
             responseContent.append("===================================\r\n");
 
-            responseContent.append("VERSION: " + request.protocolVersion().getText() + "\r\n");
+            responseContent.append("VERSION: " + request.protocolVersion().text() + "\r\n");
 
             responseContent.append("REQUEST_URI: " + request.uri() + "\r\n\r\n");
             responseContent.append("\r\n\r\n");
@@ -139,7 +139,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
             responseContent.append("\r\n\r\n");
 
             QueryStringDecoder decoderQuery = new QueryStringDecoder(request.uri());
-            Map<String, List<String>> uriAttributes = decoderQuery.getParameters();
+            Map<String, List<String>> uriAttributes = decoderQuery.parameters();
             for (Entry<String, List<String>> attr: uriAttributes.entrySet()) {
                 for (String attrVal: attr.getValue()) {
                     responseContent.append("URI: " + attr.getKey() + '=' + attrVal + "\r\n");

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -85,16 +85,14 @@ public class ChannelOption<T> extends UniqueName {
     /**
      * Create a new {@link ChannelOption} with the given name. The name needs to be
      * unique.
-     *
      */
-    public ChannelOption(String name) {
+    protected ChannelOption(String name) {
         super(names, name);
     }
 
     /**
      * Validate the value which is set for the {@link ChannelOption}. Sub-classes
      * may override this for special checks.
-     *
      */
     public void validate(T value) {
         if (value == null) {

File: buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
Patch:
@@ -140,7 +140,7 @@ public long getLong(int index) {
 
     @Override
     public ByteBuf duplicate() {
-        ByteBuf duplicate = new SlicedByteBuf(buffer, adjustment, length);
+        ByteBuf duplicate = buffer.slice(adjustment, length);
         duplicate.setIndex(readerIndex(), writerIndex());
         return duplicate;
     }
@@ -157,7 +157,8 @@ public ByteBuf slice(int index, int length) {
         if (length == 0) {
             return Unpooled.EMPTY_BUFFER;
         }
-        return new SlicedByteBuf(buffer, index + adjustment, length);
+        return buffer.slice(index + adjustment, length);
+        //new SlicedByteBuf(buffer, index + adjustment, length);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
Patch:
@@ -59,7 +59,7 @@ public ByteBuf order(ByteOrder endianness) {
 
     @Override
     public ByteBuf unwrap() {
-        return buf;
+        return buf.unwrap();
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibCompressor.java
Patch:
@@ -51,8 +51,9 @@ public void setInput(ByteBuf decompressed) {
 
     @Override
     public void encode(ByteBuf compressed) {
-        while (!compressor.needsInput()) {
-            int numBytes = compressor.deflate(out, 0, out.length, Deflater.SYNC_FLUSH);
+        int numBytes = out.length;
+        while (numBytes == out.length) {
+            numBytes = compressor.deflate(out, 0, out.length, Deflater.SYNC_FLUSH);
             compressed.writeBytes(out, 0, numBytes);
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibCompressor.java
Patch:
@@ -51,8 +51,9 @@ public void setInput(ByteBuf decompressed) {
 
     @Override
     public void encode(ByteBuf compressed) {
-        while (!compressor.needsInput()) {
-            int numBytes = compressor.deflate(out, 0, out.length, Deflater.SYNC_FLUSH);
+        int numBytes = out.length;
+        while (numBytes == out.length) {
+            numBytes = compressor.deflate(out, 0, out.length, Deflater.SYNC_FLUSH);
             compressed.writeBytes(out, 0, numBytes);
         }
     }

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpObjecctAggregatorTest.java
Patch:
@@ -29,7 +29,7 @@
 
 import static org.junit.Assert.*;
 
-public class FullHttpMessageDecoderTest {
+public class HttpObjecctAggregatorTest {
 
     @Test
     public void testAggregate() {

File: codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
Patch:
@@ -22,7 +22,7 @@
  * the HTTP cookie version 0, 1, and 2.
  * <pre>
  * // Example
- * {@link HttpRequestHeader} req = ...;
+ * {@link HttpRequest} req = ...;
  * res.setHeader("Cookie", {@link ClientCookieEncoder}.encode("JSESSIONID", "1234"));
  * </pre>
  *

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -29,7 +29,7 @@
  * the HTTP cookie version 0, 1, and 2.
  *
  * <pre>
- * {@link HttpRequestHeader} req = ...;
+ * {@link HttpRequest} req = ...;
  * String value = req.getHeader("Cookie");
  * Set&lt;{@link Cookie}&gt; cookies = new {@link CookieDecoder}().decode(value);
  * </pre>

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.util.internal.StringUtil;
 
 /**
- * Compresses an {@link HttpHeader} and an {@link HttpContent} in {@code gzip} or
+ * Compresses an {@link HttpMessage} and an {@link HttpContent} in {@code gzip} or
  * {@code deflate} encoding while respecting the {@code "Accept-Encoding"} header.
  * If there is no matching encoding, no compression is done.  For more
  * information on how this handler modifies the message, please refer to
@@ -93,8 +93,8 @@ public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel)
     }
 
     @Override
-    protected Result beginEncode(HttpHeader header, HttpContent msg, String acceptEncoding) throws Exception {
-        String contentEncoding = header.getHeader(HttpHeaders.Names.CONTENT_ENCODING);
+    protected Result beginEncode(HttpMessage header, HttpContent msg, String acceptEncoding) throws Exception {
+        String contentEncoding = header.headers().get(HttpHeaders.Names.CONTENT_ENCODING);
         if (contentEncoding != null &&
             !HttpHeaders.Values.IDENTITY.equalsIgnoreCase(contentEncoding)) {
             return null;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.handler.codec.compression.ZlibWrapper;
 
 /**
- * Decompresses an {@link HttpHeader} and an {@link HttpContent} compressed in
+ * Decompresses an {@link HttpMessage} and an {@link HttpContent} compressed in
  * {@code gzip} or {@code deflate} encoding.  For more information on how this
  * handler modifies the message, please refer to {@link HttpContentDecoder}.
  */

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -54,7 +54,7 @@
  * @see QueryStringEncoder
  *
  * @apiviz.stereotype utility
- * @apiviz.has        io.netty.handler.codec.http.HttpRequest oneway - - decodes
+ * @apiviz.has        io.netty.handler.codec.http.FullHttpRequest oneway - - decodes
  */
 public class QueryStringDecoder {
 

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -36,7 +36,7 @@
  * @see QueryStringDecoder
  *
  * @apiviz.stereotype utility
- * @apiviz.has        io.netty.handler.codec.http.HttpRequest oneway - - encodes
+ * @apiviz.has        io.netty.handler.codec.http.FullHttpRequest oneway - - encodes
  */
 public class QueryStringEncoder {
 

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -15,19 +15,19 @@
  */
 package io.netty.handler.codec.http;
 
-import static io.netty.handler.codec.http.CookieEncoderUtil.*;
-
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
 import java.util.List;
 
+import static io.netty.handler.codec.http.CookieEncoderUtil.*;
+
 /**
  * Encodes server-side {@link Cookie}s into HTTP header values.  This encoder can encode
  * the HTTP cookie version 0, 1, and 2.
  * <pre>
  * // Example
- * {@link HttpRequestHeader} req = ...;
+ * {@link HttpRequest} req = ...;
  * res.setHeader("Set-Cookie", {@link ServerCookieEncoder}.encode("JSESSIONID", "1234"));
  * </pre>
  *

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.FullHttpResponse;
 
 import java.net.URI;
 import java.util.Map;
@@ -148,5 +148,5 @@ public ChannelFuture handshake(Channel channel) {
      * @param response
      *            HTTP response containing the closing handshake details
      */
-    public abstract void finishHandshake(Channel channel, HttpResponse response);
+    public abstract void finishHandshake(Channel channel, FullHttpResponse response);
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.util.internal.StringUtil;
 
 import java.util.Collections;
@@ -112,7 +112,7 @@ public int getMaxFramePayloadLength() {
      * @param req
      *            HTTP Request
      */
-    public ChannelFuture handshake(Channel channel, HttpRequest req) {
+    public ChannelFuture handshake(Channel channel, FullHttpRequest req) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }
@@ -129,7 +129,7 @@ public ChannelFuture handshake(Channel channel, HttpRequest req) {
      * @param promise
      *            the {@link ChannelPromise} to be notified when the opening handshake is done
      */
-    public abstract ChannelFuture handshake(Channel channel, HttpRequest req, ChannelPromise promise);
+    public abstract ChannelFuture handshake(Channel channel, FullHttpRequest req, ChannelPromise promise);
 
     /**
      * Performs the closing handshake

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
Patch:
@@ -196,9 +196,9 @@ public static HttpMethod getMethod(int spdyVersion, SpdyHeaderBlock block) {
      */
     public static void setMethod(int spdyVersion, SpdyHeaderBlock block, HttpMethod method) {
         if (spdyVersion < 3) {
-            block.setHeader(Spdy2HttpNames.METHOD, method.getName());
+            block.setHeader(Spdy2HttpNames.METHOD, method.name());
         } else {
-            block.setHeader(HttpNames.METHOD, method.getName());
+            block.setHeader(HttpNames.METHOD, method.name());
         }
     }
 
@@ -264,7 +264,7 @@ public static HttpResponseStatus getStatus(int spdyVersion, SpdyHeaderBlock bloc
                 int code = Integer.parseInt(status.substring(0, space));
                 String reasonPhrase = status.substring(space + 1);
                 HttpResponseStatus responseStatus = HttpResponseStatus.valueOf(code);
-                if (responseStatus.getReasonPhrase().equals(reasonPhrase)) {
+                if (responseStatus.reasonPhrase().equals(reasonPhrase)) {
                     return responseStatus;
                 } else {
                     return new HttpResponseStatus(code, reasonPhrase);

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.handler.codec.http.HttpContentCompressor;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
 
@@ -38,7 +37,7 @@ public void initChannel(SocketChannel ch) throws Exception {
         //pipeline.addLast("aggregator", new HttpChunkAggregator(1048576));
         p.addLast("encoder", new HttpResponseEncoder());
         // Remove the following line if you don't want automatic content compression.
-        p.addLast("deflater", new HttpContentCompressor());
+        //p.addLast("deflater", new HttpContentCompressor());
         p.addLast("handler", new HttpSnoopServerHandler());
     }
 }

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -44,6 +44,7 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpRequestEncoder;
 import io.netty.handler.codec.http.HttpResponseDecoder;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
@@ -91,6 +92,7 @@ public void initChannel(SocketChannel ch) throws Exception {
                      ChannelPipeline pipeline = ch.pipeline();
                      pipeline.addLast("decoder", new HttpResponseDecoder());
                      pipeline.addLast("encoder", new HttpRequestEncoder());
+                     pipeline.addLast("aggregator", new HttpObjectAggregator(8192));
                      pipeline.addLast("ws-handler", handler);
                  }
              });
@@ -101,7 +103,7 @@ public void initChannel(SocketChannel ch) throws Exception {
 
             // Send 10 messages and wait for responses
             System.out.println("WebSocket Client sending message");
-            for (int i = 0; i < 1; i++) {
+            for (int i = 0; i < 10; i++) {
                 ch.write(new TextWebSocketFrame("Message #" + i));
             }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -578,7 +578,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
             }
         }
 
-        while (numHeaders -- > 0) {
+        while (numHeaders > 0) {
             int headerSize = this.headerSize;
             decompressed.markReaderIndex();
 
@@ -638,6 +638,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
                     return;
                 } else {
                     spdyHeaderBlock.addHeader(name, "");
+                    numHeaders --;
                     this.headerSize = headerSize;
                     continue;
                 }
@@ -683,6 +684,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
                 index ++;
                 offset = index;
             }
+            numHeaders --;
             this.headerSize = headerSize;
         }
         decompressed = null;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -578,7 +578,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
             }
         }
 
-        while (numHeaders -- > 0) {
+        while (numHeaders > 0) {
             int headerSize = this.headerSize;
             decompressed.markReaderIndex();
 
@@ -638,6 +638,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
                     return;
                 } else {
                     spdyHeaderBlock.addHeader(name, "");
+                    numHeaders --;
                     this.headerSize = headerSize;
                     continue;
                 }
@@ -683,6 +684,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
                 index ++;
                 offset = index;
             }
+            numHeaders --;
             this.headerSize = headerSize;
         }
         decompressed = null;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -249,6 +249,7 @@ private SpdySynStreamFrame createSynStreamFrame(HttpMessage httpMessage)
             HttpResponse httpResponse = (HttpResponse) httpMessage;
             SpdyHeaders.setStatus(spdyVersion, spdySynStreamFrame, httpResponse.getStatus());
             SpdyHeaders.setUrl(spdyVersion, spdySynStreamFrame, URL);
+            SpdyHeaders.setVersion(spdyVersion, spdySynStreamFrame, httpMessage.getProtocolVersion());
             spdySynStreamFrame.setUnidirectional(true);
         }
 

File: buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.internal.PlatformDependent;
 import sun.misc.Unsafe;
 
 import java.io.IOException;
@@ -57,7 +58,7 @@ final class PooledUnsafeDirectByteBuf extends PooledByteBuf<ByteBuffer> {
             if (addressField.getLong(directBuf) == 0) {
                 throw new Error("direct buffer address must be non-zero");
             }
-            UnpooledDirectByteBuf.freeDirect(directBuf);
+            PlatformDependent.freeDirectBuffer(directBuf);
         } catch (Throwable t) {
             throw new Error(t);
         }
@@ -120,7 +121,7 @@ public short getShort(int index) {
     public int getUnsignedMedium(int index) {
         checkIndex(index, 3);
         long addr = addr(index);
-        return (UNSAFE.getByte(addr) & 0xff) << 16 |(UNSAFE.getByte(addr + 1) & 0xff) << 8 |
+        return (UNSAFE.getByte(addr) & 0xff) << 16 | (UNSAFE.getByte(addr + 1) & 0xff) << 8 |
                 UNSAFE.getByte(addr + 2) & 0xff;
     }
 

File: common/src/main/java/io/netty/util/internal/PlatformDependent0.java
Patch:
@@ -96,7 +96,6 @@ static long objectFieldOffset(Field field) {
         return UNSAFE.objectFieldOffset(field);
     }
 
-
     private PlatformDependent0() {
     }
 }

File: buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.buffer;
 
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -699,7 +699,7 @@ public CompositeByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int lengt
     @Override
     public int getBytes(int index, GatheringByteChannel out, int length)
             throws IOException {
-        if (DetectionUtil.javaVersion() < 7) {
+        if (PlatformDependent.javaVersion() < 7) {
             // XXX Gathering write is not supported because of a known issue.
             //     See http://bugs.sun.com/view_bug.do?bug_id=6210541
             return out.write(copiedNioBuffer(index, length));

File: buffer/src/main/java/io/netty/buffer/PoolArena.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 
 import java.nio.ByteBuffer;
@@ -370,7 +371,7 @@ protected PoolChunk<ByteBuffer> newUnpooledChunk(int capacity) {
 
         @Override
         protected void destroyChunk(PoolChunk<ByteBuffer> chunk) {
-            UnpooledDirectByteBuf.freeDirect(chunk.memory);
+            PlatformDependent.freeDirectBuffer(chunk.memory);
         }
 
         @Override

File: buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.buffer;
 
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 /**
  * Simplistic {@link ByteBufAllocator} implementation that does not pool anything.
@@ -41,7 +41,7 @@ protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
 
     @Override
     public ByteBuf ioBuffer() {
-        if (DetectionUtil.canFreeDirectBuffer()) {
+        if (PlatformDependent.canFreeDirectBuffer()) {
             return directBuffer(0);
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java
Patch:
@@ -16,14 +16,14 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 abstract class SpdyHeaderBlockCompressor {
 
     static SpdyHeaderBlockCompressor newInstance(
             int version, int compressionLevel, int windowBits, int memLevel) {
 
-        if (DetectionUtil.javaVersion() >= 7) {
+        if (PlatformDependent.javaVersion() >= 7) {
             return new SpdyHeaderBlockZlibCompressor(
                     version, compressionLevel);
         } else {

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.monitor.MonitorName;
 import io.netty.monitor.MonitorRegistry;
 import io.netty.monitor.ValueDistributionMonitor;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SharedResourceMisuseDetector;
 
 import java.util.ArrayList;
@@ -548,7 +548,7 @@ private long waitForNextTick() {
                 // the JVM if it runs on windows.
                 //
                 // See https://github.com/netty/netty/issues/356
-                if (DetectionUtil.isWindows()) {
+                if (PlatformDependent.isWindows()) {
                     sleepTime = sleepTime / 10 * 10;
                 }
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -30,7 +30,7 @@
 import io.netty.channel.DefaultChannelPromise;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLEngineResult;
@@ -659,7 +659,7 @@ private boolean ignoreException(Throwable t) {
                     }
 
                     // also match against SctpChannel via String matching as it may not present.
-                    if (DetectionUtil.javaVersion() >= 7
+                    if (PlatformDependent.javaVersion() >= 7
                             && "com.sun.nio.sctp.SctpChannel".equals(clazz.getSuperclass().getName())) {
                         return true;
                     }

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
 import io.netty.util.DefaultAttributeMap;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -631,7 +631,7 @@ public final void bind(final SocketAddress localAddress, final ChannelPromise pr
                     boolean wasActive = isActive();
 
                     // See: https://github.com/netty/netty/issues/576
-                    if (!DetectionUtil.isWindows() && !DetectionUtil.isRoot() &&
+                    if (!PlatformDependent.isWindows() && !PlatformDependent.isRoot() &&
                         Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&
                         localAddress instanceof InetSocketAddress &&
                         !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress()) {

File: transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
 import java.net.DatagramSocket;
@@ -146,7 +146,7 @@ public DatagramChannelConfig setBroadcast(boolean broadcast) {
         try {
             // See: https://github.com/netty/netty/issues/576
             if (broadcast &&
-                !DetectionUtil.isWindows() && !DetectionUtil.isRoot() &&
+                !PlatformDependent.isWindows() && !PlatformDependent.isRoot() &&
                 !javaSocket.getLocalAddress().isAnyLocalAddress()) {
                 // Warn a user about the fact that a non-root user can't receive a
                 // broadcast packet on *nix if the socket is bound on non-wildcard address.

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java
Patch:
@@ -22,7 +22,7 @@
 import io.netty.channel.MultithreadEventLoopGroup;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
 import java.nio.channels.AsynchronousChannelGroup;
@@ -44,7 +44,7 @@ public class AioEventLoopGroup extends MultithreadEventLoopGroup {
     static {
         AioChannelFinder finder;
         try {
-            if (DetectionUtil.hasUnsafe()) {
+            if (PlatformDependent.hasUnsafe()) {
                 finder = new UnsafeAioChannelFinder();
             } else {
                 finder = new ReflectiveAioChannelFinder();

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.socket.DatagramChannelConfig;
 import io.netty.channel.socket.DefaultDatagramChannelConfig;
-import io.netty.util.internal.DetectionUtil;
+import io.netty.util.internal.PlatformDependent;
 
 import java.lang.reflect.Method;
 import java.net.InetAddress;
@@ -162,7 +162,7 @@ public DatagramChannelConfig setLoopbackModeDisabled(boolean loopbackModeDisable
     }
 
     private Object getOption0(Object option) {
-        if (DetectionUtil.javaVersion() < 7) {
+        if (PlatformDependent.javaVersion() < 7) {
             throw new UnsupportedOperationException();
         } else {
             try {
@@ -174,7 +174,7 @@ private Object getOption0(Object option) {
     }
 
     private void setOption0(Object option, Object value) {
-        if (DetectionUtil.javaVersion() < 7) {
+        if (PlatformDependent.javaVersion() < 7) {
             throw new UnsupportedOperationException();
         } else {
             try {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
Patch:
@@ -223,7 +223,6 @@ public void finishHandshake(Channel channel, HttpResponse response) {
         setHandshakeComplete();
 
         ChannelPipeline p = channel.pipeline();
-        p.remove(HttpRequestEncoder.class);
         p.get(HttpResponseDecoder.class).replace(
                 "ws-decoder",
                 new WebSocket07FrameDecoder(false, allowExtensions, getMaxFramePayloadLength()));

File: buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
Patch:
@@ -248,7 +248,7 @@ public ByteBuf copy(int index, int length) {
         checkIndex(index, length);
         ByteBuf copy = alloc().directBuffer(capacity(), maxCapacity());
         copy.writeBytes(this, index, length);
-        return copy();
+        return copy;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
Patch:
@@ -218,7 +218,7 @@ public ByteBuf copy(int index, int length) {
         checkIndex(index, length);
         ByteBuf copy = alloc().heapBuffer(length, maxCapacity());
         copy.writeBytes(memory, idx(index), length);
-        return copy();
+        return copy;
     }
 
     @Override

File: example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
Patch:
@@ -26,7 +26,7 @@
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.util.CharsetUtil;
 
-import javax.swing.*;
+import javax.swing.JApplet;
 
 /**
  * {@link JApplet} which starts up a Server that receive data and discard it.

File: buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java
Patch:
@@ -131,7 +131,7 @@ public Object[] toArray() {
     }
 
     @Override
-    public <T1 extends Object> T1[] toArray(T1[] a) {
+    public <T1> T1[] toArray(T1[] a) {
         ensureValid();
         return super.toArray(a);
     }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;

File: common/src/main/java/io/netty/util/internal/DetectionUtil.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.util.internal;
 
 import sun.misc.Cleaner;
+import sun.misc.Unsafe;
 
 import java.lang.reflect.Field;
 import java.net.InetSocketAddress;
@@ -119,7 +120,7 @@ public static boolean isRoot() {
     }
 
     /**
-     * Return {@code true} if {@link sun.misc.Unsafe} was found on the classpath and can be used.
+     * Return {@code true} if {@link Unsafe} was found on the classpath and can be used.
      */
     public static boolean hasUnsafe() {
         return HAS_UNSAFE;

File: example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
Patch:
@@ -15,14 +15,12 @@
  */
 package io.netty.example.udt.echo.message;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.transport.udt.UdtMessage;
 import io.netty.transport.udt.nio.NioUdtProvider;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -52,7 +50,6 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
     @Override
     protected void messageReceived(final ChannelHandlerContext ctx,
             final UdtMessage message) throws Exception {
-        final ByteBuf byteBuf = message.data();
         final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
         out.add(message);
         ctx.flush();

File: example/src/main/java/io/netty/example/udt/util/UtilThreadFactory.java
Patch:
@@ -35,6 +35,5 @@ public UtilThreadFactory(final String name) {
     @Override
     public Thread newThread(final Runnable runnable) {
         return new Thread(runnable, name + "-" + counter.getAndIncrement());
-    };
-
+    }
 }

File: handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java
Patch:
@@ -33,7 +33,7 @@ public final class IdleStateEvent {
      * Create a new instance
      *
      * @param state             the detailed idle state.
-     * @param count             the count how often this kind of {@IdleStateEvent} was fired before
+     * @param count             the count how often this kind of {@link IdleStateEvent} was fired before
      * @param durationMillis    the duration which caused the {@link IdleStateEvent} to get fired in milliseconds
      */
     public IdleStateEvent(IdleState state, int count, long durationMillis) {
@@ -61,7 +61,7 @@ public IdleState state() {
     }
 
     /**
-     * Return the count how often this kind of {@IdleStateEvent} was fired before.
+     * Return the count how often this kind of {@link IdleStateEvent} was fired before.
      */
     public int count() {
         return count;

File: handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java
Patch:
@@ -86,7 +86,7 @@ public class TrafficCounter {
     /**
      * Delay between two captures
      */
-    AtomicLong checkInterval = new AtomicLong(
+    final AtomicLong checkInterval = new AtomicLong(
             AbstractTrafficShapingHandler.DEFAULT_CHECK_INTERVAL);
 
     // default 1 s
@@ -117,7 +117,7 @@ public class TrafficCounter {
     /**
      * Is Monitor active
      */
-    AtomicBoolean monitorActive = new AtomicBoolean();
+    final AtomicBoolean monitorActive = new AtomicBoolean();
 
     /**
      * Class to implement monitoring at fix delay

File: transport-udt/src/test/java/io/netty/transport/udt/nio/NioUdtByteConnectorChannelTest.java
Patch:
@@ -16,12 +16,12 @@
 
 package io.netty.transport.udt.nio;
 
-import static org.junit.Assert.*;
 import io.netty.buffer.BufType;
-
 import org.junit.Test;
 
-public class TestNioUdtByteConnectorChannel extends TestAny {
+import static org.junit.Assert.*;
+
+public class NioUdtByteConnectorChannelTest extends TestAny {
 
     /**
      * verify channel meta data

File: transport-udt/src/test/java/io/netty/transport/udt/nio/NioUdtMessageAcceptorChannelTest.java
Patch:
@@ -16,12 +16,12 @@
 
 package io.netty.transport.udt.nio;
 
-import static org.junit.Assert.*;
 import io.netty.buffer.BufType;
-
 import org.junit.Test;
 
-public class TestNioUdtMessageAcceptorChannel extends TestAny {
+import static org.junit.Assert.*;
+
+public class NioUdtMessageAcceptorChannelTest extends TestAny {
 
     /**
      * verify channel meta data

File: transport-udt/src/test/java/io/netty/transport/udt/nio/NioUdtMessageConnectorChannelTest.java
Patch:
@@ -16,12 +16,12 @@
 
 package io.netty.transport.udt.nio;
 
-import static org.junit.Assert.*;
 import io.netty.buffer.BufType;
-
 import org.junit.Test;
 
-public class TestNioUdtMessageConnectorChannel extends TestAny {
+import static org.junit.Assert.*;
+
+public class NioUdtMessageConnectorChannelTest extends TestAny {
 
     /**
      * verify channel meta data

File: transport-udt/src/test/java/io/netty/transport/udt/nio/NioUdtProviderTest.java
Patch:
@@ -16,11 +16,11 @@
 
 package io.netty.transport.udt.nio;
 
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
-public class TestNioUdtProvider extends TestAny {
+import static org.junit.Assert.*;
+
+public class NioUdtProviderTest extends TestAny {
 
     /**
      * verify factory

File: transport-udt/src/test/java/io/netty/transport/udt/util/BootHelp.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Bootstrap utilities.
  */
-public class BootHelp {
+public final class BootHelp {
 
     /**
      * bootstrap for byte rendezvous peer
@@ -70,4 +70,5 @@ public static Bootstrap messagePeerBoot(final InetSocketAddress self,
 
     }
 
+    private BootHelp() { }
 }

File: transport-udt/src/test/java/io/netty/transport/udt/util/UtilThreadFactory.java
Patch:
@@ -34,7 +34,7 @@ public UtilThreadFactory(final String name) {
 
     @Override
     public Thread newThread(final Runnable runnable) {
-        return new Thread(runnable, name + "-" + counter.getAndIncrement());
+        return new Thread(runnable, name + '-' + counter.getAndIncrement());
     }
 
 }

File: transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufHolder;
 import io.netty.buffer.Freeable;
 import io.netty.buffer.MessageBuf;
 

File: transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java
Patch:
@@ -242,7 +242,6 @@ protected boolean removeTask(Runnable task) {
 
     /**
      * Poll all tasks from the task queue and run them via {@link Runnable#run()} method.
-     * @return
      */
     protected boolean runAllTasks() {
         boolean ran = false;

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -26,7 +26,7 @@
  *
  */
 public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
-    protected CounterMonitor channelCounter = MonitorRegistries.instance()
+    protected final CounterMonitor channelCounter = MonitorRegistries.instance()
             .unique().newCounterMonitor(new MonitorName(getClass(), "total-channels-registered"));
 
     /**

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -65,7 +65,7 @@ private static AsynchronousSocketChannel newSocket(AsynchronousChannelGroup grou
         }
     }
 
-    private DefaultAioSocketChannelConfig config;
+    private final DefaultAioSocketChannelConfig config;
     private volatile boolean inputShutdown;
     private volatile boolean outputShutdown;
 

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java
Patch:
@@ -194,8 +194,8 @@ public void run() {
                                     if (connectTimeoutException == null) {
                                         connectTimeoutException = new ConnectException("connection timed out");
                                     }
-                                    ChannelPromise connectFuture = AbstractNioChannel.this.connectPromise;
-                                    if (connectFuture != null && connectFuture.tryFailure(connectTimeoutException)) {
+                                    ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;
+                                    if (connectPromise != null && connectPromise.tryFailure(connectTimeoutException)) {
                                         close(voidFuture());
                                     }
                                 }

File: transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -62,7 +61,6 @@ public void shutdownBeforeStart() throws Exception {
 
     @Test
     public void shutdownAfterStart() throws Exception {
-        final AtomicBoolean interrupted = new AtomicBoolean();
         final CountDownLatch latch = new CountDownLatch(1);
         loop.execute(new Runnable() {
             @Override

File: transport/src/test/java/io/netty/channel/socket/nio/NioEventLoopTest.java
Patch:
@@ -18,8 +18,6 @@
 import io.netty.channel.AbstractEventLoopTest;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.socket.ServerSocketChannel;
-import io.netty.channel.socket.nio.NioEventLoopGroup;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
 
 public class NioEventLoopTest extends AbstractEventLoopTest {
 

File: transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpServerChannel.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.ServerChannel;
 
-import java.net.SocketAddress;
+import java.net.InetSocketAddress;
 import java.util.Set;
 
 /**
@@ -45,11 +45,11 @@ public interface SctpServerChannel extends ServerChannel {
      * with SctpStandardSocketOption.SCTP_PRIMARY_ADDR option).
      */
     @Override
-    SocketAddress localAddress();
+    InetSocketAddress localAddress();
 
     /**
      * Return all local addresses of the SCTP server channel.
      * Please note that, it will return more than one address if this channel is using multi-homing
      */
-    Set<SocketAddress> allLocalAddresses();
+    Set<InetSocketAddress> allLocalAddresses();
 }

File: transport/src/main/java/io/netty/channel/socket/SocketChannel.java
Patch:
@@ -29,6 +29,9 @@
  * @apiviz.composedOf io.netty.channel.socket.SocketChannelConfig
  */
 public interface SocketChannel extends Channel {
+    @Override
+    ServerSocketChannel parent();
+
     @Override
     SocketChannelConfig config();
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Encodes a SPDY Data or Control Frame into a {@link ByteBuf}.
  */
-public class SpdyFrameEncoder extends MessageToByteEncoder {
+public class SpdyFrameEncoder extends MessageToByteEncoder<Object> {
 
     private final int version;
     private volatile boolean finished;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -58,9 +58,9 @@ public static void shutdownExecutor() {
         executor.shutdown();
     }
 
-    @Test//(timeout = 30000)
+    @Test(timeout = 30000)
     public void testStartTls() throws Throwable {
-        for (;;) { run(); }
+        run();
     }
 
     public void testStartTls(ServerBootstrap sb, Bootstrap cb) throws Throwable {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
Patch:
@@ -58,9 +58,9 @@ public static void shutdownExecutor() {
         executor.shutdown();
     }
 
-    @Test(timeout = 30000)
+    @Test//(timeout = 30000)
     public void testStartTls() throws Throwable {
-        run();
+        for (;;) { run(); }
     }
 
     public void testStartTls(ServerBootstrap sb, Bootstrap cb) throws Throwable {

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -214,7 +214,7 @@ private static int toInt(String name) {
     private static void verifyContextNumber(DefaultChannelPipeline pipeline, int expectedNumber) {
         DefaultChannelHandlerContext ctx = (DefaultChannelHandlerContext) pipeline.firstContext();
         int handlerNumber = 0;
-        while (ctx != null) {
+        while (ctx != pipeline.tail) {
             handlerNumber++;
             ctx = ctx.next;
         }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
Patch:
@@ -50,7 +50,6 @@ protected void encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, ByteBuf out) t
             @Override
             public INBOUND_OUT decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
                 return ByteToMessageCodec.this.decode(ctx, in);
-
             }
 
             @Override
@@ -109,4 +108,4 @@ public boolean isEncodable(Object msg) throws Exception {
     protected INBOUND_OUT decodeLast(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
         return decode(ctx, in);
     }
-}
\ No newline at end of file
+}

File: codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java
Patch:
@@ -96,7 +96,6 @@ private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {
             }
         }
 
-        in.discardSomeReadBytes();
         if (out.readableBytes() > oldOutSize) {
             ctx.fireInboundBufferUpdated();
         }

File: codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
Patch:
@@ -75,7 +75,7 @@ public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
                 break;
             }
         }
-        in.discardSomeReadBytes();
+
         ctx.flush(promise);
     }
 

File: codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
Patch:
@@ -181,7 +181,6 @@ public boolean isClosed() {
     protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
         if (finished.get()) {
             out.writeBytes(in);
-            in.discardReadBytes();
             return;
         }
 

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -95,9 +95,6 @@ protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws
                 writtenObjects ++;
                 if (writtenObjects % resetInterval == 0) {
                     oos.reset();
-
-                    // Also discard the byproduct to avoid OOM on the sending side.
-                    out.discardSomeReadBytes();
                 }
             }
 

File: example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
Patch:
@@ -87,7 +87,6 @@ private void generateTraffic() {
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {
-                ctx.nextOutboundByteBuffer().discardReadBytes();
                 generateTraffic();
             }
         }

File: example/src/main/java/io/netty/example/echo/EchoClientHandler.java
Patch:
@@ -56,7 +56,6 @@ public void channelActive(ChannelHandlerContext ctx) {
     @Override
     public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) {
         ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.discardReadBytes();
         out.writeBytes(in);
         ctx.flush();
     }

File: example/src/main/java/io/netty/example/echo/EchoServerHandler.java
Patch:
@@ -35,7 +35,6 @@ public class EchoServerHandler extends ChannelInboundByteHandlerAdapter {
     @Override
     public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) {
         ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.discardReadBytes();
         out.writeBytes(in);
         ctx.flush();
     }

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
Patch:
@@ -36,9 +36,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     @Override
     public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
         ByteBuf out = inboundChannel.outboundByteBuffer();
-        out.discardReadBytes();
         out.writeBytes(in);
-        in.clear();
         inboundChannel.flush();
     }
 

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
Patch:
@@ -68,9 +68,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     @Override
     public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
         ByteBuf out = outboundChannel.outboundByteBuffer();
-        out.discardReadBytes();
         out.writeBytes(in);
-        in.clear();
         if (outboundChannel.isActive()) {
             outboundChannel.flush();
         }

File: example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
Patch:
@@ -42,9 +42,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     @Override
     public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
         ByteBuf out = relayChannel.outboundByteBuffer();
-        out.discardReadBytes();
         out.writeBytes(in);
-        in.clear();
         if (relayChannel.isActive()) {
             relayChannel.flush();
         }

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.stream;
 
-import io.netty.buffer.Buf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
@@ -98,8 +97,8 @@ public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Ex
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
-        // Nothing to free
+    public void freeOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
+        queue.free();
     }
 
     private boolean isWritable() {

File: transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java
Patch:
@@ -51,7 +51,6 @@ public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
             ByteBuf payload = Unpooled.buffer(in.readableBytes());
             payload.writeBytes(in);
             out.add(new SctpMessage(streamIdentifier, protocolIdentifier, payload));
-            in.discardReadBytes();
         } catch (Throwable t) {
             ctx.fireExceptionCaught(new EncoderException(t));
         }

File: transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
Patch:
@@ -30,5 +30,5 @@ public interface ChannelInboundHandler extends ChannelStateHandler {
      * Invoked when this handler is not going to receive any inbound message anymore and thus it's safe to
      * deallocate its inbound buffer.
      */
-    void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception;
+    void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
Patch:
@@ -85,7 +85,7 @@ public interface ChannelInboundInvoker {
     void fireInboundBufferUpdated();
 
     /**
-     * Triggers an {@link ChannelStateHandler#inboundBufferSuspended(ChannelHandlerContext) inboundBufferSuspended}
+     * Triggers an {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) inboundBufferSuspended}
      * event to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
      */
     void fireInboundBufferSuspended();

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
Patch:
@@ -30,5 +30,5 @@ public interface ChannelOutboundHandler extends ChannelOperationHandler {
      * Invoked when this handler is not allowed to send any outbound message anymore and thus it's safe to
      * deallocate its outbound buffer.
      */
-    void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception;
+    void freeOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
Patch:
@@ -157,7 +157,7 @@ public interface ChannelOutboundInvoker {
      * Reads data from the {@link Channel} into the first inbound buffer, triggers an
      * {@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext) inboundBufferUpdated} event if data was
      * read, and triggers an
-     * {@link ChannelStateHandler#inboundBufferSuspended(ChannelHandlerContext) inboundBufferSuspended} event so the
+     * {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) inboundBufferSuspended} event so the
      * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
      */
     void read();

File: transport/src/main/java/io/netty/channel/ChannelStateHandlerAdapter.java
Patch:
@@ -155,7 +155,7 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void inboundBufferSuspended(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception {
         ctx.fireInboundBufferSuspended();
     }
 }

File: transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java
Patch:
@@ -331,7 +331,7 @@ public Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
+        public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
             // Do NOT free the buffer.
         }
 
@@ -354,7 +354,7 @@ public Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
+        public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {
             // Do NOT free the buffer.
         }
 

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java
Patch:
@@ -77,9 +77,6 @@ protected boolean hasReadableOutboundBuffer() {
 
     @Override
     protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
-        if (!lastOutboundBuffer().readable()) {
-            lastOutboundBuffer().discardReadBytes();
-        }
         lastOutboundBuffer().writeBytes(buf);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibWrapper.java
Patch:
@@ -25,7 +25,7 @@ public enum ZlibWrapper {
      */
     ZLIB,
     /**
-     * The GZIP wrapper as specified in <a href="http://tools.ietf.org/html/rfc1950">RFC 1952</a>.
+     * The GZIP wrapper as specified in <a href="http://tools.ietf.org/html/rfc1952">RFC 1952</a>.
      */
     GZIP,
     /**

File: common/src/test/java/io/netty/monitor/MonitorRegistriesTest.java
Patch:
@@ -35,7 +35,7 @@ public final void forProviderShouldReturnMonitorRegistryMatchingTheSuppliedProvi
 				registry.getClass());
 	}
 
-	@Test(expected = IllegalStateException.class)
+	@Test
 	public final void uniqueShouldThrowIllegalStateExceptionIfMoreThanOneProviderIsRegistered() {
 		final MonitorRegistries objectUnderTest = MonitorRegistries.instance();
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelOption;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.net.Socket;
@@ -37,7 +38,7 @@ public class ServerSocketSuspendTest extends AbstractServerSocketTest {
     private static final long TIMEOUT = 3000000000L;
 
     @Test
-    //@Ignore("Need to investigate why it fails on osx")
+    @Ignore("Need to investigate why it fails on osx")
     public void testSuspendAndResumeAccept() throws Throwable {
         run();
     }

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -493,7 +493,7 @@ protected void completed0(T result, AioSocketChannel channel) {
                             channel.unsafe().close(channel.unsafe().voidFuture());
                         }
                     }
-                } else  if (!firedInboundBufferSuspended) {
+                } else if (!firedInboundBufferSuspended) {
                     pipeline.fireInboundBufferSuspended();
                 }
             }

File: codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java
Patch:
@@ -16,11 +16,10 @@
 package io.netty.handler.codec.marshalling;
 
 import io.netty.buffer.ByteBuf;
+import org.jboss.marshalling.ByteOutput;
 
 import java.io.IOException;
 
-import org.jboss.marshalling.ByteOutput;
-
 /**
  * {@link ByteOutput} implementation which writes the data to a {@link ByteBuf}
  *
@@ -39,7 +38,7 @@ public ChannelBufferByteOutput(ByteBuf buffer) {
 
     @Override
     public void close() throws IOException {
-        // Nothing todo
+        // Nothing to do
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec.marshalling;
 
-import java.io.IOException;
-
 import org.jboss.marshalling.ByteInput;
 
+import java.io.IOException;
+
 /**
  * {@link ByteInput} implementation which wraps another {@link ByteInput} and throws a {@link TooBigObjectException}
  * if the read limit was reached.
@@ -42,7 +42,7 @@ public LimitingByteInput(ByteInput input, long limit) {
 
     @Override
     public void close() throws IOException {
-        // Nothing todo
+        // Nothing to do
     }
 
     @Override

File: example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 
 public class LocalEchoClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
-
     @Override
     public void messageReceived(ChannelHandlerContext ctx, String msg) {
         // Print as received

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -15,20 +15,20 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketEchoTest extends AbstractSocketTest {
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
Patch:
@@ -32,8 +32,7 @@
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 public class SocketFileRegionTest extends AbstractSocketTest {
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
@@ -26,12 +25,13 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.FixedLengthFrameDecoder;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketFixedLengthEchoTest extends AbstractSocketTest {
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
Patch:
@@ -15,22 +15,22 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.socket.ChannelInputShutdownEvent;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.socket.ChannelInputShutdownEvent;
 import io.netty.channel.socket.SocketChannel;
+import org.junit.Test;
 
 import java.net.Socket;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketShutdownOutputByPeerTest extends AbstractServerSocketTest {
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
@@ -30,13 +29,14 @@
 import io.netty.handler.codec.spdy.SpdyFrameDecoder;
 import io.netty.handler.codec.spdy.SpdyFrameEncoder;
 import io.netty.util.NetUtil;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketSpdyEchoTest extends AbstractSocketTest {
 

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -225,8 +225,8 @@ public MessageBuf<Channel> newInboundBuffer(ChannelHandlerContext ctx) throws Ex
             return Unpooled.messageBuffer();
         }
 
-        @SuppressWarnings("unchecked")
         @Override
+        @SuppressWarnings("unchecked")
         public void inboundBufferUpdated(ChannelHandlerContext ctx) {
             MessageBuf<Channel> in = ctx.inboundMessageBuffer();
             for (;;) {

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -44,6 +44,8 @@ public class ChannelOption<T> extends UniqueName {
             new ChannelOption<Integer>("WRITE_SPIN_COUNT");
     public static final ChannelOption<Boolean> ALLOW_HALF_CLOSURE =
             new ChannelOption<Boolean>("ALLOW_HALF_CLOSURE");
+    public static final ChannelOption<Boolean> AUTO_READ =
+            new ChannelOption<Boolean>("AUTO_READ");
 
     public static final ChannelOption<Boolean> SO_BROADCAST =
             new ChannelOption<Boolean>("SO_BROADCAST");

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
Patch:
@@ -24,7 +24,7 @@
 import io.netty.channel.ChannelPipeline;
 
 /**
- * Embedded {@@link Channel} which operates on messages which can be of any time.
+ * Embedded {@link Channel} which operates on messages which can be of any time.
  */
 public class EmbeddedMessageChannel extends AbstractEmbeddedChannel<Object> {
 
@@ -47,6 +47,7 @@ public MessageBuf<Object> inboundBuffer() {
         return pipeline().inboundMessageBuffer();
     }
 
+    @Override
     @SuppressWarnings("unchecked")
     public MessageBuf<Object> lastOutboundBuffer() {
         return (MessageBuf<Object>) lastOutboundBuffer;

File: transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
Patch:
@@ -163,4 +163,7 @@ public interface DatagramChannelConfig extends ChannelConfig {
 
     @Override
     DatagramChannelConfig setAllocator(ByteBufAllocator allocator);
+
+    @Override
+    DatagramChannelConfig setAutoRead(boolean autoRead);
 }

File: transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
Patch:
@@ -90,4 +90,7 @@ public interface ServerSocketChannelConfig extends ChannelConfig {
 
     @Override
     ServerSocketChannelConfig setAllocator(ByteBufAllocator allocator);
+
+    @Override
+    ServerSocketChannelConfig setAutoRead(boolean autoRead);
 }

File: transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
Patch:
@@ -153,4 +153,7 @@ public interface SocketChannelConfig extends ChannelConfig {
 
     @Override
     SocketChannelConfig setAllocator(ByteBufAllocator allocator);
+
+    @Override
+    SocketChannelConfig setAutoRead(boolean autoRead);
 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioSctpServerChannel.java
Patch:
@@ -118,8 +118,6 @@ protected SocketAddress localAddress0() {
     @Override
     protected void doBind(SocketAddress localAddress) throws Exception {
         javaChannel().bind(localAddress, config.getBacklog());
-        SelectionKey selectionKey = selectionKey();
-        selectionKey.interestOps(selectionKey.interestOps() | SelectionKey.OP_ACCEPT);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -90,8 +90,6 @@ protected SocketAddress localAddress0() {
     @Override
     protected void doBind(SocketAddress localAddress) throws Exception {
         javaChannel().socket().bind(localAddress, config.getBacklog());
-        SelectionKey selectionKey = selectionKey();
-        selectionKey.interestOps(selectionKey.interestOps() | SelectionKey.OP_ACCEPT);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioEventLoop.java
Patch:
@@ -78,8 +78,6 @@ protected void run() {
                     }
                 }
 
-                ch.unsafe().read();
-
                 // Handle deregistration
                 if (!ch.isRegistered()) {
                     runAllTasks();

File: codec/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
Patch:
@@ -40,7 +40,7 @@ public SctpInboundByteStreamHandler(int protocolIdentifier, int streamIdentifier
     }
 
     protected boolean isDecodable(SctpMessage msg) {
-        return msg.getProtocolIdentifier() == protocolIdentifier && msg.getStreamIdentifier() == streamIdentifier;
+        return msg.protocolIdentifier() == protocolIdentifier && msg.streamIdentifier() == streamIdentifier;
     }
 
     @Override
@@ -56,7 +56,7 @@ protected void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throw
                     "pipeline before this handler", SctpMessageCompletionHandler.class.getSimpleName()));
         }
 
-        ctx.nextInboundByteBuffer().writeBytes(msg.getPayloadBuffer());
+        ctx.nextInboundByteBuffer().writeBytes(msg.payloadBuffer());
         ctx.fireInboundBufferUpdated();
     }
 }

File: codec/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
Patch:
@@ -31,9 +31,9 @@ public class SctpMessageCompletionHandler extends ChannelInboundMessageHandlerAd
     @Override
     protected void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
 
-        final ByteBuf byteBuf = msg.getPayloadBuffer();
-        final int protocolIdentifier = msg.getProtocolIdentifier();
-        final int streamIdentifier = msg.getStreamIdentifier();
+        final ByteBuf byteBuf = msg.payloadBuffer();
+        final int protocolIdentifier = msg.protocolIdentifier();
+        final int streamIdentifier = msg.streamIdentifier();
         final boolean isComplete = msg.isComplete();
 
         ByteBuf frag;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java
Patch:
@@ -57,7 +57,7 @@ static void validateHeaderName(String headerName) {
     /**
      * Validates the specified header value
      *
-     * @param value The value being validated
+     * @param headerValue The value being validated
      */
     static void validateHeaderValue(String headerValue) {
         //Check to see if the value is null

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Encodes the content of the outbound {@link HttpResponse} and {@link HttpChunk}.
  * The original content is replaced with the new content encoded by the
- * {@link EncoderEmbedder}, which is created by {@link #beginEncode(HttpMessage, String)}.
+ * {@link EmbeddedByteChannel}, which is created by {@link #beginEncode(HttpMessage, String)}.
  * Once encoding is finished, the value of the <tt>'Content-Encoding'</tt> header
  * is set to the target content encoding, as returned by
  * {@link #beginEncode(HttpMessage, String)}.
@@ -163,7 +163,7 @@ public Object encode(ChannelHandlerContext ctx, Object msg)
      *        the value of the {@code "Accept-Encoding"} header
      *
      * @return the result of preparation, which is composed of the determined
-     *         target content encoding and a new {@link EncoderEmbedder} that
+     *         target content encoding and a new {@link EmbeddedByteChannel} that
      *         encodes the content into the target content encoding.
      *         {@code null} if {@code acceptEncoding} is unsupported or rejected
      *         and thus the content should be handled as-is (i.e. no encoding).

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -76,8 +76,8 @@
  * </pre>
  * triggers {@link HttpRequestDecoder} to generate 4 objects:
  * <ol>
- * <li>An {@link HttpRequest} whose {@link HttpMessage#isChunked() chunked}
- *     property is {@code true},</li>
+ * <li>An {@link HttpRequest} whose {@link HttpMessage#getTransferEncoding()}
+ *     property is {@link HttpTransferEncoding#CHUNKED},</li>
  * <li>The first {@link HttpChunk} whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>
  * <li>The second {@link HttpChunk} whose content is {@code '1234567890abcdef'}, and</li>
  * <li>An {@link HttpChunkTrailer} which marks the end of the content.</li>

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java
Patch:
@@ -43,7 +43,7 @@ public interface HttpRequest extends HttpMessage {
     /**
      * Sets the {@link HttpMethod} of this {@link HttpRequest}.
      *
-     * @param The {@link HttpMethod} to set
+     * @param method The {@link HttpMethod} to set
      */
     void setMethod(HttpMethod method);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
Patch:
@@ -24,6 +24,8 @@
  */
 public class CloseWebSocketFrame extends WebSocketFrame {
 
+    private static final byte[] EMTPY_REASON = new byte[0];
+
     /**
      * Creates a new empty close frame.
      */
@@ -73,7 +75,7 @@ public CloseWebSocketFrame(boolean finalFragment, int rsv, int statusCode, Strin
         setFinalFragment(finalFragment);
         setRsv(rsv);
 
-        byte[] reasonBytes = new byte[0];
+        byte[] reasonBytes = EMTPY_REASON;
         if (reasonText != null) {
             reasonBytes = reasonText.getBytes(CharsetUtil.UTF_8);
         }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -24,7 +24,7 @@
 import io.netty.handler.codec.http.HttpResponse;
 
 /**
- * {@link MessageToMessageCodec} that takes care of adding the right {@link SpdyHttpHeaders#Names#STREAM_ID} to the
+ * {@link MessageToMessageCodec} that takes care of adding the right {@link SpdyHttpHeaders.Names#STREAM_ID} to the
  * {@link HttpResponse} if one is not present. This makes it possible to just re-use plan handlers current used
  * for HTTP.
  */

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -215,7 +215,6 @@ protected void validate() {
             logger.warn("childGroup is not set. Using parentGroup instead.");
             childGroup = group();
         }
-
     }
 
     private class Acceptor

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
Patch:
@@ -41,8 +41,7 @@
  * and then you can use an array of bytes instead of a {@link ByteBuf}
  * as a message:
  * <pre>
- * void messageReceived({@link ChannelHandlerContext} ctx, {@link MessageEvent} e) {
- *     byte[] bytes = (byte[]) e.getMessage();
+ * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {
  *     ...
  * }
  * </pre>

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
Patch:
@@ -43,8 +43,7 @@
  * and then you can use an array of bytes instead of a {@link ByteBuf}
  * as a message:
  * <pre>
- * void messageReceived({@link ChannelHandlerContext} ctx, {@link MessageEvent} e) {
- *     byte[] bytes = (byte[]) e.getMessage();
+ * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {
  *     ...
  * }
  * </pre>

File: transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java
Patch:
@@ -42,7 +42,7 @@ public abstract class MultithreadEventExecutorGroup implements EventExecutorGrou
      *                          of {@link #DEFAULT_POOL_SIZE}
      * @param threadFactory     the ThreadFactory to use, or {@code null} if the default should be used.
      * @param args              arguments which will passed to each
-     *                          {@link #newChild(java.util.concurrent.ThreadFactory, ChannelTaskScheduler, Object...)}
+     *                          {@link #newChild(ThreadFactory, ChannelTaskScheduler, Object...)}
      *                          call.
      */
     protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) {

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -45,6 +45,9 @@ private static ServerSocketChannel newSocket() {
 
     private final ServerSocketChannelConfig config;
 
+    /**
+     * Create a new instance
+     */
     public NioServerSocketChannel() {
         super(null, null, newSocket(), SelectionKey.OP_ACCEPT);
         config = new DefaultServerSocketChannelConfig(javaChannel().socket());

File: transport/src/main/java/io/netty/channel/socket/nio/SelectorUtil.java
Patch:
@@ -24,6 +24,9 @@
 import java.nio.channels.Selector;
 import java.util.concurrent.TimeUnit;
 
+/**
+ * Utility class for operate on a {@link Selector}
+ */
 final class SelectorUtil {
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SelectorUtil.class);

File: transport/src/main/java/io/netty/channel/socket/nio/ProtocolFamilyConverter.java
Patch:
@@ -22,8 +22,6 @@
 
 /**
  * Helper class which convert the {@link InternetProtocolFamily}.
- *
- *
  */
 final class ProtocolFamilyConverter {
 
@@ -38,7 +36,6 @@ public static ProtocolFamily convert(InternetProtocolFamily family) {
         switch (family) {
         case IPv4:
             return StandardProtocolFamily.INET;
-
         case IPv6:
             return StandardProtocolFamily.INET6;
         default:

File: transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java
Patch:
@@ -23,7 +23,6 @@ public final class ChannelFlushFutureNotifier {
     private long writeCounter;
     private final Queue<FlushCheckpoint> flushCheckpoints = new ArrayDeque<FlushCheckpoint>();
 
-
     /**
      * Add a {@link ChannelFuture} to this {@link ChannelFlushFutureNotifier} which will be notified after the given
      * pendingDataSize was reached.

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java
Patch:
@@ -48,7 +48,7 @@ public ChunkedNioStream(ReadableByteChannel in) {
      * Creates a new instance that fetches data from the specified channel.
      *
      * @param chunkSize the number of bytes to fetch on each
-     *                  {@link #nextChunk()} call
+     *                  {@link #readChunk(ByteBuf)} call
      */
     public ChunkedNioStream(ReadableByteChannel in, int chunkSize) {
         if (in == null) {

File: handler/src/main/java/io/netty/handler/stream/ChunkedStream.java
Patch:
@@ -49,7 +49,7 @@ public ChunkedStream(InputStream in) {
      * Creates a new instance that fetches data from the specified stream.
      *
      * @param chunkSize the number of bytes to fetch on each
-     *                  {@link #nextChunk()} call
+     *                  {@link #readChunk(ByteBuf)} call
      */
     public ChunkedStream(InputStream in, int chunkSize) {
         if (in == null) {

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -60,7 +60,7 @@
  *
  * Some {@link ChunkedInput} generates a chunk on a certain event or timing.
  * Such {@link ChunkedInput} implementation often returns {@code null} on
- * {@link ChunkedInput#nextChunk()}, resulting in the indefinitely suspended
+ * {@link ChunkedInput#readChunk(Object)}, resulting in the indefinitely suspended
  * transfer.  To resume the transfer when a new chunk is available, you have to
  * call {@link #resumeTransfer()}.
  * @apiviz.landmark

File: buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java
Patch:
@@ -34,6 +34,4 @@ public interface ByteBufAllocator {
     CompositeByteBuf compositeHeapBuffer(int maxNumComponents);
     CompositeByteBuf compositeDirectBuffer();
     CompositeByteBuf compositeDirectBuffer(int maxNumComponents);
-
-    int bufferMaxCapacity();
 }

File: buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java
Patch:
@@ -26,7 +26,7 @@ public final class UnpooledByteBufAllocator extends AbstractByteBufAllocator {
     public static final UnpooledByteBufAllocator DIRECT_BY_DEFAULT = new UnpooledByteBufAllocator(true);
 
     private UnpooledByteBufAllocator(boolean directByDefault) {
-        super(Integer.MAX_VALUE, directByDefault);
+        super(directByDefault);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/PoolChunkList.java
Patch:
@@ -38,20 +38,20 @@ final class PoolChunkList<T> {
         this.maxUsage = maxUsage;
     }
 
-    boolean allocate(PooledByteBuf<T> buf, int capacity) {
+    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {
         if (head == null) {
             return false;
         }
 
         for (PoolChunk<T> cur = head;;) {
-            long handle = cur.allocate(capacity);
+            long handle = cur.allocate(normCapacity);
             if (handle < 0) {
                 cur = cur.next;
                 if (cur == null) {
                     return false;
                 }
             } else {
-                cur.initBuf(buf, handle);
+                cur.initBuf(buf, handle, reqCapacity);
                 if (cur.usage() >= maxUsage) {
                     remove(cur);
                     nextList.add(cur);

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1241,7 +1241,7 @@ private void fill() {
                 data = ctx.alloc().buffer(dataLen, dataLen);
             }
 
-            byteBuf.readBytes(data, dataLen).discardSomeReadBytes();
+            byteBuf.readBytes(data).discardSomeReadBytes();
 
             exchangeBuf.add(data);
         }

File: transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java
Patch:
@@ -22,7 +22,7 @@
  * Abstract base class for {@link ChannelInboundHandlerAdapter} which should be extended by the user to
  * get notified once more data is ready to get consumed from the inbound {@link ByteBuf}.
  *
- * This implementation is a good starting point for must users.
+ * This implementation is a good starting point for most users.
  */
 public abstract class ChannelInboundByteHandlerAdapter
         extends ChannelInboundHandlerAdapter implements ChannelInboundByteHandler {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SctpEchoTest.java
Patch:
@@ -58,14 +58,13 @@ public void testSimpleEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
     }
 
     @Test
-    @Ignore("TODO: fix this after OioSctp EventLoop done")
     public void testSimpleEchoWithBoundedBuffer() throws Throwable {
         Assume.assumeTrue(TestUtils.isSctpSupported());
         run();
     }
 
     public void testSimpleEchoWithBoundedBuffer(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, 32);
+        testSimpleEcho0(sb, cb, 4096);
     }
 
     private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb, int maxInboundBufferSize) throws Throwable {

File: transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java
Patch:
@@ -36,7 +36,7 @@ public abstract class MultithreadEventExecutorGroup implements EventExecutorGrou
     private final AtomicInteger childIndex = new AtomicInteger();
 
     /**
-     * Create a new intance
+     * Create a new instance.
      *
      * @param nThreads          the number of threads that will be used by this instance. Use 0 for the default number
      *                          of {@link #DEFAULT_POOL_SIZE}

File: transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
Patch:
@@ -24,7 +24,7 @@
 public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup {
 
     /**
-     * @see #MultithreadEventLoopGroup(int, java.util.concurrent.ThreadFactory, Object...)
+     * @see {@link MultithreadEventExecutorGroup##MultithreadEventLoopGroup(int,ThreadFactory, Object...)}
      */
     protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory,
             Object... args) {

File: transport/src/main/java/io/netty/channel/socket/aio/AioCompletionHandler.java
Patch:
@@ -22,8 +22,6 @@
 
 /**
  * Special {@link CompletionHandler} which makes sure that the callback methods gets executed in the {@link EventLoop}
- *
- *
  */
 abstract class AioCompletionHandler<V, A extends Channel> implements CompletionHandler<V, A> {
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoop.java
Patch:
@@ -28,6 +28,9 @@
 import java.util.Set;
 import java.util.concurrent.ThreadFactory;
 
+/**
+ * {@link SingleThreadEventLoop} implementations which will handle AIO {@link Channel}s.
+ */
 final class AioEventLoop extends SingleThreadEventLoop {
 
     private final Set<Channel> channels = Collections.newSetFromMap(new IdentityHashMap<Channel, Boolean>());

File: transport/src/main/java/io/netty/channel/socket/aio/ReflectiveAioChannelFinder.java
Patch:
@@ -19,6 +19,9 @@
 import java.util.HashMap;
 import java.util.Map;
 
+/**
+ * {@link AioChannelFinder} implementation which use reflection for find the right {@link AbstractAioChannel}.
+ */
 final class ReflectiveAioChannelFinder implements AioChannelFinder {
     private static volatile Map<Class<?>, Field> fieldCache = new HashMap<Class<?>, Field>();
 

File: transport/src/main/java/io/netty/channel/socket/aio/UnsafeAioChannelFinder.java
Patch:
@@ -21,6 +21,9 @@
 
 import sun.misc.Unsafe;
 
+/**
+ * {@link AioChannelFinder} implementation which will use {@link Unsafe}.
+ */
 @SuppressWarnings("restriction")
 final class UnsafeAioChannelFinder implements AioChannelFinder {
     private static final Unsafe UNSAFE = getUnsafe();

File: transport/src/main/java/io/netty/channel/socket/aio/package-info.java
Patch:
@@ -17,5 +17,7 @@
 /**
  * <a href="http://en.wikipedia.org/wiki/New_I/O">NIO2</a>-based socket channel
  * API implementation - recommended for a large number of connections (&gt;= 1000).
+ *
+ * NIO2 is only supported on Java 7+.
  */
 package io.netty.channel.socket.aio;

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioChannel.java
Patch:
@@ -33,7 +33,7 @@ abstract class AbstractOioChannel extends AbstractChannel {
     protected volatile boolean readSuspended;
 
     /**
-     * @see AbstractChannel#AbstractChannel(io.netty.channel.Channel, Integer)
+     * @see AbstractChannel#AbstractChannel(Channel, Integer)
      */
     protected AbstractOioChannel(Channel parent, Integer id) {
         super(parent, id);
@@ -122,7 +122,7 @@ protected boolean isFlushPending() {
     }
 
     /**
-     * Connect to the remote peer using the given localAddress if one is specified or null otherwise.
+     * Connect to the remote peer using the given localAddress if one is specified or {@code null} otherwise.
      */
     protected abstract void doConnect(
             SocketAddress remoteAddress, SocketAddress localAddress) throws Exception;

File: transport/src/main/java/io/netty/channel/socket/aio/DefaultAioSocketChannelConfig.java
Patch:
@@ -309,16 +309,16 @@ private void propagateOptions() {
 
     @Override
     public AioSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
-        return (AioSocketChannelConfig) setConnectTimeoutMillis(connectTimeoutMillis);
+        return (AioSocketChannelConfig) super.setConnectTimeoutMillis(connectTimeoutMillis);
     }
 
     @Override
     public AioSocketChannelConfig setWriteSpinCount(int writeSpinCount) {
-        return (AioSocketChannelConfig) setWriteSpinCount(writeSpinCount);
+        return (AioSocketChannelConfig) super.setWriteSpinCount(writeSpinCount);
     }
 
     @Override
     public AioSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
-        return (AioSocketChannelConfig) setAllocator(allocator);
+        return (AioSocketChannelConfig) super.setAllocator(allocator);
     }
 }

File: transport/src/main/java/io/netty/channel/ChannelPipelineException.java
Patch:
@@ -17,8 +17,7 @@
 
 /**
  * A {@link ChannelException} which is thrown when a {@link ChannelPipeline}
- * failed to process a {@link ChannelEvent} or when a {@link ChannelPipelineFactory}
- * failed to initialize a {@link ChannelPipeline}.
+ * failed to execute an operation.
  *
  * @apiviz.exclude
  */

File: transport/src/main/java/io/netty/channel/DefaultEventExecutor.java
Patch:
@@ -24,6 +24,9 @@
  */
 class DefaultEventExecutor extends SingleThreadEventExecutor {
 
+    /**
+     * @see SingleThreadEventExecutor#SingleThreadEventExecutor(EventExecutorGroup, ThreadFactory, ChannelTaskScheduler)
+     */
     DefaultEventExecutor(
             DefaultEventExecutorGroup parent, ThreadFactory threadFactory, ChannelTaskScheduler scheduler) {
         super(parent, threadFactory, scheduler);

File: transport/src/main/java/io/netty/channel/EventExecutor.java
Patch:
@@ -34,8 +34,6 @@ public interface EventExecutor extends EventExecutorGroup, ScheduledExecutorServ
 
     /**
      * Return the {@link EventExecutorGroup} which is the parent of this {@link EventExecutor},
-     * or {@code null} if it has no parent
-
      */
     EventExecutorGroup parent();
 

File: transport/src/main/java/io/netty/channel/FailedChannelFuture.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * The {@link CompleteChannelFuture} which is failed already.  It is
- * recommended to use {@link Channels#failedFuture(Channel, Throwable)}
+ * recommended to use {@link Channel#newFailedFuture(Throwable)}
  * instead of calling the constructor of this future.
  */
 public class FailedChannelFuture extends CompleteChannelFuture {

File: transport/src/main/java/io/netty/channel/FileRegion.java
Patch:
@@ -75,7 +75,7 @@ public interface FileRegion {
     long transferTo(WritableByteChannel target, long position) throws IOException;
 
     /**
-     * Close the {@link FileRegion}.
+     * Close the {@link FileRegion}. After calling this method accessing the {@link FileRegion} may fail.
      */
     void close();
 }

File: transport/src/main/java/io/netty/channel/SucceededChannelFuture.java
Patch:
@@ -15,14 +15,13 @@
  */
 package io.netty.channel;
 
-import java.nio.channels.Channels;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
 /**
  * The {@link CompleteChannelFuture} which is succeeded already.  It is
- * recommended to use {@link Channels#succeededFuture(Channel)} instead of
+ * recommended to use {@link Channel#newSucceededFuture()} instead of
  * calling the constructor of this future.
  */
 public class SucceededChannelFuture extends CompleteChannelFuture {

File: transport/src/main/java/io/netty/channel/VoidChannelFuture.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-public class VoidChannelFuture implements ChannelFuture.Unsafe {
+class VoidChannelFuture implements ChannelFuture.Unsafe {
 
     private final Channel channel;
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
Patch:
@@ -153,7 +153,6 @@ public interface ChannelOutboundInvoker {
      */
     ChannelFuture write(Object message, ChannelFuture future);
 
-
     /**
      * Send a {@link FileRegion} via this ChannelOutboundInvoker and notify the {@link ChannelFuture}
      * once the operation completes, either because the operation was successful or because of an error.

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
Patch:
@@ -15,20 +15,20 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.socket.SocketChannel;
+import org.junit.Test;
 
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketShutdownOutputBySelfTest extends AbstractClientSocketTest {
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
@@ -28,12 +27,13 @@
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 import io.netty.util.CharsetUtil;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketStringEchoTest extends AbstractSocketTest {
 

File: transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
Patch:
@@ -22,7 +22,7 @@
  */
 public interface ChannelInboundHandler extends ChannelStateHandler {
     /**
-     * Return the {@link io.netty.buffer.Buf} which will be used for inbound data for the given {@link ChannelHandlerContext}.
+     * Return the {@link Buf} which will be used for inbound data for the given {@link ChannelHandlerContext}.
      */
     Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
 

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -47,8 +47,8 @@ protected AbstractByteBuf(int maxCapacity) {
     }
 
     @Override
-    public ChannelBufType type() {
-        return ChannelBufType.BYTE;
+    public BufType type() {
+        return BufType.BYTE;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/Buf.java
Patch:
@@ -15,11 +15,11 @@
  */
 package io.netty.buffer;
 
-public interface ChannelBuf {
+public interface Buf {
     /**
-     * The ChannelBufType which will be handled by the ChannelBuf implementation
+     * The BufType which will be handled by the Buf implementation
      */
-    ChannelBufType type();
+    BufType type();
 
     /**
      * Returns {@code true} if and only if this buffer has been deallocated by {@link #free()}.

File: buffer/src/main/java/io/netty/buffer/BufType.java
Patch:
@@ -16,9 +16,9 @@
 package io.netty.buffer;
 
 /**
- * The type of the ChannelBuf
+ * The type of the Buf
  */
-public enum ChannelBufType {
+public enum BufType {
     /**
      * Operates one bytes.
      */

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -228,7 +228,7 @@
  * {@link ByteBufOutputStream}.
  * @apiviz.landmark
  */
-public interface ByteBuf extends ChannelBuf, Comparable<ByteBuf> {
+public interface ByteBuf extends Buf, Comparable<ByteBuf> {
 
     /**
      * Returns the number of bytes (octets) this buffer can contain.

File: buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java
Patch:
@@ -31,8 +31,8 @@ final class DefaultMessageBuf<T> extends ArrayDeque<T> implements MessageBuf<T>
     }
 
     @Override
-    public ChannelBufType type() {
-        return ChannelBufType.MESSAGE;
+    public BufType type() {
+        return BufType.MESSAGE;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/MessageBuf.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Queue;
 
 /**
- * ChannelBuf which operates on messages
+ * Buf which operates on messages
  *
  * @param <T>
  */
-public interface MessageBuf<T> extends ChannelBuf, Queue<T> {
+public interface MessageBuf<T> extends Buf, Queue<T> {
     int drainTo(Collection<? super T> c);
     int drainTo(Collection<? super T> c, int maxElements);
 }

File: buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java
Patch:
@@ -32,8 +32,8 @@ final class QueueBackedMessageBuf<T> implements MessageBuf<T> {
     }
 
     @Override
-    public ChannelBufType type() {
-        return ChannelBufType.MESSAGE;
+    public BufType type() {
+        return BufType.MESSAGE;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
Patch:
@@ -68,8 +68,8 @@ public ByteBufAllocator alloc() {
     }
 
     @Override
-    public ChannelBufType type() {
-        return ChannelBufType.MESSAGE;
+    public BufType type() {
+        return BufType.MESSAGE;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/Unpooled.java
Patch:
@@ -73,7 +73,7 @@
  * of a new buffer type, generation of hex dump and swapping an integer's
  * byte order.
  * @apiviz.landmark
- * @apiviz.has io.netty.buffer.ChannelBuf oneway - - creates
+ * @apiviz.has io.netty.buffer.Buf oneway - - creates
  */
 public final class Unpooled {
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFuture;
@@ -97,12 +97,12 @@ public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Ex
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         // Nothing to free
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         // Nothing to free
     }
 

File: codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
@@ -67,12 +67,12 @@ public void flush(
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         decoder.freeInboundBuffer(ctx, buf);
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         encoder.freeOutboundBuffer(ctx, buf);
     }
 

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuf;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerAdapter;
@@ -71,12 +71,12 @@ public void flush(
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         decoder.freeInboundBuffer(ctx, buf);
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         encoder.freeOutboundBuffer(ctx, buf);
     }
 

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerAdapter;
@@ -74,7 +74,7 @@ public MessageBuf<INBOUND_IN> newInboundBuffer(ChannelHandlerContext ctx) throws
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 
@@ -90,7 +90,7 @@ public MessageBuf<OUTBOUND_IN> newOutboundBuffer(ChannelHandlerContext ctx) thro
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufIndexFinder;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.SwappedByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.Signal;
@@ -74,8 +74,8 @@ public int maxCapacity() {
     }
 
     @Override
-    public ChannelBufType type() {
-        return ChannelBufType.BYTE;
+    public BufType type() {
+        return BufType.BYTE;
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.logging;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandler;
@@ -117,12 +117,12 @@ public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 

File: handler/src/main/java/io/netty/handler/logging/MessageLoggingHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.logging;
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFuture;
@@ -59,12 +59,12 @@ public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exc
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         // Nothing to free
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         // Nothing to free
     }
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.handler.ssl;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufUtil;
-import io.netty.buffer.ChannelBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFlushFutureNotifier;
 import io.netty.channel.ChannelFuture;
@@ -383,12 +383,12 @@ public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
@@ -97,7 +97,7 @@ public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Ex
     }
 
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         // Nothing to free
     }
 

File: transport/src/main/java/io/netty/channel/AbstractServerChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 
 import java.net.SocketAddress;
@@ -33,7 +33,7 @@
  */
 public abstract class AbstractServerChannel extends AbstractChannel implements ServerChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     /**
      * Creates a new instance.

File: transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
Patch:
@@ -16,13 +16,13 @@
 package io.netty.channel;
 
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 
 public abstract class ChannelInboundHandlerAdapter
         extends ChannelStateHandlerAdapter implements ChannelInboundHandler {
 
     @Override
-    public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeInboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
Patch:
@@ -15,14 +15,14 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 
 public interface ChannelOutboundHandler extends ChannelOperationHandler {
-    ChannelBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
+    Buf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
 
     /**
      * Invoked when this handler is not allowed to send any outbound message anymore and thus it's safe to
      * deallocate its outbound buffer.
      */
-    void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception;
+    void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
Patch:
@@ -15,12 +15,12 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.Buf;
 
 public abstract class ChannelOutboundHandlerAdapter
         extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler {
     @Override
-    public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
+    public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) throws Exception {
         buf.free();
     }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.channel;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.ChannelBuf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.util.DefaultAttributeMap;
@@ -268,7 +268,7 @@ public void run() {
         }
 
         if (type.contains(ChannelHandlerType.INBOUND)) {
-            ChannelBuf buf;
+            Buf buf;
             try {
                 buf = ((ChannelInboundHandler) handler).newInboundBuffer(this);
             } catch (Exception e) {
@@ -343,7 +343,7 @@ public void run() {
     }
 
     private void initOutboundBuffer() {
-        ChannelBuf buf;
+        Buf buf;
         try {
             buf = ((ChannelOutboundHandler) handler).newOutboundBuffer(this);
         } catch (Exception e) {

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.logging.InternalLogger;
@@ -1459,7 +1459,7 @@ void readable(DefaultChannelHandlerContext ctx, boolean readable) {
 
     private final class HeadHandler implements ChannelOutboundHandler {
         @Override
-        public ChannelBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
+        public Buf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
             switch (channel.metadata().bufferType()) {
             case BYTE:
                 return ctx.alloc().ioBuffer();
@@ -1471,7 +1471,7 @@ public ChannelBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception
         }
 
         @Override
-        public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) {
+        public void freeOutboundBuffer(ChannelHandlerContext ctx, Buf buf) {
             buf.free();
         }
 

File: transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.embedded;
 
+import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuf;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.AbstractChannel;
@@ -207,7 +207,7 @@ public void resumeRead() {
 
     private final class LastInboundMessageHandler extends ChannelInboundHandlerAdapter {
         @Override
-        public ChannelBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
+        public Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
             return lastInboundMessageBuffer;
         }
 
@@ -231,7 +231,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
 
     private final class LastInboundByteHandler extends ChannelInboundHandlerAdapter {
         @Override
-        public ChannelBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
+        public Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
             return lastInboundByteBuffer;
         }
 

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java
Patch:
@@ -15,15 +15,15 @@
  */
 package io.netty.channel.embedded;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelMetadata;
 
 public class EmbeddedByteChannel extends AbstractEmbeddedChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
 
     public EmbeddedByteChannel(ChannelHandler... handlers) {
         super(Unpooled.buffer(), handlers);

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
Patch:
@@ -15,15 +15,15 @@
  */
 package io.netty.channel.embedded;
 
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelMetadata;
 
 public class EmbeddedMessageChannel extends AbstractEmbeddedChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     public EmbeddedMessageChannel(ChannelHandler... handlers) {
         super(Unpooled.messageBuffer(), handlers);

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel.local;
 
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
@@ -41,7 +41,7 @@
  */
 public class LocalChannel extends AbstractChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private final ChannelConfig config = new DefaultChannelConfig();
     private final Runnable shutdownHook = new Runnable() {

File: transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel.socket.aio;
 
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
@@ -34,7 +34,7 @@
 
 public class AioServerSocketChannel extends AbstractAioChannel implements ServerSocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private static final AcceptHandler ACCEPT_HANDLER = new AcceptHandler();
     private static final InternalLogger logger =

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.socket.aio;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFlushFutureNotifier;
 import io.netty.channel.ChannelFuture;
@@ -43,7 +43,7 @@
 
 public class AioSocketChannel extends AbstractAioChannel implements SocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
 
     private static final CompletionHandler<Void, AioSocketChannel> CONNECT_HANDLER  = new ConnectHandler();
     private static final CompletionHandler<Integer, AioSocketChannel> WRITE_HANDLER = new WriteHandler<Integer>();

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.socket.nio;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelException;
@@ -49,7 +49,7 @@
 public final class NioDatagramChannel
         extends AbstractNioMessageChannel implements io.netty.channel.socket.DatagramChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, true);
 
     private final DatagramChannelConfig config;
     private final Map<InetAddress, List<MembershipKey>> memberships =

File: transport/src/main/java/io/netty/channel/socket/nio/NioSctpChannel.java
Patch:
@@ -19,8 +19,8 @@
 import com.sun.nio.sctp.MessageInfo;
 import com.sun.nio.sctp.NotificationHandler;
 import com.sun.nio.sctp.SctpChannel;
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
@@ -45,7 +45,7 @@
 import java.util.Set;
 
 public class NioSctpChannel extends AbstractNioMessageChannel implements io.netty.channel.socket.SctpChannel {
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSctpChannel.class);
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioSctpServerChannel.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpServerChannel;
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
@@ -35,7 +35,7 @@
 
 public class NioSctpServerChannel extends AbstractNioMessageChannel
         implements io.netty.channel.socket.SctpServerChannel {
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private static SctpServerChannel newSocket() {
         try {

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel.socket.nio;
 
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
@@ -32,7 +32,7 @@
 public class NioServerSocketChannel extends AbstractNioMessageChannel
                              implements io.netty.channel.socket.ServerSocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private static ServerSocketChannel newSocket() {
         try {

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.socket.nio;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
@@ -34,7 +34,7 @@
 
 public class NioSocketChannel extends AbstractNioByteChannel implements io.netty.channel.socket.SocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSocketChannel.class);
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.socket.oio;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelException;
@@ -44,7 +44,7 @@ public class OioDatagramChannel extends AbstractOioMessageChannel
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(OioDatagramChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, true);
 
     private static final byte[] EMPTY_DATA = new byte[0];
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioSctpChannel.java
Patch:
@@ -19,8 +19,8 @@
 import com.sun.nio.sctp.MessageInfo;
 import com.sun.nio.sctp.NotificationHandler;
 import com.sun.nio.sctp.SctpChannel;
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
@@ -49,7 +49,7 @@ public class OioSctpChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSctpChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private final SctpChannel ch;
     private final SctpChannelConfig config;

File: transport/src/main/java/io/netty/channel/socket/oio/OioSctpServerChannel.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpServerChannel;
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
@@ -40,7 +40,7 @@ public class OioSctpServerChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSctpServerChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private static SctpServerChannel newServerSocket() {
         try {

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel.socket.oio;
 
-import io.netty.buffer.ChannelBufType;
+import io.netty.buffer.BufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
@@ -40,7 +40,7 @@ public class OioServerSocketChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(OioServerSocketChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
 
     private static ServerSocket newServerSocket() {
         try {

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.socket.oio;
 
+import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
@@ -45,7 +45,7 @@ public class OioSocketChannel extends AbstractOioByteChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSocketChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
 
     private final Socket socket;
     private final SocketChannelConfig config;

File: codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java
Patch:
@@ -70,7 +70,7 @@ private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {
             }
         }
 
-        in.unsafe().discardSomeReadBytes();
+        in.discardSomeReadBytes();
         if (out.readableBytes() > oldOutSize) {
             ctx.fireInboundBufferUpdated();
         }

File: codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
Patch:
@@ -43,7 +43,7 @@ public void flush(ChannelHandlerContext ctx, ChannelFuture future) throws Except
             }
         }
 
-        in.unsafe().discardSomeReadBytes();
+        in.discardSomeReadBytes();
         ctx.flush(future);
     }
 

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -91,7 +91,7 @@ protected void callDecode(ChannelHandlerContext ctx) {
                     break;
                 }
             } catch (Throwable t) {
-                in.unsafe().discardSomeReadBytes();
+                in.discardSomeReadBytes();
 
                 if (decoded) {
                     decoded = false;
@@ -106,7 +106,7 @@ protected void callDecode(ChannelHandlerContext ctx) {
             }
         }
 
-        in.unsafe().discardSomeReadBytes();
+        in.discardSomeReadBytes();
 
         if (decoded) {
             ctx.fireInboundBufferUpdated();

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -75,7 +75,7 @@ public MessageBuf<INBOUND_IN> newInboundBuffer(ChannelHandlerContext ctx) throws
 
     @Override
     public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        buf.unsafe().free();
+        buf.free();
     }
 
     @Override
@@ -91,7 +91,7 @@ public MessageBuf<OUTBOUND_IN> newOutboundBuffer(ChannelHandlerContext ctx) thro
 
     @Override
     public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        buf.unsafe().free();
+        buf.free();
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -458,7 +458,7 @@ protected void callDecode(ChannelHandlerContext ctx) {
 
     private void fireInboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) {
         final int oldReaderIndex = in.readerIndex();
-        in.unsafe().discardSomeReadBytes();
+        in.discardSomeReadBytes();
         final int newReaderIndex = in.readerIndex();
         checkpoint -= oldReaderIndex - newReaderIndex;
         ctx.fireInboundBufferUpdated();

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -97,7 +97,7 @@ public void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Ex
                     oos.reset();
 
                     // Also discard the byproduct to avoid OOM on the sending side.
-                    out.unsafe().discardSomeReadBytes();
+                    out.discardSomeReadBytes();
                 }
             }
 

File: handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java
Patch:
@@ -118,12 +118,12 @@ public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        buf.unsafe().free();
+        buf.free();
     }
 
     @Override
     public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        buf.unsafe().free();
+        buf.free();
     }
 
     @Override

File: microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java
Patch:
@@ -51,7 +51,7 @@ protected void setUp() throws Exception {
     @Override
     protected void tearDown() throws Exception {
         for (ByteBuf b: queue) {
-            b.unsafe().free();
+            b.free();
         }
         queue.clear();
     }
@@ -63,7 +63,7 @@ public void timeAllocAndFree(int reps) {
 
         for (int i = 0; i < reps; i ++) {
             queue.add(alloc.buffer(size));
-            queue.removeFirst().unsafe().free();
+            queue.removeFirst().free();
         }
     }
 

File: transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java
Patch:
@@ -43,7 +43,7 @@ public final void inboundBufferUpdated(ChannelHandlerContext ctx) throws Excepti
             inboundBufferUpdated(ctx, in);
         } finally {
             if (!in.readable()) {
-                in.unsafe().discardSomeReadBytes();
+                in.discardReadBytes();
             }
         }
     }

File: transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
Patch:
@@ -23,7 +23,7 @@ public abstract class ChannelInboundHandlerAdapter
 
     @Override
     public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        buf.unsafe().free();
+        buf.free();
     }
 
     /**

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
Patch:
@@ -21,7 +21,7 @@ public abstract class ChannelOutboundHandlerAdapter
         extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler {
     @Override
     public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        buf.unsafe().free();
+        buf.free();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1237,8 +1237,7 @@ private void fill() {
                 data = ctx.alloc().buffer(dataLen, dataLen);
             }
 
-            byteBuf.readBytes(data, dataLen);
-            byteBuf.unsafe().discardSomeReadBytes();
+            byteBuf.readBytes(data, dataLen).discardSomeReadBytes();
 
             exchangeBuf.add(data);
         }
@@ -1259,7 +1258,7 @@ private void flush(ByteBuf out) {
                     try {
                         out.writeBytes(data);
                     } finally {
-                        data.unsafe().free();
+                        data.free();
                     }
                 }
             }

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1472,7 +1472,7 @@ public ChannelBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception
 
         @Override
         public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) {
-            buf.unsafe().free();
+            buf.free();
         }
 
         @Override

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -412,7 +412,7 @@ public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws
 
         @Override
         public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) {
-            buf.unsafe().free();
+            buf.free();
         }
 
         @Override
@@ -464,7 +464,7 @@ public void flush(ChannelHandlerContext ctx,
                     out.add(msg);
                 }
             }
-            in.unsafe().discardSomeReadBytes();
+            in.discardSomeReadBytes();
             if (swallow) {
                 future.setSuccess();
             } else {
@@ -507,7 +507,7 @@ public MessageBuf<Integer> newOutboundBuffer(
 
         @Override
         public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-            buf.unsafe().free();
+            buf.free();
         }
 
         @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -91,7 +91,7 @@ public WebSocketClientHandshaker00(URI webSocketURL, WebSocketVersion version, S
      *            Channel into which we can write our request
      */
     @Override
-    public ChannelFuture handshake(Channel channel) {
+    public ChannelFuture handshake(Channel channel, final ChannelFuture handshakeFuture) {
         // Make keys
         int spaces1 = WebSocketUtil.randomNumber(1, 12);
         int spaces2 = WebSocketUtil.randomNumber(1, 12);
@@ -173,9 +173,7 @@ public ChannelFuture handshake(Channel channel) {
         request.setHeader(Names.CONTENT_LENGTH, key3.length);
         request.setContent(Unpooled.copiedBuffer(key3));
 
-        final ChannelFuture handshakeFuture = channel.newFuture();
         ChannelFuture future = channel.write(request);
-
         future.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -97,7 +97,7 @@ public WebSocketClientHandshaker08(URI webSocketURL, WebSocketVersion version, S
      *            Channel into which we can write our request
      */
     @Override
-    public ChannelFuture handshake(Channel channel) {
+    public ChannelFuture handshake(Channel channel, final ChannelFuture handshakeFuture) {
         // Get path
         URI wsURL = getWebSocketUrl();
         String path = wsURL.getPath();
@@ -151,9 +151,7 @@ public ChannelFuture handshake(Channel channel) {
             }
         }
 
-        final ChannelFuture handshakeFuture = channel.newFuture();
         ChannelFuture future = channel.write(request);
-
         future.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -97,7 +97,7 @@ public WebSocketClientHandshaker13(URI webSocketURL, WebSocketVersion version, S
      *            Channel into which we can write our request
      */
     @Override
-    public ChannelFuture handshake(Channel channel) {
+    public ChannelFuture handshake(Channel channel, final ChannelFuture handshakeFuture) {
         // Get path
         URI wsURL = getWebSocketUrl();
         String path = wsURL.getPath();
@@ -151,9 +151,7 @@ public ChannelFuture handshake(Channel channel) {
             }
         }
 
-        final ChannelFuture handshakeFuture = channel.newFuture();
         ChannelFuture future = channel.write(request);
-
         future.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) {

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java
Patch:
@@ -216,7 +216,7 @@ public void testCompositeWrappedBuffer() {
         assertEquals(512, payload.readableBytes());
 
         assertEquals(12 + 512, buffer.readableBytes());
-        assertFalse(buffer.hasNioBuffer());
+        assertEquals(2, buffer.nioBufferCount());
     }
 
     @Test

File: buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java
Patch:
@@ -49,7 +49,7 @@ public void testCompositeWrappedBuffer() {
         assertEquals(512, payload.readableBytes());
 
         assertEquals(12 + 512, buffer.readableBytes());
-        assertFalse(buffer.hasNioBuffer());
+        assertEquals(2, buffer.nioBufferCount());
     }
 
     @Test

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -133,7 +133,7 @@ public void addContent(ByteBuf buffer, boolean last)
                 throw new IOException("Out of size: " + (size + localsize) +
                         " > " + definedSize);
             }
-            ByteBuffer byteBuffer = buffer.hasNioBuffer() ? buffer.nioBuffer() : buffer.copy().nioBuffer();
+            ByteBuffer byteBuffer = buffer.nioBufferCount() == 1 ? buffer.nioBuffer() : buffer.copy().nioBuffer();
             int written = 0;
             if (file == null) {
                 file = tempFile();

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -193,7 +193,7 @@ protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws E
         ByteBuf data = packet.data();
         int dataLen = data.readableBytes();
         ByteBuffer nioData;
-        if (data.hasNioBuffer()) {
+        if (data.nioBufferCount() == 1) {
             nioData = data.nioBuffer();
         } else {
             nioData = ByteBuffer.allocate(dataLen);

File: transport/src/main/java/io/netty/channel/socket/nio/NioSctpChannel.java
Patch:
@@ -241,7 +241,7 @@ protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws E
         ByteBuf data = packet.getPayloadBuffer();
         int dataLen = data.readableBytes();
         ByteBuffer nioData;
-        if (data.hasNioBuffer()) {
+        if (data.nioBufferCount() == 1) {
             nioData = data.nioBuffer();
         } else {
             nioData = ByteBuffer.allocate(dataLen);

File: transport/src/main/java/io/netty/channel/socket/oio/OioSctpChannel.java
Patch:
@@ -136,7 +136,7 @@ protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
         ByteBuf data = packet.getPayloadBuffer();
         int dataLen = data.readableBytes();
         ByteBuffer nioData;
-        if (data.hasNioBuffer()) {
+        if (data.nioBufferCount() == 1) {
             nioData = data.nioBuffer();
         } else {
             nioData = ByteBuffer.allocate(dataLen);

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -1745,7 +1745,7 @@ public interface ByteBuf extends ChannelBuf, Comparable<ByteBuf> {
     ByteBuffer[] nioBuffers();
 
     /**
-     * Exposes this buffer's bytes as an NIO {@link ByteBuffer}'s for the specified offset and length
+     * Exposes this buffer's bytes as an NIO {@link ByteBuffer}'s for the specified index and length
      * The returned buffer shares the content with this buffer, while changing the position and limit
      * of the returned NIO buffer does not affect the indexes and marks of this buffer. This method does
      * not modify {@code readerIndex} or {@code writerIndex} of this buffer.  Please note that the
@@ -1756,7 +1756,7 @@ public interface ByteBuf extends ChannelBuf, Comparable<ByteBuf> {
      * @throws UnsupportedOperationException
      *         if this buffer cannot create a {@link ByteBuffer} that shares the content with itself
      */
-    ByteBuffer[] nioBuffers(int offset, int length);
+    ByteBuffer[] nioBuffers(int index, int length);
 
     /**
      * Returns {@code true} if and only if this buffer has a backing byte array.

File: buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
Patch:
@@ -31,7 +31,7 @@
  * parent.  It is recommended to use {@link ByteBuf#duplicate()} instead
  * of calling the constructor explicitly.
  */
-final class DuplicatedByteBuf extends AbstractByteBuf  implements Unsafe {
+public class DuplicatedByteBuf extends AbstractByteBuf implements Unsafe {
 
     private final ByteBuf buffer;
 
@@ -235,8 +235,8 @@ public boolean hasNioBuffers() {
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int offset, int length) {
-        return buffer.nioBuffers(offset, length);
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return buffer.nioBuffers(index, length);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
Patch:
@@ -31,7 +31,7 @@
  * recommended to use {@link Unpooled#unmodifiableBuffer(ByteBuf)}
  * instead of calling the constructor explicitly.
  */
-final class ReadOnlyByteBuf extends AbstractByteBuf implements Unsafe {
+public class ReadOnlyByteBuf extends AbstractByteBuf implements Unsafe {
 
     private final ByteBuf buffer;
 
@@ -223,8 +223,8 @@ public boolean hasNioBuffers() {
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int offset, int length) {
-        return buffer.nioBuffers(offset, length);
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return buffer.nioBuffers(index, length);
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
Patch:
@@ -32,7 +32,7 @@
  * {@link ByteBuf#slice(int, int)} instead of calling the constructor
  * explicitly.
  */
-final class SlicedByteBuf extends AbstractByteBuf implements Unsafe {
+public class SlicedByteBuf extends AbstractByteBuf implements Unsafe {
 
     private final ByteBuf buffer;
     private final int adjustment;

File: buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
Patch:
@@ -735,8 +735,8 @@ public ByteBuffer[] nioBuffers() {
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int offset, int length) {
-        ByteBuffer[] nioBuffers = buf.nioBuffers(offset, length);
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        ByteBuffer[] nioBuffers = buf.nioBuffers(index, length);
         for (int i = 0; i < nioBuffers.length; i++) {
             nioBuffers[i] = nioBuffers[i].order(order);
         }

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
@@ -26,12 +25,13 @@
 import io.netty.handler.codec.serialization.ClassResolvers;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 import io.netty.handler.codec.serialization.ObjectEncoder;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketObjectEchoTest extends AbstractSocketTest {
 

File: transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.UnpooledByteBufAllocator;
+import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.channel.socket.SocketChannelConfig;
 
 import java.util.IdentityHashMap;
@@ -30,7 +30,7 @@
  */
 public class DefaultChannelConfig implements ChannelConfig {
 
-    private static final ByteBufAllocator DEFAULT_ALLOCATOR = UnpooledByteBufAllocator.HEAP_BY_DEFAULT;
+    private static final ByteBufAllocator DEFAULT_ALLOCATOR = PooledByteBufAllocator.DEFAULT;
     private static final int DEFAULT_CONNECT_TIMEOUT = 30000;
 
     private volatile ByteBufAllocator allocator = DEFAULT_ALLOCATOR;

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -1252,7 +1252,7 @@ private void flush(ByteBuf out) {
 
                 if (out.writerIndex() > out.maxCapacity() - data.readableBytes()) {
                     // The target buffer is not going to be able to accept all data in the bridge.
-                    out.ensureWritableBytes(out.maxCapacity() - out.writerIndex());
+                    out.capacity(out.maxCapacity());
                     out.writeBytes(data, out.writableBytes());
                 } else {
                     exchangeBuf.remove();

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -527,7 +527,6 @@ public void inboundBufferUpdated(
 
             ByteBuf in = ctx.inboundByteBuffer();
             MessageBuf<Object> out = ctx.nextInboundMessageBuffer();
-
             while (in.readableBytes() >= 4) {
                 int msg = in.readInt();
                 int expected = inCnt ++;

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
Patch:
@@ -75,7 +75,7 @@ public MessageBuf<INBOUND_IN> newInboundBuffer(ChannelHandlerContext ctx) throws
 
     @Override
     public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        // Nothing to free
+        buf.unsafe().free();
     }
 
     @Override
@@ -91,7 +91,7 @@ public MessageBuf<OUTBOUND_IN> newOutboundBuffer(ChannelHandlerContext ctx) thro
 
     @Override
     public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {
-        // Nothing to free
+        buf.unsafe().free();
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -201,13 +201,13 @@ public void finishHandshake(Channel channel, HttpResponse response) {
         }
 
         String upgrade = response.getHeader(Names.UPGRADE);
-        if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: "
                     + response.getHeader(Names.UPGRADE));
         }
 
         String connection = response.getHeader(Names.CONNECTION);
-        if (Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: "
                     + response.getHeader(Names.CONNECTION));
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -200,13 +200,13 @@ public void finishHandshake(Channel channel, HttpResponse response) {
         }
 
         String upgrade = response.getHeader(Names.UPGRADE);
-        if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: "
                     + response.getHeader(Names.UPGRADE));
         }
 
         String connection = response.getHeader(Names.CONNECTION);
-        if (Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: "
                     + response.getHeader(Names.CONNECTION));
         }

File: codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
Patch:
@@ -130,7 +130,7 @@ public void replace(String newHandlerName, ChannelInboundByteHandler newHandler)
         ByteBuf in = ctx.inboundByteBuffer();
         try {
             if (in.readable()) {
-                ctx.nextInboundByteBuffer().writeBytes(ctx.inboundByteBuffer());
+                ctx.nextInboundByteBuffer().writeBytes(in);
                 ctx.fireInboundBufferUpdated();
             }
         } finally {

File: codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequest.java
Patch:
@@ -28,6 +28,7 @@
  */
 public final class SocksAuthRequest extends SocksRequest {
     private static final CharsetEncoder asciiEncoder = CharsetUtil.getEncoder(CharsetUtil.US_ASCII);
+    private static final SubnegotiationVersion SUBNEGOTIATION_VERSION = SubnegotiationVersion.AUTH_PASSWORD;
     private final String username;
     private final String password;
 
@@ -73,7 +74,7 @@ public String getPassword() {
 
     @Override
     public void encodeAsByteBuf(ByteBuf byteBuf) {
-        byteBuf.writeByte(getProtocolVersion().getByteValue());
+        byteBuf.writeByte(SUBNEGOTIATION_VERSION.getByteValue());
         byteBuf.writeByte(username.length());
         byteBuf.writeBytes(username.getBytes(CharsetUtil.US_ASCII));
         byteBuf.writeByte(password.length());

File: codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequestDecoder.java
Patch:
@@ -31,7 +31,7 @@ public static String getName() {
         return name;
     }
 
-    private SocksMessage.ProtocolVersion version;
+    private SocksMessage.SubnegotiationVersion version;
     private int fieldLength;
     private String username;
     private String password;
@@ -45,8 +45,8 @@ public SocksAuthRequestDecoder() {
     public SocksRequest decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksMessage.ProtocolVersion.fromByte(byteBuf.readByte());
-                if (version != SocksMessage.ProtocolVersion.SOCKS5) {
+                version = SocksMessage.SubnegotiationVersion.fromByte(byteBuf.readByte());
+                if (version != SocksMessage.SubnegotiationVersion.AUTH_PASSWORD) {
                     break;
                 }
                 checkpoint(State.READ_USERNAME);

File: codec-socks/src/main/java/io/netty/codec/socks/SocksAuthResponse.java
Patch:
@@ -24,7 +24,7 @@
  * @see SocksAuthResponseDecoder
  */
 public final class SocksAuthResponse extends SocksResponse {
-
+    private static final SubnegotiationVersion SUBNEGOTIATION_VERSION = SubnegotiationVersion.AUTH_PASSWORD;
     private final AuthStatus authStatus;
 
     /**
@@ -52,7 +52,7 @@ public AuthStatus getAuthStatus() {
 
     @Override
     public void encodeAsByteBuf(ByteBuf byteBuf) {
-        byteBuf.writeByte(getProtocolVersion().getByteValue());
+        byteBuf.writeByte(SUBNEGOTIATION_VERSION.getByteValue());
         byteBuf.writeByte(authStatus.getByteValue());
     }
 }

File: codec-socks/src/main/java/io/netty/codec/socks/SocksAuthResponseDecoder.java
Patch:
@@ -30,7 +30,7 @@ public static String getName() {
         return name;
     }
 
-    private SocksMessage.ProtocolVersion version;
+    private SocksMessage.SubnegotiationVersion version;
     private SocksMessage.AuthStatus authStatus;
     private SocksResponse msg = SocksCommonUtils.UNKNOWN_SOCKS_RESPONSE;
 
@@ -42,8 +42,8 @@ public SocksAuthResponseDecoder() {
     public SocksResponse decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksMessage.ProtocolVersion.fromByte(byteBuf.readByte());
-                if (version != SocksMessage.ProtocolVersion.SOCKS5) {
+                version = SocksMessage.SubnegotiationVersion.fromByte(byteBuf.readByte());
+                if (version != SocksMessage.SubnegotiationVersion.AUTH_PASSWORD) {
                     break;
                 }
                 checkpoint(State.READ_AUTH_RESPONSE);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -181,7 +181,7 @@ public void operationComplete(ChannelFuture future) {
                 if (p.get(HttpChunkAggregator.class) != null) {
                     p.remove(HttpChunkAggregator.class);
                 }
-                p.replace(HttpRequestDecoder.class, "wsdecoder",
+                p.get(HttpRequestDecoder.class).replace("wsdecoder",
                         new WebSocket00FrameDecoder(getMaxFramePayloadLength()));
 
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket00FrameEncoder());

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -155,7 +155,7 @@ public void operationComplete(ChannelFuture future) {
                     p.remove(HttpChunkAggregator.class);
                 }
 
-                p.replace(HttpRequestDecoder.class, "wsdecoder",
+                p.get(HttpRequestDecoder.class).replace("wsdecoder",
                         new WebSocket08FrameDecoder(true, allowExtensions, getMaxFramePayloadLength()));
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket08FrameEncoder(false));
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -155,7 +155,7 @@ public void operationComplete(ChannelFuture future) {
                     p.remove(HttpChunkAggregator.class);
                 }
 
-                p.replace(HttpRequestDecoder.class, "wsdecoder",
+                p.get(HttpRequestDecoder.class).replace("wsdecoder",
                         new WebSocket13FrameDecoder(true, allowExtensions, getMaxFramePayloadLength()));
                 p.replace(HttpResponseEncoder.class, "wsencoder", new WebSocket13FrameEncoder(false));
             }

File: buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
Patch:
@@ -265,4 +265,5 @@ public void suspendIntermediaryDeallocations() { }
 
     @Override
     public void resumeIntermediaryDeallocations() { }
-}
\ No newline at end of file
+}
+

File: codec-socks/src/test/java/io/netty/codec/socks/SocksAuthRequestDecoderTest.java
Patch:
@@ -17,12 +17,13 @@
 
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import org.junit.Test;
+import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static org.junit.Assert.*;
 
 public class SocksAuthRequestDecoderTest {
-    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(SocksAuthRequestDecoderTest.class);
+    private static final Logger logger = LoggerFactory.getLogger(SocksAuthRequestDecoderTest.class);
     @Test
     public void testAuthRequestDecoder() {
         String username = "test";

File: codec-socks/src/test/java/io/netty/codec/socks/SocksAuthResponseDecoderTest.java
Patch:
@@ -17,12 +17,13 @@
 
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import org.junit.Test;
+import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static org.junit.Assert.*;
 
 public class SocksAuthResponseDecoderTest {
-    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(SocksAuthResponseDecoderTest.class);
+    private static final Logger logger = LoggerFactory.getLogger(SocksAuthResponseDecoderTest.class);
     private static void testSocksAuthResponseDecoderWithDifferentParams(SocksMessage.AuthStatus authStatus){
         logger.debug("Testing SocksAuthResponseDecoder with authStatus: "+ authStatus);
         SocksAuthResponse msg = new SocksAuthResponse(authStatus);

File: codec-socks/src/test/java/io/netty/codec/socks/SocksCmdRequestDecoderTest.java
Patch:
@@ -17,13 +17,14 @@
 
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import org.junit.Test;
+import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import sun.net.util.IPAddressUtil;
 
 import static org.junit.Assert.*;
 
 public class SocksCmdRequestDecoderTest {
-    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(SocksCmdRequestDecoderTest.class);
+    private static final Logger logger = LoggerFactory.getLogger(SocksCmdRequestDecoderTest.class);
 
     private static void testSocksCmdRequestDecoderWithDifferentParams(SocksMessage.CmdType cmdType, SocksMessage.AddressType addressType, String host, int port) {
         logger.debug("Testing cmdType: " + cmdType + " addressType: " + addressType + " host: " + host + " port: " + port);

File: codec-socks/src/test/java/io/netty/codec/socks/SocksCmdResponseDecoderTest.java
Patch:
@@ -17,12 +17,13 @@
 
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import org.junit.Test;
+import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static org.junit.Assert.*;
 
 public class SocksCmdResponseDecoderTest {
-    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(SocksCmdResponseDecoderTest.class);
+    private static final Logger logger = LoggerFactory.getLogger(SocksCmdResponseDecoderTest.class);
 
     private static void testSocksCmdResponseDecoderWithDifferentParams(SocksMessage.CmdStatus cmdStatus, SocksMessage.AddressType addressType){
         logger.debug("Testing cmdStatus: " + cmdStatus + " addressType: " + addressType);

File: codec-socks/src/test/java/io/netty/codec/socks/SocksCommonTestUtils.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedByteChannel;
 
-class SocksCommonTestUtils {
+final class SocksCommonTestUtils {
     /**
      * A constructor to stop this class being constructed.
      */

File: codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
Patch:
@@ -208,7 +208,7 @@ private static boolean isLineBased(final ByteBuf[] delimiters) {
      * Return {@code true} if the current instance is a subclass of DelimiterBasedFrameDecoder
      */
     private boolean isSubclass() {
-        return this.getClass() != DelimiterBasedFrameDecoder.class;
+        return getClass() != DelimiterBasedFrameDecoder.class;
     }
     @Override
     public Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {

File: example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
Patch:
@@ -71,7 +71,7 @@ public void messageReceived(ChannelHandlerContext ctx, SocksRequest socksRequest
     }
 
     @Override
-    public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable throwable) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) throws Exception {
         throwable.printStackTrace();
         SocksServerUtils.closeOnFlush(ctx.channel());
     }

File: codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequestDecoder.java
Patch:
@@ -45,7 +45,7 @@ public SocksAuthRequestDecoder() {
     public SocksRequest decode(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksMessage.ProtocolVersion.fromByte((byte) byteBuf.readByte());
+                version = SocksMessage.ProtocolVersion.fromByte(byteBuf.readByte());
                 if (version != SocksMessage.ProtocolVersion.SOCKS5) {
                     break;
                 }

File: example/src/main/java/io/netty/example/socksproxy/CallbackNotifier.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.ChannelHandlerContext;
 
 public interface CallbackNotifier {
-    void onSuccess(final ChannelHandlerContext outboundCtx);
-
-    void onFailure(final ChannelHandlerContext outboundCtx, final Throwable cause);
+    void onSuccess(ChannelHandlerContext outboundCtx);
+    void onFailure(ChannelHandlerContext outboundCtx, Throwable cause);
 }

File: example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
Patch:
@@ -24,8 +24,6 @@
 import io.netty.codec.socks.SocksRequest;
 import io.netty.codec.socks.SocksAuthResponse;
 import io.netty.codec.socks.SocksCmdRequest;
-import io.netty.codec.socks.SocksCmdResponse;
-
 
 
 @ChannelHandler.Sharable

File: handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
Patch:
@@ -32,7 +32,6 @@
 import java.nio.channels.Channels;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Assert;
 import org.junit.Test;
 
 public class ChunkedWriteHandlerTest {

File: common/src/main/java/io/netty/util/DefaultAttributeMap.java
Patch:
@@ -32,6 +32,7 @@ public synchronized <T> Attribute<T> attr(AttributeKey<T> key) {
             map = this.map = new IdentityHashMap<AttributeKey<?>, Attribute<?>>(2);
         }
 
+        @SuppressWarnings("unchecked")
         Attribute<T> attr = (Attribute<T>) map.get(key);
         if (attr == null) {
             attr = new DefaultAttribute<T>();

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -153,7 +153,9 @@ public <T> B attr(AttributeKey<T> key, T value) {
             attrs.put(key, value);
         }
 
-        return (B) this;
+        @SuppressWarnings("unchecked")
+        B b = (B) this;
+        return b;
     }
 
     /**

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -173,7 +173,9 @@ public ChannelFuture bind(ChannelFuture future) {
         }
 
         for (Entry<AttributeKey<?>, Object> e: attrs().entrySet()) {
-            channel.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());
+            @SuppressWarnings("unchecked")
+            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();
+            channel.attr(key).set(e.getValue());
         }
 
         ChannelPipeline p = future.channel().pipeline();

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -278,8 +278,9 @@ public ByteBuf outboundByteBuffer() {
     }
 
     @Override
-    public MessageBuf<Object> outboundMessageBuffer() {
-        return pipeline.outboundMessageBuffer();
+    @SuppressWarnings("unchecked")
+    public <T> MessageBuf<T> outboundMessageBuffer() {
+        return (MessageBuf<T>) pipeline.outboundMessageBuffer();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/AbstractServerChannel.java
Patch:
@@ -49,7 +49,7 @@ public ByteBuf outboundByteBuffer() {
     }
 
     @Override
-    public MessageBuf<Object> outboundMessageBuffer() {
+    public <T> MessageBuf<T> outboundMessageBuffer() {
         throw new NoSuchBufferException(String.format(
                 "%s does not have an outbound buffer.", ServerChannel.class.getSimpleName()));
     }

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -205,9 +205,9 @@
  */
 public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker {
 
-    MessageBuf<Object> inboundMessageBuffer();
+    <T> MessageBuf<T> inboundMessageBuffer();
     ByteBuf inboundByteBuffer();
-    MessageBuf<Object> outboundMessageBuffer();
+    <T> MessageBuf<T> outboundMessageBuffer();
     ByteBuf outboundByteBuffer();
 
     /**

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -355,7 +355,9 @@ private void initOutboundBuffer() {
         } else if (buf instanceof MessageBuf) {
             outByteBuf = null;
             outByteBridge = null;
-            outMsgBuf = (MessageBuf<Object>) buf;
+            @SuppressWarnings("unchecked")
+            MessageBuf<Object> msgBuf = (MessageBuf<Object>) buf;
+            outMsgBuf = msgBuf;
             outMsgBridge = new AtomicReference<MessageBridge>();
         } else {
             throw new Error();

File: transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java
Patch:
@@ -249,7 +249,7 @@ protected void run() {
 
                 if (isShutdown()) {
                     closeAll();
-                    if (peekTask() == null) {
+                    if (confirmShutdown()) {
                         break;
                     }
                 }

File: buffer/src/test/java/io/netty/buffer/DuplicateChannelBufferTest.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.buffer;
 
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 /**
  * Tests duplicated channel buffers
  */
@@ -28,7 +28,7 @@ public class DuplicateChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = new DuplicatedByteBuf(Unpooled.buffer(length));
+        buffer = new DuplicatedByteBuf((UnsafeByteBuf) Unpooled.buffer(length));
         assertEquals(0, buffer.writerIndex());
         return buffer;
     }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
@@ -64,7 +63,7 @@ protected SpdyOrHttpChooser(int maxSpdyContentLength, int maxHttpContentLength)
 
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.buffer();
+        return ctx.alloc().buffer();
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.UnsafeByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 
@@ -70,7 +71,7 @@ private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {
             }
         }
 
-        in.unsafe().discardSomeReadBytes();
+        ((UnsafeByteBuf) in).discardSomeReadBytes();
         if (out.readableBytes() > oldOutSize) {
             ctx.fireInboundBufferUpdated();
         }

File: codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.UnsafeByteBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundByteHandlerAdapter;
@@ -43,7 +44,7 @@ public void flush(ChannelHandlerContext ctx, ChannelFuture future) throws Except
             }
         }
 
-        in.unsafe().discardSomeReadBytes();
+        ((UnsafeByteBuf) in).discardSomeReadBytes();
         ctx.flush(future);
     }
 

File: codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 
 /**
@@ -68,7 +67,7 @@ public FixedLengthFrameDecoder(int frameLength, boolean allocateFullBuffer) {
     @Override
     public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
         if (allocateFullBuffer) {
-            return Unpooled.buffer(frameLength);
+            return ctx.alloc().buffer(frameLength);
         } else {
             return super.newInboundBuffer(ctx);
         }

File: codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 
@@ -426,7 +427,7 @@ private void failIfNecessary(ChannelHandlerContext ctx, boolean firstDetectionOf
      * is overridden to avoid memory copy.
      */
     protected ByteBuf extractFrame(ByteBuf buffer, int index, int length) {
-        ByteBuf frame = buffer.unsafe().newBuffer(length);
+        ByteBuf frame = Unpooled.buffer(length);
         frame.writeBytes(buffer, index, length);
         return frame;
     }

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.UnsafeByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToByteEncoder;
 import io.netty.util.Attribute;
@@ -97,7 +98,7 @@ public void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Ex
                     oos.reset();
 
                     // Also discard the byproduct to avoid OOM on the sending side.
-                    out.unsafe().discardSomeReadBytes();
+                    ((UnsafeByteBuf) out).discardSomeReadBytes();
                 }
             }
 

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.channel;
 
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.util.UniqueName;
 
 import java.net.InetAddress;
@@ -28,6 +29,7 @@ public class ChannelOption<T> extends UniqueName {
 
     private static final ConcurrentMap<String, Boolean> names = new ConcurrentHashMap<String, Boolean>();
 
+    public static final ChannelOption<ByteBufAllocator> ALLOCATOR = new ChannelOption<ByteBufAllocator>("ALLOCATOR");
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS =
             new ChannelOption<Integer>("CONNECT_TIMEOUT_MILLIS");
     public static final ChannelOption<Integer> WRITE_SPIN_COUNT =

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecompressor.java
Patch:
@@ -24,6 +24,6 @@ static SpdyHeaderBlockDecompressor newInstance(int version) {
     }
 
     abstract void setInput(ByteBuf compressed);
-    abstract void decode(ByteBuf decompressed) throws Exception;
+    abstract int decode(ByteBuf decompressed) throws Exception;
     abstract void end();
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecompressor.java
Patch:
@@ -43,7 +43,7 @@ public void setInput(ByteBuf compressed) {
     }
 
     @Override
-    public void decode(ByteBuf decompressed) throws Exception {
+    public int decode(ByteBuf decompressed) throws Exception {
         try {
             int numBytes = decompressor.inflate(out);
             if (numBytes == 0 && decompressor.needsDictionary()) {
@@ -55,6 +55,7 @@ public void decode(ByteBuf decompressed) throws Exception {
                 numBytes = decompressor.inflate(out);
             }
             decompressed.writeBytes(out, 0, numBytes);
+            return numBytes;
         } catch (DataFormatException e) {
             throw new SpdyProtocolException(
                     "Received invalid header block", e);

File: transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java
Patch:
@@ -63,7 +63,7 @@ public final void inboundBufferUpdated(ChannelHandlerContext ctx) throws Excepti
                     }
                     messageReceived(ctx, (I) msg);
                 } catch (Throwable t) {
-                    ctx.fireExceptionCaught(t);
+                    exceptionCaught(ctx, t);
                 }
             }
         } finally {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
Patch:
@@ -34,10 +34,10 @@ public class SpdySessionStatus implements Comparable<SpdySessionStatus> {
         new SpdySessionStatus(1, "PROTOCOL_ERROR");
 
     /**
-     * 11 Internal Error
+     * 2 Internal Error
      */
     public static final SpdySessionStatus INTERNAL_ERROR =
-        new SpdySessionStatus(11, "INTERNAL_ERROR");
+        new SpdySessionStatus(2, "INTERNAL_ERROR");
 
     /**
      * Returns the {@link SpdySessionStatus} represented by the specified code.
@@ -50,7 +50,7 @@ public static SpdySessionStatus valueOf(int code) {
             return OK;
         case 1:
             return PROTOCOL_ERROR;
-        case 11:
+        case 2:
             return INTERNAL_ERROR;
         }
 

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -101,7 +101,7 @@ public ServerBootstrap channel(Class<? extends Channel> channelClass) {
             throw new IllegalArgumentException();
         }
         if (channelClass == AioServerSocketChannel.class) {
-            channelFactory(new AioServerSocketChannelFactory());
+            return channelFactory(new AioServerSocketChannelFactory());
         }
         return super.channel(channelClass);
     }

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
Patch:
@@ -25,7 +25,6 @@
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.Marshalling;
 import org.jboss.marshalling.MarshallingConfiguration;
-import org.junit.Assert;
 import org.junit.Test;
 
 import java.io.ByteArrayOutputStream;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
Patch:
@@ -72,7 +72,7 @@ protected AbstractDiskHttpData(String name, Charset charset, long size) {
      * @return a new Temp File from getDiskFilename(), default prefix, postfix and baseDirectory
      */
     private File tempFile() throws IOException {
-        String newpostfix = null;
+        String newpostfix;
         String diskFilename = getDiskFilename();
         if (diskFilename != null) {
             newpostfix = '_' + diskFilename;

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -467,7 +467,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                 // previously a data field so CRLF
                 internal.addValue("\r\n");
             }
-            boolean localMixed = false;
+            boolean localMixed;
             if (duringMixedMode) {
                 if (currentFileUpload != null && currentFileUpload.getName().equals(fileUpload.getName())) {
                     // continue a mixed mode
@@ -918,7 +918,7 @@ private HttpChunk nextChunk() throws ErrorDataEncoderException {
             isLastChunkSent = true;
             return new DefaultHttpChunk(EMPTY_BUFFER);
         }
-        ByteBuf buffer = null;
+        ByteBuf buffer;
         int size = HttpPostBodyUtil.chunkSize;
         // first test if previous buffer is not empty
         if (currentBuffer != null) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -168,7 +168,7 @@ public void encode(
             int counter = 0;
             for (int i = data.readerIndex(); i < data.writerIndex(); i ++) {
                 byte byteData = data.getByte(i);
-                out.writeByte(byteData ^ mask[+counter++ % 4]);
+                out.writeByte(byteData ^ mask[counter++ % 4]);
             }
         } else {
             out.writeBytes(data, data.readerIndex(), data.readableBytes());

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -182,7 +182,7 @@ public void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Ex
             out.writeInt(numEntries);
             for (Integer ID: IDs) {
                 int id = ID.intValue();
-                byte ID_flags = (byte) 0;
+                byte ID_flags = 0;
                 if (spdySettingsFrame.isPersistValue(id)) {
                     ID_flags |= SPDY_SETTINGS_PERSIST_VALUE;
                 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -40,7 +40,7 @@ public SpdyHttpResponseStreamIdHandler() {
     @Override
     public HttpMessage encode(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {
         Integer id = ids.poll();
-        if (id != null && id != NO_ID && !msg.containsHeader(SpdyHttpHeaders.Names.STREAM_ID)) {
+        if (id != null && id.intValue() != NO_ID && !msg.containsHeader(SpdyHttpHeaders.Names.STREAM_ID)) {
             SpdyHttpHeaders.setStreamId(msg, id);
         }
         return msg;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
Patch:
@@ -15,8 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-import javax.net.ssl.SSLEngine;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
@@ -31,6 +29,8 @@
 import io.netty.handler.codec.http.HttpResponseEncoder;
 import io.netty.handler.ssl.SslHandler;
 
+import javax.net.ssl.SSLEngine;
+
 /**
  * {@link ChannelInboundByteHandler} which is responsible to setup the {@link ChannelPipeline} either for
  * HTTP or SPDY. This offers an easy way for users to support both at the same time while not care to
@@ -89,7 +89,6 @@ private boolean initPipeline(ChannelHandlerContext ctx) {
             throw new IllegalStateException("SslHandler is needed for SPDY");
         }
 
-        ChannelPipeline pipeline = ctx.pipeline();
         SelectedProtocol protocol = getProtocol(handler.getEngine());
         switch (protocol) {
         case None:

File: common/src/main/java/io/netty/util/internal/DetectionUtil.java
Patch:
@@ -114,7 +114,7 @@ private static boolean hasUnsafe(ClassLoader loader) {
         }
 
         // Legacy properties
-        boolean tryUnsafe = false;
+        boolean tryUnsafe;
         if (SystemPropertyUtil.contains("io.netty.tryUnsafe")) {
             tryUnsafe = SystemPropertyUtil.getBoolean("io.netty.tryUnsafe", true);
         } else {

File: common/src/main/java/io/netty/util/internal/jzlib/Deflate.java
Patch:
@@ -349,7 +349,7 @@ private void scan_tree(short[] tree, // the tree to be scanned
         int n; // iterates over all tree elements
         int prevlen = -1; // last emitted length
         int curlen; // length of current code
-        int nextlen = tree[0 * 2 + 1]; // length of next code
+        int nextlen = tree[1]; // length of next code
         int count = 0; // repeat count of the current code
         int max_count = 7; // max repeat count
         int min_count = 4; // min repeat count
@@ -445,7 +445,7 @@ private void send_tree(short[] tree, // the tree to be sent
         int n; // iterates over all tree elements
         int prevlen = -1; // last emitted length
         int curlen; // length of current code
-        int nextlen = tree[0 * 2 + 1]; // length of next code
+        int nextlen = tree[1]; // length of next code
         int count = 0; // repeat count of the current code
         int max_count = 7; // max repeat count
         int min_count = 4; // min repeat count
@@ -797,6 +797,7 @@ private void _tr_stored_block(int buf, // input block
             int stored_len, // length of input block
             boolean eof // true if this is the last block for a file
     ) {
+        //noinspection PointlessArithmeticExpression
         send_bits((STORED_BLOCK << 1) + (eof? 1 : 0), 3); // send block type
         copy_block(buf, stored_len, true); // with header
     }

File: common/src/main/java/io/netty/util/internal/jzlib/Tree.java
Patch:
@@ -213,7 +213,7 @@ private void gen_bitlen(Deflate s) {
                     continue;
                 }
                 if (tree[m * 2 + 1] != bits) {
-                    s.opt_len += ((long) bits - (long) tree[m * 2 + 1]) *
+                    s.opt_len += ((long) bits - tree[m * 2 + 1]) *
                             tree[m * 2];
                     tree[m * 2 + 1] = (short) bits;
                 }

File: example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
Patch:
@@ -192,7 +192,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
             responseContent.append('o');
             // example of reading chunk by chunk (minimize memory usage due to
             // Factory)
-            readHttpDataChunkByChunk(ctx.channel());
+            readHttpDataChunkByChunk();
             // example of reading only if at the end
             if (chunk.isLast()) {
                 readHttpDataAllReceive(ctx.channel());
@@ -206,7 +206,7 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
      * Example of reading all InterfaceHttpData from finished transfer
      */
     private void readHttpDataAllReceive(Channel channel) {
-        List<InterfaceHttpData> datas = null;
+        List<InterfaceHttpData> datas;
         try {
             datas = decoder.getBodyHttpDatas();
         } catch (NotEnoughDataDecoderException e1) {
@@ -226,7 +226,7 @@ private void readHttpDataAllReceive(Channel channel) {
     /**
      * Example of reading request by chunk and getting values from chunk to chunk
      */
-    private void readHttpDataChunkByChunk(Channel channel) {
+    private void readHttpDataChunkByChunk() {
         try {
             while (decoder.hasNext()) {
                 InterfaceHttpData data = decoder.next();

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
Patch:
@@ -254,7 +254,7 @@ final class SpdyCodecUtil {
         try {
             SPDY2_DICT_ = SPDY2_DICT_S.getBytes(CharsetUtil.US_ASCII);
             // dictionary is null terminated
-            SPDY2_DICT_[SPDY2_DICT_.length - 1] = (byte) 0;
+            SPDY2_DICT_[SPDY2_DICT_.length - 1] = 0;
         } catch (Exception e) {
             SPDY2_DICT_ = new byte[1];
         }
@@ -307,9 +307,9 @@ static int getSignedInt(ByteBuf buf, int offset) {
     /**
      * Returns {@code true} if ID is for a server initiated stream or ping.
      */
-    static boolean isServerId(int ID) {
+    static boolean isServerId(int id) {
         // Server initiated streams and pings have even IDs
-        return ID % 2 == 0;
+        return id % 2 == 0;
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
Patch:
@@ -38,6 +38,7 @@ public class SpdySessionHandler
     private static final SpdyProtocolException STREAM_CLOSED = new SpdyProtocolException("Stream closed");
 
     static {
+        @SuppressWarnings("ZeroLengthArrayAllocation")
         StackTraceElement[] emptyTrace = new StackTraceElement[0];
         PROTOCOL_EXCEPTION.setStackTrace(emptyTrace);
         STREAM_CLOSED.setStackTrace(emptyTrace);
@@ -695,8 +696,8 @@ private void issueStreamError(
      * Helper functions
      */
 
-    private boolean isRemoteInitiatedID(int ID) {
-        boolean serverID = SpdyCodecUtil.isServerId(ID);
+    private boolean isRemoteInitiatedID(int id) {
+        boolean serverID = SpdyCodecUtil.isServerId(id);
         return server && !serverID || !server && serverID;
     }
 

File: common/src/main/java/io/netty/util/internal/jzlib/Deflate.java
Patch:
@@ -49,6 +49,7 @@ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 
 import io.netty.util.internal.jzlib.JZlib.WrapperType;
 
+@SuppressWarnings("MethodParameterNamingConvention")
 final class Deflate {
 
     private static final class Config {

File: common/src/main/java/io/netty/util/internal/jzlib/InfCodes.java
Patch:
@@ -47,6 +47,7 @@ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  */
 package io.netty.util.internal.jzlib;
 
+@SuppressWarnings("MethodParameterNamingConvention")
 final class InfCodes {
 
     private static final int[] inflate_mask = { 0x00000000, 0x00000001,

File: common/src/main/java/io/netty/util/internal/jzlib/StaticTree.java
Patch:
@@ -47,6 +47,7 @@ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  */
 package io.netty.util.internal.jzlib;
 
+@SuppressWarnings("MethodParameterNamingConvention")
 final class StaticTree {
     static final short[] static_ltree = { 12, 8, 140, 8, 76, 8, 204, 8, 44, 8,
             172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188,

File: common/src/main/java/io/netty/util/internal/jzlib/Tree.java
Patch:
@@ -47,6 +47,7 @@ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  */
 package io.netty.util.internal.jzlib;
 
+@SuppressWarnings("MethodParameterNamingConvention")
 final class Tree {
     // extra bits for each length code
     static final int[] extra_lbits = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2,

File: example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
Patch:
@@ -83,10 +83,10 @@ private void generateTraffic() {
 
         // Flush the outbound buffer to the socket.
         // Once flushed, generate the same amount of traffic again.
-        ctx.flush().addListener(GENERATE_TRAFFIC);
+        ctx.flush().addListener(trafficGenerator);
     }
 
-    private final ChannelFutureListener GENERATE_TRAFFIC = new ChannelFutureListener() {
+    private final ChannelFutureListener trafficGenerator = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {

File: example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
Patch:
@@ -112,11 +112,11 @@ private void sendNumbers() {
 
         ChannelFuture f = ctx.flush();
         if (!finished) {
-            f.addListener(SEND_NUMBERS);
+            f.addListener(numberSender);
         }
     }
 
-    private final ChannelFutureListener SEND_NUMBERS = new ChannelFutureListener() {
+    private final ChannelFutureListener numberSender = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {

File: buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java
Patch:
@@ -1421,9 +1421,9 @@ public void testDuplicate() {
 
         // Make sure the buffer content is shared.
         buffer.setByte(readerIndex, (byte) (buffer.getByte(readerIndex) + 1));
-        assertTrue(buffer.getByte(readerIndex) == duplicate.getByte(readerIndex));
+        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(readerIndex));
         duplicate.setByte(1, (byte) (duplicate.getByte(1) + 1));
-        assertTrue(buffer.getByte(1) == duplicate.getByte(1));
+        assertEquals(buffer.getByte(1), duplicate.getByte(1));
     }
 
     @Test

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
Patch:
@@ -18,8 +18,7 @@
 import java.text.ParseException;
 import java.util.Date;
 
-import junit.framework.Assert;
-
+import org.junit.Assert;
 import org.junit.Test;
 
 public class HttpHeaderDateFormatTest {

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.embedded.EmbeddedByteChannel;
-import junit.framework.Assert;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.Marshalling;
 import org.jboss.marshalling.MarshallingConfiguration;

File: common/src/test/java/io/netty/util/UniqueNameTest.java
Patch:
@@ -66,7 +66,7 @@ public void testRegisteringName() {
         registerName("Abcedrian");
 
         assertTrue(names.get("Abcedrian"));
-        assertTrue(names.get("Hellyes") == null);
+        assertNull(names.get("Hellyes"));
     }
 
     @Test

File: buffer/src/main/java/io/netty/buffer/ByteBuf.java
Patch:
@@ -336,7 +336,7 @@ public interface ByteBuf extends ChannelBuf, Comparable<ByteBuf> {
      * buf.readerIndex(2);
      * </pre>
      *
-     * By contrast, {@link #setIndex(int, int)} guarantees that it never
+     * By contrast, this method guarantees that it never
      * throws an {@link IndexOutOfBoundsException} as long as the specified
      * indexes meet basic constraints, regardless what the current index
      * values of the buffer are:

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java
Patch:
@@ -80,7 +80,7 @@ public interface HttpMessage extends HttpObject {
     /**
      * Returns the protocol version of this {@link HttpMessage}
      *
-     * @returns The protocol version
+     * @return The protocol version
      */
     HttpVersion getProtocolVersion();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
Patch:
@@ -28,7 +28,6 @@ public interface Attribute extends HttpData {
 
     /**
      * Sets the value of this HttpData.
-     * @param value
      */
     void setValue(String value) throws IOException;
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
Patch:
@@ -30,7 +30,6 @@ public interface FileUpload extends HttpData {
 
     /**
      * Set the original filename
-     * @param filename
      */
     void setFilename(String filename);
 
@@ -48,7 +47,6 @@ public interface FileUpload extends HttpData {
 
     /**
      * Set the Content-Transfer-Encoding type from String as 7bit, 8bit or binary
-     * @param contentTransferEncoding
      */
     void setContentTransferEncoding(String contentTransferEncoding);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
Patch:
@@ -105,10 +105,8 @@ public interface HttpData extends InterfaceHttpData {
      * read. Once it arrives at the end, it returns an EMPTY_BUFFER and it
      * resets the current position to 0.
      *
-     * @param length
      * @return a ChannelBuffer for the content from the current position or an
      *         EMPTY_BUFFER if there is no more data to return
-     * @throws IOException
      */
     ByteBuf getChunk(int length) throws IOException;
 

File: codec/src/main/java/io/netty/handler/codec/CodecException.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * An {@link Exception} which is thrown by a codec.
  *
- * @apiviz.hidden
+ * @apiviz.exclude
  */
 public class CodecException extends RuntimeException {
 

File: codec/src/main/java/io/netty/handler/codec/CorruptedFrameException.java
Patch:
@@ -19,7 +19,7 @@
  * An {@link Exception} which is thrown when the received frame data could not be decoded by
  * an inbound handler.
  *
- * @apiviz.hidden
+ * @apiviz.exclude
  */
 public class CorruptedFrameException extends DecoderException {
 

File: codec/src/main/java/io/netty/handler/codec/DecoderException.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * An {@link Exception} which is thrown by an encoder.
  *
- * @apiviz.hidden
+ * @apiviz.exclude
  */
 public class DecoderException extends CodecException {
 

File: codec/src/main/java/io/netty/handler/codec/EncoderException.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * An {@link Exception} which is thrown by an encoder.
  *
- * @apiviz.hidden
+ * @apiviz.exclude
  */
 public class EncoderException extends CodecException {
 

File: codec/src/main/java/io/netty/handler/codec/TooLongFrameException.java
Patch:
@@ -18,7 +18,8 @@
 /**
  * An {@link Exception} which is thrown when the length of the frame
  * decoded by {@link DelimiterBasedFrameDecoder} is greater than the maximum.
- * @apiviz.hidden
+ *
+ * @apiviz.exclude
  */
 public class TooLongFrameException extends DecoderException {
 

File: common/src/main/java/io/netty/monitor/EventRateMonitor.java
Patch:
@@ -48,7 +48,6 @@ public void event() {
 
     /**
      * Record {@code count} event occurrences.
-     * @param count
      */
     void events(long count);
 }

File: common/src/main/java/io/netty/monitor/ValueDistributionMonitor.java
Patch:
@@ -49,7 +49,6 @@ public void reset() {
 
     /**
      * Record {@code value}.
-     * @param value
      */
     void update(long value);
 }

File: transport/src/main/java/io/netty/channel/ChannelException.java
Patch:
@@ -17,7 +17,8 @@
 
 /**
  * A {@link RuntimeException} which is thrown when an I/O operation fails.
- * @apiviz.hidden
+ *
+ * @apiviz.exclude
  */
 public class ChannelException extends RuntimeException {
 

File: transport/src/main/java/io/netty/channel/ChannelHandlerLifeCycleException.java
Patch:
@@ -19,7 +19,8 @@
  * A {@link RuntimeException} which is thrown when a
  * {@link LifeCycleAwareChannelHandler} throws an {@link Exception}
  * in its handler methods.
- * @apiviz.hidden
+ *
+ * @apiviz.exclude
  */
 public class ChannelHandlerLifeCycleException extends RuntimeException {
 

File: transport/src/main/java/io/netty/channel/ChannelPipelineException.java
Patch:
@@ -19,7 +19,8 @@
  * A {@link ChannelException} which is thrown when a {@link ChannelPipeline}
  * failed to process a {@link ChannelEvent} or when a {@link ChannelPipelineFactory}
  * failed to initialize a {@link ChannelPipeline}.
- * @apiviz.hidden
+ *
+ * @apiviz.exclude
  */
 public class ChannelPipelineException extends ChannelException {
 

File: buffer/src/main/java/io/netty/buffer/ChannelBuf.java
Patch:
@@ -22,7 +22,7 @@ public interface ChannelBuf {
     ChannelBufType type();
 
     /**
-     * Return <code>true</code> if the ChannelBuf is pooled.
+     * Return {@code true} if the ChannelBuf is pooled.
      *
      */
     boolean isPooled();

File: buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
Patch:
@@ -247,6 +247,9 @@ private void consolidateIfNeeded() {
             final int capacity = components.get(numComponents - 1).endOffset;
 
             ByteBuf consolidated = components.get(numComponents - 1).buf.unsafe().newBuffer(capacity);
+
+            // We're not using foreach to avoid creating an iterator.
+            // noinspection ForLoopReplaceableByForEach
             for (int i = 0; i < numComponents; i ++) {
                 ByteBuf b = components.get(i).buf;
                 consolidated.writeBytes(b);

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -295,7 +295,7 @@ public static String decodeComponent(final String s) {
      * {@code 0xC3 0xA9}) is encoded as {@code %C3%A9} or {@code %c3%a9}.
      * <p>
      * This is essentially equivalent to calling
-     *   <code>{@link URLDecoder#decode(String, String) URLDecoder.decode}(s, charset.name())</code>
+     *   {@link URLDecoder#decode(String, String) URLDecoder.decode(s, charset.name())}
      * except that it's over 2x faster and generates less garbage for the GC.
      * Actually this function doesn't allocate any memory if there's nothing
      * to decode, the argument itself is returned.

File: codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
Patch:
@@ -41,7 +41,7 @@ public class FixedLengthFrameDecoder extends ByteToMessageDecoder<Object> {
     private final boolean allocateFullBuffer;
 
     /**
-     * Calls {@link #FixedLengthFrameDecoder(int, boolean)} with <code>false</code>
+     * Calls {@link #FixedLengthFrameDecoder(int, boolean)} with {@code false}
      */
     public FixedLengthFrameDecoder(int frameLength) {
         this(frameLength, false);
@@ -53,7 +53,7 @@ public FixedLengthFrameDecoder(int frameLength) {
      * @param frameLength
      *        the length of the frame
      * @param allocateFullBuffer
-     *        <code>true</code> if the cumulative {@link ByteBuf} should use the
+     *        {@code true} if the cumulative {@link ByteBuf} should use the
      *        {@link #frameLength} as its initial size
      */
     public FixedLengthFrameDecoder(int frameLength, boolean allocateFullBuffer) {

File: common/src/main/java/io/netty/util/internal/DetectionUtil.java
Patch:
@@ -85,7 +85,7 @@ public final class DetectionUtil {
     }
 
     /**
-     * Return <code>true</code> if the JVM is running on Windows
+     * Return {@code true} if the JVM is running on Windows
      */
     public static boolean isWindows() {
         return IS_WINDOWS;

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java
Patch:
@@ -36,7 +36,7 @@
  * <p>06. Create a directory for test configuration and results: <tt>mkdir autobahn</tt> <tt>cd autobahn</tt>.
  *
  * <p>07. Create <tt>fuzzing_clinet_spec.json</tt> in the above directory
- * <code>
+ * {@code
  * {
  *    "options": {"failByDrop": false},
  *    "outdir": "./reports/servers",
@@ -51,7 +51,7 @@
  *    "exclude-cases": [],
  *    "exclude-agent-cases": {}
  * }
- * </code>
+ * }
  *
  * <p>08. Run the <tt>AutobahnServer</tt> located in this package. If you are in Eclipse IDE, right click on
  * <tt>AutobahnServer.java</tt> and select Run As > Java Application.

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/package-info.java
Patch:
@@ -20,11 +20,11 @@
  * <dl>
  *   <dt>Step 1. Generate Your Key
  *   <dd>
- *     <code>keytool -genkey -keystore mySrvKeystore -keyalg RSA</code>.
+ *     {@code keytool -genkey -keystore mySrvKeystore -keyalg RSA}.
  *     Make sure that you set the key password to be the same the key file password.
  *   <dt>Step 2. Specify your key store file and password as system properties
  *   <dd>
- *     <code>-Dkeystore.file.path=&lt;path to mySrvKeystore&gt; -Dkeystore.file.password=&lt;password&gt;</code>
+ *     {@code -Dkeystore.file.path=<path to mySrvKeystore> -Dkeystore.file.password=<password>}
  *   <dt>Step 3. Run WebSocketSslServer as a Java application
  *   <dd>
  *     Once started, you can test the web server against your browser by navigating to https://localhost:8081/

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -309,7 +309,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
      * Read the next {@link ChunkedInput} and transfer it the the outbound buffer.
      * @param ctx           the {@link ChannelHandlerContext} this handler is bound to
      * @param chunks        the {@link ChunkedInput} to read from
-     * @return read         <code>true</code> if something could be transfered to the outbound buffer
+     * @return read         {@code true} if something could be transfered to the outbound buffer
      * @throws Exception    if something goes wrong
      */
     @SuppressWarnings("unchecked")

File: testsuite/src/test/java/io/netty/testsuite/util/TestUtils.java
Patch:
@@ -77,7 +77,7 @@ public static int getFreePort() {
     }
 
     /**
-     * Return <code>true</code> if SCTP is supported by the running os.
+     * Return {@code true} if SCTP is supported by the running os.
      *
      */
     public static boolean isSctpSupported() {

File: transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
Patch:
@@ -124,7 +124,7 @@ public B localAddress(InetAddress host, int port) {
 
     /**
      * Allow to specify a {@link ChannelOption} which is used for the {@link Channel} instances once they got
-     * created. Use a value of <code>null</code> to remove a previous set {@link ChannelOption}.
+     * created. Use a value of {@code null} to remove a previous set {@link ChannelOption}.
      */
     @SuppressWarnings("unchecked")
     public <T> B option(ChannelOption<T> option, T value) {

File: transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -108,7 +108,7 @@ public ServerBootstrap channel(Class<? extends Channel> channelClass) {
 
     /**
      * Allow to specify a {@link ChannelOption} which is used for the {@link Channel} instances once they get created
-     * (after the acceptor accepted the {@link Channel}). Use a value of <code>null</code> to remove a previous set
+     * (after the acceptor accepted the {@link Channel}). Use a value of {@code null} to remove a previous set
      * {@link ChannelOption}.
      */
     public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value) {

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -205,13 +205,13 @@ interface Unsafe {
 
         /**
          * Return the {@link SocketAddress} to which is bound local or
-         * <code>null</code> if none.
+         * {@code null} if none.
          */
         SocketAddress localAddress();
 
         /**
          * Return the {@link SocketAddress} to which is bound remote or
-         * <code>null</code> if none is bound yet.
+         * {@code null} if none is bound yet.
          */
         SocketAddress remoteAddress();
 
@@ -230,7 +230,7 @@ interface Unsafe {
         /**
          * Connect the {@link Channel} of the given {@link ChannelFuture} with the given remote {@link SocketAddress}.
          * If a specific local {@link SocketAddress} should be used it need to be given as argument. Otherwise just
-         * pass <code>null</code> to it.
+         * pass {@code null} to it.
          *
          * The {@link ChannelFuture} will get notified once the connect operation was complete.
          */

File: transport/src/main/java/io/netty/channel/ChannelFutureFactory.java
Patch:
@@ -28,14 +28,14 @@ public interface ChannelFutureFactory {
 
     /**
      * Create a new {@link ChannelFuture} which is marked as successes already. So {@link ChannelFuture#isSuccess()}
-     * will return <code>true</code>. All {@link ChannelFutureListener} added to it will be notified directly. Also
+     * will return {@code true}. All {@link ChannelFutureListener} added to it will be notified directly. Also
      * every call of blocking methods will just return without blocking.
      */
     ChannelFuture newSucceededFuture();
 
     /**
      * Create a new {@link ChannelFuture} which is marked as fakued already. So {@link ChannelFuture#isSuccess()}
-     * will return <code>false</code>. All {@link ChannelFutureListener} added to it will be notified directly. Also
+     * will return {@code false}. All {@link ChannelFutureListener} added to it will be notified directly. Also
      * every call of blocking methods will just return without blocking.
      */
     ChannelFuture newFailedFuture(Throwable cause);

File: transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java
Patch:
@@ -88,10 +88,10 @@ public boolean isSupported(Object msg) throws Exception {
     /**
      * Will get notified once {@link #inboundBufferUpdated(ChannelHandlerContext)} was called.
      *
-     * If this method returns <code>false</code> no further processing of the {@link MessageBuf}
+     * If this method returns {@code false} no further processing of the {@link MessageBuf}
      * will be done until the next call of {@link #inboundBufferUpdated(ChannelHandlerContext)}.
      *
-     * This will return <code>true</code> by default, and may get overriden by sub-classes for
+     * This will return {@code true} by default, and may get overriden by sub-classes for
      * special handling.
      */
     public boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception {

File: transport/src/main/java/io/netty/channel/EventExecutor.java
Patch:
@@ -34,7 +34,7 @@ public interface EventExecutor extends EventExecutorGroup, ScheduledExecutorServ
 
     /**
      * Return the {@link EventExecutorGroup} which is the parent of this {@link EventExecutor},
-     * or <code>null</code> if it has no parent
+     * or {@code null} if it has no parent
 
      */
     EventExecutorGroup parent();
@@ -45,8 +45,8 @@ public interface EventExecutor extends EventExecutorGroup, ScheduledExecutorServ
     boolean inEventLoop();
 
     /**
-     * Return <code>true</code> if the given {@link Thread} is executed in the event loop,
-     * <code>false</code> otherwise.
+     * Return {@code true} if the given {@link Thread} is executed in the event loop,
+     * {@code false} otherwise.
      */
     boolean inEventLoop(Thread thread);
 }

File: transport/src/main/java/io/netty/channel/socket/SctpNotificationEvent.java
Patch:
@@ -36,7 +36,7 @@ public Notification notification() {
 
     /**
      * Return the attachment of this {@link SctpNotificationEvent}, or
-     * <code>null</code> if no attachment was provided
+     * {@code null} if no attachment was provided
      */
     public Object attachment() {
         return attachment;

File: testsuite/src/test/java/io/netty/testsuite/util/TestUtils.java
Patch:
@@ -87,7 +87,7 @@ public static boolean isSctpSupported() {
                 // Try to open a SCTP Channel, by using reflection to make it compile also on
                 // operation systems that not support SCTP like OSX and Windows
                 Class<?> sctpChannelClass = Class.forName("com.sun.nio.sctp.SctpChannel");
-                Channel channel = (Channel) sctpChannelClass.getMethod("open", null).invoke(null, null);
+                Channel channel = (Channel) sctpChannelClass.getMethod("open").invoke(null);
                 try {
                     channel.close();
                 } catch (IOException e) {

File: transport/src/main/java/com/sun/nio/sctp/SctpServerChannel.java
Patch:
@@ -22,12 +22,13 @@
 import java.nio.channels.spi.SelectorProvider;
 import java.util.Set;
 
+@SuppressWarnings("all")
 public abstract class SctpServerChannel extends AbstractSelectableChannel {
     static {
         UnsupportedOperatingSystemException.raise();
     }
 
-    public static SctpServerChannel open() {
+    public static SctpServerChannel open() throws IOException {
         return null;
     }
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -15,18 +15,18 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.AbstractBootstrap;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.socket.DatagramPacket;
+import org.junit.Test;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class DatagramUnicastTest extends AbstractDatagramTest {
 
@@ -35,7 +35,7 @@ public void testSimpleSend() throws Throwable {
         run();
     }
 
-    public void testSimpleSend(AbstractBootstrap sb, AbstractBootstrap cb) throws Throwable {
+    public void testSimpleSend(AbstractBootstrap<?> sb, AbstractBootstrap<?> cb) throws Throwable {
         final CountDownLatch latch = new CountDownLatch(1);
 
         sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java
Patch:
@@ -15,14 +15,14 @@
  */
 package io.netty.handler.codec.http.multipart;
 
+import io.netty.handler.codec.http.HttpRequest;
+
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
 
-import io.netty.handler.codec.http.HttpRequest;
-
 /**
  * Default factory giving Attribute and FileUpload according to constructor
  *
@@ -35,7 +35,7 @@ public class DefaultHttpDataFactory implements HttpDataFactory {
     /**
      * Proposed default MINSIZE as 16 KB.
      */
-    public static long MINSIZE = 0x4000;
+    public static final long MINSIZE = 0x4000;
 
     private final boolean useDisk;
 

File: transport/src/main/java/com/sun/nio/sctp/SctpStandardSocketOptions.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.net.SocketAddress;
 
+@SuppressWarnings("all")
 public class SctpStandardSocketOptions {
     static {
         UnsupportedOperatingSystemException.raise();

File: codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
Patch:
@@ -749,7 +749,7 @@ private HttpChunk encodeNextChunkMultipart(int sizeleft) throws ErrorDataEncoder
         }
         ByteBuf buffer;
         if (currentData instanceof InternalAttribute) {
-            String internal = ((InternalAttribute) currentData).toString();
+            String internal = currentData.toString();
             byte[] bytes;
             try {
                 bytes = internal.getBytes("ASCII");

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -537,7 +537,7 @@ private State readHeaders(ByteBuf buffer) throws TooLongFrameException {
         String line = readHeader(buffer);
         String name = null;
         String value = null;
-        if (line.isEmpty()) {
+        if (!line.isEmpty()) {
             message.clearHeaders();
             do {
                 char firstChar = line.charAt(0);

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
Patch:
@@ -20,12 +20,11 @@
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.util.CharsetUtil;
-
-import java.util.Random;
-
 import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.Random;
+
 public class HttpInvalidMessageTest {
 
     private final Random rnd = new Random();

File: common/src/main/java/io/netty/monitor/MonitorRegistries.java
Patch:
@@ -47,8 +47,8 @@ public static MonitorRegistries instance() {
         return Holder.INSTANCE;
     }
 
-    private static final class Holder {
-        private static final MonitorRegistries INSTANCE = new MonitorRegistries();
+    private interface Holder {
+        MonitorRegistries INSTANCE = new MonitorRegistries();
     }
 
     private static final ServiceLoader<MonitorRegistryFactory> FACTORIES = ServiceLoader

File: testsuite/src/test/java/io/netty/testsuite/util/TestUtils.java
Patch:
@@ -23,7 +23,7 @@
 import java.nio.channels.Channel;
 import java.util.*;
 
-public class TestUtils {
+public final class TestUtils {
 
     private static final int START_PORT = 32768;
     private static final int END_PORT = 65536;
@@ -109,4 +109,4 @@ public static boolean isSctpSupported() {
     }
 
     private TestUtils() { }
-}
\ No newline at end of file
+}

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -41,14 +41,14 @@ public SpdyHttpResponseStreamIdHandler() {
     @Override
     public Object encode(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof HttpMessage) {
-            boolean contains = ((HttpMessage)msg).containsHeader(SpdyHttpHeaders.Names.STREAM_ID);
+            boolean contains = ((HttpMessage) msg).containsHeader(SpdyHttpHeaders.Names.STREAM_ID);
             if (!contains) {
                 ids.add(NO_ID);
             } else {
                 ids.add(SpdyHttpHeaders.getStreamId((HttpMessage) msg));
             }
         } else if (msg instanceof SpdyRstStreamFrame) {
-            ids.remove(((SpdyRstStreamFrame)msg).getStreamId());
+            ids.remove(((SpdyRstStreamFrame) msg).getStreamId());
         }
 
         return msg;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
Patch:
@@ -41,14 +41,14 @@ public SpdyHttpResponseStreamIdHandler() {
     @Override
     public Object encode(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof HttpMessage) {
-            boolean contains = ((HttpMessage)msg).containsHeader(SpdyHttpHeaders.Names.STREAM_ID);
+            boolean contains = ((HttpMessage) msg).containsHeader(SpdyHttpHeaders.Names.STREAM_ID);
             if (!contains) {
                 ids.add(NO_ID);
             } else {
                 ids.add(SpdyHttpHeaders.getStreamId((HttpMessage) msg));
             }
         } else if (msg instanceof SpdyRstStreamFrame) {
-            ids.remove(((SpdyRstStreamFrame)msg).getStreamId());
+            ids.remove(((SpdyRstStreamFrame) msg).getStreamId());
         }
 
         return msg;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -32,11 +32,13 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Test;
 
 public class DatagramMulticastTest extends AbstractDatagramTest {
 
     @Test
+    @Ignore("Ignore because it does give different behavior on different OS, need to investigate!")
     public void testMulticast() throws Throwable {
         run();
     }

File: common/src/main/java/io/netty/monitor/MonitorRegistries.java
Patch:
@@ -90,13 +90,13 @@ public MonitorRegistry forProvider(final MonitorProvider provider) {
      * @return <em>The</em> uniquely determined {@link MonitorRegistry}
      *         implementation
      * @throws IllegalStateException If either none or more that one
-     *             {@link MonitorRegistryFactor} provider was found on the
+     *             {@link MonitorRegistries} provider was found on the
      *             classpath
      */
     public MonitorRegistry unique() {
         final Iterator<MonitorRegistry> registries = iterator();
         if (!registries.hasNext()) {
-            throw new IllegalStateException("Could not find any MonitorRegistryFactories on the classpath - "
+            throw new IllegalStateException("Could not find any MonitorRegistries the classpath - "
                     + "implementations need to be registered in META-INF/services/"
                     + MonitorRegistryFactory.class.getName());
         }

File: metrics-yammer/src/main/java/io/netty/monitor/yammer/YammerMonitorRegistry.java
Patch:
@@ -63,7 +63,7 @@ public YammerMonitorRegistry(final MetricsRegistry delegate) {
 
     /**
      * Create a new {@link ValueDistributionMonitor} that is backed by a
-     * {@code Yammer} {@link Histrogram}.
+     * {@code Yammer} {@link Histogram}.
      * @see io.netty.monitor.MonitorRegistry#newValueDistributionMonitor(io.netty.monitor.MonitorName)
      */
     @Override

File: common/src/main/java/io/netty/util/internal/DetectionUtil.java
Patch:
@@ -20,6 +20,7 @@
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -40,7 +41,7 @@ public final class DetectionUtil {
     private static final boolean IS_ROOT;
 
     static {
-        String os = SystemPropertyUtil.get("os.name").toLowerCase();
+        String os = SystemPropertyUtil.get("os.name", "").toLowerCase(Locale.UK);
         // windows
         IS_WINDOWS = os.contains("win");
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -46,7 +46,7 @@
  * @apiviz.landmark
  * @apiviz.has io.netty.handler.codec.http.HttpChunk oneway - - filters out
  */
-public class HttpChunkAggregator extends MessageToMessageDecoder<Object, HttpMessage> {
+public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject, HttpMessage> {
     public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024;
     private static final ByteBuf CONTINUE = Unpooled.copiedBuffer(
             "HTTP/1.1 100 Continue\r\n\r\n", CharsetUtil.US_ASCII);
@@ -66,7 +66,7 @@ public class HttpChunkAggregator extends MessageToMessageDecoder<Object, HttpMes
      *        a {@link TooLongFrameException} will be raised.
      */
     public HttpChunkAggregator(int maxContentLength) {
-        super(HttpMessage.class, HttpChunk.class);
+        super(HttpObject.class);
 
         if (maxContentLength <= 0) {
             throw new IllegalArgumentException(
@@ -109,7 +109,7 @@ public final void setMaxCumulationBufferComponents(int maxCumulationBufferCompon
     }
 
     @Override
-    public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
         HttpMessage currentMessage = this.currentMessage;
 
         if (msg instanceof HttpMessage) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -48,7 +48,7 @@ public abstract class HttpContentDecoder extends MessageToMessageDecoder<Object,
      * Creates a new instance.
      */
     protected HttpContentDecoder() {
-        super(HttpMessage.class, HttpChunk.class);
+        super(HttpObject.class);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -57,7 +57,7 @@ public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpMessa
     protected HttpContentEncoder() {
         super(
                 new Class<?>[] { HttpMessage.class },
-                new Class<?>[] { HttpMessage.class, HttpChunk.class });
+                new Class<?>[] { HttpObject.class });
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -50,7 +50,7 @@ public abstract class HttpMessageEncoder extends MessageToByteEncoder<Object> {
      * Creates a new instance.
      */
     protected HttpMessageEncoder() {
-        super(HttpMessage.class, HttpChunk.class);
+        super(HttpObject.class);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -22,6 +22,7 @@
 import io.netty.handler.codec.http.HttpChunkTrailer;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMessage;
+import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 
@@ -129,7 +130,7 @@ public class SpdyHttpEncoder extends MessageToMessageEncoder<Object, Object> {
      * @param version the protocol version
      */
     public SpdyHttpEncoder(int version) {
-        super(HttpMessage.class, HttpChunk.class);
+        super(HttpObject.class);
 
         if (version < SpdyConstants.SPDY_MIN_VERSION || version > SpdyConstants.SPDY_MAX_VERSION) {
             throw new IllegalArgumentException(

File: transport/src/main/java/io/netty/channel/socket/nio/SelectorUtil.java
Patch:
@@ -27,7 +27,7 @@
 final class SelectorUtil {
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SelectorUtil.class);
-    static final long DEFAULT_SELECT_TIMEOUT = 10;
+    static final long DEFAULT_SELECT_TIMEOUT = 500;
     static final long SELECT_TIMEOUT =
             SystemPropertyUtil.getLong("io.netty.selectTimeout", DEFAULT_SELECT_TIMEOUT);
     static final long SELECT_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(SELECT_TIMEOUT);

File: transport/src/main/java/com/sun/nio/sctp/SctpServerChannel.java
Patch:
@@ -30,13 +30,13 @@ public abstract class SctpServerChannel extends AbstractSelectableChannel {
     public static SctpServerChannel open() throws IOException {
         return null;
     }
-    
+
     protected SctpServerChannel(SelectorProvider provider) {
         super(provider);
     }
 
     public abstract <T> T getOption(SctpSocketOption<T> name) throws IOException;
-    public abstract <T> SctpChannel setOption(SctpSocketOption<T> name, T value) throws IOException;
+    public abstract <T> SctpServerChannel setOption(SctpSocketOption<T> name, T value) throws IOException;
 
     public abstract Set<SocketAddress> getAllLocalAddresses() throws IOException;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java
Patch:
@@ -32,9 +32,8 @@
 @Sharable
 public class WebSocket00FrameEncoder extends MessageToByteEncoder<WebSocketFrame> {
 
-    @Override
-    public boolean isEncodable(Object msg) throws Exception {
-        return msg instanceof WebSocketFrame;
+    public WebSocket00FrameEncoder() {
+        super(WebSocketFrame.class);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -52,6 +52,8 @@ public class SpdyHttpDecoder extends MessageToMessageDecoder<Object, HttpMessage
      *        a {@link TooLongFrameException} will be raised.
      */
     public SpdyHttpDecoder(int version, int maxContentLength) {
+        super(SpdyDataFrame.class, SpdyControlFrame.class);
+
         if (version < SpdyConstants.SPDY_MIN_VERSION || version > SpdyConstants.SPDY_MAX_VERSION) {
             throw new IllegalArgumentException(
                     "unsupported version: " + version);

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
Patch:
@@ -49,9 +49,8 @@
  */
 public class ByteArrayDecoder extends MessageToMessageDecoder<ByteBuf, byte[]> {
 
-    @Override
-    public boolean isDecodable(Object msg) throws Exception {
-        return msg instanceof ByteBuf;
+    public ByteArrayDecoder() {
+        super(ByteBuf.class);
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java
Patch:
@@ -59,9 +59,8 @@
 @Sharable
 public class ProtobufEncoder extends MessageToMessageEncoder<Object, ByteBuf> {
 
-    @Override
-    public boolean isEncodable(Object msg) throws Exception {
-        return msg instanceof MessageLite || msg instanceof MessageLite.Builder;
+    public ProtobufEncoder() {
+        super(MessageLite.class, MessageLite.Builder.class);
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectEncoder.java
Patch:
@@ -39,9 +39,8 @@
 public class ObjectEncoder extends MessageToByteEncoder<Object> {
     private static final byte[] LENGTH_PLACEHOLDER = new byte[4];
 
-    @Override
-    public boolean isEncodable(Object msg) throws Exception {
-        return msg instanceof Serializable;
+    public ObjectEncoder() {
+        super(Serializable.class);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -223,7 +223,7 @@ protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
             buf.drainTo(peerPipeline.inboundMessageBuffer());
             peerPipeline.fireInboundBufferUpdated();
         } else {
-            final Object msgs[] = buf.toArray();
+            final Object[] msgs = buf.toArray();
             buf.clear();
             peerLoop.execute(new Runnable() {
                 @Override

File: testsuite/src/test/java/io/netty/testsuite/util/TestUtils.java
Patch:
@@ -20,8 +20,8 @@
 
 public class TestUtils {
 
-    private final static int START_PORT = 20000;
-    private final static int END_PORT = 30000;
+    private static int START_PORT = 20000;
+    private static int END_PORT = 30000;
 
     /**
      * Return a free port which can be used to bind to
@@ -34,6 +34,7 @@ public static int getFreePort() {
                 ServerSocket socket = new ServerSocket(start);
                 socket.setReuseAddress(true);
                 socket.close();
+                START_PORT = start + 1;
                 return start;
             } catch (IOException e) {
                 // ignore

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
Patch:
@@ -43,7 +43,8 @@ public class WebSocketServerProtocolHandshakeHandler extends ChannelInboundMessa
     private final String subprotocols;
     private final boolean allowExtensions;
 
-    public WebSocketServerProtocolHandshakeHandler(String websocketPath, String subprotocols, boolean allowExtensions) {
+    public WebSocketServerProtocolHandshakeHandler(String websocketPath, String subprotocols,
+            boolean allowExtensions) {
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;

File: common/src/main/java/io/netty/util/internal/DetectionUtil.java
Patch:
@@ -154,8 +154,9 @@ private static int javaVersion0() {
             Class.forName(
                     "java.util.concurrent.LinkedTransferQueue", false,
                     BlockingQueue.class.getClassLoader());
-        } catch (Exception e) {
             return 7;
+        } catch (Exception e) {
+            // Ignore
         }
 
         return 6;

File: common/src/main/java/io/netty/util/UniqueName.java
Patch:
@@ -103,7 +103,7 @@ public int compareTo(UniqueName other) {
             return returnCode;
         }
 
-        return ((Integer) id).compareTo((Integer) other.id);
+        return ((Integer) id).compareTo(other.id);
     }
 
     @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
Patch:
@@ -57,7 +57,7 @@ public void testShutdownOutput(Bootstrap cb) throws Throwable {
             assertFalse(h.ch.isOutputShutdown());
 
             // Make the connection half-closed and ensure read() returns -1.
-            ch.shutdownOutput();
+            ch.shutdownOutput().sync();
             assertEquals(-1, s.getInputStream().read());
 
             assertTrue(h.ch.isOpen());

File: transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
Patch:
@@ -139,7 +139,7 @@ public interface SocketChannelConfig extends ChannelConfig {
     /**
      * Sets whether the channel should not close itself when its remote peer shuts down output to
      * make the connection half-closed.  If {@code true} the connection is not closed when the
-     * remote peer shuts down output.  Instead, {@link ChannelHandler#userEventTriggered(ChannelHandlerContext, Object)}
+     * remote peer shuts down output. Instead, {@link ChannelHandler#userEventTriggered(ChannelHandlerContext, Object)}
      * is invoked with a {@link ChannelInputShutdownEvent} object. If {@code false}, the connection
      * is closed automatically.
      */

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java
Patch:
@@ -41,13 +41,13 @@ public class AioEventLoopGroup extends MultithreadEventLoopGroup {
             if (DetectionUtil.hasUnsafe()) {
                 finder = new UnsafeAioChannelFinder();
             } else {
-                finder = new DefaultAioChannelFinder();
+                finder = new ReflectiveAioChannelFinder();
             }
         } catch (Throwable t) {
             LOGGER.debug(String.format(
                     "Failed to instantiate the optimal %s implementation - falling back to %s.",
-                    AioChannelFinder.class.getSimpleName(), DefaultAioChannelFinder.class.getSimpleName()), t);
-            finder = new DefaultAioChannelFinder();
+                    AioChannelFinder.class.getSimpleName(), ReflectiveAioChannelFinder.class.getSimpleName()), t);
+            finder = new ReflectiveAioChannelFinder();
         }
         CHANNEL_FINDER = finder;
     }

File: transport/src/main/java/io/netty/channel/socket/aio/ReflectiveAioChannelFinder.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-final class DefaultAioChannelFinder implements AioChannelFinder {
+final class ReflectiveAioChannelFinder implements AioChannelFinder {
     private static volatile Map<Class<?>, Field> fieldCache = new HashMap<Class<?>, Field>();
 
     @Override
@@ -39,7 +39,7 @@ public AbstractAioChannel findChannel(Runnable command) throws Exception {
     }
 
     private static Field findField(Object command) throws Exception {
-        Map<Class<?>, Field> fieldCache = DefaultAioChannelFinder.fieldCache;
+        Map<Class<?>, Field> fieldCache = ReflectiveAioChannelFinder.fieldCache;
         Class<?> commandType = command.getClass();
         Field res = fieldCache.get(commandType);
         if (res != null) {

File: transport/src/main/java/io/netty/channel/socket/aio/AioChannelFinder.java
Patch:
@@ -17,4 +17,4 @@
 
 interface AioChannelFinder {
     AbstractAioChannel findChannel(Runnable command) throws Exception;
-}
\ No newline at end of file
+}

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java
Patch:
@@ -45,7 +45,7 @@ public class AioEventLoopGroup extends MultithreadEventLoopGroup {
             }
         } catch (Throwable t) {
             LOGGER.debug(String.format(
-                    "Unable to instance the optimal %s implementation - falling back to %s.",
+                    "Failed to instantiate the optimal %s implementation - falling back to %s.",
                     AioChannelFinder.class.getSimpleName(), DefaultAioChannelFinder.class.getSimpleName()), t);
             finder = new DefaultAioChannelFinder();
         }

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -157,7 +157,7 @@ public interface ChannelHandlerContext
      * The {@link ChannelHandler} that is bound this {@link ChannelHandlerContext}.
      */
     ChannelHandler handler();
-    Set<ChannelHandlerType> type();
+    Set<ChannelHandlerType> types();
 
     /**
      * Return <code>true</code> if the {@link ChannelHandlerContext} has an {@link ByteBuf} bound for inbound

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -349,7 +349,7 @@ public String name() {
     }
 
     @Override
-    public Set<ChannelHandlerType> type() {
+    public Set<ChannelHandlerType> types() {
         return type;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -94,7 +94,7 @@ public static Set<Cookie> decode(String header) {
             String commentURL = null;
             String domain = null;
             String path = null;
-            long maxAge = Integer.MIN_VALUE;
+            long maxAge = Long.MIN_VALUE;
             List<Integer> ports = new ArrayList<Integer>(2);
 
             for (int j = i + 1; j < names.size(); j++, i++) {

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -94,7 +94,7 @@ public static Set<Cookie> decode(String header) {
             String commentURL = null;
             String domain = null;
             String path = null;
-            long maxAge = -1;
+            long maxAge = Integer.MIN_VALUE;
             List<Integer> ports = new ArrayList<Integer>(2);
 
             for (int j = i + 1; j < names.size(); j++, i++) {

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -204,7 +204,7 @@ public void testStagedExecution() throws Throwable {
         }
     }
 
-    @Test(timeout = 120000)
+    @Test(timeout = 30000)
     public void testConcurrentMessageBufferAccess() throws Throwable {
         EventLoopGroup l = new LocalEventLoopGroup(4, new PrefixThreadFactory("l"));
         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new PrefixThreadFactory("e1"));

File: transport/src/main/java/io/netty/channel/DefaultEventExecutor.java
Patch:
@@ -19,8 +19,9 @@
 
 class DefaultEventExecutor extends SingleThreadEventExecutor {
 
-    DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {
-        super(parent, threadFactory);
+    DefaultEventExecutor(
+            DefaultEventExecutorGroup parent, ThreadFactory threadFactory, TaskScheduler scheduler) {
+        super(parent, threadFactory, scheduler);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DefaultEventExecutorGroup.java
Patch:
@@ -28,7 +28,8 @@ public DefaultEventExecutorGroup(int nThreads, ThreadFactory threadFactory) {
     }
 
     @Override
-    protected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception {
-        return new DefaultEventExecutor(this, threadFactory);
+    protected EventExecutor newChild(
+            ThreadFactory threadFactory, TaskScheduler scheduler, Object... args) throws Exception {
+        return new DefaultEventExecutor(this, threadFactory, scheduler);
     }
 }

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -19,8 +19,9 @@
 
 public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
 
-    protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory) {
-        super(parent, threadFactory);
+    protected SingleThreadEventLoop(
+            EventLoopGroup parent, ThreadFactory threadFactory, TaskScheduler scheduler) {
+        super(parent, threadFactory, scheduler);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java
Patch:
@@ -68,7 +68,7 @@ public boolean isOpen() {
 
     @Override
     protected Runnable doRegister() throws Exception {
-        if (((AioChildEventLoop) eventLoop()).parent() != group) {
+        if (((AioEventLoop) eventLoop()).parent() != group) {
             throw new ChannelException(
                     getClass().getSimpleName() + " must be registered to the " +
                     AioEventLoopGroup.class.getSimpleName() + " which was specified in the constructor.");
@@ -83,7 +83,7 @@ protected void doDeregister() throws Exception {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof AioChildEventLoop;
+        return loop instanceof AioEventLoop;
     }
 
     protected abstract class AbstractAioUnsafe extends AbstractUnsafe {

File: transport/src/main/java/io/netty/channel/socket/oio/OioEventLoop.java
Patch:
@@ -27,7 +27,7 @@ class OioEventLoop extends SingleThreadEventLoop {
     private AbstractOioChannel ch;
 
     OioEventLoop(OioEventLoopGroup parent) {
-        super(parent, parent.threadFactory);
+        super(parent, parent.threadFactory, parent.scheduler);
         this.parent = parent;
     }
 

File: transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
Patch:
@@ -256,7 +256,8 @@ private static class SingleThreadEventLoopImpl extends SingleThreadEventLoop {
         final AtomicInteger cleanedUp = new AtomicInteger();
 
         SingleThreadEventLoopImpl() {
-            super(null, Executors.defaultThreadFactory());
+            super(null, Executors.defaultThreadFactory(),
+                  new TaskScheduler(Executors.defaultThreadFactory()));
         }
 
         @Override

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
Patch:
@@ -57,7 +57,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, List<Integer> msg) throws Exception {
-        // Echo back the received object to the client.
+        // Echo back the received object to the server.
         ctx.write(msg);
     }
 

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
Patch:
@@ -57,7 +57,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, List<Integer> msg) throws Exception {
-        // Echo back the received object to the client.
+        // Echo back the received object to the server.
         ctx.write(msg);
     }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -64,7 +64,7 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
     final AtomicReference<ByteBridge> inByteBridge;
     final AtomicReference<ByteBridge> outByteBridge;
 
-    final AtomicBoolean suspendRead = new AtomicBoolean();
+    final AtomicBoolean readable = new AtomicBoolean(true);
 
     // Runnables that calls handlers
     final Runnable fireChannelRegisteredTask = new Runnable() {
@@ -800,7 +800,7 @@ void flush(ByteBuf out) {
 
     @Override
     public boolean isReadable() {
-        return !suspendRead.get();
+        return readable.get();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1450,7 +1450,7 @@ private DefaultChannelHandlerContext getContextOrDie(Class<? extends ChannelHand
     }
 
     void readable(DefaultChannelHandlerContext ctx, boolean readable) {
-        if (ctx.suspendRead.compareAndSet(!readable, readable)) {
+        if (ctx.readable.compareAndSet(!readable, readable)) {
             if (!readable) {
                 if (suspendRead.incrementAndGet() == 1) {
                     unsafe.suspendRead();

File: codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
Patch:
@@ -87,7 +87,7 @@ public interface Cookie extends Comparable<Cookie> {
     void setComment(String comment);
 
     /**
-     * Returns the maximum age of this {@link Cookie} in seconds.
+     * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified
      *
      * @return The maximum age of this {@link Cookie}
      */
@@ -97,7 +97,7 @@ public interface Cookie extends Comparable<Cookie> {
      * Sets the maximum age of this {@link Cookie} in seconds.
      * If an age of {@code 0} is specified, this {@link Cookie} will be
      * automatically removed by browser because it will expire immediately.
-     * If {@code -1} is specified, this {@link Cookie} will be removed when the
+     * If {@link Long#MIN_VALUE} is specified, this {@link Cookie} will be removed when the
      * browser is closed.
      *
      * @param maxAge The maximum age of this {@link Cookie} in seconds

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java
Patch:
@@ -35,7 +35,7 @@ public class DefaultCookie implements Cookie {
     private boolean discard;
     private Set<Integer> ports = Collections.emptySet();
     private Set<Integer> unmodifiablePorts = ports;
-    private long maxAge = -1;
+    private long maxAge = Long.MIN_VALUE;
     private int version;
     private boolean secure;
     private boolean httpOnly;

File: codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
Patch:
@@ -54,7 +54,7 @@ public static String encode(Cookie cookie) {
 
         add(buf, cookie.getName(), cookie.getValue());
 
-        if (cookie.getMaxAge() >= 0) {
+        if (cookie.getMaxAge() != Long.MIN_VALUE) {
             if (cookie.getVersion() == 0) {
                 addUnquoted(buf, CookieHeaderNames.EXPIRES,
                         new HttpHeaderDateFormat().format(

File: handler/src/main/java/io/netty/handler/logging/LogLevel.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.logging.InternalLogLevel;
 
 public enum LogLevel {
+    TRACE(InternalLogLevel.TRACE),
     DEBUG(InternalLogLevel.DEBUG),
     INFO(InternalLogLevel.INFO),
     WARN(InternalLogLevel.WARN),

File: transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import io.netty.util.internal.QueueFactory;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -32,6 +31,7 @@
 import java.util.concurrent.DelayQueue;
 import java.util.concurrent.Delayed;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.Semaphore;
@@ -71,7 +71,7 @@ public EventExecutor nextChild() {
         }
     };
 
-    private final BlockingQueue<Runnable> taskQueue = QueueFactory.createQueue();
+    private final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();
     private final Thread thread;
     private final Object stateLock = new Object();
     private final Semaphore threadLock = new Semaphore(0);

File: transport/src/main/java/io/netty/channel/socket/oio/OioEventLoop.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.channel.EventExecutor;
 import io.netty.channel.EventLoop;
 import io.netty.channel.SingleThreadEventExecutor;
-import io.netty.util.internal.QueueFactory;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -31,6 +30,7 @@
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
@@ -45,7 +45,7 @@ public class OioEventLoop implements EventLoop {
     final ThreadFactory threadFactory;
     final Set<OioChildEventLoop> activeChildren = Collections.newSetFromMap(
             new ConcurrentHashMap<OioChildEventLoop, Boolean>());
-    final Queue<OioChildEventLoop> idleChildren = QueueFactory.createQueue();
+    final Queue<OioChildEventLoop> idleChildren = new ConcurrentLinkedQueue<OioChildEventLoop>();
     private final ChannelException tooManyChannels;
     private final Unsafe unsafe = new Unsafe() {
         @Override

File: transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
Patch:
@@ -32,11 +32,11 @@
 import io.netty.channel.DefaultEventExecutor;
 import io.netty.channel.EventExecutor;
 import io.netty.channel.EventLoop;
-import io.netty.util.internal.QueueFactory;
 
 import java.util.HashSet;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
@@ -337,8 +337,8 @@ private static class ThreadNameAuditor
 
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
-        private final Queue<String> inboundThreadNames = QueueFactory.createQueue();
-        private final Queue<String> outboundThreadNames = QueueFactory.createQueue();
+        private final Queue<String> inboundThreadNames = new ConcurrentLinkedQueue<String>();
+        private final Queue<String> outboundThreadNames = new ConcurrentLinkedQueue<String>();
 
         @Override
         public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -240,7 +240,7 @@ public void run() {
             }
 
             if (buf == null) {
-                throw new ChannelPipelineException("A user handler's newInboundBuffer() returned null");
+                throw new ChannelPipelineException("A user handler's newOutboundBuffer() returned null");
             }
 
             if (buf instanceof ByteBuf) {

File: buffer/src/main/java/io/netty/buffer/DirectByteBuf.java
Patch:
@@ -173,6 +173,8 @@ public void capacity(int newCapacity) {
                 newBuffer.position(readerIndex).limit(writerIndex);
                 newBuffer.put(oldBuffer);
                 newBuffer.clear();
+            } else {
+                setIndex(newCapacity, newCapacity);
             }
             setByteBuffer(newBuffer);
         }

File: buffer/src/main/java/io/netty/buffer/HeapByteBuf.java
Patch:
@@ -103,6 +103,8 @@ public void capacity(int newCapacity) {
                     writerIndex(writerIndex = newCapacity);
                 }
                 System.arraycopy(array, readerIndex, newArray, readerIndex, writerIndex - readerIndex);
+            } else {
+                setIndex(newCapacity, newCapacity);
             }
             setArray(newArray);
         }

File: buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
Patch:
@@ -39,6 +39,8 @@ public abstract class AbstractByteBuf implements ByteBuf {
     private int markedReaderIndex;
     private int markedWriterIndex;
 
+    int refCnt = 1;
+
     protected AbstractByteBuf(ByteOrder endianness, int maxCapacity) {
         if (endianness == null) {
             throw new NullPointerException("endianness");

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.List;
 
-public interface CompositeByteBuf extends ByteBuf {
+public interface CompositeByteBuf extends ByteBuf, Iterable<ByteBuf> {
 
     void addComponent(ByteBuf buffer);
     void addComponent(int cIndex, ByteBuf buffer);

File: buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java
Patch:
@@ -52,7 +52,9 @@ protected ByteBuf newBuffer(int length) {
             buffers.add(Unpooled.EMPTY_BUFFER);
         }
 
-        buffer = Unpooled.wrappedBuffer(buffers.toArray(new ByteBuf[buffers.size()])).order(order);
+        buffer = Unpooled.wrappedBuffer(
+                Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);
+
         assertEquals(length, buffer.capacity());
         assertEquals(length, buffer.readableBytes());
         assertFalse(buffer.writable());

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -18,7 +18,6 @@
 import static io.netty.handler.codec.http.HttpHeaders.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
-import io.netty.buffer.DefaultCompositeByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
@@ -138,7 +137,7 @@ public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exceptio
                     m.removeHeader(HttpHeaders.Names.TRANSFER_ENCODING);
                 }
                 m.setChunked(false);
-                m.setContent(new DefaultCompositeByteBuf(maxCumulationBufferComponents));
+                m.setContent(Unpooled.compositeBuffer(maxCumulationBufferComponents));
                 this.currentMessage = m;
                 return null;
             } else {

File: codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
Patch:
@@ -35,7 +35,7 @@ public void testGetTargetContentEncoding() throws Exception {
             "gzip; q=0.5, identity", "gzip",
             "gzip ; q=0.1", "gzip",
             "gzip; q=0, deflate", "deflate",
-            " defalte ; q=0 , *;q=0.5", "gzip",
+            " deflate ; q=0 , *;q=0.5", "gzip",
         };
         for (int i = 0; i < tests.length; i += 2) {
             String acceptEncoding = tests[i];

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -166,7 +166,7 @@ public void encode(ChannelHandlerContext ctx,
         if (maskPayload) {
             int random = (int) (Math.random() * Integer.MAX_VALUE);
             mask = ByteBuffer.allocate(4).putInt(random).array();
-            header.writeBytes(mask);
+            out.writeBytes(mask);
 
             int counter = 0;
             for (int i = data.readerIndex(); i < data.writerIndex(); i ++) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -166,7 +166,7 @@ public void encode(ChannelHandlerContext ctx,
         if (maskPayload) {
             int random = (int) (Math.random() * Integer.MAX_VALUE);
             mask = ByteBuffer.allocate(4).putInt(random).array();
-            header.writeBytes(mask);
+            out.writeBytes(mask);
 
             int counter = 0;
             for (int i = data.readerIndex(); i < data.writerIndex(); i ++) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -166,7 +166,7 @@ public void encode(ChannelHandlerContext ctx,
         if (maskPayload) {
             int random = (int) (Math.random() * Integer.MAX_VALUE);
             mask = ByteBuffer.allocate(4).putInt(random).array();
-            out.writeInt((int) (Math.random() * Integer.MAX_VALUE));
+            header.writeBytes(mask);
 
             int counter = 0;
             for (int i = data.readerIndex(); i < data.writerIndex(); i ++) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -166,7 +166,7 @@ public void encode(ChannelHandlerContext ctx,
         if (maskPayload) {
             int random = (int) (Math.random() * Integer.MAX_VALUE);
             mask = ByteBuffer.allocate(4).putInt(random).array();
-            out.writeInt((int) (Math.random() * Integer.MAX_VALUE));
+            out.writeInt(random);
 
             int counter = 0;
             for (int i = data.readerIndex(); i < data.writerIndex(); i ++) {

File: transport/src/main/java/io/netty/channel/DefaultChildEventExecutor.java
Patch:
@@ -42,7 +42,7 @@ protected void run() {
 
     @Override
     protected void wakeup(boolean inEventLoop) {
-        if (!inEventLoop) {
+        if (!inEventLoop && isShutdown()) {
             interruptThread();
         }
     }

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -163,9 +163,9 @@ protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
 
         flushing = true;
         if (buf.readable()) {
-            buf.discardReadBytes();
             javaChannel().write(buf.nioBuffer(), this, WRITE_HANDLER);
         } else {
+            buf.discardReadBytes();
             notifyFlushFutures();
             flushing = false;
         }

File: transport/src/main/java/io/netty/channel/socket/aio/AioCompletionHandler.java
Patch:
@@ -37,7 +37,7 @@ abstract class AioCompletionHandler<V, A extends Channel> implements CompletionH
      */
     protected abstract void failed0(Throwable exc, A channel);
 
-    private static final int MAX_STACK_DEPTH = Integer.MAX_VALUE;
+    private static final int MAX_STACK_DEPTH = 4;
     private static final ThreadLocal<Integer> STACK_DEPTH = new ThreadLocal<Integer>() {
         @Override
         protected Integer initialValue() {

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -437,7 +437,7 @@ public final void register(EventLoop eventLoop, ChannelFuture future) {
 
                 future.setFailure(t);
                 pipeline.fireExceptionCaught(t);
-                closeFuture().setSuccess();
+                closeFuture.setClosed();
             }
         }
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoop.java
Patch:
@@ -99,6 +99,6 @@ private static AbstractAioChannel findChannel(Runnable command) throws Exception
 
     @Override
     protected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception {
-        return new AioChildEventLoop(threadFactory);
+        return new AioChildEventLoop(this, threadFactory);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
-import io.netty.util.VoidEnum;
 
 /**
  * Decodes {@link ByteBuf}s into {@link WebSocketFrame}s.
@@ -30,7 +29,7 @@
  * @apiviz.landmark
  * @apiviz.uses io.netty.handler.codec.http.websocket.WebSocketFrame
  */
-public class WebSocket00FrameDecoder extends ReplayingDecoder<WebSocketFrame, VoidEnum> {
+public class WebSocket00FrameDecoder extends ReplayingDecoder<WebSocketFrame, Void> {
 
     static final int DEFAULT_MAX_FRAME_SIZE = 16384;
 

File: codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
-import io.netty.util.VoidEnum;
 
 import java.io.ObjectStreamConstants;
 
@@ -32,7 +31,7 @@
  *
  * If you can you should use {@link MarshallingDecoder}.
  */
-public class CompatibleMarshallingDecoder extends ReplayingDecoder<Object, VoidEnum> {
+public class CompatibleMarshallingDecoder extends ReplayingDecoder<Object, Void> {
     protected final UnmarshallerProvider provider;
     protected final int maxObjectSize;
 

File: codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedByteChannel;
-import io.netty.util.VoidEnum;
 
 import org.junit.Test;
 
@@ -48,7 +47,7 @@ public void testLineProtocol() {
         assertNull(ch.readInbound());
     }
 
-    private static final class LineDecoder extends ReplayingDecoder<ByteBuf, VoidEnum> {
+    private static final class LineDecoder extends ReplayingDecoder<ByteBuf, Void> {
 
         LineDecoder() {
         }

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoop.java
Patch:
@@ -59,7 +59,7 @@ private void executeAioTask(Runnable command) {
         AbstractAioChannel ch = null;
         try {
             ch = findChannel(command);
-        } catch (Exception e) {
+        } catch (Throwable t) {
             // Ignore
         }
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioEventLoop.java
Patch:
@@ -73,7 +73,7 @@ private void executeAioTask(Runnable command) {
         if (l.isShutdown()) {
             command.run();
         } else {
-            ch.eventLoop().execute(command);
+            l.execute(command);
         }
     }
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -165,6 +165,7 @@ protected boolean isFlushPending() {
     @Override
     protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
         if (!buf.readable()) {
+            notifyFlushFutures();
             return;
         }
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioCompletionHandler.java
Patch:
@@ -37,7 +37,7 @@ abstract class AioCompletionHandler<V, A extends Channel> implements CompletionH
      */
     protected abstract void failed0(Throwable exc, A channel);
 
-    private static final int MAX_STACK_DEPTH = 4;
+    private static final int MAX_STACK_DEPTH = Integer.MAX_VALUE;
     private static final ThreadLocal<Integer> STACK_DEPTH = new ThreadLocal<Integer>() {
         @Override
         protected Integer initialValue() {

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -190,7 +190,7 @@ protected void completed0(Integer result, AioSocketChannel channel) {
 
             if (empty) {
                 // Reset reader/writerIndex to 0 if the buffer is empty.
-                buf.clear();
+                buf.discardReadBytes();
             }
 
             channel.notifyFlushFutures(writtenBytes);
@@ -274,7 +274,6 @@ protected void completed0(Integer result, AioSocketChannel channel) {
                     channel.unsafe().close(channel.unsafe().voidFuture());
                 } else {
                     // start the next read
-                    //channel.readTask.run();
                     channel.eventLoop().execute(channel.readTask);
                 }
             }

File: transport/src/main/java/io/netty/channel/MultithreadEventLoop.java
Patch:
@@ -19,7 +19,6 @@
 
 public abstract class MultithreadEventLoop extends MultithreadEventExecutor implements EventLoop {
 
-
     protected MultithreadEventLoop(int nThreads, ThreadFactory threadFactory,
             Object... args) {
         super(nThreads, threadFactory, args);

File: transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
Patch:
@@ -290,7 +290,7 @@ protected void cleanup() {
 
         @Override
         protected void wakeup(boolean inEventLoop) {
-            if (!inEventLoop) {
+            if (!inEventLoop && isShutdown()) {
                 interruptThread();
             }
         }

File: transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java
Patch:
@@ -43,7 +43,6 @@ protected AbstractAioChannel(Channel parent, Integer id) {
         super(parent, id);
     }
 
-
     @Override
     public InetSocketAddress localAddress() {
         if (ch == null) {
@@ -64,7 +63,6 @@ protected AsynchronousChannel javaChannel() {
         return ch;
     }
 
-
     @Override
     public boolean isOpen() {
         return ch == null || ch.isOpen();
@@ -162,6 +160,7 @@ protected final void connectSuccess() {
             }
         }
     }
+
     protected abstract void doConnect(SocketAddress remoteAddress,
             SocketAddress localAddress, ChannelFuture connectFuture);
 

File: transport/src/main/java/io/netty/channel/socket/aio/AioCompletionHandler.java
Patch:
@@ -43,7 +43,6 @@ public final void completed(final V result, final A channel) {
             completed0(result, channel);
         } else {
             channel.eventLoop().execute(new Runnable() {
-
                 @Override
                 public void run() {
                     completed0(result, channel);
@@ -58,7 +57,6 @@ public final void failed(final Throwable exc, final A channel) {
             failed0(exc, channel);
         } else {
             channel.eventLoop().execute(new Runnable() {
-
                 @Override
                 public void run() {
                     failed0(exc, channel);

File: transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.util.NetworkConstants;
 
 import java.net.ServerSocket;
 import java.net.SocketException;
@@ -31,7 +32,7 @@ public class DefaultServerSocketChannelConfig extends DefaultChannelConfig
                                               implements ServerSocketChannelConfig {
 
     private final ServerSocket socket;
-    private volatile int backlog;
+    private volatile int backlog = NetworkConstants.SOMAXCONN;
 
     /**
      * Creates a new instance.

File: transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.socket.ServerSocketChannelConfig;
+import io.netty.util.NetworkConstants;
 
 import java.io.IOException;
 import java.net.StandardSocketOptions;
@@ -33,7 +34,7 @@ public class AioServerSocketChannelConfig extends DefaultChannelConfig
                                               implements ServerSocketChannelConfig {
 
     private final AsynchronousServerSocketChannel channel;
-    private volatile int backlog;
+    private volatile int backlog = NetworkConstants.SOMAXCONN;
 
     /**
      * Creates a new instance.

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -760,7 +760,7 @@ protected void notifyFlushFutures() {
         }
     }
 
-    private void notifyFlushFutures(Throwable cause) {
+    protected void notifyFlushFutures(Throwable cause) {
         notifyFlushFutures();
         for (;;) {
             FlushCheckpoint cp = flushCheckpoints.poll();

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannelConfig.java
Patch:
@@ -51,7 +51,6 @@ public Map<ChannelOption<?>, Object> getOptions() {
                 SO_RCVBUF, SO_SNDBUF, TCP_NODELAY, SO_KEEPALIVE, SO_REUSEADDR, SO_LINGER, IP_TOS);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public <T> T getOption(ChannelOption<T> option) {
         if (option == SO_RCVBUF) {
@@ -107,7 +106,7 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
     @Override
     public int getReceiveBufferSize() {
         try {
-            return (int) channel.getOption(StandardSocketOptions.SO_RCVBUF);
+            return channel.getOption(StandardSocketOptions.SO_RCVBUF);
         } catch (IOException e) {
             throw new ChannelException(e);
         }

File: transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java
Patch:
@@ -50,7 +50,6 @@ public Map<ChannelOption<?>, Object> getOptions() {
         return getOptions(super.getOptions(), SO_RCVBUF, SO_REUSEADDR, SO_BACKLOG);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public <T> T getOption(ChannelOption<T> option) {
         if (option == SO_RCVBUF) {

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -722,7 +722,7 @@ protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
 
     protected abstract boolean isFlushPending();
 
-    private void notifyFlushFutures() {
+    protected void notifyFlushFutures() {
         if (flushCheckpoints.isEmpty()) {
             return;
         }

File: transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
Patch:
@@ -172,11 +172,10 @@ protected boolean isFlushPending() {
     }
 
     @Override
-    protected boolean doFlushByteBuffer(ByteBuf buf) throws Exception {
+    protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
         if (!buf.readable()) {
             // Reset reader/writerIndex to 0 if the buffer is empty.
             buf.clear();
-            return true;
         }
 
         // Only one pending write can be scheduled at one time. Otherwise
@@ -187,7 +186,6 @@ protected boolean doFlushByteBuffer(ByteBuf buf) throws Exception {
             ByteBuffer buffer = buf.nioBuffer();
             javaChannel().write(buffer, this, WRITE_HANDLER);
         }
-        return false;
     }
 
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -272,7 +272,7 @@ public Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception
             assert chunkSize <= Integer.MAX_VALUE;
             int chunkSize = (int) this.chunkSize;
             int readLimit = actualReadableBytes();
-            
+
             // Check if the buffer is readable first as we use the readable byte count
             // to create the HttpChunk. This is needed as otherwise we may end up with
             // create a HttpChunk instance that contains an empty buffer and so is

File: codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
Patch:
@@ -109,6 +109,7 @@ private static void encode(StringBuilder buf, Cookie c) {
                 }
                 buf.setCharAt(buf.length() - 1, (char) HttpConstants.DOUBLE_QUOTE);
                 buf.append((char) HttpConstants.SEMICOLON);
+                buf.append((char) HttpConstants.SP);
             }
         }
     }

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -585,7 +585,7 @@ private void copyTo(int index, int length, int componentId, ByteBuf dst) {
      * Instead, it only returns a portion of the composite buffer where the
      * index is located
      * </p>
-     * 
+     *
      *
      * @param index The {@code index} to search for and include in the returned {@link ByteBuf}
      * @return The {@link ByteBuf} that contains the specified {@code index}

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -592,7 +592,7 @@ private void copyTo(int index, int length, int componentId, ByteBuf dst) {
      * less than zero, or larger than {@code capacity()}
      */
     public ByteBuf getBufferFor(int index) throws IndexOutOfBoundsException {
-        if (index < 0 || index > capacity()) {
+        if (index < 0 || index >= capacity()) {
             throw new IndexOutOfBoundsException("Invalid index: " + index
                     + " - Bytes needed: " + index + ", maximum is "
                     + capacity());

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
Patch:
@@ -165,6 +165,6 @@ public static String getScheme(HttpMessage message) {
      * Sets the {@code "X-SPDY-Scheme"} header.
      */
     public static void setScheme(HttpMessage message, String scheme) {
-        message.setHeader(Names.URL, scheme);
+        message.setHeader(Names.SCHEME, scheme);
     }
 }

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -575,7 +575,7 @@ private void copyTo(int index, int length, int componentId, ByteBuf dst) {
         dst.writerIndex(dst.capacity());
     }
     
-    public ByteBuf getBufferFor(int index) throws IOException {
+    public ByteBuf getBufferFor(int index) throws IndexOutOfBoundsException {
         if (index < 0 || index > capacity()) {
             throw new IndexOutOfBoundsException("Invalid index: " + index
                     + " - Bytes needed: " + (index) + ", maximum is "

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
Patch:
@@ -22,7 +22,6 @@
  * Decompresses a {@link ByteBuf} using the deflate algorithm.
  *
  * @apiviz.landmark
- * @apiviz.has io.netty.handler.codec.compression.ZlibWrapper
  */
 public abstract class ZlibDecoder extends ByteToByteDecoder {
 

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -20,10 +20,9 @@
 import io.netty.handler.codec.ByteToByteEncoder;
 
 /**
- * Decompresses a {@link ByteBuf} using the deflate algorithm.
+ * Compresses a {@link ByteBuf} using the deflate algorithm.
  *
  * @apiviz.landmark
- * @apiviz.has io.netty.handler.codec.compression.ZlibWrapper
  */
 public abstract class ZlibEncoder extends ByteToByteEncoder {
 

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.ServerSocketChannel;
@@ -139,7 +138,7 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
     boolean isRegistered();
     boolean isActive();
 
-    ChannelBufType bufferType();
+    ChannelMetadata metadata();
 
     ByteBuf outboundByteBuffer();
     <T> MessageBuf<T> outboundMessageBuffer();

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -272,7 +272,7 @@ public Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception
             assert chunkSize <= Integer.MAX_VALUE;
             int chunkSize = (int) this.chunkSize;
             int readLimit = actualReadableBytes();
-            
+
             // Check if the buffer is readable first as we use the readable byte count
             // to create the HttpChunk. This is needed as otherwise we may end up with
             // create a HttpChunk instance that contains an empty buffer and so is

File: codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
Patch:
@@ -109,6 +109,7 @@ private static void encode(StringBuilder buf, Cookie c) {
                 }
                 buf.setCharAt(buf.length() - 1, (char) HttpConstants.DOUBLE_QUOTE);
                 buf.append((char) HttpConstants.SEMICOLON);
+                buf.append((char) HttpConstants.SP);
             }
         }
     }

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -585,7 +585,7 @@ private void copyTo(int index, int length, int componentId, ByteBuf dst) {
      * Instead, it only returns a portion of the composite buffer where the
      * index is located
      * </p>
-     * 
+     *
      *
      * @param index The {@code index} to search for and include in the returned {@link ByteBuf}
      * @return The {@link ByteBuf} that contains the specified {@code index}

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -592,7 +592,7 @@ private void copyTo(int index, int length, int componentId, ByteBuf dst) {
      * less than zero, or larger than {@code capacity()}
      */
     public ByteBuf getBufferFor(int index) throws IndexOutOfBoundsException {
-        if (index < 0 || index > capacity()) {
+        if (index < 0 || index >= capacity()) {
             throw new IndexOutOfBoundsException("Invalid index: " + index
                     + " - Bytes needed: " + index + ", maximum is "
                     + capacity());

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
Patch:
@@ -165,6 +165,6 @@ public static String getScheme(HttpMessage message) {
      * Sets the {@code "X-SPDY-Scheme"} header.
      */
     public static void setScheme(HttpMessage message, String scheme) {
-        message.setHeader(Names.URL, scheme);
+        message.setHeader(Names.SCHEME, scheme);
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
Patch:
@@ -165,6 +165,6 @@ public static String getScheme(HttpMessage message) {
      * Sets the {@code "X-SPDY-Scheme"} header.
      */
     public static void setScheme(HttpMessage message, String scheme) {
-        message.setHeader(Names.URL, scheme);
+        message.setHeader(Names.SCHEME, scheme);
     }
 }

File: buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
Patch:
@@ -575,7 +575,7 @@ private void copyTo(int index, int length, int componentId, ByteBuf dst) {
         dst.writerIndex(dst.capacity());
     }
     
-    public ByteBuf getBufferFor(int index) throws IOException {
+    public ByteBuf getBufferFor(int index) throws IndexOutOfBoundsException {
         if (index < 0 || index > capacity()) {
             throw new IndexOutOfBoundsException("Invalid index: " + index
                     + " - Bytes needed: " + (index) + ", maximum is "

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
Patch:
@@ -22,7 +22,6 @@
  * Decompresses a {@link ByteBuf} using the deflate algorithm.
  *
  * @apiviz.landmark
- * @apiviz.has io.netty.handler.codec.compression.ZlibWrapper
  */
 public abstract class ZlibDecoder extends ByteToByteDecoder {
 

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -20,10 +20,9 @@
 import io.netty.handler.codec.ByteToByteEncoder;
 
 /**
- * Decompresses a {@link ByteBuf} using the deflate algorithm.
+ * Compresses a {@link ByteBuf} using the deflate algorithm.
  *
  * @apiviz.landmark
- * @apiviz.has io.netty.handler.codec.compression.ZlibWrapper
  */
 public abstract class ZlibEncoder extends ByteToByteEncoder {
 

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.ServerSocketChannel;
@@ -139,7 +138,7 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
     boolean isRegistered();
     boolean isActive();
 
-    ChannelBufType bufferType();
+    ChannelMetadata metadata();
 
     ByteBuf outboundByteBuffer();
     <T> MessageBuf<T> outboundMessageBuffer();

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
Patch:
@@ -17,14 +17,13 @@
 
 import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 
-import java.util.ArrayDeque;
-
 public class EmbeddedMessageChannel extends AbstractEmbeddedChannel {
 
     public EmbeddedMessageChannel(ChannelHandler... handlers) {
-        super(new ArrayDeque<Object>(), handlers);
+        super(Unpooled.messageBuffer(), handlers);
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -182,7 +182,7 @@ public void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Ex
             SpdySettingsFrame spdySettingsFrame = (SpdySettingsFrame) msg;
             byte flags = spdySettingsFrame.clearPreviouslyPersistedSettings() ?
                 SPDY_SETTINGS_CLEAR : 0;
-            Set<Integer> IDs = spdySettingsFrame.getIDs();
+            Set<Integer> IDs = spdySettingsFrame.getIds();
             int numEntries = IDs.size();
             int length = 4 + numEntries * 8;
             out.ensureWritableBytes(SPDY_HEADER_SIZE + length);
@@ -194,7 +194,7 @@ public void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Ex
             for (Integer ID: IDs) {
                 int id = ID.intValue();
                 byte ID_flags = (byte) 0;
-                if (spdySettingsFrame.persistValue(id)) {
+                if (spdySettingsFrame.isPersistValue(id)) {
                     ID_flags |= SPDY_SETTINGS_PERSIST_VALUE;
                 }
                 if (spdySettingsFrame.isPersisted(id)) {

File: buffer/src/main/java/io/netty/buffer/ChannelBuf.java
Patch:
@@ -16,5 +16,6 @@
 package io.netty.buffer;
 
 public interface ChannelBuf {
+    ChannelBufType type();
     boolean isPooled();
 }

File: buffer/src/main/java/io/netty/buffer/ChannelBufType.java
Patch:
@@ -13,9 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.channel;
+package io.netty.buffer;
 
-public enum ChannelBufferType {
+public enum ChannelBufType {
     BYTE,
     MESSAGE
 }

File: transport/src/main/java/io/netty/channel/AbstractServerChannel.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 
 import java.net.SocketAddress;
@@ -51,8 +52,8 @@ public MessageBuf<Object> outboundMessageBuffer() {
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.MESSAGE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.ServerSocketChannel;
@@ -138,7 +139,7 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
     boolean isRegistered();
     boolean isActive();
 
-    ChannelBufferType bufferType();
+    ChannelBufType bufferType();
 
     ByteBuf outboundByteBuffer();
     <T> MessageBuf<T> outboundMessageBuffer();

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -18,6 +18,7 @@
 import static io.netty.channel.DefaultChannelHandlerContext.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ChannelBuf;
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.DefaultChannelHandlerContext.ByteBridge;
@@ -886,7 +887,7 @@ public String toString() {
 
     @Override
     public MessageBuf<Object> inboundMessageBuffer() {
-        if (channel.bufferType() != ChannelBufferType.MESSAGE) {
+        if (channel.bufferType() != ChannelBufType.MESSAGE) {
             throw new NoSuchBufferException(
                     "The first inbound buffer of this channel must be a message buffer.");
         }
@@ -895,7 +896,7 @@ public MessageBuf<Object> inboundMessageBuffer() {
 
     @Override
     public ByteBuf inboundByteBuffer() {
-        if (channel.bufferType() != ChannelBufferType.BYTE) {
+        if (channel.bufferType() != ChannelBufType.BYTE) {
             throw new NoSuchBufferException(
                     "The first inbound buffer of this channel must be a byte buffer.");
         }

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.channel.embedded;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelHandler;
 
 public class EmbeddedByteChannel extends AbstractEmbeddedChannel {
@@ -27,8 +27,8 @@ public EmbeddedByteChannel(ChannelHandler... handlers) {
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.BYTE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.BYTE;
     }
 
     public ByteBuf inboundBuffer() {

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.embedded;
 
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelHandler;
 
 import java.util.ArrayDeque;
@@ -28,8 +28,8 @@ public EmbeddedMessageChannel(ChannelHandler... handlers) {
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.MESSAGE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.MESSAGE;
     }
 
     public MessageBuf<Object> inboundBuffer() {

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.channel.local;
 
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
@@ -68,8 +68,8 @@ public LocalChannel(Integer id) {
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.MESSAGE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ChannelBufType;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelPipeline;
 
 import java.io.IOException;
@@ -32,8 +32,8 @@ protected AbstractNioByteChannel(
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.BYTE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.BYTE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.channel.socket.nio;
 
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelPipeline;
 
 import java.io.IOException;
@@ -31,8 +31,8 @@ protected AbstractNioMessageChannel(
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.MESSAGE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.channel.socket.oio;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ChannelBufType;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelPipeline;
 
 import java.io.IOException;
@@ -29,8 +29,8 @@ protected AbstractOioByteChannel(Channel parent, Integer id) {
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.BYTE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.BYTE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.channel.socket.oio;
 
+import io.netty.buffer.ChannelBufType;
 import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBufferType;
 import io.netty.channel.ChannelPipeline;
 
 import java.io.IOException;
@@ -29,8 +29,8 @@ protected AbstractOioMessageChannel(Channel parent, Integer id) {
     }
 
     @Override
-    public ChannelBufferType bufferType() {
-        return ChannelBufferType.MESSAGE;
+    public ChannelBufType bufferType() {
+        return ChannelBufType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -498,8 +498,8 @@ public void run() {
         @Override
         public final void close(final ChannelFuture future) {
             if (eventLoop().inEventLoop()) {
+                boolean wasActive = isActive();
                 if (closeFuture.setClosed()) {
-                    boolean wasActive = isActive();
                     try {
                         doClose();
                         future.setSuccess();

File: codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
Patch:
@@ -46,8 +46,9 @@ public void flush(ChannelHandlerContext ctx, ChannelFuture future) throws Except
 
         if (out.readableBytes() > oldOutSize) {
             in.discardReadBytes();
-            ctx.flush(future);
         }
+
+        ctx.flush(future);
     }
 
     public abstract void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception;

File: handler/src/main/java/io/netty/handler/stream/ChunkedFile.java
Patch:
@@ -143,14 +143,13 @@ public boolean readChunk(ByteBuf buffer) throws Exception {
         }
 
         int chunkSize = (int) Math.min(this.chunkSize, endOffset - offset);
-        
         // Check if the buffer is backed by an byte array. If so we can optimize it a bit an safe a copy
-        
+
         byte[] chunk = new byte[chunkSize];
         file.readFully(chunk);
         buffer.writeBytes(chunk);
         this.offset = offset + chunkSize;
-        
+
         return true;
     }
 }

File: handler/src/main/java/io/netty/handler/stream/ChunkedInput.java
Patch:
@@ -32,8 +32,7 @@ public interface ChunkedInput<B> {
      * Releases the resources associated with the stream.
      */
     void close() throws Exception;
-    
-    
+
     /**
      * Fetches a chunked data from the stream.  The chunk is then
      * transfered to the given buffer.  Once this method returns the last chunk

File: handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java
Patch:
@@ -19,7 +19,6 @@
 
 /**
  * {@link ChunkedInput} which reads its chunks and transfer it to a {@link Queue}
- * 
  *
  */
 public interface ChunkedMessageInput extends ChunkedInput<Queue<Object>> {

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java
Patch:
@@ -164,7 +164,7 @@ public boolean readChunk(ByteBuf buffer) throws Exception {
         chunk.flip();
         buffer.writeBytes(chunk);
         this.offset += readBytes;
-        
+
         return true;
     }
 }

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java
Patch:
@@ -100,7 +100,6 @@ public boolean readChunk(ByteBuf buffer) throws Exception {
         if (isEndOfInput()) {
             return false;
         }
-        
         // buffer cannot be not be empty from there
         int readBytes = byteBuffer.position();
         for (;;) {
@@ -110,15 +109,14 @@ public boolean readChunk(ByteBuf buffer) throws Exception {
             }
             readBytes += localReadBytes;
             offset += localReadBytes;
-
             if (readBytes == chunkSize) {
                 break;
             }
         }
         byteBuffer.flip();
         buffer.writeBytes(byteBuffer);
         byteBuffer.clear();
-        
+
         return true;
     }
 }

File: handler/src/main/java/io/netty/handler/stream/ChunkedStream.java
Patch:
@@ -105,9 +105,9 @@ public boolean readChunk(ByteBuf buffer) throws Exception {
         } else {
             chunkSize = Math.min(this.chunkSize, in.available());
         }
-        
+
         // transfer to buffer
-        offset =+ buffer.writeBytes(in, chunkSize);
+        offset += buffer.writeBytes(in, chunkSize);
         return true;
     }
 }

File: transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
Patch:
@@ -15,7 +15,8 @@
  */
 package io.netty.channel;
 
+import io.netty.buffer.ChannelBuf;
 
-public interface ChannelInboundHandler<T> extends ChannelStateHandler {
-    ChannelBufferHolder<T> newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
+public interface ChannelInboundHandler extends ChannelStateHandler {
+    ChannelBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
Patch:
@@ -16,8 +16,8 @@
 package io.netty.channel;
 
 
-public abstract class ChannelInboundHandlerAdapter<I> extends ChannelStateHandlerAdapter
-        implements ChannelInboundHandler<I> {
+public abstract class ChannelInboundHandlerAdapter
+        extends ChannelStateHandlerAdapter implements ChannelInboundHandler {
     @Override
     public abstract void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.channel;
 
-public abstract class ChannelOutboundHandlerAdapter<O>
-        extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler<O> {
+public abstract class ChannelOutboundHandlerAdapter
+        extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler {
     @Override
     public abstract void flush(ChannelHandlerContext ctx, ChannelFuture future) throws Exception;
 }

File: buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java
Patch:
@@ -19,8 +19,8 @@
 
 
 /**
- * A big-endian Java heap buffer.  It is recommended to use {@link ChannelBuffers#buffer(int)}
- * and {@link ChannelBuffers#wrappedBuffer(byte[])} instead of calling the
+ * A big-endian Java heap buffer.  It is recommended to use {@link ByteBufs#buffer(int)}
+ * and {@link ByteBufs#wrappedBuffer(byte[])} instead of calling the
  * constructor explicitly.
  */
 public class BigEndianHeapByteBuf extends HeapByteBuf {

File: buffer/src/main/java/io/netty/buffer/DynamicByteBuf.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * A dynamic capacity buffer which increases its capacity as needed.  It is
- * recommended to use {@link ChannelBuffers#dynamicBuffer(int)} instead of
+ * recommended to use {@link ByteBufs#dynamicBuffer(int)} instead of
  * calling the constructor explicitly.
  */
 public class DynamicByteBuf extends AbstractByteBuf {
@@ -310,12 +310,12 @@ public ByteBuf copy(int index, int length) {
     public ByteBuf slice(int index, int length) {
         if (index == 0) {
             if (length == 0) {
-                return ChannelBuffers.EMPTY_BUFFER;
+                return ByteBufs.EMPTY_BUFFER;
             }
             return new TruncatedByteBuf(this, length);
         } else {
             if (length == 0) {
-                return ChannelBuffers.EMPTY_BUFFER;
+                return ByteBufs.EMPTY_BUFFER;
             }
             return new SlicedByteBuf(this, index, length);
         }

File: buffer/src/main/java/io/netty/buffer/HeapByteBuf.java
Patch:
@@ -172,7 +172,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
     public ByteBuf slice(int index, int length) {
         if (index == 0) {
             if (length == 0) {
-                return ChannelBuffers.EMPTY_BUFFER;
+                return ByteBufs.EMPTY_BUFFER;
             }
             if (length == array.length) {
                 ByteBuf slice = duplicate();
@@ -183,7 +183,7 @@ public ByteBuf slice(int index, int length) {
             }
         } else {
             if (length == 0) {
-                return ChannelBuffers.EMPTY_BUFFER;
+                return ByteBufs.EMPTY_BUFFER;
             }
             return new SlicedByteBuf(this, index, length);
         }

File: buffer/src/main/java/io/netty/buffer/HeapByteBufFactory.java
Patch:
@@ -66,18 +66,18 @@ public HeapByteBufFactory(ByteOrder defaultOrder) {
 
     @Override
     public ByteBuf getBuffer(ByteOrder order, int capacity) {
-        return ChannelBuffers.buffer(order, capacity);
+        return ByteBufs.buffer(order, capacity);
     }
 
     @Override
     public ByteBuf getBuffer(ByteOrder order, byte[] array, int offset, int length) {
-        return ChannelBuffers.wrappedBuffer(order, array, offset, length);
+        return ByteBufs.wrappedBuffer(order, array, offset, length);
     }
 
     @Override
     public ByteBuf getBuffer(ByteBuffer nioBuffer) {
         if (nioBuffer.hasArray()) {
-            return ChannelBuffers.wrappedBuffer(nioBuffer);
+            return ByteBufs.wrappedBuffer(nioBuffer);
         }
 
         ByteBuf buf = getBuffer(nioBuffer.order(), nioBuffer.remaining());

File: buffer/src/main/java/io/netty/buffer/LittleEndianHeapByteBuf.java
Patch:
@@ -19,8 +19,8 @@
 
 
 /**
- * A little-endian Java heap buffer.  It is recommended to use {@link ChannelBuffers#buffer(ByteOrder, int)}
- * and {@link ChannelBuffers#wrappedBuffer(ByteOrder, byte[])} instead of
+ * A little-endian Java heap buffer.  It is recommended to use {@link ByteBufs#buffer(ByteOrder, int)}
+ * and {@link ByteBufs#wrappedBuffer(ByteOrder, byte[])} instead of
  * calling the constructor explicitly.
  */
 public class LittleEndianHeapByteBuf extends HeapByteBuf {

File: buffer/src/main/java/io/netty/buffer/NioBufferBackedByteBuf.java
Patch:
@@ -25,8 +25,8 @@
 import java.nio.channels.ScatteringByteChannel;
 
 /**
- * A NIO {@link ByteBuffer} based buffer.  It is recommended to use {@link ChannelBuffers#directBuffer(int)}
- * and {@link ChannelBuffers#wrappedBuffer(ByteBuffer)} instead of calling the
+ * A NIO {@link ByteBuffer} based buffer.  It is recommended to use {@link ByteBufs#directBuffer(int)}
+ * and {@link ByteBufs#wrappedBuffer(ByteBuffer)} instead of calling the
  * constructor explicitly.
  */
 public class NioBufferBackedByteBuf extends AbstractByteBuf {
@@ -299,7 +299,7 @@ public ByteBuf slice(int index, int length) {
             return slice;
         } else {
             if (index >= 0 && length == 0) {
-                return ChannelBuffers.EMPTY_BUFFER;
+                return ByteBufs.EMPTY_BUFFER;
             }
             return new NioBufferBackedByteBuf(
                     ((ByteBuffer) tmpBuf.clear().position(

File: buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * A derived buffer which forbids any write requests to its parent.  It is
- * recommended to use {@link ChannelBuffers#unmodifiableBuffer(ByteBuf)}
+ * recommended to use {@link ByteBufs#unmodifiableBuffer(ByteBuf)}
  * instead of calling the constructor explicitly.
  */
 public class ReadOnlyByteBuf extends AbstractByteBuf implements WrappedByteBuf {

File: buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
Patch:
@@ -140,7 +140,7 @@ public ByteBuf copy(int index, int length) {
     public ByteBuf slice(int index, int length) {
         checkIndex(index, length);
         if (length == 0) {
-            return ChannelBuffers.EMPTY_BUFFER;
+            return ByteBufs.EMPTY_BUFFER;
         }
         return new SlicedByteBuf(buffer, index + adjustment, length);
     }

File: buffer/src/main/java/io/netty/buffer/TruncatedByteBuf.java
Patch:
@@ -133,7 +133,7 @@ public ByteBuf copy(int index, int length) {
     public ByteBuf slice(int index, int length) {
         checkIndex(index, length);
         if (length == 0) {
-            return ChannelBuffers.EMPTY_BUFFER;
+            return ByteBufs.EMPTY_BUFFER;
         }
         return buffer.slice(index, length);
     }

File: buffer/src/main/java/io/netty/buffer/package-info.java
Patch:
@@ -98,7 +98,7 @@
  * of the resulting string and let {@link java.lang.StringBuffer} expand itself
  * on demand.  Netty allows you to do the same via a <em>dynamic</em> buffer
  * which is created by the
- * {@link io.netty.buffer.ChannelBuffers#dynamicBuffer()} method.
+ * {@link io.netty.buffer.ByteBufs#dynamicBuffer()} method.
  * <pre>
  * // A new dynamic buffer is created.  Internally, the actual buffer is created
  * // lazily to avoid potentially wasted memory space.

File: buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.buffer;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import static org.junit.Assert.*;
 import io.netty.util.CharsetUtil;
 

File: buffer/src/test/java/io/netty/buffer/BigEndianCompositeChannelBufferTest.java
Patch:
@@ -21,6 +21,6 @@
  */
 public class BigEndianCompositeChannelBufferTest extends AbstractCompositeChannelBufferTest {
     public BigEndianCompositeChannelBufferTest() {
-        super(ChannelBuffers.BIG_ENDIAN);
+        super(ByteBufs.BIG_ENDIAN);
     }
 }

File: buffer/src/test/java/io/netty/buffer/BigEndianDirectChannelBufferTest.java
Patch:
@@ -28,7 +28,7 @@ public class BigEndianDirectChannelBufferTest extends AbstractChannelBufferTest
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.directBuffer(ByteOrder.BIG_ENDIAN, length);
+        buffer = ByteBufs.directBuffer(ByteOrder.BIG_ENDIAN, length);
         assertSame(ByteOrder.BIG_ENDIAN, buffer.order());
         assertEquals(0, buffer.writerIndex());
         return buffer;

File: buffer/src/test/java/io/netty/buffer/BigEndianHeapChannelBufferTest.java
Patch:
@@ -28,7 +28,7 @@ public class BigEndianHeapChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.buffer(length);
+        buffer = ByteBufs.buffer(length);
         assertEquals(0, buffer.writerIndex());
         return buffer;
     }

File: buffer/src/test/java/io/netty/buffer/ChannelBufferIndexFinderTest.java
Patch:
@@ -28,7 +28,7 @@ public class ChannelBufferIndexFinderTest {
 
     @Test
     public void testForward() {
-        ByteBuf buf = ChannelBuffers.copiedBuffer(
+        ByteBuf buf = ByteBufs.copiedBuffer(
                 "abc\r\n\ndef\r\rghi\n\njkl\0\0mno  \t\tx",
                 CharsetUtil.ISO_8859_1);
 
@@ -47,7 +47,7 @@ public void testForward() {
 
     @Test
     public void testBackward() {
-        ByteBuf buf = ChannelBuffers.copiedBuffer(
+        ByteBuf buf = ByteBufs.copiedBuffer(
                 "abc\r\n\ndef\r\rghi\n\njkl\0\0mno  \t\tx",
                 CharsetUtil.ISO_8859_1);
 

File: buffer/src/test/java/io/netty/buffer/ChannelBufferStreamTest.java
Patch:
@@ -29,7 +29,7 @@ public class ChannelBufferStreamTest {
 
     @Test
     public void testAll() throws Exception {
-        ByteBuf buf = ChannelBuffers.dynamicBuffer();
+        ByteBuf buf = ByteBufs.dynamicBuffer();
 
         try {
             new ByteBufOutputStream(null);
@@ -171,7 +171,7 @@ public void testAll() throws Exception {
 
     @Test
     public void testEmptyReadLine() throws Exception {
-        ByteBuf buf = ChannelBuffers.buffer(0);
+        ByteBuf buf = ByteBufs.buffer(0);
         ByteBufInputStream in = new ByteBufInputStream(buf);
 
         String s = in.readLine();

File: buffer/src/test/java/io/netty/buffer/DuplicateChannelBufferTest.java
Patch:
@@ -28,7 +28,7 @@ public class DuplicateChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = new DuplicatedByteBuf(ChannelBuffers.buffer(length));
+        buffer = new DuplicatedByteBuf(ByteBufs.buffer(length));
         assertEquals(0, buffer.writerIndex());
         return buffer;
     }

File: buffer/src/test/java/io/netty/buffer/DynamicChannelBufferTest.java
Patch:
@@ -30,7 +30,7 @@ public class DynamicChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.dynamicBuffer(length);
+        buffer = ByteBufs.dynamicBuffer(length);
 
         assertEquals(0, buffer.readerIndex());
         assertEquals(0, buffer.writerIndex());

File: buffer/src/test/java/io/netty/buffer/LittleEndianCompositeChannelBufferTest.java
Patch:
@@ -21,6 +21,6 @@
  */
 public class LittleEndianCompositeChannelBufferTest extends AbstractCompositeChannelBufferTest {
     public LittleEndianCompositeChannelBufferTest() {
-        super(ChannelBuffers.LITTLE_ENDIAN);
+        super(ByteBufs.LITTLE_ENDIAN);
     }
 }

File: buffer/src/test/java/io/netty/buffer/LittleEndianDirectChannelBufferTest.java
Patch:
@@ -28,7 +28,7 @@ public class LittleEndianDirectChannelBufferTest extends AbstractChannelBufferTe
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, length);
+        buffer = ByteBufs.directBuffer(ByteOrder.LITTLE_ENDIAN, length);
         assertSame(ByteOrder.LITTLE_ENDIAN, buffer.order());
         assertEquals(0, buffer.writerIndex());
         return buffer;

File: buffer/src/test/java/io/netty/buffer/LittleEndianHeapChannelBufferTest.java
Patch:
@@ -30,7 +30,7 @@ public class LittleEndianHeapChannelBufferTest extends AbstractChannelBufferTest
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.buffer(ByteOrder.LITTLE_ENDIAN, length);
+        buffer = ByteBufs.buffer(ByteOrder.LITTLE_ENDIAN, length);
         assertEquals(0, buffer.writerIndex());
         return buffer;
     }

File: buffer/src/test/java/io/netty/buffer/SlicedChannelBufferTest.java
Patch:
@@ -31,7 +31,7 @@ public class SlicedChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.wrappedBuffer(
+        buffer = ByteBufs.wrappedBuffer(
                 new byte[length * 2], random.nextInt(length - 1) + 1, length);
         assertEquals(length, buffer.writerIndex());
         return buffer;

File: buffer/src/test/java/io/netty/buffer/TruncatedChannelBufferTest.java
Patch:
@@ -28,7 +28,7 @@ public class TruncatedChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
-        buffer = ChannelBuffers.wrappedBuffer(
+        buffer = ByteBufs.wrappedBuffer(
                 new byte[length * 2], 0, length);
         assertEquals(length, buffer.writerIndex());
         return buffer;

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 import java.util.List;
 import java.util.Map;
@@ -97,7 +97,7 @@ public Set<String> getHeaderNames() {
 
     @Override
     public ByteBuf getContent() {
-        return ChannelBuffers.EMPTY_BUFFER;
+        return ByteBufs.EMPTY_BUFFER;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunk.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelPipeline;
 
 import java.util.Collections;
@@ -41,7 +41,7 @@ public interface HttpChunk {
     HttpChunkTrailer LAST_CHUNK = new HttpChunkTrailer() {
         @Override
         public ByteBuf getContent() {
-            return ChannelBuffers.EMPTY_BUFFER;
+            return ByteBufs.EMPTY_BUFFER;
         }
 
         @Override
@@ -113,7 +113,7 @@ public void setHeader(String name, Iterable<?> values) {
 
     /**
      * Returns the content of this chunk.  If this is the 'end of content'
-     * marker, {@link ChannelBuffers#EMPTY_BUFFER} will be returned.
+     * marker, {@link ByteBufs#EMPTY_BUFFER} will be returned.
      */
     ByteBuf getContent();
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -17,7 +17,7 @@
 
 import static io.netty.handler.codec.http.HttpHeaders.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
@@ -48,7 +48,7 @@
  */
 public class HttpChunkAggregator extends MessageToMessageDecoder<Object, HttpMessage> {
 
-    private static final ByteBuf CONTINUE = ChannelBuffers.copiedBuffer(
+    private static final ByteBuf CONTINUE = ByteBufs.copiedBuffer(
             "HTTP/1.1 100 Continue\r\n\r\n", CharsetUtil.US_ASCII);
 
     private final int maxContentLength;
@@ -101,7 +101,7 @@ public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exceptio
                     m.removeHeader(HttpHeaders.Names.TRANSFER_ENCODING);
                 }
                 m.setChunked(false);
-                m.setContent(ChannelBuffers.dynamicBuffer());
+                m.setContent(ByteBufs.dynamicBuffer());
                 this.currentMessage = m;
                 return null;
             } else {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.ReplayingDecoder;
@@ -204,7 +204,7 @@ public Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception
             } else {
                 long contentLength = HttpHeaders.getContentLength(message, -1);
                 if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {
-                    content = ChannelBuffers.EMPTY_BUFFER;
+                    content = ByteBufs.EMPTY_BUFFER;
                     return reset();
                 }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import static io.netty.handler.codec.http.HttpConstants.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 /**
  * Web Socket frame containing binary data
@@ -27,7 +27,7 @@ public class BinaryWebSocketFrame extends WebSocketFrame {
      * Creates a new empty binary frame.
      */
     public BinaryWebSocketFrame() {
-        setBinaryData(ChannelBuffers.EMPTY_BUFFER);
+        setBinaryData(ByteBufs.EMPTY_BUFFER);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 /**
  * Web Socket frame containing binary data
@@ -28,7 +28,7 @@ public class PingWebSocketFrame extends WebSocketFrame {
      */
     public PingWebSocketFrame() {
         setFinalFragment(true);
-        setBinaryData(ChannelBuffers.EMPTY_BUFFER);
+        setBinaryData(ByteBufs.EMPTY_BUFFER);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 /**
  * Web Socket frame containing binary data
@@ -27,7 +27,7 @@ public class PongWebSocketFrame extends WebSocketFrame {
      * Creates a new empty pong frame.
      */
     public PongWebSocketFrame() {
-        setBinaryData(ChannelBuffers.EMPTY_BUFFER);
+        setBinaryData(ByteBufs.EMPTY_BUFFER);
     }
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -54,7 +54,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.CorruptedFrameException;
@@ -257,7 +257,7 @@ public WebSocketFrame decode(
                 // Returning null means we will get called back
                 payloadBuffer = in.readBytes(rbytes);
                 if (framePayload == null) {
-                    framePayload = ChannelBuffers.buffer(toFrameLength(framePayloadLength));
+                    framePayload = ByteBufs.buffer(toFrameLength(framePayloadLength));
                 }
                 framePayload.writeBytes(payloadBuffer);
                 framePayloadBytesRead += rbytes;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -54,7 +54,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToByteEncoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -106,7 +106,7 @@ public void encode(ChannelHandlerContext ctx,
         WebSocketFrame frame = msg;
         ByteBuf data = frame.getBinaryData();
         if (data == null) {
-            data = ChannelBuffers.EMPTY_BUFFER;
+            data = ByteBufs.EMPTY_BUFFER;
         }
 
         byte opcode;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.handler.codec.http.DefaultHttpRequest;
@@ -164,7 +164,7 @@ public ChannelFuture handshake(Channel channel) {
             }
         }
 
-        request.setContent(ChannelBuffers.copiedBuffer(key3));
+        request.setContent(ByteBufs.copiedBuffer(key3));
 
         ChannelFuture future = channel.write(request);
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -19,7 +19,7 @@
 import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPipeline;
@@ -154,11 +154,11 @@ public ChannelFuture handshake(Channel channel, HttpRequest req) {
             int a = (int) (Long.parseLong(key1.replaceAll("[^0-9]", "")) / key1.replaceAll("[^ ]", "").length());
             int b = (int) (Long.parseLong(key2.replaceAll("[^0-9]", "")) / key2.replaceAll("[^ ]", "").length());
             long c = req.getContent().readLong();
-            ByteBuf input = ChannelBuffers.buffer(16);
+            ByteBuf input = ByteBufs.buffer(16);
             input.writeInt(a);
             input.writeInt(b);
             input.writeLong(c);
-            ByteBuf output = ChannelBuffers.wrappedBuffer(WebSocketUtil.md5(input.array()));
+            ByteBuf output = ByteBufs.wrappedBuffer(WebSocketUtil.md5(input.array()));
             res.setContent(output);
         } else {
             // Old Hixie 75 handshake method with no challenge:

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.handler.codec.base64.Base64;
 import io.netty.util.CharsetUtil;
 
@@ -68,7 +68,7 @@ static byte[] sha1(byte[] bytes) {
      * @return encoded string
      */
     static String base64(byte[] bytes) {
-        ByteBuf hashed = ChannelBuffers.wrappedBuffer(bytes);
+        ByteBuf hashed = ByteBufs.wrappedBuffer(bytes);
         return Base64.encode(hashed).toString(CharsetUtil.UTF_8);
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.util.internal.StringUtil;
 
 /**
@@ -27,7 +27,7 @@ public class DefaultSpdyDataFrame implements SpdyDataFrame {
     private int streamID;
     private boolean last;
     private boolean compressed;
-    private ByteBuf data = ChannelBuffers.EMPTY_BUFFER;
+    private ByteBuf data = ByteBufs.EMPTY_BUFFER;
 
     /**
      * Creates a new instance.
@@ -80,7 +80,7 @@ public ByteBuf getData() {
     @Override
     public void setData(ByteBuf data) {
         if (data == null) {
-            data = ChannelBuffers.EMPTY_BUFFER;
+            data = ByteBufs.EMPTY_BUFFER;
         }
         if (data.readableBytes() > SpdyCodecUtil.SPDY_MAX_LENGTH) {
             throw new IllegalArgumentException("data payload cannot exceed "

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 /**
  * A SPDY Protocol Data Frame
@@ -58,13 +58,13 @@ public interface SpdyDataFrame {
 
     /**
      * Returns the data payload of this frame.  If there is no data payload
-     * {@link ChannelBuffers#EMPTY_BUFFER} is returned.
+     * {@link ByteBufs#EMPTY_BUFFER} is returned.
      */
     ByteBuf getData();
 
     /**
      * Sets the data payload of this frame.  If {@code null} is specified,
-     * the data payload will be set to {@link ChannelBuffers#EMPTY_BUFFER}.
+     * the data payload will be set to {@link ByteBufs#EMPTY_BUFFER}.
      * The data payload cannot exceed 16777215 bytes.
      */
     void setData(ByteBuf data);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -554,7 +554,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
             // Initialize header block decoding fields
             headerSize = 0;
             numHeaders = -1;
-            decompressed = ChannelBuffers.dynamicBuffer(8192);
+            decompressed = ByteBufs.dynamicBuffer(8192);
         }
 
         // Accumulate decompressed data

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -206,8 +206,8 @@ public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exceptio
 
             ByteBuf spdyDataFrameData = spdyDataFrame.getData();
             int spdyDataFrameDataLen = spdyDataFrameData.readableBytes();
-            if (content == ChannelBuffers.EMPTY_BUFFER) {
-                content = ChannelBuffers.dynamicBuffer(spdyDataFrameDataLen);
+            if (content == ByteBufs.EMPTY_BUFFER) {
+                content = ByteBufs.dynamicBuffer(spdyDataFrameDataLen);
                 content.writeBytes(spdyDataFrameData, spdyDataFrameData.readerIndex(), spdyDataFrameDataLen);
                 httpMessage.setContent(content);
             } else {

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -19,7 +19,7 @@
 import static io.netty.handler.codec.http.HttpVersion.*;
 import static org.easymock.EasyMock.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.DefaultChannelFuture;
 import io.netty.channel.DefaultChannelPipeline;
@@ -71,7 +71,7 @@ public void testPerformOpeningHandshake() {
         req.setHeader(Names.SEC_WEBSOCKET_KEY2, "12998 5 Y3 1  .P00");
         req.setHeader(Names.SEC_WEBSOCKET_PROTOCOL, "chat, superchat");
 
-        ByteBuf buffer = ChannelBuffers.copiedBuffer("^n:ds[4U", Charset.defaultCharset());
+        ByteBuf buffer = ByteBufs.copiedBuffer("^n:ds[4U", Charset.defaultCharset());
         req.setContent(buffer);
 
         WebSocketServerHandshaker00 handsaker = new WebSocketServerHandshaker00("ws://example.com/chat", "chat", Integer.MAX_VALUE);

File: codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelHandlerContext;
@@ -71,7 +71,7 @@ public FixedLengthFrameDecoder(int frameLength, boolean allocateFullBuffer) {
     public ChannelBufferHolder<Byte> newInboundBuffer(
             ChannelHandlerContext ctx) throws Exception {
         if (allocateFullBuffer) {
-            return ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer(frameLength));
+            return ChannelBufferHolders.byteBuffer(ByteBufs.dynamicBuffer(frameLength));
         } else {
             return super.newInboundBuffer(ctx);
         }

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufFactory;
 import io.netty.buffer.ByteBufIndexFinder;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.util.Signal;
 
 import java.io.IOException;
@@ -37,7 +37,7 @@ class ReplayingDecoderBuffer implements ByteBuf {
     private final ByteBuf buffer;
     private boolean terminated;
 
-    public static ReplayingDecoderBuffer EMPTY_BUFFER = new ReplayingDecoderBuffer(ChannelBuffers.EMPTY_BUFFER);
+    public static ReplayingDecoderBuffer EMPTY_BUFFER = new ReplayingDecoderBuffer(ByteBufs.EMPTY_BUFFER);
 
     static {
         EMPTY_BUFFER.terminate();

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelHandlerContext;
@@ -67,6 +67,6 @@ public ByteBuf encode(ChannelHandlerContext ctx, byte[] msg) throws Exception {
         if (msg.length == 0) {
             return null;
         }
-        return ChannelBuffers.wrappedBuffer(msg);
+        return ByteBufs.wrappedBuffer(msg);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
@@ -383,9 +383,9 @@ private ChannelFuture finishEncode(ChannelHandlerContext ctx, ChannelFuture futu
                     future.setFailure(ZlibUtil.exception(z, "compression failure", resultCode));
                     return future;
                 } else if (z.next_out_index != 0) {
-                    footer = ChannelBuffers.wrappedBuffer(out, 0, z.next_out_index);
+                    footer = ByteBufs.wrappedBuffer(out, 0, z.next_out_index);
                 } else {
-                    footer = ChannelBuffers.EMPTY_BUFFER;
+                    footer = ByteBufs.EMPTY_BUFFER;
                 }
             } finally {
                 z.deflateEnd();

File: codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufFactory;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 import java.io.IOException;
 
@@ -44,7 +44,7 @@ public ChannelBufferByteOutput(ByteBuf buffer) {
      * Calls {@link #ChannelBufferByteOutput(ByteBuf)} with a dynamic {@link ByteBuf}
      */
     public ChannelBufferByteOutput(ByteBufFactory factory, int estimatedLength) {
-        this(ChannelBuffers.dynamicBuffer(estimatedLength, factory));
+        this(ByteBufs.dynamicBuffer(estimatedLength, factory));
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.protobuf;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectEncoderOutputStream.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -81,7 +81,7 @@ public ObjectEncoderOutputStream(OutputStream out, int estimatedLength) {
     @Override
     public void writeObject(Object obj) throws IOException {
         ByteBufOutputStream bout = new ByteBufOutputStream(
-                ChannelBuffers.dynamicBuffer(estimatedLength));
+                ByteBufs.dynamicBuffer(estimatedLength));
         ObjectOutputStream oout = new CompactObjectOutputStream(bout);
         oout.writeObject(obj);
         oout.flush();

File: codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.string;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
@@ -79,6 +79,6 @@ public boolean isEncodable(Object msg) throws Exception {
 
     @Override
     public ByteBuf encode(ChannelHandlerContext ctx, String msg) throws Exception {
-        return ChannelBuffers.copiedBuffer(msg, charset);
+        return ByteBufs.copiedBuffer(msg, charset);
     }
 }

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.bytes;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
 import io.netty.channel.embedded.EmbeddedMessageChannel;

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.bytes;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import static org.hamcrest.core.Is.*;
 import static org.hamcrest.core.IsNull.*;
 import static org.junit.Assert.*;

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.junit.Assert.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.embedded.EmbeddedByteChannel;
 import io.netty.handler.codec.CodecException;
@@ -64,7 +64,7 @@ public void testSimpleUnmarshalling() throws IOException {
     }
 
     protected ByteBuf input(byte[] input) {
-        return ChannelBuffers.wrappedBuffer(input);
+        return ByteBufs.wrappedBuffer(input);
     }
 
     @Test

File: codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
Patch:
@@ -16,16 +16,16 @@
 package io.netty.handler.codec.marshalling;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandler;
 
 public class RiverMarshallingDecoderTest extends RiverCompatibleMarshallingDecoderTest {
 
     @Override
     protected ByteBuf input(byte[] input) {
-        ByteBuf length = ChannelBuffers.buffer(4);
+        ByteBuf length = ByteBufs.buffer(4);
         length.writeInt(input.length);
-        return ChannelBuffers.wrappedBuffer(length, ChannelBuffers.wrappedBuffer(input));
+        return ByteBufs.wrappedBuffer(length, ByteBufs.wrappedBuffer(input));
     }
 
     @Override

File: codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
Patch:
@@ -16,16 +16,16 @@
 package io.netty.handler.codec.marshalling;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandler;
 
 public class SerialMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest {
 
     @Override
     protected ByteBuf input(byte[] input) {
-        ByteBuf length = ChannelBuffers.buffer(4);
+        ByteBuf length = ByteBufs.buffer(4);
         length.writeInt(input.length);
-        return ChannelBuffers.wrappedBuffer(length, ChannelBuffers.wrappedBuffer(input));
+        return ByteBufs.wrappedBuffer(length, ByteBufs.wrappedBuffer(input));
     }
 
     @Override

File: codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.protobuf;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import static org.hamcrest.core.Is.*;
 import static org.hamcrest.core.IsNull.*;
 import static org.junit.Assert.*;

File: codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.protobuf;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
 import io.netty.channel.embedded.EmbeddedByteChannel;

File: example/src/main/java/io/netty/example/echo/EchoClientHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.echo;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
 
@@ -42,7 +42,7 @@ public EchoClientHandler(int firstMessageSize) {
         if (firstMessageSize <= 0) {
             throw new IllegalArgumentException("firstMessageSize: " + firstMessageSize);
         }
-        firstMessage = ChannelBuffers.buffer(firstMessageSize);
+        firstMessage = ByteBufs.buffer(firstMessageSize);
         for (int i = 0; i < firstMessage.capacity(); i ++) {
             firstMessage.writeByte((byte) i);
         }

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -20,7 +20,7 @@
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
@@ -215,7 +215,7 @@ private static String sanitizeUri(String uri) {
     private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
         HttpResponse response = new DefaultHttpResponse(HTTP_1_1, status);
         response.setHeader(CONTENT_TYPE, "text/plain; charset=UTF-8");
-        response.setContent(ChannelBuffers.copiedBuffer(
+        response.setContent(ByteBufs.copiedBuffer(
                 "Failure: " + status.toString() + "\r\n",
                 CharsetUtil.UTF_8));
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
Patch:
@@ -20,7 +20,7 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelFuture;
@@ -131,7 +131,7 @@ private void writeResponse(ChannelHandlerContext ctx) {
 
         // Build the response object.
         HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
-        response.setContent(ChannelBuffers.copiedBuffer(buf.toString(), CharsetUtil.UTF_8));
+        response.setContent(ByteBufs.copiedBuffer(buf.toString(), CharsetUtil.UTF_8));
         response.setHeader(CONTENT_TYPE, "text/plain; charset=UTF-8");
 
         if (keepAlive) {

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -19,7 +19,7 @@
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
@@ -108,7 +108,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
     private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpResponse res) {
         // Generate an error page if response status code is not OK (200).
         if (res.getStatus().getCode() != 200) {
-            res.setContent(ChannelBuffers.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
+            res.setContent(ByteBufs.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
             setContentLength(res, res.getContent().readableBytes());
         }
 

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -37,7 +37,7 @@
 package io.netty.example.http.websocketx.client;
 
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
@@ -108,7 +108,7 @@ public void initChannel(SocketChannel ch) throws Exception {
 
             // Ping
             System.out.println("WebSocket Client sending ping");
-            ch.write(new PingWebSocketFrame(ChannelBuffers.copiedBuffer(new byte[]{1, 2, 3, 4, 5, 6})));
+            ch.write(new PingWebSocketFrame(ByteBufs.copiedBuffer(new byte[]{1, 2, 3, 4, 5, 6})));
 
             // Close
             System.out.println("WebSocket Client sending close");

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -21,7 +21,7 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
@@ -121,7 +121,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
     private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpResponse res) {
         // Generate an error page if response status code is not OK (200).
         if (res.getStatus().getCode() != 200) {
-            res.setContent(ChannelBuffers.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
+            res.setContent(ByteBufs.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
             setContentLength(res, res.getContent().readableBytes());
         }
 

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerIndexPage.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.http.websocketx.server;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.util.CharsetUtil;
 
 /**
@@ -27,7 +27,7 @@ public final class WebSocketServerIndexPage {
     private static final String NEWLINE = "\r\n";
 
     public static ByteBuf getContent(String webSocketLocation) {
-        return ChannelBuffers.copiedBuffer(
+        return ByteBufs.copiedBuffer(
                 "<html><head><title>Web Socket Test</title></head>" + NEWLINE +
                 "<body>" + NEWLINE +
                 "<script type=\"text/javascript\">" + NEWLINE +

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
Patch:
@@ -21,7 +21,7 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
@@ -122,7 +122,7 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
     private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpResponse res) {
         // Generate an error page if response status code is not OK (200).
         if (res.getStatus().getCode() != 200) {
-            res.setContent(ChannelBuffers.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
+            res.setContent(ByteBufs.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8));
             setContentLength(res, res.getContent().readableBytes());
         }
 

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.qotm;
 
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.socket.DatagramPacket;
@@ -53,7 +53,7 @@ public void run() throws Exception {
 
             // Broadcast the QOTM request to port 8080.
             ch.write(new DatagramPacket(
-                    ChannelBuffers.copiedBuffer("QOTM?", CharsetUtil.UTF_8),
+                    ByteBufs.copiedBuffer("QOTM?", CharsetUtil.UTF_8),
                     new InetSocketAddress("255.255.255.255", port)));
 
             // QuoteOfTheMomentClientHandler will close the DatagramChannel when a

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.qotm;
 
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.socket.DatagramPacket;
@@ -49,7 +49,7 @@ public void messageReceived(
             throws Exception {
         if (msg.data().toString(CharsetUtil.UTF_8).equals("QOTM?")) {
             ctx.write(new DatagramPacket(
-                    ChannelBuffers.copiedBuffer("QOTM: " + nextQuote(), CharsetUtil.UTF_8),
+                    ByteBufs.copiedBuffer("QOTM: " + nextQuote(), CharsetUtil.UTF_8),
                     msg.remoteAddress()));
         }
     }

File: handler/src/main/java/io/netty/handler/stream/ChunkedFile.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 
 import java.io.File;
 import java.io.IOException;

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 
 import java.io.File;
 import java.io.FileInputStream;

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;

File: handler/src/main/java/io/netty/handler/stream/ChunkedStream.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import static io.netty.buffer.ChannelBuffers.*;
+import static io.netty.buffer.ByteBufs.*;
 
 import java.io.InputStream;
 import java.io.PushbackInputStream;

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
@@ -197,7 +197,7 @@ private void doFlush(final ChannelHandlerContext ctx) throws Exception {
                     chunk = chunks.nextChunk();
                     endOfInput = chunks.isEndOfInput();
                     if (chunk == null) {
-                        chunk = ChannelBuffers.EMPTY_BUFFER;
+                        chunk = ByteBufs.EMPTY_BUFFER;
                         // No need to suspend when reached at the end.
                         suspend = !endOfInput;
                     } else {

File: handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.junit.Assert.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelFuture;
@@ -103,11 +103,11 @@ public void testChunkedNioFile() throws IOException {
     // http://stackoverflow.com/questions/10409241/why-is-close-channelfuturelistener-not-notified/10426305#comment14126161_10426305
     @Test
     public void testListenerNotifiedWhenIsEnd() {
-        ByteBuf buffer = ChannelBuffers.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
+        ByteBuf buffer = ByteBufs.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
 
         ChunkedInput input = new ChunkedInput() {
             private boolean done;
-            private final ByteBuf buffer = ChannelBuffers.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
+            private final ByteBuf buffer = ByteBufs.copiedBuffer("Test", CharsetUtil.ISO_8859_1);
 
             @Override
             public Object nextChunk() throws Exception {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -68,7 +68,7 @@ public void messageReceived(
 
         cc.joinGroup(groupAddress, NetworkConstants.LOOPBACK_IF).sync();
 
-        sc.write(new DatagramPacket(ChannelBuffers.copyInt(1), groupAddress)).sync();
+        sc.write(new DatagramPacket(ByteBufs.copyInt(1), groupAddress)).sync();
         assertTrue(mhandler.await());
 
         // leave the group
@@ -78,7 +78,7 @@ public void messageReceived(
         Thread.sleep(1000);
 
         // we should not receive a message anymore as we left the group before
-        sc.write(new DatagramPacket(ChannelBuffers.copyInt(1), groupAddress)).sync();
+        sc.write(new DatagramPacket(ByteBufs.copyInt(1), groupAddress)).sync();
         mhandler.await();
 
         sc.close().awaitUninterruptibly();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -61,7 +61,7 @@ public void messageReceived(
         Channel sc = sb.bind().sync().channel();
         Channel cc = cb.bind().sync().channel();
 
-        cc.write(new DatagramPacket(ChannelBuffers.copyInt(1), addr)).sync();
+        cc.write(new DatagramPacket(ByteBufs.copyInt(1), addr)).sync();
         assertTrue(latch.await(10, TimeUnit.SECONDS));
 
         sc.close().sync();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
@@ -56,7 +56,7 @@ public void testSimpleEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
 
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);
-            cc.write(ChannelBuffers.wrappedBuffer(data, i, length));
+            cc.write(ByteBufs.wrappedBuffer(data, i, length));
             i += length;
         }
 
@@ -135,7 +135,7 @@ public void inboundBufferUpdated(
             }
 
             if (channel.parent() != null) {
-                channel.write(ChannelBuffers.wrappedBuffer(actual));
+                channel.write(ByteBufs.wrappedBuffer(actual));
             }
 
             counter += actual.length;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
@@ -71,7 +71,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         Channel cc = cb.connect().sync().channel();
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 3), data.length - i);
-            cc.write(ChannelBuffers.wrappedBuffer(data, i, length));
+            cc.write(ByteBufs.wrappedBuffer(data, i, length));
             i += length;
         }
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundByteHandlerAdapter;
@@ -45,7 +45,7 @@ public class SocketSpdyEchoTest extends AbstractSocketTest {
 
     private static ByteBuf createFrames(int version) {
         int length = version < 3 ? 1176 : 1174;
-        ByteBuf frames = ChannelBuffers.buffer(length);
+        ByteBuf frames = ByteBufs.buffer(length);
 
         // SPDY UNKNOWN Frame
         frames.writeByte(0x80);

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
@@ -96,7 +96,7 @@ public void initChannel(SocketChannel sch) throws Exception {
 
         for (int i = 0; i < data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);
-            cc.write(ChannelBuffers.wrappedBuffer(data, i, length));
+            cc.write(ByteBufs.wrappedBuffer(data, i, length));
             i += length;
         }
 
@@ -177,7 +177,7 @@ public void inboundBufferUpdated(
             }
 
             if (channel.parent() != null) {
-                channel.write(ChannelBuffers.wrappedBuffer(actual));
+                channel.write(ByteBufs.wrappedBuffer(actual));
             }
 
             counter += actual.length;

File: transport/src/main/java/io/netty/channel/ChannelBufferHolders.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.AbstractByteBuf;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufFactory;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.buffer.HeapByteBufFactory;
 
 import java.io.IOException;
@@ -51,7 +51,7 @@ public static <E> ChannelBufferHolder<E> messageBuffer(Queue<E> buffer) {
 
     public static ChannelBufferHolder<Byte> byteBuffer() {
         // TODO: Use more efficient implementation.
-        return byteBuffer(ChannelBuffers.dynamicBuffer());
+        return byteBuffer(ByteBufs.dynamicBuffer());
     }
 
     public static ChannelBufferHolder<Byte> byteBuffer(ByteBuf buffer) {

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -17,7 +17,7 @@
 
 import static io.netty.channel.DefaultChannelPipeline.*;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.util.DefaultAttributeMap;
 import io.netty.util.internal.QueueFactory;
 
@@ -763,7 +763,7 @@ void flush(Queue<Object> out) {
     }
 
     static final class ByteBridge {
-        final ByteBuf byteBuf = ChannelBuffers.dynamicBuffer();
+        final ByteBuf byteBuf = ByteBufs.dynamicBuffer();
         final BlockingQueue<ByteBuf> exchangeBuf = QueueFactory.createQueue();
 
         void fill() {

File: transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel.embedded;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
@@ -47,7 +47,7 @@ public abstract class AbstractEmbeddedChannel extends AbstractChannel {
     private final SocketAddress localAddress = new EmbeddedSocketAddress();
     private final SocketAddress remoteAddress = new EmbeddedSocketAddress();
     private final Queue<Object> lastInboundMessageBuffer = new ArrayDeque<Object>();
-    private final ByteBuf lastInboundByteBuffer = ChannelBuffers.dynamicBuffer();
+    private final ByteBuf lastInboundByteBuffer = ByteBufs.dynamicBuffer();
     protected final Object lastOutboundBuffer;
     private Throwable lastException;
     private int state; // 0 = OPEN, 1 = ACTIVE, 2 = CLOSED

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java
Patch:
@@ -16,14 +16,14 @@
 package io.netty.channel.embedded;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelBufferType;
 
 public class EmbeddedByteChannel extends AbstractEmbeddedChannel {
 
     public EmbeddedByteChannel(ChannelHandler... handlers) {
-        super(ChannelBuffers.dynamicBuffer(), handlers);
+        super(ByteBufs.dynamicBuffer(), handlers);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/group/ChannelGroup.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ServerChannel;
@@ -43,7 +43,7 @@
  * recipients.add(channelA);
  * recipients.add(channelB);
  * ..
- * <strong>recipients.write({@link ChannelBuffers}.copiedBuffer(
+ * <strong>recipients.write({@link ByteBufs}.copiedBuffer(
  *         "Service will shut down for maintenance in 5 minutes.",
  *         {@link CharsetUtil}.UTF_8));</strong>
  * </pre>

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.socket.DatagramChannelConfig;
@@ -169,7 +169,7 @@ protected int doReadMessages(Queue<Object> buf) throws Exception {
         }
 
         data.flip();
-        buf.add(new DatagramPacket(ChannelBuffers.wrappedBuffer(data), remoteAddress));
+        buf.add(new DatagramPacket(ByteBufs.wrappedBuffer(data), remoteAddress));
         return 1;
     }
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel.socket.oio;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ChannelBuffers;
+import io.netty.buffer.ByteBufs;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.socket.DatagramChannel;
@@ -158,7 +158,7 @@ protected int doReadMessages(Queue<Object> buf) throws Exception {
             if (remoteAddr == null) {
                 remoteAddr = remoteAddress();
             }
-            buf.add(new DatagramPacket(ChannelBuffers.wrappedBuffer(
+            buf.add(new DatagramPacket(ByteBufs.wrappedBuffer(
                     data, tmpPacket.getOffset(), tmpPacket.getLength()), remoteAddr));
             return 1;
         } catch (SocketTimeoutException e) {

File: transport/src/main/java/io/netty/channel/AbstractServerChannel.java
Patch:
@@ -50,8 +50,8 @@ public Queue<Object> outboundMessageBuffer() {
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.MESSAGE;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -113,8 +113,6 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
      */
     Integer id();
 
-    ChannelType type();
-
     EventLoop eventLoop();
 
     /**
@@ -140,6 +138,8 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
     boolean isRegistered();
     boolean isActive();
 
+    ChannelBufferType bufferType();
+
     ChannelBuffer outboundByteBuffer();
     <T> Queue<T> outboundMessageBuffer();
 

File: transport/src/main/java/io/netty/channel/ChannelBufferType.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-public enum ChannelType {
+public enum ChannelBufferType {
     STREAM,
     MESSAGE;
 }

File: transport/src/main/java/io/netty/channel/ChannelHandlerType.java
Patch:
@@ -17,8 +17,8 @@
 
 public enum ChannelHandlerType {
     STATE(0),
-    OPERATION(1),
     INBOUND(0),
+    OPERATION(1),
     OUTBOUND(1);
 
     final int direction; // 0 - up (inbound), 1 - down (outbound)

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -79,7 +79,7 @@
  *  |            /|\                         .               |
  *  |             .                          .               |
  *  |     [ sendUpstream() ]        [ sendDownstream() ]     |
- *  |     [ + INBOUND data ]        [ + OUTBOUND data  ]     |
+ *  |     [ + VAL_INBOUND data ]        [ + VAL_OUTBOUND data  ]     |
  *  |             .                          .               |
  *  |             .                         \|/              |
  *  |  +----------+-----------+  +-----------+------------+  |

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.channel.embedded;
 
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
@@ -28,8 +28,8 @@ public EmbeddedMessageChannel(ChannelHandler... handlers) {
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.MESSAGE;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.MESSAGE;
     }
 
     public Queue<Object> inboundBuffer() {

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedStreamChannel.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 
 public class EmbeddedStreamChannel extends AbstractEmbeddedChannel {
 
@@ -27,8 +27,8 @@ public EmbeddedStreamChannel(ChannelHandler... handlers) {
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.STREAM;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.STREAM;
     }
 
     public ChannelBuffer inboundBuffer() {

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -20,7 +20,7 @@
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
 import io.netty.channel.SingleThreadEventLoop;
@@ -67,8 +67,8 @@ public LocalChannel(Integer id) {
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.MESSAGE;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 
 import java.io.IOException;
 import java.nio.channels.SelectableChannel;
@@ -31,8 +31,8 @@ protected AbstractNioMessageChannel(
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.MESSAGE;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioStreamChannel.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 
 import java.io.IOException;
 import java.nio.channels.SelectableChannel;
@@ -32,8 +32,8 @@ protected AbstractNioStreamChannel(
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.STREAM;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.STREAM;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 
 import java.io.IOException;
 import java.util.Queue;
@@ -29,8 +29,8 @@ protected AbstractOioMessageChannel(Channel parent, Integer id) {
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.MESSAGE;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.MESSAGE;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioStreamChannel.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelType;
+import io.netty.channel.ChannelBufferType;
 
 import java.io.IOException;
 
@@ -29,8 +29,8 @@ protected AbstractOioStreamChannel(Channel parent, Integer id) {
     }
 
     @Override
-    public ChannelType type() {
-        return ChannelType.STREAM;
+    public ChannelBufferType bufferType() {
+        return ChannelBufferType.STREAM;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -255,7 +255,7 @@ private static void addQuoted(StringBuilder sb, String name, String val) {
         sb.append((char) HttpConstants.SEMICOLON);
     }
 
-    private static void add(StringBuilder sb, String name, int val) {
+    private static void add(StringBuilder sb, String name, long val) {
         sb.append(name);
         sb.append((char) HttpConstants.EQUALS);
         sb.append(val);

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioChannel.java
Patch:
@@ -25,6 +25,8 @@
 
 abstract class AbstractOioChannel extends AbstractChannel {
 
+    static final int SO_TIMEOUT = 1000;
+
     protected AbstractOioChannel(Channel parent, Integer id) {
         super(parent, id);
     }

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -69,7 +69,7 @@ public OioDatagramChannel(Integer id, MulticastSocket socket) {
 
         boolean success = false;
         try {
-            socket.setSoTimeout(1000);
+            socket.setSoTimeout(SO_TIMEOUT);
             socket.setBroadcast(false);
             success = true;
         } catch (SocketException e) {

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -66,7 +66,7 @@ public OioServerSocketChannel(Integer id, ServerSocket socket) {
 
         boolean success = false;
         try {
-            socket.setSoTimeout(1000);
+            socket.setSoTimeout(SO_TIMEOUT);
             success = true;
         } catch (IOException e) {
             throw new ChannelException(

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -62,7 +62,7 @@ public OioSocketChannel(Channel parent, Integer id, Socket socket) {
                 is = socket.getInputStream();
                 os = socket.getOutputStream();
             }
-            socket.setSoTimeout(1000);
+            socket.setSoTimeout(SO_TIMEOUT);
             success = true;
         } catch (Exception e) {
             throw new ChannelException("failed to initialize a socket", e);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
Patch:
@@ -17,8 +17,6 @@
 
 import io.netty.channel.CombinedChannelHandler;
 
-import io.netty.channel.CombinedChannelHandler;
-
 
 /**
  * A combination of {@link HttpRequestDecoder} and {@link HttpResponseEncoder}

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
Patch:
@@ -17,8 +17,6 @@
 
 import io.netty.channel.CombinedChannelHandler;
 
-import io.netty.channel.CombinedChannelHandler;
-
 
 /**
  * A combination of {@link SpdyFrameDecoder} and {@link SpdyFrameEncoder}.

File: transport/src/main/java/io/netty/channel/ChannelStateHandlerAdapter.java
Patch:
@@ -96,7 +96,7 @@ static <I> void inboundBufferUpdated0(ChannelHandlerContext ctx) {
                 }
                 nextIn.add(msg);
             }
-        } else if (ctx.hasInboundByteBuffer()){
+        } else if (ctx.hasInboundByteBuffer()) {
             ChannelBuffer in = ctx.inboundByteBuffer();
             ChannelBuffer nextIn = ctx.nextInboundByteBuffer();
             nextIn.writeBytes(in);

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1474,7 +1474,9 @@ ChannelFuture write(DefaultChannelHandlerContext ctx, final Object message, fina
                 msgBuf = true;
                 executor = ctx.executor();
                 break;
-            } if (message instanceof ChannelBuffer && ctx.hasOutboundByteBuffer()) {
+            }
+
+            if (message instanceof ChannelBuffer && ctx.hasOutboundByteBuffer()) {
                 executor = ctx.executor();
                 break;
             }

File: transport/src/main/java/io/netty/channel/EventExecutor.java
Patch:
@@ -19,6 +19,7 @@
 
 public interface EventExecutor extends ScheduledExecutorService {
     boolean inEventLoop();
+    boolean inEventLoop(Thread thread);
     Unsafe unsafe();
 
     public interface Unsafe {

File: transport/src/main/java/io/netty/channel/embedded/EmbeddedSocketAddress.java
Patch:
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.handler.codec.embedder;
+package io.netty.channel.embedded;
 
 import java.net.SocketAddress;
 

File: transport/src/main/java/io/netty/channel/ChannelInitializer.java
Patch:
@@ -35,9 +35,7 @@ public final void channelRegistered(ChannelHandlerContext ctx)
             initChannel((C) ctx.channel());
             ctx.pipeline().remove(this);
             removed = true;
-            // Note that we do not call ctx.fireChannelRegistered() because a user might have
-            // inserted a handler before the initializer using pipeline.addFirst().
-            ctx.pipeline().fireChannelRegistered();
+            ctx.fireChannelRegistered();
             success = true;
         } catch (Throwable t) {
             logger.warn("Failed to initialize a channel. Closing: " + ctx.channel(), t);

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -22,6 +22,8 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
 
 import java.net.InetSocketAddress;
 
@@ -55,7 +57,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             //new LoggingHandler(LogLevel.INFO),
+                             new LoggingHandler(LogLevel.INFO),
                              new EchoClientHandler(firstMessageSize));
                  }
              });

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1471,7 +1471,7 @@ ChannelFuture write(DefaultChannelHandlerContext ctx, final Object message, fina
                 msgBuf = true;
                 executor = ctx.executor();
                 break;
-            } else if (message instanceof ChannelBuffer) {
+            } if (message instanceof ChannelBuffer && ctx.hasOutboundByteBuffer()) {
                 executor = ctx.executor();
                 break;
             }

File: transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel;
 
 
-public interface ChannelInboundHandler<T> extends ChannelHandler {
+public interface ChannelInboundHandler<T> extends ChannelStateHandler {
     ChannelBufferHolder<T> newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
-    void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelOperationHandler.java
Patch:
@@ -8,4 +8,5 @@ public interface ChannelOperationHandler extends ChannelHandler {
     void disconnect(ChannelHandlerContext ctx, ChannelFuture future) throws Exception;
     void close(ChannelHandlerContext ctx, ChannelFuture future) throws Exception;
     void deregister(ChannelHandlerContext ctx, ChannelFuture future) throws Exception;
+    void flush(ChannelHandlerContext ctx, ChannelFuture future) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.channel;
 
-public interface ChannelOutboundHandler<T> extends ChannelHandler {
+public interface ChannelOutboundHandler<T> extends ChannelOperationHandler {
     ChannelBufferHolder<T> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
-    void flush(ChannelHandlerContext ctx, ChannelFuture future) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelStateHandler.java
Patch:
@@ -6,4 +6,6 @@ public interface ChannelStateHandler extends ChannelHandler {
 
     void channelActive(ChannelHandlerContext ctx) throws Exception;
     void channelInactive(ChannelHandlerContext ctx) throws Exception;
+
+    void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -1214,7 +1214,7 @@ public void fireInboundBufferUpdated() {
             fireInboundBufferUpdatedOnActivation = true;
             return;
         }
-        DefaultChannelHandlerContext ctx = firstContext(ChannelHandlerType.INBOUND);
+        DefaultChannelHandlerContext ctx = firstContext(ChannelHandlerType.STATE);
         if (ctx != null) {
             fireInboundBufferUpdated(ctx);
         }
@@ -1413,7 +1413,7 @@ public void run() {
 
     @Override
     public ChannelFuture flush(ChannelFuture future) {
-        return flush(firstContext(ChannelHandlerType.OUTBOUND), future);
+        return flush(firstContext(ChannelHandlerType.OPERATION), future);
     }
 
     ChannelFuture flush(final DefaultChannelHandlerContext ctx, final ChannelFuture future) {
@@ -1436,7 +1436,7 @@ public void run() {
     private void flush0(final DefaultChannelHandlerContext ctx, ChannelFuture future) {
         try {
             ctx.flushBridge();
-            ((ChannelOutboundHandler<Object>) ctx.handler()).flush(ctx, future);
+            ((ChannelOperationHandler) ctx.handler()).flush(ctx, future);
         } catch (Throwable t) {
             notifyHandlerException(t);
         } finally {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -77,7 +77,7 @@ public boolean isDecodable(Object msg) throws Exception {
     }
 
     @Override
-    public HttpMessage decode(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exception {
         HttpMessage currentMessage = this.currentMessage;
 
         if (msg instanceof HttpMessage) {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 
@@ -56,7 +56,7 @@ public boolean isDecodable(Object msg) throws Exception {
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().getCode() == 100) {
             // 100-continue response must be passed through.
             return msg;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -166,7 +166,7 @@ protected HttpMessageDecoder(
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer buffer) throws Exception {
         switch (state()) {
         case SKIP_CONTROL_CHARS: {
             try {

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -18,7 +18,7 @@
 import static io.netty.buffer.ChannelBuffers.*;
 import static io.netty.handler.codec.http.HttpConstants.*;
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 import io.netty.handler.codec.http.HttpHeaders.Names;
@@ -61,7 +61,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, ChannelBuffer out) throws Exception {
+    public void encode(ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {
         if (msg instanceof HttpMessage) {
             HttpMessage m = (HttpMessage) msg;
             boolean chunked;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.CombinedChannelHandler;
 
 /**
  * A combination of {@link HttpRequestDecoder} and {@link HttpResponseEncoder}

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.VoidEnum;
@@ -53,7 +53,7 @@ public WebSocket00FrameDecoder(int maxFrameSize) {
     }
 
     @Override
-    public WebSocketFrame decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public WebSocketFrame decode(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         // Discard all data received if closing handshake was received before.
         if (receivedClosingHandshake) {
             in.skipBytes(actualReadableBytes());

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 
 /**
@@ -39,7 +39,7 @@ public boolean isEncodable(Object msg) throws Exception {
 
     @Override
     public void encode(
-            ChannelOutboundHandlerContext<WebSocketFrame> ctx,
+            ChannelHandlerContext ctx,
             WebSocketFrame msg, ChannelBuffer out) throws Exception {
         if (msg instanceof TextWebSocketFrame) {
             // Text frame

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -55,7 +55,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.logging.InternalLogger;
@@ -99,7 +99,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<WebSocketFrame> ctx,
+    public void encode(ChannelHandlerContext ctx,
             WebSocketFrame msg, ChannelBuffer out) throws Exception {
         byte[] mask;
 

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspMessageDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.rtsp;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 import io.netty.handler.codec.http.HttpChunkAggregator;
@@ -75,7 +75,7 @@ protected RtspMessageDecoder(int maxInitialLineLength, int maxHeaderSize, int ma
 
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer buffer) throws Exception {
         Object o = super.decode(ctx, buffer);
         if (o != null && aggregator.offer(o)) {
             return aggregator.poll();

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspMessageEncoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpMessageEncoder;
@@ -39,7 +39,7 @@ protected RtspMessageEncoder() {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg,
+    public void encode(ChannelHandlerContext ctx, Object msg,
             ChannelBuffer out) throws Exception {
         // Ignore unrelated message types such as HttpChunk.
         if (!(msg instanceof HttpMessage)) {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.channel.CombinedChannelHandler;
 
 /**
  * A combination of {@link SpdyFrameDecoder} and {@link SpdyFrameEncoder}.

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.handler.codec.StreamToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -102,7 +101,7 @@ public SpdyFrameDecoder(int version, int maxChunkSize, int maxHeaderSize) {
     }
 
     @Override
-    public Object decodeLast(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decodeLast(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         try {
             return decode(ctx, in);
         } finally {
@@ -111,7 +110,7 @@ public Object decodeLast(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer i
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer buffer) throws Exception {
         switch(state) {
         case READ_COMMON_HEADER:
             state = readCommonHeader(buffer);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 
@@ -92,7 +91,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, ChannelBuffer out) throws Exception {
+    public void encode(ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {
         if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.channel.CombinedChannelHandler;
 
 /**
  * A combination of {@link SpdyHttpDecoder} and {@link SpdyHttpEncoder}

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -15,10 +15,9 @@
  */
 package io.netty.handler.codec.spdy;
 
-import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpRequest;
@@ -67,7 +66,7 @@ public SpdyHttpDecoder(int version, int maxContentLength) {
     }
 
     @Override
-    public HttpMessage decode(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof SpdySynStreamFrame) {
 
             // HTTP requests/responses are mapped one-to-one to SPDY streams.

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -15,8 +15,7 @@
  */
 package io.netty.handler.codec.spdy;
 
-import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageEncoder;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 import io.netty.handler.codec.http.HttpChunk;
@@ -145,7 +144,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public Object encode(ChannelOutboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public Object encode(ChannelHandlerContext ctx, Object msg) throws Exception {
 
         List<Object> out = new ArrayList<Object>();
         if (msg instanceof HttpRequest) {

File: codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 
 /**
  * A decoder that splits the received {@link ChannelBuffer}s by one or more
@@ -187,7 +186,7 @@ public DelimiterBasedFrameDecoder(
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer buffer) throws Exception {
         // Try all delimiters and choose the delimiter which yields the shortest frame.
         int minFrameLength = Integer.MAX_VALUE;
         ChannelBuffer minDelim = null;

File: codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 
 /**
  * A decoder that splits the received {@link ChannelBuffer}s by the fixed number
@@ -66,7 +66,7 @@ public FixedLengthFrameDecoder(int frameLength, boolean allocateFullBuffer) {
 
     @Override
     public ChannelBufferHolder<Byte> newInboundBuffer(
-            ChannelInboundHandlerContext<Byte> ctx) throws Exception {
+            ChannelHandlerContext ctx) throws Exception {
         if (allocateFullBuffer) {
             return ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer(frameLength));
         } else {
@@ -75,7 +75,7 @@ public ChannelBufferHolder<Byte> newInboundBuffer(
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         if (in.readableBytes() < frameLength) {
             return null;
         } else {

File: codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferFactory;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 
 /**
@@ -308,7 +307,7 @@ public LengthFieldBasedFrameDecoder(
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         if (discardingTooLongFrame) {
             long bytesToDiscard = this.bytesToDiscard;
             int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());

File: codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferFactory;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 
 import java.nio.ByteOrder;
 
@@ -103,7 +103,7 @@ public boolean isEncodable(Object msg) throws Exception {
 
     @Override
     public void encode(
-            ChannelOutboundHandlerContext<ChannelBuffer> ctx,
+            ChannelHandlerContext ctx,
             ChannelBuffer msg, ChannelBuffer out) throws Exception {
 
         int length = lengthIncludesLengthFieldLength?

File: codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -65,7 +65,7 @@ public boolean isDecodable(Object msg) throws Exception {
     }
 
     @Override
-    public ChannelBuffer decode(ChannelInboundHandlerContext<ChannelBuffer> ctx, ChannelBuffer msg) throws Exception {
+    public ChannelBuffer decode(ChannelHandlerContext ctx, ChannelBuffer msg) throws Exception {
         return Base64.decode(msg, msg.readerIndex(), msg.readableBytes(), dialect);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -68,7 +68,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public ChannelBuffer encode(ChannelOutboundHandlerContext<ChannelBuffer> ctx,
+    public ChannelBuffer encode(ChannelHandlerContext ctx,
             ChannelBuffer msg) throws Exception {
         return Base64.encode(msg, msg.readerIndex(), msg.readableBytes(), breakLines, dialect);
     }

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
@@ -56,7 +55,7 @@ public boolean isDecodable(Object msg) throws Exception {
     }
 
     @Override
-    public byte[] decode(ChannelInboundHandlerContext<ChannelBuffer> ctx, ChannelBuffer msg) throws Exception {
+    public byte[] decode(ChannelHandlerContext ctx, ChannelBuffer msg) throws Exception {
         byte[] array;
         if (msg.hasArray()) {
             if (msg.arrayOffset() == 0 && msg.readableBytes() == msg.capacity()) {

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
@@ -54,7 +53,7 @@
 public class ByteArrayEncoder extends MessageToMessageEncoder<byte[], ChannelBuffer> {
 
     @Override
-    public ChannelBufferHolder<byte[]> newOutboundBuffer(ChannelOutboundHandlerContext<byte[]> ctx) throws Exception {
+    public ChannelBufferHolder<byte[]> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
         return ChannelBufferHolders.messageBuffer();
     }
 
@@ -64,7 +63,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public ChannelBuffer encode(ChannelOutboundHandlerContext<byte[]> ctx, byte[] msg) throws Exception {
+    public ChannelBuffer encode(ChannelHandlerContext ctx, byte[] msg) throws Exception {
         if (msg.length == 0) {
             return null;
         }

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.StreamToStreamDecoder;
 import io.netty.util.internal.jzlib.JZlib;
 import io.netty.util.internal.jzlib.ZStream;
@@ -88,7 +88,7 @@ public boolean isClosed() {
 
     @Override
     public void decode(
-            ChannelInboundHandlerContext<Byte> ctx,
+            ChannelHandlerContext ctx,
             ChannelBuffer in, ChannelBuffer out) throws Exception {
 
         if (!in.readable()) {

File: codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingEncoder.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 
 import org.jboss.marshalling.Marshaller;
@@ -50,7 +50,7 @@ public CompatibleMarshallingEncoder(MarshallerProvider provider) {
 
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, ChannelBuffer out) throws Exception {
+    public void encode(ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {
         Marshaller marshaller = provider.getMarshaller(ctx);
         marshaller.start(new ChannelBufferByteOutput(out));
         marshaller.writeObject(msg);

File: codec/src/main/java/io/netty/handler/codec/marshalling/MarshallingDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.marshalling;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -60,7 +60,7 @@ public MarshallingDecoder(UnmarshallerProvider provider, int maxObjectSize) {
 
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         ChannelBuffer frame = (ChannelBuffer) super.decode(ctx, in);
         if (frame == null) {
             return null;

File: codec/src/main/java/io/netty/handler/codec/marshalling/MarshallingEncoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 
 import org.jboss.marshalling.Marshaller;
@@ -50,7 +50,7 @@ public MarshallingEncoder(MarshallerProvider provider) {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, ChannelBuffer out) throws Exception {
+    public void encode(ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {
         Marshaller marshaller = provider.getMarshaller(ctx);
         int lengthPos = out.writerIndex();
         out.writeBytes(LENGTH_PLACEHOLDER);

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.buffer.ChannelBufferInputStream;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
@@ -88,7 +87,7 @@ public boolean isDecodable(Object msg) throws Exception {
     }
 
     @Override
-    public MessageLite decode(ChannelInboundHandlerContext<ChannelBuffer> ctx, ChannelBuffer msg) throws Exception {
+    public MessageLite decode(ChannelHandlerContext ctx, ChannelBuffer msg) throws Exception {
         if (msg.hasArray()) {
             final int offset = msg.readerIndex();
             if (extensionRegistry == null) {

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
@@ -66,7 +65,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public ChannelBuffer encode(ChannelOutboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public ChannelBuffer encode(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof MessageLite) {
             return wrappedBuffer(((MessageLite) msg).toByteArray());
         }

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.protobuf;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.StreamToMessageDecoder;
 
@@ -49,7 +49,7 @@ public ProtobufVarint32FrameDecoder() {
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         in.markReaderIndex();
         final byte[] buf = new byte[5];
         for (int i = 0; i < buf.length; i ++) {

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferOutputStream;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 
 import com.google.protobuf.CodedOutputStream;
@@ -53,7 +53,7 @@ public boolean isEncodable(Object msg) throws Exception {
 
     @Override
     public void encode(
-            ChannelOutboundHandlerContext<ChannelBuffer> ctx, ChannelBuffer msg, ChannelBuffer out) throws Exception {
+            ChannelHandlerContext ctx, ChannelBuffer msg, ChannelBuffer out) throws Exception {
         ChannelBuffer body = msg;
         int bodyLen = body.readableBytes();
         int headerLen = CodedOutputStream.computeRawVarint32Size(bodyLen);

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferOutputStream;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
@@ -81,7 +81,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, ChannelBuffer out) throws Exception {
+    public void encode(ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {
         Attribute<ObjectOutputStream> oosAttr = ctx.attr(OOS);
         ObjectOutputStream oos = oosAttr.get();
         if (oos == null) {

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferInputStream;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 
 import java.io.ObjectOutputStream;
@@ -66,7 +66,7 @@ public ObjectDecoder(int maxObjectSize, ClassResolver classResolver) {
     }
 
     @Override
-    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {
         ChannelBuffer frame = (ChannelBuffer) super.decode(ctx, in);
         if (frame == null) {
             return null;

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectEncoder.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferOutputStream;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 
 import java.io.ObjectInputStream;
@@ -45,7 +45,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, ChannelBuffer out) throws Exception {
+    public void encode(ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {
         int startIdx = out.writerIndex();
 
         ChannelBufferOutputStream bout = new ChannelBufferOutputStream(out);

File: codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -81,7 +80,7 @@ public boolean isDecodable(Object msg) throws Exception {
     }
 
     @Override
-    public String decode(ChannelInboundHandlerContext<ChannelBuffer> ctx, ChannelBuffer msg) throws Exception {
+    public String decode(ChannelHandlerContext ctx, ChannelBuffer msg) throws Exception {
         return msg.toString(charset);
     }
 }

File: codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -79,7 +78,7 @@ public boolean isEncodable(Object msg) throws Exception {
     }
 
     @Override
-    public ChannelBuffer encode(ChannelOutboundHandlerContext<String> ctx, String msg) throws Exception {
+    public ChannelBuffer encode(ChannelHandlerContext ctx, String msg) throws Exception {
         return ChannelBuffers.copiedBuffer(msg, charset);
     }
 }

File: codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBufferIndexFinder;
 import io.netty.buffer.ChannelBuffers;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 import io.netty.util.VoidEnum;
 
@@ -54,7 +54,7 @@ private static final class LineDecoder extends ReplayingDecoder<ChannelBuffer, V
         }
 
         @Override
-        public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {
+        public ChannelBuffer decode(ChannelHandlerContext ctx, ChannelBuffer in) {
             ChannelBuffer msg = in.readBytes(in.bytesBefore(ChannelBufferIndexFinder.LF));
             in.skipBytes(1);
             return msg;

File: example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.discard;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundStreamHandlerAdapter;
 
 import java.util.logging.Level;
@@ -32,15 +32,15 @@ public class DiscardServerHandler extends ChannelInboundStreamHandlerAdapter {
 
 
     @Override
-    public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in)
+    public void inboundBufferUpdated(ChannelHandlerContext ctx, ChannelBuffer in)
             throws Exception {
         // Discard the received data silently.
         in.clear();
     }
 
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<Byte> ctx,
+    public void exceptionCaught(ChannelHandlerContext ctx,
             Throwable cause) throws Exception {
         // Close the connection when an exception is raised.
         logger.log(

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -23,8 +23,6 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
 
 import java.net.InetSocketAddress;
 
@@ -51,7 +49,7 @@ public void run() throws Exception {
              .handler(new ChannelInitializer<ServerSocketChannel>() {
                 @Override
                 public void initChannel(ServerSocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));
+                    //ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));
                 }
              })
              .childHandler(new ChannelInitializer<SocketChannel>() {

File: example/src/main/java/io/netty/example/echo/EchoServerHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.echo;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundStreamHandlerAdapter;
 
 import java.util.logging.Level;
@@ -31,15 +31,15 @@ public class EchoServerHandler extends ChannelInboundStreamHandlerAdapter {
             EchoServerHandler.class.getName());
 
     @Override
-    public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {
+    public void inboundBufferUpdated(ChannelHandlerContext ctx, ChannelBuffer in) {
         ChannelBuffer out = ctx.nextOutboundByteBuffer();
         out.discardReadBytes();
         out.writeBytes(in);
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<Byte> ctx, Throwable cause) {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         // Close the connection when an exception is raised.
         logger.log(Level.WARNING, "Unexpected exception from downstream.", cause);
         ctx.close();

File: example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.factorial;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.StreamToMessageDecoder;
 
@@ -31,7 +31,7 @@
 public class BigIntegerDecoder extends StreamToMessageDecoder<BigInteger> {
 
     @Override
-    public BigInteger decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {
+    public BigInteger decode(ChannelHandlerContext ctx, ChannelBuffer in) {
         // Wait until the length prefix is available.
         if (in.readableBytes() < 5) {
             return null;

File: example/src/main/java/io/netty/example/factorial/NumberEncoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.factorial;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.channel.ChannelOutboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
 
 import java.math.BigInteger;
@@ -30,7 +30,7 @@ public class NumberEncoder extends MessageToStreamEncoder<Number> {
 
     @Override
     public void encode(
-            ChannelOutboundHandlerContext<Number> ctx, Number msg, ChannelBuffer out) throws Exception {
+            ChannelHandlerContext ctx, Number msg, ChannelBuffer out) throws Exception {
         // Convert to a BigInteger first for easier implementation.
         BigInteger v;
         if (msg instanceof BigInteger) {

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -24,7 +24,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpResponse;
@@ -103,7 +102,7 @@ public class HttpStaticFileServerHandler extends ChannelInboundMessageHandlerAda
 
     @Override
     public void messageReceived(
-            ChannelInboundHandlerContext<HttpRequest> ctx, HttpRequest request) throws Exception {
+            ChannelHandlerContext ctx, HttpRequest request) throws Exception {
 
         if (request.getMethod() != GET) {
             sendError(ctx, METHOD_NOT_ALLOWED);
@@ -173,7 +172,7 @@ public void messageReceived(
 
     @Override
     public void exceptionCaught(
-            ChannelInboundHandlerContext<HttpRequest> ctx, Throwable cause) throws Exception {
+            ChannelHandlerContext ctx, Throwable cause) throws Exception {
         if (cause instanceof TooLongFrameException) {
             sendError(ctx, BAD_REQUEST);
             return;

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
+import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.http.CookieEncoder;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders;

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
 
 import java.net.InetSocketAddress;
 

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -51,7 +50,7 @@ public class AutobahnServerHandler extends ChannelInboundMessageHandlerAdapter<O
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void messageReceived(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof HttpRequest) {
             handleHttpRequest(ctx, (HttpRequest) msg);
         } else if (msg instanceof WebSocketFrame) {
@@ -121,7 +120,7 @@ private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req,
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<Object> ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -25,7 +25,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -53,7 +52,7 @@ public class WebSocketServerHandler extends ChannelInboundMessageHandlerAdapter<
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void messageReceived(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof HttpRequest) {
             handleHttpRequest(ctx, (HttpRequest) msg);
         } else if (msg instanceof WebSocketFrame) {
@@ -134,7 +133,7 @@ private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req,
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<Object> ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
Patch:
@@ -25,7 +25,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -53,7 +52,7 @@ public class WebSocketSslServerHandler extends ChannelInboundMessageHandlerAdapt
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void messageReceived(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof HttpRequest) {
             handleHttpRequest(ctx, (HttpRequest) msg);
         } else if (msg instanceof WebSocketFrame) {
@@ -134,7 +133,7 @@ private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req,
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<Object> ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java
Patch:
@@ -15,16 +15,16 @@
  */
 package io.netty.example.http.websocketx.sslserver;
 
+import io.netty.logging.InternalLogger;
+import io.netty.logging.InternalLoggerFactory;
+
 import java.io.FileInputStream;
 import java.security.KeyStore;
 import java.security.Security;
 
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 
-import io.netty.logging.InternalLogger;
-import io.netty.logging.InternalLoggerFactory;
-
 /**
  * Creates a {@link SSLContext} for just server certificates.
  */

File: example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java
Patch:
@@ -15,19 +15,19 @@
  */
 package io.netty.example.localecho;
 
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 
 public class LocalEchoClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
 
     @Override
-    public void messageReceived(ChannelInboundHandlerContext<String> ctx, String msg) {
+    public void messageReceived(ChannelHandlerContext ctx, String msg) {
         // Print as received
         System.out.println(msg);
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<String> ctx, Throwable cause) {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
Patch:
@@ -15,19 +15,19 @@
  */
 package io.netty.example.localecho;
 
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 
 public class LocalEchoServerHandler extends ChannelInboundMessageHandlerAdapter<String> {
 
     @Override
-    public void messageReceived(ChannelInboundHandlerContext<String> ctx, String msg) {
+    public void messageReceived(ChannelHandlerContext ctx, String msg) {
         // Write back as received
         ctx.write(msg);
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<String> ctx, Throwable cause) {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }

File: example/src/main/java/io/netty/example/localtime/LocalTimeServerHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.localtime;
 
 import static java.util.Calendar.*;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.example.localtime.LocalTimeProtocol.Continent;
 import io.netty.example.localtime.LocalTimeProtocol.DayOfWeek;
@@ -36,7 +36,7 @@ public class LocalTimeServerHandler extends ChannelInboundMessageHandlerAdapter<
             LocalTimeServerHandler.class.getName());
 
     @Override
-    public void messageReceived(ChannelInboundHandlerContext<Locations> ctx, Locations locations) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, Locations locations) throws Exception {
         long currentTime = System.currentTimeMillis();
 
         LocalTimes.Builder builder = LocalTimes.newBuilder();
@@ -60,7 +60,7 @@ public void messageReceived(ChannelInboundHandlerContext<Locations> ctx, Locatio
     }
 
     @Override
-    public void exceptionCaught(ChannelInboundHandlerContext<Locations> ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.", cause);

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.objectecho;
 
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 
 import java.util.List;
@@ -33,14 +33,14 @@ public class ObjectEchoServerHandler extends ChannelInboundMessageHandlerAdapter
 
     @Override
     public void messageReceived(
-            ChannelInboundHandlerContext<List<Integer>> ctx, List<Integer> msg) throws Exception {
+            ChannelHandlerContext ctx, List<Integer> msg) throws Exception {
         // Echo back the received object to the client.
         ctx.write(msg);
     }
 
     @Override
     public void exceptionCaught(
-            ChannelInboundHandlerContext<List<Integer>> ctx, Throwable cause) throws Exception {
+            ChannelHandlerContext ctx, Throwable cause) throws Exception {
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.", cause);

File: example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerContext;
 import io.netty.channel.ChannelInboundStreamHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
 import io.netty.example.factorial.BigIntegerDecoder;
@@ -54,8 +53,8 @@ private PortUnificationServerHandler(boolean detectSsl, boolean detectGzip) {
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx) throws Exception {
-        ChannelBuffer buffer = ctx.inbound().byteBuffer();
+    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
+        ChannelBuffer buffer = ctx.inboundByteBuffer();
 
         // Will use the first two bytes to detect a protocol.
         if (buffer.readableBytes() < 2) {

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.qotm;
 
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.util.CharsetUtil;
@@ -25,7 +25,7 @@ public class QuoteOfTheMomentClientHandler extends ChannelInboundMessageHandlerA
 
     @Override
     public void messageReceived(
-            ChannelInboundHandlerContext<DatagramPacket> ctx, DatagramPacket msg)
+            ChannelHandlerContext ctx, DatagramPacket msg)
             throws Exception {
         String response = msg.data().toString(CharsetUtil.UTF_8);
         if (response.startsWith("QOTM: ")) {
@@ -36,7 +36,7 @@ public void messageReceived(
 
     @Override
     public void exceptionCaught(
-            ChannelInboundHandlerContext<DatagramPacket> ctx, Throwable cause)
+            ChannelHandlerContext ctx, Throwable cause)
             throws Exception {
         cause.printStackTrace();
         ctx.close();

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.example.qotm;
 
 import io.netty.buffer.ChannelBuffers;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.util.CharsetUtil;
@@ -45,7 +45,7 @@ private static String nextQuote() {
 
     @Override
     public void messageReceived(
-            ChannelInboundHandlerContext<DatagramPacket> ctx, DatagramPacket msg)
+            ChannelHandlerContext ctx, DatagramPacket msg)
             throws Exception {
         if (msg.data().toString(CharsetUtil.UTF_8).equals("QOTM?")) {
             ctx.write(new DatagramPacket(
@@ -56,7 +56,7 @@ public void messageReceived(
 
     @Override
     public void exceptionCaught(
-            ChannelInboundHandlerContext<DatagramPacket> ctx, Throwable cause)
+            ChannelHandlerContext ctx, Throwable cause)
             throws Exception {
         cause.printStackTrace();
         // We don't close the channel because we can keep serving requests.

File: example/src/main/java/io/netty/example/securechat/SecureChatSslContextFactory.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.netty.example.securechat;
 
+import io.netty.handler.ssl.SslHandler;
+
 import java.security.KeyStore;
 import java.security.Security;
 
@@ -24,8 +26,6 @@
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.TrustManager;
 
-import io.netty.handler.ssl.SslHandler;
-
 /**
  * Creates a bogus {@link SSLContext}.  A client-side context created by this
  * factory accepts any certificate even if it is invalid.  A server-side context

File: handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java
Patch:
@@ -16,12 +16,11 @@
 package io.netty.handler.stream;
 
 import static io.netty.buffer.ChannelBuffers.*;
+import io.netty.buffer.ChannelBuffer;
 
 import java.nio.ByteBuffer;
 import java.nio.channels.ReadableByteChannel;
 
-import io.netty.buffer.ChannelBuffer;
-
 /**
  * A {@link ChunkedInput} that fetches data from a {@link ReadableByteChannel}
  * chunk by chunk.  Please note that the {@link ReadableByteChannel} must

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -22,7 +22,6 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
-import io.netty.channel.ChannelOutboundHandlerContext;
 import io.netty.channel.ChannelPipeline;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timer;
@@ -105,12 +104,12 @@ public WriteTimeoutHandler(long timeout, TimeUnit unit) {
     }
 
     @Override
-    public ChannelBufferHolder<Object> newOutboundBuffer(ChannelOutboundHandlerContext<Object> ctx) throws Exception {
+    public ChannelBufferHolder<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
         return ChannelBufferHolders.outboundBypassBuffer(ctx);
     }
 
     @Override
-    public void flush(final ChannelOutboundHandlerContext<Object> ctx, final ChannelFuture future) throws Exception {
+    public void flush(final ChannelHandlerContext ctx, final ChannelFuture future) throws Exception {
         if (timeoutMillis > 0) {
             // Schedule a timeout.
             final ScheduledFuture<?> sf = ctx.executor().schedule(new Runnable() {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.socket.DatagramChannel;
@@ -46,7 +46,7 @@ public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {
         sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
             @Override
             public void messageReceived(
-                    ChannelInboundHandlerContext<DatagramPacket> ctx,
+                    ChannelHandlerContext ctx,
                     DatagramPacket msg) throws Exception {
                 // Nothing will be sent.
             }
@@ -94,7 +94,7 @@ private final class MulticastTestHandler extends ChannelInboundMessageHandlerAda
 
         @Override
         public void messageReceived(
-                ChannelInboundHandlerContext<DatagramPacket> ctx,
+                ChannelHandlerContext ctx,
                 DatagramPacket msg) throws Exception {
             if (done) {
                 fail = true;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.socket.DatagramPacket;
 
@@ -42,7 +42,7 @@ public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {
         sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
             @Override
             public void messageReceived(
-                    ChannelInboundHandlerContext<DatagramPacket> ctx,
+                    ChannelHandlerContext ctx,
                     DatagramPacket msg) throws Exception {
                 Assert.assertEquals(1, msg.data().readInt());
                 latch.countDown();
@@ -52,7 +52,7 @@ public void messageReceived(
         cb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
             @Override
             public void messageReceived(
-                    ChannelInboundHandlerContext<DatagramPacket> ctx,
+                    ChannelHandlerContext ctx,
                     DatagramPacket msg) throws Exception {
                 // Nothing will be sent.
             }

File: testsuite/src/test/java/io/netty/testsuite/util/DummyHandler.java
Patch:
@@ -15,10 +15,7 @@
  */
 package io.netty.testsuite.util;
 
-import io.netty.channel.ChannelDownstreamHandler;
-import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelUpstreamHandler;
 
 public class DummyHandler implements ChannelUpstreamHandler, ChannelDownstreamHandler {
 

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -141,7 +141,7 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
     boolean isActive();
 
     ChannelBuffer outboundByteBuffer();
-    Queue<Object> outboundMessageBuffer();
+    <T> Queue<T> outboundMessageBuffer();
 
     /**
      * Returns the local address where this channel is bound to.  The returned
@@ -179,7 +179,7 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
     Unsafe unsafe();
 
     public interface Unsafe {
-        ChannelBufferHolder<Object> directOutbound();
+        ChannelHandlerContext directOutboundContext();
         ChannelFuture voidFuture();
 
         SocketAddress localAddress();

File: transport/src/main/java/io/netty/channel/group/ChannelGroup.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.netty.channel.group;
 
+import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;

File: transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.channel.socket;
 
-import java.net.ServerSocket;
-
 import io.netty.channel.ChannelConfig;
 
+import java.net.ServerSocket;
+
 /**
  * A {@link ChannelConfig} for a {@link ServerSocketChannel}.
  *

File: transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
Patch:
@@ -55,13 +55,13 @@ private static ChannelHandler newHandler() {
     private static class TestHandler extends ChannelHandlerAdapter<Byte, Byte> {
         @Override
         public ChannelBufferHolder<Byte> newInboundBuffer(
-                ChannelInboundHandlerContext<Byte> ctx) throws Exception {
+                ChannelHandlerContext ctx) throws Exception {
             return ChannelBufferHolders.byteBuffer();
         }
 
         @Override
         public ChannelBufferHolder<Byte> newOutboundBuffer(
-                ChannelOutboundHandlerContext<Byte> ctx) throws Exception {
+                ChannelHandlerContext ctx) throws Exception {
             return ChannelBufferHolders.byteBuffer();
         }
     };

File: transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelInboundHandlerContext;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.logging.InternalLogger;
@@ -85,7 +85,7 @@ public void initChannel(LocalChannel ch) throws Exception {
 
     static class TestHandler extends ChannelInboundMessageHandlerAdapter<String> {
         @Override
-        public void messageReceived(ChannelInboundHandlerContext<String> ctx, String msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
             logger.info(String.format("Received mesage: %s", msg));
         }
     }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java
Patch:
@@ -20,5 +20,5 @@ public final class SpdyConstants {
     public static final int SPDY_MIN_VERSION = 2;
     public static final int SPDY_MAX_VERSION = 3;
 
-    private SpdyConstants() {}
+    private SpdyConstants() { }
 }

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
Patch:
@@ -56,7 +56,7 @@ public void channelActive(ChannelInboundHandlerContext<List<Integer>> ctx) throw
     }
 
     @Override
-    public void messageReceived( ChannelInboundHandlerContext<List<Integer>> ctx, List<Integer> msg) throws Exception {
+    public void messageReceived(ChannelInboundHandlerContext<List<Integer>> ctx, List<Integer> msg) throws Exception {
         // Echo back the received object to the client.
         ctx.write(msg);
     }

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
Patch:
@@ -53,4 +53,4 @@ public void exceptionCaught(ChannelInboundHandlerContext<Byte> ctx, Throwable ca
         cause.printStackTrace();
         HexDumpProxyFrontendHandler.closeOnFlush(ctx.channel());
     }
-}
\ No newline at end of file
+}

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -60,7 +60,7 @@ public class LoggingHandler extends ChannelHandlerAdapter<Object, Object> {
             buf.append(i);
             BYTE2HEX[i] = buf.toString();
         }
-        for (;i < 16; i ++) {
+        for (; i < 16; i ++) {
             StringBuilder buf = new StringBuilder(3);
             buf.append(" 0");
             buf.append((char) ('a' + i - 10));

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -466,7 +466,7 @@ public void encode(ChannelOutboundHandlerContext<Byte> ctx, ChannelBuffer in, Ch
         try {
             ByteBuffer outAppBuf = in.nioBuffer();
 
-            while(in.readable()) {
+            while (in.readable()) {
 
                 int read;
                 int remaining = outAppBuf.remaining();

File: handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java
Patch:
@@ -19,11 +19,11 @@
  * A {@link TimeoutException} raised by {@link ReadTimeoutHandler} when no data
  * was read within a certain period of time.
  */
-public class ReadTimeoutException extends TimeoutException {
+public final class ReadTimeoutException extends TimeoutException {
 
     private static final long serialVersionUID = 169287984113283421L;
 
     public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();
 
-    private ReadTimeoutException() {}
+    private ReadTimeoutException() { }
 }

File: handler/src/main/java/io/netty/handler/timeout/TimeoutException.java
Patch:
@@ -25,7 +25,7 @@ public class TimeoutException extends ChannelException {
 
     private static final long serialVersionUID = 4673641882869672533L;
 
-    TimeoutException() {}
+    TimeoutException() { }
 
     @Override
     public Throwable fillInStackTrace() {

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutException.java
Patch:
@@ -19,11 +19,11 @@
  * A {@link TimeoutException} raised by {@link WriteTimeoutHandler} when no data
  * was written within a certain period of time.
  */
-public class WriteTimeoutException extends TimeoutException {
+public final class WriteTimeoutException extends TimeoutException {
 
     private static final long serialVersionUID = -144786655770296065L;
 
     public static final WriteTimeoutException INSTANCE = new WriteTimeoutException();
 
-    private WriteTimeoutException() {}
+    private WriteTimeoutException() { }
 }

File: transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
Patch:
@@ -59,7 +59,7 @@ public void initChannel(LocalChannel ch) throws Exception {
 
 
             // Start server
-            sb.bind().sync();
+            Channel sc = sb.bind().sync().channel();
 
             // Connect to the server
             Channel cc = cb.connect().sync().channel();
@@ -74,6 +74,8 @@ public void initChannel(LocalChannel ch) throws Exception {
             sb.shutdown();
             cb.shutdown();
 
+            sc.closeFuture().sync();
+
             Assert.assertTrue(String.format(
                     "Expected null, got channel '%s' for local address '%s'",
                     LocalChannelRegistry.get(addr), addr),

File: transport/src/main/java/io/netty/channel/DefaultEventExecutor.java
Patch:
@@ -20,7 +20,7 @@
 public class DefaultEventExecutor extends MultithreadEventExecutor {
 
     public DefaultEventExecutor(int nThreads) {
-        super(nThreads);
+        this(nThreads, null);
     }
 
     public DefaultEventExecutor(int nThreads, ThreadFactory threadFactory) {

File: example/src/main/java/io/netty/example/securechat/SecureChatServer.java
Patch:
@@ -31,7 +31,7 @@ public SecureChatServer(int port) {
         this.port = port;
     }
 
-    public void run() {
+    public void run() throws InterruptedException {
         ServerBootstrap b = new ServerBootstrap();
         try {
             b.eventLoop(new NioEventLoop(), new NioEventLoop())

File: handler/src/main/java/io/netty/handler/queue/BlockingReadHandler.java
Patch:
@@ -100,7 +100,7 @@ public BlockingReadHandler(BlockingQueue<Object> queue) {
     public ChannelBufferHolder<Object> newInboundBuffer(
             ChannelInboundHandlerContext<Object> ctx) throws Exception {
         this.ctx = ctx;
-        return ChannelBufferHolders.catchAllBuffer();
+        return ChannelBufferHolders.messageBuffer(queue);
     }
 
     /**

File: buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java
Patch:
@@ -195,7 +195,7 @@ public String readLine() throws IOException {
             lineBuf.append((char) b);
         }
 
-        if (lineBuf.length() > 0 ) {
+        if (lineBuf.length() > 0) {
             while (lineBuf.charAt(lineBuf.length() - 1) == '\r') {
                 lineBuf.setLength(lineBuf.length() - 1);
             }

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -746,7 +746,7 @@ private void notifyFlushFutures(Throwable cause) {
         }
     }
 
-    static abstract class FlushCheckpoint {
+    abstract static class FlushCheckpoint {
         abstract long flushCheckpoint();
         abstract void flushCheckpoint(long checkpoint);
         abstract ChannelFuture future();

File: transport/src/main/java/io/netty/channel/BlockingOperationException.java
Patch:
@@ -25,7 +25,7 @@ public class BlockingOperationException extends IllegalStateException {
 
     private static final long serialVersionUID = 2462223247762460301L;
 
-    public BlockingOperationException() {}
+    public BlockingOperationException() { }
 
     public BlockingOperationException(String s) {
         super(s);

File: transport/src/main/java/io/netty/channel/CombinedChannelHandler.java
Patch:
@@ -178,4 +178,4 @@ public void flush(
             ChannelOutboundHandlerContext<Object> ctx, ChannelFuture future) throws Exception {
         out.flush(ctx, future);
     }
-}
\ No newline at end of file
+}

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -588,4 +588,4 @@ void flush(ChannelBuffer out) {
             }
         }
     }
-}
\ No newline at end of file
+}

File: transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java
Patch:
@@ -503,7 +503,7 @@ private class ScheduledFutureTask<V> extends FutureTask<V> implements ScheduledF
 
         private final long id = nextTaskId.getAndIncrement();
         private long deadlineNanos;
-        /** 0 - no repeat, >0 - repeat at fixed rate, <0 - repeat with fixed delay */
+        /* 0 - no repeat, >0 - repeat at fixed rate, <0 - repeat with fixed delay */
         private final long periodNanos;
 
         ScheduledFutureTask(Runnable runnable, V result, long nanoTime) {

File: transport/src/main/java/io/netty/channel/local/LocalEventLoop.java
Patch:
@@ -22,7 +22,7 @@
 
 public class LocalEventLoop extends MultithreadEventLoop {
 
-    public LocalEventLoop() {}
+    public LocalEventLoop() { }
 
     public LocalEventLoop(int nThreads) {
         super(nThreads);

File: transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java
Patch:
@@ -23,7 +23,7 @@
 
 public class NioEventLoop extends MultithreadEventLoop {
 
-    public NioEventLoop() {}
+    public NioEventLoop() { }
 
     public NioEventLoop(int nThreads) {
         super(nThreads);

File: transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.util.Queue;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -247,7 +248,7 @@ private static class SingleThreadEventLoopImpl extends SingleThreadEventLoop {
         final AtomicInteger cleanedUp = new AtomicInteger();
 
         SingleThreadEventLoopImpl() {
-            super(null);
+            super(Executors.defaultThreadFactory());
         }
 
         @Override

File: codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java
Patch:
@@ -76,8 +76,9 @@ protected SocketAddress remoteAddress0() {
     }
 
     @Override
-    protected void doRegister() throws Exception {
+    protected Runnable doRegister() throws Exception {
         state = 1;
+        return null;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -179,7 +179,9 @@ protected void doClose() throws Exception {
             return;
         }
 
-        LocalChannelRegistry.unregister(localAddress);
+        if (parent() == null) {
+            LocalChannelRegistry.unregister(localAddress);
+        }
         localAddress = null;
         state = 3;
         if (peer.isActive()) {

File: transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
Patch:
@@ -357,7 +357,7 @@ public ChannelFuture flush(ChannelFuture future) {
 
     @Override
     public ChannelFuture write(Object message, ChannelFuture future) {
-        return pipeline.write(DefaultChannelPipeline.nextOutboundContext(prev), message, future);
+        return pipeline.write(prev, message, future);
     }
 
     @Override

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.testsuite.util.TestUtils;
 import io.netty.util.SocketAddresses;
 
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -61,6 +62,8 @@ protected void run() throws Exception {
                 Method m = getClass().getDeclaredMethod(
                         testName.getMethodName(), ServerBootstrap.class, Bootstrap.class);
                 m.invoke(this, sb, cb);
+            } catch (InvocationTargetException ex) {
+                throw ex.getCause();
             } finally {
                 sb.shutdown();
                 cb.shutdown();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
Patch:
@@ -2,6 +2,7 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.channel.socket.nio.NioDatagramChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -94,7 +95,8 @@ static List<Entry<Factory<Bootstrap>, Factory<Bootstrap>>> datagram() {
         bfs.add(new Factory<Bootstrap>() {
             @Override
             public Bootstrap newInstance() {
-                return new Bootstrap().eventLoop(new NioEventLoop()).channel(new NioDatagramChannel());
+                return new Bootstrap().eventLoop(new NioEventLoop()).channel(
+                        new NioDatagramChannel(InternetProtocolFamily.IPv4));
             }
         });
         bfs.add(new Factory<Bootstrap>() {

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -113,7 +113,6 @@ public Set<Cookie> decode(String header) {
             }
 
             Cookie c = new DefaultCookie(name, value);
-            cookies.add(c);
 
             boolean discard = false;
             boolean secure = false;
@@ -189,6 +188,8 @@ public Set<Cookie> decode(String header) {
                 c.setPorts(ports);
                 c.setDiscard(discard);
             }
+
+            cookies.add(c);
         }
 
         return cookies;

File: codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
Patch:
@@ -233,6 +233,7 @@ public void testDecodingCommaSeparatedClientSideCookies() {
         Iterator<Cookie> it = cookies.iterator();
         Cookie c;
 
+        assertTrue(it.hasNext());
         c = it.next();
         assertEquals(1, c.getVersion());
         assertEquals("session_id", c.getName());
@@ -244,6 +245,7 @@ public void testDecodingCommaSeparatedClientSideCookies() {
         assertTrue(c.getPorts().isEmpty());
         assertEquals(-1, c.getMaxAge());
 
+        assertTrue(it.hasNext());
         c = it.next();
         assertEquals(1, c.getVersion());
         assertEquals("session_id", c.getName());

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -113,6 +113,8 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelFu
      */
     Integer id();
 
+    ChannelType type();
+
     EventLoop eventLoop();
 
     /**

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -42,7 +42,8 @@ private static ServerSocketChannel newSocket() {
     private final ServerSocketChannelConfig config;
 
     public NioServerSocketChannel() {
-        super(null, null, ChannelBufferHolders.discardBuffer(), newSocket(), SelectionKey.OP_ACCEPT);
+        super(null, null, ChannelBufferHolders.discardMessageBuffer(),
+                newSocket(), SelectionKey.OP_ACCEPT);
         config = new DefaultServerSocketChannelConfig(javaChannel().socket());
     }
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -60,7 +60,7 @@ public OioServerSocketChannel(ServerSocket socket) {
     }
 
     public OioServerSocketChannel(Integer id, ServerSocket socket) {
-        super(null, id, ChannelBufferHolders.discardBuffer());
+        super(null, id, ChannelBufferHolders.discardMessageBuffer());
         if (socket == null) {
             throw new NullPointerException("socket");
         }

File: handler/src/main/java/io/netty/handler/ssl/SslBufferPool.java
Patch:
@@ -17,6 +17,8 @@
 
 import java.nio.ByteBuffer;
 
+import javax.net.ssl.SSLEngine;
+
 /**
  * A {@link ByteBuffer} pool dedicated for {@link SslHandler} performance
  * improvement.

File: codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
Patch:
@@ -121,10 +121,7 @@ public void testTooBigObject() throws IOException {
             fail();
         } catch (CodecException e) {
             assertEquals(TooLongFrameException.class, e.getClass());
-
-
         }
-
     }
 
     protected ChannelHandler createDecoder(int maxObjectSize) {

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -4,8 +4,6 @@
 
 public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
 
-    protected SingleThreadEventLoop() {}
-
     protected SingleThreadEventLoop(ThreadFactory threadFactory) {
         super(threadFactory);
     }

File: common/src/main/java/io/netty/util/internal/DetectionUtil.java
Patch:
@@ -68,7 +68,7 @@ private static boolean hasUnsafe(ClassLoader loader) {
         if (value == null) {
             value = SystemPropertyUtil.get("org.jboss.netty.tryUnsafe", "true");
         }
-        if ("true".equalsIgnoreCase(value)) {
+        if (!"true".equalsIgnoreCase(value)) {
             return false;
         }
 

File: codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java
Patch:
@@ -169,7 +169,7 @@ private static ChannelBuffer createFrames(int version) {
     protected abstract ServerBootstrap newServerBootstrap();
     protected abstract Bootstrap newClientBootstrap();
 
-    @Test
+    @Test(timeout = 10000)
     public void testSpdyEcho() throws Throwable {
         for (int version = SPDY_MIN_VERSION; version <= SPDY_MAX_VERSION; version ++) {
             sb = newServerBootstrap();

File: codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java
Patch:
@@ -100,7 +100,7 @@ protected void callDecode(ChannelInboundHandlerContext<Byte> ctx) {
      * inbound buffer.
      */
     public void replace(String newHandlerName, ChannelInboundHandler<Byte> newHandler) {
-        if (!ctx.eventLoop().inEventLoop()) {
+        if (!ctx.executor().inEventLoop()) {
             throw new IllegalStateException("not in event loop");
         }
 

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
Patch:
@@ -21,7 +21,7 @@ public void channelActive(ChannelInboundHandlerContext<Byte> ctx) throws Excepti
     @Override
     public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx) throws Exception {
         ChannelBuffer in = ctx.inbound().byteBuffer();
-        ChannelBuffer out = inboundChannel.outbound().byteBuffer();
+        ChannelBuffer out = inboundChannel.outboundByteBuffer();
         out.discardReadBytes();
         out.writeBytes(in);
         in.clear();

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
Patch:
@@ -46,7 +46,7 @@ public void channelActive(ChannelInboundHandlerContext<Byte> ctx) throws Excepti
 
         // Start the connection attempt.
         Bootstrap b = new Bootstrap();
-        b.eventLoop(ctx.eventLoop())
+        b.eventLoop(inboundChannel.eventLoop())
          .channel(new NioSocketChannel())
          .remoteAddress(remoteHost, remotePort)
          .initializer(new ChannelInitializer<SocketChannel>() {
@@ -75,7 +75,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     @Override
     public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx) throws Exception {
         ChannelBuffer in = ctx.inbound().byteBuffer();
-        ChannelBuffer out = outboundChannel.outbound().byteBuffer();
+        ChannelBuffer out = outboundChannel.outboundByteBuffer();
         out.discardReadBytes();
         out.writeBytes(in);
         in.clear();

File: example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
Patch:
@@ -79,7 +79,7 @@ public void channelUnregistered(final ChannelInboundHandlerContext<Byte> ctx)
             throws Exception {
         println("Sleeping for: " + UptimeClient.RECONNECT_DELAY + "s");
 
-        final EventLoop loop = ctx.eventLoop();
+        final EventLoop loop = ctx.channel().eventLoop();
         loop.schedule(new Runnable() {
             @Override
             public void run() {

File: handler/src/main/java/io/netty/handler/queue/BlockingReadHandler.java
Patch:
@@ -187,7 +187,7 @@ private Object readEvent(long timeout, TimeUnit unit) throws InterruptedExceptio
     }
 
     private void detectDeadLock() {
-        if (ctx.eventLoop().inEventLoop()) {
+        if (ctx.executor().inEventLoop()) {
             throw new BlockingOperationException();
         }
     }

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -113,7 +113,7 @@ public ChannelBufferHolder<Object> newOutboundBuffer(ChannelOutboundHandlerConte
     public void flush(final ChannelOutboundHandlerContext<Object> ctx, final ChannelFuture future) throws Exception {
         if (timeoutMillis > 0) {
             // Schedule a timeout.
-            final ScheduledFuture<?> sf = ctx.eventLoop().schedule(new Runnable() {
+            final ScheduledFuture<?> sf = ctx.executor().schedule(new Runnable() {
                 @Override
                 public void run() {
                     if (future.setFailure(WriteTimeoutException.INSTANCE)) {

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -129,7 +129,7 @@ public interface ChannelHandlerContext
                  ChannelInboundInvoker, ChannelOutboundInvoker {
     Channel channel();
     ChannelPipeline pipeline();
-    EventLoop eventLoop();
+    EventExecutor executor();
 
     String name();
     ChannelHandler handler();

File: transport/src/main/java/io/netty/channel/local/LocalChannel.java
Patch:
@@ -186,7 +186,7 @@ protected void doFlush(ChannelBufferHolder<Object> buf) throws Exception {
         assert peer != null;
 
         Queue<Object> in = buf.messageBuffer();
-        Queue<Object> out = peer.pipeline().inbound().messageBuffer();
+        Queue<Object> out = peer.pipeline().inboundMessageBuffer();
         for (;;) {
             Object msg = in.poll();
             if (msg == null) {

File: transport/src/main/java/io/netty/channel/local/LocalChildEventLoop.java
Patch:
@@ -15,14 +15,15 @@
  */
 package io.netty.channel.local;
 
+import io.netty.channel.EventLoop;
 import io.netty.channel.SingleThreadEventLoop;
 
 import java.util.concurrent.ThreadFactory;
 
 final class LocalChildEventLoop extends SingleThreadEventLoop {
 
-    LocalChildEventLoop(ThreadFactory threadFactory) {
-        super(threadFactory);
+    LocalChildEventLoop(EventLoop parent, ThreadFactory threadFactory) {
+        super(parent, threadFactory);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
Patch:
@@ -119,7 +119,7 @@ LocalChannel serve(final LocalChannel peer) {
 
     private void serve0(final LocalChannel child) {
         if (eventLoop().inEventLoop()) {
-            pipeline().inbound().messageBuffer().add(child);
+            pipeline().inboundMessageBuffer().add(child);
             pipeline().fireInboundBufferUpdated();
         } else {
             eventLoop().execute(new Runnable() {

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java
Patch:
@@ -27,11 +27,10 @@ public void read() {
             assert eventLoop().inEventLoop();
 
             final ChannelPipeline pipeline = pipeline();
-            final ChannelBufferHolder<Object> buf = pipeline.inbound();
+            final Queue<Object> msgBuf = pipeline.inboundMessageBuffer();
             boolean closed = false;
             boolean read = false;
             try {
-                Queue<Object> msgBuf = buf.messageBuffer();
                 for (;;) {
                     int localReadAmount = doReadMessages(msgBuf);
                     if (localReadAmount > 0) {

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioStreamChannel.java
Patch:
@@ -28,11 +28,10 @@ public void read() {
             assert eventLoop().inEventLoop();
 
             final ChannelPipeline pipeline = pipeline();
-            final ChannelBufferHolder<Object> buf = pipeline.inbound();
+            final ChannelBuffer byteBuf = pipeline.inboundByteBuffer();
             boolean closed = false;
             boolean read = false;
             try {
-                ChannelBuffer byteBuf = buf.byteBuffer();
                 expandReadBuffer(byteBuf);
                 for (;;) {
                     int localReadAmount = doReadBytes(byteBuf);

File: transport/src/main/java/io/netty/channel/socket/nio/NioChildEventLoop.java
Patch:
@@ -60,8 +60,8 @@ final class NioChildEventLoop extends SingleThreadEventLoop {
     private int cancelledKeys;
     private boolean cleanedCancelledKeys;
 
-    NioChildEventLoop(ThreadFactory threadFactory, SelectorProvider selectorProvider) {
-        super(threadFactory);
+    NioChildEventLoop(NioEventLoop parent, ThreadFactory threadFactory, SelectorProvider selectorProvider) {
+        super(parent, threadFactory);
         if (selectorProvider == null) {
             throw new NullPointerException("selectorProvider");
         }

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java
Patch:
@@ -25,11 +25,10 @@ public void read() {
             assert eventLoop().inEventLoop();
 
             final ChannelPipeline pipeline = pipeline();
-            final ChannelBufferHolder<Object> buf = pipeline.inbound();
+            final Queue<Object> msgBuf = pipeline.inboundMessageBuffer();
             boolean closed = false;
             boolean read = false;
             try {
-                Queue<Object> msgBuf = buf.messageBuffer();
                 int localReadAmount = doReadMessages(msgBuf);
                 if (localReadAmount > 0) {
                     read = true;

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioStreamChannel.java
Patch:
@@ -25,11 +25,10 @@ public void read() {
             assert eventLoop().inEventLoop();
 
             final ChannelPipeline pipeline = pipeline();
-            final ChannelBufferHolder<Object> buf = pipeline.inbound();
+            final ChannelBuffer byteBuf = pipeline.inboundByteBuffer();
             boolean closed = false;
             boolean read = false;
             try {
-                ChannelBuffer byteBuf = buf.byteBuffer();
                 expandReadBuffer(byteBuf);
                 int localReadAmount = doReadBytes(byteBuf);
                 if (localReadAmount > 0) {

File: transport/src/main/java/io/netty/channel/socket/oio/OioChildEventLoop.java
Patch:
@@ -8,12 +8,10 @@
 
 class OioChildEventLoop extends SingleThreadEventLoop {
 
-    private final OioEventLoop parent;
     private AbstractOioChannel ch;
 
     OioChildEventLoop(OioEventLoop parent) {
-        super(parent.threadFactory);
-        this.parent = parent;
+        super(parent, parent.threadFactory);
     }
 
     @Override
@@ -71,6 +69,7 @@ protected void wakeup(boolean inEventLoop) {
 
     private void deregister() {
         ch = null;
+        OioEventLoop parent = (OioEventLoop) parent();
         parent.activeChildren.remove(this);
         parent.idleChildren.add(this);
     }

File: transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
Patch:
@@ -70,7 +70,7 @@ public void initChannel(LocalChannel ch) throws Exception {
             Channel cc = cb.connect().sync().channel();
 
             // Send a message event up the pipeline.
-            cc.pipeline().inbound().messageBuffer().add("Hello, World");
+            cc.pipeline().inboundMessageBuffer().add("Hello, World");
             cc.pipeline().fireInboundBufferUpdated();
 
             // Close the channel

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -626,6 +626,9 @@ public final void flushNow() {
                     cause = t;
                 } finally {
                     writeCounter += oldSize - out.size();
+                    if (out.isEmpty() && out.hasByteBuffer()) {
+                        out.byteBuffer().discardReadBytes();
+                    }
                 }
 
                 if (cause == null) {

File: transport/src/main/java/io/netty/channel/DefaultChannelFuture.java
Patch:
@@ -323,7 +323,7 @@ private boolean await0(long timeoutNanos, boolean interruptable) throws Interrup
     }
 
     private void checkDeadLock() {
-        if (channel().eventLoop().inEventLoop()) {
+        if (channel().isRegistered() && channel().eventLoop().inEventLoop()) {
             throw new BlockingOperationException();
         }
     }

File: codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java
Patch:
@@ -36,8 +36,7 @@
 public class ContextBoundUnmarshallerProvider extends DefaultUnmarshallerProvider {
 
     private static final AttributeKey<Unmarshaller> UNMARSHALLER = new AttributeKey<Unmarshaller>(
-            ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller",
-            Unmarshaller.class);
+            ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");
 
     public ContextBoundUnmarshallerProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         super(factory, config);

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -37,8 +37,7 @@
 public class CompatibleObjectEncoder extends MessageToStreamEncoder<Object> {
 
     private static final AttributeKey<ObjectOutputStream> OOS =
-            new AttributeKey<ObjectOutputStream>(
-                    CompatibleObjectEncoder.class.getName() + ".oos", ObjectOutputStream.class);
+            new AttributeKey<ObjectOutputStream>(CompatibleObjectEncoder.class.getName() + ".oos");
 
     private final int resetInterval;
     private int writtenObjects;

File: common/src/main/java/io/netty/util/AttributeKey.java
Patch:
@@ -3,11 +3,11 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-public final class AttributeKey<T> extends UniqueKey<T> {
+public final class AttributeKey<T> extends UniqueName {
 
     private static final ConcurrentMap<String, Boolean> names = new ConcurrentHashMap<String, Boolean>();
 
-    public AttributeKey(String name, Class<T> valueType) {
-        super(names, name, valueType);
+    public AttributeKey(String name) {
+        super(names, name);
     }
 }

File: transport/src/main/java/io/netty/channel/ChannelBufferHolder.java
Patch:
@@ -184,7 +184,7 @@ public boolean isEmpty() {
             if (msgBuf != null) {
                 return msgBuf.isEmpty();
             } else {
-                return byteBuf.readable();
+                return !byteBuf.readable();
             }
         case 1:
         case 2:

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -742,7 +742,7 @@ private void fireInboundBufferUpdated(DefaultChannelHandlerContext ctx) {
             notifyHandlerException(t);
         } finally {
             ChannelBufferHolder<Object> inbound = ctx.inbound();
-            if (inbound.isEmpty() && inbound.hasByteBuffer()) {
+            if (!inbound.isBypass() && inbound.isEmpty() && inbound.hasByteBuffer()) {
                 inbound.byteBuffer().discardReadBytes();
             }
         }

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -22,8 +22,6 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
 
 import java.net.InetSocketAddress;
 
@@ -57,7 +55,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new EchoClientHandler(firstMessageSize));
                  }
              });

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -58,7 +58,7 @@ public void initChannel(ServerSocketChannel ch) throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new EchoServerHandler());
                  }
              });

File: buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java
Patch:
@@ -145,7 +145,7 @@ public void getBytes(int index, byte[] dst, int dstIndex, int length) {
             tmpBuf.clear().position(index).limit(index + length);
         } catch (IllegalArgumentException e) {
             throw new IndexOutOfBoundsException("Too many bytes to read - Need "
-                    + (index + length) + ", maximum is " + data.limit());
+                    + (index + length) + ", maximum is " + buffer.limit());
         }
         tmpBuf.get(dst, dstIndex, length);
     }
@@ -157,7 +157,7 @@ public void getBytes(int index, ByteBuffer dst) {
             tmpBuf.clear().position(index).limit(index + bytesToCopy);
         } catch (IllegalArgumentException e) {
             throw new IndexOutOfBoundsException("Too many bytes to read - Need "
-                    + (index + bytesToCopy) + ", maximum is " + data.limit());
+                    + (index + bytesToCopy) + ", maximum is " + buffer.limit());
         }
         dst.put(tmpBuf);
     }

File: transport/src/main/java/io/netty/channel/socket/oio/OioChildEventLoop.java
Patch:
@@ -54,7 +54,9 @@ protected void run() {
             }
 
             if (isShutdown()) {
-                ch.unsafe().close(ch.unsafe().voidFuture());
+                if (ch != null) {
+                    ch.unsafe().close(ch.unsafe().voidFuture());
+                }
                 if (peekTask() == null) {
                     break;
                 }

File: buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java
Patch:
@@ -195,7 +195,8 @@ public String readLine() throws IOException {
             lineBuf.append((char) b);
         }
 
-        while (lineBuf.charAt(lineBuf.length() - 1) == '\r') {
+        while ( lineBuf.length() > 0 &&
+                lineBuf.charAt(lineBuf.length() - 1) == '\r') {
             lineBuf.setLength(lineBuf.length() - 1);
         }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -200,7 +200,8 @@ public void finishHandshake(Channel channel, HttpResponse response) {
         String subprotocol = response.getHeader(Names.SEC_WEBSOCKET_PROTOCOL);
         setActualSubprotocol(subprotocol);
 
-        channel.pipeline().replace(HttpResponseDecoder.class, "ws-decoder",
+        channel.pipeline().get(HttpResponseDecoder.class).replace(
+                "ws-decoder",
                 new WebSocket08FrameDecoder(false, allowExtensions, getMaxFramePayloadLength()));
 
         setHandshakeComplete();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -200,7 +200,8 @@ public void finishHandshake(Channel channel, HttpResponse response) throws WebSo
         String subprotocol = response.getHeader(Names.SEC_WEBSOCKET_PROTOCOL);
         setActualSubprotocol(subprotocol);
 
-        channel.pipeline().replace(HttpResponseDecoder.class, "ws-decoder",
+        channel.pipeline().get(HttpResponseDecoder.class).replace(
+                "ws-decoder",
                 new WebSocket13FrameDecoder(false, allowExtensions, getMaxFramePayloadLength()));
 
         setHandshakeComplete();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -35,7 +35,7 @@ public abstract class WebSocketServerHandshaker {
 
     private final int maxFramePayloadLength;
 
-    private String selectedSubprotocol = null;
+    private String selectedSubprotocol;
 
     /**
      * Constructor specifying the destination web socket location

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -98,14 +98,15 @@ protected void setHandshakeComplete() {
     }
 
     /**
-     * Returns the sub protocol request sent to the server as specified in the constructor
+     * Returns the CSV of requested subprotocol(s) sent to the server as specified in the constructor
      */
     public String getExpectedSubprotocol() {
         return expectedSubprotocol;
     }
 
     /**
-     * Returns the sub protocol response and sent by the server. Only available after end of handshake.
+     * Returns the subprotocol response sent by the server. Only available after end of handshake.
+     * Null if no subprotocol was requested or confirmed by the server.
      */
     public String getActualSubprotocol() {
         return actualSubprotocol;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -851,7 +851,7 @@ void skipControlCharacters() {
         }
 
         while (sao.pos < sao.limit) {
-            char c = (char) ()sao.bytes[sao.pos ++] & 0xFF);
+            char c = (char) (sao.bytes[sao.pos ++] & 0xFF);
             if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
                 sao.setReadPosition(1);
                 return;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -851,7 +851,7 @@ void skipControlCharacters() {
         }
 
         while (sao.pos < sao.limit) {
-            char c = (char) sao.bytes[sao.pos ++];
+            char c = (char) ()sao.bytes[sao.pos ++] & 0xFF);
             if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
                 sao.setReadPosition(1);
                 return;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -147,6 +147,7 @@ public ChannelFuture handshake(Channel channel) {
             originValue = originValue + ":" + wsPort;
         }
 
+        request.addHeader(Names.ORIGIN, originValue);
         request.addHeader(Names.SEC_WEBSOCKET_KEY1, key1);
         request.addHeader(Names.SEC_WEBSOCKET_KEY2, key2);
         if (getExpectedSubprotocol() != null && !getExpectedSubprotocol().equals("")) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -130,6 +130,7 @@ public ChannelFuture handshake(Channel channel) {
             // See http://tools.ietf.org/html/rfc6454#section-6.2
             originValue = originValue + ":" + wsPort;
         }
+        request.addHeader(Names.ORIGIN, originValue);
 
         if (protocol != null && !protocol.equals("")) {
             request.addHeader(Names.SEC_WEBSOCKET_PROTOCOL, protocol);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -130,6 +130,7 @@ public ChannelFuture handshake(Channel channel) {
             // See http://tools.ietf.org/html/rfc6454#section-6.2
             originValue = originValue + ":" + wsPort;
         }
+        request.addHeader(Names.ORIGIN, originValue);
 
         if (protocol != null && !protocol.equals("")) {
             request.addHeader(Names.SEC_WEBSOCKET_PROTOCOL, protocol);

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -47,7 +47,6 @@ public class OioDatagramChannel extends AbstractOioMessageChannel
 
     private final MulticastSocket socket;
     private final DatagramChannelConfig config;
-    private final ChannelBufferHolder<Object> out = ChannelBufferHolders.messageBuffer();
     private final java.net.DatagramPacket tmpPacket = new java.net.DatagramPacket(EMPTY_DATA, 0);
 
     private static MulticastSocket newSocket() {
@@ -103,8 +102,8 @@ public boolean isActive() {
     }
 
     @Override
-    protected ChannelBufferHolder<Object> firstOut() {
-        return out;
+    protected ChannelBufferHolder<?> newOutboundBuffer() {
+        return ChannelBufferHolders.messageBuffer();
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -161,7 +161,7 @@ protected void doConnect(
     }
 
     @Override
-    protected ChannelBufferHolder<Object> firstOut() {
+    protected ChannelBufferHolder<?> newOutboundBuffer() {
         return ChannelBufferHolders.discardBuffer();
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
Patch:
@@ -84,7 +84,8 @@ public boolean isEncodable(Object msg) throws Exception {
                msg instanceof SpdySettingsFrame ||
                msg instanceof SpdyNoOpFrame ||
                msg instanceof SpdyGoAwayFrame ||
-               msg instanceof SpdyHeadersFrame;
+               msg instanceof SpdyHeadersFrame ||
+               msg instanceof SpdyPingFrame;
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -1,6 +1,5 @@
 package io.netty.handler.codec;
 
-import static io.netty.handler.codec.MessageToMessageEncoder.*;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelInboundHandlerAdapter;
@@ -42,7 +41,7 @@ public void inboundBufferUpdated(ChannelInboundHandlerContext<I> ctx)
                     continue;
                 }
 
-                if (unfoldAndAdd(ctx, ctx.nextInboundMessageBuffer(), omsg)) {
+                if (CodecUtil.unfoldAndAdd(ctx, omsg, true)) {
                     notify = true;
                 }
             } catch (Throwable t) {

File: codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec;
 
-import static io.netty.handler.codec.MessageToMessageEncoder.*;
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelBufferHolder;
@@ -378,7 +377,7 @@ public void channelInactive(ChannelInboundHandlerContext<Byte> ctx) throws Excep
         }
 
         try {
-            if (unfoldAndAdd(ctx, ctx.nextInboundMessageBuffer(), decodeLast(ctx, replayable))) {
+            if (CodecUtil.unfoldAndAdd(ctx, decodeLast(ctx, replayable), true)) {
                 fireInboundBufferUpdated(ctx, in);
             }
         } catch (Signal replay) {
@@ -442,7 +441,7 @@ protected void callDecode(ChannelInboundHandlerContext<Byte> ctx) {
                 }
 
                 // A successful decode
-                if (unfoldAndAdd(ctx, ctx.nextInboundMessageBuffer(), result)) {
+                if (CodecUtil.unfoldAndAdd(ctx, result, true)) {
                     decoded = true;
                 }
             } catch (Throwable t) {

File: codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java
Patch:
@@ -1,6 +1,5 @@
 package io.netty.handler.codec;
 
-import static io.netty.handler.codec.MessageToMessageEncoder.*;
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
@@ -33,7 +32,7 @@ public void channelInactive(ChannelInboundHandlerContext<Byte> ctx) throws Excep
         }
 
         try {
-            if (unfoldAndAdd(ctx, ctx.nextInboundMessageBuffer(), decodeLast(ctx, in))) {
+            if (CodecUtil.unfoldAndAdd(ctx, decodeLast(ctx, in), true)) {
                 in.discardReadBytes();
                 ctx.fireInboundBufferUpdated();
             }
@@ -69,7 +68,7 @@ protected void callDecode(ChannelInboundHandlerContext<Byte> ctx) {
                     }
                 }
 
-                if (unfoldAndAdd(ctx, ctx.nextInboundMessageBuffer(), o)) {
+                if (CodecUtil.unfoldAndAdd(ctx, o, true)) {
                     decoded = true;
                 } else {
                     break;

File: example/src/main/java/io/netty/example/discard/DiscardClient.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.discard;
 
-import io.netty.channel.ChannelBootstrap;
+import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.socket.SocketChannel;
@@ -38,7 +38,7 @@ public DiscardClient(String host, int port, int firstMessageSize) {
     }
 
     public void run() throws Exception {
-        ChannelBootstrap b = new ChannelBootstrap();
+        Bootstrap b = new Bootstrap();
         try {
             b.eventLoop(new NioEventLoop())
              .channel(new NioSocketChannel())

File: example/src/main/java/io/netty/example/discard/DiscardServer.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.example.discard;
 
+import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ServerChannelBootstrap;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -34,7 +34,7 @@ public DiscardServer(int port) {
     }
 
     public void run() throws Exception {
-        ServerChannelBootstrap b = new ServerChannelBootstrap();
+        ServerBootstrap b = new ServerBootstrap();
         try {
             b.eventLoop(new NioEventLoop(), new NioEventLoop())
              .channel(new NioServerSocketChannel())

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.echo;
 
-import io.netty.channel.ChannelBootstrap;
+import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
@@ -47,7 +47,7 @@ public EchoClient(String host, int port, int firstMessageSize) {
 
     public void run() throws Exception {
         // Configure the client.
-        ChannelBootstrap b = new ChannelBootstrap();
+        Bootstrap b = new Bootstrap();
         try {
             b.eventLoop(new NioEventLoop())
              .channel(new NioSocketChannel())

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.example.echo;
 
+import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
-import io.netty.channel.ServerChannelBootstrap;
 import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
@@ -41,7 +41,7 @@ public EchoServer(int port) {
 
     public void run() throws Exception {
         // Configure the server.
-        ServerChannelBootstrap b = new ServerChannelBootstrap();
+        ServerBootstrap b = new ServerBootstrap();
         try {
             b.eventLoop(new NioEventLoop(), new NioEventLoop())
              .channel(new NioServerSocketChannel())

File: example/src/main/java/io/netty/example/factorial/FactorialClient.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.factorial;
 
-import io.netty.channel.ChannelBootstrap;
+import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioSocketChannel;
@@ -37,7 +37,7 @@ public FactorialClient(String host, int port, int count) {
     }
 
     public void run() throws Exception {
-        ChannelBootstrap b = new ChannelBootstrap();
+        Bootstrap b = new Bootstrap();
         try {
             b.eventLoop(new NioEventLoop())
              .channel(new NioSocketChannel())

File: example/src/main/java/io/netty/example/factorial/FactorialServer.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.factorial;
 
-import io.netty.channel.ServerChannelBootstrap;
+import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 
@@ -32,7 +32,7 @@ public FactorialServer(int port) {
     }
 
     public void run() throws Exception {
-        ServerChannelBootstrap b = new ServerChannelBootstrap();
+        ServerBootstrap b = new ServerBootstrap();
         try {
             b.eventLoop(new NioEventLoop(), new NioEventLoop())
              .channel(new NioServerSocketChannel())

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.example.http.snoop;
 
+import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBootstrap;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.handler.codec.http.CookieEncoder;
@@ -61,7 +61,7 @@ public void run() throws Exception {
         boolean ssl = scheme.equalsIgnoreCase("https");
 
         // Configure the client.
-        ChannelBootstrap b = new ChannelBootstrap();
+        Bootstrap b = new Bootstrap();
         try {
             b.eventLoop(new NioEventLoop())
              .channel(new NioSocketChannel())

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.netty.example.http.snoop;
 
+import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.ServerChannelBootstrap;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.nio.NioEventLoop;
 
@@ -36,7 +36,7 @@ public HttpSnoopServer(int port) {
 
     public void run() throws Exception {
         // Configure the server.
-        ServerChannelBootstrap b = new ServerChannelBootstrap();
+        ServerBootstrap b = new ServerBootstrap();
 
         try {
             b.eventLoop(new NioEventLoop(), new NioEventLoop())

File: example/src/main/java/io/netty/example/http/websocketx/client/package-info.java
Patch:
@@ -16,8 +16,9 @@
 
 /**
  * <p>This is an example web service client.
- * <p>To run this example, you must first start {@link WebSocketServer} and
- * then {@link WebSocketClient}.
+ * <p>To run this example, you must first start
+ * {@link io.netty.example.http.websocketx.server.WebSocketServer} and
+ * then {@link io.netty.example.http.websocketx.client.WebSocketClient}.
  */
 package io.netty.example.http.websocketx.client;
 

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.netty.example.qotm;
 
+import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelBootstrap;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.socket.DatagramChannel;
@@ -43,7 +43,7 @@ public QuoteOfTheMomentClient(int port) {
     }
 
     public void run() throws Exception {
-        ChannelBootstrap b = new ChannelBootstrap();
+        Bootstrap b = new Bootstrap();
         try {
             b.eventLoop(new NioEventLoop())
              .channel(new NioDatagramChannel())

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServer.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.netty.example.qotm;
 
-import io.netty.channel.ChannelBootstrap;
+import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.socket.DatagramChannel;
@@ -39,7 +39,7 @@ public QuoteOfTheMomentServer(int port) {
     }
 
     public void run() throws Exception {
-        ChannelBootstrap b = new ChannelBootstrap();
+        Bootstrap b = new Bootstrap();
         try {
             b.eventLoop(new NioEventLoop())
              .channel(new NioDatagramChannel())

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -179,7 +179,7 @@ public ChannelPipeline addLast(ChannelHandler... handlers) {
         return this;
     }
 
-    static String generateName(ChannelHandler handler) {
+    private static String generateName(ChannelHandler handler) {
         String type = handler.getClass().getSimpleName();
         StringBuilder buf = new StringBuilder(type.length() + 10);
         buf.append(type);

File: codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java
Patch:
@@ -109,13 +109,11 @@ protected void doFlush(ChannelBufferHolder<Object> buf) throws Exception {
         int byteBufLen = byteBuf.readableBytes();
         if (byteBufLen > 0) {
             productQueue.add(byteBuf.readBytes(byteBufLen));
-            writeCounter += byteBufLen;
             byteBuf.clear();
         }
         Queue<Object> msgBuf = buf.messageBuffer();
         if (!msgBuf.isEmpty()) {
             productQueue.addAll(msgBuf);
-            writeCounter += msgBuf.size();
             msgBuf.clear();
         }
     }

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -38,7 +38,7 @@
 import java.net.SocketTimeoutException;
 import java.util.Queue;
 
-public class OioDatagramChannel extends AbstractOioChannel
+public class OioDatagramChannel extends AbstractOioMessageChannel
                                 implements DatagramChannel {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(OioDatagramChannel.class);

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -34,7 +34,7 @@
 import java.net.SocketTimeoutException;
 import java.nio.channels.NotYetConnectedException;
 
-public class OioSocketChannel extends AbstractOioChannel
+public class OioSocketChannel extends AbstractOioStreamChannel
                               implements SocketChannel {
 
     private static final InternalLogger logger =

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -579,6 +579,7 @@ public void run() {
             }
         }
 
+        @Override
         public void flushNow() {
             try {
                 doFlush(out());

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -44,7 +44,7 @@
 /**
  * Provides an NIO based {@link io.netty.channel.socket.DatagramChannel}.
  */
-public final class NioDatagramChannel extends AbstractNioChannel implements io.netty.channel.socket.DatagramChannel {
+public final class NioDatagramChannel extends AbstractNioMessageChannel implements io.netty.channel.socket.DatagramChannel {
 
     private final DatagramChannelConfig config;
     private final Map<InetAddress, List<MembershipKey>> memberships =

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -30,7 +30,7 @@
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
 
-public class NioSocketChannel extends AbstractNioChannel implements io.netty.channel.socket.SocketChannel {
+public class NioSocketChannel extends AbstractNioStreamChannel implements io.netty.channel.socket.SocketChannel {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSocketChannel.class);
 
@@ -54,7 +54,7 @@ public NioSocketChannel(SocketChannel socket) {
     }
 
     public NioSocketChannel(Channel parent, Integer id, SocketChannel socket) {
-        super(parent, id, socket, SelectionKey.OP_READ);
+        super(parent, id, socket);
         try {
             socket.configureBlocking(false);
         } catch (IOException e) {

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java
Patch:
@@ -352,7 +352,7 @@ private void flushMessageBuf(Queue<Object> buf) throws Exception {
 
     private static boolean expandReadBuffer(ChannelBuffer byteBuf) {
         if (!byteBuf.writable()) {
-            // FIXME: Use a sensible value.
+            // FIXME: Magic number
             byteBuf.ensureWritableBytes(4096);
             return true;
         }

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorkerPool.java
Patch:
@@ -39,7 +39,7 @@ public abstract class AbstractNioWorkerPool<E extends AbstractNioWorker> impleme
      * Create a new instance
      * 
      * @param workerExecutor the {@link Executor} to use for the {@link Worker}'s
-     * @param allowShutdownOnIdle allow the {@link Worker}'s to shutdown when there is not {@link Channel} is registered with it
+     * @param allowShutDownOnIdle allow the {@link Worker}'s to shutdown when there is not {@link Channel} is registered with it
      * @param workerCount the count of {@link Worker}'s to create
      */
     protected AbstractNioWorkerPool(Executor workerExecutor, int workerCount, boolean allowShutDownOnIdle) {

File: buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java
Patch:
@@ -195,7 +195,7 @@ public String readLine() throws IOException {
             lineBuf.append((char) b);
         }
 
-        if (lineBuf.length() > 0 ) {
+        if (lineBuf.length() > 0) {
             while (lineBuf.charAt(lineBuf.length() - 1) == '\r') {
                 lineBuf.setLength(lineBuf.length() - 1);
             }

File: codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java
Patch:
@@ -20,21 +20,21 @@
 import io.netty.channel.ServerChannelBootstrap;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.channel.socket.nio.SelectorEventLoop;
+import io.netty.channel.socket.nio.NioEventLoop;
 
 public class NioNioSocketSpdyEchoTest extends AbstractSocketSpdyEchoTest {
 
     @Override
     protected ChannelBootstrap newClientBootstrap() {
         return new ChannelBootstrap()
-                .eventLoop(new SelectorEventLoop())
+                .eventLoop(new NioEventLoop())
                 .channel(new NioSocketChannel());
     }
 
     @Override
     protected ServerChannelBootstrap newServerBootstrap() {
         return new ServerChannelBootstrap()
-                .eventLoop(new SelectorEventLoop(), new SelectorEventLoop())
+                .eventLoop(new NioEventLoop(), new NioEventLoop())
                 .channel(new NioServerSocketChannel());
     }
 }

File: codec-http/src/test/java/io/netty/handler/codec/spdy/OioOioSocketSpdyEchoTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.netty.channel.ChannelBootstrap;
 import io.netty.channel.ServerChannelBootstrap;
-import io.netty.channel.socket.oio.BlockingChannelEventLoop;
+import io.netty.channel.socket.oio.OioEventLoop;
 import io.netty.channel.socket.oio.OioServerSocketChannel;
 import io.netty.channel.socket.oio.OioSocketChannel;
 
@@ -27,14 +27,14 @@ public class OioOioSocketSpdyEchoTest extends AbstractSocketSpdyEchoTest {
     @Override
     protected ChannelBootstrap newClientBootstrap() {
         return new ChannelBootstrap()
-                .eventLoop(new BlockingChannelEventLoop())
+                .eventLoop(new OioEventLoop())
                 .channel(new OioSocketChannel());
     }
 
     @Override
     protected ServerChannelBootstrap newServerBootstrap() {
         return new ServerChannelBootstrap()
-                .eventLoop(new BlockingChannelEventLoop(), new BlockingChannelEventLoop())
+                .eventLoop(new OioEventLoop(), new OioEventLoop())
                 .channel(new OioServerSocketChannel());
     }
 }

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
Patch:
@@ -60,6 +60,9 @@ public ChannelBufferHolder<byte[]> newOutboundBuffer(ChannelOutboundHandlerConte
 
     @Override
     public ChannelBuffer encode(ChannelOutboundHandlerContext<byte[]> ctx, byte[] msg) throws Exception {
+        if (msg.length == 0) {
+            return null;
+        }
         return ChannelBuffers.wrappedBuffer(msg);
     }
 }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelBootstrap;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.channel.socket.nio.SelectorEventLoop;
+import io.netty.channel.socket.nio.NioEventLoop;
 import io.netty.handler.codec.http.CookieEncoder;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -63,7 +63,7 @@ public void run() throws Exception {
         // Configure the client.
         ChannelBootstrap b = new ChannelBootstrap();
         try {
-            b.eventLoop(new SelectorEventLoop())
+            b.eventLoop(new NioEventLoop())
              .channel(new NioSocketChannel())
              .initializer(new HttpSnoopClientInitializer(ssl))
              .remoteAddress(new InetSocketAddress(host, port));

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java
Patch:
@@ -15,17 +15,17 @@
  */
 package io.netty.example.http.snoop;
 
-import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.socket.SocketChannel;
 import io.netty.example.securechat.SecureChatSslContextFactory;
 import io.netty.handler.codec.http.HttpClientCodec;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 
 import javax.net.ssl.SSLEngine;
 
-public class HttpSnoopClientInitializer extends ChannelInitializer {
+public class HttpSnoopClientInitializer extends ChannelInitializer<SocketChannel> {
 
     private final boolean ssl;
 
@@ -34,7 +34,7 @@ public HttpSnoopClientInitializer(boolean ssl) {
     }
 
     @Override
-    public void initChannel(Channel ch) throws Exception {
+    public void initChannel(SocketChannel ch) throws Exception {
         // Create a default pipeline implementation.
         ChannelPipeline p = ch.pipeline();
 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ServerChannelBootstrap;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
-import io.netty.channel.socket.nio.SelectorEventLoop;
+import io.netty.channel.socket.nio.NioEventLoop;
 
 import java.net.InetSocketAddress;
 
@@ -39,7 +39,7 @@ public void run() throws Exception {
         ServerChannelBootstrap b = new ServerChannelBootstrap();
 
         try {
-            b.eventLoop(new SelectorEventLoop(), new SelectorEventLoop())
+            b.eventLoop(new NioEventLoop(), new NioEventLoop())
              .channel(new NioServerSocketChannel())
              .childInitializer(new HttpSnoopServerInitializer())
              .localAddress(new InetSocketAddress(port));

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
Patch:
@@ -15,15 +15,15 @@
  */
 package io.netty.example.http.snoop;
 
-import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
 
-public class HttpSnoopServerInitializer extends ChannelInitializer {
+public class HttpSnoopServerInitializer extends ChannelInitializer<SocketChannel> {
     @Override
-    public void initChannel(Channel ch) throws Exception {
+    public void initChannel(SocketChannel ch) throws Exception {
         // Create a default pipeline implementation.
         ChannelPipeline p = ch.pipeline();
 

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java
Patch:
@@ -55,12 +55,12 @@ protected SelectionKey selectionKey() {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof SingleThreadSelectorEventLoop;
+        return loop instanceof NioChildEventLoop;
     }
 
     @Override
     protected void doRegister() throws Exception {
-        SingleThreadSelectorEventLoop loop = (SingleThreadSelectorEventLoop) eventLoop();
+        NioChildEventLoop loop = (NioChildEventLoop) eventLoop();
         selectionKey = javaChannel().register(loop.selector, isActive()? SelectionKey.OP_READ : 0, this);
     }
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioChildEventLoop.java
Patch:
@@ -34,13 +34,13 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-final class SingleThreadSelectorEventLoop extends SingleThreadEventLoop {
+final class NioChildEventLoop extends SingleThreadEventLoop {
 
     /**
      * Internal Netty logger.
      */
     protected static final InternalLogger logger = InternalLoggerFactory
-            .getInstance(SingleThreadSelectorEventLoop.class);
+            .getInstance(NioChildEventLoop.class);
 
     static final int CLEANUP_INTERVAL = 256; // XXX Hard-coded value, but won't need customization.
 
@@ -59,7 +59,7 @@ final class SingleThreadSelectorEventLoop extends SingleThreadEventLoop {
 
     int cancelledKeys;
 
-    SingleThreadSelectorEventLoop(ThreadFactory threadFactory, SelectorProvider selectorProvider) {
+    NioChildEventLoop(ThreadFactory threadFactory, SelectorProvider selectorProvider) {
         super(threadFactory);
         if (selectorProvider == null) {
             throw new NullPointerException("selectorProvider");

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -89,7 +89,7 @@ public NioDatagramChannel(Integer id, DatagramChannel socket) {
             throw new ChannelException("Failed to enter non-blocking mode.", e);
         }
 
-        config = new DefaultNioDatagramChannelConfig(socket);
+        config = new NioDatagramChannelConfig(socket);
 
     }
 
@@ -168,7 +168,7 @@ protected void doClose() throws Exception {
     @Override
     protected void doDeregister() throws Exception {
         selectionKey().cancel();
-        ((SingleThreadSelectorEventLoop) eventLoop()).cancelledKeys ++;
+        ((NioChildEventLoop) eventLoop()).cancelledKeys ++;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * The default {@link NioSocketChannelConfig} implementation.
  */
-class DefaultNioDatagramChannelConfig extends DefaultDatagramChannelConfig {
+class NioDatagramChannelConfig extends DefaultDatagramChannelConfig {
 
     private static final Object IP_MULTICAST_IF;
     private static final Method GET_OPTION;
@@ -70,7 +70,7 @@ class DefaultNioDatagramChannelConfig extends DefaultDatagramChannelConfig {
 
     private final DatagramChannel channel;
 
-    DefaultNioDatagramChannelConfig(DatagramChannel channel) {
+    NioDatagramChannelConfig(DatagramChannel channel) {
         super(channel.socket());
         this.channel = channel;
     }

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -101,12 +101,12 @@ protected SocketAddress localAddress0() {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof SingleThreadSelectorEventLoop;
+        return loop instanceof NioChildEventLoop;
     }
 
     @Override
     protected void doRegister() throws Exception {
-        SingleThreadSelectorEventLoop loop = (SingleThreadSelectorEventLoop) eventLoop();
+        NioChildEventLoop loop = (NioChildEventLoop) eventLoop();
         selectionKey = javaChannel().register(
                 loop.selector, isActive()? SelectionKey.OP_ACCEPT : 0, this);
     }

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -155,7 +155,7 @@ protected void doClose() throws Exception {
     @Override
     protected void doDeregister() throws Exception {
         selectionKey().cancel();
-        ((SingleThreadSelectorEventLoop) eventLoop()).cancelledKeys ++;
+        ((NioChildEventLoop) eventLoop()).cancelledKeys ++;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -117,7 +117,7 @@ public boolean isActive() {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof SingleBlockingChannelEventLoop;
+        return loop instanceof OioChildEventLoop;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -118,7 +118,7 @@ public boolean isActive() {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof SingleBlockingChannelEventLoop;
+        return loop instanceof OioChildEventLoop;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -111,7 +111,7 @@ public boolean isActive() {
 
     @Override
     protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof SingleBlockingChannelEventLoop;
+        return loop instanceof OioChildEventLoop;
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -193,6 +193,9 @@ protected int doRead(Queue<Object> buf) throws Exception {
 
     @Override
     protected int doRead(ChannelBuffer buf) throws Exception {
+        if (socket.isClosed()) {
+            return -1;
+        }
         try {
             int readBytes = buf.writeBytes(is, buf.writableBytes());
             return readBytes;

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -42,6 +42,7 @@ private static long deadlineNanos(long delay) {
     private final Thread thread;
     private final Object stateLock = new Object();
     private final Semaphore threadLock = new Semaphore(0);
+    // TODO: Use PriorityQueue to reduce the locking overhead of DelayQueue.
     private final Queue<ScheduledFutureTask<?>> scheduledTasks = new DelayQueue<ScheduledFutureTask<?>>();
     /** 0 - not started, 1 - started, 2 - shut down, 3 - terminated */
     private volatile int state;

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.channel.AbstractServerChannel;
-import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelException;
 import io.netty.channel.EventLoop;
 import io.netty.channel.socket.DefaultServerSocketChannelConfig;
@@ -29,6 +28,7 @@
 import java.net.SocketAddress;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.ServerSocketChannel;
+import java.util.Queue;
 
 public class NioServerSocketChannel extends AbstractServerChannel
                              implements io.netty.channel.socket.ServerSocketChannel {
@@ -128,12 +128,12 @@ protected void doDeregister() throws Exception {
     }
 
     @Override
-    protected int doRead(ChannelBufferHolder<Object> buf) throws Exception {
+    protected int doRead(Queue<Object> buf) throws Exception {
         java.nio.channels.SocketChannel ch = javaChannel().accept();
         if (ch == null) {
             return 0;
         }
-        buf.messageBuffer().add(new NioSocketChannel(this, null, ch));
+        buf.add(new NioSocketChannel(this, null, ch));
         return 1;
     }
 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -126,7 +126,7 @@ protected SocketAddress remoteAddress0() {
 
     @Override
     protected void doBind(SocketAddress localAddress) throws Exception {
-        javaChannel().bind(localAddress);
+        javaChannel().socket().bind(localAddress);
         selectionKey().interestOps(SelectionKey.OP_READ);
     }
 
@@ -174,6 +174,7 @@ protected void doDeregister() throws Exception {
     @Override
     protected int doRead(ChannelBufferHolder<Object> buf) throws Exception {
         DatagramChannel ch = javaChannel();
+        // FIXME: Make this configurable.
         ByteBuffer data = ByteBuffer.allocate(1024);
         InetSocketAddress remoteAddress = (InetSocketAddress) ch.receive(data);
         if (remoteAddress == null) {

File: buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java
Patch:
@@ -195,7 +195,8 @@ public String readLine() throws IOException {
             lineBuf.append((char) b);
         }
 
-        while (lineBuf.charAt(lineBuf.length() - 1) == '\r') {
+        while ( lineBuf.length() > 0 &&
+                lineBuf.charAt(lineBuf.length() - 1) == '\r') {
             lineBuf.setLength(lineBuf.length() - 1);
         }
 

File: buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java
Patch:
@@ -195,7 +195,8 @@ public String readLine() throws IOException {
             lineBuf.append((char) b);
         }
 
-        while (lineBuf.charAt(lineBuf.length() - 1) == '\r') {
+        while ( lineBuf.length() > 0 &&
+                lineBuf.charAt(lineBuf.length() - 1) == '\r') {
             lineBuf.setLength(lineBuf.length() - 1);
         }
 

File: transport/src/main/java/io/netty/channel/group/ChannelGroup.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.channel.group;
 
-import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;

File: transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -116,7 +116,7 @@ public boolean add(Channel channel) {
 
         boolean added = map.putIfAbsent(channel.id(), channel) == null;
         if (added) {
-            channel.addClosureListener(remover);
+            channel.closeFuture().addListener(remover);
         }
         return added;
     }
@@ -142,7 +142,7 @@ public boolean remove(Object o) {
             return false;
         }
 
-        c.removeClosureListener(remover);
+        c.closeFuture().removeListener(remover);
         return true;
     }
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -116,7 +116,6 @@ public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, Channe
                     out.writeBytes(chunkContent, chunkContent.readerIndex(), chunkContent.readableBytes());
                 }
             }
-
         } else {
             throw new UnsupportedMessageTypeException(msg, HttpMessage.class, HttpChunk.class);
         }

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java
Patch:
@@ -15,12 +15,14 @@
  */
 package io.netty.handler.codec.spdy;
 
+import io.netty.handler.codec.CodecException;
+
 /**
  * An {@link Exception} which is thrown when the received frame cannot
  * be decoded by the {@link SpdyFrameDecoder}.
  * @apiviz.exclude
  */
-public class SpdyProtocolException extends Exception {
+public class SpdyProtocolException extends CodecException {
 
     private static final long serialVersionUID = -1097979786367505658L;
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
Patch:
@@ -53,7 +53,7 @@ public void removeStream(int streamID) {
 
     public boolean isRemoteSideClosed(int streamID) {
         StreamState state = activeStreams.get(new Integer(streamID));
-        return (state == null) || state.isRemoteSideClosed();
+        return state == null || state.isRemoteSideClosed();
     }
 
     public void closeRemoteSide(int streamID) {
@@ -69,7 +69,7 @@ public void closeRemoteSide(int streamID) {
 
     public boolean isLocalSideClosed(int streamID) {
         StreamState state = activeStreams.get(new Integer(streamID));
-        return (state == null) || state.isLocalSideClosed();
+        return state == null || state.isLocalSideClosed();
     }
 
     public void closeLocalSide(int streamID) {
@@ -85,7 +85,7 @@ public void closeLocalSide(int streamID) {
 
     public boolean hasReceivedReply(int streamID) {
         StreamState state = activeStreams.get(new Integer(streamID));
-        return (state != null) && state.hasReceivedReply();
+        return state != null && state.hasReceivedReply();
     }
 
     public void receivedReply(int streamID) {

File: codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-import java.util.concurrent.Executor;
 
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.socket.nio.NioClientSocketChannelFactory;
@@ -24,12 +23,12 @@
 public class NioOioSocketSpdyEchoTest extends AbstractSocketSpdyEchoTest {
 
     @Override
-    protected ChannelFactory newClientSocketChannelFactory(Executor executor) {
+    protected ChannelFactory newClientBootstrap() {
         return new NioClientSocketChannelFactory(executor);
     }
 
     @Override
-    protected ChannelFactory newServerSocketChannelFactory(Executor executor) {
+    protected ChannelFactory newServerBootstrap() {
         return new OioServerSocketChannelFactory(executor, executor);
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-import java.util.concurrent.Executor;
 
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.socket.nio.NioServerSocketChannelFactory;
@@ -24,12 +23,12 @@
 public class OioNioSocketSpdyEchoTest extends AbstractSocketSpdyEchoTest {
 
     @Override
-    protected ChannelFactory newClientSocketChannelFactory(Executor executor) {
+    protected ChannelFactory newClientBootstrap() {
         return new OioClientSocketChannelFactory(executor);
     }
 
     @Override
-    protected ChannelFactory newServerSocketChannelFactory(Executor executor) {
+    protected ChannelFactory newServerBootstrap() {
         return new NioServerSocketChannelFactory(executor);
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/spdy/OioOioSocketSpdyEchoTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-import java.util.concurrent.Executor;
 
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.socket.oio.OioClientSocketChannelFactory;
@@ -24,12 +23,12 @@
 public class OioOioSocketSpdyEchoTest extends AbstractSocketSpdyEchoTest {
 
     @Override
-    protected ChannelFactory newClientSocketChannelFactory(Executor executor) {
+    protected ChannelFactory newClientBootstrap() {
         return new OioClientSocketChannelFactory(executor);
     }
 
     @Override
-    protected ChannelFactory newServerSocketChannelFactory(Executor executor) {
+    protected ChannelFactory newServerBootstrap() {
         return new OioServerSocketChannelFactory(executor, executor);
     }
 

File: codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.embedder;
 
 import io.netty.buffer.ChannelBuffer;
+import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
@@ -30,7 +31,7 @@
 class EmbeddedChannel extends AbstractChannel {
 
     private final ChannelConfig config = new DefaultChannelConfig();
-    private final ChannelBufferHolder<?> firstOut = ChannelBufferHolders.byteBuffer();
+    private final ChannelBufferHolder<?> firstOut;
     private final SocketAddress localAddress = new EmbeddedSocketAddress();
     private final SocketAddress remoteAddress = new EmbeddedSocketAddress();
     private final Queue<Object> productQueue;
@@ -50,6 +51,7 @@ public void close() throws IOException {
     EmbeddedChannel(Queue<Object> productQueue) {
         super(null, null);
         this.productQueue = productQueue;
+        firstOut = ChannelBufferHolders.catchAllBuffer(productQueue, ChannelBuffers.dynamicBuffer());
     }
 
     @Override

File: codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java
Patch:
@@ -124,7 +124,7 @@ protected void doDeregister() throws Exception {
     }
 
     @Override
-    protected int doRead() throws Exception {
+    protected int doRead(ChannelBufferHolder<Object> buf) throws Exception {
         return 0;
     }
 

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -91,7 +91,7 @@ public abstract class AbstractTrafficShapingHandler extends
     /**
      * used in releaseExternalResources() to cancel the timer
      */
-    volatile private Timeout timeout = null;
+    private volatile Timeout timeout;
     
     /**
      * Limit in B/s to apply to write

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -33,7 +33,7 @@
  * <li>Add in your pipeline a new ChannelTrafficShapingHandler, before a recommended {@link ExecutionHandler} (like
  * {@link OrderedMemoryAwareThreadPoolExecutor} or {@link MemoryAwareThreadPoolExecutor}).<br>
  * <tt>ChannelTrafficShapingHandler myHandler = new ChannelTrafficShapingHandler(timer);</tt><br>
- * timer could be created using <tt>HashedWheelTimer<tt><br>
+ * timer could be created using <tt>HashedWheelTimer</tt><br>
  * <tt>pipeline.addLast("CHANNEL_TRAFFIC_SHAPING", myHandler);</tt><br><br>
  *
  * <b>Note that this handler has a Pipeline Coverage of "one" which means a new handler must be created

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -31,7 +31,7 @@
  * <ul>
  * <li>Create your unique GlobalTrafficShapingHandler like:<br><br>
  * <tt>GlobalTrafficShapingHandler myHandler = new GlobalTrafficShapingHandler(timer);</tt><br><br>
- * timer could be created using <tt>HashedWheelTimer<tt><br>
+ * timer could be created using <tt>HashedWheelTimer</tt><br>
  * <tt>pipeline.addLast("GLOBAL_TRAFFIC_SHAPING", myHandler);</tt><br><br>
  *
  * <b>Note that this handler has a Pipeline Coverage of "all" which means only one such handler must be created

File: handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java
Patch:
@@ -113,7 +113,7 @@ public class TrafficCounter {
     /**
      * used in stop() to cancel the timer
      */
-    volatile private Timeout timeout = null;
+    private volatile Timeout timeout;
 
     /**
      * Is Monitor active

File: handler/src/main/java/io/netty/handler/traffic/package-info.java
Patch:
@@ -36,7 +36,7 @@
  *
  * The insertion in the pipeline of one of those handlers can be wherever you want, but
  * <b>it must be placed before any <tt>{@link MemoryAwareThreadPoolExecutor}</tt>
- * in your pipeline</b>.</li><br>
+ * in your pipeline</b>.<br>
  * <b><i>It is really recommended to have such a</i> <tt>{@link MemoryAwareThreadPoolExecutor}</tt>
  * <i>(either non ordered or </i> <tt>{@link OrderedMemoryAwareThreadPoolExecutor}</tt>
  * <i>) in your pipeline</i></b>
@@ -76,7 +76,7 @@
  *
  * <P>So in your application you will create your own TrafficShapingHandler and set the values to fit your needs.</P>
  * <tt>XXXXXTrafficShapingHandler myHandler = new XXXXXTrafficShapingHandler(timer);</tt><br><br>
- * timer could be created using <tt>HashedWheelTimer<tt> and XXXXX could be either
+ * timer could be created using <tt>HashedWheelTimer</tt> and XXXXX could be either
  * Global or Channel<br>
  * <tt>pipeline.addLast("XXXXX_TRAFFIC_SHAPING", myHandler);</tt><br>
  * <tt>...</tt><br>

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -286,7 +286,7 @@ public void configure(long newWriteLimit, long newReadLimit) {
         writeLimit = newWriteLimit;
         readLimit = newReadLimit;
         if (trafficCounter != null) {
-            trafficCounter.resetAccounting(System.currentTimeMillis()+1);
+            trafficCounter.resetAccounting(System.currentTimeMillis() + 1);
         }
     }
 

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -353,7 +353,7 @@ private long getTimeToWait(long limit, long bytes, long lastTime,
             // Time is too short, so just lets continue
             return 0;
         }
-        return ((bytes * 1000 / limit - interval)/10)*10;
+        return ((bytes * 1000 / limit - interval) / 10) * 10;
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java
Patch:
@@ -245,7 +245,7 @@ public TrafficCounter(AbstractTrafficShapingHandler trafficShapingHandler,
      * @param newcheckInterval
      */
     public void configure(long newcheckInterval) {
-        long newInterval = (newcheckInterval/10)*10;
+        long newInterval = (newcheckInterval / 10) * 10;
         if (checkInterval.get() != newInterval) {
             checkInterval.set(newInterval);
             if (newInterval <= 0) {

File: transport/src/main/java/io/netty/channel/CombinedChannelHandler.java
Patch:
@@ -8,7 +8,7 @@ public class CombinedChannelHandler implements ChannelInboundHandler<Object>,
     private ChannelOutboundHandler<Object> out;
     private ChannelInboundHandler<Object> in;
 
-    public CombinedChannelHandler() {
+    protected CombinedChannelHandler() {
         // User will call init in the subclass constructor.
     }
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -16,6 +16,7 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.channel.AbstractServerChannel;
+import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelException;
 import io.netty.channel.EventLoop;
 import io.netty.channel.socket.DefaultServerSocketChannelConfig;
@@ -127,12 +128,12 @@ protected void doDeregister() throws Exception {
     }
 
     @Override
-    protected int doRead() throws Exception {
+    protected int doRead(ChannelBufferHolder<Object> buf) throws Exception {
         java.nio.channels.SocketChannel ch = javaChannel().accept();
         if (ch == null) {
             return 0;
         }
-        pipeline().nextIn().messageBuffer().add(new NioSocketChannel(this, null, ch));
+        buf.messageBuffer().add(new NioSocketChannel(this, null, ch));
         return 1;
     }
 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -166,9 +166,9 @@ protected void doDeregister() throws Exception {
     }
 
     @Override
-    protected int doRead() throws Exception {
-        ChannelBuffer buf = pipeline().nextIn().byteBuffer();
-        return buf.writeBytes(javaChannel(), buf.writableBytes());
+    protected int doRead(ChannelBufferHolder<Object> buf) throws Exception {
+        ChannelBuffer byteBuf = buf.byteBuffer();
+        return byteBuf.writeBytes(javaChannel(), byteBuf.writableBytes());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -227,9 +227,10 @@ public void finishHandshake(Channel channel, HttpResponse response) {
         String subprotocol = response.getHeader(Names.SEC_WEBSOCKET_PROTOCOL);
         setActualSubprotocol(subprotocol);
 
+        setHandshakeComplete();
+
         channel.getPipeline().replace(HttpResponseDecoder.class, "ws-decoder",
                 new WebSocket08FrameDecoder(false, allowExtensions, this.getMaxFramePayloadLength()));
 
-        setHandshakeComplete();
     }
 }

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -359,7 +359,7 @@ private long getTimeToWait(long limit, long bytes, long lastTime,
             // Time is too short, so just lets continue
             return 0;
         }
-        return bytes * 1000 / limit - interval;
+        return ((bytes * 1000 / limit - interval)/10)*10;
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -240,10 +240,10 @@ public void finishHandshake(Channel channel, HttpResponse response) throws WebSo
         String subprotocol = response.getHeader(Names.SEC_WEBSOCKET_PROTOCOL);
         setActualSubprotocol(subprotocol);
 
-        channel.getPipeline().replace(HttpResponseDecoder.class, "ws-decoder",
-                new WebSocket00FrameDecoder(this.getMaxFramePayloadLength()));
-
         setHandshakeComplete();
+        
+        channel.getPipeline().get(HttpResponseDecoder.class).replace("ws-decoder",
+                new WebSocket00FrameDecoder(this.getMaxFramePayloadLength()));
     }
 
     private String insertRandomCharacters(String key) {

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -224,9 +224,10 @@ public void finishHandshake(Channel channel, HttpResponse response) throws WebSo
         String subprotocol = response.getHeader(Names.SEC_WEBSOCKET_PROTOCOL);
         setActualSubprotocol(subprotocol);
 
-        channel.getPipeline().replace(HttpResponseDecoder.class, "ws-decoder",
+        setHandshakeComplete();
+
+        channel.getPipeline().get(HttpResponseDecoder.class).replace("ws-decoder",
                 new WebSocket13FrameDecoder(false, allowExtensions, this.getMaxFramePayloadLength()));
 
-        setHandshakeComplete();
     }
 }

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -360,7 +360,7 @@ private long getTimeToWait(long limit, long bytes, long lastTime,
             // Time is too short, so just lets continue
             return 0;
         }
-        return bytes * 1000 / limit - interval;
+        return ((bytes * 1000 / limit - interval)/10)*10;
     }
 
     @Override

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -23,7 +23,7 @@
 import io.netty.handler.execution.ExecutionHandler;
 import io.netty.handler.execution.MemoryAwareThreadPoolExecutor;
 import io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
-import io.netty.util.ObjectSizeEstimator;
+import io.netty.handler.execution.ObjectSizeEstimator;
 
 /**
  * This implementation of the {@link AbstractTrafficShapingHandler} is for channel

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.handler.execution.ExecutionHandler;
 import io.netty.handler.execution.MemoryAwareThreadPoolExecutor;
 import io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
-import io.netty.util.ObjectSizeEstimator;
+import io.netty.handler.execution.ObjectSizeEstimator;
 
 /**
  * This implementation of the {@link AbstractTrafficShapingHandler} is for global

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.handler.execution.ExecutionHandler;
 import io.netty.handler.execution.MemoryAwareThreadPoolExecutor;
 import io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
-import io.netty.util.ObjectSizeEstimator;
+import io.netty.handler.execution.ObjectSizeEstimator;
 
 /**
  * This implementation of the {@link AbstractTrafficShapingHandler} is for global

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -23,7 +23,7 @@
 import io.netty.handler.execution.ExecutionHandler;
 import io.netty.handler.execution.MemoryAwareThreadPoolExecutor;
 import io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
-import io.netty.util.ObjectSizeEstimator;
+import io.netty.handler.execution.ObjectSizeEstimator;
 
 /**
  * This implementation of the {@link AbstractTrafficShapingHandler} is for channel

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -18,19 +18,18 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelState;
 import io.netty.channel.ChannelStateEvent;
 import io.netty.channel.MessageEvent;
 import io.netty.channel.SimpleChannelHandler;
+import io.netty.handler.execution.ObjectSizeEstimator;
+import io.netty.handler.execution.DefaultObjectSizeEstimator;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import io.netty.util.DefaultObjectSizeEstimator;
 import io.netty.util.ExternalResourceReleasable;
-import io.netty.util.ObjectSizeEstimator;
 import io.netty.util.internal.ExecutorUtil;
 
 /**

File: codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
Patch:
@@ -31,7 +31,7 @@ public void inboundBufferUpdated(ChannelInboundHandlerContext<I> ctx)
                 O emsg = decode(ctx, msg);
                 if (emsg == null) {
                     // Decoder consumed a message but returned null.
-                    // Probably it needs more messages.
+                    // Probably it needs more messages because it's an aggregator.
                     continue;
                 }
 

File: codec/src/main/java/io/netty/handler/codec/UnreplayableOperationException.java
Patch:
@@ -22,8 +22,7 @@
  * operation on a {@link ChannelBuffer} in a {@link ReplayingDecoder}
  * implementation.
  */
-public class UnreplayableOperationException extends
-        UnsupportedOperationException {
+public class UnreplayableOperationException extends UnsupportedOperationException {
 
     private static final long serialVersionUID = 8577363912862364021L;
 

File: codec/src/main/java/io/netty/handler/codec/redis/RedisEncoder.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelOutboundHandlerContext;
 import io.netty.handler.codec.MessageToStreamEncoder;
+import io.netty.handler.codec.UnsupportedMessageTypeException;
 
 /**
  * {@link SimpleChannelDownstreamHandler} which encodes {@link Command}'s to {@link ChannelBuffer}'s
@@ -43,7 +44,7 @@ public void encode(ChannelOutboundHandlerContext<Object> ctx, Object msg, Channe
                 }
             }
         } else {
-            throw new IllegalArgumentException("unsupported message type: " + msg.getClass().getName());
+            throw new UnsupportedMessageTypeException(msg, Command.class, Iterable.class);
         }
     }
 }

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.handler.execution.ExecutionHandler;
 import io.netty.handler.execution.MemoryAwareThreadPoolExecutor;
 import io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
-import org.jboss.netty.util.ObjectSizeEstimator;
+import io.netty.util.ObjectSizeEstimator;
 
 /**
  * This implementation of the {@link AbstractTrafficShapingHandler} is for global

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -23,7 +23,7 @@
 import io.netty.handler.execution.ExecutionHandler;
 import io.netty.handler.execution.MemoryAwareThreadPoolExecutor;
 import io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
-import org.jboss.netty.util.ObjectSizeEstimator;
+import io.netty.util.ObjectSizeEstimator;
 
 /**
  * This implementation of the {@link AbstractTrafficShapingHandler} is for channel

File: handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
Patch:
@@ -28,9 +28,9 @@
 import io.netty.channel.SimpleChannelHandler;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
-import org.jboss.netty.util.DefaultObjectSizeEstimator;
-import org.jboss.netty.util.ExternalResourceReleasable;
-import org.jboss.netty.util.ObjectSizeEstimator;
+import io.netty.util.DefaultObjectSizeEstimator;
+import io.netty.util.ExternalResourceReleasable;
+import io.netty.util.ObjectSizeEstimator;
 import io.netty.util.internal.ExecutorUtil;
 
 /**

File: handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java
Patch:
@@ -117,7 +117,7 @@ public class TrafficCounter {
     /**
      * Class to implement monitoring at fix delay
  */
-    private class TrafficMonitoring implements Runnable {
+    private static class TrafficMonitoring implements Runnable {
         /**
          * The associated TrafficShapingHandler
          */
@@ -145,8 +145,8 @@ protected TrafficMonitoring(
         @Override
         public void run() {
             try {
-                Thread.currentThread().setName(name);
-                for (; monitorActive.get();) {
+                Thread.currentThread().setName(counter.name);
+                for (; counter.monitorActive.get();) {
                     long check = counter.checkInterval.get();
                     if (check > 0) {
                         Thread.sleep(check);

File: codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java
Patch:
@@ -96,7 +96,7 @@ public void checkpoint() {
     }
 
     @Override
-    public Reply decode(ChannelInboundHandlerContext<Byte> channelHandlerContext, ChannelBuffer channelBuffer, VoidEnum anEnum) throws Exception {
+    public Reply decode(ChannelInboundHandlerContext<Byte> channelHandlerContext, ChannelBuffer channelBuffer) throws Exception {
         if (reply != null) {
             reply.read(this, channelBuffer);
             Reply ret = reply;

File: codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
Patch:
@@ -54,8 +54,7 @@ private static final class LineDecoder extends ReplayingDecoder<ChannelBuffer, V
         }
 
         @Override
-        public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx,
-                ChannelBuffer in, VoidEnum state) throws Exception {
+        public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {
             ChannelBuffer msg = in.readBytes(in.bytesBefore(ChannelBufferIndexFinder.LF));
             in.skipBytes(1);
             return msg;

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
Patch:
@@ -18,7 +18,7 @@
 import static io.netty.buffer.ChannelBuffers.*;
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
-import io.netty.handler.codec.embedder.CodecEmbedderException;
+import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 
 import java.util.Random;
@@ -59,7 +59,7 @@ public void testDecodeOtherType() {
         try {
             embedder.poll();
             fail();
-        } catch (CodecEmbedderException e) {
+        } catch (DecoderException e) {
             // Expected
             assertTrue(e.getCause() instanceof ClassCastException);
         }

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
Patch:
@@ -20,7 +20,7 @@
 import static org.hamcrest.core.IsNull.*;
 import static org.junit.Assert.*;
 import io.netty.buffer.ChannelBuffer;
-import io.netty.handler.codec.embedder.CodecEmbedderException;
+import io.netty.handler.codec.EncoderException;
 import io.netty.handler.codec.embedder.EncoderEmbedder;
 
 import java.util.Random;
@@ -61,7 +61,7 @@ public void testEncodeOtherType() {
         try {
             embedder.poll();
             fail();
-        } catch (CodecEmbedderException e) {
+        } catch (EncoderException e) {
             // Expected
             assertTrue(e.getCause() instanceof ClassCastException);
         }

File: codec/src/main/java/io/netty/handler/codec/CorruptedFrameException.java
Patch:
@@ -21,7 +21,7 @@
  *
  * @apiviz.hidden
  */
-public class CorruptedFrameException extends Exception {
+public class CorruptedFrameException extends DecoderException {
 
     private static final long serialVersionUID = 3918052232492988408L;
 

File: codec/src/main/java/io/netty/handler/codec/TooLongFrameException.java
Patch:
@@ -20,7 +20,7 @@
  * decoded by {@link DelimiterBasedFrameDecoder} is greater than the maximum.
  * @apiviz.hidden
  */
-public class TooLongFrameException extends Exception {
+public class TooLongFrameException extends DecoderException {
 
     private static final long serialVersionUID = -1995801950698951640L;
 

File: codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
Patch:
@@ -55,7 +55,7 @@
  * </pre>
  * @apiviz.uses io.netty.handler.codec.frame.Delimiters - - useful
  */
-public class DelimiterBasedFrameDecoder extends StreamToMessageDecoder<ChannelBuffer> {
+public class DelimiterBasedFrameDecoder extends StreamToMessageDecoder<Object> {
 
     private final ChannelBuffer[] delimiters;
     private final int maxFrameLength;
@@ -187,7 +187,7 @@ public DelimiterBasedFrameDecoder(
     }
 
     @Override
-    public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {
+    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {
         // Try all delimiters and choose the delimiter which yields the shortest frame.
         int minFrameLength = Integer.MAX_VALUE;
         ChannelBuffer minDelim = null;

File: codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
Patch:
@@ -37,7 +37,7 @@
  * +-----+-----+-----+
  * </pre>
  */
-public class FixedLengthFrameDecoder extends StreamToMessageDecoder<ChannelBuffer> {
+public class FixedLengthFrameDecoder extends StreamToMessageDecoder<Object> {
 
     private final int frameLength;
     private final boolean allocateFullBuffer;
@@ -75,7 +75,7 @@ public ChannelBufferHolder<Byte> newInboundBuffer(
     }
 
     @Override
-    public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
         if (in.readableBytes() < frameLength) {
             return null;
         } else {

File: codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
Patch:
@@ -180,7 +180,7 @@
  * </pre>
  * @see LengthFieldPrepender
  */
-public class LengthFieldBasedFrameDecoder extends StreamToMessageDecoder<ChannelBuffer> {
+public class LengthFieldBasedFrameDecoder extends StreamToMessageDecoder<Object> {
 
     private final int maxFrameLength;
     private final int lengthFieldOffset;
@@ -308,7 +308,7 @@ public LengthFieldBasedFrameDecoder(
     }
 
     @Override
-    public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
         if (discardingTooLongFrame) {
             long bytesToDiscard = this.bytesToDiscard;
             int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
Patch:
@@ -37,7 +37,7 @@
  *
  * @see com.google.protobuf.CodedInputStream
  */
-public class ProtobufVarint32FrameDecoder extends StreamToMessageDecoder<ChannelBuffer> {
+public class ProtobufVarint32FrameDecoder extends StreamToMessageDecoder<Object> {
 
     // TODO maxFrameLength + safe skip + fail-fast option
     //      (just like LengthFieldBasedFrameDecoder)
@@ -49,7 +49,7 @@ public ProtobufVarint32FrameDecoder() {
     }
 
     @Override
-    public ChannelBuffer decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
+    public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {
         in.markReaderIndex();
         final byte[] buf = new byte[5];
         for (int i = 0; i < buf.length; i ++) {

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
Patch:
@@ -18,6 +18,7 @@
 import static io.netty.buffer.ChannelBuffers.*;
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
+import io.netty.handler.codec.embedder.CodecEmbedderException;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 
 import java.util.Random;
@@ -58,8 +59,9 @@ public void testDecodeOtherType() {
         try {
             embedder.poll();
             fail();
-        } catch (ClassCastException e) {
+        } catch (CodecEmbedderException e) {
             // Expected
+            assertTrue(e.getCause() instanceof ClassCastException);
         }
     }
 }

File: codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.hamcrest.core.IsNull.*;
 import static org.junit.Assert.*;
 import io.netty.buffer.ChannelBuffer;
+import io.netty.handler.codec.embedder.CodecEmbedderException;
 import io.netty.handler.codec.embedder.EncoderEmbedder;
 
 import java.util.Random;
@@ -60,8 +61,9 @@ public void testEncodeOtherType() {
         try {
             embedder.poll();
             fail();
-        } catch (ClassCastException e) {
+        } catch (CodecEmbedderException e) {
             // Expected
+            assertTrue(e.getCause() instanceof ClassCastException);
         }
     }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -911,7 +911,7 @@ public ChannelFuture write(Object message, ChannelFuture future) {
         } else {
             throw new IllegalArgumentException(
                     "cannot write a message whose type is not " +
-                    ChannelBuffer.class.getSimpleName() + ": " + message.getClass().getName()));
+                    ChannelBuffer.class.getSimpleName() + ": " + message.getClass().getName());
         }
 
         return flush(future);

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -29,7 +29,7 @@
 import io.netty.channel.Channels;
 import io.netty.channel.MessageEvent;
 import io.netty.channel.SimpleChannelUpstreamHandler;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.CharsetUtil;
 
 /**

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -22,7 +22,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.replay.ReplayingDecoder;
 
 /**

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelPipeline;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 
 
 /**

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.ChannelPipeline;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 
 
 /**

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
Patch:
@@ -18,7 +18,7 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.replay.ReplayingDecoder;
 import io.netty.handler.codec.replay.VoidEnum;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -58,8 +58,8 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.frame.CorruptedFrameException;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.replay.ReplayingDecoder;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java
Patch:
@@ -59,7 +59,7 @@
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.oneone.OneToOneEncoder;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -155,7 +155,7 @@ public ChannelFuture handshake(Channel channel) {
 
         ChannelFuture future = channel.write(request);
 
-        channel.getPipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket00FrameEncoder());
+        channel.pipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket00FrameEncoder());
 
         return future;
     }
@@ -210,7 +210,7 @@ public void finishHandshake(Channel channel, HttpResponse response) throws WebSo
         String protocol = response.getHeader(Names.SEC_WEBSOCKET_PROTOCOL);
         setActualSubprotocol(protocol);
 
-        channel.getPipeline().replace(HttpResponseDecoder.class, "ws-decoder", new WebSocket00FrameDecoder());
+        channel.pipeline().replace(HttpResponseDecoder.class, "ws-decoder", new WebSocket00FrameDecoder());
 
         setHandshakeComplete();
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -136,7 +136,7 @@ public ChannelFuture handshake(Channel channel) {
 
         ChannelFuture future = channel.write(request);
 
-        channel.getPipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket08FrameEncoder(true));
+        channel.pipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket08FrameEncoder(true));
 
         return future;
     }
@@ -186,7 +186,7 @@ public void finishHandshake(Channel channel, HttpResponse response) {
                     expectedChallengeResponseString));
         }
 
-        channel.getPipeline().replace(HttpResponseDecoder.class, "ws-decoder",
+        channel.pipeline().replace(HttpResponseDecoder.class, "ws-decoder",
                 new WebSocket08FrameDecoder(false, allowExtensions));
 
         setHandshakeComplete();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -136,7 +136,7 @@ public ChannelFuture handshake(Channel channel) {
         
         ChannelFuture future = channel.write(request);
 
-        channel.getPipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket13FrameEncoder(true));
+        channel.pipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket13FrameEncoder(true));
 
         return future;
     }
@@ -186,7 +186,7 @@ public void finishHandshake(Channel channel, HttpResponse response) throws WebSo
                     expectedChallengeResponseString));
         }
 
-        channel.getPipeline().replace(HttpResponseDecoder.class, "ws-decoder",
+        channel.pipeline().replace(HttpResponseDecoder.class, "ws-decoder",
                 new WebSocket13FrameDecoder(false, allowExtensions));
 
         setHandshakeComplete();

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -163,7 +163,7 @@ public ChannelFuture handshake(Channel channel, HttpRequest req) {
         }
 
         // Upgrade the connection and send the handshake response.
-        ChannelPipeline p = channel.getPipeline();
+        ChannelPipeline p = channel.pipeline();
         if (p.get(HttpChunkAggregator.class) != null) {
             p.remove(HttpChunkAggregator.class);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -137,7 +137,7 @@ public ChannelFuture handshake(Channel channel, HttpRequest req) {
         ChannelFuture future = channel.write(res);
 
         // Upgrade the connection and send the handshake response.
-        ChannelPipeline p = channel.getPipeline();
+        ChannelPipeline p = channel.pipeline();
         if (p.get(HttpChunkAggregator.class) != null) {
             p.remove(HttpChunkAggregator.class);
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -138,7 +138,7 @@ public ChannelFuture handshake(Channel channel, HttpRequest req) {
         ChannelFuture future = channel.write(res);
 
         // Upgrade the connection and send the handshake response.
-        ChannelPipeline p = channel.getPipeline();
+        ChannelPipeline p = channel.pipeline();
         if (p.get(HttpChunkAggregator.class) != null) {
             p.remove(HttpChunkAggregator.class);
         }

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspMessageDecoder.java
Patch:
@@ -18,8 +18,8 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
-import io.netty.handler.codec.frame.TooLongFrameException;
 import io.netty.handler.codec.http.HttpChunkAggregator;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpMessageDecoder;

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.rtsp;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpRequest;

File: codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.rtsp;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.http.HttpResponse;

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.frame.FrameDecoder;
+import io.netty.handler.codec.FrameDecoder;
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
Patch:
@@ -24,7 +24,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.Channels;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -55,7 +55,7 @@ public void testPerformOpeningHandshake() {
         Channel channelMock = EasyMock.createMock(Channel.class);
         
         DefaultChannelPipeline pipeline = createPipeline();
-        EasyMock.expect(channelMock.getPipeline()).andReturn(pipeline);
+        EasyMock.expect(channelMock.pipeline()).andReturn(pipeline);
         
         // capture the http response in order to verify the headers
         Capture<HttpResponse> res = new Capture<HttpResponse>();

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
Patch:
@@ -51,7 +51,7 @@ public void testPerformOpeningHandshake() {
         Channel channelMock = EasyMock.createMock(Channel.class);
         
         DefaultChannelPipeline pipeline = createPipeline();
-        EasyMock.expect(channelMock.getPipeline()).andReturn(pipeline);
+        EasyMock.expect(channelMock.pipeline()).andReturn(pipeline);
         
         // capture the http response in order to verify the headers
         Capture<HttpResponse> res = new Capture<HttpResponse>();

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
Patch:
@@ -51,7 +51,7 @@ public void testPerformOpeningHandshake() {
         Channel channelMock = EasyMock.createMock(Channel.class);
 
         DefaultChannelPipeline pipeline = createPipeline();
-        EasyMock.expect(channelMock.getPipeline()).andReturn(pipeline);
+        EasyMock.expect(channelMock.pipeline()).andReturn(pipeline);
 
         // capture the http response in order to verify the headers
         Capture<HttpResponse> res = new Capture<HttpResponse>();

File: codec/src/main/java/io/netty/handler/codec/Delimiters.java
Patch:
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.handler.codec.frame;
+package io.netty.handler.codec;
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;

File: codec/src/main/java/io/netty/handler/codec/TooLongFrameException.java
Patch:
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.handler.codec.frame;
+package io.netty.handler.codec;
 
 /**
  * An {@link Exception} which is thrown when the length of the frame

File: codec/src/main/java/io/netty/handler/codec/embedder/CodecEmbedder.java
Patch:
@@ -95,5 +95,5 @@ public interface CodecEmbedder<E> {
     /**
      * Returns the {@link ChannelPipeline} that handles the input.
      */
-    ChannelPipeline getPipeline();
+    ChannelPipeline pipeline();
 }

File: codec/src/main/java/io/netty/handler/codec/package-info.java
Patch:
@@ -24,4 +24,4 @@
  * @apiviz.exclude \.codec\.[a-eg-z][a-z0-9]*\.
  * @apiviz.exclude \.ssl\.
  */
-package io.netty.handler.codec.frame;
+package io.netty.handler.codec;

File: codec/src/main/java/io/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -29,7 +29,7 @@
 import io.netty.channel.ExceptionEvent;
 import io.netty.channel.MessageEvent;
 import io.netty.channel.SimpleChannelUpstreamHandler;
-import io.netty.handler.codec.frame.FrameDecoder;
+import io.netty.handler.codec.FrameDecoder;
 
 /**
  * A specialized variation of {@link FrameDecoder} which enables implementation

File: codec/src/main/java/io/netty/handler/codec/replay/package-info.java
Patch:
@@ -15,7 +15,7 @@
  */
 
 /**
- * Specialized variation of {@link io.netty.handler.codec.frame.FrameDecoder}
+ * Specialized variation of {@link io.netty.handler.codec.FrameDecoder}
  * which enables implementation of a non-blocking decoder in the blocking I/O
  * paradigm.
  *

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectDecoder.java
Patch:
@@ -22,7 +22,7 @@
 import io.netty.buffer.ChannelBufferInputStream;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;
+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 
 /**
  * A decoder which deserializes the received {@link ChannelBuffer}s into Java

File: codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
Patch:
@@ -23,9 +23,9 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.MessageEvent;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
-import io.netty.handler.codec.frame.FrameDecoder;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
+import io.netty.handler.codec.FrameDecoder;
 import io.netty.handler.codec.oneone.OneToOneDecoder;
 
 /**

File: codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
Patch:
@@ -25,8 +25,8 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.MessageEvent;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.oneone.OneToOneEncoder;
 
 /**

File: codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java
Patch:
@@ -17,6 +17,9 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.embedder.CodecEmbedderException;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 import io.netty.util.CharsetUtil;

File: codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
Patch:
@@ -17,6 +17,8 @@
 
 import io.netty.buffer.ChannelBuffer;
 import io.netty.buffer.ChannelBuffers;
+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.embedder.CodecEmbedderException;
 import io.netty.handler.codec.embedder.DecoderEmbedder;
 import io.netty.util.CharsetUtil;

File: example/src/main/java/io/netty/example/echo/EchoClientHandler.java
Patch:
@@ -52,7 +52,7 @@ public EchoClientHandler(int firstMessageSize) {
 
     @Override
     public ChannelBufferHolder<Byte> newInboundBuffer(ChannelInboundHandlerContext<Byte> ctx) {
-        return ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer());
+        return ChannelBufferHolders.byteBuffer();
     }
 
     @Override

File: example/src/main/java/io/netty/example/echo/EchoServerHandler.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.example.echo;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
 import io.netty.channel.ChannelInboundHandlerAdapter;
@@ -35,7 +34,7 @@ public class EchoServerHandler extends ChannelInboundHandlerAdapter<Byte> {
 
     @Override
     public ChannelBufferHolder<Byte> newInboundBuffer(ChannelInboundHandlerContext<Byte> ctx) {
-        return ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer());
+        return ChannelBufferHolders.byteBuffer();
     }
 
     @Override

File: example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
Patch:
@@ -20,8 +20,8 @@
 import io.netty.buffer.ChannelBuffer;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.frame.CorruptedFrameException;
-import io.netty.handler.codec.frame.FrameDecoder;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.FrameDecoder;
 
 /**
  * Decodes the binary representation of a {@link BigInteger} prepended

File: example/src/main/java/io/netty/example/factorial/FactorialClient.java
Patch:
@@ -57,7 +57,7 @@ public void run() {
 
         // Get the handler instance to retrieve the answer.
         FactorialClientHandler handler =
-            (FactorialClientHandler) channel.getPipeline().last();
+            (FactorialClientHandler) channel.pipeline().last();
 
         // Print out the answer.
         System.err.format(

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -46,7 +46,7 @@
 import io.netty.channel.FileRegion;
 import io.netty.channel.MessageEvent;
 import io.netty.channel.SimpleChannelUpstreamHandler;
-import io.netty.handler.codec.frame.TooLongFrameException;
+import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
@@ -171,7 +171,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
 
         // Write the content.
         ChannelFuture writeFuture;
-        if (ch.getPipeline().get(SslHandler.class) != null) {
+        if (ch.pipeline().get(SslHandler.class) != null) {
             // Cannot use zero-copy with HTTPS.
             writeFuture = ch.write(new ChunkedFile(raf, 0, fileLength, 8192));
         } else {

File: example/src/main/java/io/netty/example/local/LocalExample.java
Patch:
@@ -52,7 +52,7 @@ public void run() throws IOException {
 
         // Set up the default server-side event pipeline.
         EchoServerHandler handler = new EchoServerHandler();
-        sb.getPipeline().addLast("handler", handler);
+        sb.pipeline().addLast("handler", handler);
 
         // Start up the server.
         sb.bind(socketAddress);

File: example/src/main/java/io/netty/example/localtime/LocalTimeClient.java
Patch:
@@ -62,7 +62,7 @@ public void run() {
 
         // Get the handler instance to initiate the request.
         LocalTimeClientHandler handler =
-            channel.getPipeline().get(LocalTimeClientHandler.class);
+            channel.pipeline().get(LocalTimeClientHandler.class);
 
         // Request and get the response.
         List<String> response = handler.getLocalTimes(cities);

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyInboundHandler.java
Patch:
@@ -59,7 +59,7 @@ public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e)
 
         // Start the connection attempt.
         ClientBootstrap cb = new ClientBootstrap(cf);
-        cb.getPipeline().addLast("handler", new OutboundHandler(e.channel()));
+        cb.pipeline().addLast("handler", new OutboundHandler(e.channel()));
         ChannelFuture f = cb.connect(new InetSocketAddress(remoteHost, remotePort));
 
         outboundChannel = f.channel();

File: example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
Patch:
@@ -48,7 +48,7 @@ public void channelConnected(
             ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
         // Get the SslHandler from the pipeline
         // which were added in SecureChatPipelineFactory.
-        SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
+        SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
 
         // Begin handshake.
         sslHandler.handshake();

File: example/src/main/java/io/netty/example/securechat/SecureChatClientPipelineFactory.java
Patch:
@@ -21,8 +21,8 @@
 
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPipelineFactory;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 import io.netty.handler.ssl.SslHandler;

File: example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
Patch:
@@ -57,7 +57,7 @@ public void channelConnected(
 
         // Get the SslHandler in the current pipeline.
         // We added it in SecureChatPipelineFactory.
-        final SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
+        final SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
 
         // Get notified when SSL handshake is done.
         ChannelFuture handshakeFuture = sslHandler.handshake();

File: example/src/main/java/io/netty/example/securechat/SecureChatServerPipelineFactory.java
Patch:
@@ -21,8 +21,8 @@
 
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPipelineFactory;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 import io.netty.handler.ssl.SslHandler;

File: example/src/main/java/io/netty/example/stdio/StdioLogger.java
Patch:
@@ -29,8 +29,8 @@
 import io.netty.channel.SimpleChannelHandler;
 import io.netty.channel.iostream.IoStreamAddress;
 import io.netty.channel.iostream.IoStreamChannelFactory;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 

File: example/src/main/java/io/netty/example/telnet/TelnetClientPipelineFactory.java
Patch:
@@ -19,8 +19,8 @@
 
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPipelineFactory;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 

File: example/src/main/java/io/netty/example/telnet/TelnetServerPipelineFactory.java
Patch:
@@ -19,8 +19,8 @@
 
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPipelineFactory;
-import io.netty.handler.codec.frame.DelimiterBasedFrameDecoder;
-import io.netty.handler.codec.frame.Delimiters;
+import io.netty.handler.codec.DelimiterBasedFrameDecoder;
+import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -47,7 +47,7 @@
 import io.netty.channel.ExceptionEvent;
 import io.netty.channel.LifeCycleAwareChannelHandler;
 import io.netty.channel.MessageEvent;
-import io.netty.handler.codec.frame.FrameDecoder;
+import io.netty.handler.codec.FrameDecoder;
 import io.netty.logging.InternalLogger;
 import io.netty.logging.InternalLoggerFactory;
 import io.netty.util.internal.NonReentrantLock;

File: handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -224,7 +224,7 @@ public void releaseExternalResources() {
 
     @Override
     public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
-        if (ctx.getPipeline().isAttached()) {
+        if (ctx.pipeline().isAttached()) {
             // channelOpen event has been fired already, which means
             // this.channelOpen() will not be invoked.
             // We have to initialize here instead.

File: handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -138,7 +138,7 @@ public void releaseExternalResources() {
 
     @Override
     public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
-        if (ctx.getPipeline().isAttached()) {
+        if (ctx.pipeline().isAttached()) {
             // channelOpen event has been fired already, which means
             // this.channelOpen() will not be invoked.
             // We have to initialize here instead.

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java
Patch:
@@ -68,8 +68,8 @@ public void testMulticast() throws Throwable {
         ConnectionlessBootstrap cb = new ConnectionlessBootstrap(newClientSocketChannelFactory(executor));
         MulticastTestHandler mhandler = new MulticastTestHandler();
         
-        cb.getPipeline().addFirst("handler", mhandler);
-        sb.getPipeline().addFirst("handler", new SimpleChannelUpstreamHandler());
+        cb.pipeline().addFirst("handler", mhandler);
+        sb.pipeline().addFirst("handler", new SimpleChannelUpstreamHandler());
 
         int port = TestUtils.getFreePort();
         

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java
Patch:
@@ -63,7 +63,7 @@ public void testSimpleSend() throws Throwable {
         ConnectionlessBootstrap cb = new ConnectionlessBootstrap(newClientSocketChannelFactory(executor));
 
         final CountDownLatch latch = new CountDownLatch(1);
-        sb.getPipeline().addFirst("handler", new SimpleChannelUpstreamHandler() {
+        sb.pipeline().addFirst("handler", new SimpleChannelUpstreamHandler() {
 
             @Override
             public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
@@ -74,7 +74,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
             }
             
         });
-        cb.getPipeline().addFirst("handler", new SimpleChannelUpstreamHandler());
+        cb.pipeline().addFirst("handler", new SimpleChannelUpstreamHandler());
 
         Channel sc = sb.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
 

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketEchoTest.java
Patch:
@@ -75,8 +75,8 @@ public void testSimpleEcho() throws Throwable {
         EchoHandler sh = new EchoHandler();
         EchoHandler ch = new EchoHandler();
 
-        sb.getPipeline().addFirst("handler", sh);
-        cb.getPipeline().addFirst("handler", ch);
+        sb.pipeline().addFirst("handler", sh);
+        cb.pipeline().addFirst("handler", ch);
 
         Channel sc = sb.bind(new InetSocketAddress(0));
         int port = ((InetSocketAddress) sc.getLocalAddress()).getPort();

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketServerBootstrapTest.java
Patch:
@@ -121,11 +121,11 @@ public void testSuccessfulBindAttempt() throws Exception {
         bootstrap.setOption("child.receiveBufferSize", 9753);
         bootstrap.setOption("child.sendBufferSize", 8642);
 
-        bootstrap.getPipeline().addLast("dummy", new DummyHandler());
+        bootstrap.pipeline().addLast("dummy", new DummyHandler());
 
         Channel channel = bootstrap.bind();
         ParentChannelHandler pch =
-            channel.getPipeline().get(ParentChannelHandler.class);
+            channel.pipeline().get(ParentChannelHandler.class);
 
         Socket socket = null;
         try {
@@ -183,7 +183,7 @@ public void testFailedPipelineInitialization() throws Exception {
         ChannelPipelineFactory pipelineFactory = EasyMock.createMock(ChannelPipelineFactory.class);
         bootstrap.setPipelineFactory(pipelineFactory);
 
-        EasyMock.expect(pipelineFactory.getPipeline()).andThrow(new ChannelPipelineException());
+        EasyMock.expect(pipelineFactory.pipeline()).andThrow(new ChannelPipelineException());
         EasyMock.replay(pipelineFactory);
 
         bootstrap.connect(new InetSocketAddress(SocketAddresses.LOCALHOST, 1));

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/NioClientSocketShutdownTimeTest.java
Patch:
@@ -39,7 +39,7 @@ public void testShutdownTime() throws Throwable {
 
         ClientBootstrap b = new ClientBootstrap(
                 new NioClientSocketChannelFactory(Executors.newCachedThreadPool()));
-        b.getPipeline().addLast("handler", new DummyHandler());
+        b.pipeline().addLast("handler", new DummyHandler());
 
         long startTime;
         long stopTime;

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/NioServerSocketShutdownTimeTest.java
Patch:
@@ -43,7 +43,7 @@ public void testSuccessfulBindAttempt() throws Exception {
         bootstrap.setOption("child.sendBufferSize", 8642);
 
         DummyHandler handler = new DummyHandler();
-        bootstrap.getPipeline().addLast("dummy", handler);
+        bootstrap.pipeline().addLast("dummy", handler);
 
         Channel channel = bootstrap.bind();
 

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientChannel.java
Patch:
@@ -232,7 +232,7 @@ private ChannelPipeline createPollPipeline() {
 
     void setTunnelIdForPollChannel() {
         HttpTunnelClientPollHandler pollHandler =
-                pollChannel.getPipeline()
+                pollChannel.pipeline()
                         .get(HttpTunnelClientPollHandler.class);
         pollHandler.setTunnelId(tunnelId);
     }

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelServerChannel.java
Patch:
@@ -61,7 +61,7 @@ private HttpTunnelServerChannel(HttpTunnelServerChannelFactory factory,
         realChannel = factory.createRealChannel(this, messageSwitch);
         // TODO fix calling of overrideable getPipeline() from constructor
         HttpTunnelServerChannelSink sink =
-                (HttpTunnelServerChannelSink) getPipeline().getSink();
+                (HttpTunnelServerChannelSink) pipeline().getSink();
         sink.setRealChannel(realChannel);
         sink.setCloseListener(CLOSE_FUTURE_PROXY);
         config = new HttpTunnelServerChannelConfig(realChannel);
@@ -107,7 +107,7 @@ public HttpTunnelAcceptedChannelReceiver newChannel(
                 String newTunnelId, InetSocketAddress remoteAddress) {
             ChannelPipeline childPipeline = null;
             try {
-                childPipeline = getConfig().getPipelineFactory().getPipeline();
+                childPipeline = getConfig().getPipelineFactory().pipeline();
             } catch (Exception e) {
                 throw new ChannelPipelineException(
                         "Failed to initialize a pipeline.", e);

File: transport-http/src/test/java/io/netty/channel/socket/http/FakeServerSocketChannel.java
Patch:
@@ -79,7 +79,7 @@ public boolean isConnected() {
     public FakeSocketChannel acceptNewConnection(
             InetSocketAddress remoteAddress, ChannelSink sink) throws Exception {
         ChannelPipeline newPipeline =
-                getConfig().getPipelineFactory().getPipeline();
+                getConfig().getPipelineFactory().pipeline();
         FakeSocketChannel newChannel =
                 new FakeSocketChannel(this, getFactory(), newPipeline, sink);
         newChannel.localAddress = localAddress;

File: transport-http/src/test/java/io/netty/channel/socket/http/HttpTunnelServerChannelFactoryTest.java
Patch:
@@ -68,7 +68,7 @@ public void testNewChannel() {
         ChannelPipeline pipeline = Channels.pipeline();
         HttpTunnelServerChannel newChannel = factory.newChannel(pipeline);
         assertNotNull(newChannel);
-        assertSame(pipeline, newChannel.getPipeline());
+        assertSame(pipeline, newChannel.pipeline());
     }
 
     @Test

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelImpl.java
Patch:
@@ -161,14 +161,14 @@ public Set<InetSocketAddress> getAllRemoteAddresses() {
     @Override
     public ChannelFuture bindAddress(InetAddress localAddress) {
         ChannelFuture future = future(this);
-        getPipeline().sendDownstream(new SctpBindAddressEvent(this, future, localAddress));
+        pipeline().sendDownstream(new SctpBindAddressEvent(this, future, localAddress));
         return future;
     }
 
     @Override
     public ChannelFuture unbindAddress(InetAddress localAddress) {
         ChannelFuture future = future(this);
-        getPipeline().sendDownstream(new SctpUnbindAddressEvent(this, future, localAddress));
+        pipeline().sendDownstream(new SctpUnbindAddressEvent(this, future, localAddress));
         return future;
     }
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java
Patch:
@@ -36,7 +36,7 @@ class SctpNotificationHandler extends AbstractNotificationHandler<Object> {
 
     SctpNotificationHandler(SctpChannelImpl sctpChannel) {
         this.sctpChannel = sctpChannel;
-        pipeline = sctpChannel.getPipeline();
+        pipeline = sctpChannel.pipeline();
     }
 
     @Override

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelImpl.java
Patch:
@@ -91,14 +91,14 @@ class SctpServerChannelImpl extends AbstractServerChannel
     @Override
     public ChannelFuture bindAddress(InetAddress localAddress) {
         ChannelFuture future = future(this);
-        getPipeline().sendDownstream(new SctpBindAddressEvent(this, future, localAddress));
+        pipeline().sendDownstream(new SctpBindAddressEvent(this, future, localAddress));
         return future;
     }
 
     @Override
     public ChannelFuture unbindAddress(InetAddress localAddress) {
         ChannelFuture future = future(this);
-        getPipeline().sendDownstream(new SctpUnbindAddressEvent(this, future, localAddress));
+        pipeline().sendDownstream(new SctpUnbindAddressEvent(this, future, localAddress));
         return future;
     }
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java
Patch:
@@ -133,9 +133,9 @@ protected boolean accept(SelectionKey key) {
             if (acceptedSocket != null) {
                 
                 ChannelPipeline pipeline =
-                        channel.getConfig().getPipelineFactory().getPipeline();
+                        channel.getConfig().getPipelineFactory().pipeline();
                 registerTask(new SctpAcceptedChannel(channel.getFactory(), pipeline, channel,
-                        channel.getPipeline().getSink(), acceptedSocket, this), null);
+                        channel.pipeline().getSink(), acceptedSocket, this), null);
                 return true;
             }
             return false;

File: transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java
Patch:
@@ -118,11 +118,11 @@ public void testSuccessfulBindAttempt() throws Exception {
         bootstrap.setOption("child.receiveBufferSize", 9753);
         bootstrap.setOption("child.sendBufferSize", 8642);
 
-        bootstrap.getPipeline().addLast("dummy", new DummyHandler());
+        bootstrap.pipeline().addLast("dummy", new DummyHandler());
 
         Channel channel = bootstrap.bind();
         ParentChannelHandler pch =
-            channel.getPipeline().get(ParentChannelHandler.class);
+            channel.pipeline().get(ParentChannelHandler.class);
 
         SctpChannel sctpChannel = SctpChannel.open();
         try {
@@ -183,7 +183,7 @@ public void testFailedPipelineInitialization() throws Exception {
         ChannelPipelineFactory pipelineFactory = EasyMock.createMock(ChannelPipelineFactory.class);
         bootstrap.setPipelineFactory(pipelineFactory);
 
-        EasyMock.expect(pipelineFactory.getPipeline()).andThrow(new ChannelPipelineException());
+        EasyMock.expect(pipelineFactory.pipeline()).andThrow(new ChannelPipelineException());
         EasyMock.replay(pipelineFactory);
 
         bootstrap.connect(new InetSocketAddress(SctpTestUtil.LOOP_BACK, 1));

File: transport-sctp/src/test/java/io/netty/testsuite/transport/sctp/SctpMultiStreamingEchoTest.java
Patch:
@@ -92,9 +92,9 @@ public void testMultiStreamingEcho() throws Throwable {
         EchoHandler sh = new EchoHandler();
         EchoHandler ch = new EchoHandler();
 
-        sb.getPipeline().addLast("handler", sh);
+        sb.pipeline().addLast("handler", sh);
 
-        cb.getPipeline().addLast("handler", ch);
+        cb.pipeline().addLast("handler", ch);
 
         Channel sc = sb.bind(new InetSocketAddress(SctpTestUtil.LOOP_BACK, 0));
         int port = ((InetSocketAddress) sc.getLocalAddress()).getPort();

File: transport/src/main/java/io/netty/channel/ServerChannelBootstrap.java
Patch:
@@ -7,7 +7,6 @@
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.nio.channels.ClosedChannelException;
-import java.util.ArrayDeque;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -166,7 +165,7 @@ private void validate() {
     private class Acceptor extends ChannelInboundHandlerAdapter<Channel> {
         @Override
         public ChannelBufferHolder<Channel> newInboundBuffer(ChannelInboundHandlerContext<Channel> ctx) {
-            return ChannelBufferHolders.messageBuffer(new ArrayDeque<Channel>());
+            return ChannelBufferHolders.messageBuffer();
         }
 
         @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -16,7 +16,6 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.buffer.ChannelBuffer;
-import io.netty.buffer.ChannelBuffers;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelBufferHolder;
 import io.netty.channel.ChannelBufferHolders;
@@ -36,7 +35,7 @@ public class NioSocketChannel extends AbstractNioChannel implements io.netty.cha
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSocketChannel.class);
 
     private final SocketChannelConfig config;
-    private final ChannelBufferHolder<?> out = ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer());
+    private final ChannelBufferHolder<?> out = ChannelBufferHolders.byteBuffer();
 
     private static SocketChannel newSocket() {
         try {

File: transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -143,7 +143,7 @@ public ChannelPipeline addFirst(ChannelHandler... handlers) {
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
-        if (handlers[0] == null) {
+        if (handlers.length == 0 || handlers[0] == null) {
             return this;
         }
 

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -105,10 +105,10 @@ public ChannelPipeline getPipeline() throws Exception {
             ChannelFuture future =
                     bootstrap.connect(
                             new InetSocketAddress(uri.getHost(), uri.getPort()));
-            future.awaitUninterruptibly().rethrowIfFailed();
+            future.awaitUninterruptibly().sync();
     
             ch = future.channel();
-            handshaker.handshake(ch).awaitUninterruptibly().rethrowIfFailed();
+            handshaker.handshake(ch).awaitUninterruptibly().sync();
             
             // Send 10 messages and wait for responses
             System.out.println("WebSocket Client sending message");

File: example/src/main/java/io/netty/example/redis/RedisClient.java
Patch:
@@ -52,7 +52,7 @@ public ChannelPipeline getPipeline() throws Exception {
             }
         });
         ChannelFuture redis = cb.connect(new InetSocketAddress("localhost", 6379));
-        redis.await().rethrowIfFailed();
+        redis.await().sync();
         Channel channel = redis.channel();
 
         channel.write(new Command("set", "1", "value"));

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -367,7 +367,7 @@ public void register(EventLoop eventLoop, ChannelFuture future) {
             if (eventLoop == null) {
                 throw new NullPointerException("eventLoop");
             }
-            if (AbstractChannel.this.eventLoop != null) {
+            if (isRegistered()) {
                 throw new IllegalStateException("registered to an event loop already");
             }
             if (!isCompatible(eventLoop)) {
@@ -581,10 +581,9 @@ public void deregister(final ChannelFuture future) {
                 } catch (Throwable t) {
                     logger.warn("Unexpected exception occurred while deregistering a channel.", t);
                 } finally {
-                    future.setSuccess();
                     registered = false;
+                    future.setSuccess();
                     pipeline().fireChannelUnregistered();
-                    eventLoop = null;
                 }
             } else {
                 eventLoop().execute(new Runnable() {

File: transport/src/main/java/io/netty/channel/ChannelFutureListener.java
Patch:
@@ -39,7 +39,7 @@ public interface ChannelFutureListener extends EventListener {
     ChannelFutureListener CLOSE = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) {
-            future.channel().close(null);
+            future.channel().close();
         }
     };
 
@@ -51,7 +51,7 @@ public void operationComplete(ChannelFuture future) {
         @Override
         public void operationComplete(ChannelFuture future) {
             if (!future.isSuccess()) {
-                future.channel().close(null);
+                future.channel().close();
             }
         }
     };

File: transport/src/main/java/io/netty/channel/ChannelHandler.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.netty.channel;
 
-import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.group.ChannelGroup;
 
 import java.lang.annotation.Documented;
@@ -24,6 +23,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.nio.channels.Channels;
 
 /**
  * Handles or intercepts a {@link ChannelEvent}, and sends a

File: transport/src/main/java/io/netty/channel/ChannelOption.java
Patch:
@@ -9,6 +9,8 @@
 
 public class ChannelOption<T> implements Comparable<ChannelOption<T>> {
 
+    private static final ConcurrentMap<String, Boolean> names = new ConcurrentHashMap<String, Boolean>();
+
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS =
             new ChannelOption<Integer>("CONNECT_TIMEOUT_MILLIS", Integer.class);
     public static final ChannelOption<Integer> WRITE_SPIN_COUNT =
@@ -73,8 +75,6 @@ public void validate(List<Integer> value) {
     public static final ChannelOption<SocketAddress> SCTP_SET_PEER_PRIMARY_ADDR =
             new ChannelOption<SocketAddress>("SCTP_SET_PEER_PRIMARY_ADDR", SocketAddress.class);
 
-    private static final ConcurrentMap<String, Boolean> names = new ConcurrentHashMap<String, Boolean>();
-
     private final String name;
     private final Class<T> valueType;
     private final String strVal;

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -35,7 +35,7 @@ public abstract class WebSocketClientHandshaker {
 
     private final String expectedSubprotocol;
 
-    private String actualSubprotocol = null;
+    private String actualSubprotocol;
 
     protected final Map<String, String> customHeaders;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -35,7 +35,7 @@ public abstract class WebSocketServerHandshaker {
 
     private final long maxFramePayloadLength;
 
-    private String selectedSubprotocol = null;
+    private String selectedSubprotocol;
 
     /**
      * Constructor using default values

File: transport/src/main/java/io/netty/channel/Channel.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioSocketChannelConfig;
 import io.netty.util.AttributeMap;
 
 import java.net.InetSocketAddress;

File: transport/src/main/java/io/netty/channel/ChannelFuture.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.channel;
 
-import java.util.concurrent.TimeUnit;
-
 import io.netty.bootstrap.ClientBootstrap;
 
+import java.util.concurrent.TimeUnit;
+
 /**
  * The result of an asynchronous {@link Channel} I/O operation.
  * <p>

File: transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
Patch:
@@ -15,10 +15,10 @@
  */
 package io.netty.channel.socket;
 
-import java.net.Socket;
-
 import io.netty.channel.ChannelConfig;
 
+import java.net.Socket;
+
 /**
  * A {@link ChannelConfig} for a {@link SocketChannel}.
  *

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java
Patch:
@@ -87,6 +87,6 @@ protected void doRegister() throws Exception {
         }
 
         SelectorEventLoop loop = (SelectorEventLoop) eventLoop();
-        selectionKey = javaChannel().register(loop.selector, SelectionKey.OP_READ, this);
+        selectionKey = javaChannel().register(loop.selector, isActive()? SelectionKey.OP_READ : 0, this);
     }
 }

File: transport/src/main/java/io/netty/channel/AbstractChannel.java
Patch:
@@ -612,7 +612,6 @@ public void run() {
         @Override
         public void read() {
             assert eventLoop().inEventLoop();
-            // FIXME: Wrap with a loop
             long readAmount = 0;
             try {
                 boolean closed = false;

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -82,10 +82,10 @@ protected SocketChannel javaChannel() {
 
     @Override
     public boolean isActive() {
-        return javaChannel().isConnected();
+        SocketChannel ch = javaChannel();
+        return ch.isOpen() && ch.isConnected();
     }
 
-
     @Override
     @SuppressWarnings("unchecked")
     protected ChannelBufferHolder<Object> firstOut() {

File: example/src/main/java/io/netty/example/echo/EchoServer.java
Patch:
@@ -88,7 +88,7 @@ public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx) {
         });
 
         loop.register(ssc).awaitUninterruptibly().rethrowIfFailed();
-        ssc.bind(new InetSocketAddress(port), ssc.newFuture());
+        ssc.bind(new InetSocketAddress(port), ssc.newFuture()).awaitUninterruptibly().rethrowIfFailed();
     }
 
     public static void main(String[] args) throws Exception {

File: transport/src/main/java/io/netty/channel/DefaultChannelFuture.java
Patch:
@@ -190,7 +190,7 @@ public void removeListener(ChannelFutureListener listener) {
     @Override
     public ChannelFuture rethrowIfFailed() throws Exception {
         if (!isDone()) {
-            return this;
+            throw new IllegalStateException("not done yet");
         }
 
         Throwable cause = cause();

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java
Patch:
@@ -87,6 +87,6 @@ protected void doRegister() throws Exception {
         }
 
         SelectorEventLoop loop = (SelectorEventLoop) eventLoop();
-        selectionKey = javaChannel().register(loop.selector, javaChannel().validOps() & ~SelectionKey.OP_WRITE, this);
+        selectionKey = javaChannel().register(loop.selector, SelectionKey.OP_READ, this);
     }
 }

File: transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -116,6 +116,9 @@ protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddr
         boolean success = false;
         try {
             boolean connected = javaChannel().connect(remoteAddress);
+            if (!connected) {
+                selectionKey().interestOps(selectionKey().interestOps() | SelectionKey.OP_CONNECT);
+            }
             success = true;
             return connected;
         } finally {

File: transport/src/main/java/io/netty/channel/socket/nio/SelectorEventLoop.java
Patch:
@@ -55,6 +55,7 @@ public class SelectorEventLoop extends SingleThreadEventLoop {
      */
     protected final AtomicBoolean wakenUp = new AtomicBoolean();
 
+    // FIXME: It's not being increased by any channel implementations but we have to.
     private volatile int cancelledKeys; // should use AtomicInteger but we just need approximation
 
     public SelectorEventLoop() {
@@ -199,7 +200,6 @@ private void processSelectedKeys(Set<SelectionKey> selectedKeys) throws IOExcept
                 if ((readyOps & SelectionKey.OP_WRITE) != 0) {
                     ch.unsafe().flush(null);
                 }
-
                 if ((readyOps & SelectionKey.OP_ACCEPT) != 0) {
                     ch.unsafe().read();
                 }

File: transport/src/main/java/io/netty/channel/ChannelFutureFactory.java
Patch:
@@ -4,4 +4,5 @@ public interface ChannelFutureFactory {
     ChannelFuture newFuture();
     ChannelFuture newSucceededFuture();
     ChannelFuture newFailedFuture(Throwable cause);
+    ChannelFuture newVoidFuture();
 }

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -122,7 +122,9 @@
  * pipeline,  and how to handle the event in your application.
  * @apiviz.owns io.netty.channel.ChannelHandler
  */
-public interface ChannelHandlerContext extends AttributeMap, ChannelHandlerInvoker, ChannelFutureFactory {
+public interface ChannelHandlerContext
+         extends AttributeMap, ChannelFutureFactory,
+                 ChannelInboundInvoker, ChannelOutboundInvoker {
     Channel channel();
     ChannelPipeline pipeline();
 

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandlerContext.java
Patch:
@@ -2,5 +2,5 @@
 
 
 public interface ChannelOutboundHandlerContext<O> extends ChannelHandlerContext {
-    ChannelBufferHolder<O> out();
+    ChannelBufferHolder<O> prevOut();
 }

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.nio.channels.Channels;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
@@ -202,7 +203,7 @@
  * @apiviz.owns       io.netty.channel.ChannelHandler
  * @apiviz.uses       io.netty.channel.ChannelSink - - sends events downstream
  */
-public interface ChannelPipeline extends ChannelHandlerInvoker {
+public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker {
 
     /**
      * Inserts a {@link ChannelHandler} at the first position of this pipeline.

File: transport/src/main/java/io/netty/channel/EventLoop.java
Patch:
@@ -4,6 +4,6 @@
 
 public interface EventLoop extends ExecutorService {
     ChannelFuture register(Channel channel);
-    EventLoop register(Channel channel, ChannelFuture future);
+    ChannelFuture register(Channel channel, ChannelFuture future);
     boolean inEventLoop();
 }

File: transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
Patch:
@@ -51,13 +51,13 @@ public void run() {
 
     @Override
     public ChannelFuture register(Channel channel) {
-        ChannelFuture future = new DefaultChannelFuture(channel, false);
+        ChannelFuture future = channel.newFuture();
         register(channel, future);
         return future;
     }
 
     @Override
-    public EventLoop register(final Channel channel, final ChannelFuture future) {
+    public ChannelFuture register(final Channel channel, final ChannelFuture future) {
         if (inEventLoop()) {
             channel.unsafe().register(this, future);
         } else {
@@ -68,7 +68,7 @@ public void run() {
                 }
             });
         }
-        return this;
+        return future;
     }
 
     protected void interruptThread() {

File: transport/src/main/java/io/netty/channel/socket/DatagramChannel.java
Patch:
@@ -45,6 +45,8 @@ public interface DatagramChannel extends Channel {
      */
     void joinGroup(InetSocketAddress multicastAddress, NetworkInterface networkInterface, ChannelFuture future);
 
+    void joinGroup(InetAddress multicastAddress, NetworkInterface networkInterface, InetAddress source, ChannelFuture future);
+
     /**
      * Leaves a multicast group.
      */

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -77,7 +77,7 @@ public class ChunkedWriteHandler implements ChannelUpstreamHandler, ChannelDowns
 
     private final Queue<MessageEvent> queue = QueueFactory.createQueue(MessageEvent.class);
 
-    private ChannelHandlerContext ctx;
+    private volatile ChannelHandlerContext ctx;
     private MessageEvent currentEvent;
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -851,7 +851,7 @@ void skipControlCharacters() {
         }
 
         while (sao.pos < sao.limit) {
-            char c = (char) ()sao.bytes[sao.pos ++] & 0xFF);
+            char c = (char) (sao.bytes[sao.pos ++] & 0xFF);
             if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
                 sao.setReadPosition(1);
                 return;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -851,7 +851,7 @@ void skipControlCharacters() {
         }
 
         while (sao.pos < sao.limit) {
-            char c = (char) ()sao.bytes[sao.pos ++] & 0xFF);
+            char c = (char) (sao.bytes[sao.pos ++] & 0xFF);
             if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
                 sao.setReadPosition(1);
                 return;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -851,7 +851,7 @@ void skipControlCharacters() {
         }
 
         while (sao.pos < sao.limit) {
-            char c = (char) sao.bytes[sao.pos ++];
+            char c = (char) ()sao.bytes[sao.pos ++] & 0xFF);
             if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
                 sao.setReadPosition(1);
                 return;

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -851,7 +851,7 @@ void skipControlCharacters() {
         }
 
         while (sao.pos < sao.limit) {
-            char c = (char) sao.bytes[sao.pos ++];
+            char c = (char) ()sao.bytes[sao.pos ++] & 0xFF);
             if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
                 sao.setReadPosition(1);
                 return;

File: codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java
Patch:
@@ -212,8 +212,8 @@ public boolean renameTo(File dest) throws IOException {
         int written = 0;
         while (written < length) {
             written += fileChannel.write(byteBuffer);
-            fileChannel.force(false);
         }
+        fileChannel.force(false);
         fileChannel.close();
         isRenamed = true;
         return written == length;

File: codec-http/src/main/java/io/netty/handler/codec/http/MixedAttribute.java
Patch:
@@ -65,7 +65,7 @@ public void addContent(ChannelBuffer buffer, boolean last) throws IOException {
                         .getName());
                 if (((MemoryAttribute) attribute).getChannelBuffer() != null) {
                     diskAttribute.addContent(((MemoryAttribute) attribute)
-                        .getChannelBuffer(), last);
+                        .getChannelBuffer(), false);
                 }
                 attribute = diskAttribute;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/MixedFileUpload.java
Patch:
@@ -58,7 +58,7 @@ public void addContent(ChannelBuffer buffer, boolean last)
                         definedSize);
                 if (((MemoryFileUpload) fileUpload).getChannelBuffer() != null) {
                     diskFileUpload.addContent(((MemoryFileUpload) fileUpload)
-                        .getChannelBuffer(), last);
+                        .getChannelBuffer(), false);
                 }
                 fileUpload = diskFileUpload;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -91,7 +91,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             //       No need to notify the upstream handlers - just log.
             //       If decoding a response, just throw an exception.
             if (is100ContinueExpected(m)) {
-                write(ctx, succeededFuture(ctx.getChannel()), CONTINUE.duplicate());
+                write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());
             }
 
             if (m.isChunked()) {
@@ -103,7 +103,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                     m.removeHeader(HttpHeaders.Names.TRANSFER_ENCODING);
                 }
                 m.setChunked(false);
-                m.setContent(ChannelBuffers.dynamicBuffer(e.getChannel().getConfig().getBufferFactory()));
+                m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));
                 this.currentMessage = m;
             } else {
                 // Not a chunked message - pass through.

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -154,7 +154,7 @@ public void writeRequested(ChannelHandlerContext ctx, MessageEvent e)
                     // the last product on closure,
                     if (lastProduct.readable()) {
                         Channels.write(
-                                ctx, Channels.succeededFuture(e.getChannel()), new DefaultHttpChunk(lastProduct), e.getRemoteAddress());
+                                ctx, Channels.succeededFuture(e.channel()), new DefaultHttpChunk(lastProduct), e.getRemoteAddress());
                     }
 
                     // Emit the last chunk.

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
Patch:
@@ -170,7 +170,7 @@ public void handleDownstream(ChannelHandlerContext ctx, ChannelEvent evt)
                     }
 
                     // Write HEADERS frame and append Data Frame
-                    ChannelFuture future = Channels.future(e.getChannel());
+                    ChannelFuture future = Channels.future(e.channel());
                     future.addListener(new SpdyFrameWriter(ctx, e, spdyDataFrame));
                     Channels.write(ctx, future, spdyHeadersFrame, e.getRemoteAddress());
                 }
@@ -195,7 +195,7 @@ private ChannelFuture getContentFuture(
         spdyDataFrame.setLast(true);
 
         // Create new future and add listener
-        ChannelFuture future = Channels.future(e.getChannel());
+        ChannelFuture future = Channels.future(e.channel());
         future.addListener(new SpdyFrameWriter(ctx, e, spdyDataFrame));
 
         return future;
@@ -219,7 +219,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
             } else if (future.isCancelled()) {
                 e.getFuture().cancel();
             } else {
-                e.getFuture().setFailure(future.getCause());
+                e.getFuture().setFailure(future.cause());
             }
         }
     }

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
Patch:
@@ -112,7 +112,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
                 byte[] out = new byte[in.length << 1];
                 ChannelBuffer decompressed = ChannelBuffers.dynamicBuffer(
                         compressed.order(), out.length,
-                        ctx.getChannel().getConfig().getBufferFactory());
+                        ctx.channel().getConfig().getBufferFactory());
                 z.next_out = out;
                 z.next_out_index = 0;
                 z.avail_out = out.length;

File: codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java
Patch:
@@ -209,7 +209,7 @@ private void handleEvent(ChannelEvent e) {
                 boolean offered = productQueue.offer(((MessageEvent) e).getMessage());
                 assert offered;
             } else if (e instanceof ExceptionEvent) {
-                throw new CodecEmbedderException(((ExceptionEvent) e).getCause());
+                throw new CodecEmbedderException(((ExceptionEvent) e).cause());
             }
 
             // Swallow otherwise.
@@ -231,9 +231,9 @@ public void exceptionCaught(
         public ChannelFuture execute(ChannelPipeline pipeline, Runnable task) {
             try {
                 task.run();
-                return Channels.succeededFuture(pipeline.getChannel());
+                return Channels.succeededFuture(pipeline.channel());
             } catch (Throwable t) {
-                return Channels.failedFuture(pipeline.getChannel(), t);
+                return Channels.failedFuture(pipeline.channel(), t);
             }
         }
     }

File: codec/src/main/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java
Patch:
@@ -257,13 +257,13 @@ protected Object decode(
     private void fail(ChannelHandlerContext ctx, long frameLength) {
         if (frameLength > 0) {
             Channels.fireExceptionCaught(
-                    ctx.getChannel(),
+                    ctx.channel(),
                     new TooLongFrameException(
                             "frame length exceeds " + maxFrameLength +
                             ": " + frameLength + " - discarded"));
         } else {
             Channels.fireExceptionCaught(
-                    ctx.getChannel(),
+                    ctx.channel(),
                     new TooLongFrameException(
                             "frame length exceeds " + maxFrameLength +
                             " - discarding"));

File: codec/src/main/java/io/netty/handler/codec/frame/FixedLengthFrameDecoder.java
Patch:
@@ -76,10 +76,10 @@ protected Object decode(
 
     @Override
     protected ChannelBuffer newCumulationBuffer(ChannelHandlerContext ctx, int minimumCapacity) {
-        ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();
+        ChannelBufferFactory factory = ctx.channel().getConfig().getBufferFactory();
         if (allocateFullBuffer) {
             return ChannelBuffers.dynamicBuffer(
-                    factory.getDefaultOrder(), frameLength, ctx.getChannel().getConfig().getBufferFactory());
+                    factory.getDefaultOrder(), frameLength, ctx.channel().getConfig().getBufferFactory());
         }
         return super.newCumulationBuffer(ctx, minimumCapacity);
     }

File: codec/src/main/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoder.java
Patch:
@@ -439,13 +439,13 @@ protected ChannelBuffer extractFrame(ChannelBuffer buffer, int index, int length
     private void fail(ChannelHandlerContext ctx, long frameLength) {
         if (frameLength > 0) {
             Channels.fireExceptionCaught(
-                    ctx.getChannel(),
+                    ctx.channel(),
                     new TooLongFrameException(
                             "Adjusted frame length exceeds " + maxFrameLength +
                             ": " + frameLength + " - discarded"));
         } else {
             Channels.fireExceptionCaught(
-                    ctx.getChannel(),
+                    ctx.channel(),
                     new TooLongFrameException(
                             "Adjusted frame length exceeds " + maxFrameLength +
                             " - discarding"));

File: codec/src/main/java/io/netty/handler/codec/oneone/OneToOneDecoder.java
Patch:
@@ -63,7 +63,7 @@ public void handleUpstream(
 
         MessageEvent e = (MessageEvent) evt;
         Object originalMessage = e.getMessage();
-        Object decodedMessage = decode(ctx, e.getChannel(), originalMessage);
+        Object decodedMessage = decode(ctx, e.channel(), originalMessage);
         if (originalMessage == decodedMessage) {
             ctx.sendUpstream(evt);
         } else if (decodedMessage != null) {

File: codec/src/main/java/io/netty/handler/codec/oneone/OneToOneEncoder.java
Patch:
@@ -57,7 +57,7 @@ public void handleDownstream(
 
         MessageEvent e = (MessageEvent) evt;
         Object originalMessage = e.getMessage();
-        Object encodedMessage = encode(ctx, e.getChannel(), originalMessage);
+        Object encodedMessage = encode(ctx, e.channel(), originalMessage);
         if (originalMessage == encodedMessage) {
             ctx.sendDownstream(evt);
         } else if (encodedMessage != null) {

File: codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -99,7 +99,7 @@ protected Object encode(ChannelHandlerContext context, Channel channel, Object m
     private ChannelBuffer buffer(ChannelHandlerContext ctx) throws Exception {
         ChannelBuffer buf = buffer.get();
         if (buf == null) {
-            ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();
+            ChannelBufferFactory factory = ctx.channel().getConfig().getBufferFactory();
             buf = ChannelBuffers.dynamicBuffer(factory);
             if (buffer.compareAndSet(null, buf)) {
                 boolean success = false;

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectEncoder.java
Patch:
@@ -73,7 +73,7 @@ public ObjectEncoder(int estimatedLength) {
     protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception {
         ChannelBufferOutputStream bout =
             new ChannelBufferOutputStream(dynamicBuffer(
-                    estimatedLength, ctx.getChannel().getConfig().getBufferFactory()));
+                    estimatedLength, ctx.channel().getConfig().getBufferFactory()));
         bout.write(LENGTH_PLACEHOLDER);
         ObjectOutputStream oout = new CompactObjectOutputStream(bout);
         oout.writeObject(msg);

File: example/src/main/java/io/netty/example/discard/DiscardClient.java
Patch:
@@ -58,7 +58,7 @@ public ChannelPipeline getPipeline() throws Exception {
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection is closed or the connection attempt fails.
-        future.getChannel().getCloseFuture().awaitUninterruptibly();
+        future.channel().getCloseFuture().awaitUninterruptibly();
 
         // Shut down thread pools to exit.
         bootstrap.releaseExternalResources();

File: example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
Patch:
@@ -93,16 +93,16 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 
     private void generateTraffic(ChannelStateEvent e) {
         // Keep generating traffic until the channel is unwritable.
         // A channel becomes unwritable when its internal buffer is full.
         // If you keep writing messages ignoring this property,
         // you will end up with an OutOfMemoryError.
-        Channel channel = e.getChannel();
+        Channel channel = e.channel();
         while (channel.isWritable()) {
             ChannelBuffer m = nextMessage();
             if (m == null) {

File: example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
Patch:
@@ -62,7 +62,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/echo/EchoClient.java
Patch:
@@ -61,7 +61,7 @@ public ChannelPipeline getPipeline() throws Exception {
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection is closed or the connection attempt fails.
-        future.getChannel().getCloseFuture().awaitUninterruptibly();
+        future.channel().getCloseFuture().awaitUninterruptibly();
 
         // Shut down thread pools to exit.
         bootstrap.releaseExternalResources();

File: example/src/main/java/io/netty/example/echo/EchoServerHandler.java
Patch:
@@ -44,7 +44,7 @@ public void messageReceived(
             ChannelHandlerContext ctx, MessageEvent e) {
         // Send back the received message to the remote peer.
         transferredBytes.addAndGet(((ChannelBuffer) e.getMessage()).readableBytes());
-        e.getChannel().write(e.getMessage());
+        e.channel().write(e.getMessage());
     }
 
     @Override
@@ -54,7 +54,7 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/factorial/FactorialClient.java
Patch:
@@ -53,11 +53,11 @@ public void run() {
             bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection is made successfully.
-        Channel channel = connectFuture.awaitUninterruptibly().getChannel();
+        Channel channel = connectFuture.awaitUninterruptibly().channel();
 
         // Get the handler instance to retrieve the answer.
         FactorialClientHandler handler =
-            (FactorialClientHandler) channel.getPipeline().getLast();
+            (FactorialClientHandler) channel.getPipeline().last();
 
         // Print out the answer.
         System.err.format(

File: example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
Patch:
@@ -65,7 +65,7 @@ public void messageReceived(
         }
         lastMultiplier = number.intValue();
         factorial = factorial.multiply(number);
-        e.getChannel().write(factorial);
+        e.channel().write(factorial);
     }
 
     @Override
@@ -81,7 +81,7 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -73,9 +73,9 @@ public void run() {
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection attempt succeeds or fails.
-        Channel channel = future.awaitUninterruptibly().getChannel();
+        Channel channel = future.awaitUninterruptibly().channel();
         if (!future.isSuccess()) {
-            future.getCause().printStackTrace();
+            future.cause().printStackTrace();
             bootstrap.releaseExternalResources();
             return;
         }

File: example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
Patch:
@@ -72,7 +72,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
             throws Exception {
-        e.getCause().printStackTrace();
-        e.getChannel().close();
+        e.cause().printStackTrace();
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -107,7 +107,7 @@ public ChannelPipeline getPipeline() throws Exception {
                             new InetSocketAddress(uri.getHost(), uri.getPort()));
             future.awaitUninterruptibly().rethrowIfFailed();
     
-            ch = future.getChannel();
+            ch = future.channel();
             handshaker.handshake(ch).awaitUninterruptibly().rethrowIfFailed();
             
             // Send 10 messages and wait for responses

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -66,7 +66,7 @@ public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-        Channel ch = ctx.getChannel();
+        Channel ch = ctx.channel();
         if (!handshaker.isHandshakeComplete()) {
             handshaker.finishHandshake(ch, (HttpResponse) e.getMessage());
             System.out.println("WebSocket Client connected!");
@@ -93,8 +93,8 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
-        final Throwable t = e.getCause();
+        final Throwable t = e.cause();
         t.printStackTrace();
-        e.getChannel().close();
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/local/LocalExample.java
Patch:
@@ -86,17 +86,17 @@ public ChannelPipeline getPipeline() throws Exception {
             }
 
             // Sends the received line to the server.
-            lastWriteFuture = channelFuture.getChannel().write(line);
+            lastWriteFuture = channelFuture.channel().write(line);
         }
 
         // Wait until all messages are flushed before closing the channel.
         if (lastWriteFuture != null) {
             lastWriteFuture.awaitUninterruptibly();
         }
-        channelFuture.getChannel().close();
+        channelFuture.channel().close();
 
         // Wait until the connection is closed or the connection attempt fails.
-        channelFuture.getChannel().getCloseFuture().awaitUninterruptibly();
+        channelFuture.channel().getCloseFuture().awaitUninterruptibly();
 
         // Release all resources used by the local transport.
         cb.releaseExternalResources();

File: example/src/main/java/io/netty/example/localtime/LocalTimeClient.java
Patch:
@@ -58,7 +58,7 @@ public void run() {
             bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection is made successfully.
-        Channel channel = connectFuture.awaitUninterruptibly().getChannel();
+        Channel channel = connectFuture.awaitUninterruptibly().channel();
 
         // Get the handler instance to initiate the request.
         LocalTimeClientHandler handler =

File: example/src/main/java/io/netty/example/localtime/LocalTimeClientHandler.java
Patch:
@@ -102,7 +102,7 @@ public void handleUpstream(
     @Override
     public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e)
             throws Exception {
-        channel = e.getChannel();
+        channel = e.channel();
         super.channelOpen(ctx, e);
     }
 
@@ -119,7 +119,7 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/localtime/LocalTimeServerHandler.java
Patch:
@@ -73,7 +73,7 @@ public void messageReceived(
                     setSecond(calendar.get(SECOND)).build());
         }
 
-        e.getChannel().write(builder.build());
+        e.channel().write(builder.build());
     }
 
     @Override
@@ -82,8 +82,8 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 
     private static String toString(Continent c) {

File: example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
Patch:
@@ -57,7 +57,7 @@ public void messageReceived(
             ChannelHandlerContext ctx, MessageEvent e) {
         // Echo back the received object to the client.
         transferredMessages.incrementAndGet();
-        e.getChannel().write(e.getMessage());
+        e.channel().write(e.getMessage());
     }
 
     @Override
@@ -66,7 +66,7 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
Patch:
@@ -75,7 +75,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
         } else {
             // Unknown protocol; discard everything and close the connection.
             buffer.skipBytes(buffer.readableBytes());
-            ctx.getChannel().close();
+            ctx.channel().close();
             return null;
         }
 

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
Patch:
@@ -28,14 +28,14 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
         String msg = (String) e.getMessage();
         if (msg.startsWith("QOTM: ")) {
             System.out.println("Quote of the Moment: " + msg.substring(6));
-            e.getChannel().close();
+            e.channel().close();
         }
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
             throws Exception {
-        e.getCause().printStackTrace();
-        e.getChannel().close();
+        e.cause().printStackTrace();
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
Patch:
@@ -47,14 +47,14 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             throws Exception {
         String msg = (String) e.getMessage();
         if (msg.equals("QOTM?")) {
-            e.getChannel().write("QOTM: " + nextQuote(), e.getRemoteAddress());
+            e.channel().write("QOTM: " + nextQuote(), e.getRemoteAddress());
         }
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
             throws Exception {
-        e.getCause().printStackTrace();
+        e.cause().printStackTrace();
         // We don't close the channel because we can keep serving requests.
     }
 }

File: example/src/main/java/io/netty/example/redis/RedisClient.java
Patch:
@@ -53,7 +53,7 @@ public ChannelPipeline getPipeline() throws Exception {
         });
         ChannelFuture redis = cb.connect(new InetSocketAddress("localhost", 6379));
         redis.await().rethrowIfFailed();
-        Channel channel = redis.getChannel();
+        Channel channel = redis.channel();
 
         channel.write(new Command("set", "1", "value"));
         System.out.print(blockingReadHandler.read());

File: example/src/main/java/io/netty/example/sctp/SctpClient.java
Patch:
@@ -66,7 +66,7 @@ public ChannelPipeline getPipeline() throws Exception {
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection is closed or the connection attempt fails.
-        future.getChannel().getCloseFuture().awaitUninterruptibly();
+        future.channel().getCloseFuture().awaitUninterruptibly();
 
         //  Please check SctpClientHandler to see, how echo message is sent & received
 

File: example/src/main/java/io/netty/example/sctp/SctpServerHandler.java
Patch:
@@ -36,13 +36,13 @@ public class SctpServerHandler extends SimpleChannelUpstreamHandler {
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) {
         // Send back the received message to the remote peer.
         logger.log(Level.INFO, "Received " + counter.incrementAndGet() + "th message from client, sending it back.");
-        messageEvent.getChannel().write(messageEvent.getMessage());
+        messageEvent.channel().write(messageEvent.getMessage());
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent event) {
         // Close the connection when an exception is raised.
-        logger.log(Level.WARNING, "Unexpected exception from downstream.", event.getCause());
-        event.getChannel().close();
+        logger.log(Level.WARNING, "Unexpected exception from downstream.", event.cause());
+        event.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/securechat/SecureChatClient.java
Patch:
@@ -53,9 +53,9 @@ public void run() throws IOException {
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection attempt succeeds or fails.
-        Channel channel = future.awaitUninterruptibly().getChannel();
+        Channel channel = future.awaitUninterruptibly().channel();
         if (!future.isSuccess()) {
-            future.getCause().printStackTrace();
+            future.cause().printStackTrace();
             bootstrap.releaseExternalResources();
             return;
         }

File: example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
Patch:
@@ -66,7 +66,7 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/stdio/StdioLogger.java
Patch:
@@ -60,7 +60,7 @@ public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent
 
                         final String message = (String) e.getMessage();
                         synchronized (System.out) {
-                            e.getChannel().write("Message received: " + message);
+                            e.channel().write("Message received: " + message);
                         }
                         if ("exit".equals(message)) {
                             running = false;
@@ -77,7 +77,7 @@ public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent
         ChannelFuture connectFuture = bootstrap.connect(new IoStreamAddress(System.in, System.out));
 
         // Wait until the connection is made successfully.
-        Channel channel = connectFuture.awaitUninterruptibly().getChannel();
+        Channel channel = connectFuture.awaitUninterruptibly().channel();
 
         while (running) {
             try {

File: example/src/main/java/io/netty/example/telnet/TelnetClient.java
Patch:
@@ -52,9 +52,9 @@ public void run() throws IOException {
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
 
         // Wait until the connection attempt succeeds or fails.
-        Channel channel = future.awaitUninterruptibly().getChannel();
+        Channel channel = future.awaitUninterruptibly().channel();
         if (!future.isSuccess()) {
-            future.getCause().printStackTrace();
+            future.cause().printStackTrace();
             bootstrap.releaseExternalResources();
             return;
         }

File: example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
Patch:
@@ -55,7 +55,7 @@ public void exceptionCaught(
         logger.log(
                 Level.WARNING,
                 "Unexpected exception from downstream.",
-                e.getCause());
-        e.getChannel().close();
+                e.cause());
+        e.channel().close();
     }
 }

File: example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
Patch:
@@ -75,7 +75,7 @@ public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) {
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
-        Throwable cause = e.getCause();
+        Throwable cause = e.cause();
         if (cause instanceof ConnectException) {
             startTime = -1;
             println("Failed to connect: " + cause.getMessage());
@@ -86,7 +86,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
         } else {
             cause.printStackTrace();
         }
-        ctx.getChannel().close();
+        ctx.channel().close();
     }
 
     void println(String msg) {

File: handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
Patch:
@@ -213,7 +213,7 @@ public void log(ChannelEvent e) {
 
             // Log the message (and exception if available.)
             if (e instanceof ExceptionEvent) {
-                getLogger().log(level, msg, ((ExceptionEvent) e).getCause());
+                getLogger().log(level, msg, ((ExceptionEvent) e).cause());
             } else {
                 getLogger().log(level, msg);
             }

File: handler/src/main/java/io/netty/handler/queue/BlockingReadHandler.java
Patch:
@@ -133,7 +133,7 @@ public E read() throws IOException, InterruptedException {
         if (e instanceof MessageEvent) {
             return getMessage((MessageEvent) e);
         } else if (e instanceof ExceptionEvent) {
-            throw (IOException) new IOException().initCause(((ExceptionEvent) e).getCause());
+            throw (IOException) new IOException().initCause(((ExceptionEvent) e).cause());
         } else {
             throw new IllegalStateException();
         }
@@ -168,7 +168,7 @@ public E read(long timeout, TimeUnit unit) throws IOException, InterruptedExcept
         if (e instanceof MessageEvent) {
             return getMessage((MessageEvent) e);
         } else if (e instanceof ExceptionEvent) {
-            throw (IOException) new IOException().initCause(((ExceptionEvent) e).getCause());
+            throw (IOException) new IOException().initCause(((ExceptionEvent) e).cause());
         } else {
             throw new IllegalStateException();
         }

File: handler/src/main/java/io/netty/handler/queue/BufferedWriteHandler.java
Patch:
@@ -294,7 +294,7 @@ private List<MessageEvent> consolidatedWrite(final List<MessageEvent> pendingWri
         }
 
         ChannelBuffer composite = ChannelBuffers.wrappedBuffer(data);
-        ChannelFuture future = Channels.future(ctx.getChannel());
+        ChannelFuture future = Channels.future(ctx.channel());
         future.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future)
@@ -304,7 +304,7 @@ public void operationComplete(ChannelFuture future)
                         e.getFuture().setSuccess();
                     }
                 } else {
-                    Throwable cause = future.getCause();
+                    Throwable cause = future.cause();
                     for (MessageEvent e: pendingWrites) {
                         e.getFuture().setFailure(cause);
                     }

File: handler/src/main/java/io/netty/handler/region/ChannelWritableByteChannel.java
Patch:
@@ -56,7 +56,7 @@ public ChannelWritableByteChannel(ChannelHandlerContext context, ChannelFutureAg
     
     @Override
     public boolean isOpen() {
-        return !closed && context.getChannel().isOpen();
+        return !closed && context.channel().isOpen();
     }
 
     @Override
@@ -69,7 +69,7 @@ public int write(ByteBuffer src) throws IOException {
         int written = src.remaining();
         
         // create a new ChannelFuture and add it to the aggregator
-        ChannelFuture future =  Channels.future(context.getChannel(), true);
+        ChannelFuture future =  Channels.future(context.channel(), true);
         aggregator.addFuture(future);
         
         Channels.write(context, future, ChannelBuffers.wrappedBuffer(src), remote);

File: handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -109,7 +109,7 @@ public void handleDownstream(ChannelHandlerContext ctx, ChannelEvent e)
         boolean offered = queue.offer((MessageEvent) e);
         assert offered;
 
-        final Channel channel = ctx.getChannel();
+        final Channel channel = ctx.channel();
         if (channel.isWritable()) {
             this.ctx = ctx;
             flush(ctx, false);
@@ -182,7 +182,7 @@ private void discard(ChannelHandlerContext ctx, boolean fireNow) {
     }
 
     private synchronized void flush(ChannelHandlerContext ctx, boolean fireNow) throws Exception {
-        final Channel channel = ctx.getChannel();
+        final Channel channel = ctx.channel();
         if (!channel.isConnected()) {
             discard(ctx, fireNow);
         }
@@ -250,7 +250,7 @@ private synchronized void flush(ChannelHandlerContext ctx, boolean fireNow) thro
                                 public void operationComplete(ChannelFuture future)
                                         throws Exception {
                                     if (!future.isSuccess()) {
-                                        currentEvent.getFuture().setFailure(future.getCause());
+                                        currentEvent.getFuture().setFailure(future.cause());
                                         closeInput((ChunkedInput) currentEvent.getMessage());
                                     }
                                 }

File: handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -248,7 +248,7 @@ public void run(Timeout timeout) throws Exception {
                 return;
             }
 
-            if (!ctx.getChannel().isOpen()) {
+            if (!ctx.channel().isOpen()) {
                 return;
             }
 

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -173,7 +173,7 @@ public void run(Timeout timeout) throws Exception {
                 return;
             }
 
-            if (!ctx.getChannel().isOpen()) {
+            if (!ctx.channel().isOpen()) {
                 return;
             }
 

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -95,19 +95,19 @@ public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)
             throws Exception {
         // readSuspended = true;
         ctx.setAttachment(Boolean.TRUE);
-        ctx.getChannel().setReadable(false);
+        ctx.channel().setReadable(false);
         if (trafficCounter == null) {
             // create a new counter now
             trafficCounter = new TrafficCounter(this, executor, "ChannelTC" +
-                    ctx.getChannel().getId(), checkInterval);
+                    ctx.channel().getId(), checkInterval);
         }
         if (trafficCounter != null) {
             trafficCounter.start();
         }
         super.channelConnected(ctx, e);
         // readSuspended = false;
         ctx.setAttachment(null);
-        ctx.getChannel().setReadable(true);
+        ctx.channel().setReadable(true);
     }
 
 }

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/NioClientSocketShutdownTimeTest.java
Patch:
@@ -54,14 +54,14 @@ public void testShutdownTime() throws Throwable {
             serverSocket.accept();
             f.awaitUninterruptibly();
 
-            if (f.getCause() != null) {
-                throw f.getCause();
+            if (f.cause() != null) {
+                throw f.cause();
             }
             assertTrue(f.isSuccess());
 
             startTime = System.currentTimeMillis();
 
-            f.getChannel().close().awaitUninterruptibly();
+            f.channel().close().awaitUninterruptibly();
         } finally {
             b.getFactory().releaseExternalResources();
 

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelAcceptedChannelSink.java
Patch:
@@ -74,7 +74,7 @@ private void handleMessageEvent(MessageEvent ev) {
         }
 
         final HttpTunnelAcceptedChannelReceiver channel =
-                (HttpTunnelAcceptedChannelReceiver) ev.getChannel();
+                (HttpTunnelAcceptedChannelReceiver) ev.channel();
         final ChannelBuffer message = (ChannelBuffer) ev.getMessage();
         final int messageSize = message.readableBytes();
         final ChannelFuture future = ev.getFuture();
@@ -98,7 +98,7 @@ public void operationComplete(ChannelFuture future)
     private void handleStateEvent(ChannelStateEvent ev) {
         /* TODO: as any of disconnect, unbind or close destroys a server
            channel, should we fire all three events always? */
-        Channel owner = ev.getChannel();
+        Channel owner = ev.channel();
         switch (ev.getState()) {
         case OPEN:
             if (Boolean.FALSE.equals(ev.getValue())) {

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientChannel.java
Patch:
@@ -252,7 +252,7 @@ public void operationComplete(ChannelFuture future)
                         if (future.isSuccess()) {
                             originalFuture.setSuccess();
                         } else {
-                            originalFuture.setFailure(future.getCause());
+                            originalFuture.setFailure(future.cause());
                         }
                         updateSaturationStatus(-messageSize);
                     }
@@ -312,7 +312,7 @@ protected void allFuturesComplete() {
         }
 
         protected void futureFailed(ChannelFuture future) {
-            completionFuture.setFailure(future.getCause());
+            completionFuture.setFailure(future.cause());
         }
     }
 

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientChannelSink.java
Patch:
@@ -41,13 +41,13 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e)
 
     private void handleMessageEvent(MessageEvent e) {
         HttpTunnelClientChannel channel =
-                (HttpTunnelClientChannel) e.getChannel();
+                (HttpTunnelClientChannel) e.channel();
         channel.sendData(e);
     }
 
     private void handleChannelStateEvent(ChannelStateEvent e) {
         HttpTunnelClientChannel channel =
-                (HttpTunnelClientChannel) e.getChannel();
+                (HttpTunnelClientChannel) e.channel();
 
         switch (e.getState()) {
         case CONNECTED:

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientPollHandler.java
Patch:
@@ -88,6 +88,6 @@ private void sendPoll(ChannelHandlerContext ctx) {
         HttpRequest request =
                 HttpTunnelMessageUtils.createReceiveDataRequest(
                         tunnelChannel.getServerHostName(), tunnelId);
-        Channels.write(ctx, Channels.future(ctx.getChannel()), request);
+        Channels.write(ctx, Channels.future(ctx.channel()), request);
     }
 }

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelServerChannelSink.java
Patch:
@@ -70,7 +70,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {
                 upstreamFuture.setSuccess();
             } else {
-                upstreamFuture.setFailure(future.getCause());
+                upstreamFuture.setFailure(future.cause());
             }
         }
     }

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelingServlet.java
Patch:
@@ -147,7 +147,7 @@ protected void service(HttpServletRequest req, HttpServletResponse res)
         Channel channel = channelFactory.newChannel(pipeline);
         ChannelFuture future = channel.connect(remoteAddress).awaitUninterruptibly();
         if (!future.isSuccess()) {
-            Throwable cause = future.getCause();
+            Throwable cause = future.cause();
             if (logger.isWarnEnabled()) {
                 logger.warn("Endpoint unavailable: " + cause.getMessage(), cause);
             }
@@ -240,9 +240,9 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
             if (logger.isWarnEnabled()) {
-                logger.warn("Unexpected exception while HTTP tunneling", e.getCause());
+                logger.warn("Unexpected exception while HTTP tunneling", e.cause());
             }
-            e.getChannel().close();
+            e.channel().close();
         }
     }
 }

File: transport-http/src/main/java/io/netty/channel/socket/http/ServerMessageSwitch.java
Patch:
@@ -223,7 +223,7 @@ public void routeOutboundData(String tunnelId, ChannelBuffer data,
         }
         for (ChannelBuffer fragment: fragments) {
             ChannelFuture fragmentFuture =
-                    Channels.future(writeFuture.getChannel());
+                    Channels.future(writeFuture.channel());
             aggregator.addFuture(fragmentFuture);
             tunnel.queuedResponses.offer(new QueuedResponse(fragment,
                     fragmentFuture));
@@ -248,7 +248,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {
                 originalFuture.setSuccess();
             } else {
-                originalFuture.setFailure(future.getCause());
+                originalFuture.setFailure(future.cause());
             }
         }
     }

File: transport-http/src/main/java/io/netty/channel/socket/http/TunnelWrappedServerChannelHandler.java
Patch:
@@ -48,7 +48,7 @@ public TunnelWrappedServerChannelHandler(
     @Override
     public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e)
             throws Exception {
-        e.getChannel().getConfig().setPipelineFactory(pipelineFactory);
+        e.channel().getConfig().setPipelineFactory(pipelineFactory);
         super.channelOpen(ctx, e);
     }
 

File: transport-http/src/main/java/io/netty/channel/socket/http/WriteFragmenter.java
Patch:
@@ -62,7 +62,7 @@ public void writeRequested(ChannelHandlerContext ctx, MessageEvent e)
                     new ChannelFutureAggregator(e.getFuture());
             for (ChannelBuffer fragment: fragments) {
                 ChannelFuture fragmentFuture =
-                        Channels.future(ctx.getChannel(), true);
+                        Channels.future(ctx.channel(), true);
                 aggregator.addFuture(fragmentFuture);
                 Channels.write(ctx, fragmentFuture, fragment);
             }

File: transport-http/src/test/java/io/netty/channel/socket/http/HttpTunnelClientChannelTest.java
Patch:
@@ -251,7 +251,7 @@ public void testBind_sendBindFails() {
                 bindFailureReason);
         assertTrue(bindFuture.isDone());
         assertFalse(bindFuture.isSuccess());
-        assertSame(bindFailureReason, bindFuture.getCause());
+        assertSame(bindFailureReason, bindFuture.cause());
     }
 
     @Test
@@ -264,6 +264,6 @@ public void testBind_pollBindFails() {
                 bindFailureReason);
         assertTrue(bindFuture.isDone());
         assertFalse(bindFuture.isSuccess());
-        assertSame(bindFailureReason, bindFuture.getCause());
+        assertSame(bindFailureReason, bindFuture.cause());
     }
 }

File: transport-http/src/test/java/io/netty/channel/socket/http/HttpTunnelServerChannelSinkTest.java
Patch:
@@ -149,7 +149,7 @@ private final class ExceptionCatcher extends SimpleChannelUpstreamHandler {
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                 throws Exception {
-            exceptionInPipeline = e.getCause();
+            exceptionInPipeline = e.cause();
         }
     }
 }

File: transport-http/src/test/java/io/netty/channel/socket/http/HttpTunnelServerChannelTest.java
Patch:
@@ -231,7 +231,7 @@ private void checkIsUpstreamChannelStateEvent(ChannelEvent ev,
             Object expectedValue) {
         assertTrue(ev instanceof UpstreamChannelStateEvent);
         UpstreamChannelStateEvent checkedEv = (UpstreamChannelStateEvent) ev;
-        assertSame(expectedChannel, checkedEv.getChannel());
+        assertSame(expectedChannel, checkedEv.channel());
         assertEquals(expectedState, checkedEv.getState());
         assertEquals(expectedValue, checkedEv.getValue());
     }

File: transport-http/src/test/java/io/netty/channel/socket/http/NettyTestUtils.java
Patch:
@@ -167,7 +167,7 @@ public static InetSocketAddress createAddress(byte[] addr, int port) {
     public static Throwable checkIsExceptionEvent(ChannelEvent ev) {
         assertTrue(ev instanceof ExceptionEvent);
         ExceptionEvent exceptionEv = (ExceptionEvent) ev;
-        return exceptionEv.getCause();
+        return exceptionEv.cause();
     }
 
     public static ChannelStateEvent checkIsStateEvent(ChannelEvent event,

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpClientPipelineSink.java
Patch:
@@ -41,7 +41,7 @@ public void eventSunk(
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
             SctpClientChannel channel =
-                (SctpClientChannel) event.getChannel();
+                (SctpClientChannel) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -80,7 +80,7 @@ public void eventSunk(
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            SctpChannelImpl channel = (SctpChannelImpl) event.getChannel();
+            SctpChannelImpl channel = (SctpChannelImpl) event.channel();
             boolean offered = channel.getWriteBufferQueue().offer(event);
             assert offered;
             channel.getWorker().writeFromUserCode(channel);

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerPipelineSink.java
Patch:
@@ -58,7 +58,7 @@ private void handleServerSocket(ChannelEvent e) {
 
         ChannelStateEvent event = (ChannelStateEvent) e;
         SctpServerChannelImpl channel =
-            (SctpServerChannelImpl) event.getChannel();
+            (SctpServerChannelImpl) event.channel();
         ChannelFuture future = event.getFuture();
         ChannelState state = event.getState();
         Object value = event.getValue();
@@ -92,7 +92,7 @@ private void handleServerSocket(ChannelEvent e) {
     private void handleAcceptedSocket(ChannelEvent e) {
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
-            SctpChannelImpl channel = (SctpChannelImpl) event.getChannel();
+            SctpChannelImpl channel = (SctpChannelImpl) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -115,7 +115,7 @@ private void handleAcceptedSocket(ChannelEvent e) {
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            SctpChannelImpl channel = (SctpChannelImpl) event.getChannel();
+            SctpChannelImpl channel = (SctpChannelImpl) event.channel();
             boolean offered = channel.getWriteBufferQueue().offer(event);
             assert offered;
             channel.getWorker().writeFromUserCode(channel);

File: transport/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java
Patch:
@@ -199,8 +199,8 @@ public Channel bind(final SocketAddress localAddress) {
         // Wait for the future.
         future.awaitUninterruptibly();
         if (!future.isSuccess()) {
-            future.getChannel().close().awaitUninterruptibly();
-            throw new ChannelException("Failed to bind to: " + localAddress, future.getCause());
+            future.channel().close().awaitUninterruptibly();
+            throw new ChannelException("Failed to bind to: " + localAddress, future.cause());
         }
 
         return ch;

File: transport/src/main/java/io/netty/channel/ChannelFuture.java
Patch:
@@ -170,7 +170,7 @@ public interface ChannelFuture {
      * Returns a channel where the I/O operation associated with this
      * future takes place.
      */
-    Channel getChannel();
+    Channel channel();
 
     /**
      * Returns {@code true} if and only if this future is
@@ -199,7 +199,7 @@ public interface ChannelFuture {
      *         {@code null} if succeeded or this future is not
      *         completed yet.
      */
-    Throwable getCause();
+    Throwable cause();
 
     /**
      * Cancels the I/O operation associated with this future

File: transport/src/main/java/io/netty/channel/ChannelFutureAggregator.java
Patch:
@@ -60,7 +60,7 @@ public void operationComplete(ChannelFuture future)
             } else {
                 pendingFutures.remove(future);
                 if (!future.isSuccess()) {
-                    aggregateFuture.setFailure(future.getCause());
+                    aggregateFuture.setFailure(future.cause());
                     for (ChannelFuture pendingFuture: pendingFutures) {
                         pendingFuture.cancel();
                     }

File: transport/src/main/java/io/netty/channel/ChannelFutureListener.java
Patch:
@@ -39,7 +39,7 @@ public interface ChannelFutureListener extends EventListener {
     ChannelFutureListener CLOSE = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) {
-            future.getChannel().close();
+            future.channel().close(null);
         }
     };
 
@@ -51,7 +51,7 @@ public void operationComplete(ChannelFuture future) {
         @Override
         public void operationComplete(ChannelFuture future) {
             if (!future.isSuccess()) {
-                future.getChannel().close();
+                future.channel().close(null);
             }
         }
     };

File: transport/src/main/java/io/netty/channel/ChannelInboundHandlerContext.java
Patch:
@@ -1,7 +1,5 @@
 package io.netty.channel;
 
 public interface ChannelInboundHandlerContext<I> extends ChannelHandlerContext {
-    @Override
-    ChannelInboundHandler<I> handler();
     ChannelBufferHolder<I> in();
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
Patch:
@@ -3,12 +3,12 @@
 import java.net.SocketAddress;
 
 public interface ChannelOutboundHandler<T> extends ChannelHandler {
+    ChannelBufferHolder<T> newOutboundBuffer(ChannelOutboundHandlerContext<T> ctx) throws Exception;
+
     void bind(ChannelOutboundHandlerContext<T> ctx, SocketAddress localAddress, ChannelFuture future) throws Exception;
     void connect(ChannelOutboundHandlerContext<T> ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelFuture future) throws Exception;
     void disconnect(ChannelOutboundHandlerContext<T> ctx, ChannelFuture future) throws Exception;
     void close(ChannelOutboundHandlerContext<T> ctx, ChannelFuture future) throws Exception;
     void deregister(ChannelOutboundHandlerContext<T> ctx, ChannelFuture future) throws Exception;
-
-    ChannelBufferHolder<T> newOutboundBuffer(ChannelOutboundHandlerContext<T> ctx) throws Exception;
-    void outboundBufferUpdated(ChannelOutboundHandlerContext<T> ctx) throws Exception;
+    void flush(ChannelOutboundHandlerContext<T> ctx, ChannelFuture future) throws Exception;
 }

File: transport/src/main/java/io/netty/channel/ChannelOutboundHandlerContext.java
Patch:
@@ -2,7 +2,5 @@
 
 
 public interface ChannelOutboundHandlerContext<O> extends ChannelHandlerContext {
-    @Override
-    ChannelOutboundHandler<O> handler();
     ChannelBufferHolder<O> out();
 }

File: transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
Patch:
@@ -101,7 +101,7 @@ public boolean awaitUninterruptibly(long timeoutMillis) {
     }
 
     @Override
-    public Channel getChannel() {
+    public Channel channel() {
         return channel;
     }
 

File: transport/src/main/java/io/netty/channel/DefaultChannelFuture.java
Patch:
@@ -90,7 +90,7 @@ public DefaultChannelFuture(Channel channel, boolean cancellable) {
     }
 
     @Override
-    public Channel getChannel() {
+    public Channel channel() {
         return channel;
     }
 
@@ -105,7 +105,7 @@ public synchronized boolean isSuccess() {
     }
 
     @Override
-    public synchronized Throwable getCause() {
+    public synchronized Throwable cause() {
         if (cause != CANCELLED) {
             return cause;
         } else {
@@ -183,7 +183,7 @@ public ChannelFuture rethrowIfFailed() throws Exception {
             return this;
         }
         
-        Throwable cause = getCause();
+        Throwable cause = cause();
         if (cause == null) {
             return this;
         }

File: transport/src/main/java/io/netty/channel/FailedChannelFuture.java
Patch:
@@ -39,7 +39,7 @@ public FailedChannelFuture(Channel channel, Throwable cause) {
     }
 
     @Override
-    public Throwable getCause() {
+    public Throwable cause() {
         return cause;
     }
 

File: transport/src/main/java/io/netty/channel/SucceededChannelFuture.java
Patch:
@@ -32,7 +32,7 @@ public SucceededChannelFuture(Channel channel) {
     }
 
     @Override
-    public Throwable getCause() {
+    public Throwable cause() {
         return null;
     }
 

File: transport/src/main/java/io/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -47,7 +47,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
             ChannelStateEvent event = (ChannelStateEvent) e;
 
             DefaultLocalChannel channel =
-                  (DefaultLocalChannel) event.getChannel();
+                  (DefaultLocalChannel) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -78,7 +78,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
+            DefaultLocalChannel channel = (DefaultLocalChannel) event.channel();
             boolean offered = channel.writeBuffer.offer(event);
             assert offered;
             channel.flushWriteBuffer();

File: transport/src/main/java/io/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -49,7 +49,7 @@ private void handleServerChannel(ChannelEvent e) {
 
         ChannelStateEvent event = (ChannelStateEvent) e;
         DefaultLocalServerChannel channel =
-              (DefaultLocalServerChannel) event.getChannel();
+              (DefaultLocalServerChannel) event.channel();
         ChannelFuture future = event.getFuture();
         ChannelState state = event.getState();
         Object value = event.getValue();
@@ -72,7 +72,7 @@ private void handleServerChannel(ChannelEvent e) {
     private void handleAcceptedChannel(ChannelEvent e) {
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
-            DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
+            DefaultLocalChannel channel = (DefaultLocalChannel) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -96,7 +96,7 @@ private void handleAcceptedChannel(ChannelEvent e) {
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
+            DefaultLocalChannel channel = (DefaultLocalChannel) event.channel();
             boolean offered = channel.writeBuffer.offer(event);
             assert offered;
             channel.flushWriteBuffer();

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannelSink.java
Patch:
@@ -27,10 +27,10 @@ public abstract class AbstractNioChannelSink extends AbstractChannelSink {
 
     @Override
     public ChannelFuture execute(ChannelPipeline pipeline, final Runnable task) {
-        Channel ch = pipeline.getChannel();
+        Channel ch = pipeline.channel();
         if (ch instanceof AbstractNioChannel) {
             AbstractNioChannel channel = (AbstractNioChannel) ch;
-            ChannelRunnableWrapper wrapper = new ChannelRunnableWrapper(pipeline.getChannel(), task);
+            ChannelRunnableWrapper wrapper = new ChannelRunnableWrapper(pipeline.channel(), task);
             channel.getWorker().executeInIoThread(wrapper);
             return wrapper;
         }

File: transport/src/main/java/io/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -42,7 +42,7 @@ public void eventSunk(
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
             NioClientSocketChannel channel =
-                (NioClientSocketChannel) event.getChannel();
+                (NioClientSocketChannel) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -73,7 +73,7 @@ public void eventSunk(
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            NioSocketChannel channel = (NioSocketChannel) event.getChannel();
+            NioSocketChannel channel = (NioSocketChannel) event.channel();
             boolean offered = channel.writeBufferQueue.offer(event);
             assert offered;
             channel.getWorker().writeFromUserCode(channel);

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -53,7 +53,7 @@ private void handleServerSocket(ChannelEvent e) {
 
         ChannelStateEvent event = (ChannelStateEvent) e;
         NioServerSocketChannel channel =
-            (NioServerSocketChannel) event.getChannel();
+            (NioServerSocketChannel) event.channel();
         ChannelFuture future = event.getFuture();
         ChannelState state = event.getState();
         Object value = event.getValue();
@@ -77,7 +77,7 @@ private void handleServerSocket(ChannelEvent e) {
     private void handleAcceptedSocket(ChannelEvent e) {
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
-            NioSocketChannel channel = (NioSocketChannel) event.getChannel();
+            NioSocketChannel channel = (NioSocketChannel) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -100,7 +100,7 @@ private void handleAcceptedSocket(ChannelEvent e) {
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            NioSocketChannel channel = (NioSocketChannel) event.getChannel();
+            NioSocketChannel channel = (NioSocketChannel) event.channel();
             boolean offered = channel.writeBufferQueue.offer(event);
             assert offered;
             channel.getWorker().writeFromUserCode(channel);

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioChannelSink.java
Patch:
@@ -28,12 +28,12 @@ public abstract class AbstractOioChannelSink extends AbstractChannelSink {
 
     @Override
     public ChannelFuture execute(final ChannelPipeline pipeline, final Runnable task) {
-        Channel ch = pipeline.getChannel();
+        Channel ch = pipeline.channel();
         if (ch instanceof AbstractOioChannel) {
             AbstractOioChannel channel = (AbstractOioChannel) ch;
             Worker worker = channel.worker;
             if (worker != null) {
-                ChannelRunnableWrapper wrapper = new ChannelRunnableWrapper(pipeline.getChannel(), task);
+                ChannelRunnableWrapper wrapper = new ChannelRunnableWrapper(pipeline.channel(), task);
                 channel.worker.executeInIoThread(wrapper);
                 return wrapper;
             }

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -67,7 +67,7 @@ private void handleServerSocket(ChannelEvent e) {
 
         ChannelStateEvent event = (ChannelStateEvent) e;
         OioServerSocketChannel channel =
-            (OioServerSocketChannel) event.getChannel();
+            (OioServerSocketChannel) event.channel();
         ChannelFuture future = event.getFuture();
         ChannelState state = event.getState();
         Object value = event.getValue();
@@ -92,7 +92,7 @@ private void handleAcceptedSocket(ChannelEvent e) {
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
             OioAcceptedSocketChannel channel =
-                (OioAcceptedSocketChannel) event.getChannel();
+                (OioAcceptedSocketChannel) event.channel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -115,7 +115,7 @@ private void handleAcceptedSocket(ChannelEvent e) {
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            OioSocketChannel channel = (OioSocketChannel) event.getChannel();
+            OioSocketChannel channel = (OioSocketChannel) event.channel();
             ChannelFuture future = event.getFuture();
             Object message = event.getMessage();
             OioWorker.write(channel, future, message);

File: transport/src/test/java/io/netty/channel/CompleteChannelFutureTest.java
Patch:
@@ -72,7 +72,7 @@ public void shouldNotDoAnythingOnRemove() throws Exception {
 
     @Test
     public void testConstantProperties() throws InterruptedException {
-        assertSame(channel, future.getChannel());
+        assertSame(channel, future.channel());
         assertTrue(future.isDone());
         assertFalse(future.cancel());
         assertFalse(future.isCancelled());
@@ -91,7 +91,7 @@ private static class CompleteChannelFutureImpl extends CompleteChannelFuture {
         }
 
         @Override
-        public Throwable getCause() {
+        public Throwable cause() {
             throw new Error();
         }
 

File: transport/src/test/java/io/netty/channel/FailedChannelFutureTest.java
Patch:
@@ -28,7 +28,7 @@ public void testConstantProperties() {
         FailedChannelFuture future = new FailedChannelFuture(channel, e);
 
         assertFalse(future.isSuccess());
-        assertSame(e, future.getCause());
+        assertSame(e, future.cause());
     }
 
     @Test(expected = NullPointerException.class)

File: transport/src/test/java/io/netty/channel/SucceededChannelFutureTest.java
Patch:
@@ -27,6 +27,6 @@ public void testConstantProperties() {
         SucceededChannelFuture future = new SucceededChannelFuture(channel);
 
         assertTrue(future.isSuccess());
-        assertNull(future.getCause());
+        assertNull(future.cause());
     }
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/MixedFileUpload.java
Patch:
@@ -58,7 +58,7 @@ public void addContent(ChannelBuffer buffer, boolean last)
                         definedSize);
                 if (((MemoryFileUpload) fileUpload).getChannelBuffer() != null) {
                     diskFileUpload.addContent(((MemoryFileUpload) fileUpload)
-                        .getChannelBuffer(), last);
+                        .getChannelBuffer(), false);
                 }
                 fileUpload = diskFileUpload;
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/MixedAttribute.java
Patch:
@@ -65,7 +65,7 @@ public void addContent(ChannelBuffer buffer, boolean last) throws IOException {
                         .getName());
                 if (((MemoryAttribute) attribute).getChannelBuffer() != null) {
                     diskAttribute.addContent(((MemoryAttribute) attribute)
-                        .getChannelBuffer(), last);
+                        .getChannelBuffer(), false);
                 }
                 attribute = diskAttribute;
             }

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -75,7 +75,7 @@ public void testPerformOpeningHandshake() {
         ChannelBuffer buffer = ChannelBuffers.copiedBuffer("^n:ds[4U", Charset.defaultCharset());
         req.setContent(buffer);
         
-        WebSocketServerHandshaker00 handsaker = new WebSocketServerHandshaker00("ws://example.com/chat", "chat");
+        WebSocketServerHandshaker00 handsaker = new WebSocketServerHandshaker00("ws://example.com/chat", "chat", Long.MAX_VALUE);
         handsaker.handshake(channelMock, req);
         
         Assert.assertEquals("ws://example.com/chat", res.getValue().getHeader(Names.SEC_WEBSOCKET_LOCATION));

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
Patch:
@@ -68,7 +68,7 @@ public void testPerformOpeningHandshake() {
         req.setHeader(Names.SEC_WEBSOCKET_PROTOCOL, "chat, superchat");
         req.setHeader(Names.SEC_WEBSOCKET_VERSION, "8");
         
-        WebSocketServerHandshaker08 handsaker = new WebSocketServerHandshaker08("ws://example.com/chat", "chat", false);
+        WebSocketServerHandshaker08 handsaker = new WebSocketServerHandshaker08("ws://example.com/chat", "chat", false, Long.MAX_VALUE);
         handsaker.handshake(channelMock, req);
         
         Assert.assertEquals("s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.getValue().getHeader(Names.SEC_WEBSOCKET_ACCEPT));

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
Patch:
@@ -67,7 +67,7 @@ public void testPerformOpeningHandshake() {
         req.setHeader(Names.SEC_WEBSOCKET_ORIGIN, "http://example.com");
         req.setHeader(Names.SEC_WEBSOCKET_PROTOCOL, "chat, superchat");
         req.setHeader(Names.SEC_WEBSOCKET_VERSION, "13");
-        WebSocketServerHandshaker13 handsaker = new WebSocketServerHandshaker13("ws://example.com/chat", "chat", false);
+        WebSocketServerHandshaker13 handsaker = new WebSocketServerHandshaker13("ws://example.com/chat", "chat", false, Long.MAX_VALUE);
         handsaker.handshake(channelMock, req);
 
         Assert.assertEquals("s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.getValue().getHeader(Names.SEC_WEBSOCKET_ACCEPT));

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -117,7 +117,7 @@ public ChannelPipeline getPipeline() throws Exception {
             
             // Send 10 messages and wait for responses
             logger.info("WebSocket Client sending message");
-            for (int i = 0; i < 10; i++) {
+            for (int i = 0; i < 1000; i++) {
                 ch.write(new TextWebSocketFrame("Message #" + i));
             }
     

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
Patch:
@@ -35,7 +35,7 @@ public class WebSocket00FrameDecoder extends ReplayingDecoder<VoidEnum> {
 
     private static final int DEFAULT_MAX_FRAME_SIZE = 16384;
 
-    private final int maxFrameSize;
+    private final long maxFrameSize;
     private boolean receivedClosingHandshake;
 
     public WebSocket00FrameDecoder() {
@@ -49,7 +49,7 @@ public WebSocket00FrameDecoder() {
      * @param maxFrameSize
      *            the maximum frame size to decode
      */
-    public WebSocket00FrameDecoder(int maxFrameSize) {
+    public WebSocket00FrameDecoder(long maxFrameSize) {
         this.maxFrameSize = maxFrameSize;
     }
 

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
Patch:
@@ -75,7 +75,7 @@ public void testPerformOpeningHandshake() {
         ChannelBuffer buffer = ChannelBuffers.copiedBuffer("^n:ds[4U", Charset.defaultCharset());
         req.setContent(buffer);
         
-        WebSocketServerHandshaker00 handsaker = new WebSocketServerHandshaker00("ws://example.com/chat", "chat");
+        WebSocketServerHandshaker00 handsaker = new WebSocketServerHandshaker00("ws://example.com/chat", "chat", Long.MAX_VALUE);
         handsaker.handshake(channelMock, req);
         
         Assert.assertEquals("ws://example.com/chat", res.getValue().getHeader(Names.SEC_WEBSOCKET_LOCATION));

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
Patch:
@@ -68,7 +68,7 @@ public void testPerformOpeningHandshake() {
         req.setHeader(Names.SEC_WEBSOCKET_PROTOCOL, "chat, superchat");
         req.setHeader(Names.SEC_WEBSOCKET_VERSION, "8");
         
-        WebSocketServerHandshaker08 handsaker = new WebSocketServerHandshaker08("ws://example.com/chat", "chat", false);
+        WebSocketServerHandshaker08 handsaker = new WebSocketServerHandshaker08("ws://example.com/chat", "chat", false, Long.MAX_VALUE);
         handsaker.handshake(channelMock, req);
         
         Assert.assertEquals("s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.getValue().getHeader(Names.SEC_WEBSOCKET_ACCEPT));

File: codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
Patch:
@@ -67,7 +67,7 @@ public void testPerformOpeningHandshake() {
         req.setHeader(Names.SEC_WEBSOCKET_ORIGIN, "http://example.com");
         req.setHeader(Names.SEC_WEBSOCKET_PROTOCOL, "chat, superchat");
         req.setHeader(Names.SEC_WEBSOCKET_VERSION, "13");
-        WebSocketServerHandshaker13 handsaker = new WebSocketServerHandshaker13("ws://example.com/chat", "chat", false);
+        WebSocketServerHandshaker13 handsaker = new WebSocketServerHandshaker13("ws://example.com/chat", "chat", false, Long.MAX_VALUE);
         handsaker.handshake(channelMock, req);
 
         Assert.assertEquals("s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.getValue().getHeader(Names.SEC_WEBSOCKET_ACCEPT));

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
Patch:
@@ -117,7 +117,7 @@ public ChannelPipeline getPipeline() throws Exception {
             
             // Send 10 messages and wait for responses
             logger.info("WebSocket Client sending message");
-            for (int i = 0; i < 10; i++) {
+            for (int i = 0; i < 1000; i++) {
                 ch.write(new TextWebSocketFrame("Message #" + i));
             }
     

File: example/src/main/java/io/netty/example/proxy/HexDumpProxyInboundHandler.java
Patch:
@@ -100,7 +100,9 @@ public void channelInterestChanged(ChannelHandlerContext ctx,
         // the incoming traffic from the outboundChannel.
         synchronized (trafficLock) {
             if (e.getChannel().isWritable()) {
-                outboundChannel.setReadable(true);
+                if (outboundChannel != null) {
+                    outboundChannel.setReadable(true);
+                }
             }
         }
     }

File: common/src/main/java/io/netty/util/internal/QueueFactory.java
Patch:
@@ -18,8 +18,8 @@
 import java.util.Collection;
 import java.util.concurrent.BlockingQueue;
 
-import org.jboss.netty.logging.InternalLogger;
-import org.jboss.netty.logging.InternalLoggerFactory;
+import io.netty.logging.InternalLogger;
+import io.netty.logging.InternalLoggerFactory;
 
 /**
  * This factory should be used to create the "optimal" {@link BlockingQueue}

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -146,6 +146,8 @@ public ChannelFuture handshake(Channel channel) {
             // See http://tools.ietf.org/html/rfc6454#section-6.2
             originValue = originValue + ":" + wsPort;
         }
+        request.addHeader(Names.ORIGIN, originValue);
+
         
         request.addHeader(Names.SEC_WEBSOCKET_KEY1, key1);
         request.addHeader(Names.SEC_WEBSOCKET_KEY2, key2);

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -130,6 +130,8 @@ public ChannelFuture handshake(Channel channel) {
             // See http://tools.ietf.org/html/rfc6454#section-6.2
             originValue = originValue + ":" + wsPort;
         }
+        request.addHeader(Names.ORIGIN, originValue);
+
         
         if (protocol != null && !protocol.equals("")) {
             request.addHeader(Names.SEC_WEBSOCKET_PROTOCOL, protocol);

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -83,7 +83,7 @@ public void addCookie(Cookie cookie) {
      * so far into an HTTP header value.  If no {@link Cookie}s were added,
      * an empty string is returned.
      * 
-     * <strong>Be aware that calling this method will clear the contends of the {@link CookieEncoder}</strong>
+     * <strong>Be aware that calling this method will clear the content of the {@link CookieEncoder}</strong>
      */
     public String encode() {
         String answer;

File: example/src/main/java/io/netty/example/localtime/LocalTimeClient.java
Patch:
@@ -81,7 +81,7 @@ public void run() {
         Iterator<String> i1 = cities.iterator();
         Iterator<String> i2 = response.iterator();
         while (i1.hasNext()) {
-            System.out.format("%28s: %s%n", i1.next(), i2.next());
+            logger.info(String.format("%28s: %s%n", i1.next(), i2.next()));
         }
     }
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannelFactory.java
Patch:
@@ -137,13 +137,13 @@ public NioServerSocketChannelFactory(WorkerPool<NioWorker> workerPool) {
         }
        
         this.workerPool = workerPool;
-        sink = new NioServerSocketPipelineSink(workerPool);
+        sink = new NioServerSocketPipelineSink();
     }
 
     
     @Override
     public ServerSocketChannel newChannel(ChannelPipeline pipeline) {
-        return NioServerSocketChannel.create(this, pipeline, sink, workerPool.nextWorker());
+        return NioServerSocketChannel.create(this, pipeline, sink, workerPool.nextWorker(), workerPool);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -127,8 +127,7 @@ protected void registerTask(AbstractNioChannel channel, ChannelFuture future) {
             boolean registered = channel.getJdkChannel().isRegistered();
             if (!registered) {
                 synchronized (channel.interestOpsLock) {
-                    channel.getJdkChannel().register(
-                            selector, channel.getRawInterestOps(), channel);
+                    channel.getJdkChannel().register(selector, channel.getRawInterestOps(), channel);
                 }
                 
             } else {

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannelFactory.java
Patch:
@@ -137,13 +137,13 @@ public NioServerSocketChannelFactory(WorkerPool<NioWorker> workerPool) {
         }
        
         this.workerPool = workerPool;
-        sink = new NioServerSocketPipelineSink(workerPool);
+        sink = new NioServerSocketPipelineSink();
     }
 
     
     @Override
     public ServerSocketChannel newChannel(ChannelPipeline pipeline) {
-        return NioServerSocketChannel.create(this, pipeline, sink, workerPool.nextWorker());
+        return NioServerSocketChannel.create(this, pipeline, sink, workerPool.nextWorker(), workerPool);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -127,8 +127,7 @@ protected void registerTask(AbstractNioChannel channel, ChannelFuture future) {
             boolean registered = channel.getJdkChannel().isRegistered();
             if (!registered) {
                 synchronized (channel.interestOpsLock) {
-                    channel.getJdkChannel().register(
-                            selector, channel.getRawInterestOps(), channel);
+                    channel.getJdkChannel().register(selector, channel.getRawInterestOps(), channel);
                 }
                 
             } else {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.netty.testsuite.util.TestUtils;
 import io.netty.util.internal.ExecutorUtil;
 
-import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.NetworkInterface;
 import java.util.concurrent.CountDownLatch;
@@ -73,7 +72,7 @@ public void testMulticast() throws Throwable {
 
         int port = TestUtils.getFreePort();
         
-        NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());
+        NetworkInterface iface = NetworkInterface.getNetworkInterfaces().nextElement();
         sb.setOption("networkInterface", iface);
         sb.setOption("reuseAddress", true);
         

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -82,11 +82,10 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throw
 
     private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
         if (logger.isDebugEnabled()) {
-            logger.debug(String
-                    .format("Channel %s received %s", ctx.getChannel().getId(), frame.getClass().getSimpleName()));
+            logger.debug(String.format("Channel %s received %s", ctx.getChannel().getId(), frame.getClass()
+                    .getSimpleName()));
         }
 
-
         if (frame instanceof CloseWebSocketFrame) {
             this.handshaker.close(ctx.getChannel(), (CloseWebSocketFrame) frame);
         } else if (frame instanceof PingWebSocketFrame) {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.netty.testsuite.util.TestUtils;
 import io.netty.util.internal.ExecutorUtil;
 
-import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.NetworkInterface;
 import java.util.concurrent.CountDownLatch;
@@ -73,7 +72,7 @@ public void testMulticast() throws Throwable {
 
         int port = TestUtils.getFreePort();
         
-        NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLocalHost());
+        NetworkInterface iface = NetworkInterface.getNetworkInterfaces().nextElement();
         sb.setOption("networkInterface", iface);
         sb.setOption("reuseAddress", true);
         

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -82,11 +82,10 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throw
 
     private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
         if (logger.isDebugEnabled()) {
-            logger.debug(String
-                    .format("Channel %s received %s", ctx.getChannel().getId(), frame.getClass().getSimpleName()));
+            logger.debug(String.format("Channel %s received %s", ctx.getChannel().getId(), frame.getClass()
+                    .getSimpleName()));
         }
 
-
         if (frame instanceof CloseWebSocketFrame) {
             this.handshaker.close(ctx.getChannel(), (CloseWebSocketFrame) frame);
         } else if (frame instanceof PingWebSocketFrame) {

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -82,11 +82,10 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throw
 
     private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
         if (logger.isDebugEnabled()) {
-            logger.debug(String
-                    .format("Channel %s received %s", ctx.getChannel().getId(), frame.getClass().getSimpleName()));
+            logger.debug(String.format("Channel %s received %s", ctx.getChannel().getId(), frame.getClass()
+                    .getSimpleName()));
         }
 
-
         if (frame instanceof CloseWebSocketFrame) {
             this.handshaker.close(ctx.getChannel(), (CloseWebSocketFrame) frame);
         } else if (frame instanceof PingWebSocketFrame) {

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/oio/nio/OioNioDatagramTest.java
Patch:
@@ -18,14 +18,15 @@
 import java.util.concurrent.Executor;
 
 import io.netty.channel.socket.DatagramChannelFactory;
+import io.netty.channel.socket.nio.NioDatagramChannelFactory;
 import io.netty.channel.socket.oio.OioDatagramChannelFactory;
 import io.netty.testsuite.transport.socket.AbstractDatagramTest;
 
 public class OioNioDatagramTest extends AbstractDatagramTest{
 
     @Override
     protected DatagramChannelFactory newServerSocketChannelFactory(Executor executor) {
-        return new OioDatagramChannelFactory(executor);
+        return new NioDatagramChannelFactory(executor);
     }
 
     @Override

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java
Patch:
@@ -116,7 +116,7 @@ abstract class AbstractNioWorker implements Worker {
     
     private volatile int cancelledKeys; // should use AtomicInteger but we just need approximation
 
-    private final SendBufferPool sendBufferPool = new SendBufferPool();
+    protected final SendBufferPool sendBufferPool = new SendBufferPool();
 
     private final boolean allowShutdownOnIdle;
 

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java
Patch:
@@ -887,7 +887,7 @@ public void close(AbstractNioChannel channel, ChannelFuture future) {
         }
     }
 
-    private void cleanUpWriteBuffer(AbstractNioChannel channel) {
+    protected void cleanUpWriteBuffer(AbstractNioChannel channel) {
         Exception cause = null;
         boolean fireExceptionCaught = false;
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -273,7 +273,7 @@ public ChannelFuture write(Object message, SocketAddress remoteAddress) {
         if (remoteAddress == null || remoteAddress.equals(getRemoteAddress())) {
             return super.write(message, null);
         } else {
-            return Channels.write(this, message, remoteAddress);
+            return super.write(message, remoteAddress);
         }
 
     }

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -273,7 +273,7 @@ public ChannelFuture write(Object message, SocketAddress remoteAddress) {
         if (remoteAddress == null || remoteAddress.equals(getRemoteAddress())) {
             return super.write(message, null);
         } else {
-            return super.write(message, remoteAddress);
+            return Channels.write(this, message, remoteAddress);
         }
 
     }

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java
Patch:
@@ -45,6 +45,7 @@
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.ClosedSelectorException;
 import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.Executor;
@@ -68,6 +69,8 @@ public SctpWorker(Executor executor, boolean allowShutdownOnIdle) {
 
     @Override
     public void registerWithWorker(final Channel channel, final ChannelFuture future) {
+        final Selector selector = start();
+
         try {
             if (channel instanceof SctpServerChannelImpl) {
                 final SctpServerChannelImpl ch = (SctpServerChannelImpl) channel;

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java
Patch:
@@ -345,9 +345,6 @@ protected void registerTask(AbstractNioChannel ch, ChannelFuture future) {
                             selector, channel.getRawInterestOps(), channel);
                 }
                 
-            } else {
-                // TODO: Is this needed ?
-                setInterestOps(channel, future, channel.getRawInterestOps());
             }
             if (future != null) {
                 ((SctpChannelImpl) channel).setConnected();

File: transport/src/main/java/io/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -131,9 +131,6 @@ protected void registerTask(AbstractNioChannel channel, ChannelFuture future) {
                             selector, channel.getRawInterestOps(), channel);
                 }
                 
-            } else {
-                // TODO: Is this needed ?
-                setInterestOps(channel, future, channel.getRawInterestOps());
             }
             if (future != null) {
                 if (channel instanceof NioSocketChannel) {

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelImpl.java
Patch:
@@ -72,6 +72,8 @@ class SctpChannelImpl extends AbstractChannel implements SctpChannel {
     MessageEvent currentWriteEvent;
     SendBuffer currentWriteBuffer;
 
+    final SctpNotificationHandler notificationHandler = new SctpNotificationHandler(this);
+    
     public SctpChannelImpl(Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink,
                            com.sun.nio.sctp.SctpChannel channel, SctpWorker worker) {
         super(parent, factory, pipeline, sink);

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
Patch:
@@ -21,13 +21,13 @@
 /**
  * Provides the constants for the header names and the utility methods
  * used by the {@link SpdyHttpDecoder} and {@link SpdyHttpEncoder}.
- * @apiviz.sterotype static
+ * @apiviz.stereotype static
  */
 public final class SpdyHttpHeaders {
 
     /**
      * SPDY HTTP header names
-     * @apiviz.sterotype static
+     * @apiviz.stereotype static
      */
     public static final class Names {
         /**

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
Patch:
@@ -28,13 +28,13 @@
 /**
  * Provides the constants for the standard SPDY HTTP header names and commonly
  * used utility methods that access an {@link SpdyHeaderBlock}.
- * @apiviz.sterotype static
+ * @apiviz.stereotype static
  */
 public class SpdyHeaders {
 
     /**
      * SPDY HTTP header names
-     * @apiviz.sterotype static
+     * @apiviz.stereotype static
      */
     public static final class HttpNames {
         /**

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
Patch:
@@ -37,6 +37,7 @@
  * <li>Chrome 14+ (draft-ietf-hybi-thewebsocketprotocol-10)
  * <li>Chrome 16+ (RFC 6455 aka draft-ietf-hybi-thewebsocketprotocol-17)
  * <li>Firefox 7+ (draft-ietf-hybi-thewebsocketprotocol-10)
+ * <li>Firefox 11+ (RFC 6455 aka draft-ietf-hybi-thewebsocketprotocol-17)
  * </ul>
  */
 public class WebSocketServer {

File: codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecompressor.java
Patch:
@@ -13,14 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.jboss.netty.handler.codec.spdy;
+package io.netty.handler.codec.spdy;
 
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
 
-import org.jboss.netty.buffer.ChannelBuffer;
+import io.netty.buffer.ChannelBuffer;
 
-import static org.jboss.netty.handler.codec.spdy.SpdyCodecUtil.*;
+import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 
 class SpdyHeaderBlockZlibDecompressor extends SpdyHeaderBlockDecompressor {
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramWorkerPool.java
Patch:
@@ -23,7 +23,7 @@
  * 
  *
  */
-public class NioDatagramWorkerPool extends AbstractWorkerPool<NioDatagramWorker>{
+public class NioDatagramWorkerPool extends AbstractNioWorkerPool<NioDatagramWorker> {
 
     protected NioDatagramWorkerPool(Executor executor, int workerCount, boolean allowShutdownOnIdle) {
         super(executor, workerCount, allowShutdownOnIdle);

File: transport/src/main/java/io/netty/channel/socket/nio/NioWorkerPool.java
Patch:
@@ -23,7 +23,7 @@
  * 
  *
  */
-public class NioWorkerPool extends AbstractWorkerPool<NioWorker>{
+public class NioWorkerPool extends AbstractNioWorkerPool<NioWorker> {
 
     NioWorkerPool(Executor executor, int workerCount, boolean allowShutdownOnIdle) {
         super(executor, workerCount, allowShutdownOnIdle);

File: transport/src/main/java/io/netty/channel/socket/nio/ShareableWorkerPool.java
Patch:
@@ -24,7 +24,7 @@
  * 
  * 
  */
-public final class ShareableWorkerPool<E extends Worker> implements WorkerPool<E>{
+public final class ShareableWorkerPool<E extends Worker> implements WorkerPool<E> {
 
     private final WorkerPool<E> wrapped;
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java
Patch:
@@ -59,7 +59,7 @@ public HandlerResult handleNotification(SendFailedNotification notification, Obj
 
     @Override
     public HandlerResult handleNotification(ShutdownNotification notification, Object o) {
-        Channels.fireChannelDisconnected(sctpChannel);
+        sctpChannel.worker.close(sctpChannel, Channels.succeededFuture(sctpChannel));
         return HandlerResult.RETURN;
     }
 

File: common/src/main/java/io/netty/util/internal/jzlib/InfCodes.java
Patch:
@@ -71,7 +71,7 @@ final class InfCodes {
     // mode dependent information
     private int len;
     private int[] tree; // pointer into tree
-    private int tree_index = 0;
+    private int tree_index;
     private int need; // bits needed
     private int lit;
     // if EXT or COPY, where and how much

File: common/src/main/java/io/netty/util/internal/jzlib/InfTree.java
Patch:
@@ -180,8 +180,8 @@ private int huft_build(int[] b, // code lengths in bits (all assumed <= BMAX)
             int[] e, // list of extra bits for non-simple codes
             int[] t, // result: starting table
             int[] m, // maximum lookup bits, returns actual
-            int[] hp,// space for trees
-            int[] hn,// hufts used in space
+            int[] hp, // space for trees
+            int[] hn, // hufts used in space
             int[] v // working area: values in order of bit length
     ) {
         // Given a list of code lengths and a maximum table size, make a set of
@@ -437,7 +437,7 @@ int inflate_trees_dynamic(int nl, // number of literal/length codes
 
     static int inflate_trees_fixed(int[] bl, //literal desired/actual bit depth
             int[] bd, //distance desired/actual bit depth
-            int[][] tl,//literal/length tree result
+            int[][] tl, //literal/length tree result
             int[][] td //distance tree result
     ) {
         bl[0] = fixed_bl;

File: common/src/main/java/io/netty/util/internal/jzlib/Inflate.java
Patch:
@@ -76,7 +76,7 @@ final class Inflate {
     private static final int GZIP_FNAME = 21;
     private static final int GZIP_FCOMMENT = 22;
     private static final int GZIP_FHCRC = 23;
-    private static final int GZIP_CRC32= 24;
+    private static final int GZIP_CRC32 = 24;
     private static final int GZIP_ISIZE = 25;
 
     private int mode; // current inflate mode
@@ -305,7 +305,7 @@ int inflate(ZStream z, int f) {
                     break;
                 } else if (z.istate.wrapperType == WrapperType.ZLIB) {
                     z.istate.mode = CHECK4;
-                } else if (z.istate.wrapperType == WrapperType.GZIP){
+                } else if (z.istate.wrapperType == WrapperType.GZIP) {
                     gzipCRC32 = 0;
                     gzipISize = 0;
                     gzipBytesToRead = 4;

File: handler/src/main/java/io/netty/handler/execution/ExecutionHandler.java
Patch:
@@ -110,7 +110,7 @@ public class ExecutionHandler implements ChannelUpstreamHandler, ChannelDownstre
 
     private final Executor executor;
     private final boolean handleDownstream;
-	private final boolean handleUpstream;
+    private final boolean handleUpstream;
 
     /**
      * Creates a new instance with the specified {@link Executor} which only handles upstream events.

File: example/src/main/java/io/netty/example/securechat/SecureChatClientPipelineFactory.java
Patch:
@@ -45,7 +45,7 @@ public ChannelPipeline getPipeline() throws Exception {
 
         SSLEngine engine =
             SecureChatSslContextFactory.getClientContext().createSSLEngine();
-        //engine.setUseClientMode(true);
+        engine.setUseClientMode(true);
 
         pipeline.addLast("ssl", new SslHandler(engine));
 

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -574,15 +574,15 @@ protected Object decode(
         if (tls) {
             // SSLv3 or TLS - Check ProtocolVersion
             int majorVersion = buffer.getUnsignedByte(buffer.readerIndex() + 1);
-            if (majorVersion >= 3 && majorVersion < 10) {
+            if (majorVersion == 3) {
                 // SSLv3 or TLS
                 packetLength = (getShort(buffer, buffer.readerIndex() + 3) & 0xFFFF) + 5;
                 if (packetLength <= 5) {
-                    // Neither SSLv2 or TLSv1 (i.e. SSLv2 or bad data)
+                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)
                     tls = false;
                 }
             } else {
-                // Neither SSLv2 or TLSv1 (i.e. SSLv2 or bad data)
+                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)
                 tls = false;
             }
         }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -594,7 +594,7 @@ protected Object decode(
                     buffer.readerIndex()) & 0x80) != 0 ? 2 : 3;
             int majorVersion = buffer.getUnsignedByte(
                     buffer.readerIndex() + headerLength + 1);
-            if (majorVersion >= 2 && majorVersion < 10) {
+            if (majorVersion == 2 || majorVersion == 3) {
                 // SSLv2
                 if (headerLength == 2) {
                     packetLength = (getShort(buffer, buffer.readerIndex()) & 0x7FFF) + 2;

File: transport/src/main/java/io/netty/channel/socket/ChannelRunnableWrapper.java
Patch:
@@ -21,7 +21,7 @@
 public class ChannelRunnableWrapper extends DefaultChannelFuture implements Runnable {
 
     private final Runnable task;
-    private boolean started = false;
+    private boolean started;
     
     public ChannelRunnableWrapper(Channel channel, Runnable task) {
         super(channel, true);
@@ -30,7 +30,7 @@ public ChannelRunnableWrapper(Channel channel, Runnable task) {
 
     @Override
     public void run() {
-        synchronized(this) {
+        synchronized (this) {
             if (!isCancelled()) {
                 started = true;
             } else {

File: handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -154,7 +154,7 @@ public void writeRequested(ChannelHandlerContext ctx, MessageEvent e)
     }
 
     protected void writeTimedOut(ChannelHandlerContext ctx) throws Exception {
-        Channels.fireExceptionCaught(ctx, EXCEPTION);
+        Channels.fireExceptionCaughtLater(ctx.getChannel(), EXCEPTION);
     }
 
     private final class WriteTimeoutTask implements TimerTask {

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpClientPipelineSink.java
Patch:
@@ -32,7 +32,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
@@ -48,7 +47,7 @@
 
 /**
  */
-class SctpClientPipelineSink extends AbstractChannelSink {
+class SctpClientPipelineSink extends AbstractSctpChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SctpClientPipelineSink.class);

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerPipelineSink.java
Patch:
@@ -31,7 +31,6 @@
 
 import com.sun.nio.sctp.SctpChannel;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
@@ -45,7 +44,7 @@
 
 /**
  */
-class SctpServerPipelineSink extends AbstractChannelSink {
+class SctpServerPipelineSink extends AbstractSctpChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SctpServerPipelineSink.class);

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -442,6 +442,9 @@ public interface ChannelPipeline {
      */
     void sendUpstream(ChannelEvent e);
 
+
+    ChannelFuture execute(Runnable task);
+
     /**
      * Sends the specified {@link ChannelEvent} to the last
      * {@link ChannelDownstreamHandler} in this pipeline.

File: transport/src/main/java/io/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -31,7 +31,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
@@ -45,7 +44,7 @@
 import io.netty.util.internal.DeadLockProofWorker;
 import io.netty.util.internal.QueueFactory;
 
-class NioClientSocketPipelineSink extends AbstractChannelSink {
+class NioClientSocketPipelineSink extends AbstractNioChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(NioClientSocketPipelineSink.class);

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramPipelineSink.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
@@ -35,7 +34,7 @@
  * Receives downstream events from a {@link ChannelPipeline}.  It contains
  * an array of I/O workers.
  */
-class NioDatagramPipelineSink extends AbstractChannelSink {
+class NioDatagramPipelineSink extends AbstractNioChannelSink {
 
     private final NioDatagramWorker[] workers;
     private final AtomicInteger workerIndex = new AtomicInteger();

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
@@ -41,7 +40,7 @@
 import io.netty.logging.InternalLoggerFactory;
 import io.netty.util.internal.DeadLockProofWorker;
 
-class NioServerSocketPipelineSink extends AbstractChannelSink {
+class NioServerSocketPipelineSink extends AbstractNioChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(NioServerSocketPipelineSink.class);

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioChannel.java
Patch:
@@ -25,11 +25,14 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelSink;
+import io.netty.channel.socket.Worker;
 
 abstract class AbstractOioChannel extends AbstractChannel {
     private volatile InetSocketAddress localAddress;
     volatile InetSocketAddress remoteAddress;
     volatile Thread workerThread;
+    volatile Worker worker;
+    
     final Object interestOpsLock = new Object();
 
     AbstractOioChannel(

File: transport/src/main/java/io/netty/channel/socket/oio/OioClientSocketPipelineSink.java
Patch:
@@ -21,7 +21,6 @@
 import java.net.SocketAddress;
 import java.util.concurrent.Executor;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
@@ -31,7 +30,7 @@
 import io.netty.channel.MessageEvent;
 import io.netty.util.internal.DeadLockProofWorker;
 
-class OioClientSocketPipelineSink extends AbstractChannelSink {
+class OioClientSocketPipelineSink extends AbstractOioChannelSink {
 
     private final Executor workerExecutor;
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramPipelineSink.java
Patch:
@@ -20,7 +20,6 @@
 import java.net.SocketAddress;
 import java.util.concurrent.Executor;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
@@ -30,7 +29,7 @@
 import io.netty.channel.MessageEvent;
 import io.netty.util.internal.DeadLockProofWorker;
 
-class OioDatagramPipelineSink extends AbstractChannelSink {
+class OioDatagramPipelineSink extends AbstractOioChannelSink {
 
     private final Executor workerExecutor;
 

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
@@ -36,7 +35,7 @@
 import io.netty.logging.InternalLoggerFactory;
 import io.netty.util.internal.DeadLockProofWorker;
 
-class OioServerSocketPipelineSink extends AbstractChannelSink {
+class OioServerSocketPipelineSink extends AbstractOioChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(OioServerSocketPipelineSink.class);

File: transport/src/main/java/io/netty/channel/ChannelSink.java
Patch:
@@ -39,7 +39,7 @@ public interface ChannelSink {
     void exceptionCaught(ChannelPipeline pipeline, ChannelEvent e, ChannelPipelineException cause) throws Exception;
     
     /**
-     * Schedule the given {@link ChannelEvent} for later execution (in the io-thread). Some implementation may not support his and just fire it directly
+     * Execute the given {@link Runnable} later in the io-thread. Some implementation may not support his and just execute it directly
      */
-    void fireUpstreamEventLater(ChannelPipeline pipeline, ChannelEvent e) throws Exception;
+    ChannelFuture execute(ChannelPipeline pipeline, Runnable task);
 }

File: transport/src/main/java/io/netty/channel/socket/oio/OioDatagramWorker.java
Patch:
@@ -63,7 +63,7 @@ boolean process() throws IOException {
     static void write(
             OioDatagramChannel channel, ChannelFuture future,
             Object message, SocketAddress remoteAddress) {
-        boolean iothread = isIoThead(channel);
+        boolean iothread = isIoThread(channel);
         
         try {
             ChannelBuffer buf = (ChannelBuffer) message;
@@ -105,7 +105,7 @@ static void write(
     
     static void disconnect(OioDatagramChannel channel, ChannelFuture future) {
         boolean connected = channel.isConnected();
-        boolean iothread = isIoThead(channel);
+        boolean iothread = isIoThread(channel);
         
         try {
             channel.socket.disconnect();

File: transport/src/main/java/io/netty/channel/socket/oio/OioWorker.java
Patch:
@@ -65,7 +65,7 @@ static void write(
             OioSocketChannel channel, ChannelFuture future,
             Object message) {
 
-        boolean iothread = isIoThead(channel);
+        boolean iothread = isIoThread(channel);
         OutputStream out = channel.getOutputStream();
         if (out == null) {
             Exception e = new ClosedChannelException();

File: codec/src/main/java/io/netty/handler/codec/frame/FrameDecoder.java
Patch:
@@ -361,6 +361,6 @@ protected ChannelBuffer newCumulationBuffer(
             ChannelHandlerContext ctx, int minimumCapacity) {
         ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();
         return ChannelBuffers.dynamicBuffer(
-                factory.getDefaultOrder(), minimumCapacity, factory);
+                factory.getDefaultOrder(), Math.max(minimumCapacity, 256), factory);
     }
 }

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -972,7 +972,7 @@ private ChannelBuffer unwrap(
             outAppBuf.flip();
 
             if (outAppBuf.hasRemaining()) {
-                ChannelBuffer frame = ChannelBuffers.buffer(outAppBuf.remaining());
+                ChannelBuffer frame = ctx.getChannel().getConfig().getBufferFactory().getBuffer(outAppBuf.remaining());
                 frame.writeBytes(outAppBuf.array(), 0, frame.capacity());
                 return frame;
             } else {

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpClientPipelineSink.java
Patch:
@@ -262,7 +262,7 @@ public void run() {
                 wakenUp.set(false);
 
                 try {
-                    int selectedKeyCount = selector.select(500);
+                    int selectedKeyCount = selector.select(10);
 
                     // 'wakenUp.compareAndSet(false, true)' is always evaluated
                     // before calling 'selector.wakeup()' to reduce the wake-up
@@ -302,9 +302,9 @@ public void run() {
                         processSelectedKeys(selector.selectedKeys());
                     }
 
-                    // Handle connection timeout every 0.5 seconds approximately.
+                    // Handle connection timeout every 10 milliseconds approximately.
                     long currentTimeNanos = System.nanoTime();
-                    if (currentTimeNanos - lastConnectTimeoutCheckTimeNanos >= 500 * 1000000L) {
+                    if (currentTimeNanos - lastConnectTimeoutCheckTimeNanos >= 10 * 1000000L) {
                         lastConnectTimeoutCheckTimeNanos = currentTimeNanos;
                         processConnectTimeout(selector.keys(), currentTimeNanos);
                     }

File: transport/src/main/java/io/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -242,7 +242,7 @@ public void run() {
                 wakenUp.set(false);
 
                 try {
-                    int selectedKeyCount = selector.select(500);
+                    int selectedKeyCount = selector.select(10);
 
                     // 'wakenUp.compareAndSet(false, true)' is always evaluated
                     // before calling 'selector.wakeup()' to reduce the wake-up
@@ -282,9 +282,9 @@ public void run() {
                         processSelectedKeys(selector.selectedKeys());
                     }
 
-                    // Handle connection timeout every 0.5 seconds approximately.
+                    // Handle connection timeout every 10 milliseconds approximately.
                     long currentTimeNanos = System.nanoTime();
-                    if (currentTimeNanos - lastConnectTimeoutCheckTimeNanos >= 500 * 1000000L) {
+                    if (currentTimeNanos - lastConnectTimeoutCheckTimeNanos >= 10 * 1000000L) {
                         lastConnectTimeoutCheckTimeNanos = currentTimeNanos;
                         processConnectTimeout(selector.keys(), currentTimeNanos);
                     }

File: transport-sctp/src/main/java/io/netty/channel/sctp/AbstractSctpChannelSink.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelPipeline;
 
-public abstract class AbstractScptChannelSink extends AbstractChannelSink {
+public abstract class AbstractSctpChannelSink extends AbstractChannelSink {
 
     @Override
     public void fireUpstreamEventLater(final ChannelPipeline pipeline, final ChannelEvent e) throws Exception {

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpClientPipelineSink.java
Patch:
@@ -47,7 +47,7 @@
 
 /**
  */
-class SctpClientPipelineSink extends AbstractScptChannelSink {
+class SctpClientPipelineSink extends AbstractSctpChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SctpClientPipelineSink.class);

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerPipelineSink.java
Patch:
@@ -44,7 +44,7 @@
 
 /**
  */
-class SctpServerPipelineSink extends AbstractScptChannelSink {
+class SctpServerPipelineSink extends AbstractSctpChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SctpServerPipelineSink.class);

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java
Patch:
@@ -273,7 +273,9 @@ public void run() {
     
     @Override
     public void executeInIoThread(Runnable eventRunnable) {
-       assert eventQueue.offer(eventRunnable);
+       boolean added = eventQueue.offer(eventRunnable);
+      
+       assert added;
        
        // wake up the selector to speed things
        selector.wakeup();

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioWorker.java
Patch:
@@ -90,8 +90,9 @@ static boolean isIoThead(AbstractOioChannel channel) {
     
     @Override
     public void executeInIoThread(Runnable eventRunnable) {
-        assert eventQueue.offer(eventRunnable);
+        boolean added = eventQueue.offer(eventRunnable);
         
+        assert added;
         // as we set the SO_TIMEOUT to 1 second this task will get picked up in 1 second at latest
     }
     

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelAcceptedChannelSink.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.netty.buffer.ChannelBuffer;
+import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
@@ -32,7 +33,7 @@
  * from here to the ServerMessageSwitch, which queues the data awaiting a poll request from the
  * client end of the tunnel.
  */
-class HttpTunnelAcceptedChannelSink extends AbstractHttpChannelSink {
+class HttpTunnelAcceptedChannelSink extends AbstractChannelSink {
 
     final SaturationManager saturationManager;
 

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientChannelSink.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.net.InetSocketAddress;
 
+import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelStateEvent;
@@ -26,7 +27,7 @@
  * Sink of a client channel, deals with sunk events and then makes appropriate calls
  * on the channel itself to push data.
  */
-class HttpTunnelClientChannelSink extends AbstractHttpChannelSink {
+class HttpTunnelClientChannelSink extends AbstractChannelSink {
 
     @Override
     public void eventSunk(ChannelPipeline pipeline, ChannelEvent e)

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelServerChannelSink.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.net.SocketAddress;
 
+import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
@@ -26,7 +27,7 @@
 
 /**
  */
-class HttpTunnelServerChannelSink extends AbstractHttpChannelSink {
+class HttpTunnelServerChannelSink extends AbstractChannelSink {
 
     private ChannelFutureListener closeHook;
 

File: transport-http/src/test/java/io/netty/channel/socket/http/FakeChannelSink.java
Patch:
@@ -19,13 +19,14 @@
 import java.util.LinkedList;
 import java.util.Queue;
 
+import io.netty.channel.AbstractChannelSink;
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelPipeline;
 
 /**
  * A fake channel sink for use in testing
  */
-public class FakeChannelSink extends AbstractHttpChannelSink {
+public class FakeChannelSink extends AbstractChannelSink {
 
     public Queue<ChannelEvent> events = new LinkedList<ChannelEvent>();
 

File: transport-sctp/src/main/java/io/netty/channel/sctp/AbstractScptChannelSink.java
Patch:
@@ -21,7 +21,7 @@
 import io.netty.channel.ChannelEvent;
 import io.netty.channel.ChannelPipeline;
 
-public abstract class AbstractScptChannelSink extends AbstractChannelSink{
+public abstract class AbstractScptChannelSink extends AbstractChannelSink {
 
     @Override
     public void fireUpstreamEventLater(final ChannelPipeline pipeline, final ChannelEvent e) throws Exception {
@@ -41,7 +41,7 @@ public void run() {
                 pipeline.sendUpstream(e);
             }
         } else {
-            throw new UnsupportedOperationException();
+            super.fireUpstreamEventLater(pipeline, e);
         }
 
     }

File: transport/src/main/java/io/netty/channel/socket/Worker.java
Patch:
@@ -20,7 +20,7 @@
  * A {@link Worker} is responsible to dispatch IO operations
  *
  */
-public interface Worker extends Runnable{
+public interface Worker extends Runnable {
 
     /**
      * Execute the given {@link Runnable} in the IO-Thread. This may be now or later once the IO-Thread do some other work.

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java
Patch:
@@ -504,7 +504,7 @@ private void write0(AbstractNioChannel<?> channel) {
     }
 
     static boolean isIoThread(AbstractNioChannel<?> channel) {
-        return Thread.currentThread() == channel.worker.thread;
+        return channel.worker.thread == null || Thread.currentThread() == channel.worker.thread;
     }
     
     private void setOpWrite(AbstractNioChannel<?> channel) {

File: transport/src/main/java/io/netty/channel/socket/oio/AbstractOioWorker.java
Patch:
@@ -30,7 +30,7 @@
  *
  * @param <C> {@link AbstractOioChannel}
  */
-abstract class AbstractOioWorker<C extends AbstractOioChannel> implements Worker{
+abstract class AbstractOioWorker<C extends AbstractOioChannel> implements Worker {
 
     private final Queue<Runnable> eventQueue = QueueFactory.createQueue(Runnable.class);
     
@@ -85,7 +85,7 @@ public void run() {
     }
     
     static boolean isIoThead(AbstractOioChannel channel) {
-        return Thread.currentThread() == channel.workerThread;
+        return channel.workerThread == null || Thread.currentThread() == channel.workerThread;
     }
     
     @Override

File: transport/src/main/java/io/netty/channel/Channels.java
Patch:
@@ -481,7 +481,7 @@ public static void fireChannelClosed(ChannelHandlerContext ctx) {
      * the specified {@link Channel} once the io-thread runs again.
      */
     public static void fireExceptionCaughtLater(Channel channel, Throwable cause) {
-        channel.getPipeline().sendUpstream(
+        channel.getPipeline().sendUpstreamLater(
                 new DefaultExceptionEvent(channel, cause));
     }
 

File: transport-sctp/src/main/java/com/sun/nio/sctp/SctpChannel.java
Patch:
@@ -52,4 +52,6 @@ protected SctpChannel(SelectorProvider provider) {
 
     public abstract <T> MessageInfo receive(ByteBuffer dst, T attachment, NotificationHandler<T> handler) throws IOException;
     public abstract int send(ByteBuffer src, MessageInfo messageInfo) throws IOException;
+    
+    public abstract Set<SctpSocketOption<?>> supportedOptions();
 }

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -159,7 +159,7 @@ public QueryStringDecoder(URI uri, Charset charset, int maxParams) {
         if (rawPath != null) {
             hasPath = true;
         } else {
-            rawPath ="";
+            rawPath = "";
             hasPath = false;
         }
         // Also take care of cut of things like "http://localhost" 

File: transport/src/main/java/io/netty/channel/socket/nio/NioChannelConfig.java
Patch:
@@ -25,7 +25,7 @@
  * Special {@link ChannelConfig} sub-type which offers extra methods which are useful for NIO.
  *
  */
-public interface NioChannelConfig extends ChannelConfig{
+public interface NioChannelConfig extends ChannelConfig {
 
     /**
      * Returns the high water mark of the write buffer.  If the number of bytes

File: transport/src/main/java/io/netty/channel/socket/nio/NioChannelConfig.java
Patch:
@@ -25,7 +25,7 @@
  * Special {@link ChannelConfig} sub-type which offers extra methods which are useful for NIO.
  *
  */
-public interface NioChannelConfig extends ChannelConfig{
+public interface NioChannelConfig extends ChannelConfig {
 
     /**
      * Returns the high water mark of the write buffer.  If the number of bytes

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -159,7 +159,7 @@ public QueryStringDecoder(URI uri, Charset charset, int maxParams) {
         if (rawPath != null) {
             hasPath = true;
         } else {
-            rawPath ="";
+            rawPath = "";
             hasPath = false;
         }
         // Also take care of cut of things like "http://localhost" 

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -159,7 +159,7 @@ public QueryStringDecoder(URI uri, Charset charset, int maxParams) {
         if (rawPath != null) {
             hasPath = true;
         } else {
-            rawPath ="";
+            rawPath = "";
             hasPath = false;
         }
         // Also take care of cut of things like "http://localhost" 

File: example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
Patch:
@@ -83,7 +83,7 @@ public void run() {
 
         // Prepare the HTTP request.
         HttpRequest request = new DefaultHttpRequest(
-                HttpVersion.HTTP_1_1, HttpMethod.GET, uri.toASCIIString());
+                HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());
         request.setHeader(HttpHeaders.Names.HOST, host);
         request.setHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);
         request.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelImpl.java
Patch:
@@ -297,8 +297,8 @@ public MessageEvent poll() {
 
         private int getMessageSize(MessageEvent e) {
             Object m = e.getMessage();
-            if (m instanceof ChannelBuffer) {
-                return ((ChannelBuffer) m).readableBytes();
+            if (m instanceof SctpPayload) {
+                return ((SctpPayload) m).getPayloadBuffer().readableBytes();
             }
             return 0;
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -164,7 +164,9 @@ public ChannelFuture handshake(Channel channel, HttpRequest req) {
 
         // Upgrade the connection and send the handshake response.
         ChannelPipeline p = channel.getPipeline();
-        p.remove(HttpChunkAggregator.class);
+        if (p.get(HttpChunkAggregator.class) != null) {
+            p.remove(HttpChunkAggregator.class);
+        }
         p.replace(HttpRequestDecoder.class, "wsdecoder", new WebSocket00FrameDecoder());
 
         ChannelFuture future = channel.write(res);

File: common/src/main/java/io/netty/util/internal/jzlib/Deflate.java
Patch:
@@ -1296,9 +1296,9 @@ private int longest_match(int cur_match) {
         return lookahead;
     }
 
-    int deflateInit(ZStream strm, int level, int bits, WrapperType wrapperType) {
+    int deflateInit(ZStream strm, int level, int bits, int memLevel, WrapperType wrapperType) {
         return deflateInit2(strm, level, JZlib.Z_DEFLATED, bits,
-                JZlib.DEF_MEM_LEVEL, JZlib.Z_DEFAULT_STRATEGY, wrapperType);
+                memLevel, JZlib.Z_DEFAULT_STRATEGY, wrapperType);
     }
 
     private int deflateInit2(ZStream strm, int level, int method, int windowBits,

File: codec/src/main/java/io/netty/handler/codec/frame/FrameDecoder.java
Patch:
@@ -358,7 +358,7 @@ private void cleanup(ChannelHandlerContext ctx, ChannelStateEvent e)
      * Get the currently used {@link ChannelBuffer} for cumulation or create one in a lazy fashion if none exist yet
      * 
      * @param ctx the {@link ChannelHandlerContext} for this handler
-     * @return buffer the {@link ChannelBuffer} which is used fo cumulation
+     * @return buffer the {@link ChannelBuffer} which is used for cumulation
      */
     private ChannelBuffer cumulation(ChannelHandlerContext ctx) {
         ChannelBuffer c = cumulation;

File: transport/src/main/java/io/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -484,7 +484,9 @@ private void write0(NioSocketChannel channel) {
                 } catch (AsynchronousCloseException e) {
                     // Doesn't need a user attention - ignore.
                 } catch (Throwable t) {
-                    buf.release();
+                    if (buf != null) {
+                        buf.release();
+                    }
                     channel.currentWriteEvent = null;
                     channel.currentWriteBuffer = null;
                     buf = null;

File: codec-http/src/main/java/io/netty/handler/codec/http/MemoryFileUpload.java
Patch:
@@ -114,8 +114,8 @@ public void setContentTransferEncoding(String contentTransferEncoding) {
 
     @Override
     public String toString() {
-        return HttpPostBodyUtil.CONTENT_DISPOSITION+": "+
-            HttpPostBodyUtil.FORM_DATA + "; " + HttpPostBodyUtil.NAME+"=\"" + getName() +
+        return HttpPostBodyUtil.CONTENT_DISPOSITION + ": " +
+            HttpPostBodyUtil.FORM_DATA + "; " + HttpPostBodyUtil.NAME + "=\"" + getName() +
             "\"; " + HttpPostBodyUtil.FILENAME + "=\"" + filename + "\"\r\n" +
             HttpHeaders.Names.CONTENT_TYPE + ": " + contentType +
             (charset != null? "; " + HttpHeaders.Values.CHARSET + "=" + charset + "\r\n" : "\r\n") +

File: handler/src/main/java/io/netty/handler/ipfilter/PatternRule.java
Patch:
@@ -174,9 +174,6 @@ private boolean isLocalhost(InetAddress address) {
 
     }
 
-    /* (non-Javadoc)
-    * @see java.lang.Comparable#compareTo(java.lang.Object)
-    */
     @Override
     public int compareTo(Object o) {
         if (o == null) {

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RRXTXDeviceAddress.java
Patch:
@@ -21,7 +21,7 @@
  * A {@link SocketAddress} subclass to wrap the serial port address of a RXTX
  * device (e.g. COM1, /dev/ttyUSB0).
  */
-public class RXTXDeviceAddress extends SocketAddress {
+public class RRXTXDeviceAddress extends SocketAddress {
 
     private static final long serialVersionUID = -2907820090993709523L;
 
@@ -31,7 +31,7 @@ public class RXTXDeviceAddress extends SocketAddress {
      *
      * @param deviceAddress the address of the device (e.g. COM1, /dev/ttyUSB0, ...)
      */
-    public RXTXDeviceAddress(String deviceAddress) {
+    public RRXTXDeviceAddress(String deviceAddress) {
         this.deviceAddress = deviceAddress;
     }
 

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
Patch:
@@ -47,8 +47,8 @@
 /**
  * Handles handshakes and messages
  */
-public class WebSocketServerHandler extends SimpleChannelUpstreamHandler {
-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketServerHandler.class);
+public class AutobahnServerHandler extends SimpleChannelUpstreamHandler {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AutobahnServerHandler.class);
 
     private WebSocketServerHandshaker handshaker;
 

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java
Patch:
@@ -47,7 +47,7 @@
  *    }
  * </code>
  * 
- * <p>10. Run <tt>WebSocketServer</tt> in this package
+ * <p>10. Run <tt>AutobahnServer</tt> in this package
  * 
  * <p>11. Run the test <tt>python fuzzing_client.py</tt>. Note that the actual test case python code is 
  * located in <tt>/usr/local/lib/python2.6/dist-packages/autobahn-0.4.3-py2.6.egg/autobahn/cases</tt> 

File: example/src/main/java/io/netty/example/http/websocketx/client/package-info.java
Patch:
@@ -16,9 +16,8 @@
 
 /**
  * <p>This is an example web service client.
- * <p>To run this example, you must first start 
- * <tt>io.netty.example.http.websocketx.server.WebSocketServer</tt>
- * <p>Next, run <tt>io.netty.example.http.websocketx.client.App</tt>. 
+ * <p>To run this example, you must first start {@link WebSocketServer} and
+ * then {@link WebSocketClient}.
  */
 package io.netty.example.http.websocketx.client;
 

File: example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
Patch:
@@ -57,7 +57,6 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)
     public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) {
         println("Sleeping for: " + UptimeClient.RECONNECT_DELAY + "s");
         timer.newTimeout(new TimerTask() {
-            @Override
             public void run(Timeout timeout) throws Exception {
                 println("Reconnecting to: " + getRemoteAddress());
                 bootstrap.connect();

File: example/src/main/java/io/netty/example/proxy/HexDumpProxy.java
Patch:
@@ -42,7 +42,7 @@ public static void main(String[] args) throws Exception {
         String remoteHost = args[1];
         int remotePort = Integer.parseInt(args[2]);
 
-        run(localPort, remoteHost, remotePort);
+        new HexDumpProxy(localPort, remoteHost, remotePort).run();
     }
 
     private final int localPort;

File: buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -135,7 +135,7 @@ public void ensureWritableBytes(int writableBytes) {
     
     @Override
     public boolean getBoolean(int index) {
-        return (getByte(index) == 1);
+        return getByte(index) != 0;
     }
 
     @Override
@@ -278,7 +278,7 @@ public byte readByte() {
     
     @Override
     public boolean readBoolean() {
-        return (readByte() == 1);
+        return readByte() != 0;
     }
 
     @Override

File: buffer/src/main/java/io/netty/buffer/ChannelBuffer.java
Patch:
@@ -47,7 +47,7 @@
  *
  * <pre>
  * {@link ChannelBuffer} buffer = ...;
- * for (int i = 0; i &lt; buffer.capacity(); i ++</strong>) {
+ * for (int i = 0; i &lt; buffer.capacity(); i ++) {
  *     byte b = buffer.getByte(i);
  *     System.out.println((char) b);
  * }

File: buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java
Patch:
@@ -347,7 +347,7 @@ public void setMedium(int index, int value) {
             setByte(index + 2, (byte) value);
         } else {
             setShort(index    , (short) value);
-            setByte (index + 2, (byte) (value >>> 16));
+            setByte(index + 2, (byte) (value >>> 16));
         }
     }
 

File: buffer/src/main/java/io/netty/buffer/DirectChannelBufferFactory.java
Patch:
@@ -57,9 +57,9 @@ public static ChannelBufferFactory getInstance(ByteOrder defaultEndianness) {
     private final Object bigEndianLock = new Object();
     private final Object littleEndianLock = new Object();
     private final int preallocatedBufferCapacity;
-    private ChannelBuffer preallocatedBigEndianBuffer = null;
+    private ChannelBuffer preallocatedBigEndianBuffer;
     private int preallocatedBigEndianBufferPosition;
-    private ChannelBuffer preallocatedLittleEndianBuffer = null;
+    private ChannelBuffer preallocatedLittleEndianBuffer;
     private int preallocatedLittleEndianBufferPosition;
 
     /**

File: codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -41,10 +41,10 @@
  */
 public class CookieDecoder {
 
-    private final static Pattern PATTERN =
+    private static final Pattern PATTERN =
         Pattern.compile("(?:\\s|[;,])*\\$*([^;=]+)(?:=(?:[\"']((?:\\\\.|[^\"])*)[\"']|([^;,]*)))?(\\s*(?:[;,]+\\s*|$))");
 
-    private final static String COMMA = ",";
+    private static final String COMMA = ",";
 
     private final boolean lenient;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java
Patch:
@@ -283,7 +283,7 @@ public boolean equals(Object o) {
         } else if (that.getDomain() == null) {
             return false;
         }
-	    return getDomain().equalsIgnoreCase(that.getDomain());
+        return getDomain().equalsIgnoreCase(that.getDomain());
     }
 
     @Override

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  */
-class HttpCodecUtil {
+final class HttpCodecUtil {
     //space ' '
     static final byte SP = 32;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpPostBodyUtil.java
Patch:
@@ -23,7 +23,8 @@
 /**
  * Shared Static object between HttpMessageDecoder, HttpPostRequestDecoder and HttpPostRequestEncoder
  */
-public class HttpPostBodyUtil {
+final class HttpPostBodyUtil {
+
     public static int chunkSize = 8096;
     /**
      * HTTP content disposition header name.

File: codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -71,7 +71,7 @@ public HttpRequestDecoder(
     }
 
     @Override
-    protected HttpMessage createMessage(String[] initialLine) throws Exception{
+    protected HttpMessage createMessage(String[] initialLine) throws Exception {
         return new DefaultHttpRequest(
                 HttpVersion.valueOf(initialLine[2]), HttpMethod.valueOf(initialLine[0]), initialLine[1]);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/MemoryAttribute.java
Patch:
@@ -36,8 +36,7 @@ public MemoryAttribute(String name) {
      * @throws IllegalArgumentException
      * @throws IOException
      */
-    public MemoryAttribute(String name, String value)
-            throws NullPointerException, IllegalArgumentException, IOException {
+    public MemoryAttribute(String name, String value) throws IOException {
         super(name, HttpCodecUtil.DEFAULT_CHARSET, 0); // Attribute have no default size
         setValue(value);
     }

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -135,7 +135,7 @@ public QueryStringDecoder(URI uri) {
      * Creates a new decoder that decodes the specified URI encoded in the
      * specified charset.
      */
-    public QueryStringDecoder(URI uri, Charset charset){
+    public QueryStringDecoder(URI uri, Charset charset) {
         this(uri, charset, DEFAULT_MAX_PARAMS);
     }
 
@@ -174,8 +174,7 @@ public String getPath() {
             int pathEndPos = uri.indexOf('?');
             if (pathEndPos < 0) {
                 path = uri;
-            }
-            else {
+            } else {
                 return path = uri.substring(0, pathEndPos);
             }
         }

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -106,7 +106,7 @@ public String toString() {
                 sb.append(encodeComponent(param.name, charset));
                 sb.append("=");
                 sb.append(encodeComponent(param.value, charset));
-                if(i != params.size() - 1) {
+                if (i != params.size() - 1) {
                     sb.append("&");
                 }
             }

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
Patch:
@@ -25,7 +25,7 @@
  */
 public class ContinuationWebSocketFrame extends WebSocketFrame {
 
-    private String aggregatedText = null;
+    private String aggregatedText;
 
     /**
      * Creates a new empty continuation frame.

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Output.java
Patch:
@@ -42,7 +42,7 @@ final class UTF8Output {
             12, 12, 12, 12, 12, 12, 12, 12 };
 
     private int state = UTF8_ACCEPT;
-    private int codep = 0;
+    private int codep;
 
     private final StringBuilder stringBuilder;
 
@@ -60,7 +60,7 @@ public void write(byte[] bytes) {
     public void write(int b) {
         byte type = TYPES[b & 0xFF];
 
-        codep = (state != UTF8_ACCEPT) ? (b & 0x3f) | (codep << 6) : (0xff >> type) & (b);
+        codep = (state != UTF8_ACCEPT) ? (b & 0x3f) | (codep << 6) : (0xff >> type) & b;
 
         state = STATES[state + type];
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -45,7 +45,7 @@
  */
 public class WebSocketClientHandshaker00 extends WebSocketClientHandshaker {
 
-    private byte[] expectedChallengeResponseBytes = null;
+    private byte[] expectedChallengeResponseBytes;
 
     /**
      * Constructor specifying the destination web socket location and version to initiate

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
Patch:
@@ -46,11 +46,11 @@ public class WebSocketClientHandshaker08 extends WebSocketClientHandshaker {
 
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
-    private String expectedChallengeResponseString = null;
+    private String expectedChallengeResponseString;
 
     private static final String protocol = null;
 
-    private boolean allowExtensions = false;
+    private boolean allowExtensions;
 
     /**
      * Constructor specifying the destination web socket location and version to initiate

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
Patch:
@@ -46,11 +46,11 @@ public class WebSocketClientHandshaker13 extends WebSocketClientHandshaker {
 
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
-    private String expectedChallengeResponseString = null;
+    private String expectedChallengeResponseString;
 
     private static final String protocol = null;
 
-    private boolean allowExtensions = false;
+    private boolean allowExtensions;
 
     /**
      * Constructor specifying the destination web socket location and version to initiate

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
Patch:
@@ -31,7 +31,7 @@ public abstract class WebSocketFrame {
     /**
      * RSV1, RSV2, RSV3 used for extensions
      */
-    private int rsv = 0;
+    private int rsv;
 
     /**
      * Contents of this frame

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -34,7 +34,7 @@ public abstract class WebSocketServerHandshaker {
 
     private String subProtocols;
 
-    private String[] subProtocolsArray = null;
+    private String[] subProtocolsArray;
 
     private WebSocketVersion version = WebSocketVersion.UNKNOWN;
 

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
Patch:
@@ -49,7 +49,7 @@ public class WebSocketServerHandshaker08 extends WebSocketServerHandshaker {
 
     public static final String WEBSOCKET_08_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
-    private boolean allowExtensions = false;
+    private boolean allowExtensions;
 
     /**
      * Constructor specifying the destination web socket location

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
Patch:
@@ -50,7 +50,7 @@ public class WebSocketServerHandshaker13 extends WebSocketServerHandshaker {
 
     public static final String WEBSOCKET_13_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
-    private boolean allowExtensions = false;
+    private boolean allowExtensions;
 
     /**
      * Constructor specifying the destination web socket location

File: codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -32,7 +32,7 @@ public class WebSocketServerHandshakerFactory {
 
     private final String subProtocols;
 
-    private boolean allowExtensions = false;
+    private boolean allowExtensions;
 
     /**
      * Constructor specifying the destination web socket location

File: codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
Patch:
@@ -56,7 +56,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
         if (!(msg instanceof ChannelBuffer)) {
             return msg;
         }
-        ChannelBuffer buf = (ChannelBuffer )msg;
+        ChannelBuffer buf = (ChannelBuffer) msg;
         byte[] array;
         if (buf.hasArray()) {
             if (buf.arrayOffset() == 0 && buf.readableBytes() == buf.capacity()) {

File: codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -157,7 +157,7 @@ public ZlibEncoder(int compressionLevel, byte[] dictionary) {
                 ZlibUtil.fail(z, "initialization failure", resultCode);
             } else {
                 resultCode = z.deflateSetDictionary(dictionary, dictionary.length);
-                if (resultCode != JZlib.Z_OK){
+                if (resultCode != JZlib.Z_OK) {
                     ZlibUtil.fail(z, "failed to set the dictionary", resultCode);
                 }
             }

File: codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannelFactory.java
Patch:
@@ -21,7 +21,7 @@
 
 /**
  */
-class EmbeddedChannelFactory implements ChannelFactory {
+final class EmbeddedChannelFactory implements ChannelFactory {
 
     static final ChannelFactory INSTANCE = new EmbeddedChannelFactory();
 

File: codec/src/main/java/io/netty/handler/codec/frame/Delimiters.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * A set of commonly used delimiters for {@link DelimiterBasedFrameDecoder}.
  */
-public class Delimiters {
+public final class Delimiters {
 
     /**
      * Returns a {@code NUL (0x00)} delimiter, which could be used for

File: codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
Patch:
@@ -94,7 +94,7 @@ protected Object decode(
         ChannelBuffer buf = (ChannelBuffer) msg;
         if (buf.hasArray()) {
             final int offset = buf.readerIndex();
-            if(extensionRegistry == null) {
+            if (extensionRegistry == null) {
                 return prototype.newBuilderForType().mergeFrom(
                         buf.array(), buf.arrayOffset() + offset, buf.readableBytes()).build();
             } else {

File: codec/src/main/java/io/netty/handler/codec/serialization/ObjectDecoderInputStream.java
Patch:
@@ -191,6 +191,9 @@ public final int readInt() throws IOException {
         return in.readInt();
     }
 
+    /**
+     * @deprecated Use {@link java.io.BufferedReader#readLine()} instead.
+     */
     @Override
     @Deprecated
     public final String readLine() throws IOException {

File: common/src/main/java/io/netty/util/CharsetUtil.java
Patch:
@@ -26,7 +26,7 @@
  * A utility class that provides various common operations and constants
  * related with {@link Charset} and its relevant classes.
  */
-public class CharsetUtil {
+public final class CharsetUtil {
 
     /**
      * 16-bit UTF (UCS Transformation Format) whose byte order is identified by
@@ -61,15 +61,15 @@ public class CharsetUtil {
     public static final Charset US_ASCII = Charset.forName("US-ASCII");
 
     private static final ThreadLocal<Map<Charset, CharsetEncoder>> encoders =
-        new ThreadLocal<Map<Charset,CharsetEncoder>>() {
+        new ThreadLocal<Map<Charset, CharsetEncoder>>() {
             @Override
             protected Map<Charset, CharsetEncoder> initialValue() {
                 return new IdentityHashMap<Charset, CharsetEncoder>();
             }
         };
 
     private static final ThreadLocal<Map<Charset, CharsetDecoder>> decoders =
-        new ThreadLocal<Map<Charset,CharsetDecoder>>() {
+        new ThreadLocal<Map<Charset, CharsetDecoder>>() {
             @Override
             protected Map<Charset, CharsetDecoder> initialValue() {
                 return new IdentityHashMap<Charset, CharsetDecoder>();

File: common/src/main/java/io/netty/util/ExternalResourceUtil.java
Patch:
@@ -19,7 +19,7 @@
  * A utility class that provides the convenient shutdown of
  * {@link ExternalResourceReleasable}s.
  */
-public class ExternalResourceUtil {
+public final class ExternalResourceUtil {
 
     /**
      * Releases the specified {@link ExternalResourceReleasable}s.

File: common/src/main/java/io/netty/util/HashedWheelTimer.java
Patch:
@@ -545,7 +545,7 @@ public String toString() {
             }
 
             if (isCancelled()) {
-                buf.append (", cancelled");
+                buf.append(", cancelled");
             }
 
             return buf.append(')').toString();

File: common/src/main/java/io/netty/util/internal/AtomicFieldUpdaterUtil.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  */
-class AtomicFieldUpdaterUtil {
+final class AtomicFieldUpdaterUtil {
 
     private static final boolean AVAILABLE;
 
@@ -49,7 +49,7 @@ static final class Node {
         AVAILABLE = available;
     }
 
-    static <T, V> AtomicReferenceFieldUpdater<T,V> newRefUpdater(Class<T> tclass, Class<V> vclass, String fieldName) {
+    static <T, V> AtomicReferenceFieldUpdater<T, V> newRefUpdater(Class<T> tclass, Class<V> vclass, String fieldName) {
         if (AVAILABLE) {
             return AtomicReferenceFieldUpdater.newUpdater(tclass, vclass, fieldName);
         } else {

File: common/src/main/java/io/netty/util/internal/ConcurrentHashMap.java
Patch:
@@ -42,7 +42,7 @@
  * @param <V> the type of mapped values
  */
 public final class ConcurrentHashMap<K, V> extends AbstractMap<K, V>
-        implements ConcurrentMap<K, V>{
+        implements ConcurrentMap<K, V> {
 
     /**
      * The default initial capacity for this table, used when not otherwise
@@ -65,7 +65,7 @@ public final class ConcurrentHashMap<K, V> extends AbstractMap<K, V>
     /**
      * The maximum capacity, used if a higher value is implicitly specified by
      * either of the constructors with arguments.  MUST be a power of two
-     * <= 1<<30 to ensure that entries are indexable using integers.
+     * &lt;= 1&lt;&lt;30 to ensure that entries are indexable using integers.
      */
     static final int MAXIMUM_CAPACITY = 1 << 30;
 
@@ -262,7 +262,7 @@ static final class Segment<K, V> extends ReentrantLock {
 
         Segment(int initialCapacity, float lf) {
             loadFactor = lf;
-            setTable(HashEntry.<K, V> newArray(initialCapacity));
+            setTable(HashEntry.<K, V>newArray(initialCapacity));
         }
 
         @SuppressWarnings("unchecked")

File: common/src/main/java/io/netty/util/internal/ConcurrentIdentityHashMap.java
Patch:
@@ -42,7 +42,7 @@
  * @param <V> the type of mapped values
  */
 public final class ConcurrentIdentityHashMap<K, V> extends AbstractMap<K, V>
-        implements ConcurrentMap<K, V>{
+        implements ConcurrentMap<K, V> {
 
     /**
      * The default initial capacity for this table, used when not otherwise
@@ -65,7 +65,7 @@ public final class ConcurrentIdentityHashMap<K, V> extends AbstractMap<K, V>
     /**
      * The maximum capacity, used if a higher value is implicitly specified by
      * either of the constructors with arguments.  MUST be a power of two
-     * <= 1<<30 to ensure that entries are indexable using integers.
+     * &lt;= 1&lt;&lt;30 to ensure that entries are indexable using integers.
      */
     static final int MAXIMUM_CAPACITY = 1 << 30;
 
@@ -262,7 +262,7 @@ static final class Segment<K, V> extends ReentrantLock {
 
         Segment(int initialCapacity, float lf) {
             loadFactor = lf;
-            setTable(HashEntry.<K, V> newArray(initialCapacity));
+            setTable(HashEntry.<K, V>newArray(initialCapacity));
         }
 
         @SuppressWarnings("unchecked")

File: common/src/main/java/io/netty/util/internal/ConcurrentIdentityWeakKeyHashMap.java
Patch:
@@ -72,7 +72,7 @@ public final class ConcurrentIdentityWeakKeyHashMap<K, V> extends AbstractMap<K,
     /**
      * The maximum capacity, used if a higher value is implicitly specified by
      * either of the constructors with arguments.  MUST be a power of two
-     * <= 1<<30 to ensure that entries are indexable using integers.
+     * &lt;= 1&lt;&lt;30 to ensure that entries are indexable using integers.
      */
     static final int MAXIMUM_CAPACITY = 1 << 30;
 
@@ -307,7 +307,7 @@ static final class Segment<K, V> extends ReentrantLock {
 
         Segment(int initialCapacity, float lf) {
             loadFactor = lf;
-            setTable(HashEntry.<K, V> newArray(initialCapacity));
+            setTable(HashEntry.<K, V>newArray(initialCapacity));
         }
 
         @SuppressWarnings("unchecked")

File: common/src/main/java/io/netty/util/internal/ConcurrentWeakKeyHashMap.java
Patch:
@@ -72,7 +72,7 @@ public final class ConcurrentWeakKeyHashMap<K, V> extends AbstractMap<K, V> impl
     /**
      * The maximum capacity, used if a higher value is implicitly specified by
      * either of the constructors with arguments.  MUST be a power of two
-     * <= 1<<30 to ensure that entries are indexable using integers.
+     * &lt;= 1&lt;&lt;30 to ensure that entries are indexable using integers.
      */
     static final int MAXIMUM_CAPACITY = 1 << 30;
 
@@ -307,7 +307,7 @@ static final class Segment<K, V> extends ReentrantLock {
 
         Segment(int initialCapacity, float lf) {
             loadFactor = lf;
-            setTable(HashEntry.<K, V> newArray(initialCapacity));
+            setTable(HashEntry.<K, V>newArray(initialCapacity));
         }
 
         @SuppressWarnings("unchecked")

File: common/src/main/java/io/netty/util/internal/ConversionUtil.java
Patch:
@@ -22,7 +22,7 @@
  * Conversion utility class to parse a property represented as a string or
  * an object.
  */
-public class ConversionUtil {
+public final class ConversionUtil {
 
     /**
      * Converts the specified object into an integer.
@@ -88,8 +88,8 @@ public static String[] toStringArray(Object value) {
     }
 
     private static final String[] INTEGERS = {
-        "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
-        "10","11","12","13","14","15",
+        "0",  "1",  "2",  "3",  "4",  "5",  "6",  "7",  "8",  "9",
+        "10", "11", "12", "13", "14", "15",
     };
 
     public static String toString(int value) {

File: common/src/main/java/io/netty/util/internal/ExecutorUtil.java
Patch:
@@ -25,7 +25,7 @@
  * their termination.  An {@link Executor} which is not an {@link ExecutorService}
  * will be ignored silently.
  */
-public class ExecutorUtil {
+public final class ExecutorUtil {
 
     /**
      * Returns {@code true} if and only if the specified {@code executor}

File: common/src/main/java/io/netty/util/internal/QueueFactory.java
Patch:
@@ -26,7 +26,7 @@
 
 
  */
-public class QueueFactory {
+public final class QueueFactory {
     
     private static final boolean useUnsafe = UnsafeDetectUtil.isUnsafeFound(QueueFactory.class.getClassLoader());
     
@@ -41,7 +41,7 @@ private QueueFactory() {
      * @param itemClass  the {@link Class} type which will be used as {@link BlockingQueue} items
      * @return queue     the {@link BlockingQueue} implementation
      */
-    public static final <T> BlockingQueue<T> createQueue(Class<T> itemClass) {
+    public static <T> BlockingQueue<T> createQueue(Class<T> itemClass) {
         if (useUnsafe) {
             return new LinkedTransferQueue<T>();
         } else {
@@ -56,7 +56,7 @@ public static final <T> BlockingQueue<T> createQueue(Class<T> itemClass) {
      * @param itemClass   the {@link Class} type which will be used as {@link BlockingQueue} items
      * @return queue      the {@link BlockingQueue} implementation
      */
-    public static final <T> BlockingQueue<T> createQueue(Collection<? extends T> collection, Class<T> itemClass) {
+    public static <T> BlockingQueue<T> createQueue(Collection<? extends T> collection, Class<T> itemClass) {
         if (useUnsafe) {
             return new LinkedTransferQueue<T>(collection);
         } else {

File: common/src/main/java/io/netty/util/internal/StringUtil.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * String utility class.
  */
-public class StringUtil {
+public final class StringUtil {
 
     private StringUtil() {
         // Unused.

File: common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * Accesses the system property swallowing a {@link SecurityException}.
  */
-public class SystemPropertyUtil {
+public final class SystemPropertyUtil {
 
     /**
      * Returns the value of the Java system property with the specified

File: example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
Patch:
@@ -38,7 +38,7 @@ public class DiscardClientHandler extends SimpleChannelUpstreamHandler {
     private static final Logger logger = Logger.getLogger(
             DiscardClientHandler.class.getName());
 
-    private long transferredBytes = 0;
+    private long transferredBytes;
     private final byte[] content;
 
     public DiscardClientHandler(int messageSize) {
@@ -84,7 +84,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {
 
     @Override
     public void writeComplete(ChannelHandlerContext ctx, WriteCompletionEvent e) {
-        transferredBytes =+e.getWrittenAmount();
+        transferredBytes += e.getWrittenAmount();
     }
 
     @Override

File: example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
Patch:
@@ -34,7 +34,7 @@ public class DiscardServerHandler extends SimpleChannelUpstreamHandler {
     private static final Logger logger = Logger.getLogger(
             DiscardServerHandler.class.getName());
 
-    private long transferredBytes = 0;
+    private long transferredBytes;
 
     public long getTransferredBytes() {
         return transferredBytes;
@@ -53,7 +53,7 @@ public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exc
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {
         // Discard received data silently by doing nothing.
-        transferredBytes += (((ChannelBuffer) e.getMessage()).readableBytes());
+        transferredBytes += ((ChannelBuffer) e.getMessage()).readableBytes();
     }
 
     @Override

File: example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
Patch:
@@ -45,7 +45,7 @@ public class FactorialClientHandler extends SimpleChannelUpstreamHandler {
 
     // Stateful properties
     private int i = 1;
-    private int receivedMessages = 0;
+    private int receivedMessages;
     private final int count;
     final BlockingQueue<BigInteger> answer = new LinkedBlockingQueue<BigInteger>();
 

File: example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -134,8 +134,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
 
         // Cache Validation
         String ifModifiedSince = request.getHeader(HttpHeaders.Names.IF_MODIFIED_SINCE);
-        if (ifModifiedSince != null && !ifModifiedSince.equals(""))
-        {
+        if (ifModifiedSince != null && !ifModifiedSince.equals("")) {
             SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
             Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
 

File: example/src/main/java/io/netty/example/http/snoop/HttpRequestHandler.java
Patch:
@@ -140,7 +140,7 @@ private void writeResponse(MessageEvent e) {
         if (cookieString != null) {
             CookieDecoder cookieDecoder = new CookieDecoder();
             Set<Cookie> cookies = cookieDecoder.decode(cookieString);
-            if(!cookies.isEmpty()) {
+            if (!cookies.isEmpty()) {
                 // Reset the cookies if necessary.
                 CookieEncoder cookieEncoder = new CookieEncoder(true);
                 for (Cookie cookie : cookies) {

File: example/src/main/java/io/netty/example/http/upload/HttpRequestHandler.java
Patch:
@@ -66,14 +66,14 @@ public class HttpRequestHandler extends SimpleChannelUpstreamHandler {
 
     private volatile HttpRequest request;
 
-    private volatile boolean readingChunks = false;
+    private volatile boolean readingChunks;
 
     private final StringBuilder responseContent = new StringBuilder();
 
     private static final HttpDataFactory factory = new DefaultHttpDataFactory(
             DefaultHttpDataFactory.MINSIZE); // Disk if size exceed MINSIZE
 
-    private HttpPostRequestDecoder decoder = null;
+    private HttpPostRequestDecoder decoder;
     static {
         DiskFileUpload.deleteOnExitTemporaryFile = true; // should delete file
                                                          // on exit (in normal

File: example/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerHandler.java
Patch:
@@ -50,7 +50,7 @@
 public class WebSocketServerHandler extends SimpleChannelUpstreamHandler {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketServerHandler.class);
 
-    private WebSocketServerHandshaker handshaker = null;
+    private WebSocketServerHandshaker handshaker;
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {

File: example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -53,9 +53,9 @@ public class WebSocketClientHandler extends SimpleChannelUpstreamHandler impleme
     private URI url;
     private final WebSocketCallback callback;
     private Channel channel;
-    private WebSocketClientHandshaker handshaker = null;
+    private WebSocketClientHandshaker handshaker;
     private final WebSocketVersion version;
-    private Map<String, String> customHeaders = null;
+    private Map<String, String> customHeaders;
 
     public WebSocketClientHandler(ClientBootstrap bootstrap, URI url, WebSocketVersion version,
             WebSocketCallback callback, Map<String, String> customHeaders) {

File: example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -52,7 +52,7 @@ public class WebSocketServerHandler extends SimpleChannelUpstreamHandler {
 
     private static final String WEBSOCKET_PATH = "/websocket";
 
-    private WebSocketServerHandshaker handshaker = null;
+    private WebSocketServerHandshaker handshaker;
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
Patch:
@@ -52,7 +52,7 @@ public class WebSocketSslServerHandler extends SimpleChannelUpstreamHandler {
 
     private static final String WEBSOCKET_PATH = "/websocket";
 
-    private WebSocketServerHandshaker handshaker = null;
+    private WebSocketServerHandshaker handshaker;
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {

File: example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Creates a {@link SSLContext} for just server certificates.
  */
-public class WebSocketSslServerSslContext {
+public final class WebSocketSslServerSslContext {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketSslServerSslContext.class);
     private static final String PROTOCOL = "TLS";

File: example/src/main/java/io/netty/example/local/LocalExampleMultthreaded.java
Patch:
@@ -66,7 +66,7 @@ public ChannelPipeline getPipeline() throws Exception {
         // Read commands from array
         String[] commands = { "First", "Second", "Third", "quit" };
         for (int j = 0; j < 5 ; j++) {
-            System.err.println("Start "+j);
+            System.err.println("Start " + j);
             ChannelFuture channelFuture = cb.connect(socketAddress);
             channelFuture.awaitUninterruptibly();
             if (! channelFuture.isSuccess()) {
@@ -87,7 +87,7 @@ public ChannelPipeline getPipeline() throws Exception {
             channelFuture.getChannel().close();
             // Wait until the connection is closed or the connection attempt fails.
             channelFuture.getChannel().getCloseFuture().awaitUninterruptibly();
-            System.err.println("End "+j);
+            System.err.println("End " + j);
         }
 
         // Release all resources

File: example/src/main/java/io/netty/example/local/LocalServerPipelineFactory.java
Patch:
@@ -73,7 +73,7 @@ public void handleDownstream(ChannelHandlerContext ctx, ChannelEvent e) {
                     Channels.close(e.getChannel());
                     return;
                 }
-                System.err.println("SERVER:"+msg);
+                System.err.println("SERVER:" + msg);
                 // Write back
                 Channels.write(e.getChannel(), msg);
             }

File: example/src/main/java/io/netty/example/securechat/SecureChatKeyStore.java
Patch:
@@ -30,7 +30,7 @@
  *          -keystore cert.jks
  * </pre>
  */
-public class SecureChatKeyStore {
+public final class SecureChatKeyStore {
     private static final short[] DATA = {
         0xfe, 0xed, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x02,
         0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,

File: example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
Patch:
@@ -84,8 +84,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
         if (cause instanceof ReadTimeoutException) {
             // The connection was OK but there was no traffic for last period.
             println("Disconnecting due to no inbound traffic");
-        }
-        else {
+        } else {
             cause.printStackTrace();
         }
         ctx.getChannel().close();

File: handler/src/main/java/io/netty/handler/execution/ChannelDownstreamEventRunnable.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * A {@link ChannelEventRunnable} which sends the specified {@link ChannelEvent} downstream.
  */
-public final class ChannelDownstreamEventRunnable extends ChannelEventRunnable{
+public final class ChannelDownstreamEventRunnable extends ChannelEventRunnable {
 
     public ChannelDownstreamEventRunnable(ChannelHandlerContext ctx, ChannelEvent e) {
         super(ctx, e);

File: handler/src/main/java/io/netty/handler/execution/ChannelEventRunnable.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.util.EstimatableObjectWrapper;
 
-public abstract class ChannelEventRunnable implements Runnable, EstimatableObjectWrapper{
+public abstract class ChannelEventRunnable implements Runnable, EstimatableObjectWrapper {
     
     protected final ChannelHandlerContext ctx;
     protected final ChannelEvent e;

File: handler/src/main/java/io/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java
Patch:
@@ -290,7 +290,7 @@ public void execute(Runnable command) {
             tasks.add(command);
             
 
-            if (isRunning.get() == false) {
+            if (!isRunning.get()) {
                 doUnorderedExecute(this);
             }
         }

File: handler/src/main/java/io/netty/handler/execution/filter/ChannelDownstreamEventRunnableFilter.java
Patch:
@@ -22,7 +22,7 @@
  * {@link ChannelEventRunnableFilter} implementation which matches {@link ChannelDownstreamEventRunnable}
  *
  */
-public class ChannelDownstreamEventRunnableFilter implements ChannelEventRunnableFilter{
+public class ChannelDownstreamEventRunnableFilter implements ChannelEventRunnableFilter {
 
     @Override
     public boolean filter(ChannelEventRunnable event) {

File: handler/src/main/java/io/netty/handler/execution/filter/ChannelEventRunnableFilter.java
Patch:
@@ -22,8 +22,8 @@
 public interface ChannelEventRunnableFilter {
     
     /**
-     * Return <code>true<code> if the {@link ChannelEventRunnable} should get handled by the {@link Executor}
+     * Return <code>true</code> if the {@link ChannelEventRunnable} should get handled by the {@link Executor}
      * 
      */
-    public boolean filter(ChannelEventRunnable event);
+    boolean filter(ChannelEventRunnable event);
 }

File: handler/src/main/java/io/netty/handler/execution/filter/ChannelUpstreamEventRunnableFilter.java
Patch:
@@ -23,7 +23,7 @@
  * 
  *
  */
-public class ChannelUpstreamEventRunnableFilter implements ChannelEventRunnableFilter{
+public class ChannelUpstreamEventRunnableFilter implements ChannelEventRunnableFilter {
 
     @Override
     public boolean filter(ChannelEventRunnable event) {

File: handler/src/main/java/io/netty/handler/region/FileRegionEncoder.java
Patch:
@@ -40,7 +40,7 @@
 
  */
 @ChannelHandler.Sharable
-public class FileRegionEncoder implements ChannelDownstreamHandler{
+public class FileRegionEncoder implements ChannelDownstreamHandler {
 
     @Override
     public void handleDownstream(

File: handler/src/main/java/io/netty/handler/ssl/SslHandler.java
Patch:
@@ -194,7 +194,7 @@ public static synchronized SslBufferPool getDefaultBufferPool() {
     private final Queue<PendingWrite> pendingUnencryptedWrites = new LinkedList<PendingWrite>();
     private final Queue<MessageEvent> pendingEncryptedWrites = QueueFactory.createQueue(MessageEvent.class);
     private final NonReentrantLock pendingEncryptedWritesLock = new NonReentrantLock();
-    private volatile boolean issueHandshake = false;
+    private volatile boolean issueHandshake;
     
     private static final ChannelFutureListener HANDSHAKE_LISTENER = new ChannelFutureListener() {
 

File: handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java
Patch:
@@ -33,7 +33,7 @@
  * <li>Add in your pipeline a new ChannelTrafficShapingHandler, before a recommended {@link ExecutionHandler} (like
  * {@link OrderedMemoryAwareThreadPoolExecutor} or {@link MemoryAwareThreadPoolExecutor}).<br>
  * <tt>ChannelTrafficShapingHandler myHandler = new ChannelTrafficShapingHandler(executor);</tt><br>
- * executor could be created using <tt>Executors.newCachedThreadPool();<tt><br>
+ * executor could be created using <tt>Executors.newCachedThreadPool();</tt><br>
  * <tt>pipeline.addLast("CHANNEL_TRAFFIC_SHAPING", myHandler);</tt><br><br>
  *
  * <b>Note that this handler has a Pipeline Coverage of "one" which means a new handler must be created

File: handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java
Patch:
@@ -31,7 +31,7 @@
  * <ul>
  * <li>Create your unique GlobalTrafficShapingHandler like:<br><br>
  * <tt>GlobalTrafficShapingHandler myHandler = new GlobalTrafficShapingHandler(executor);</tt><br><br>
- * executor could be created using <tt>Executors.newCachedThreadPool();<tt><br>
+ * executor could be created using <tt>Executors.newCachedThreadPool();</tt><br>
  * <tt>pipeline.addLast("GLOBAL_TRAFFIC_SHAPING", myHandler);</tt><br><br>
  *
  * <b>Note that this handler has a Pipeline Coverage of "all" which means only one such handler must be created

File: handler/src/main/java/io/netty/handler/traffic/package-info.java
Patch:
@@ -34,7 +34,7 @@
  *
  * The insertion in the pipeline of one of those handlers can be wherever you want, but
  * <b>it must be placed before any <tt>{@link io.netty.handler.execution.MemoryAwareThreadPoolExecutor}</tt>
- * in your pipeline</b>.</li><br>
+ * in your pipeline</b>.<br>
  * <b><i>It is really recommended to have such a</i> <tt>{@link io.netty.handler.execution.MemoryAwareThreadPoolExecutor}</tt>
  * <i>(either non ordered or </i> <tt>{@link io.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor}</tt>
  * <i>) in your pipeline</i></b>
@@ -74,7 +74,7 @@
  *
  * <P>So in your application you will create your own TrafficShapingHandler and set the values to fit your needs.</P>
  * <tt>XXXXXTrafficShapingHandler myHandler = new XXXXXTrafficShapingHandler(executor);</tt><br><br>
- * where executor could be created using <tt>Executors.newCachedThreadPool();<tt> and XXXXX could be either
+ * where executor could be created using <tt>Executors.newCachedThreadPool();</tt> and XXXXX could be either
  * Global or Channel<br>
  * <tt>pipeline.addLast("XXXXX_TRAFFIC_SHAPING", myHandler);</tt><br>
  * <tt>...</tt><br>

File: testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketSslEchoTest.java
Patch:
@@ -122,8 +122,8 @@ public void testSslEcho() throws Throwable {
         cb.getPipeline().addLast("handler", ch);
 
         if (isExecutorRequired()) {
-            sb.getPipeline().addFirst("executor",new ExecutionHandler(eventExecutor));
-            cb.getPipeline().addFirst("executor",new ExecutionHandler(eventExecutor));
+            sb.getPipeline().addFirst("executor", new ExecutionHandler(eventExecutor));
+            cb.getPipeline().addFirst("executor", new ExecutionHandler(eventExecutor));
         }
 
         Channel sc = sb.bind(new InetSocketAddress(0));
@@ -368,7 +368,7 @@ protected void engineInit(ManagerFactoryParameters managerFactoryParameters)
      *          -keystore cert.jks
      * </pre>
      */
-    private static class BogusKeyStore {
+    private static final class BogusKeyStore {
         private static final short[] DATA = {
             0xfe, 0xed, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x02,
             0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelAcceptedChannel.java
Patch:
@@ -36,7 +36,7 @@
  * to change over the lifecycle of a tunnel, especially when an HTTP proxy is in
  * use.
  */
-class HttpTunnelAcceptedChannel extends AbstractChannel implements
+final class HttpTunnelAcceptedChannel extends AbstractChannel implements
         SocketChannel, HttpTunnelAcceptedChannelReceiver {
 
     private final HttpTunnelAcceptedChannelConfig config;

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelAcceptedChannelFactory.java
Patch:
@@ -27,4 +27,4 @@ HttpTunnelAcceptedChannelReceiver newChannel(String newTunnelId,
                                                  InetSocketAddress remoteAddress);
 
     String generateTunnelId();
-}
\ No newline at end of file
+}

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientChannel.java
Patch:
@@ -41,7 +41,7 @@
  * this type are designed to emulate a normal TCP based socket channel as far as is feasible within the limitations
  * of the HTTP 1.1 protocol, and the usage patterns permitted by commonly used HTTP proxies and firewalls.
  */
-public class HttpTunnelClientChannel extends AbstractChannel implements
+final class HttpTunnelClientChannel extends AbstractChannel implements
         SocketChannel {
 
     static final InternalLogger LOG = InternalLoggerFactory

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientSendHandler.java
Patch:
@@ -44,7 +44,7 @@ class HttpTunnelClientSendHandler extends SimpleChannelHandler {
 
     private final HttpTunnelClientWorkerOwner tunnelChannel;
 
-    private String tunnelId = null;
+    private String tunnelId;
 
     private final AtomicBoolean disconnecting;
 

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelClientWorkerOwner.java
Patch:
@@ -61,4 +61,4 @@ void onConnectRequest(ChannelFuture connectFuture,
      */
     String getServerHostName();
 
-}
\ No newline at end of file
+}

File: transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelServerChannel.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  */
-public class HttpTunnelServerChannel extends AbstractServerChannel implements
+final class HttpTunnelServerChannel extends AbstractServerChannel implements
         ServerSocketChannel {
 
     private final ServerSocketChannel realChannel;

File: transport-http/src/main/java/io/netty/channel/socket/http/ServerMessageSwitchDownstreamInterface.java
Patch:
@@ -29,4 +29,4 @@ interface ServerMessageSwitchDownstreamInterface {
     void routeOutboundData(String tunnelId, ChannelBuffer data,
                            ChannelFuture writeFuture);
 
-}
\ No newline at end of file
+}

File: transport-http/src/main/java/io/netty/channel/socket/http/ServerMessageSwitchUpstreamInterface.java
Patch:
@@ -50,4 +50,4 @@ enum TunnelStatus {
         ALIVE, CLOSED
     }
 
-}
\ No newline at end of file
+}

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RXTXChannelConfig.java
Patch:
@@ -108,9 +108,9 @@ public static Paritybit ofValue(int value) {
 
     private int baudrate = 115200;
 
-    private boolean dtr = false;
+    private boolean dtr;
 
-    private boolean rts = false;
+    private boolean rts;
 
     private Stopbits stopbits = RXTXChannelConfig.Stopbits.STOPBITS_1;
 

File: transport-rxtx/src/main/java/io/netty/channel/rxtx/RXTXChannelSink.java
Patch:
@@ -276,7 +276,7 @@ public void serialEvent(final SerialPortEvent event) {
 
     SerialPort serialPort;
 
-    volatile boolean closed = false;
+    volatile boolean closed;
 
     @Override
     public void eventSunk(final ChannelPipeline pipeline, final ChannelEvent e) throws Exception {

File: transport-sctp/src/main/java/io/netty/channel/sctp/SctpProviderMetadata.java
Patch:
@@ -37,7 +37,7 @@
  * Provides information which is specific to a NIO service provider
  * implementation.
  */
-class SctpProviderMetadata {
+final class SctpProviderMetadata {
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SctpProviderMetadata.class);
 

File: transport/src/main/java/io/netty/bootstrap/Bootstrap.java
Patch:
@@ -213,7 +213,7 @@ public void setPipelineAsMap(Map<String, ChannelHandler> pipelineMap) {
         }
 
         ChannelPipeline pipeline = pipeline();
-        for(Map.Entry<String, ChannelHandler> e: pipelineMap.entrySet()) {
+        for (Map.Entry<String, ChannelHandler> e: pipelineMap.entrySet()) {
             pipeline.addLast(e.getKey(), e.getValue());
         }
 

File: transport/src/main/java/io/netty/channel/ChannelEvent.java
Patch:
@@ -55,7 +55,7 @@
  *
  * <table border="1" cellspacing="0" cellpadding="6">
  * <tr>
- * <th>Event name</th></th><th>Event type and condition</th><th>Meaning</th>
+ * <th>Event name</th><th>Event type and condition</th><th>Meaning</th>
  * </tr>
  * <tr>
  * <td>{@code "messageReceived"}</td>

File: transport/src/main/java/io/netty/channel/ChannelFutureAggregator.java
Patch:
@@ -36,7 +36,7 @@ public ChannelFutureAggregator(ChannelFuture aggregateFuture) {
     }
 
     public void addFuture(ChannelFuture future) {
-        synchronized(this) {
+        synchronized (this) {
             if (pendingFutures == null) {
                 pendingFutures = new HashSet<ChannelFuture>();
             }
@@ -74,4 +74,4 @@ public void operationComplete(ChannelFuture future)
         }
         
     }
-}
\ No newline at end of file
+}

File: transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
Patch:
@@ -51,7 +51,7 @@
  *     public void login(String username, password) {
  *         {@link Channels}.write(
  *                 <b>this.ctx</b>,
- *                 {@link Channels}.succeededFuture(<b>this.ctx</t>.getChannel()</b>),
+ *                 {@link Channels}.succeededFuture(<b>this.ctx.getChannel()</b>),
  *                 new LoginMessage(username, password));
  *     }
  *     ...

File: transport/src/main/java/io/netty/channel/ChannelPipeline.java
Patch:
@@ -215,7 +215,7 @@ public interface ChannelPipeline {
      * @throws NullPointerException
      *         if the specified name or handler is {@code null}
      */
-    void addFirst (String name, ChannelHandler handler);
+    void addFirst(String name, ChannelHandler handler);
 
     /**
      * Appends a {@link ChannelHandler} at the last position of this pipeline.
@@ -228,7 +228,7 @@ public interface ChannelPipeline {
      * @throws NullPointerException
      *         if the specified name or handler is {@code null}
      */
-    void addLast  (String name, ChannelHandler handler);
+    void addLast(String name, ChannelHandler handler);
 
     /**
      * Inserts a {@link ChannelHandler} before an existing handler of this
@@ -262,7 +262,7 @@ public interface ChannelPipeline {
      * @throws NullPointerException
      *         if the specified baseName, name, or handler is {@code null}
      */
-    void addAfter (String baseName, String name, ChannelHandler handler);
+    void addAfter(String baseName, String name, ChannelHandler handler);
 
     /**
      * Removes the specified {@link ChannelHandler} from this pipeline.

File: transport/src/main/java/io/netty/channel/Channels.java
Patch:
@@ -47,7 +47,7 @@
  * {@link ChannelHandlerContext#sendDownstream(ChannelEvent)} by yourself.
  * @apiviz.landmark
  */
-public class Channels {
+public final class Channels {
 
     // pipeline factory methods
 

File: transport/src/main/java/io/netty/channel/iostream/IOStreamAddress.java
Patch:
@@ -26,8 +26,6 @@
  */
 public class IOStreamAddress extends SocketAddress {
 
-    /**
- */
     private static final long serialVersionUID = -4382415449059935960L;
 
     private final InputStream inputStream;

File: transport/src/main/java/io/netty/channel/local/DefaultLocalChannel.java
Patch:
@@ -171,15 +171,15 @@ void closeNow(ChannelFuture future) {
     void flushWriteBuffer() {
         DefaultLocalChannel pairedChannel = this.pairedChannel;
         if (pairedChannel != null) {
-            if (pairedChannel.isConnected()){
+            if (pairedChannel.isConnected()) {
                 // Channel is open and connected and channelConnected event has
                 // been fired.
                 if (!delivering.get()) {
                     delivering.set(true);
                     try {
                         for (;;) {
                             MessageEvent e = writeBuffer.poll();
-                            if(e == null) {
+                            if (e == null) {
                                 break;
                             }
 
@@ -206,7 +206,7 @@ void flushWriteBuffer() {
 
             for (;;) {
                 MessageEvent e = writeBuffer.poll();
-                if(e == null) {
+                if (e == null) {
                     break;
                 }
 

File: transport/src/main/java/io/netty/channel/local/LocalAddress.java
Patch:
@@ -104,7 +104,7 @@ public boolean equals(Object o) {
     public int compareTo(LocalAddress o) {
         if (ephemeral) {
             if (o.ephemeral) {
-                if (this == o){
+                if (this == o) {
                     return 0;
                 }
 

File: transport/src/main/java/io/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -76,8 +76,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
                 future.setSuccess();
                 break;
             }
-        }
-        else if (e instanceof MessageEvent) {
+        } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
             DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
             boolean offered = channel.writeBuffer.offer(event);

File: transport/src/main/java/io/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -39,8 +39,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
         Channel channel = e.getChannel();
         if (channel instanceof DefaultLocalServerChannel) {
             handleServerChannel(e);
-        }
-        else if (channel instanceof DefaultLocalChannel) {
+        } else if (channel instanceof DefaultLocalChannel) {
             handleAcceptedChannel(e);
         }
     }

File: transport/src/main/java/io/netty/channel/socket/nio/AbstractWriteRequestQueue.java
Patch:
@@ -29,7 +29,7 @@
 
 
  */
-abstract class AbstractWriteRequestQueue implements BlockingQueue<MessageEvent>{
+abstract class AbstractWriteRequestQueue implements BlockingQueue<MessageEvent> {
 
     protected final BlockingQueue<MessageEvent> queue;
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioClientSocketChannelFactory.java
Patch:
@@ -117,7 +117,7 @@ public NioClientSocketChannelFactory(
     public NioClientSocketChannelFactory(
             Executor bossExecutor, Executor workerExecutor,
             int workerCount) {
-    	this(bossExecutor, workerExecutor, DEFAULT_BOSS_COUNT, workerCount);
+        this(bossExecutor, workerExecutor, DEFAULT_BOSS_COUNT, workerCount);
     }
     
     /**
@@ -135,7 +135,7 @@ public NioClientSocketChannelFactory(
     public NioClientSocketChannelFactory(
             Executor bossExecutor, Executor workerExecutor,
             int bossCount, int workerCount) {
-    	
+
         if (bossExecutor == null) {
             throw new NullPointerException("bossExecutor");
         }

File: transport/src/main/java/io/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -54,7 +54,7 @@ class NioClientSocketPipelineSink extends AbstractChannelSink {
 
     final Executor bossExecutor;
 
-    private final Boss bosses[];
+    private final Boss[] bosses;
     private final NioWorker[] workers;
     
     private final AtomicInteger bossIndex = new AtomicInteger();
@@ -63,12 +63,12 @@ class NioClientSocketPipelineSink extends AbstractChannelSink {
     NioClientSocketPipelineSink(
             Executor bossExecutor, Executor workerExecutor,
             int bossCount, int workerCount) {
-    	
+
         this.bossExecutor = bossExecutor;
 
         bosses = new Boss[bossCount];
         for (int i = 0; i < bosses.length; i ++) {
-        	bosses[i] = new Boss();
+            bosses[i] = new Boss();
         }
 
         workers = new NioWorker[workerCount];

File: transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -44,7 +44,7 @@
 /**
  * Provides an NIO based {@link io.netty.channel.socket.DatagramChannel}.
  */
-class NioDatagramChannel extends AbstractChannel
+final class NioDatagramChannel extends AbstractChannel
                                 implements io.netty.channel.socket.DatagramChannel {
 
     /**

File: transport/src/main/java/io/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -37,7 +37,7 @@
  * Provides information which is specific to a NIO service provider
  * implementation.
  */
-class NioProviderMetadata {
+final class NioProviderMetadata {
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(NioProviderMetadata.class);
 

File: transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -36,7 +36,7 @@
 
 /**
  */
-class NioServerSocketChannel extends AbstractServerChannel
+final class NioServerSocketChannel extends AbstractServerChannel
                              implements io.netty.channel.socket.ServerSocketChannel {
 
     private static final InternalLogger logger =

File: transport/src/main/java/io/netty/channel/socket/nio/SocketReceiveBufferPool.java
Patch:
@@ -68,7 +68,7 @@ void release(ByteBuffer buffer) {
 
         // pool is full - replace one
         final int capacity = buffer.capacity();
-        for (int i = 0; i< POOL_SIZE; i ++) {
+        for (int i = 0; i < POOL_SIZE; i ++) {
             SoftReference<ByteBuffer> ref = pool[i];
             ByteBuffer pooled = ref.get();
             if (pooled == null) {

File: transport/src/main/java/io/netty/channel/socket/nio/SocketSendBufferPool.java
Patch:
@@ -35,7 +35,7 @@ final class SocketSendBufferPool {
     private static final int ALIGN_SHIFT = 4;
     private static final int ALIGN_MASK = 15;
 
-    PreallocationRef poolHead = null;
+    PreallocationRef poolHead;
     Preallocation current = new Preallocation(DEFAULT_PREALLOCATION_SIZE);
 
     SocketSendBufferPool() {

File: transport/src/main/java/io/netty/channel/socket/oio/OioAcceptedSocketChannel.java
Patch:
@@ -30,7 +30,7 @@
 
 /**
  */
-class OioAcceptedSocketChannel extends OioSocketChannel {
+final class OioAcceptedSocketChannel extends OioSocketChannel {
 
     private final PushbackInputStream in;
     private final OutputStream out;

File: transport/src/main/java/io/netty/channel/socket/oio/OioClientSocketChannel.java
Patch:
@@ -27,7 +27,7 @@
 
 /**
  */
-class OioClientSocketChannel extends OioSocketChannel {
+final class OioClientSocketChannel extends OioSocketChannel {
 
     volatile PushbackInputStream in;
     volatile OutputStream out;

File: transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -36,7 +36,7 @@
 
 /**
  */
-class OioServerSocketChannel extends AbstractServerChannel
+final class OioServerSocketChannel extends AbstractServerChannel
                              implements ServerSocketChannel {
 
     private static final InternalLogger logger =

File: codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -29,7 +29,7 @@
  * This encoder is for one time use only.  Create a new instance for each URI.
  *
  * <pre>
- * {@link QueryStringEncoder} encoder = new {@link QueryStringDecoder}("/hello");
+ * {@link QueryStringEncoder} encoder = new {@link QueryStringEncoder}("/hello");
  * encoder.addParam("recipient", "world");
  * assert encoder.toString().equals("/hello?recipient=world");
  * </pre>

File: src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java
Patch:
@@ -55,7 +55,7 @@ protected ObjectStreamClass readClassDescriptor()
         case CompactObjectOutputStream.TYPE_THIN_DESCRIPTOR:
             String className = readUTF();
             Class<?> clazz = classResolver.resolve(className);
-            return ObjectStreamClass.lookupAny(clazz);
+            return ObjectStreamClass.lookup(clazz);
         default:
             throw new StreamCorruptedException(
                     "Unexpected class descriptor type: " + type);

File: src/main/java/io/netty/handler/codec/serialization/CompactObjectOutputStream.java
Patch:
@@ -39,7 +39,7 @@ protected void writeStreamHeader() throws IOException {
     @Override
     protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {
         Class<?> clazz = desc.forClass();
-        if (clazz.isPrimitive() || clazz.isArray()) {
+        if (clazz.isPrimitive() || clazz.isArray() || desc.getSerialVersionUID() == 0) {
             write(TYPE_FAT_DESCRIPTOR);
             super.writeClassDescriptor(desc);
         } else {

File: src/main/java/io/netty/handler/execution/seda/SimpleSedaExecutor.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * {@link SedaExecutor} which use two different {@link Executor}'s. One is used for upstream events and one for downstream events.
  * 
- * You should use an {@link SedaOrderedMemoryAwareThreadPoolExecutor} if you care about the order of thread-execution. In most cases this should be the case
+ * You should use a {@link SedaOrderedMemoryAwareThreadPoolExecutor} if you care about the order of thread-execution. In most cases this should be the case
  * 
  * 
  *
@@ -34,7 +34,7 @@ public class SimpleSedaExecutor extends SedaExecutor{
     private final Executor downstreamExecutor;
 
     /**
-     * Constrct an {@link SimpleSedaExecutor} which use two different {@link Executor}'s. One is used for upstream events and one for downstream events.
+     * Construct an {@link SimpleSedaExecutor} which use two different {@link Executor}'s. One is used for upstream events and one for downstream events.
      * 
      * @param upstreamExecutor the {@link Executor} which is used for upstream events
      * @param downstreamExecutor the {@link Executor} which is used for downstream events

File: src/main/java/io/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -286,8 +286,8 @@ private ChannelHandler replace(DefaultChannelHandlerContext ctx, String newName,
 
             if (!sameName) {
                 name2ctx.remove(ctx.getName());
-                name2ctx.put(newName, newCtx);
             }
+            name2ctx.put(newName, newCtx);
 
             ChannelHandlerLifeCycleException removeException = null;
             ChannelHandlerLifeCycleException addException = null;

File: src/main/java/io/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -289,7 +289,7 @@ public abstract class ReplayingDecoder<T extends Enum<T>>
 
 
     private ChannelBuffer cumulation;
-    private boolean needsCleanup = false;
+    private boolean needsCleanup;
     private final boolean unfold;
     private ReplayingDecoderBuffer replayable;
     private T state;

File: src/main/java/org/jboss/netty/channel/socket/sctp/SctpPayload.java
Patch:
@@ -39,7 +39,7 @@ public SctpPayload(int streamIdentifier, int protocolIdentifier, ChannelBuffer p
         this.payloadBuffer = payloadBuffer;
     }
 
-    public int getstreamIdentifier() {
+    public int getStreamIdentifier() {
         return streamIdentifier;
     }
 

File: src/main/java/org/jboss/netty/channel/socket/sctp/SctpSendBufferPool.java
Patch:
@@ -54,7 +54,7 @@ final SendBuffer acquire(Object message) {
 
     private final SendBuffer acquire(SctpPayload message) {
         final ChannelBuffer src = message.getPayloadBuffer();
-        final int streamNo = message.getstreamIdentifier();
+        final int streamNo = message.getStreamIdentifier();
         final int protocolId = message.getProtocolIdentifier();
 
         final int size = src.readableBytes();

File: src/main/java/org/jboss/netty/example/http/websocket/WebSocketServerIndexPage.java
Patch:
@@ -46,7 +46,7 @@ public static ChannelBuffer getContent(String webSocketLocation) {
         "} else {" + NEWLINE +
         "  alert(\"Your browser does not support Web Socket.\");" + NEWLINE +
         "}" + NEWLINE +
-        "" + NEWLINE +
+        NEWLINE +
         "function send(message) {" + NEWLINE +
         "  if (!window.WebSocket) { return; }" + NEWLINE +
         "  if (socket.readyState == WebSocket.OPEN) {" + NEWLINE +

File: src/main/java/org/jboss/netty/example/http/websocketx/server/WebSocketServerIndexPage.java
Patch:
@@ -50,7 +50,7 @@ public static ChannelBuffer getContent(String webSocketLocation) {
         "} else {" + NEWLINE +
         "  alert(\"Your browser does not support Web Socket.\");" + NEWLINE +
         "}" + NEWLINE +
-        "" + NEWLINE +
+        NEWLINE +
         "function send(message) {" + NEWLINE +
         "  if (!window.WebSocket) { return; }" + NEWLINE +
         "  if (socket.readyState == WebSocket.OPEN) {" + NEWLINE +

File: src/main/java/org/jboss/netty/example/http/websocketx/sslserver/WebSocketSslServerIndexPage.java
Patch:
@@ -50,7 +50,7 @@ public static ChannelBuffer getContent(String webSocketLocation) {
         "} else {" + NEWLINE +
         "  alert(\"Your browser does not support Web Socket.\");" + NEWLINE +
         "}" + NEWLINE +
-        "" + NEWLINE +
+        NEWLINE +
         "function send(message) {" + NEWLINE +
         "  if (!window.WebSocket) { return; }" + NEWLINE +
         "  if (socket.readyState == WebSocket.OPEN) {" + NEWLINE +

File: src/main/java/org/jboss/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java
Patch:
@@ -92,8 +92,6 @@ private WebSocketSslServerSslContext() {
 				throw new Error("Failed to initialize the server-side SSLContext", e);
 			}
 			_serverContext = serverContext;
-
-			return;
 		} catch (Exception ex) {
 			logger.error("Error initializing SslContextManager. " + ex.getMessage(), ex);
 			System.exit(1);

File: src/main/java/org/jboss/netty/example/localtime/LocalTimeServerHandler.java
Patch:
@@ -93,6 +93,6 @@ public void exceptionCaught(
     }
 
     private static String toString(Continent c) {
-        return "" + c.name().charAt(0) + c.name().toLowerCase().substring(1);
+        return c.name().charAt(0) + c.name().toLowerCase().substring(1);
     }
 }

File: src/main/java/org/jboss/netty/channel/socket/sctp/SctpNotificationEvent.java
Patch:
@@ -40,9 +40,6 @@ public SctpNotificationEvent(Channel channel, Notification notification, Object
         if (notification == null) {
             throw new NullPointerException("notification");
         }
-        if (value == null) {
-            throw new NullPointerException("value");
-        }
 
         this.channel = channel;
         this.notification = notification;

File: src/main/java/org/jboss/netty/channel/socket/sctp/SctpWorker.java
Patch:
@@ -256,7 +256,7 @@ private void processWriteTaskQueue() throws IOException {
         }
     }
 
-    private void processSelectedKeys(Set<SelectionKey> selectedKeys) throws IOException {
+    private void processSelectedKeys(final Set<SelectionKey> selectedKeys) throws IOException {
         for (Iterator<SelectionKey> i = selectedKeys.iterator(); i.hasNext();) {
             SelectionKey k = i.next();
             i.remove();
@@ -513,15 +513,15 @@ private void write0(SctpChannelImpl channel) {
             channel.inWriteNowLoop = false;
         }
 
-        fireWriteComplete(channel, writtenBytes);
-
         if (open) {
             if (addOpWrite) {
                 setOpWrite(channel);
             } else if (removeOpWrite) {
                 clearOpWrite(channel);
             }
         }
+
+        fireWriteComplete(channel, writtenBytes);
     }
 
     private void setOpWrite(SctpChannelImpl channel) {

File: src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java
Patch:
@@ -545,7 +545,7 @@ synchronized void increase(long amount) {
                 try {
                     wait();
                 } catch (InterruptedException e) {
-                    Thread.currentThread().interrupt();
+                    // Ignore
                 } finally {
                     waiters --;
                 }

File: src/test/java/org/jboss/netty/handler/codec/serialization/CompactObjectSerializationTest.java
Patch:
@@ -32,7 +32,7 @@ public void testInterfaceSerialization() throws Exception {
         PipedOutputStream pipeOut = new PipedOutputStream();
         PipedInputStream pipeIn = new PipedInputStream(pipeOut);
         CompactObjectOutputStream out = new CompactObjectOutputStream(pipeOut);
-        CompactObjectInputStream in = new CompactObjectInputStream(pipeIn);
+        CompactObjectInputStream in = new CompactObjectInputStream(pipeIn, ClassResolvers.cacheDisabled(null));
         out.writeObject(List.class);
         Assert.assertSame(List.class, in.readObject());
     }

File: src/main/java/org/jboss/netty/handler/codec/serialization/ObjectDecoder.java
Patch:
@@ -64,7 +64,7 @@ public ObjectDecoder() {
      *                       will be raised.
      */
     public ObjectDecoder(int maxObjectSize) {
-        this(maxObjectSize, ClassResolvers.cachingResolver(null));
+        this(maxObjectSize, ClassResolvers.weakCachingResolver(null));
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/serialization/ObjectDecoderInputStream.java
Patch:
@@ -104,7 +104,7 @@ public ObjectDecoderInputStream(InputStream in, ClassLoader classLoader, int max
         } else {
             this.in = new DataInputStream(in);
         }
-        this.classResolver = ClassResolvers.cachingResolver(classLoader);
+        this.classResolver = ClassResolvers.weakCachingResolver(classLoader);
         this.maxObjectSize = maxObjectSize;
     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -58,16 +58,17 @@ class NioClientSocketPipelineSink extends AbstractChannelSink {
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(NioClientSocketPipelineSink.class);
 
+    private static final int DEFAULT_BOSS_COUNT = 1;
     final Executor bossExecutor;
-    private int numBosses = 1;
+    private final int numBosses;
     private final Boss bosses[];
     private final NioWorker[] workers;
     
     private final AtomicInteger bossIndex = new AtomicInteger();
     private final AtomicInteger workerIndex = new AtomicInteger();
 
     NioClientSocketPipelineSink(Executor bossExecutor, Executor workerExecutor, int workerCount) {
-        this(bossExecutor, workerExecutor, 1, workerCount);
+        this(bossExecutor, workerExecutor, DEFAULT_BOSS_COUNT, workerCount);
     }
     
     NioClientSocketPipelineSink(Executor bossExecutor, Executor workerExecutor, int bossCount, int workerCount) {

File: src/main/java/org/jboss/netty/bootstrap/Bootstrap.java
Patch:
@@ -60,7 +60,6 @@ public class Bootstrap implements ExternalResourceReleasable {
      * I/O operation is requested.
      */
     protected Bootstrap() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java
Patch:
@@ -118,7 +118,6 @@ public class ClientBootstrap extends Bootstrap {
      * operation is requested.
      */
     public ClientBootstrap() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java
Patch:
@@ -127,7 +127,6 @@ public class ConnectionlessBootstrap extends Bootstrap {
      * operation is requested.
      */
     public ConnectionlessBootstrap() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -170,7 +170,6 @@ public class ServerBootstrap extends Bootstrap {
      * operation is requested.
      */
     public ServerBootstrap() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -804,8 +804,7 @@ public static ChannelBuffer copiedBuffer(
     }
 
     private static ChannelBuffer copiedBuffer(ByteOrder endianness, CharBuffer buffer, Charset charset) {
-        CharBuffer src = buffer;
-        ByteBuffer dst = ChannelBuffers.encodeString(src, charset);
+        ByteBuffer dst = ChannelBuffers.encodeString(buffer, charset);
         ChannelBuffer result = wrappedBuffer(endianness, dst.array());
         result.writerIndex(dst.remaining());
         return result;

File: src/main/java/org/jboss/netty/buffer/HeapChannelBufferFactory.java
Patch:
@@ -57,7 +57,6 @@ public static ChannelBufferFactory getInstance(ByteOrder endianness) {
      * {@link ByteOrder#BIG_ENDIAN}.
      */
     public HeapChannelBufferFactory() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/AbstractChannelSink.java
Patch:
@@ -31,7 +31,6 @@ public abstract class AbstractChannelSink implements ChannelSink {
      * Creates a new instance.
      */
     protected AbstractChannelSink() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/ChannelException.java
Patch:
@@ -33,7 +33,6 @@ public class ChannelException extends RuntimeException {
      * Creates a new exception.
      */
     public ChannelException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/ChannelHandlerLifeCycleException.java
Patch:
@@ -35,7 +35,6 @@ public class ChannelHandlerLifeCycleException extends RuntimeException {
      * Creates a new exception.
      */
     public ChannelHandlerLifeCycleException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/ChannelPipelineException.java
Patch:
@@ -35,7 +35,6 @@ public class ChannelPipelineException extends ChannelException {
      * Creates a new instance.
      */
     public ChannelPipelineException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/ChannelState.java
Patch:
@@ -100,5 +100,5 @@ public enum ChannelState {
      * Represents a {@link Channel}'s {@link Channel#getInterestOps() interestOps}
      * property
      */
-    INTEREST_OPS;
+    INTEREST_OPS
 }

File: src/main/java/org/jboss/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -817,7 +817,6 @@ public void sendUpstream(ChannelEvent e) {
 
     private static final class DiscardingChannelSink implements ChannelSink {
         DiscardingChannelSink() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/SimpleChannelDownstreamHandler.java
Patch:
@@ -61,7 +61,6 @@ public class SimpleChannelDownstreamHandler implements ChannelDownstreamHandler
      * Creates a new instance.
      */
     public SimpleChannelDownstreamHandler() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/SimpleChannelHandler.java
Patch:
@@ -85,7 +85,6 @@ public class SimpleChannelHandler implements ChannelUpstreamHandler, ChannelDown
      * Creates a new instance.
      */
     public SimpleChannelHandler() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/SimpleChannelUpstreamHandler.java
Patch:
@@ -65,7 +65,6 @@ public class SimpleChannelUpstreamHandler implements ChannelUpstreamHandler {
      * Creates a new instance.
      */
     public SimpleChannelUpstreamHandler() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/group/CombinedIterator.java
Patch:
@@ -59,8 +59,7 @@ public boolean hasNext() {
     @Override
     public E next() {
         try {
-            E e = currentIterator.next();
-            return e;
+            return currentIterator.next();
         } catch (NoSuchElementException e) {
             if (currentIterator == i1) {
                 currentIterator = i2;

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -43,7 +43,6 @@ final class LocalClientChannelSink extends AbstractChannelSink {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(LocalClientChannelSink.class);
 
     LocalClientChannelSink() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -36,7 +36,6 @@
 final class LocalServerChannelSink extends AbstractChannelSink {
 
     LocalServerChannelSink() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelMessageUtils.java
Patch:
@@ -252,9 +252,7 @@ public static boolean hasContents(HttpResponse response,
     }
 
     public static HttpResponse createTunnelCloseResponse() {
-        HttpResponse response =
-                createResponseTemplate(HttpResponseStatus.RESET_CONTENT, null);
-        return response;
+        return createResponseTemplate(HttpResponseStatus.RESET_CONTENT, null);
     }
 
     public static boolean isTunnelCloseResponse(HttpResponse response) {

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelServerChannel.java
Patch:
@@ -103,7 +103,6 @@ private final class TunnelCreator implements
             HttpTunnelAcceptedChannelFactory {
 
         TunnelCreator() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/socket/http/ServerMessageSwitch.java
Patch:
@@ -258,7 +258,6 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
     private static final class TunnelInfo {
         TunnelInfo() {
-            super();
         }
 
         public String tunnelId;

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -173,7 +173,6 @@ private final class Boss implements Runnable {
         private final Queue<Runnable> registerTaskQueue = new LinkedTransferQueue<Runnable>();
 
         Boss() {
-            super();
         }
 
         void register(NioClientSocketChannel channel) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -260,7 +260,6 @@ private final class WriteRequestQueue extends
         private final ThreadLocalBoolean notifying = new ThreadLocalBoolean();
 
         WriteRequestQueue() {
-            super();
         }
 
         /**
@@ -330,7 +329,6 @@ private int getMessageSize(MessageEvent e) {
      */
     private final class WriteTask implements Runnable {
         WriteTask() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -220,7 +220,6 @@ private static int detectConstraintLevelFromSystemProperties() {
     private static final class ConstraintLevelAutodetector {
 
         ConstraintLevelAutodetector() {
-            super();
         }
 
         int autodetect() {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -206,7 +206,6 @@ private final class WriteRequestQueue extends LinkedTransferQueue<MessageEvent>
         private final ThreadLocalBoolean notifying = new ThreadLocalBoolean();
 
         WriteRequestQueue() {
-            super();
         }
 
         @Override
@@ -265,7 +264,6 @@ private int getMessageSize(MessageEvent e) {
     private final class WriteTask implements Runnable {
 
         WriteTask() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/socket/nio/SocketSendBufferPool.java
Patch:
@@ -42,7 +42,6 @@ final class SocketSendBufferPool {
     Preallocation current = new Preallocation(DEFAULT_PREALLOCATION_SIZE);
 
     SocketSendBufferPool() {
-        super();
     }
 
     SendBuffer acquire(Object message) {
@@ -316,7 +315,6 @@ public void release() {
     static final class EmptySendBuffer implements SendBuffer {
 
         EmptySendBuffer() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/example/http/upload/HttpRequestHandler.java
Patch:
@@ -267,7 +267,6 @@ private void readHttpDataChunkByChunk(Channel channel) {
             // end
             responseContent
                     .append("\r\n\r\nEND OF CONTENT CHUNK BY CHUNK\r\n\r\n");
-            return;
         }
     }
 

File: src/main/java/org/jboss/netty/example/http/websocketx/autobahn/WebSocketServerHandler.java
Patch:
@@ -84,7 +84,6 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throw
 		} else {
 			this.handshaker.executeOpeningHandshake(ctx, req);
 		}
-		return;
 	}
 
 	private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {

File: src/main/java/org/jboss/netty/example/http/websocketx/client/App.java
Patch:
@@ -98,7 +98,6 @@ public static class MyCallbackHandler implements WebSocketCallback {
 		public ArrayList<String> messagesReceived = new ArrayList<String>();
 
 		public MyCallbackHandler() {
-			return;
 		}
 
 		@Override

File: src/main/java/org/jboss/netty/example/http/websocketx/server/WebSocketServerHandler.java
Patch:
@@ -104,7 +104,6 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throw
 		} else {
 			this.handshaker.executeOpeningHandshake(ctx, req);
 		}
-		return;
 	}
 
 	private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {

File: src/main/java/org/jboss/netty/example/qotm/QuoteOfTheMomentServerHandler.java
Patch:
@@ -32,7 +32,7 @@ public class QuoteOfTheMomentServerHandler extends SimpleChannelUpstreamHandler
     private static final Random random = new Random();
 
     // Quotes from Mohandas K. Gandhi:
-    private static final String[] quotes = new String[] {
+    private static final String[] quotes = {
         "Where there is love there is life.",
         "First they ignore you, then they laugh at you, then they fight you, then you win.",
         "Be the change you want to see in the world.",

File: src/main/java/org/jboss/netty/example/securechat/SecureChatKeyStore.java
Patch:
@@ -36,7 +36,7 @@
  * @version $Rev$, $Date$
  */
 public class SecureChatKeyStore {
-    private static final short[] DATA = new short[] {
+    private static final short[] DATA = {
         0xfe, 0xed, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x02,
         0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
         0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,

File: src/main/java/org/jboss/netty/handler/codec/compression/CompressionException.java
Patch:
@@ -33,7 +33,6 @@ public class CompressionException extends RuntimeException {
      * Creates a new instance.
      */
     public CompressionException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/compression/ZlibUtil.java
Patch:
@@ -58,6 +58,5 @@ static Enum<?> convertWrapperType(ZlibWrapper wrapper) {
     }
 
     private ZlibUtil() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/compression/ZlibWrapper.java
Patch:
@@ -40,5 +40,5 @@ public enum ZlibWrapper {
      * Try {@link #ZLIB} first and then {@link #NONE} if the first attempt fails.
      * Please note that you can specify this wrapper type only when decompressing.
      */
-    ZLIB_OR_NONE;
+    ZLIB_OR_NONE
 }

File: src/main/java/org/jboss/netty/handler/codec/embedder/AbstractCodecEmbedder.java
Patch:
@@ -194,7 +194,6 @@ public ChannelPipeline getPipeline() {
 
     private final class EmbeddedChannelSink implements ChannelSink, ChannelUpstreamHandler {
         EmbeddedChannelSink() {
-            super();
         }
 
         @Override
@@ -234,7 +233,6 @@ public void exceptionCaught(
     private static final class EmbeddedChannelPipeline extends DefaultChannelPipeline {
 
         EmbeddedChannelPipeline() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/handler/codec/embedder/CodecEmbedderException.java
Patch:
@@ -33,7 +33,6 @@ public class CodecEmbedderException extends RuntimeException {
      * Creates a new instance.
      */
     public CodecEmbedderException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannelFactory.java
Patch:
@@ -29,7 +29,6 @@ class EmbeddedChannelFactory implements ChannelFactory {
     static final ChannelFactory INSTANCE = new EmbeddedChannelFactory();
 
     private EmbeddedChannelFactory() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/frame/CorruptedFrameException.java
Patch:
@@ -34,7 +34,6 @@ public class CorruptedFrameException extends Exception {
      * Creates a new instance.
      */
     public CorruptedFrameException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/frame/TooLongFrameException.java
Patch:
@@ -34,7 +34,6 @@ public class TooLongFrameException extends Exception {
      * Creates a new instance.
      */
     public TooLongFrameException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/CaseIgnoringComparator.java
Patch:
@@ -31,7 +31,6 @@ final class CaseIgnoringComparator implements Comparator<String>, Serializable {
     static final CaseIgnoringComparator INSTANCE = new CaseIgnoringComparator();
 
     private CaseIgnoringComparator() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpClientCodec.java
Patch:
@@ -87,7 +87,6 @@ public void handleDownstream(ChannelHandlerContext ctx, ChannelEvent e)
     private final class Encoder extends HttpRequestEncoder {
 
         Encoder() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCodecUtil.java
Patch:
@@ -50,7 +50,7 @@ class HttpCodecUtil {
     /**
      * carriage return line feed
      */
-    static final byte[] CRLF = new byte[] { CR, LF };
+    static final byte[] CRLF = { CR, LF };
 
     /**
     * Colon ':'
@@ -72,7 +72,6 @@ class HttpCodecUtil {
     static final Charset DEFAULT_CHARSET = CharsetUtil.UTF_8;
 
     private HttpCodecUtil() {
-        super();
     }
 
     static void validateHeaderName(String name) {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -54,7 +54,6 @@ public abstract class HttpContentDecoder extends SimpleChannelUpstreamHandler {
      * Creates a new instance.
      */
     protected HttpContentDecoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -61,7 +61,6 @@ public abstract class HttpContentEncoder extends SimpleChannelHandler {
      * Creates a new instance.
      */
     protected HttpContentEncoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -310,7 +310,6 @@ public static final class Names {
         public static final String WWW_AUTHENTICATE = "WWW-Authenticate";
 
         private Names() {
-            super();
         }
     }
 
@@ -455,7 +454,6 @@ public static final class Values {
         public static final String WEBSOCKET = "WebSocket";
 
         private Values() {
-            super();
         }
     }
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -136,7 +136,7 @@ protected enum State {
         READ_CHUNKED_CONTENT,
         READ_CHUNKED_CONTENT_AS_CHUNKS,
         READ_CHUNK_DELIMITER,
-        READ_CHUNK_FOOTER;
+        READ_CHUNK_FOOTER
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -59,7 +59,6 @@ public abstract class HttpMessageEncoder extends OneToOneEncoder {
      * Creates a new instance.
      */
     protected HttpMessageEncoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpPostBodyUtil.java
Patch:
@@ -119,7 +119,6 @@ public String toString() {
     }
 
     private HttpPostBodyUtil() {
-        super();
     }
 
     //Some commons methods between HttpPostRequestDecoder and HttpMessageDecoder

File: src/main/java/org/jboss/netty/handler/codec/http/HttpPostRequestEncoder.java
Patch:
@@ -965,7 +965,6 @@ public static class ErrorDataEncoderException extends Exception {
          *
          */
         public ErrorDataEncoderException() {
-            super();
         }
 
         /**

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -65,7 +65,6 @@ public class HttpRequestDecoder extends HttpMessageDecoder {
      * {@code maxChunkSize (8192)}.
      */
     public HttpRequestDecoder() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -34,7 +34,6 @@ public class HttpRequestEncoder extends HttpMessageEncoder {
      * Creates a new instance.
      */
     public HttpRequestEncoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -94,7 +94,6 @@ public class HttpResponseDecoder extends HttpMessageDecoder {
      * {@code maxChunkSize (8192)}.
      */
     public HttpResponseDecoder() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseEncoder.java
Patch:
@@ -34,7 +34,6 @@ public class HttpResponseEncoder extends HttpMessageEncoder {
      * Creates a new instance.
      */
     public HttpResponseEncoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/InterfaceHttpData.java
Patch:
@@ -25,7 +25,7 @@
  */
 public interface InterfaceHttpData extends Comparable<InterfaceHttpData> {
     enum HttpDataType {
-        Attribute, FileUpload, InternalAttribute;
+        Attribute, FileUpload, InternalAttribute
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
Patch:
@@ -204,7 +204,6 @@ protected byte[] createRandomBytes(int size) {
      * @return Random number
      */
     protected int createRandomNumber(int min, int max) {
-        int rand = (int) (Math.random() * max + min);
-        return rand;
+        return (int) (Math.random() * max + min);
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
Patch:
@@ -65,7 +65,6 @@ public class WebSocketClientHandshaker00 extends WebSocketClientHandshaker {
      */
     public WebSocketClientHandshaker00(URI webSocketURL, WebSocketSpecificationVersion version, String subProtocol) {
         super(webSocketURL, version, subProtocol);
-        return;
     }
 
     /**
@@ -206,7 +205,6 @@ public void endOpeningHandshake(ChannelHandlerContext ctx, HttpResponse response
         ctx.getPipeline().replace("decoder", "ws-decoder", new WebSocket00FrameDecoder());
 
         this.setOpenningHandshakeCompleted(true);
-        return;
     }
 
     private String insertRandomCharacters(String key) {

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketClientHandshaker10.java
Patch:
@@ -73,7 +73,6 @@ public class WebSocketClientHandshaker10 extends WebSocketClientHandshaker {
     public WebSocketClientHandshaker10(URI webSocketURL, WebSocketSpecificationVersion version, String subProtocol, boolean allowExtensions) {
         super(webSocketURL, version, subProtocol);
         this.allowExtensions = allowExtensions;
-        return;
     }
 
     /**
@@ -134,7 +133,6 @@ public void beginOpeningHandshake(ChannelHandlerContext ctx, Channel channel) {
         channel.write(request);
 
         ctx.getPipeline().replace("encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
-        return;
     }
 
     /**
@@ -183,7 +181,6 @@ public void endOpeningHandshake(ChannelHandlerContext ctx, HttpResponse response
         ctx.getPipeline().replace("decoder", "ws-decoder", new WebSocket08FrameDecoder(false, this.allowExtensions));
 
         this.setOpenningHandshakeCompleted(true);
-        return;
     }
 
 }

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
Patch:
@@ -61,7 +61,6 @@ public WebSocketServerHandshaker(String webSocketURL, String subProtocols) {
                 this.subProtocolsArray[i] = this.subProtocolsArray[i].trim();
             }
         }
-        return;
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
Patch:
@@ -73,7 +73,6 @@ public class WebSocketServerHandshaker00 extends WebSocketServerHandshaker {
      */
     public WebSocketServerHandshaker00(String webSocketURL, String subProtocols) {
         super(webSocketURL, subProtocols);
-        return;
     }
 
     /**
@@ -185,7 +184,6 @@ public void executeOpeningHandshake(ChannelHandlerContext ctx, HttpRequest req)
         ctx.getChannel().write(res);
 
         p.replace("encoder", "wsencoder", new WebSocket00FrameEncoder());
-        return;
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketServerHandshaker10.java
Patch:
@@ -65,7 +65,6 @@ public class WebSocketServerHandshaker10 extends WebSocketServerHandshaker {
     public WebSocketServerHandshaker10(String webSocketURL, String subProtocols, boolean allowExtensions) {
         super(webSocketURL, subProtocols);
         this.allowExtensions = allowExtensions;
-        return;
     }
 
     /**
@@ -148,7 +147,6 @@ public void executeOpeningHandshake(ChannelHandlerContext ctx, HttpRequest req)
         p.replace("decoder", "wsdecoder", new WebSocket08FrameDecoder(true, this.allowExtensions));
         p.replace("encoder", "wsencoder", new WebSocket08FrameEncoder(false));
 
-        return;
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java
Patch:
@@ -54,7 +54,6 @@ public WebSocketServerHandshakerFactory(String webSocketURL, String subProtocols
         this.webSocketURL = webSocketURL;
         this.subProtocols = subProtocols;
         this.allowExtensions = allowExtensions;
-        return;
     }
 
     /**
@@ -91,7 +90,6 @@ public void sendUnsupportedWebSocketVersionResponse(ChannelHandlerContext ctx) {
         res.setStatus(HttpResponseStatus.UPGRADE_REQUIRED);
         res.setHeader(Names.SEC_WEBSOCKET_VERSION, "8");
         ctx.getChannel().write(res);
-        return;
     }
 
 }

File: src/main/java/org/jboss/netty/handler/codec/oneone/OneToOneDecoder.java
Patch:
@@ -57,7 +57,6 @@ public abstract class OneToOneDecoder implements ChannelUpstreamHandler {
      * Creates a new instance with the current system character set.
      */
     protected OneToOneDecoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/oneone/OneToOneEncoder.java
Patch:
@@ -51,7 +51,6 @@
 public abstract class OneToOneEncoder implements ChannelDownstreamHandler {
 
     protected OneToOneEncoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
Patch:
@@ -53,7 +53,6 @@ public class ProtobufVarint32FrameDecoder extends FrameDecoder {
      * Creates a new instance.
      */
     public ProtobufVarint32FrameDecoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
Patch:
@@ -52,7 +52,6 @@ public class ProtobufVarint32LengthFieldPrepender extends OneToOneEncoder {
      * Creates a new instance.
      */
     public ProtobufVarint32LengthFieldPrepender() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderBuffer.java
Patch:
@@ -363,7 +363,7 @@ public int readableBytes() {
         } else {
             return Integer.MAX_VALUE - buffer.readerIndex();
         }
-    }
+    } 
     
     @Override
     public boolean readBoolean() {

File: src/main/java/org/jboss/netty/handler/codec/replay/UnreplayableOperationException.java
Patch:
@@ -35,7 +35,6 @@ public class UnreplayableOperationException extends
      * Creates a new instance.
      */
     public UnreplayableOperationException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspHeaders.java
Patch:
@@ -218,7 +218,6 @@ public static final class Names {
         public static final String WWW_AUTHENTICATE = HttpHeaders.Names.WWW_AUTHENTICATE;
 
         private Names() {
-            super();
         }
     }
 
@@ -400,11 +399,9 @@ public static final class Values {
         public static final String URL = "url";
 
         protected Values() {
-            super();
         }
     }
 
     private RtspHeaders() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspMessageEncoder.java
Patch:
@@ -40,7 +40,6 @@ public abstract class RtspMessageEncoder extends HttpMessageEncoder {
      * Creates a new instance.
      */
     protected RtspMessageEncoder() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspMethods.java
Patch:
@@ -141,6 +141,5 @@ public static HttpMethod valueOf(String name) {
     }
 
     private RtspMethods() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestDecoder.java
Patch:
@@ -61,7 +61,6 @@ public class RtspRequestDecoder extends RtspMessageDecoder {
      * {@code maxContentLength (8192)}.
      */
     public RtspRequestDecoder() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseDecoder.java
Patch:
@@ -62,7 +62,6 @@ public class RtspResponseDecoder extends RtspMessageDecoder {
      * {@code maxContentLength (8192)}.
      */
     public RtspResponseDecoder() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseStatuses.java
Patch:
@@ -295,6 +295,5 @@ public static HttpResponseStatus valueOf(int code) {
     }
 
     private RtspResponseStatuses() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspVersions.java
Patch:
@@ -54,6 +54,5 @@ public static HttpVersion valueOf(String text) {
     }
 
     private RtspVersions() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/serialization/CompatibleObjectEncoder.java
Patch:
@@ -98,8 +98,7 @@ protected Object encode(ChannelHandlerContext context, Channel channel, Object m
         oout.writeObject(msg);
         oout.flush();
 
-        ChannelBuffer encoded = buffer.readBytes(buffer.readableBytes());
-        return encoded;
+        return buffer.readBytes(buffer.readableBytes());
     }
 
     private ChannelBuffer buffer(ChannelHandlerContext ctx) throws Exception {

File: src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java
Patch:
@@ -500,7 +500,6 @@ private static final class Settings {
 
     private static final class NewThreadRunsPolicy implements RejectedExecutionHandler {
         NewThreadRunsPolicy() {
-            super();
         }
 
         @Override
@@ -537,8 +536,7 @@ private static class Limiter {
         private int waiters;
 
         Limiter(long limit) {
-            super();
-            this.limit = limit;
+	        this.limit = limit;
         }
 
         synchronized void increase(long amount) {

File: src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java
Patch:
@@ -287,7 +287,6 @@ private final class ChildExecutor implements Executor, Runnable {
         private final LinkedList<Runnable> tasks = new LinkedList<Runnable>();
 
         ChildExecutor() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/handler/ipfilter/IpFilterRuleHandler.java
Patch:
@@ -82,7 +82,6 @@ public IpFilterRuleHandler(List<IpFilterRule> newList)
     */
    public IpFilterRuleHandler()
    {
-       super();
    }
 
    // Below are methods directly inspired from CopyOnWriteArrayList methods

File: src/main/java/org/jboss/netty/handler/ipfilter/IpFilterRuleList.java
Patch:
@@ -59,8 +59,7 @@ public class IpFilterRuleList extends ArrayList<IpFilterRule>
     */
    public IpFilterRuleList(String rules)
    {
-      super();
-      parseRules(rules);
+	   parseRules(rules);
    }
 
    private void parseRules(String rules)

File: src/main/java/org/jboss/netty/handler/ipfilter/IpSubnetFilterRule.java
Patch:
@@ -39,8 +39,7 @@ public class IpSubnetFilterRule extends IpSubnet implements IpFilterRule
     */
    public IpSubnetFilterRule(boolean allow)
    {
-      super();
-      isAllowRule = allow;
+	   isAllowRule = allow;
    }
 
    /**

File: src/main/java/org/jboss/netty/handler/ipfilter/IpV4SubnetFilterRule.java
Patch:
@@ -36,8 +36,7 @@ public class IpV4SubnetFilterRule extends IpV4Subnet implements IpFilterRule
     */
    public IpV4SubnetFilterRule(boolean allow)
    {
-      super();
-      isAllowRule = allow;
+	   isAllowRule = allow;
    }
 
    /**

File: src/main/java/org/jboss/netty/handler/queue/BlockingReadTimeoutException.java
Patch:
@@ -34,7 +34,6 @@ public class BlockingReadTimeoutException extends InterruptedIOException {
      * Creates a new instance.
      */
     public BlockingReadTimeoutException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/timeout/IdleState.java
Patch:
@@ -37,5 +37,5 @@ public enum IdleState {
     /**
      * No data was either received or sent for a while.
      */
-    ALL_IDLE;
+    ALL_IDLE
 }

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -443,7 +443,6 @@ public void run(Timeout timeout) throws Exception {
 
     private static final class State {
         State() {
-            super();
         }
 
         volatile Timeout readerIdleTimeout;

File: src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutException.java
Patch:
@@ -31,7 +31,6 @@ public class ReadTimeoutException extends TimeoutException {
      * Creates a new instance.
      */
     public ReadTimeoutException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -259,7 +259,6 @@ private static final class State {
         volatile long lastReadTime = System.currentTimeMillis();
 
         State() {
-            super();
         }
     }
 }

File: src/main/java/org/jboss/netty/handler/timeout/TimeoutException.java
Patch:
@@ -33,7 +33,6 @@ public class TimeoutException extends ChannelException {
      * Creates a new instance.
      */
     public TimeoutException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/timeout/WriteTimeoutException.java
Patch:
@@ -32,7 +32,6 @@ public class WriteTimeoutException extends TimeoutException {
      * Creates a new instance.
      */
     public WriteTimeoutException() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/logging/AbstractInternalLogger.java
Patch:
@@ -30,7 +30,6 @@ public abstract class AbstractInternalLogger implements InternalLogger {
      * Creates a new instance.
      */
     protected AbstractInternalLogger() {
-        super();
     }
 
     @Override

File: src/main/java/org/jboss/netty/logging/InternalLogLevel.java
Patch:
@@ -38,5 +38,5 @@ public enum InternalLogLevel {
     /**
      * 'ERROR' log level.
      */
-    ERROR;
+    ERROR
 }

File: src/main/java/org/jboss/netty/util/ExternalResourceUtil.java
Patch:
@@ -45,6 +45,5 @@ public static void release(ExternalResourceReleasable... releasables) {
     }
 
     private ExternalResourceUtil() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/util/HashedWheelTimer.java
Patch:
@@ -362,7 +362,6 @@ private final class Worker implements Runnable {
         private long tick;
 
         Worker() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/util/internal/DeadLockProofWorker.java
Patch:
@@ -51,6 +51,5 @@ public void run() {
     }
 
     private DeadLockProofWorker() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/util/internal/ExecutorUtil.java
Patch:
@@ -119,6 +119,5 @@ public static void terminate(Executor... executors) {
     }
 
     private ExecutorUtil() {
-        super();
     }
 }

File: src/main/java/org/jboss/netty/util/internal/ThreadLocalRandom.java
Patch:
@@ -90,7 +90,6 @@ protected ThreadLocalRandom initialValue() {
      * invokes setSeed exactly once to initialize.
      */
     ThreadLocalRandom() {
-        super();
     }
 
     /**

File: src/main/java/org/jboss/netty/util/internal/jzlib/JZlib.java
Patch:
@@ -104,6 +104,6 @@ public final class JZlib {
     static final int MAX_BL_BITS = 7;
 
     enum WrapperType {
-        NONE, ZLIB, GZIP, ZLIB_OR_NONE;
+        NONE, ZLIB, GZIP, ZLIB_OR_NONE
     }
 }

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketServerBootstrapTest.java
Patch:
@@ -207,7 +207,6 @@ private static class ParentChannelHandler extends SimpleChannelUpstreamHandler {
         final StringBuffer result = new StringBuffer();
 
         ParentChannelHandler() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/buffer/ReadOnlyChannelBufferTest.java
Patch:
@@ -93,7 +93,7 @@ public void shouldForwardReadCallsBlindly() throws Exception {
         expect(buf.getLong(21)).andReturn(22L);
 
         ByteBuffer bb = ByteBuffer.allocate(100);
-        ByteBuffer[] bbs = new ByteBuffer[] { ByteBuffer.allocate(101), ByteBuffer.allocate(102) };
+        ByteBuffer[] bbs = { ByteBuffer.allocate(101), ByteBuffer.allocate(102) };
 
         expect(buf.toByteBuffer(23, 24)).andReturn(bb);
         expect(buf.toByteBuffers(25, 26)).andReturn(bbs);

File: src/test/java/org/jboss/netty/channel/CompleteChannelFutureTest.java
Patch:
@@ -113,7 +113,6 @@ private static class ExpectedError extends Error {
         private static final long serialVersionUID = 7059276744882005047L;
 
         ExpectedError() {
-            super();
         }
     }
 }

File: src/test/java/org/jboss/netty/channel/socket/AbstractSocketEchoTest.java
Patch:
@@ -153,7 +153,6 @@ private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile int counter;
 
         EchoHandler() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/channel/socket/NioServerSocketShutdownTimeTest.java
Patch:
@@ -97,7 +97,6 @@ private static class DummyHandler extends SimpleChannelUpstreamHandler {
         volatile boolean closed;
 
         DummyHandler() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/channel/socket/http/HttpTunnelSoakTester.java
Patch:
@@ -345,7 +345,6 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
 
             if (verifiedBytes >= BYTES_TO_SEND) {
                 completionLatch.countDown();
-                return;
             }
         }
 

File: src/test/java/org/jboss/netty/handler/codec/frame/AbstractSocketFixedLengthEchoTest.java
Patch:
@@ -155,7 +155,6 @@ private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile int counter;
 
         EchoHandler() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/http/QueryStringDecoderTest.java
Patch:
@@ -106,7 +106,7 @@ public void testUrlDecoding() throws Exception {
                 // not rely on the platform's default encoding (not portable).
                 new byte[] {'C', 'a', 'f', 'f', (byte) 0xC3, (byte) 0xA9},
                 "UTF-8");
-        final String[] tests = new String[] {
+        final String[] tests = {
             // Encoded   ->   Decoded or error message substring
             "",               "",
             "foo",            "foo",

File: src/test/java/org/jboss/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoderTest.java
Patch:
@@ -42,7 +42,7 @@ public void setUp() {
 
     @Test
     public void testTinyDecode() {
-        byte[] b = new byte[] { 4, 1, 1, 1, 1 };
+        byte[] b = { 4, 1, 1, 1, 1 };
         embedder.offer(wrappedBuffer(b, 0, 1));
         assertThat(embedder.poll(), is(nullValue()));
         embedder.offer(wrappedBuffer(b, 1, 2));

File: src/test/java/org/jboss/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java
Patch:
@@ -41,7 +41,7 @@ public void setUp() {
 
     @Test
     public void testTinyEncode() {
-        byte[] b = new byte[] { 4, 1, 1, 1, 1 };
+        byte[] b = { 4, 1, 1, 1, 1 };
         embedder.offer(wrappedBuffer(b, 1, b.length - 1));
         assertThat(embedder.poll(), is(wrappedBuffer(b)));
     }

File: src/test/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderTest.java
Patch:
@@ -57,7 +57,6 @@ public void testLineProtocol() {
     private static final class LineDecoder extends ReplayingDecoder<VoidEnum> {
 
         LineDecoder() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketCompatibleObjectStreamEchoTest.java
Patch:
@@ -163,7 +163,6 @@ private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile int counter;
 
         EchoHandler() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketObjectStreamEchoTest.java
Patch:
@@ -162,7 +162,6 @@ private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile int counter;
 
         EchoHandler() {
-            super();
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/string/AbstractSocketStringEchoTest.java
Patch:
@@ -168,7 +168,6 @@ private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile int counter;
 
         EchoHandler() {
-            super();
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalChannel.java
Patch:
@@ -104,7 +104,7 @@ public boolean isConnected() {
         return state.get() == ST_CONNECTED;
     }
 
-    final void setBound() throws ClosedChannelException {
+    void setBound() throws ClosedChannelException {
         if (!state.compareAndSet(ST_OPEN, ST_BOUND)) {
             switch (state.get()) {
             case ST_CLOSED:
@@ -115,7 +115,7 @@ final void setBound() throws ClosedChannelException {
         }
     }
 
-    final void setConnected() {
+    void setConnected() {
         if (state.get() != ST_CLOSED) {
             state.set(ST_CONNECTED);
         }

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelClientChannel.java
Patch:
@@ -288,7 +288,7 @@ private void fireWriteEnabled(boolean enabled) {
         Channels.fireChannelInterestChanged(this);
     }
 
-    private class ConsolidatingFutureListener implements ChannelFutureListener {
+    private static class ConsolidatingFutureListener implements ChannelFutureListener {
 
         private final ChannelFuture completionFuture;
 

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelServerChannelSink.java
Patch:
@@ -61,7 +61,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e)
         }
     }
 
-    private final class ChannelFutureProxy implements ChannelFutureListener {
+    private static final class ChannelFutureProxy implements ChannelFutureListener {
         private final ChannelFuture upstreamFuture;
 
         ChannelFutureProxy(ChannelFuture upstreamFuture) {

File: src/main/java/org/jboss/netty/channel/socket/http/ServerMessageSwitch.java
Patch:
@@ -238,7 +238,7 @@ public void routeOutboundData(String tunnelId, ChannelBuffer data,
     /**
      * Used to pass the result received from one ChannelFutureListener to another verbatim.
      */
-    private final class RelayedChannelFutureListener implements
+    private static final class RelayedChannelFutureListener implements
             ChannelFutureListener {
         private final ChannelFuture originalFuture;
 

File: src/main/java/org/jboss/netty/channel/socket/nio/SocketReceiveBufferPool.java
Patch:
@@ -30,7 +30,7 @@ final class SocketReceiveBufferPool {
     @SuppressWarnings("unchecked")
     private final SoftReference<ByteBuffer>[] pool = new SoftReference[POOL_SIZE];
 
-    final ByteBuffer acquire(int size) {
+    ByteBuffer acquire(int size) {
         final SoftReference<ByteBuffer>[] pool = this.pool;
         for (int i = 0; i < POOL_SIZE; i ++) {
             SoftReference<ByteBuffer> ref = pool[i];
@@ -59,7 +59,7 @@ final ByteBuffer acquire(int size) {
         return buf;
     }
 
-    final void release(ByteBuffer buffer) {
+    void release(ByteBuffer buffer) {
         final SoftReference<ByteBuffer>[] pool = this.pool;
         for (int i = 0; i < POOL_SIZE; i ++) {
             SoftReference<ByteBuffer> ref = pool[i];
@@ -95,4 +95,4 @@ private static int normalizeCapacity(int capacity) {
         }
         return q << 10;
     }
-}
\ No newline at end of file
+}

File: src/main/java/org/jboss/netty/example/http/websocketx/client/WebSocketClientFactory.java
Patch:
@@ -72,6 +72,7 @@ public WebSocketClient newClient(final URI url,
 
         bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
 
+            @Override
             public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = Channels.pipeline();
                 pipeline.addLast("decoder", new WebSocketHttpResponseDecoder());

File: src/main/java/org/jboss/netty/example/http/websocketx/client/WebSocketClientHandler.java
Patch:
@@ -102,14 +102,17 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws
         e.getChannel().close();
     }
 
+    @Override
     public ChannelFuture connect() {
         return bootstrap.connect(new InetSocketAddress(url.getHost(), url.getPort()));
     }
 
+    @Override
     public ChannelFuture disconnect() {
         return channel.close();
     }
 
+    @Override
     public ChannelFuture send(WebSocketFrame frame) {
         return channel.write(frame);
     }

File: src/main/java/org/jboss/netty/example/iostream/IOStream.java
Patch:
@@ -44,6 +44,7 @@ public static void main(String[] args) {
 
 		// Configure the event pipeline factory.
 		bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+			@Override
 			public ChannelPipeline getPipeline() throws Exception {
 				DefaultChannelPipeline pipeline = new DefaultChannelPipeline();
 				pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));

File: src/main/java/org/jboss/netty/handler/codec/base64/Base64Dialect.java
Patch:
@@ -203,7 +203,7 @@ public enum Base64Dialect {
     final byte[] decodabet;
     final boolean breakLinesByDefault;
 
-    private Base64Dialect(byte[] alphabet, byte[] decodabet, boolean breakLinesByDefault) {
+    Base64Dialect(byte[] alphabet, byte[] decodabet, boolean breakLinesByDefault) {
         this.alphabet = alphabet;
         this.decodabet = decodabet;
         this.breakLinesByDefault = breakLinesByDefault;

File: src/main/java/org/jboss/netty/handler/codec/http/HttpHeaderDateFormat.java
Patch:
@@ -67,7 +67,7 @@ public Date parse(String text, ParsePosition pos) {
      * First obsolete format<p>
      * Sunday, 06-Nov-94 08:49:37 GMT -> E, d-MMM-y HH:mm:ss z
      */
-    private final class HttpHeaderDateFormatObsolete1 extends SimpleDateFormat {
+    private static final class HttpHeaderDateFormatObsolete1 extends SimpleDateFormat {
         private static final long serialVersionUID = -3178072504225114298L;
 
         HttpHeaderDateFormatObsolete1() {
@@ -81,7 +81,7 @@ private final class HttpHeaderDateFormatObsolete1 extends SimpleDateFormat {
      * <p>
      * Sun Nov 6 08:49:37 1994 -> EEE, MMM d HH:mm:ss yyyy
      */
-    private final class HttpHeaderDateFormatObsolete2 extends SimpleDateFormat {
+    private static final class HttpHeaderDateFormatObsolete2 extends SimpleDateFormat {
         private static final long serialVersionUID = 3010674519968303714L;
 
         HttpHeaderDateFormatObsolete2() {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -124,7 +124,7 @@ public abstract class HttpMessageDecoder extends ReplayingDecoder<HttpMessageDec
      *
      * @apiviz.exclude
      */
-    protected static enum State {
+    protected enum State {
         SKIP_CONTROL_CHARS,
         READ_INITIAL,
         READ_HEADER,

File: src/main/java/org/jboss/netty/handler/codec/http/HttpPostBodyUtil.java
Patch:
@@ -88,7 +88,7 @@ public class HttpPostBodyUtil {
        Not allowed: "quoted-printable"
                   / "base64"
      */
-    public static enum TransferEncodingMechanism {
+    public enum TransferEncodingMechanism {
         /**
          * Default encoding
          */
@@ -104,11 +104,11 @@ public static enum TransferEncodingMechanism {
 
         public String value;
 
-        private TransferEncodingMechanism(String value) {
+        TransferEncodingMechanism(String value) {
             this.value = value;
         }
 
-        private TransferEncodingMechanism() {
+        TransferEncodingMechanism() {
             value = name();
         }
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpPostRequestDecoder.java
Patch:
@@ -232,7 +232,7 @@ public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request,
      * @author frederic bregier
      *
      */
-    private static enum MultiPartStatus {
+    private enum MultiPartStatus {
         NOTSTARTED,
         PREAMBLE,
         HEADERDELIMITER,
@@ -1485,7 +1485,7 @@ public ErrorDataDecoderException(String arg0, Throwable arg1) {
      * @author frederic bregier
      *
      */
-    public class IncompatibleDataDecoderException extends Exception {
+    public static class IncompatibleDataDecoderException extends Exception {
         /**
          *
          */

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/UTF8Output.java
Patch:
@@ -67,6 +67,7 @@ public void write(int b) {
         }
     }
 
+    @Override
     public String toString() {
         if (state != UTF8_ACCEPT) {
             throw new UTF8Exception("bytes are not UTF-8");

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
Patch:
@@ -83,7 +83,7 @@ public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDe
     private boolean maskedPayload = false;
     private boolean receivedClosingHandshake = false;
 
-    public static enum State {
+    public enum State {
         FRAME_START, MASKING_KEY, PAYLOAD, CORRUPT
     }
 
@@ -369,4 +369,4 @@ private void checkUTF8String(Channel channel, byte[] bytes) throws CorruptedFram
             protocolViolation(channel, "invalid UTF-8 bytes");
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketClientHandshaker10.java
Patch:
@@ -49,7 +49,7 @@ public class WebSocketClientHandshaker10 extends WebSocketClientHandshaker {
 
     private String expectedChallengeResponseString = null;
 
-    private final String protocol = null;
+    private static final String protocol = null;
 
     private boolean allowExtensions = false;
 

File: src/main/java/org/jboss/netty/util/internal/NonReentrantLock.java
Patch:
@@ -68,7 +68,7 @@ public Condition newCondition() {
     }
 
     @Override
-    protected final boolean tryAcquire(int acquires) {
+    protected boolean tryAcquire(int acquires) {
         if (compareAndSetState(0, 1)) {
             owner = Thread.currentThread();
             return true;
@@ -77,7 +77,7 @@ protected final boolean tryAcquire(int acquires) {
     }
 
     @Override
-    protected final boolean tryRelease(int releases) {
+    protected boolean tryRelease(int releases) {
         if (Thread.currentThread() != owner) {
             throw new IllegalMonitorStateException();
         }
@@ -87,7 +87,7 @@ protected final boolean tryRelease(int releases) {
     }
 
     @Override
-    protected final boolean isHeldExclusively() {
+    protected boolean isHeldExclusively() {
         return getState() != 0 && owner == Thread.currentThread();
     }
 }

File: src/main/java/org/jboss/netty/util/internal/jzlib/JZlib.java
Patch:
@@ -103,7 +103,7 @@ public final class JZlib {
     // Bit length codes must not exceed MAX_BL_BITS bits
     static final int MAX_BL_BITS = 7;
 
-    static enum WrapperType {
+    enum WrapperType {
         NONE, ZLIB, GZIP, ZLIB_OR_NONE;
     }
 }

File: src/test/java/org/jboss/netty/channel/socket/AbstractSocketEchoTest.java
Patch:
@@ -147,7 +147,7 @@ public void testSimpleEcho() throws Throwable {
         }
     }
 
-    private class EchoHandler extends SimpleChannelUpstreamHandler {
+    private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;

File: src/test/java/org/jboss/netty/handler/codec/frame/AbstractSocketFixedLengthEchoTest.java
Patch:
@@ -149,7 +149,7 @@ public void testFixedLengthEcho() throws Throwable {
         }
     }
 
-    private class EchoHandler extends SimpleChannelUpstreamHandler {
+    private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketCompatibleObjectStreamEchoTest.java
Patch:
@@ -157,7 +157,7 @@ public void testCompatibleObjectEcho() throws Throwable {
         }
     }
 
-    private class EchoHandler extends SimpleChannelUpstreamHandler {
+    private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketObjectStreamEchoTest.java
Patch:
@@ -156,7 +156,7 @@ public void testObjectEcho() throws Throwable {
         }
     }
 
-    private class EchoHandler extends SimpleChannelUpstreamHandler {
+    private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;

File: src/test/java/org/jboss/netty/handler/codec/string/AbstractSocketStringEchoTest.java
Patch:
@@ -162,7 +162,7 @@ public void testStringEcho() throws Throwable {
         }
     }
 
-    private class EchoHandler extends SimpleChannelUpstreamHandler {
+    private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;

File: src/test/java/org/jboss/netty/handler/ssl/AbstractSocketSslEchoTest.java
Patch:
@@ -194,7 +194,7 @@ public void testSslEcho() throws Throwable {
         }
     }
 
-    private class EchoHandler extends SimpleChannelUpstreamHandler {
+    private static class EchoHandler extends SimpleChannelUpstreamHandler {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;

File: src/main/java/org/jboss/netty/channel/iostream/IOStreamChannelSink.java
Patch:
@@ -115,7 +115,7 @@ public void setChannel(final IOStreamChannel channel) {
 
     private PushbackInputStream inputStream;
 
-    private ChannelConfig config = new DefaultChannelConfig();
+    private final ChannelConfig config = new DefaultChannelConfig();
 
     @Override
     public void eventSunk(final ChannelPipeline pipeline, final ChannelEvent e) throws Exception {

File: src/main/java/org/jboss/netty/channel/rxtx/RXTXChannelConfig.java
Patch:
@@ -34,7 +34,7 @@ public static enum Stopbits {
         STOPBITS_2(SerialPort.STOPBITS_2),
         STOPBITS_1_5(SerialPort.STOPBITS_1_5);
 
-        private int value;
+        private final int value;
 
         private Stopbits(int value) {
             this.value = value;
@@ -61,7 +61,7 @@ public static enum Databits {
         DATABITS_7(SerialPort.DATABITS_7),
         DATABITS_8(SerialPort.DATABITS_8);
 
-        private int value;
+        private final int value;
 
         private Databits(int value) {
             this.value = value;
@@ -89,7 +89,7 @@ public static enum Paritybit {
         MARK(SerialPort.PARITY_MARK),
         SPACE(SerialPort.PARITY_SPACE);
 
-        private int value;
+        private final int value;
 
         private Paritybit(int value) {
             this.value = value;

File: src/main/java/org/jboss/netty/channel/socket/http/SaturationManager.java
Patch:
@@ -32,9 +32,9 @@
  * @author OneDrum Ltd.
  */
 class SaturationManager {
-    private AtomicLong desaturationPoint;
+    private final AtomicLong desaturationPoint;
 
-    private AtomicLong saturationPoint;
+    private final AtomicLong saturationPoint;
 
     private final AtomicLong queueSize;
 

File: src/main/java/org/jboss/netty/example/http/upload/HttpClient.java
Patch:
@@ -404,7 +404,7 @@ private static void formpostmultipart(ClientBootstrap bootstrap, String host, in
 
 
     // use to simulate a big TEXTAREA field in a form
-    private static String textArea =
+    private static final String textArea =
         "lkjlkjlKJLKJLKJLKJLJlkj lklkj\r\n\r\nLKJJJJJJJJKKKKKKKKKKKKKKK &\r\n\r\n"+
         "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"+
         "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"+
@@ -992,4 +992,4 @@ private static void formpostmultipart(ClientBootstrap bootstrap, String host, in
         "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"+
         "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n";
 
-}
\ No newline at end of file
+}

File: src/main/java/org/jboss/netty/example/http/websocketx/client/WebSocketClientFactory.java
Patch:
@@ -44,7 +44,7 @@
  */
 public class WebSocketClientFactory {
 
-    private NioClientSocketChannelFactory socketChannelFactory = new NioClientSocketChannelFactory(
+    private final NioClientSocketChannelFactory socketChannelFactory = new NioClientSocketChannelFactory(
             Executors.newCachedThreadPool(), Executors.newCachedThreadPool());
 
     /**

File: src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.java
Patch:
@@ -48,7 +48,7 @@ public static Continent valueOf(int value) {
         internalGetValueMap() {
       return internalValueMap;
     }
-    private static com.google.protobuf.Internal.EnumLiteMap<Continent>
+    private static final com.google.protobuf.Internal.EnumLiteMap<Continent>
         internalValueMap =
           new com.google.protobuf.Internal.EnumLiteMap<Continent>() {
             public Continent findValueByNumber(int number) {
@@ -125,7 +125,7 @@ public static DayOfWeek valueOf(int value) {
         internalGetValueMap() {
       return internalValueMap;
     }
-    private static com.google.protobuf.Internal.EnumLiteMap<DayOfWeek>
+    private static final com.google.protobuf.Internal.EnumLiteMap<DayOfWeek>
         internalValueMap =
           new com.google.protobuf.Internal.EnumLiteMap<DayOfWeek>() {
             public DayOfWeek findValueByNumber(int number) {

File: src/main/java/org/jboss/netty/handler/codec/base64/Base64.java
Patch:
@@ -53,21 +53,21 @@ public class Base64 {
 
     private static final byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding
 
-    private static final byte[] alphabet(Base64Dialect dialect) {
+    private static byte[] alphabet(Base64Dialect dialect) {
         if (dialect == null) {
             throw new NullPointerException("dialect");
         }
         return dialect.alphabet;
     }
 
-    private static final byte[] decodabet(Base64Dialect dialect) {
+    private static byte[] decodabet(Base64Dialect dialect) {
         if (dialect == null) {
             throw new NullPointerException("dialect");
         }
         return dialect.decodabet;
     }
 
-    private static final boolean breakLines(Base64Dialect dialect) {
+    private static boolean breakLines(Base64Dialect dialect) {
         if (dialect == null) {
             throw new NullPointerException("dialect");
         }

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpDataFactory.java
Patch:
@@ -50,7 +50,7 @@ public class DefaultHttpDataFactory implements HttpDataFactory {
     /**
      * Keep all HttpDatas until cleanAllHttpDatas() is called.
      */
-    private ConcurrentHashMap<HttpRequest, List<HttpData>> requestFileDeleteMap =
+    private final ConcurrentHashMap<HttpRequest, List<HttpData>> requestFileDeleteMap =
         new ConcurrentHashMap<HttpRequest, List<HttpData>>();
     /**
      * HttpData will be in memory if less than default size (16KB).

File: src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocketClientHandshaker10.java
Patch:
@@ -49,7 +49,7 @@ public class WebSocketClientHandshaker10 extends WebSocketClientHandshaker {
 
     private String expectedChallengeResponseString = null;
 
-    private String protocol = null;
+    private final String protocol = null;
 
     private boolean allowExtensions = false;
 

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayError.java
Patch:
@@ -27,7 +27,4 @@ class ReplayError extends Error {
 
     private static final long serialVersionUID = 2666698631187527681L;
 
-    ReplayError() {
-        super();
-    }
 }

File: src/main/java/org/jboss/netty/util/internal/AtomicFieldUpdaterUtil.java
Patch:
@@ -29,9 +29,6 @@ class AtomicFieldUpdaterUtil {
 
     static final class Node {
         volatile Node next;
-        Node() {
-            super();
-        }
     }
 
     static {

File: src/test/java/org/jboss/netty/channel/socket/http/HttpTunnelSoakTester.java
Patch:
@@ -85,7 +85,7 @@ public class HttpTunnelSoakTester {
 
     final DataVerifier s2cVerifier = new DataVerifier("S2C-Verifier");
 
-    private static byte[] SEND_STREAM;
+    private static final byte[] SEND_STREAM;
 
     static {
         SEND_STREAM = new byte[MAX_WRITE_SIZE + 127];

File: src/main/java/org/jboss/netty/handler/codec/frame/LengthFieldBasedFrameDecoder.java
Patch:
@@ -239,7 +239,7 @@ public LengthFieldBasedFrameDecoder(
             int maxFrameLength,
             int lengthFieldOffset, int lengthFieldLength,
             int lengthAdjustment, int initialBytesToStrip) {
-        this(maxFrameLength, lengthFieldOffset, lengthFieldOffset, lengthAdjustment,
+        this(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment,
                 initialBytesToStrip, false);
     }
 

File: src/main/java/org/jboss/netty/channel/local/LocalAddress.java
Patch:
@@ -115,7 +115,7 @@ public int compareTo(LocalAddress o) {
                 }
 
                 int a = System.identityHashCode(this);
-                int b = System.identityHashCode(this);
+                int b = System.identityHashCode(o);
                 if (a < b) {
                     return -1;
                 } else if (a > b) {

File: src/main/java/org/jboss/netty/channel/local/LocalAddress.java
Patch:
@@ -115,7 +115,7 @@ public int compareTo(LocalAddress o) {
                 }
 
                 int a = System.identityHashCode(this);
-                int b = System.identityHashCode(this);
+                int b = System.identityHashCode(o);
                 if (a < b) {
                     return -1;
                 } else if (a > b) {

File: src/main/java/org/jboss/netty/channel/socket/oio/OioAcceptedSocketChannel.java
Patch:
@@ -70,9 +70,6 @@ private OioAcceptedSocketChannel(
         } catch (IOException e) {
             throw new ChannelException("Failed to obtain an OutputStream.", e);
         }
-
-        fireChannelOpen(this);
-        fireChannelBound(this, getLocalAddress());
     }
 
     @Override

File: src/main/java/org/jboss/netty/channel/ChannelLocal.java
Patch:
@@ -71,7 +71,7 @@ public ChannelLocal(boolean removeOnClose) {
      * Returns the initial value of the variable.  By default, it returns
      * {@code null}.  Override it to change the initial value.
      */
-    protected T initialValue(@SuppressWarnings("unused") Channel channel) {
+    protected T initialValue(Channel channel) {
         return null;
     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -29,7 +29,6 @@
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
 import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureListener;
 import org.jboss.netty.channel.ChannelPipeline;
 import org.jboss.netty.channel.ChannelSink;
 import org.jboss.netty.channel.MessageEvent;

File: src/main/java/org/jboss/netty/handler/codec/http/HttpContentCompressor.java
Patch:
@@ -20,8 +20,6 @@
 import org.jboss.netty.handler.codec.compression.ZlibWrapper;
 import org.jboss.netty.handler.codec.embedder.EncoderEmbedder;
 
-import com.sun.net.httpserver.Headers;
-
 /**
  * Compresses an {@link HttpMessage} and an {@link HttpChunk} in {@code gzip} or
  * {@code deflate} encoding while respecting the {@code "Accept-Encoding"} header.

File: src/main/java/org/jboss/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -136,7 +136,7 @@ public void releaseExternalResources() {
         timer.stop();
     }
 
-    protected long getTimeoutMillis(@SuppressWarnings("unused") MessageEvent e) {
+    protected long getTimeoutMillis(MessageEvent e) {
         return timeoutMillis;
     }
 

File: src/main/java/org/jboss/netty/handler/ipfilter/CIDR4.java
Patch:
@@ -71,7 +71,7 @@ public InetAddress getEndAddress()
    }
 
    @Override
-public int compareTo(CIDR arg)
+   public int compareTo(CIDR arg)
    {
       if (arg instanceof CIDR6)
       {

File: src/main/java/org/jboss/netty/handler/ipfilter/CIDR6.java
Patch:
@@ -78,7 +78,7 @@ public InetAddress getEndAddress()
    }
 
    @Override
-public int compareTo(CIDR arg)
+   public int compareTo(CIDR arg)
    {
       if (arg instanceof CIDR4)
       {

File: src/main/java/org/jboss/netty/handler/ipfilter/IpFilteringHandlerImpl.java
Patch:
@@ -113,7 +113,7 @@ protected boolean continues(ChannelHandlerContext ctx, ChannelEvent e) throws Ex
     * @see org.jboss.netty.channel.ChannelUpstreamHandler#handleUpstream(org.jboss.netty.channel.ChannelHandlerContext, org.jboss.netty.channel.ChannelEvent)
     */
    @Override
-public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exception
+   public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exception
    {
       if (e instanceof ChannelStateEvent)
       {
@@ -189,7 +189,7 @@ public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exc
     * @see org.jboss.netty.handler.ipfilter.IpFilteringHandler#setIpFilterListener(org.jboss.netty.handler.ipfilter.IpFilterListener)
     */
    @Override
-public void setIpFilterListener(IpFilterListener listener)
+   public void setIpFilterListener(IpFilterListener listener)
    {
       this.listener = listener;
    }
@@ -198,7 +198,7 @@ public void setIpFilterListener(IpFilterListener listener)
     * @see org.jboss.netty.handler.ipfilter.IpFilteringHandler#removeIpFilterListener()
     */
    @Override
-public void removeIpFilterListener()
+   public void removeIpFilterListener()
    {
       this.listener = null;
 

File: src/main/java/org/jboss/netty/handler/ipfilter/IpSubnet.java
Patch:
@@ -159,7 +159,7 @@ public boolean equals(Object o)
     * Compare two IpSubnet
     */
    @Override
-public int compareTo(IpSubnet o)
+   public int compareTo(IpSubnet o)
    {
       return cidr.toString().compareTo(o.cidr.toString());
    }

File: src/main/java/org/jboss/netty/handler/ipfilter/IpSubnetFilterRule.java
Patch:
@@ -79,13 +79,13 @@ public IpSubnetFilterRule(boolean allow, String netAddress) throws UnknownHostEx
    }
 
    @Override
-public boolean isAllowRule()
+   public boolean isAllowRule()
    {
       return isAllowRule;
    }
 
    @Override
-public boolean isDenyRule()
+   public boolean isDenyRule()
    {
       return !isAllowRule;
    }

File: src/main/java/org/jboss/netty/handler/ipfilter/IpV4Subnet.java
Patch:
@@ -278,7 +278,7 @@ public boolean equals(Object o)
     * Compare two IpV4Subnet
     */
    @Override
-public int compareTo(IpV4Subnet o)
+   public int compareTo(IpV4Subnet o)
    {
       if (o.subnet == subnet && o.cidrMask == cidrMask)
       {

File: src/main/java/org/jboss/netty/handler/ipfilter/IpV4SubnetFilterRule.java
Patch:
@@ -74,13 +74,13 @@ public IpV4SubnetFilterRule(boolean allow, String netAddress) throws UnknownHost
    }
 
    @Override
-public boolean isAllowRule()
+   public boolean isAllowRule()
    {
       return isAllowRule;
    }
 
    @Override
-public boolean isDenyRule()
+   public boolean isDenyRule()
    {
       return !isAllowRule;
    }

File: src/main/java/org/jboss/netty/handler/stream/BlockingChannelBufferInputStream.java
Patch:
@@ -11,7 +11,8 @@
  * objects to and read them
  * 
  *
- *  @author Norman Maurer 
+ * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>
+ * @author <a href="http://www.murkycloud.com/">Norman Maurer</a>
  */
 public class BlockingChannelBufferInputStream extends InputStream{
     private final Object mutex = new Object();

File: src/main/java/org/jboss/netty/handler/stream/ChannelOutputStream.java
Patch:
@@ -11,7 +11,8 @@
 /**
  * {@link OutputStream} which write data to the wrapped {@link Channel}
  *
- *  @author Norman Maurer 
+ * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>
+ * @author <a href="http://www.murkycloud.com/">Norman Maurer</a>
  */
 public class ChannelOutputStream extends OutputStream{
 

File: src/main/java/org/jboss/netty/handler/stream/StreamHandler.java
Patch:
@@ -23,7 +23,8 @@
  * Abstract base class which could be used if you need to use {@link InputStream} and {@link OutputStream} directly in your Handler. 
  * Because of the blocking nature of {@link InputStream} it will spawn a new Thread on every new connected {@link Channel}
  *  
- *  @author Norman Maurer 
+ * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>
+ * @author <a href="http://www.murkycloud.com/">Norman Maurer</a>
  */
 public abstract class StreamHandler extends ReadTimeoutHandler{
     

File: src/main/java/org/jboss/netty/channel/socket/oio/OioWorker.java
Patch:
@@ -141,7 +141,9 @@ static void write(
                         }
                     }
                 } finally {
-                    fr.releaseExternalResources();
+                    if (fr.releaseAfterTransfer()) {
+                        fr.releaseExternalResources();
+                    }
 
                 }
             } else {

File: src/main/java/org/jboss/netty/channel/ChannelEvent.java
Patch:
@@ -71,6 +71,7 @@
  * <td>{@code "channelOpen"}</td>
  * <td>{@link ChannelStateEvent}<br/>(state = {@link ChannelState#OPEN OPEN}, value = {@code true})</td>
  * <td>a {@link Channel} is open, but not bound nor connected</td>
+ * <td><strong>Be aware that this event is fired from within the Boss-Thread so you should not execute any heavy operation in there as it will block the dispatching to other workers!</strong></td>
  * </tr>
  * <tr>
  * <td>{@code "channelClosed"}</td>
@@ -81,6 +82,7 @@
  * <td>{@code "channelBound"}</td>
  * <td>{@link ChannelStateEvent}<br/>(state = {@link ChannelState#BOUND BOUND}, value = {@link SocketAddress})</td>
  * <td>a {@link Channel} is open and bound to a local address, but not connected</td>
+ * <td><strong>Be aware that this event is fired from within the Boss-Thread so you should not execute any heavy operation in there as it will block the dispatching to other workers!</strong></td>
  * </tr>
  * <tr>
  * <td>{@code "channelUnbound"}</td>

File: src/main/java/org/jboss/netty/channel/socket/nio/NioAcceptedSocketChannel.java
Patch:
@@ -48,6 +48,5 @@ final class NioAcceptedSocketChannel extends NioSocketChannel {
         setConnected();
         fireChannelOpen(this);
         fireChannelBound(this, getLocalAddress());
-        fireChannelConnected(this, getRemoteAddress());
     }
 }

File: src/main/java/org/jboss/netty/channel/socket/nio/SocketSendBufferPool.java
Patch:
@@ -306,7 +306,8 @@ public long transferTo(DatagramChannel ch, SocketAddress raddr)
 
         @Override
         public void release() {
-            // Unpooled.
+            // Make sure the FileRegion resource are released otherwise it may cause a FD leak or something similar
+            file.releaseExternalResources(); 
         }
     }
 

File: src/main/java/org/jboss/netty/channel/socket/oio/OioAcceptedSocketChannel.java
Patch:
@@ -63,7 +63,6 @@ class OioAcceptedSocketChannel extends OioSocketChannel {
 
         fireChannelOpen(this);
         fireChannelBound(this, getLocalAddress());
-        fireChannelConnected(this, getRemoteAddress());
     }
 
     @Override

File: src/main/java/org/jboss/netty/util/HashedWheelTimer.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 

File: src/main/java/org/jboss/netty/handler/codec/http/MixedFileUpload.java
Patch:
@@ -62,8 +62,10 @@ public void addContent(ChannelBuffer buffer, boolean last)
                         .getContentType(), fileUpload
                         .getContentTransferEncoding(), fileUpload.getCharset(),
                         definedSize);
-                diskFileUpload.addContent(((MemoryFileUpload) fileUpload)
+                if (((MemoryFileUpload) fileUpload).getChannelBuffer() != null){
+                    diskFileUpload.addContent(((MemoryFileUpload) fileUpload)
                         .getChannelBuffer(), last);
+                }
                 fileUpload = diskFileUpload;
             }
         }

File: src/main/java/org/jboss/netty/handler/codec/http/MixedAttribute.java
Patch:
@@ -73,8 +73,10 @@ public void addContent(ChannelBuffer buffer, boolean last)
             if (attribute.length() + buffer.readableBytes() > limitSize) {
                 DiskAttribute diskAttribute = new DiskAttribute(attribute
                         .getName());
-                diskAttribute.addContent(((MemoryAttribute) attribute)
+                if (((MemoryAttribute) attribute).getChannelBuffer() != null) {
+                    diskAttribute.addContent(((MemoryAttribute) attribute)
                         .getChannelBuffer(), last);
+                }
                 attribute = diskAttribute;
             }
         }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecoder.java
Patch:
@@ -62,7 +62,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
         Object msg = e.getMessage();
         if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().getCode() == 100) {
             // 100-continue response must be passed through.
-            ctx.sendDownstream(e);
+            ctx.sendUpstream(e);
         } else if (msg instanceof HttpMessage) {
             HttpMessage m = (HttpMessage) msg;
 

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -1072,6 +1072,8 @@ private static final class ClosingChannelFutureListener implements ChannelFuture
         public void operationComplete(ChannelFuture closeNotifyFuture) throws Exception {
             if (!(closeNotifyFuture.getCause() instanceof ClosedChannelException)) {
                 Channels.close(context, e.getFuture());
+            } else {
+                e.getFuture().setSuccess();
             }
         }
     }

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -979,8 +979,8 @@ public static int compare(ChannelBuffer bufferA, ChannelBuffer bufferB) {
         }
 
         for (int i = byteCount; i > 0; i --) {
-            byte va = bufferA.getByte(aIndex);
-            byte vb = bufferB.getByte(bIndex);
+            short va = bufferA.getUnsignedByte(aIndex);
+            short vb = bufferB.getUnsignedByte(bIndex);
             if (va > vb) {
                 return 1;
             } else if (va < vb) {

File: src/main/java/org/jboss/netty/handler/codec/serialization/CompactObjectInputStream.java
Patch:
@@ -78,11 +78,13 @@ protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, Clas
         try {
             return loadClass(className);
         } catch (ClassNotFoundException ex) {
+            // FIXME Cache the result to avoid the cost of ClassNotFoundException.
             return super.resolveClass(desc);
         }
     }
 
     protected Class<?> loadClass(String className) throws ClassNotFoundException {
+        // FIXME Cache the result to avoid the cost of loading classes.
         Class<?> clazz;
         ClassLoader classLoader = this.classLoader;
         if (classLoader == null) {

File: src/main/java/org/jboss/netty/handler/codec/http/DiskFileUpload.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.jboss.netty.handler.codec.http;
 
+import java.io.File;
 import java.nio.charset.Charset;
 
 /**
@@ -156,7 +157,8 @@ protected String getBaseDirectory() {
 
     @Override
     protected String getDiskFilename() {
-        return filename;
+        File file = new File(filename);
+        return file.getName();
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/MixedAttribute.java
Patch:
@@ -74,7 +74,7 @@ public void addContent(ChannelBuffer buffer, boolean last)
                 DiskAttribute diskAttribute = new DiskAttribute(attribute
                         .getName());
                 diskAttribute.addContent(((MemoryAttribute) attribute)
-                        .getChannelBuffer(), false);
+                        .getChannelBuffer(), last);
                 attribute = diskAttribute;
             }
         }

File: src/main/java/org/jboss/netty/handler/codec/http/MixedFileUpload.java
Patch:
@@ -63,7 +63,7 @@ public void addContent(ChannelBuffer buffer, boolean last)
                         .getContentTransferEncoding(), fileUpload.getCharset(),
                         definedSize);
                 diskFileUpload.addContent(((MemoryFileUpload) fileUpload)
-                        .getChannelBuffer(), false);
+                        .getChannelBuffer(), last);
                 fileUpload = diskFileUpload;
             }
         }

File: src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelRequestDispatch.java
Patch:
@@ -109,7 +109,7 @@ private void handleSendData(ChannelHandlerContext ctx, HttpRequest request) {
             LOG.debug("send data request received for tunnel " + tunnelId);
         }
 
-        if (HttpHeaders.getContentLength(request) == 0 ||
+        if (HttpHeaders.getContentLength(request, 0) == 0 ||
                 request.getContent() == null ||
                 request.getContent().readableBytes() == 0) {
             respondWithRejection(ctx, request,

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelMessageUtils.java
Patch:
@@ -241,7 +241,7 @@ public static boolean isOKResponse(HttpResponse response) {
     public static boolean hasContents(HttpResponse response,
             byte[] expectedContents) {
         if (response.getContent() != null &&
-                HttpHeaders.getContentLength(response) == expectedContents.length &&
+                HttpHeaders.getContentLength(response, 0) == expectedContents.length &&
                 response.getContent().readableBytes() == expectedContents.length) {
             byte[] compareBytes = new byte[expectedContents.length];
             response.getContent().readBytes(compareBytes);
@@ -300,7 +300,7 @@ public static boolean isRejection(HttpResponse response) {
 
     public static Object extractErrorMessage(HttpResponse response) {
         if (response.getContent() == null ||
-                HttpHeaders.getContentLength(response) == 0) {
+                HttpHeaders.getContentLength(response, 0) == 0) {
             return "";
         }
 

File: src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java
Patch:
@@ -41,6 +41,7 @@ public AcceptedServerChannelPipelineFactory(
         this.messageSwitch = messageSwitch;
     }
 
+    @Override
     public ChannelPipeline getPipeline() throws Exception {
         ChannelPipeline pipeline = Channels.pipeline();
 

File: src/main/java/org/jboss/netty/channel/socket/http/ChannelFutureAggregator.java
Patch:
@@ -47,6 +47,7 @@ public void addFuture(ChannelFuture future) {
         future.addListener(this);
     }
 
+    @Override
     public synchronized void operationComplete(ChannelFuture future)
             throws Exception {
         if (future.isCancelled()) {

File: src/main/java/org/jboss/netty/channel/socket/http/DefaultTunnelIdGenerator.java
Patch:
@@ -39,6 +39,7 @@ public DefaultTunnelIdGenerator(SecureRandom generator) {
         this.generator = generator;
     }
 
+    @Override
     public synchronized String generateId() {
         // synchronized to ensure that this code is thread safe. The Sun
         // standard implementations seem to be synchronized or lock free

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelClientChannelFactory.java
Patch:
@@ -41,11 +41,13 @@ public HttpTunnelClientChannelFactory(ClientSocketChannelFactory factory) {
         this.factory = factory;
     }
 
+    @Override
     public HttpTunnelClientChannel newChannel(ChannelPipeline pipeline) {
         return new HttpTunnelClientChannel(this, pipeline,
                 new HttpTunnelClientChannelSink(), factory, realConnections);
     }
 
+    @Override
     public void releaseExternalResources() {
         realConnections.close().awaitUninterruptibly();
         factory.releaseExternalResources();

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelClientChannelSink.java
Patch:
@@ -33,6 +33,7 @@
  */
 class HttpTunnelClientChannelSink extends AbstractChannelSink {
 
+    @Override
     public void eventSunk(ChannelPipeline pipeline, ChannelEvent e)
             throws Exception {
         if (e instanceof ChannelStateEvent) {

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelServerChannelFactory.java
Patch:
@@ -40,6 +40,7 @@ public HttpTunnelServerChannelFactory(
         realConnections = new DefaultChannelGroup();
     }
 
+    @Override
     public HttpTunnelServerChannel newChannel(ChannelPipeline pipeline) {
         return new HttpTunnelServerChannel(this, pipeline);
     }
@@ -58,6 +59,7 @@ ServerSocketChannel createRealChannel(HttpTunnelServerChannel channel,
         return newChannel;
     }
 
+    @Override
     public void releaseExternalResources() {
         realConnections.close().awaitUninterruptibly();
         realConnectionFactory.releaseExternalResources();

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelServerChannelSink.java
Patch:
@@ -36,6 +36,7 @@ class HttpTunnelServerChannelSink extends AbstractChannelSink {
 
     private ServerSocketChannel realChannel;
 
+    @Override
     public void eventSunk(ChannelPipeline pipeline, ChannelEvent e)
             throws Exception {
 
@@ -67,6 +68,7 @@ private final class ChannelFutureProxy implements ChannelFutureListener {
             this.upstreamFuture = upstreamFuture;
         }
 
+        @Override
         public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {
                 upstreamFuture.setSuccess();

File: src/test/java/org/jboss/netty/channel/socket/http/FakeChannelSink.java
Patch:
@@ -31,6 +31,7 @@ public class FakeChannelSink extends AbstractChannelSink {
 
     public Queue<ChannelEvent> events = new LinkedList<ChannelEvent>();
 
+    @Override
     public void eventSunk(ChannelPipeline pipeline, ChannelEvent e)
             throws Exception {
         events.add(e);

File: src/test/java/org/jboss/netty/channel/socket/http/FakeClientSocketChannelFactory.java
Patch:
@@ -36,6 +36,7 @@ public FakeClientSocketChannelFactory() {
         createdChannels = new ArrayList<FakeSocketChannel>();
     }
 
+    @Override
     public SocketChannel newChannel(ChannelPipeline pipeline) {
         FakeSocketChannel channel =
                 new FakeSocketChannel(null, this, pipeline,
@@ -44,6 +45,7 @@ public SocketChannel newChannel(ChannelPipeline pipeline) {
         return channel;
     }
 
+    @Override
     public void releaseExternalResources() {
         // nothing to do
     }

File: src/test/java/org/jboss/netty/channel/socket/http/FakeServerSocketChannelFactory.java
Patch:
@@ -32,11 +32,13 @@ public class FakeServerSocketChannelFactory implements
 
     public FakeServerSocketChannel createdChannel;
 
+    @Override
     public ServerSocketChannel newChannel(ChannelPipeline pipeline) {
         createdChannel = new FakeServerSocketChannel(this, pipeline, sink);
         return createdChannel;
     }
 
+    @Override
     public void releaseExternalResources() {
         // nothing to do
     }

File: src/test/java/org/jboss/netty/channel/socket/http/HttpTunnelTest.java
Patch:
@@ -102,6 +102,7 @@ public void setUp() throws UnknownHostException {
         clientCaptureHandler = new ClientEndHandler();
         clientBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
 
+            @Override
             public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = Channels.pipeline();
                 pipeline.addLast("clientCapture", clientCaptureHandler);
@@ -117,6 +118,7 @@ public ChannelPipeline getPipeline() throws Exception {
         connectionCaptureHandler = new ServerEndHandler();
         serverBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
 
+            @Override
             public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = Channels.pipeline();
                 pipeline.addLast("capture", connectionCaptureHandler);

File: src/test/java/org/jboss/netty/channel/socket/http/NullChannelHandler.java
Patch:
@@ -28,11 +28,13 @@
 public class NullChannelHandler implements ChannelUpstreamHandler,
         ChannelDownstreamHandler {
 
+    @Override
     public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)
             throws Exception {
         ctx.sendUpstream(e);
     }
 
+    @Override
     public void handleDownstream(ChannelHandlerContext ctx, ChannelEvent e)
             throws Exception {
         ctx.sendDownstream(e);

File: src/test/java/org/jboss/netty/channel/socket/http/ServerMessageSwitchTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.jboss.netty.channel.socket.http;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 import java.net.InetSocketAddress;
 
@@ -55,7 +55,7 @@ public class ServerMessageSwitchTest {
 
     private FakeSocketChannel requesterChannel;
 
-    private HttpTunnelAcceptedChannelReceiver htunAcceptedChannel;
+    HttpTunnelAcceptedChannelReceiver htunAcceptedChannel;
 
     @Before
     public void setUp() throws Exception {

File: src/test/java/org/jboss/netty/channel/socket/http/UpstreamEventCatcher.java
Patch:
@@ -33,6 +33,7 @@ public class UpstreamEventCatcher implements ChannelUpstreamHandler {
 
     public Queue<ChannelEvent> events = new LinkedList<ChannelEvent>();
 
+    @Override
     public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)
             throws Exception {
         events.add(e);

File: src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSocketChannelConfig.java
Patch:
@@ -15,9 +15,6 @@
  */
 package org.jboss.netty.channel.socket.sctp;
 
-import java.net.Socket;
-import java.util.Map;
-
 import org.jboss.netty.channel.AdaptiveReceiveBufferSizePredictorFactory;
 import org.jboss.netty.channel.ChannelException;
 import org.jboss.netty.channel.ReceiveBufferSizePredictor;
@@ -27,6 +24,9 @@
 import org.jboss.netty.logging.InternalLoggerFactory;
 import org.jboss.netty.util.internal.ConversionUtil;
 
+import java.net.Socket;
+import java.util.Map;
+
 /**
  * The default {@link NioSocketChannelConfig} implementation.
  *

File: src/main/java/org/jboss/netty/channel/socket/sctp/NioClientSocketChannelFactory.java
Patch:
@@ -15,13 +15,13 @@
  */
 package org.jboss.netty.channel.socket.sctp;
 
-import java.util.concurrent.Executor;
-
 import org.jboss.netty.channel.ChannelPipeline;
 import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
 import org.jboss.netty.channel.socket.SocketChannel;
 import org.jboss.netty.util.internal.ExecutorUtil;
 
+import java.util.concurrent.Executor;
+
 /**
  * A {@link org.jboss.netty.channel.socket.ClientSocketChannelFactory} which creates a client-side NIO-based
  * {@link org.jboss.netty.channel.socket.SocketChannel}.  It utilizes the non-blocking I/O mode which was

File: src/main/java/org/jboss/netty/channel/socket/sctp/NioServerSocketChannelFactory.java
Patch:
@@ -15,14 +15,14 @@
  */
 package org.jboss.netty.channel.socket.sctp;
 
-import java.util.concurrent.Executor;
-
 import org.jboss.netty.channel.ChannelPipeline;
 import org.jboss.netty.channel.ChannelSink;
 import org.jboss.netty.channel.socket.ServerSocketChannel;
 import org.jboss.netty.channel.socket.ServerSocketChannelFactory;
 import org.jboss.netty.util.internal.ExecutorUtil;
 
+import java.util.concurrent.Executor;
+
 /**
  * A {@link org.jboss.netty.channel.socket.ServerSocketChannelFactory} which creates a server-side NIO-based
  * {@link org.jboss.netty.channel.socket.ServerSocketChannel}.  It utilizes the non-blocking I/O mode which

File: src/main/java/org/jboss/netty/channel/socket/sctp/SelectorUtil.java
Patch:
@@ -15,13 +15,13 @@
  */
 package org.jboss.netty.channel.socket.sctp;
 
+import org.jboss.netty.logging.InternalLogger;
+import org.jboss.netty.logging.InternalLoggerFactory;
+
 import java.io.IOException;
 import java.nio.channels.CancelledKeyException;
 import java.nio.channels.Selector;
 
-import org.jboss.netty.logging.InternalLogger;
-import org.jboss.netty.logging.InternalLoggerFactory;
-
 /**
  * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>
  * @author <a href="http://gleamynode.net/">Trustin Lee</a>

File: src/main/java/org/jboss/netty/channel/socket/sctp/SocketSendBufferPool.java
Patch:
@@ -15,16 +15,16 @@
  */
 package org.jboss.netty.channel.socket.sctp;
 
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.channel.FileRegion;
+
 import java.io.IOException;
 import java.lang.ref.SoftReference;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.DatagramChannel;
 import java.nio.channels.WritableByteChannel;
 
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.channel.FileRegion;
-
 /**
  * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>
  * @author <a href="http://gleamynode.net/">Trustin Lee</a>

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannelConfig.java
Patch:
@@ -144,5 +144,6 @@ public interface NioSocketChannelConfig extends SocketChannelConfig {
      * will be called with the new predictor.  The default factory is
      * <tt>{@link AdaptiveReceiveBufferSizePredictorFactory}(64, 1024, 65536)</tt>.
      */
-    void setReceiveBufferSizePredictorFactory(ReceiveBufferSizePredictorFactory predictorFactory);
+    void setReceiveBufferSizePredictorFactory(
+            ReceiveBufferSizePredictorFactory predictorFactory);
 }

File: src/main/java/org/jboss/netty/channel/socket/http/SaturationStateChange.java
Patch:
@@ -25,7 +25,5 @@
  * @author OneDrum Ltd.
  */
 enum SaturationStateChange {
-   NO_CHANGE,
-   DESATURATED,
-   SATURATED
+    NO_CHANGE, DESATURATED, SATURATED
 }

File: src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java
Patch:
@@ -182,7 +182,7 @@ public ChannelFuture connect() {
      */
     public ChannelFuture connect(SocketAddress remoteAddress) {
         if (remoteAddress == null) {
-            throw new NullPointerException("remotedAddress");
+            throw new NullPointerException("remoteAddress");
         }
         SocketAddress localAddress = (SocketAddress) getOption("localAddress");
         return connect(remoteAddress, localAddress);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -57,9 +57,7 @@ class NioClientSocketPipelineSink extends AbstractChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(NioClientSocketPipelineSink.class);
-    private static final AtomicInteger nextId = new AtomicInteger();
 
-    final int id = nextId.incrementAndGet();
     final Executor bossExecutor;
     private final Boss boss = new Boss();
     private final NioWorker[] workers;
@@ -70,7 +68,7 @@ class NioClientSocketPipelineSink extends AbstractChannelSink {
         this.bossExecutor = bossExecutor;
         workers = new NioWorker[workerCount];
         for (int i = 0; i < workers.length; i ++) {
-            workers[i] = new NioWorker(id, i + 1, workerExecutor);
+            workers[i] = new NioWorker(workerExecutor);
         }
     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -53,16 +53,14 @@ class NioServerSocketPipelineSink extends AbstractChannelSink {
 
     static final InternalLogger logger =
         InternalLoggerFactory.getInstance(NioServerSocketPipelineSink.class);
-    private static final AtomicInteger nextId = new AtomicInteger();
 
-    private final int id = nextId.incrementAndGet();
     private final NioWorker[] workers;
     private final AtomicInteger workerIndex = new AtomicInteger();
 
     NioServerSocketPipelineSink(Executor workerExecutor, int workerCount) {
         workers = new NioWorker[workerCount];
         for (int i = 0; i < workers.length; i ++) {
-            workers[i] = new NioWorker(id, i + 1, workerExecutor);
+            workers[i] = new NioWorker(workerExecutor);
         }
     }
 

File: src/main/java/org/jboss/netty/util/NamedThreadFactory.java
Patch:
@@ -65,7 +65,7 @@ public NamedThreadFactory(String prefix, boolean daemon, int priority) {
         if (priority < Thread.MIN_PRIORITY || priority > Thread.MAX_PRIORITY) {
             throw new IllegalArgumentException(
                     "priority: " + priority +
-                    " (expected: >= " + Thread.MIN_PRIORITY + " && <= " + Thread.MAX_PRIORITY);
+                    " (expected: >= " + Thread.MIN_PRIORITY + " && <= " + Thread.MAX_PRIORITY + ')');
         }
 
         this.prefix = prefix;

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -391,6 +391,7 @@ private void connect(SelectionKey k) {
             } catch (Throwable t) {
                 ch.connectFuture.setFailure(t);
                 fireExceptionCaught(ch, t);
+                k.cancel(); // Some JDK implementations run into an infinite loop without this.
                 ch.worker.close(ch, succeededFuture(ch));
             }
         }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -424,6 +424,7 @@ private boolean read(final SelectionKey key) {
         }
 
         if (failure) {
+            key.cancel(); // Some JDK implementations run into an infinite loop without this.
             close(channel, succeededFuture(channel));
             return false;
         }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -353,6 +353,7 @@ private boolean read(SelectionKey k) {
         }
 
         if (ret < 0 || failure) {
+            k.cancel(); // Some JDK implementations run into an infinite loop without this.
             close(channel, succeededFuture(channel));
             return false;
         }

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -503,11 +503,11 @@ private void callDecode(ChannelHandlerContext context, Channel channel, ChannelB
             }
 
             // A successful decode
-            unfoldAndfireMessageReceived(context, result, remoteAddress);
+            unfoldAndFireMessageReceived(context, result, remoteAddress);
         }
     }
 
-    private void unfoldAndfireMessageReceived(
+    private void unfoldAndFireMessageReceived(
             ChannelHandlerContext context, Object result, SocketAddress remoteAddress) {
         if (unfold) {
             if (result instanceof Object[]) {
@@ -546,7 +546,7 @@ private void cleanup(ChannelHandlerContext ctx, ChannelStateEvent e)
             // notify a user that the connection was closed explicitly.
             Object partiallyDecoded = decodeLast(ctx, e.getChannel(), replayable, state);
             if (partiallyDecoded != null) {
-                unfoldAndfireMessageReceived(ctx, partiallyDecoded, null);
+                unfoldAndFireMessageReceived(ctx, partiallyDecoded, null);
             }
         } catch (ReplayError replay) {
             // Ignore

File: src/main/java/org/jboss/netty/handler/codec/compression/ZlibUtil.java
Patch:
@@ -48,6 +48,9 @@ static Enum<?> convertWrapperType(ZlibWrapper wrapper) {
         case GZIP:
             convertedWrapperType = JZlib.W_GZIP;
             break;
+        case ZLIB_OR_NONE:
+            convertedWrapperType = JZlib.W_ZLIB_OR_NONE;
+            break;
         default:
             throw new Error();
         }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecompressor.java
Patch:
@@ -35,7 +35,8 @@ protected DecoderEmbedder<ChannelBuffer> newContentDecoder(String contentEncodin
         if ("gzip".equalsIgnoreCase(contentEncoding) || "x-gzip".equalsIgnoreCase(contentEncoding)) {
             return new DecoderEmbedder<ChannelBuffer>(new ZlibDecoder(ZlibWrapper.GZIP));
         } else if ("deflate".equalsIgnoreCase(contentEncoding) || "x-deflate".equalsIgnoreCase(contentEncoding)) {
-            return new DecoderEmbedder<ChannelBuffer>(new ZlibDecoder(ZlibWrapper.ZLIB));
+            // To be strict, 'deflate' means ZLIB, but some servers were not implemented correctly.
+            return new DecoderEmbedder<ChannelBuffer>(new ZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
         }
 
         // 'identity' or unsupported

File: src/main/java/org/jboss/netty/util/internal/jzlib/JZlib.java
Patch:
@@ -54,6 +54,7 @@ public final class JZlib {
     public static final Enum<?> W_NONE = WrapperType.NONE;
     public static final Enum<?> W_ZLIB = WrapperType.ZLIB;
     public static final Enum<?> W_GZIP = WrapperType.GZIP;
+    public static final Enum<?> W_ZLIB_OR_NONE = WrapperType.ZLIB_OR_NONE;
 
     // compression levels
     public static final int Z_NO_COMPRESSION = 0;
@@ -103,6 +104,6 @@ public final class JZlib {
     static final int MAX_BL_BITS = 7;
 
     static enum WrapperType {
-        NONE, ZLIB, GZIP;
+        NONE, ZLIB, GZIP, ZLIB_OR_NONE;
     }
 }

File: src/main/java/org/jboss/netty/example/qotm/QuoteOfTheMomentServer.java
Patch:
@@ -58,7 +58,7 @@ public ChannelPipeline getPipeline() throws Exception {
             }
         });
 
-        // Enable broadcast
+        // Server doesn't need to enable broadcast to listen to a broadcast.
         b.setOption("broadcast", "false");
 
         // Allow packets as large as up to 1024 bytes (default is 768).

File: src/main/java/org/jboss/netty/buffer/ChannelBuffer.java
Patch:
@@ -48,7 +48,7 @@
  * <pre>
  * {@link ChannelBuffer} buffer = ...;
  * for (int i = 0; i &lt; buffer.capacity(); i ++</strong>) {
- *     byte b = array.getByte(i);
+ *     byte b = buffer.getByte(i);
  *     System.out.println((char) b);
  * }
  * </pre>

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -105,7 +105,7 @@
  * ...
  * </pre>
  *
- * The {@link Timer} which was specified when the {@link ReadTimeoutHandler} is
+ * The {@link Timer} which was specified when the {@link IdleStateHandler} is
  * created should be stopped manually by calling {@link #releaseExternalResources()}
  * or {@link Timer#stop()} when your application shuts down.
  *

File: src/main/java/org/jboss/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -199,6 +199,7 @@ private synchronized void flush(ChannelHandlerContext ctx) throws Exception {
                 // attempt for the current request has been failed.
                 currentEvent = null;
             } else {
+                final MessageEvent currentEvent = this.currentEvent;
                 Object m = currentEvent.getMessage();
                 if (m instanceof ChunkedInput) {
                     ChunkedInput chunks = (ChunkedInput) m;
@@ -215,7 +216,6 @@ private synchronized void flush(ChannelHandlerContext ctx) throws Exception {
                         }
                         endOfInput = chunks.isEndOfInput();
                     } catch (Throwable t) {
-                        MessageEvent currentEvent = this.currentEvent;
                         this.currentEvent = null;
 
                         currentEvent.getFuture().setFailure(t);
@@ -226,7 +226,6 @@ private synchronized void flush(ChannelHandlerContext ctx) throws Exception {
                     }
 
                     ChannelFuture writeFuture;
-                    final MessageEvent currentEvent = this.currentEvent;
                     if (endOfInput) {
                         this.currentEvent = null;
                         closeInput(chunks);
@@ -255,7 +254,6 @@ public void operationComplete(ChannelFuture future)
                         break;
                     }
                 } else {
-                    MessageEvent currentEvent = this.currentEvent;
                     this.currentEvent = null;
                     ctx.sendDownstream(currentEvent);
                 }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -298,7 +298,7 @@ public MessageEvent poll() {
                 if (newWriteBufferSize == 0 || newWriteBufferSize < lowWaterMark) {
                     if (newWriteBufferSize + messageSize >= lowWaterMark) {
                         highWaterMarkCounter.decrementAndGet();
-                        if (!notifying.get()) {
+                        if (isBound() && !notifying.get()) {
                             notifying.set(Boolean.TRUE);
                             fireChannelInterestChanged(NioDatagramChannel.this);
                             notifying.set(Boolean.FALSE);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -242,7 +242,7 @@ public MessageEvent poll() {
                 if (newWriteBufferSize == 0 || newWriteBufferSize < lowWaterMark) {
                     if (newWriteBufferSize + messageSize >= lowWaterMark) {
                         highWaterMarkCounter.decrementAndGet();
-                        if (!notifying.get()) {
+                        if (isConnected() && !notifying.get()) {
                             notifying.set(Boolean.TRUE);
                             fireChannelInterestChanged(NioSocketChannel.this);
                             notifying.set(Boolean.FALSE);

File: src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java
Patch:
@@ -24,7 +24,7 @@
 
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
-import org.jboss.netty.util.internal.IoWorkerRunnable;
+import org.jboss.netty.util.internal.DeadLockProofWorker;
 
 /**
  * The default {@link ChannelFuture} implementation.  It is recommended to
@@ -305,7 +305,7 @@ private boolean await0(long timeoutNanos, boolean interruptable) throws Interrup
     }
 
     private void checkDeadLock() {
-        if (isUseDeadLockChecker() && IoWorkerRunnable.IN_IO_THREAD.get()) {
+        if (isUseDeadLockChecker() && DeadLockProofWorker.PARENT.get() != null) {
             throw new IllegalStateException(
                     "await*() in I/O thread causes a dead lock or " +
                     "sudden performance drop. Use addListener() instead or " +

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -31,7 +31,7 @@
 import org.jboss.netty.channel.ChannelFutureListener;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
-import org.jboss.netty.util.internal.IoWorkerRunnable;
+import org.jboss.netty.util.internal.DeadLockProofWorker;
 
 /**
  * The default {@link ChannelGroupFuture} implementation.
@@ -338,7 +338,7 @@ private boolean await0(long timeoutNanos, boolean interruptable) throws Interrup
     }
 
     private void checkDeadLock() {
-        if (IoWorkerRunnable.IN_IO_THREAD.get()) {
+        if (DeadLockProofWorker.PARENT.get() != null) {
             throw new IllegalStateException(
                     "await*() in I/O thread causes a dead lock or " +
                     "sudden performance drop. Use addListener() instead or " +

File: src/main/java/org/jboss/netty/handler/queue/BlockingReadHandler.java
Patch:
@@ -28,7 +28,7 @@
 import org.jboss.netty.channel.ExceptionEvent;
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
-import org.jboss.netty.util.internal.IoWorkerRunnable;
+import org.jboss.netty.util.internal.DeadLockProofWorker;
 import org.jboss.netty.util.internal.LinkedTransferQueue;
 
 /**
@@ -244,7 +244,7 @@ public ChannelEvent readEvent(long timeout, TimeUnit unit) throws InterruptedExc
     }
 
     private void detectDeadLock() {
-        if (IoWorkerRunnable.IN_IO_THREAD.get()) {
+        if (DeadLockProofWorker.PARENT.get() != null) {
             throw new IllegalStateException(
                     "read*(...) in I/O thread causes a dead lock or " +
                     "sudden performance drop. Implement a state machine or " +

File: src/main/java/org/jboss/netty/util/internal/StackTraceSimplifier.java
Patch:
@@ -42,8 +42,8 @@ public class StackTraceSimplifier {
     private static final Pattern EXCLUDED_STACK_TRACE =
         Pattern.compile(
                 "^org\\.jboss\\.netty\\." +
-                "(util\\.(ThreadRenamingRunnable)" +
-                "|channel\\.(SimpleChannel(Upstream|Downstream)?Handler|(Default|Static)ChannelPipeline.*))$");
+                "(util\\.(ThreadRenamingRunnable|internal\\.DeadLockProofWorker)" +
+                "|channel\\.(SimpleChannel(Upstream|Downstream)?Handler|(Default|Static)ChannelPipeline.*))(\\$.*)?$");
 
     /**
      * Removes unnecessary {@link StackTraceElement}s from the specified

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -313,7 +313,7 @@ public static ChannelBuffer wrappedBuffer(ByteBuffer buffer) {
             return EMPTY_BUFFER;
         }
         if (buffer.hasArray()) {
-            return wrappedBuffer(buffer.order(), buffer.array(), buffer.arrayOffset(),buffer.remaining());
+            return wrappedBuffer(buffer.order(), buffer.array(), buffer.arrayOffset() + buffer.position(),buffer.remaining());
         } else {
             return new ByteBufferBackedChannelBuffer(buffer);
         }

File: src/main/java/org/jboss/netty/channel/socket/oio/OioDatagramWorker.java
Patch:
@@ -102,13 +102,14 @@ static void write(
             Object message, SocketAddress remoteAddress) {
         try {
             ChannelBuffer buf = (ChannelBuffer) message;
+            int offset = buf.readerIndex();
             int length = buf.readableBytes();
             ByteBuffer nioBuf = buf.toByteBuffer();
             DatagramPacket packet;
             if (nioBuf.hasArray()) {
                 // Avoid copy if the buffer is backed by an array.
                 packet = new DatagramPacket(
-                        nioBuf.array(), nioBuf.arrayOffset(), length);
+                        nioBuf.array(), nioBuf.arrayOffset() + offset, length);
             } else {
                 // Otherwise it will be expensive.
                 byte[] arrayBuf = new byte[length];

File: src/main/java/org/jboss/netty/util/internal/jzlib/ZStream.java
Patch:
@@ -78,7 +78,7 @@ public int inflateInit(int w) {
         return inflateInit(w, WrapperType.ZLIB);
     }
 
-    public int inflateInit(int w, Enum<?> wrapperType) {
+    public int inflateInit(int w, @SuppressWarnings("rawtypes") Enum wrapperType) {
         istate = new Inflate();
         return istate.inflateInit(this, w, (WrapperType) wrapperType);
     }
@@ -125,7 +125,7 @@ public int deflateInit(int level, int bits) {
         return deflateInit(level, bits, WrapperType.ZLIB);
     }
 
-    public int deflateInit(int level, int bits, Enum<?> wrapperType) {
+    public int deflateInit(int level, int bits, @SuppressWarnings("rawtypes") Enum wrapperType) {
         dstate = new Deflate();
         return dstate.deflateInit(this, level, bits, (WrapperType) wrapperType);
     }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -335,8 +335,9 @@ private boolean read(SelectionKey k) {
 
             final ChannelBufferFactory bufferFactory =
                 channel.getConfig().getBufferFactory();
-            final ChannelBuffer buffer = bufferFactory.getBuffer(
-                    bb.order(bufferFactory.getDefaultOrder()));
+            final ChannelBuffer buffer = bufferFactory.getBuffer(readBytes);
+            buffer.setBytes(0, bb);
+            buffer.writerIndex(readBytes);
 
             recvBufferPool.release(bb);
 

File: src/main/java/org/jboss/netty/handler/codec/embedder/AbstractCodecEmbedder.java
Patch:
@@ -102,6 +102,7 @@ private void configurePipeline(ChannelHandler... handlers) {
     }
 
     public boolean finish() {
+        close(channel);
         fireChannelDisconnected(channel);
         fireChannelUnbound(channel);
         fireChannelClosed(channel);

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -164,7 +164,7 @@ protected HttpMessageDecoder(
         if (maxHeaderSize <= 0) {
             throw new IllegalArgumentException(
                     "maxHeaderSize must be a positive integer: " +
-                    maxChunkSize);
+                    maxHeaderSize);
         }
         if (maxChunkSize < 0) {
             throw new IllegalArgumentException(

File: src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java
Patch:
@@ -438,7 +438,9 @@ protected void decreaseCounter(Runnable task) {
         //System.out.println("D: " + totalCounter + ", " + increment);
         if (maxTotalMemorySize != 0 && totalCounter + increment >= maxTotalMemorySize) {
             //System.out.println("RELEASE: " + task);
-            semaphore.release();
+            while (semaphore.hasQueuedThreads()) {
+                semaphore.release();
+            }
         }
 
         if (task instanceof ChannelEventRunnable) {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -89,6 +89,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                 if (encodings.isEmpty()) {
                     m.removeHeader(HttpHeaders.Names.TRANSFER_ENCODING);
                 }
+                m.setChunked(false);
                 m.setContent(ChannelBuffers.dynamicBuffer(e.getChannel().getConfig().getBufferFactory()));
                 this.currentMessage = m;
             } else {

File: src/main/java/org/jboss/netty/util/ThreadRenamingRunnable.java
Patch:
@@ -95,7 +95,7 @@ public static boolean renameThread(Thread thread, String service, String categor
             newThreadName = oldThreadName;
         }
 
-        // Change the thread name before starting the actual runnable.
+        // Change the thread name.
         boolean renamed = false;
         if (!oldThreadName.equals(newThreadName)) {
             try {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -195,9 +195,8 @@ void register(NioClientSocketChannel channel) {
                     boolean success = false;
                     try {
                         bossExecutor.execute(
-                                new IoWorkerRunnable(
-                                        new ThreadRenamingRunnable(
-                                                this, "New I/O client boss #" + id)));
+                                new IoWorkerRunnable(new ThreadRenamingRunnable(
+                                        this, "New I/O", "client boss", String.valueOf(id), null)));
                         success = true;
                     } finally {
                         if (!success) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramPipelineSink.java
Patch:
@@ -46,9 +46,7 @@ class NioDatagramPipelineSink extends AbstractChannelSink {
     private static final AtomicInteger nextId = new AtomicInteger();
 
     private final int id = nextId.incrementAndGet();
-
     private final NioDatagramWorker[] workers;
-
     private final AtomicInteger workerIndex = new AtomicInteger();
 
     /**

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -168,8 +168,8 @@ void register(final NioDatagramChannel channel, final ChannelFuture future) {
                 boolean success = false;
                 try {
                     // Start the main selector loop. See run() for details.
-                    executor.execute(new ThreadRenamingRunnable(this,
-                            "New I/O datagram worker #" + bossId + "'-'" + id));
+                    executor.execute(new ThreadRenamingRunnable(
+                            this, "New I/O", "datagram worker", bossId + "-" + id, null));
                     success = true;
                 } finally {
                     if (!success) {

File: src/main/java/org/jboss/netty/util/HashedWheelTimer.java
Patch:
@@ -210,7 +210,9 @@ public HashedWheelTimer(
         roundDuration = tickDuration * wheel.length;
 
         workerThread = threadFactory.newThread(new ThreadRenamingRunnable(
-                        worker, "Hashed wheel timer #" + id.incrementAndGet()));
+                        worker,
+                        "Hashed wheel timer", null,
+                        String.valueOf(id.incrementAndGet()), null));
 
         // Misuse check
         misuseDetector.increase();

File: src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java
Patch:
@@ -144,7 +144,7 @@ public ConnectionlessBootstrap(ChannelFactory channelFactory) {
      *
      * <pre>
      * {@link ConnectionlessBootstrap} b = ...;
-     * b.connect(b.getOption("localAddress"));
+     * b.bind(b.getOption("localAddress"));
      * </pre>
      *
      * @return a new bound channel which accepts incoming connections

File: src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -232,7 +232,7 @@ public void setParentHandler(ChannelHandler parentHandler) {
      *
      * <pre>
      * {@link ServerBootstrap} b = ...;
-     * b.connect(b.getOption("localAddress"));
+     * b.bind(b.getOption("localAddress"));
      * </pre>
      *
      * @return a new bound channel which accepts incoming connections

File: src/main/java/org/jboss/netty/example/http/websocket/WebSocketServerHandler.java
Patch:
@@ -123,8 +123,7 @@ private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throw
                 input.writeInt(b);
                 input.writeLong(c);
                 ChannelBuffer output = ChannelBuffers.wrappedBuffer(
-                        MessageDigest.getInstance("MD5").digest(input.array()),
-                        new byte[] { '\r', '\n' });
+                        MessageDigest.getInstance("MD5").digest(input.array()));
                 res.setContent(output);
             } else {
                 // Old handshake method with no challenge:

File: src/main/java/org/jboss/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -631,14 +631,14 @@ public static long getContentLength(HttpMessage message, long defaultValue) {
             if (HttpMethod.GET.equals(req.getMethod()) &&
                 req.containsHeader(Names.SEC_WEBSOCKET_KEY1) &&
                 req.containsHeader(Names.SEC_WEBSOCKET_KEY2)) {
-                return 10;
+                return 8;
             }
         } else if (message instanceof HttpResponse) {
             HttpResponse res = (HttpResponse) message;
             if (res.getStatus().getCode() == 101 &&
                 res.containsHeader(Names.SEC_WEBSOCKET_ORIGIN) &&
                 res.containsHeader(Names.SEC_WEBSOCKET_LOCATION)) {
-                return 18;
+                return 16;
             }
         }
 

File: src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java
Patch:
@@ -304,7 +304,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
 
     public ChannelBuffer slice(int index, int length) {
         if (index == 0 && length == capacity()) {
-            return duplicate();
+            ChannelBuffer slice = duplicate();
+            slice.setIndex(0, length);
+            return slice;
         } else {
             if (index >= 0 && length == 0) {
                 return ChannelBuffers.EMPTY_BUFFER;

File: src/main/java/org/jboss/netty/buffer/HeapChannelBuffer.java
Patch:
@@ -192,7 +192,9 @@ public ChannelBuffer slice(int index, int length) {
                 return ChannelBuffers.EMPTY_BUFFER;
             }
             if (length == array.length) {
-                return duplicate();
+                ChannelBuffer slice = duplicate();
+                slice.setIndex(0, length);
+                return slice;
             } else {
                 return new TruncatedChannelBuffer(this, length);
             }

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -935,7 +935,8 @@ private ChannelBuffer unwrap(
     }
 
     private void handleRenegotiation(HandshakeStatus handshakeStatus) {
-        if (handshakeStatus == HandshakeStatus.NOT_HANDSHAKING) {
+        if (handshakeStatus == HandshakeStatus.NOT_HANDSHAKING ||
+            handshakeStatus == HandshakeStatus.FINISHED) {
             // Not handshaking
             return;
         }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -547,7 +547,7 @@ private void write0(final NioDatagramChannel channel) {
                         }
                     }
 
-                    if (localWrittenBytes > 0) {
+                    if (localWrittenBytes > 0 || buf.finished()) {
                         // Successful write - proceed to the next message.
                         buf.release();
                         ChannelFuture future = evt.getFuture();

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -603,7 +603,7 @@ private String[] splitInitialLine(String sb) {
         return new String[] {
                 sb.substring(aStart, aEnd),
                 sb.substring(bStart, bEnd),
-                sb.substring(cStart, cEnd) };
+                cStart < cEnd? sb.substring(cStart, cEnd) : "" };
     }
 
     private String[] splitHeader(String sb) {

File: src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java
Patch:
@@ -219,6 +219,8 @@ protected Set<Object> getChildExecutorKeySet() {
     }
 
     protected boolean removeChildExecutor(Object key) {
+        // FIXME: Succeed only when there is no task in the ChildExecutor's queue.
+        //        Note that it will need locking which might slow down task submission.
         return childExecutors.remove(key) != null;
     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/SocketSendBufferPool.java
Patch:
@@ -270,7 +270,7 @@ public long totalBytes() {
         }
 
         public long transferTo(WritableByteChannel ch) throws IOException {
-            long localWrittenBytes = file.transferTo(ch);
+            long localWrittenBytes = file.transferTo(ch, writtenBytes);
             writtenBytes += localWrittenBytes;
             return localWrittenBytes;
         }

File: src/main/java/org/jboss/netty/handler/stream/ChunkedFile.java
Patch:
@@ -130,7 +130,7 @@ public boolean hasNextChunk() throws Exception {
     }
 
     public boolean isEndOfInput() throws Exception {
-        return hasNextChunk();
+        return !hasNextChunk();
     }
 
     public void close() throws Exception {

File: src/main/java/org/jboss/netty/handler/stream/ChunkedNioFile.java
Patch:
@@ -136,7 +136,7 @@ public boolean hasNextChunk() throws Exception {
     }
 
     public boolean isEndOfInput() throws Exception {
-        return hasNextChunk();
+        return !hasNextChunk();
     }
 
     public void close() throws Exception {

File: src/main/java/org/jboss/netty/handler/stream/ChunkedNioStream.java
Patch:
@@ -97,7 +97,7 @@ public boolean hasNextChunk() throws Exception {
     }
 
     public boolean isEndOfInput() throws Exception {
-        return hasNextChunk();
+        return !hasNextChunk();
     }
 
     public void close() throws Exception {

File: src/main/java/org/jboss/netty/handler/stream/ChunkedStream.java
Patch:
@@ -85,7 +85,7 @@ public boolean hasNextChunk() throws Exception {
     }
 
     public boolean isEndOfInput() throws Exception {
-        return hasNextChunk();
+        return !hasNextChunk();
     }
 
     public void close() throws Exception {

File: src/main/java/org/jboss/netty/example/local/LocalServerPipelineFactory.java
Patch:
@@ -37,17 +37,17 @@
  */
 public class LocalServerPipelineFactory implements ChannelPipelineFactory {
 
-    private final Executor eventExecutor;
+    private final ExecutionHandler executionHandler;
 
     public LocalServerPipelineFactory(Executor eventExecutor) {
-        this.eventExecutor = eventExecutor;
+        executionHandler = new ExecutionHandler(eventExecutor);
     }
 
     public ChannelPipeline getPipeline() throws Exception {
         final ChannelPipeline pipeline = Channels.pipeline();
         pipeline.addLast("decoder", new StringDecoder());
         pipeline.addLast("encoder", new StringEncoder());
-        pipeline.addLast("executor", new ExecutionHandler(eventExecutor));
+        pipeline.addLast("executor", executionHandler);
         pipeline.addLast("handler", new EchoCloseServerHandler());
         return pipeline;
     }

File: src/main/java/org/jboss/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -248,8 +248,9 @@ public void operationComplete(ChannelFuture future)
                         break;
                     }
                 } else {
+                    MessageEvent currentEvent = this.currentEvent;
+                    this.currentEvent = null;
                     ctx.sendDownstream(currentEvent);
-                    currentEvent = null;
                 }
             }
 

File: src/main/java/org/jboss/netty/util/internal/ConcurrentHashMap.java
Patch:
@@ -264,8 +264,6 @@ static final class Segment<K, V> extends ReentrantLock {
          * The load factor for the hash table.  Even though this value is same
          * for all segments, it is replicated to avoid needing links to outer
          * object.
-         *
-         * @serial
          */
         final float loadFactor;
 

File: src/main/java/org/jboss/netty/util/internal/ConcurrentIdentityHashMap.java
Patch:
@@ -264,8 +264,6 @@ static final class Segment<K, V> extends ReentrantLock {
          * The load factor for the hash table.  Even though this value is same
          * for all segments, it is replicated to avoid needing links to outer
          * object.
-         *
-         * @serial
          */
         final float loadFactor;
 

File: src/main/java/org/jboss/netty/util/internal/ConcurrentIdentityWeakKeyHashMap.java
Patch:
@@ -303,8 +303,6 @@ static final class Segment<K, V> extends ReentrantLock {
          * The load factor for the hash table.  Even though this value is same
          * for all segments, it is replicated to avoid needing links to outer
          * object.
-         *
-         * @serial
          */
         final float loadFactor;
 

File: src/main/java/org/jboss/netty/util/internal/ConcurrentWeakKeyHashMap.java
Patch:
@@ -303,8 +303,6 @@ static final class Segment<K, V> extends ReentrantLock {
          * The load factor for the hash table.  Even though this value is same
          * for all segments, it is replicated to avoid needing links to outer
          * object.
-         *
-         * @serial
          */
         final float loadFactor;
 

File: src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java
Patch:
@@ -88,7 +88,7 @@ public long getLong(int index) {
                 ((long) array[index+7] & 0xff) <<  0;
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         array[index  ] = (byte) (value >>> 8);
         array[index+1] = (byte) (value >>> 0);
     }

File: src/main/java/org/jboss/netty/buffer/CompositeChannelBuffer.java
Patch:
@@ -307,12 +307,12 @@ public void getBytes(int index, OutputStream out, int length)
         }
     }
 
-    public void setByte(int index, byte value) {
+    public void setByte(int index, int value) {
         int componentId = componentId(index);
         components[componentId].setByte(index - indices[componentId], value);
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         int componentId = componentId(index);
         if (index + 2 <= indices[componentId + 1]) {
             components[componentId].setShort(index - indices[componentId], value);

File: src/main/java/org/jboss/netty/buffer/DuplicatedChannelBuffer.java
Patch:
@@ -128,11 +128,11 @@ public void getBytes(int index, ByteBuffer dst) {
         buffer.getBytes(index, dst);
     }
 
-    public void setByte(int index, byte value) {
+    public void setByte(int index, int value) {
         buffer.setByte(index, value);
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         buffer.setShort(index, value);
     }
 

File: src/main/java/org/jboss/netty/buffer/HeapChannelBuffer.java
Patch:
@@ -121,8 +121,8 @@ public int getBytes(int index, GatheringByteChannel out, int length)
         return out.write(ByteBuffer.wrap(array, index, length));
     }
 
-    public void setByte(int index, byte value) {
-        array[index] = value;
+    public void setByte(int index, int value) {
+        array[index] = (byte) value;
     }
 
     public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {

File: src/main/java/org/jboss/netty/buffer/LittleEndianHeapChannelBuffer.java
Patch:
@@ -88,7 +88,7 @@ public long getLong(int index) {
                ((long) array[index+7] & 0xff) << 56;
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         array[index  ] = (byte) (value >>> 0);
         array[index+1] = (byte) (value >>> 8);
     }

File: src/main/java/org/jboss/netty/buffer/ReadOnlyChannelBuffer.java
Patch:
@@ -85,7 +85,7 @@ public void discardReadBytes() {
         throw new ReadOnlyBufferException();
     }
 
-    public void setByte(int index, byte value) {
+    public void setByte(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
@@ -101,7 +101,7 @@ public void setBytes(int index, ByteBuffer src) {
         throw new ReadOnlyBufferException();
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -148,12 +148,12 @@ public void getBytes(int index, ByteBuffer dst) {
         buffer.getBytes(index + adjustment, dst);
     }
 
-    public void setByte(int index, byte value) {
+    public void setByte(int index, int value) {
         checkIndex(index);
         buffer.setByte(index + adjustment, value);
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         checkIndex(index, 2);
         buffer.setShort(index + adjustment, value);
     }

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -142,12 +142,12 @@ public void getBytes(int index, ByteBuffer dst) {
         buffer.getBytes(index, dst);
     }
 
-    public void setByte(int index, byte value) {
+    public void setByte(int index, int value) {
         checkIndex(index);
         buffer.setByte(index, value);
     }
 
-    public void setShort(int index, short value) {
+    public void setShort(int index, int value) {
         checkIndex(index, 2);
         buffer.setShort(index, value);
     }

File: src/main/java/org/jboss/netty/channel/WriteCompletionEvent.java
Patch:
@@ -34,5 +34,5 @@ public interface WriteCompletionEvent extends ChannelEvent {
      * @return the number of written bytes or messages, depending on the
      *         type of the transport
      */
-    int getWrittenAmount();
+    long getWrittenAmount();
 }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java
Patch:
@@ -91,7 +91,7 @@ public class NioClientSocketChannelFactory implements ClientSocketChannelFactory
 
     /**
      * Creates a new instance.  Calling this constructor is same with calling
-     * {@link #NioClientSocketChannelFactory(Executor, Executor, int)} with
+     * {@link #NioClientSocketChannelFactory(Executor, Executor, int)} with 2 *
      * the number of available processors in the machine.  The number of
      * available processors is obtained by {@link Runtime#availableProcessors()}.
      *
@@ -102,7 +102,7 @@ public class NioClientSocketChannelFactory implements ClientSocketChannelFactory
      */
     public NioClientSocketChannelFactory(
             Executor bossExecutor, Executor workerExecutor) {
-        this(bossExecutor, workerExecutor, Runtime.getRuntime().availableProcessors());
+        this(bossExecutor, workerExecutor, SelectorUtil.DEFAULT_IO_THREADS);
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramChannelFactory.java
Patch:
@@ -87,15 +87,15 @@ public class NioDatagramChannelFactory implements DatagramChannelFactory {
 
     /**
      * Creates a new instance.  Calling this constructor is same with calling
-     * {@link #NioDatagramChannelFactory(Executor, int)} with the number of
+     * {@link #NioDatagramChannelFactory(Executor, int)} with 2 * the number of
      * available processors in the machine.  The number of available processors
      * is obtained by {@link Runtime#availableProcessors()}.
      *
      * @param workerExecutor
      *        the {@link Executor} which will execute the I/O worker threads
      */
     public NioDatagramChannelFactory(final Executor workerExecutor) {
-        this(workerExecutor, Runtime.getRuntime().availableProcessors());
+        this(workerExecutor, SelectorUtil.DEFAULT_IO_THREADS);
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannelFactory.java
Patch:
@@ -95,7 +95,7 @@ public class NioServerSocketChannelFactory implements ServerSocketChannelFactory
 
     /**
      * Creates a new instance.  Calling this constructor is same with calling
-     * {@link #NioServerSocketChannelFactory(Executor, Executor, int)} with
+     * {@link #NioServerSocketChannelFactory(Executor, Executor, int)} with 2 *
      * the number of available processors in the machine.  The number of
      * available processors is obtained by {@link Runtime#availableProcessors()}.
      *
@@ -106,7 +106,7 @@ public class NioServerSocketChannelFactory implements ServerSocketChannelFactory
      */
     public NioServerSocketChannelFactory(
             Executor bossExecutor, Executor workerExecutor) {
-        this(bossExecutor, workerExecutor, Runtime.getRuntime().availableProcessors());
+        this(bossExecutor, workerExecutor, SelectorUtil.DEFAULT_IO_THREADS);
     }
 
     /**

File: src/main/java/org/jboss/netty/channel/socket/nio/SelectorUtil.java
Patch:
@@ -31,6 +31,8 @@ final class SelectorUtil {
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SelectorUtil.class);
 
+    static final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * 2;
+
     static void select(Selector selector) throws IOException {
         try {
             selector.select(500);

File: src/main/java/org/jboss/netty/channel/socket/nio/SocketSendBufferPool.java
Patch:
@@ -35,8 +35,8 @@ final class SocketSendBufferPool {
         assert (DEFAULT_PREALLOCATION_SIZE & ALIGN_MASK) == 0;
     }
 
-    private PreallocationRef poolHead = null;
-    private Preallocation current = new Preallocation(DEFAULT_PREALLOCATION_SIZE);
+    PreallocationRef poolHead = null;
+    Preallocation current = new Preallocation(DEFAULT_PREALLOCATION_SIZE);
 
     SocketSendBufferPool() {
         super();

File: src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java
Patch:
@@ -348,8 +348,8 @@ private void notifyListeners() {
         // This method doesn't need synchronization because:
         // 1) This method is always called after synchronized (this) block.
         //    Hence any listener list modification happens-before this method.
-        // 2) This method is only when 'done' is true.  If 'done' is true,
-        //    the listener list is never modified - see add/removeListener().
+        // 2) This method is called only when 'done' is true.  Once 'done'
+        //    becomes true, the listener list is never modified - see add/removeListener()
         if (firstListener != null) {
             notifyListener(firstListener);
             firstListener = null;

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -349,8 +349,8 @@ private void notifyListeners() {
         // This method doesn't need synchronization because:
         // 1) This method is always called after synchronized (this) block.
         //    Hence any listener list modification happens-before this method.
-        // 2) This method is only when 'done' is true.  If 'done' is true,
-        //    the listener list is never modified - see add/removeListener().
+        // 2) This method is called only when 'done' is true.  Once 'done'
+        //    becomes true, the listener list is never modified - see add/removeListener()
         if (firstListener != null) {
             notifyListener(firstListener);
             firstListener = null;

File: src/main/java/org/jboss/netty/channel/ChannelFutureListener.java
Patch:
@@ -63,8 +63,8 @@ public void operationComplete(ChannelFuture future) {
      * Invoked when the I/O operation associated with the {@link ChannelFuture}
      * has been completed.
      *
-     * @param future  The source {@link ChannelFuture} which called this
-     *                callback.
+     * @param future  the source {@link ChannelFuture} which called this
+     *                callback
      */
     void operationComplete(ChannelFuture future) throws Exception;
 }

File: src/main/java/org/jboss/netty/channel/ChannelFuture.java
Patch:
@@ -250,9 +250,9 @@ public interface ChannelFuture {
     /**
      * Removes the specified listener from this future.
      * The specified listener is no longer notified when this
-     * future is {@linkplain #isDone() done}.  If this
-     * future is already completed, this method has no effect
-     * and returns silently.
+     * future is {@linkplain #isDone() done}.  If the specified
+     * listener is not associated with this future, this method
+     * does nothing and returns silently.
      */
     void removeListener(ChannelFutureListener listener);
 

File: src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java
Patch:
@@ -40,7 +40,7 @@ final class DirectBufferPool {
                 0);
 
         if (val <= 0) {
-            val = 128 * 1024;
+            val = 1048576;
         } else {
             logger.debug(
                     "Setting the preallocated buffer capacity to: " + val);

File: src/main/java/org/jboss/netty/handler/execution/ExecutionHandler.java
Patch:
@@ -28,6 +28,7 @@
 import org.jboss.netty.channel.ChannelState;
 import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.ChannelUpstreamHandler;
+import org.jboss.netty.channel.Channels;
 import org.jboss.netty.channel.ChannelHandler.Sharable;
 import org.jboss.netty.util.ExternalResourceReleasable;
 import org.jboss.netty.util.internal.ExecutorUtil;

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramChannel.java
Patch:
@@ -15,7 +15,8 @@
  */
 package org.jboss.netty.channel.socket.nio;
 
-import static org.jboss.netty.channel.Channels.*;
+import static org.jboss.netty.channel.Channels.fireChannelInterestChanged;
+import static org.jboss.netty.channel.Channels.fireChannelOpen;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -27,7 +28,6 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.jboss.netty.buffer.ChannelBuffer;
@@ -78,7 +78,7 @@ class NioDatagramChannel extends AbstractChannel
     /**
      * Monitor object for synchronizing access to the {@link WriteBufferQueue}.
      */
-    final Lock writeLock = new ReentrantLock();
+    final ReentrantLock writeLock = new ReentrantLock();
 
     /**
      * WriteTask that performs write operations.

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.jboss.netty.buffer.ChannelBuffer;
@@ -61,7 +60,7 @@ class NioSocketChannel extends AbstractChannel
     private volatile InetSocketAddress remoteAddress;
 
     final Object interestOpsLock = new Object();
-    final Lock writeLock = new ReentrantLock();
+    final ReentrantLock writeLock = new ReentrantLock();
 
     final Runnable writeTask = new WriteTask();
     final AtomicBoolean writeTaskInTaskQueue = new AtomicBoolean();

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -61,8 +61,8 @@ public class HttpRequestDecoder extends HttpMessageDecoder {
 
     /**
      * Creates a new instance with the default
-     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (4096)}, and
-     * {@code maxChunkSize (4096)}.
+     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and
+     * {@code maxChunkSize (8192)}.
      */
     public HttpRequestDecoder() {
         super();

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -62,8 +62,8 @@ public class HttpResponseDecoder extends HttpMessageDecoder {
 
     /**
      * Creates a new instance with the default
-     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (4096)}, and
-     * {@code maxChunkSize (4096)}.
+     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and
+     * {@code maxChunkSize (8192)}.
      */
     public HttpResponseDecoder() {
         super();

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestDecoder.java
Patch:
@@ -37,8 +37,8 @@ public class RtspRequestDecoder extends HttpMessageDecoder {
 
     /**
      * Creates a new instance with the default
-     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (4096)}, and
-     * {@code maxChunkSize (4096)}.
+     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and
+     * {@code maxChunkSize (8192)}.
      */
     public RtspRequestDecoder() {
         super();

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseDecoder.java
Patch:
@@ -38,8 +38,8 @@ public class RtspResponseDecoder extends HttpMessageDecoder {
 
     /**
      * Creates a new instance with the default
-     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (4096)}, and
-     * {@code maxChunkSize (4096)}.
+     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and
+     * {@code maxChunkSize (8192)}.
      */
     public RtspResponseDecoder() {
         super();

File: src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -96,7 +96,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
         ChannelFuture writeFuture = ch.write(new ChunkedFile(raf, 0, fileLength, 8192));
 
         // Decide whether to close the connection or not.
-        if (!request.isKeepAlive()) {
+        if (!isKeepAlive(request)) {
             // Close the connection when the whole content is written out.
             writeFuture.addListener(ChannelFutureListener.CLOSE);
         }

File: src/main/java/org/jboss/netty/example/http/snoop/HttpRequestHandler.java
Patch:
@@ -125,7 +125,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
 
     private void writeResponse(MessageEvent e) {
         // Decide whether to close the connection or not.
-        boolean keepAlive = request.isKeepAlive();
+        boolean keepAlive = isKeepAlive(request);
 
         // Build the response object.
         HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
@@ -154,7 +154,7 @@ private void writeResponse(MessageEvent e) {
 
         // Write the response.
         ChannelFuture future = e.getChannel().write(response);
-
+        System.out.println(response.toString());
         // Close the non-keep-alive connection after the write operation is done.
         if (!keepAlive) {
             future.addListener(ChannelFutureListener.CLOSE);

File: src/main/java/org/jboss/netty/example/http/websocket/WebSocketServerHandler.java
Patch:
@@ -140,7 +140,7 @@ private void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpRe
 
         // Send the response and close the connection if necessary.
         ChannelFuture f = ctx.getChannel().write(res);
-        if (!req.isKeepAlive() || res.getStatus().getCode() != 200) {
+        if (!isKeepAlive(req) || res.getStatus().getCode() != 200) {
             f.addListener(ChannelFutureListener.CLOSE);
         }
     }

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpRequest.java
Patch:
@@ -69,9 +69,7 @@ public void setUri(String uri) {
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(getClass().getSimpleName());
-        buf.append("(keepAlive: ");
-        buf.append(isKeepAlive());
-        buf.append(", chunked: ");
+        buf.append("(chunked: ");
         buf.append(isChunked());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpResponse.java
Patch:
@@ -55,9 +55,7 @@ public void setStatus(HttpResponseStatus status) {
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(getClass().getSimpleName());
-        buf.append("(keepAlive: ");
-        buf.append(isKeepAlive());
-        buf.append(", chunked: ");
+        buf.append("(chunked: ");
         buf.append(isChunked());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspVersions.java
Patch:
@@ -30,7 +30,7 @@ public final class RtspVersions {
     /**
      * RTSP/1.0
      */
-    public static final HttpVersion RTSP_1_0 = new HttpVersion("RTSP", 1, 0);
+    public static final HttpVersion RTSP_1_0 = new HttpVersion("RTSP", 1, 0, true);
 
     /**
      * Returns an existing or new {@link HttpVersion} instance which matches to
@@ -48,7 +48,7 @@ public static HttpVersion valueOf(String text) {
             return RTSP_1_0;
         }
 
-        return new HttpVersion(text);
+        return new HttpVersion(text, true);
     }
 
     private RtspVersions() {

File: src/main/java/org/jboss/netty/channel/socket/nio/DefaultNioSocketChannelConfig.java
Patch:
@@ -81,6 +81,8 @@ public boolean setOption(String key, Object value) {
             setWriteBufferLowWaterMark0(ConversionUtil.toInt(value));
         } else if (key.equals("writeSpinCount")) {
             setWriteSpinCount(ConversionUtil.toInt(value));
+        } else if (key.equals("receiveBufferSizePredictorFactory")) {
+            setReceiveBufferSizePredictorFactory((ReceiveBufferSizePredictorFactory) value);
         } else if (key.equals("receiveBufferSizePredictor")) {
             setReceiveBufferSizePredictor((ReceiveBufferSizePredictor) value);
         } else {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -73,11 +73,11 @@
  * 0
  * Content-MD5: ...
  * <i>[blank line]</i>
- * </pre>.
+ * </pre>
  * triggers {@link HttpRequestDecoder} to generate 4 objects:
  * <ol>
  * <li>An {@link HttpRequest} whose {@link HttpMessage#isChunked() chunked}
- *     property is {@code true},<li>
+ *     property is {@code true},</li>
  * <li>The first {@link HttpChunk} whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>
  * <li>The second {@link HttpChunk} whose content is {@code '1234567890abcdef'}, and</li>
  * <li>An {@link HttpChunkTrailer} which marks the end of the content.</li>

File: src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseStatuses.java
Patch:
@@ -221,7 +221,7 @@ public final class RtspResponseStatuses {
             462, "Destination unreachable");
 
     /**
-     * 463 Destination unreachable
+     * 463 Key management failure
      */
     public static final HttpResponseStatus KEY_MANAGEMENT_FAILURE = new HttpResponseStatus(
             463, "Key management failure");

File: src/main/java/org/jboss/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -567,6 +567,7 @@ private void removeHeader0(int h, int i, String name) {
                     e = next;
                 } else {
                     entries[i] = null;
+                    e.remove();
                     return;
                 }
             } else {

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpChunkTrailer.java
Patch:
@@ -48,15 +48,15 @@ public boolean isLast() {
         return true;
     }
 
-    public void addHeader(final String name, final String value) {
+    public void addHeader(final String name, final Object value) {
         headers.addHeader(name, value);
     }
 
-    public void setHeader(final String name, final String value) {
+    public void setHeader(final String name, final Object value) {
         headers.setHeader(name, value);
     }
 
-    public void setHeader(final String name, final Iterable<String> values) {
+    public void setHeader(final String name, final Iterable<?> values) {
         headers.setHeader(name, values);
     }
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpChunk.java
Patch:
@@ -56,7 +56,7 @@ public boolean isLast() {
             return true;
         }
 
-        public void addHeader(String name, String value) {
+        public void addHeader(String name, Object value) {
             throw new IllegalStateException("read-only");
         }
 
@@ -88,11 +88,11 @@ public void removeHeader(String name) {
             // NOOP
         }
 
-        public void setHeader(String name, String value) {
+        public void setHeader(String name, Object value) {
             throw new IllegalStateException("read-only");
         }
 
-        public void setHeader(String name, Iterable<String> values) {
+        public void setHeader(String name, Iterable<?> values) {
             throw new IllegalStateException("read-only");
         }
     };

File: src/main/java/org/jboss/netty/handler/codec/http/HttpChunkTrailer.java
Patch:
@@ -74,21 +74,21 @@ public interface HttpChunkTrailer extends HttpChunk {
     /**
      * Adds a new trailing header with the specified name and value.
      */
-    void addHeader(String name, String value);
+    void addHeader(String name, Object value);
 
     /**
      * Sets a new trailing header with the specified name and value.
      * If there is an existing trailing header with the same name, the existing
      * one is removed.
      */
-    void setHeader(String name, String value);
+    void setHeader(String name, Object value);
 
     /**
      * Sets a new trailing header with the specified name and values.
      * If there is an existing trailing header with the same name, the existing
      * one is removed.
      */
-    void setHeader(String name, Iterable<String> values);
+    void setHeader(String name, Iterable<?> values);
 
     /**
      * Removes the trailing header with the specified name.

File: src/test/java/org/jboss/netty/channel/socket/NioServerSocketShutdownTimeTest.java
Patch:
@@ -62,7 +62,7 @@ public void testSuccessfulBindAttempt() throws Exception {
 
         Channel channel = bootstrap.bind();
 
-        long startTime = System.currentTimeMillis();
+        final long startTime;
 
         Socket socket = null;
         try {
@@ -87,6 +87,8 @@ public void testSuccessfulBindAttempt() throws Exception {
                     // Ignore.
                 }
             }
+
+            startTime = System.currentTimeMillis();
             channel.close().awaitUninterruptibly();
             bootstrap.getFactory().releaseExternalResources();
         }

File: src/test/java/org/jboss/netty/buffer/AbstractChannelBufferTest.java
Patch:
@@ -1199,6 +1199,7 @@ public void testSequentialCopiedBufferTransfer1() {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testSequentialCopiedBufferTransfer2() {
         buffer.clear();
         buffer.writeZero(buffer.capacity());
@@ -1249,6 +1250,7 @@ public void testSequentialSlice1() {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testSequentialSlice2() {
         buffer.clear();
         buffer.writeZero(buffer.capacity());
@@ -1641,6 +1643,7 @@ public void testSkipBytes1() {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testSkipBytes2() {
         buffer.clear();
         buffer.writeZero(buffer.capacity());

File: src/test/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderTest.java
Patch:
@@ -63,7 +63,8 @@ private static final class LineDecoder extends ReplayingDecoder<VoidEnum> {
         @Override
         protected Object decode(ChannelHandlerContext ctx, Channel channel,
                 ChannelBuffer buffer, VoidEnum state) throws Exception {
-            ChannelBuffer msg = buffer.readBytes(ChannelBufferIndexFinder.LF);
+            ChannelBuffer msg = buffer.readBytes(
+                    buffer.bytesBefore(ChannelBufferIndexFinder.LF));
             buffer.skipBytes(1);
             return msg;
         }

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -794,8 +794,8 @@ public static ChannelBuffer copiedBuffer(
     private static ChannelBuffer copiedBuffer(ByteOrder endianness, CharBuffer buffer, Charset charset) {
         CharBuffer src = buffer;
         ByteBuffer dst = ChannelBuffers.encodeString(src, charset);
-        ChannelBuffer result = wrappedBuffer(endianness, dst.array(), 0, dst.remaining());
-        result.writerIndex(dst.position());
+        ChannelBuffer result = wrappedBuffer(endianness, dst.array());
+        result.writerIndex(dst.remaining());
         return result;
     }
 

File: src/main/java/org/jboss/netty/buffer/DuplicatedChannelBuffer.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -182,7 +181,7 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public int getString(int index, int length, CharBuffer dst, Charset charset) {
-        return buffer.getString(index, length, dst, charset);
+    public String toString(int index, int length, Charset charset) {
+        return buffer.toString(index, length, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/DynamicChannelBuffer.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -292,7 +291,7 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public int getString(int index, int length, CharBuffer dst, Charset charset) {
-        return buffer.getString(index, length, dst, charset);
+    public String toString(int index, int length, Charset charset) {
+        return buffer.toString(index, length, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/ReadOnlyChannelBuffer.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.CharBuffer;
 import java.nio.ReadOnlyBufferException;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
@@ -196,7 +195,7 @@ public int capacity() {
         return buffer.capacity();
     }
 
-    public int getString(int index, int length, CharBuffer dst, Charset charset) {
-        return buffer.getString(index, length, dst, charset);
+    public String toString(int index, int length, Charset charset) {
+        return buffer.toString(index, length, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -215,9 +214,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index + adjustment, length);
     }
 
-    public int getString(int index, int length, CharBuffer dst, Charset charset) {
+    public String toString(int index, int length, Charset charset) {
         checkIndex(index, length);
-        return buffer.getString(index + adjustment, length, dst, charset);
+        return buffer.toString(index + adjustment, length, charset);
     }
 
     private void checkIndex(int index) {

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -209,9 +208,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public int getString(int index, int length, CharBuffer dst, Charset charset) {
+    public String toString(int index, int length, Charset charset) {
         checkIndex(index, length);
-        return buffer.getString(index, length, dst, charset);
+        return buffer.toString(index, length, charset);
     }
 
     private void checkIndex(int index) {

File: src/main/java/org/jboss/netty/buffer/DuplicatedChannelBuffer.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -181,7 +182,7 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public String toString(int index, int length, Charset charset) {
-        return buffer.toString(index, length, charset);
+    public int getString(int index, int length, CharBuffer dst, Charset charset) {
+        return buffer.getString(index, length, dst, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/DynamicChannelBuffer.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -291,7 +292,7 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public String toString(int index, int length, Charset charset) {
-        return buffer.toString(index, length, charset);
+    public int getString(int index, int length, CharBuffer dst, Charset charset) {
+        return buffer.getString(index, length, dst, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -214,9 +215,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index + adjustment, length);
     }
 
-    public String toString(int index, int length, Charset charset) {
+    public int getString(int index, int length, CharBuffer dst, Charset charset) {
         checkIndex(index, length);
-        return buffer.toString(index + adjustment, length, charset);
+        return buffer.getString(index + adjustment, length, dst, charset);
     }
 
     private void checkIndex(int index) {

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.CharBuffer;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -208,9 +209,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public String toString(int index, int length, Charset charset) {
+    public int getString(int index, int length, CharBuffer dst, Charset charset) {
         checkIndex(index, length);
-        return buffer.toString(index, length, charset);
+        return buffer.getString(index, length, dst, charset);
     }
 
     private void checkIndex(int index) {

File: src/test/java/org/jboss/netty/buffer/ReadOnlyChannelBufferTest.java
Patch:
@@ -98,7 +98,7 @@ public void shouldForwardReadCallsBlindly() throws Exception {
 
         expect(buf.toByteBuffer(23, 24)).andReturn(bb);
         expect(buf.toByteBuffers(25, 26)).andReturn(bbs);
-        expect(buf.toString(27, 28, CharsetUtil.UTF_8)).andReturn("29");
+        expect(buf.getString(27, 28, CharsetUtil.UTF_8)).andReturn("29");
         expect(buf.capacity()).andReturn(30);
 
         replay(buf);
@@ -126,7 +126,7 @@ public void shouldForwardReadCallsBlindly() throws Exception {
         assertEquals(102, roBBs[1].capacity());
         assertTrue(roBBs[1].isReadOnly());
 
-        assertEquals("29", roBuf.toString(27, 28, CharsetUtil.UTF_8));
+        assertEquals("29", roBuf.getString(27, 28, CharsetUtil.UTF_8));
         assertEquals(30, roBuf.capacity());
 
         verify(buf);

File: src/main/java/org/jboss/netty/example/securechat/SecureChatClient.java
Patch:
@@ -56,8 +56,8 @@ public static void main(String[] args) throws Exception {
                         Executors.newCachedThreadPool(),
                         Executors.newCachedThreadPool()));
 
-        SecureChatClientHandler handler = new SecureChatClientHandler();
-        bootstrap.setPipelineFactory(new SecureChatPipelineFactory(handler));
+        // Configure the pipeline factory.
+        bootstrap.setPipelineFactory(new SecureChatClientPipelineFactory());
 
         // Start the connection attempt.
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));

File: src/main/java/org/jboss/netty/example/securechat/SecureChatServer.java
Patch:
@@ -39,9 +39,8 @@ public static void main(String[] args) throws Exception {
                         Executors.newCachedThreadPool(),
                         Executors.newCachedThreadPool()));
 
-        SecureChatServerHandler handler = new SecureChatServerHandler();
-
-        bootstrap.setPipelineFactory(new SecureChatPipelineFactory(handler));
+        // Configure the pipeline factory.
+        bootstrap.setPipelineFactory(new SecureChatServerPipelineFactory());
 
         // Bind and start to accept incoming connections.
         bootstrap.bind(new InetSocketAddress(8080));

File: src/main/java/org/jboss/netty/example/telnet/TelnetClient.java
Patch:
@@ -54,8 +54,8 @@ public static void main(String[] args) throws Exception {
                         Executors.newCachedThreadPool(),
                         Executors.newCachedThreadPool()));
 
-        TelnetClientHandler handler = new TelnetClientHandler();
-        bootstrap.setPipelineFactory(new TelnetPipelineFactory(handler));
+        // Configure the pipeline factory.
+        bootstrap.setPipelineFactory(new TelnetClientPipelineFactory());
 
         // Start the connection attempt.
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));

File: src/main/java/org/jboss/netty/example/telnet/TelnetServer.java
Patch:
@@ -38,8 +38,8 @@ public static void main(String[] args) throws Exception {
                         Executors.newCachedThreadPool(),
                         Executors.newCachedThreadPool()));
 
-        TelnetServerHandler handler = new TelnetServerHandler();
-        bootstrap.setPipelineFactory(new TelnetPipelineFactory(handler));
+        // Configure the pipeline factory.
+        bootstrap.setPipelineFactory(new TelnetServerPipelineFactory());
 
         // Bind and start to accept incoming connections.
         bootstrap.bind(new InetSocketAddress(8080));

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -401,7 +401,7 @@ private static boolean read(final SelectionKey key) {
             // the channel is ready to receive.
             remoteAddress = nioChannel.receive(byteBuffer);
             failure = false;
-        } catch (AsynchronousCloseException e) {
+        } catch (ClosedChannelException e) {
             // Can happen, and does not need a user attention.
         } catch (Throwable t) {
             fireExceptionCaught(channel, t);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -758,6 +758,7 @@ public void run() {
                             selector, channel.getRawInterestOps(), channel);
                 }
                 if (future != null) {
+                    channel.setConnected();
                     future.setSuccess();
                 }
             } catch (IOException e) {
@@ -772,7 +773,6 @@ public void run() {
             }
 
             if (!server) {
-                channel.setConnected();
                 if (!((NioClientSocketChannel) channel).boundManually) {
                     fireChannelBound(channel, localAddress);
                 }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -133,8 +133,9 @@ final void setBound() {
     }
 
     final void setConnected() {
-        assert state == ST_OPEN || state == ST_BOUND : "Invalid state: " + state;
-        state = ST_CONNECTED;
+        if (state != ST_CLOSED) {
+            state = ST_CONNECTED;
+        }
     }
 
     @Override

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramPipelineSink.java
Patch:
@@ -116,12 +116,14 @@ public void eventSunk(final ChannelPipeline pipeline, final ChannelEvent e)
     private void close(NioDatagramChannel channel, ChannelFuture future) {
         try {
             channel.getDatagramChannel().socket().close();
-            future.setSuccess();
             if (channel.setClosed()) {
+                future.setSuccess();
                 if (channel.isBound()) {
                     fireChannelUnbound(channel);
                 }
                 fireChannelClosed(channel);
+            } else {
+                future.setSuccess();
             }
         } catch (final Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java
Patch:
@@ -83,9 +83,8 @@ public DefaultCookie(String name, String value) {
 
             // Check prohibited characters.
             switch (c) {
-            case '=':  case ',':  case ';': case ' ':
-            case '\t': case '\r': case '\n': case '\f':
-            case 0x0b: // Vertical tab
+            case '\t': case '\n': case 0x0b: case '\f': case '\r':
+            case ' ':  case ',':  case ';':  case '=':
                 throw new IllegalArgumentException(
                         "name contains one of the following prohibited characters: " +
                         "=,; \\t\\r\\n\\v\\f: " + name);

File: src/main/java/org/jboss/netty/handler/codec/oneone/OneToOneEncoder.java
Patch:
@@ -66,7 +66,7 @@ public void handleDownstream(
         Object encodedMessage = encode(ctx, e.getChannel(), originalMessage);
         if (originalMessage == encodedMessage) {
             ctx.sendDownstream(evt);
-        } else {
+        } else if (encodedMessage != null) {
             write(ctx, e.getFuture(), encodedMessage, e.getRemoteAddress());
         }
     }

File: src/main/java/org/jboss/netty/channel/StaticChannelPipeline.java
Patch:
@@ -70,6 +70,7 @@ public StaticChannelPipeline(ChannelHandler... handlers) {
         for (int i = 0; i < contexts.length; i ++) {
             ChannelHandler h = handlers[i];
             if (h == null) {
+                // FIXME: Should just break the loop on null
                 throw new NullPointerException("handlers[" + i + ']');
             }
 

File: src/main/java/org/jboss/netty/channel/socket/DefaultDatagramChannelConfig.java
Patch:
@@ -70,6 +70,8 @@ public boolean setOption(String key, Object value) {
             setReceiveBufferSize(ConversionUtil.toInt(value));
         } else if (key.equals("sendBufferSize")) {
             setSendBufferSize(ConversionUtil.toInt(value));
+        } else if (key.equals("receiveBufferSizePredictorFactory")) {
+            setReceiveBufferSizePredictorFactory((ReceiveBufferSizePredictorFactory) value);
         } else if (key.equals("receiveBufferSizePredictor")) {
             setReceiveBufferSizePredictor((ReceiveBufferSizePredictor) value);
         } else if (key.equals("reuseAddress")) {

File: src/main/java/org/jboss/netty/buffer/DuplicatedChannelBuffer.java
Patch:
@@ -22,6 +22,7 @@
 import java.nio.ByteOrder;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
+import java.nio.charset.Charset;
 
 
 /**
@@ -180,7 +181,7 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public String toString(int index, int length, String charsetName) {
-        return buffer.toString(index, length, charsetName);
+    public String toString(int index, int length, Charset charset) {
+        return buffer.toString(index, length, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/DynamicChannelBuffer.java
Patch:
@@ -22,6 +22,7 @@
 import java.nio.ByteOrder;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
+import java.nio.charset.Charset;
 
 
 /**
@@ -290,7 +291,7 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public String toString(int index, int length, String charsetName) {
-        return buffer.toString(index, length, charsetName);
+    public String toString(int index, int length, Charset charset) {
+        return buffer.toString(index, length, charset);
     }
 }

File: src/main/java/org/jboss/netty/buffer/ReadOnlyChannelBuffer.java
Patch:
@@ -23,6 +23,7 @@
 import java.nio.ReadOnlyBufferException;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
+import java.nio.charset.Charset;
 
 /**
  * A derived buffer which forbids any write requests to its parent.  It is
@@ -190,8 +191,8 @@ public ByteBuffer[] toByteBuffers(int index, int length) {
         return bufs;
     }
 
-    public String toString(int index, int length, String charsetName) {
-        return buffer.toString(index, length, charsetName);
+    public String toString(int index, int length, Charset charset) {
+        return buffer.toString(index, length, charset);
     }
 
     public int capacity() {

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -22,6 +22,7 @@
 import java.nio.ByteOrder;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
+import java.nio.charset.Charset;
 
 
 /**
@@ -213,9 +214,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index + adjustment, length);
     }
 
-    public String toString(int index, int length, String charsetName) {
+    public String toString(int index, int length, Charset charset) {
         checkIndex(index, length);
-        return buffer.toString(index + adjustment, length, charsetName);
+        return buffer.toString(index + adjustment, length, charset);
     }
 
     private void checkIndex(int index) {

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -22,6 +22,7 @@
 import java.nio.ByteOrder;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
+import java.nio.charset.Charset;
 
 
 /**
@@ -207,9 +208,9 @@ public ByteBuffer toByteBuffer(int index, int length) {
         return buffer.toByteBuffer(index, length);
     }
 
-    public String toString(int index, int length, String charsetName) {
+    public String toString(int index, int length, Charset charset) {
         checkIndex(index, length);
-        return buffer.toString(index, length, charsetName);
+        return buffer.toString(index, length, charset);
     }
 
     private void checkIndex(int index) {

File: src/main/java/org/jboss/netty/channel/group/ChannelGroup.java
Patch:
@@ -41,7 +41,8 @@
  * recipients.add(channelB);
  * ..
  * <strong>recipients.write(ChannelBuffers.copiedBuffer(
- *         "Service will shut down for maintenance in 5 minutes.", "UTF-8"));</strong>
+ *         "Service will shut down for maintenance in 5 minutes.",
+ *         CharsetUtil.UTF_8));</strong>
  * </pre>
  *
  * <h3>Simplify shutdown process with {@link ChannelGroup}</h3>

File: src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -39,6 +39,7 @@
 import org.jboss.netty.handler.codec.http.HttpResponseStatus;
 import org.jboss.netty.handler.codec.http.HttpVersion;
 import org.jboss.netty.handler.stream.ChunkedFile;
+import org.jboss.netty.util.CharsetUtil;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -159,7 +160,8 @@ private void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
         response.setHeader(
                 HttpHeaders.Names.CONTENT_TYPE, "text/plain; charset=UTF-8");
         response.setContent(ChannelBuffers.copiedBuffer(
-                "Failure: " + status.toString() + "\r\n", "UTF-8"));
+                "Failure: " + status.toString() + "\r\n",
+                CharsetUtil.UTF_8));
 
         // Close the connection as soon as the error message is sent.
         ctx.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);

File: src/main/java/org/jboss/netty/example/http/snoop/HttpResponseHandler.java
Patch:
@@ -22,6 +22,7 @@
 import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
 import org.jboss.netty.handler.codec.http.HttpChunk;
 import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.util.CharsetUtil;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -60,7 +61,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
                 ChannelBuffer content = response.getContent();
                 if (content.readable()) {
                     System.out.println("CONTENT {");
-                    System.out.println(content.toString("UTF-8"));
+                    System.out.println(content.toString(CharsetUtil.UTF_8));
                     System.out.println("} END OF CONTENT");
                 }
             }
@@ -70,7 +71,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
                 readingChunks = false;
                 System.out.println("} END OF CHUNKED CONTENT");
             } else {
-                System.out.print(chunk.getContent().toString("UTF-8"));
+                System.out.print(chunk.getContent().toString(CharsetUtil.UTF_8));
                 System.out.flush();
             }
         }

File: src/main/java/org/jboss/netty/example/qotm/QuoteOfTheMomentClient.java
Patch:
@@ -26,6 +26,7 @@
 import org.jboss.netty.channel.socket.oio.OioDatagramChannelFactory;
 import org.jboss.netty.handler.codec.string.StringDecoder;
 import org.jboss.netty.handler.codec.string.StringEncoder;
+import org.jboss.netty.util.CharsetUtil;
 
 /**
  * A UDP broadcast client that asks for a quote of the moment (QOTM) to
@@ -47,8 +48,8 @@ public static void main(String[] args) throws Exception {
 
         // Configure the pipeline.
         ChannelPipeline p = b.getPipeline();
-        p.addLast("encoder", new StringEncoder("UTF-8"));
-        p.addLast("decoder", new StringDecoder("UTF-8"));
+        p.addLast("encoder", new StringEncoder(CharsetUtil.ISO_8859_1));
+        p.addLast("decoder", new StringDecoder(CharsetUtil.ISO_8859_1));
         p.addLast("handler", new QuoteOfTheMomentClientHandler());
 
         // Enable broadcast

File: src/main/java/org/jboss/netty/example/qotm/QuoteOfTheMomentServer.java
Patch:
@@ -25,6 +25,7 @@
 import org.jboss.netty.channel.socket.oio.OioDatagramChannelFactory;
 import org.jboss.netty.handler.codec.string.StringDecoder;
 import org.jboss.netty.handler.codec.string.StringEncoder;
+import org.jboss.netty.util.CharsetUtil;
 
 /**
  * A UDP server that responds to the QOTM (quote of the moment) request to a
@@ -46,8 +47,8 @@ public static void main(String[] args) throws Exception {
 
         // Configure the pipeline.
         ChannelPipeline p = b.getPipeline();
-        p.addLast("encoder", new StringEncoder("UTF-8"));
-        p.addLast("decoder", new StringDecoder("UTF-8"));
+        p.addLast("encoder", new StringEncoder(CharsetUtil.ISO_8859_1));
+        p.addLast("decoder", new StringDecoder(CharsetUtil.ISO_8859_1));
         p.addLast("handler", new QuoteOfTheMomentServerHandler());
 
         // Enable broadcast

File: src/main/java/org/jboss/netty/handler/codec/base64/Base64Decoder.java
Patch:
@@ -25,6 +25,7 @@
 import org.jboss.netty.handler.codec.frame.Delimiters;
 import org.jboss.netty.handler.codec.frame.FrameDecoder;
 import org.jboss.netty.handler.codec.oneone.OneToOneDecoder;
+import org.jboss.netty.util.CharsetUtil;
 
 /**
  * Decodes a Base64-encoded {@link ChannelBuffer} or US-ASCII {@link String}
@@ -69,8 +70,7 @@ public Base64Decoder(Base64Dialect dialect) {
     protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
             throws Exception {
         if (msg instanceof String) {
-            msg = ChannelBuffers.wrappedBuffer(
-                    ((String) msg).getBytes("ASCII"));
+            msg = ChannelBuffers.copiedBuffer((String) msg, CharsetUtil.US_ASCII);
         } else if (!(msg instanceof ChannelBuffer)) {
             return msg;
         }

File: src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java
Patch:
@@ -31,7 +31,7 @@
  * {@link StringDecoder} without setting up the {@link ChannelPipeline} and
  * other mock objects by yourself:
  * <pre>
- * ChannelBuffer base64Data = ChannelBuffer.copiedBuffer("Zm9vYmFy", "ASCII");
+ * ChannelBuffer base64Data = ChannelBuffer.copiedBuffer("Zm9vYmFy", CharsetUtil.US_ASCII);
  *
  * DecoderEmbedder&lt;String&gt; embedder = new DecoderEmbedder&lt;String&gt;(
  *         new Base64Decoder(), new StringDecoder());

File: src/main/java/org/jboss/netty/handler/codec/embedder/EncoderEmbedder.java
Patch:
@@ -39,7 +39,7 @@
  * embedded.offer(data);
  *
  * ChannelBuffer encoded = embedded.poll();
- * assert encoded.toString("ASCII").equals("Zm9vYmFy");
+ * assert encoded.toString(CharsetUtil.US_ASCII).equals("Zm9vYmFy");
  * </pre>
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -20,8 +20,8 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
@@ -89,7 +89,7 @@ public DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> f
 
         this.group = group;
 
-        Map<Integer, ChannelFuture> futureMap = new HashMap<Integer, ChannelFuture>();
+        Map<Integer, ChannelFuture> futureMap = new LinkedHashMap<Integer, ChannelFuture>();
         for (ChannelFuture f: futures) {
             futureMap.put(f.getChannel().getId(), f);
         }

File: src/main/java/org/jboss/netty/handler/codec/compression/package-info.java
Patch:
@@ -15,7 +15,7 @@
  */
 
 /**
- * Encoder and decoder which compresses and decompresses {@link ChannelBuffer}s
+ * Encoder and decoder which compresses and decompresses {@link org.jboss.netty.buffer.ChannelBuffer}s
  * in a compression format such as <a href="http://en.wikipedia.org/wiki/Zlib">zlib</a>
  * and <a href="http://en.wikipedia.org/wiki/Gzip">gzip</a>.
  *

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java
Patch:
@@ -183,7 +183,7 @@ public void operationComplete(ChannelFuture f) {
 
                         SslHandler sslHandler = new SslHandler(engine);
                         realChannel.getPipeline().addFirst("ssl", sslHandler);
-                        sslHandshakeFuture = sslHandler.handshake(realChannel);
+                        sslHandshakeFuture = sslHandler.handshake();
                     }
 
                     // Send the HTTP request.

File: src/main/java/org/jboss/netty/example/securechat/SecureChatClientHandler.java
Patch:
@@ -58,7 +58,7 @@ public void channelConnected(
         SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
 
         // Begin handshake.
-        sslHandler.handshake(e.getChannel());
+        sslHandler.handshake();
     }
 
     @Override

File: src/main/java/org/jboss/netty/example/securechat/SecureChatServerHandler.java
Patch:
@@ -69,7 +69,7 @@ public void channelConnected(
         final SslHandler sslHandler = ctx.getPipeline().get(SslHandler.class);
 
         // Get notified when SSL handshake is done.
-        ChannelFuture handshakeFuture = sslHandler.handshake(e.getChannel());
+        ChannelFuture handshakeFuture = sslHandler.handshake();
         handshakeFuture.addListener(new Greeter(sslHandler));
     }
 

File: src/test/java/org/jboss/netty/handler/ssl/AbstractSocketSslEchoTest.java
Patch:
@@ -130,7 +130,7 @@ public void testSslEcho() throws Throwable {
         assertTrue(ccf.isSuccess());
 
         Channel cc = ccf.getChannel();
-        ChannelFuture hf = cc.getPipeline().get(SslHandler.class).handshake(cc);
+        ChannelFuture hf = cc.getPipeline().get(SslHandler.class).handshake();
         hf.awaitUninterruptibly();
         if (!hf.isSuccess()) {
             logger.error("Handshake failed", hf.getCause());

File: src/main/java/org/jboss/netty/handler/queue/BufferedWriteHandler.java
Patch:
@@ -103,9 +103,9 @@ public BufferedWriteHandler() {
     }
 
     /**
-     * Creates a new instance with the specified unbounded {@link Queue}.
-     * Please note that specifying a bounded {@link Queue} might result in
-     * an unspecified behavior.
+     * Creates a new instance with the specified thread-safe unbounded
+     * {@link Queue}.  Please note that specifying a bounded {@link Queue} or
+     * a thread-unsafe {@link Queue} will result in an unspecified behavior.
      */
     public BufferedWriteHandler(Queue<MessageEvent> queue) {
         if (queue == null) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.nio.channels.Selector;
 import java.nio.channels.ServerSocketChannel;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
@@ -49,6 +50,7 @@ class NioServerSocketChannel extends AbstractServerChannel
 
     final ServerSocketChannel socket;
     final Lock shutdownLock = new ReentrantLock();
+    volatile Selector selector;
     private final ServerSocketChannelConfig config;
 
     NioServerSocketChannel(

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannel.java
Patch:
@@ -20,6 +20,8 @@
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.nio.channels.ServerSocketChannel;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 import org.jboss.netty.channel.AbstractServerChannel;
 import org.jboss.netty.channel.ChannelException;
@@ -46,6 +48,7 @@ class NioServerSocketChannel extends AbstractServerChannel
         InternalLoggerFactory.getInstance(NioServerSocketChannel.class);
 
     final ServerSocketChannel socket;
+    final Lock shutdownLock = new ReentrantLock();
     private final ServerSocketChannelConfig config;
 
     NioServerSocketChannel(

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketChannel.java
Patch:
@@ -20,6 +20,8 @@
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.ServerSocket;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 import org.jboss.netty.channel.AbstractServerChannel;
 import org.jboss.netty.channel.ChannelException;
@@ -47,6 +49,7 @@ class OioServerSocketChannel extends AbstractServerChannel
         InternalLoggerFactory.getInstance(OioServerSocketChannel.class);
 
     final ServerSocket socket;
+    final Lock shutdownLock = new ReentrantLock();
     private final ServerSocketChannelConfig config;
 
     OioServerSocketChannel(

File: src/main/java/org/jboss/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java
Patch:
@@ -66,8 +66,8 @@ public class DelimiterBasedFrameDecoder extends FrameDecoder {
     private final ChannelBuffer[] delimiters;
     private final int maxFrameLength;
     private final boolean stripDelimiter;
-    private volatile boolean discardingTooLongFrame;
-    private volatile long tooLongFrameLength;
+    private boolean discardingTooLongFrame;
+    private long tooLongFrameLength;
 
     /**
      * Creates a new instance.

File: src/main/java/org/jboss/netty/handler/codec/frame/LengthFieldBasedFrameDecoder.java
Patch:
@@ -192,9 +192,9 @@ public class LengthFieldBasedFrameDecoder extends FrameDecoder {
     private final int lengthFieldEndOffset;
     private final int lengthAdjustment;
     private final int initialBytesToStrip;
-    private volatile boolean discardingTooLongFrame;
-    private volatile long tooLongFrameLength;
-    private volatile long bytesToDiscard;
+    private boolean discardingTooLongFrame;
+    private long tooLongFrameLength;
+    private long bytesToDiscard;
 
     /**
      * Creates a new instance.

File: src/main/java/org/jboss/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java
Patch:
@@ -179,12 +179,12 @@ protected Object decode(
             }
 
             if (stripDelimiter) {
-                frame = buffer.readBytes(minFrameLength);
-                buffer.skipBytes(minDelimLength);
+                frame = buffer.slice(buffer.readerIndex(), minFrameLength);
             } else {
-                frame = buffer.readBytes(minFrameLength + minDelimLength);
+                frame = buffer.slice(buffer.readerIndex(), minFrameLength + minDelimLength);
             }
 
+            buffer.skipBytes(minFrameLength + minDelimLength);
             return frame;
         } else {
             if (buffer.readableBytes() > maxFrameLength) {

File: src/main/java/org/jboss/netty/handler/codec/frame/FixedLengthFrameDecoder.java
Patch:
@@ -63,7 +63,9 @@ protected Object decode(
         if (buffer.readableBytes() < frameLength) {
             return null;
         } else {
-            return buffer.readBytes(frameLength);
+            ChannelBuffer frame = buffer.slice(buffer.readerIndex(), frameLength);
+            buffer.skipBytes(frameLength);
+            return frame;
         }
     }
 }

File: src/test/java/org/jboss/netty/handler/codec/frame/AbstractSocketFixedLengthEchoTest.java
Patch:
@@ -97,7 +97,7 @@ public void testFixedLengthEcho() throws Throwable {
 
         Channel cc = ccf.getChannel();
         for (int i = 0; i < data.length;) {
-            int length = Math.min(random.nextInt(1024 * 64), data.length - i);
+            int length = Math.min(random.nextInt(1024 * 3), data.length - i);
             cc.write(ChannelBuffers.wrappedBuffer(data, i, length));
             i += length;
         }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -81,7 +81,7 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)
 
         if (msg instanceof HttpChunk) {
             HttpChunk chunk = (HttpChunk) msg;
-            if (chunk.isLast()) {
+            if (chunk == HttpChunk.LAST_CHUNK) {
                 return LAST_CHUNK.duplicate();
             } else {
                 ChannelBuffer content = chunk.getContent();

File: src/main/java/org/jboss/netty/handler/codec/http/HttpChunkAggregator.java
Patch:
@@ -89,6 +89,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             if (m.isChunked()) {
                 // A chunked message - remove 'Transfer-Encoding' header,
                 // initialize the cumulative buffer, and wait for incoming chunks.
+                // TODO Add HttpMessage/HttpChunkTrailer.removeHeader(name, value)
                 List<String> encodings = m.getHeaders(HttpHeaders.Names.TRANSFER_ENCODING);
                 encodings.remove(HttpHeaders.Values.CHUNKED);
                 if (encodings.isEmpty()) {

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingServlet.java
Patch:
@@ -222,7 +222,7 @@ private static ChannelBuffer read(PushbackInputStream in) throws IOException {
     }
 
     @ChannelPipelineCoverage("one")
-    private final class OutboundConnectionHandler extends SimpleChannelUpstreamHandler {
+    private static final class OutboundConnectionHandler extends SimpleChannelUpstreamHandler {
 
         private final ServletOutputStream out;
 

File: src/main/java/org/jboss/netty/example/proxy/HexDumpProxyInboundHandler.java
Patch:
@@ -103,7 +103,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
     }
 
     @ChannelPipelineCoverage("one")
-    private class OutboundHandler extends SimpleChannelUpstreamHandler {
+    private static class OutboundHandler extends SimpleChannelUpstreamHandler {
 
         private final Channel inboundChannel;
 

File: src/main/java/org/jboss/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -241,7 +241,7 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, final Channe
             if (evt != null) {
                 ctx.sendDownstream(evt);
             }
-            return Channels.succeededFuture(evt.getChannel());
+            return Channels.succeededFuture(ctx.getChannel());
         }
 
         ChannelBuffer footer;

File: src/main/java/org/jboss/netty/handler/codec/http/HttpContentEncoder.java
Patch:
@@ -77,7 +77,8 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
         if (acceptedEncoding == null) {
             acceptedEncoding = HttpHeaders.Values.IDENTITY;
         }
-        acceptEncodingQueue.offer(acceptedEncoding);
+        boolean offered = acceptEncodingQueue.offer(acceptedEncoding);
+        assert offered;
 
         ctx.sendUpstream(e);
     }

File: src/main/java/org/jboss/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -91,7 +91,9 @@ public void handleDownstream(ChannelHandlerContext ctx, ChannelEvent e)
             return;
         }
 
-        queue.offer((MessageEvent) e);
+        boolean offered = queue.offer((MessageEvent) e);
+        assert offered;
+
         if (ctx.getChannel().isWritable()) {
             flush(ctx);
         }

File: src/main/java/org/jboss/netty/util/internal/jzlib/InfBlocks.java
Patch:
@@ -566,7 +566,6 @@ int proc(ZStream z, int r) {
                 write = q;
                 r = inflate_flush(z, r);
                 q = write;
-                m = q < read? read - q - 1 : end - q;
                 if (read != write) {
                     bitb = b;
                     bitk = k;

File: src/main/java/org/jboss/netty/util/internal/jzlib/InfCodes.java
Patch:
@@ -409,7 +409,6 @@ int proc(InfBlocks s, ZStream z, int r) {
                 s.write = q;
                 r = s.inflate_flush(z, r);
                 q = s.write;
-                m = q < s.read? s.read - q - 1 : s.end - q;
 
                 if (s.read != s.write) {
                     s.bitb = b;

File: src/main/java/org/jboss/netty/util/internal/jzlib/Inflate.java
Patch:
@@ -252,7 +252,6 @@ int inflate(ZStream z, int f) {
                 if (z.avail_in == 0) {
                     return r;
                 }
-                r = f;
 
                 z.avail_in --;
                 z.total_in ++;

File: src/main/java/org/jboss/netty/util/internal/jzlib/ZStream.java
Patch:
@@ -63,7 +63,6 @@ public final class ZStream {
     public String msg;
     Deflate dstate;
     Inflate istate;
-    int data_type; // best guess about the data type: ascii or binary
     long adler;
     int crc32;
 

File: src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java
Patch:
@@ -49,7 +49,7 @@
  * @apiviz.landmark
  * @see EncoderEmbedder
  */
-public class DecoderEmbedder<T> extends AbstractCodecEmbedder<T> {
+public class DecoderEmbedder<E> extends AbstractCodecEmbedder<E> {
 
     /**
      * Creates a new embedder whose pipeline is composed of the specified

File: src/main/java/org/jboss/netty/handler/codec/embedder/EncoderEmbedder.java
Patch:
@@ -49,7 +49,7 @@
  * @apiviz.landmark
  * @see DecoderEmbedder
  */
-public class EncoderEmbedder<T> extends AbstractCodecEmbedder<T> {
+public class EncoderEmbedder<E> extends AbstractCodecEmbedder<E> {
 
     /**
      * Creates a new embedder whose pipeline is composed of the specified

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -361,7 +361,7 @@ private void processSelectedKeys(final Set<SelectionKey> selectedKeys) throws IO
     }
 
     private boolean cleanUpCancelledKeys() throws IOException {
-        if (cancelledKeys >= 128) { // FIXME hardcoded value
+        if (cancelledKeys >= NioWorker.CLEANUP_INTERVAL) {
             cancelledKeys = 0;
             selector.selectNow();
             return true;

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -65,6 +65,8 @@ class NioWorker implements Runnable {
 
     private static final int CONSTRAINT_LEVEL = NioProviderMetadata.CONSTRAINT_LEVEL;
 
+    static final int CLEANUP_INTERVAL = 256; // XXX Hard-coded value, but won't need customization.
+
     private final int bossId;
     private final int id;
     private final Executor executor;
@@ -292,7 +294,7 @@ private void processSelectedKeys(Set<SelectionKey> selectedKeys) throws IOExcept
     }
 
     private boolean cleanUpCancelledKeys() throws IOException {
-        if (cancelledKeys >= 128) { // FIXME hardcoded value
+        if (cancelledKeys >= CLEANUP_INTERVAL) {
             cancelledKeys = 0;
             selector.selectNow();
             return true;

File: src/main/java/org/jboss/netty/util/HashedWheelTimer.java
Patch:
@@ -61,9 +61,9 @@
  * <h3>Implementation Details</h3>
  *
  * {@link HashedWheelTimer} is based on
- * <a href="http://cseweb.ucsd.edu/users/varghese/>George Varghese</a> and
+ * <a href="http://cseweb.ucsd.edu/users/varghese/">George Varghese</a> and
  * Tony Lauck's paper,
- * <a href="http://www-cse.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z">'Hashed
+ * <a href="http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z">'Hashed
  * and Hierarchical Timing Wheels: data structures to efficiently implement a
  * timer facility'</a>.  More comprehensive slides are located
  * <a href="http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">here</a>.

File: src/main/java/org/jboss/netty/channel/AdaptiveReceiveBufferSizePredictor.java
Patch:
@@ -37,6 +37,9 @@
 public class AdaptiveReceiveBufferSizePredictor implements
         ReceiveBufferSizePredictor {
 
+    // FIXME There's no easy way to configure receiveBufferSizePredictor
+    //       via Bootstrap.setOption() because it works for only one channel.
+
     private static final int INDEX_INCREMENT = 4;
     private static final int INDEX_DECREMENT = 1;
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -339,7 +339,7 @@ private static void processSelectedKeys(final Set<SelectionKey> selectedKeys) {
             i.remove();
             try {
                 int readyOps = k.readyOps();
-                if ((readyOps & SelectionKey.OP_READ) != 0) {
+                if ((readyOps & SelectionKey.OP_READ) != 0 || readyOps == 0) {
                     if (!read(k)) {
                         // Connection already closed - no need to handle write.
                         continue;

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -271,7 +271,7 @@ private static void processSelectedKeys(Set<SelectionKey> selectedKeys) {
             i.remove();
             try {
                 int readyOps = k.readyOps();
-                if ((readyOps & SelectionKey.OP_READ) != 0) {
+                if ((readyOps & SelectionKey.OP_READ) != 0 || readyOps == 0) {
                     if (!read(k)) {
                         // Connection already closed - no need to handle write.
                         continue;

File: src/main/java/org/jboss/netty/util/internal/jzlib/Inflate.java
Patch:
@@ -429,7 +429,7 @@ int inflate(ZStream z, int f) {
                         r = f;
                         z.avail_in --;
                         z.total_in ++;
-                        gzipXLen = gzipXLen << 8 | z.next_in[z.next_in_index ++] & 0xff;
+                        gzipXLen |= (z.next_in[z.next_in_index ++] & 0xff) << (1 - gzipBytesToRead) * 8;
                         gzipBytesToRead --;
                     }
                     gzipBytesToRead = gzipXLen;

File: src/main/java/org/jboss/netty/util/internal/jzlib/Inflate.java
Patch:
@@ -499,7 +499,7 @@ int inflate(ZStream z, int f) {
                     z.avail_in --;
                     z.total_in ++;
                     gzipBytesToRead --;
-                    z.istate.gzipCRC32 = z.istate.gzipCRC32 << 8 | z.next_in[z.next_in_index ++] & 0xff;
+                    z.istate.gzipCRC32 |= (z.next_in[z.next_in_index ++] & 0xff) << (3 - gzipBytesToRead) * 8;
                 }
 
                 if (z.crc32 != z.istate.gzipCRC32) {
@@ -519,7 +519,7 @@ int inflate(ZStream z, int f) {
                     z.avail_in --;
                     z.total_in ++;
                     gzipBytesToRead --;
-                    z.istate.gzipISize = z.istate.gzipISize << 8 | z.next_in[z.next_in_index ++] & 0xff;
+                    z.istate.gzipISize |= (z.next_in[z.next_in_index ++] & 0xff) << (3 - gzipBytesToRead) * 8;
                 }
 
                 if (gzipUncompressedBytes != z.istate.gzipISize) {

File: src/main/java/org/jboss/netty/util/internal/jzlib/Inflate.java
Patch:
@@ -459,7 +459,7 @@ int inflate(ZStream z, int f) {
                         r = f;
                         z.avail_in --;
                         z.total_in ++;
-                    } while (z.next_in[z.next_in_index ++] == 0);
+                    } while (z.next_in[z.next_in_index ++] != 0);
                 }
                 z.istate.mode = GZIP_FCOMMENT;
             case GZIP_FCOMMENT:
@@ -471,7 +471,7 @@ int inflate(ZStream z, int f) {
                         r = f;
                         z.avail_in --;
                         z.total_in ++;
-                    } while (z.next_in[z.next_in_index ++] == 0);
+                    } while (z.next_in[z.next_in_index ++] != 0);
                 }
                 gzipBytesToRead = 2;
                 z.istate.mode = GZIP_FHCRC;

File: src/main/java/org/jboss/netty/handler/codec/compression/ZlibEncoder.java
Patch:
@@ -76,7 +76,7 @@ public ZlibEncoder(int compressionLevel) {
         }
 
         synchronized (z) {
-            int resultCode = z.deflateInit(compressionLevel, false); // Default: ZLIB format
+            int resultCode = z.deflateInit(compressionLevel, JZlib.W_ZLIB); // Default: ZLIB format
             if (resultCode != JZlib.Z_OK) {
                 ZlibUtil.fail(z, "initialization failure", resultCode);
             }
@@ -118,7 +118,7 @@ public ZlibEncoder(int compressionLevel, byte[] dictionary) {
 
         synchronized (z) {
             int resultCode;
-            resultCode = z.deflateInit(compressionLevel, false); // Default: ZLIB format
+            resultCode = z.deflateInit(compressionLevel, JZlib.W_ZLIB); // Default: ZLIB format
             if (resultCode != JZlib.Z_OK) {
                 ZlibUtil.fail(z, "initialization failure", resultCode);
             } else {

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -306,6 +306,7 @@ public SSLEngine getEngine() {
      *         succeeds or fails.
      */
     public ChannelFuture handshake(Channel channel) throws SSLException {
+        // FIXME do not throw SSLException - return a failed future.
         ChannelFuture handshakeFuture;
         synchronized (handshakeLock) {
             if (handshaking) {
@@ -327,13 +328,14 @@ public ChannelFuture handshake(Channel channel) throws SSLException {
      * destroys the underlying {@link SSLEngine}.
      */
     public ChannelFuture close(Channel channel) throws SSLException {
+        // FIXME do not throw SSLException - return a failed future.
         ChannelHandlerContext ctx = context(channel);
         engine.closeOutbound();
         return wrapNonAppData(ctx, channel);
     }
 
     private ChannelHandlerContext context(Channel channel) {
-        return channel.getPipeline().getContext(getClass());
+        return channel.getPipeline().getContext(this);
     }
 
     public void handleDownstream(

File: src/main/java/org/jboss/netty/handler/codec/compression/ZlibDecoder.java
Patch:
@@ -75,6 +75,8 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
                 // Decompress 'in' into 'out'
                 int resultCode = z.inflate(JZlib.Z_SYNC_FLUSH);
                 switch (resultCode) {
+                case JZlib.Z_STREAM_END:
+                    // TODO: Remove myself from the pipeline
                 case JZlib.Z_OK:
                 case JZlib.Z_BUF_ERROR:
                     decompressed.writeBytes(out, 0, z.next_out_index);

File: src/main/java/org/jboss/netty/handler/codec/base64/Base64.java
Patch:
@@ -167,6 +167,7 @@ public static ChannelBuffer encode(
 
         int len43 = len * 4 / 3;
         ChannelBuffer dest = bufferFactory.getBuffer(
+                src.order(),
                 len43 +
                 (len % 3 > 0? 4 : 0) + // Account for padding
                 (breakLines? len43 / MAX_LINE_LENGTH : 0)); // New lines
@@ -292,7 +293,7 @@ public static ChannelBuffer decode(
         byte[] DECODABET = decodabet(dialect);
 
         int len34 = len * 3 / 4;
-        ChannelBuffer dest = bufferFactory.getBuffer(len34); // Upper limit on size of output
+        ChannelBuffer dest = bufferFactory.getBuffer(src.order(), len34); // Upper limit on size of output
         int outBuffPosn = 0;
 
         byte[] b4 = new byte[4];

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -285,8 +285,8 @@ public static ChannelBuffer wrappedBuffer(ByteOrder endianness, byte[] array, in
 
     /**
      * Creates a new buffer which wraps the specified NIO buffer's current
-     * slice.  A modification on the specified buffer's content and endianness
-     * will be visible to the returned buffer.
+     * slice.  A modification on the specified buffer's content will be
+     * visible to the returned buffer.
      */
     public static ChannelBuffer wrappedBuffer(ByteBuffer buffer) {
         if (!buffer.hasRemaining()) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -542,7 +542,6 @@ private static void writeNow(final NioDatagramChannel channel,
                     channel.currentWriteEvent = evt;
                 } catch (final Throwable t) {
                     channel.currentWriteEvent = null;
-                    channel.inWriteNowLoop = false;
                     evt.getFuture().setFailure(t);
                     evt = null;
                     fireExceptionCaught(channel, t);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -540,8 +540,10 @@ private static void writeNow(final NioDatagramChannel channel,
                 } catch (final AsynchronousCloseException e) {
                     // Doesn't need a user attention - ignore.
                     channel.currentWriteEvent = evt;
+                    channel.inWriteNowLoop = false;
                 } catch (final Throwable t) {
                     channel.currentWriteEvent = null;
+                    channel.inWriteNowLoop = false;
                     evt.getFuture().setFailure(t);
                     evt = null;
                     fireExceptionCaught(channel, t);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -451,12 +451,14 @@ private static void writeNow(NioSocketChannel channel, int writeSpinCount) {
                     // Doesn't need a user attention - ignore.
                     channel.currentWriteEvent = evt;
                     channel.currentWriteIndex = bufIdx;
+                    channel.inWriteNowLoop = false;
 
                     // But we still need to clean up the pending writes.
                     cleanUpWriteBuffer(channel, e);
                     break;
                 } catch (Throwable t) {
                     channel.currentWriteEvent = null;
+                    channel.inWriteNowLoop = false;
                     evt.getFuture().setFailure(t);
                     evt = null;
                     fireExceptionCaught(channel, t);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -448,11 +448,12 @@ private static void writeNow(NioSocketChannel channel, int writeSpinCount) {
                         break;
                     }
                 } catch (ClosedChannelException e) {
-                    cleanUpWriteBuffer(channel);
-
                     // Doesn't need a user attention - ignore.
                     channel.currentWriteEvent = evt;
                     channel.currentWriteIndex = bufIdx;
+
+                    // But we still need to clean up the pending writes.
+                    cleanUpWriteBuffer(channel);
                 } catch (Throwable t) {
                     channel.currentWriteEvent = null;
                     evt.getFuture().setFailure(t);

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -686,8 +686,8 @@ public void operationComplete(ChannelFuture future)
 
                 switch (result.getHandshakeStatus()) {
                 case FINISHED:
-                    runDelegatedTasks();
                     setHandshakeSuccess(channel);
+                    runDelegatedTasks();
                     break;
                 case NEED_TASK:
                     runDelegatedTasks();

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -686,8 +686,8 @@ public void operationComplete(ChannelFuture future)
 
                 switch (result.getHandshakeStatus()) {
                 case FINISHED:
-                    setHandshakeSuccess(channel);
                     runDelegatedTasks();
+                    setHandshakeSuccess(channel);
                     break;
                 case NEED_TASK:
                     runDelegatedTasks();

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -293,7 +293,7 @@ public static ChannelBuffer wrappedBuffer(ByteBuffer buffer) {
             return EMPTY_BUFFER;
         }
         if (!buffer.isReadOnly() && buffer.hasArray()) {
-            return wrappedBuffer(buffer.array(), buffer.arrayOffset(),buffer.remaining());
+            return wrappedBuffer(buffer.order(), buffer.array(), buffer.arrayOffset(),buffer.remaining());
         } else {
             return new ByteBufferBackedChannelBuffer(buffer);
         }

File: src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -81,8 +81,7 @@ public Set<Cookie> decode(String header) {
             // An exceptional case:
             // 'Expires' attribute can contain a comma without surrounded with quotes.
             if (name.equalsIgnoreCase(CookieHeaderNames.EXPIRES) &&
-                value.length() <= 3) {
-                // value contains comma, but not surrounded with quotes.
+                value.length() <= 9) { // Longest day of week is 'Wednesday'.
                 if (m.find(pos)) {
                     value = value + ", " + m.group(1);
                     pos = m.end();

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -112,8 +112,8 @@ protected enum State {
 
     /**
      * Creates a new instance with the default
-     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (4096)}, and
-     * {@code maxChunkSize (4096)}.
+     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and
+     * {@code maxChunkSize (8192)}.
      */
     protected HttpMessageDecoder() {
         this(4096, 8192, 8192);

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateAwareChannelHandler.java
Patch:
@@ -52,7 +52,7 @@ public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)
     /**
      * Invoked when a {@link Channel} has been idle for a while.
      */
-    public void channelIdle(ChannelHandlerContext ctx, IdleStateEvent e) {
+    public void channelIdle(ChannelHandlerContext ctx, IdleStateEvent e) throws Exception {
         ctx.sendUpstream(e);
     }
 }

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateAwareChannelUpstreamHandler.java
Patch:
@@ -52,7 +52,7 @@ public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)
     /**
      * Invoked when a {@link Channel} has been idle for a while.
      */
-    public void channelIdle(ChannelHandlerContext ctx, IdleStateEvent e) {
+    public void channelIdle(ChannelHandlerContext ctx, IdleStateEvent e) throws Exception {
         ctx.sendUpstream(e);
     }
 }

File: src/main/java/org/jboss/netty/channel/SimpleChannelHandler.java
Patch:
@@ -134,7 +134,7 @@ public void handleUpstream(
                 channelInterestChanged(ctx, evt);
                 break;
             default:
-                ctx.sendDownstream(e);
+                ctx.sendUpstream(e);
             }
         } else if (e instanceof ExceptionEvent) {
             exceptionCaught(ctx, (ExceptionEvent) e);

File: src/main/java/org/jboss/netty/channel/SimpleChannelUpstreamHandler.java
Patch:
@@ -116,7 +116,7 @@ public void handleUpstream(
                 channelInterestChanged(ctx, evt);
                 break;
             default:
-                ctx.sendDownstream(e);
+                ctx.sendUpstream(e);
             }
         } else if (e instanceof ExceptionEvent) {
             exceptionCaught(ctx, (ExceptionEvent) e);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -165,7 +165,7 @@ void register(final NioDatagramChannel channel, final ChannelFuture future) {
                 try {
                     // Start the main selector loop. See run() for details.
                     executor.execute(new ThreadRenamingRunnable(this,
-                            "New I/O server worker #" + bossId + "'-'" + id));
+                            "New I/O datagram worker #" + bossId + "'-'" + id));
                     success = true;
                 } finally {
                     if (!success) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramWorker.java
Patch:
@@ -539,7 +539,9 @@ private static void writeNow(final NioDatagramChannel channel,
                     }
                 } catch (final AsynchronousCloseException e) {
                     // Doesn't need a user attention - ignore.
+                    channel.currentWriteEvent = evt;
                 } catch (final Throwable t) {
+                    channel.currentWriteEvent = null;
                     evt.getFuture().setFailure(t);
                     evt = null;
                     fireExceptionCaught(channel, t);

File: src/main/java/org/jboss/netty/channel/Channel.java
Patch:
@@ -321,7 +321,7 @@ public interface Channel extends Comparable<Channel> {
      * ready to process the queued write requests.  This method is a shortcut
      * to the following code:
      * <pre>
-     * return (getInterestOps() & OP_WRITE) != 0;
+     * return (getInterestOps() & OP_WRITE) == 0;
      * </pre>
      */
     boolean isWritable();

File: src/main/java/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
Patch:
@@ -39,6 +39,8 @@ final class CookieHeaderNames {
 
     static final String SECURE = "Secure";
 
+    static final String HTTPONLY = "HTTPOnly";
+
     static final String COMMENT = "Comment";
 
     static final String COMMENTURL = "CommentURL";

File: src/main/java/org/jboss/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -138,9 +138,9 @@ private String encodeServerSide() {
                 }
             }
             if (cookie.isSecure()) {
-                    sb.append(CookieHeaderNames.SECURE);
-                    sb.append((char) HttpCodecUtil.SEMICOLON);
-                }
+                sb.append(CookieHeaderNames.SECURE);
+                sb.append((char) HttpCodecUtil.SEMICOLON);
+            }
             if (cookie.getVersion() >= 1) {
                 if (cookie.getComment() != null) {
                     add(sb, CookieHeaderNames.COMMENT, cookie.getComment());

File: src/main/java/org/jboss/netty/handler/stream/ChunkedWriteHandler.java
Patch:
@@ -139,11 +139,13 @@ private synchronized void flushWriteEventQueue(ChannelHandlerContext ctx) throws
                 } catch (Throwable t) {
                     currentEvent.getFuture().setFailure(t);
                     fireExceptionCaught(ctx, t);
+
                     try {
                         chunks.close();
                     } catch (Throwable t2) {
                         logger.warn("Failed to close a chunked input.", t2);
                     }
+                    currentEvent = null;
                     break;
                 }
 

File: src/main/java/org/jboss/netty/channel/DefaultChannelConfig.java
Patch:
@@ -29,6 +29,7 @@
 import org.jboss.netty.buffer.HeapChannelBufferFactory;
 import org.jboss.netty.channel.socket.SocketChannelConfig;
 import org.jboss.netty.handler.timeout.WriteTimeoutHandler;
+import org.jboss.netty.util.internal.ConversionUtil;
 
 /**
  * The default {@link SocketChannelConfig} implementation.
@@ -60,6 +61,8 @@ public void setOptions(Map<String, Object> options) {
     public boolean setOption(String key, Object value) {
         if (key.equals("pipelineFactory")) {
             setPipelineFactory((ChannelPipelineFactory) value);
+        } else if (key.equals("connectTimeoutMillis")) {
+            setConnectTimeoutMillis(ConversionUtil.toInt(value));
         } else if (key.equals("bufferFactory")) {
             setBufferFactory((ChannelBufferFactory) value);
         } else {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannel.java
Patch:
@@ -80,6 +80,9 @@ private static SocketChannel newSocket() {
     volatile ChannelFuture connectFuture;
     volatile boolean boundManually;
 
+    // Does not need to be volatile as it's accessed by only one thread.
+    long connectDeadlineNanos;
+
     NioClientSocketChannel(
             ChannelFactory factory, ChannelPipeline pipeline,
             ChannelSink sink, NioWorker worker) {

File: src/main/java/org/jboss/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -75,6 +75,7 @@ final class OioDatagramChannel extends AbstractChannel
 
         try {
             socket.setSoTimeout(10);
+            socket.setBroadcast(false);
         } catch (SocketException e) {
             throw new ChannelException(
                     "Failed to configure the datagram socket timeout.", e);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -379,8 +379,7 @@ public void run() {
                 channel.socket.register(
                         boss.selector, SelectionKey.OP_CONNECT, channel);
             } catch (ClosedChannelException e) {
-                throw new ChannelException(
-                        "Failed to register a socket to the selector.", e);
+                NioWorker.close(channel, succeededFuture(channel));
             }
         }
     }

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java
Patch:
@@ -257,6 +257,9 @@ void writeReal(final ChannelBuffer a, final ChannelFuture future) {
             public void operationComplete(ChannelFuture f) {
                 if (f.isSuccess()) {
                     future.setSuccess();
+                    if (size != 0) {
+                        fireWriteComplete(HttpTunnelingClientSocketChannel.this, size);
+                    }
                 } else {
                     future.setFailure(f.getCause());
                 }

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java
Patch:
@@ -220,6 +220,8 @@ public void operationComplete(ChannelFuture f) {
                         sslHandshakeFuture.addListener(new ChannelFutureListener() {
                             public void operationComplete(ChannelFuture f) {
                                 if (f.isSuccess()) {
+                                    realChannel.write(req);
+                                    requestHeaderWritten = true;
                                     future.setSuccess();
                                     fireChannelConnected(virtualChannel, remoteAddress);
                                 } else {

File: src/main/java/org/jboss/netty/channel/socket/DefaultServerSocketChannelConfig.java
Patch:
@@ -112,7 +112,7 @@ public int getBacklog() {
     }
 
     public void setBacklog(int backlog) {
-        if (backlog < 1) {
+        if (backlog < 0) {
             throw new IllegalArgumentException("backlog: " + backlog);
         }
         this.backlog = backlog;

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalChannel.java
Patch:
@@ -114,7 +114,7 @@ void closeNow(ChannelFuture future) {
             fireChannelClosed(pairedChannel);
         } finally {
             future.setSuccess();
-            if (localAddress != null) {
+            if (localAddress != null && getParent() == null) {
                 LocalChannelRegistry.unregister(localAddress);
             }
         }

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingChannelHandler.java
Patch:
@@ -134,7 +134,7 @@ public synchronized void messageReceived(ChannelHandlerContext ctx, MessageEvent
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
-        logger.warn("Unexpected exception", e.getCause());
+        logger.warn("Unexpected exception while HTTP tunneling", e.getCause());
         invalidateHttpSession();
         e.getChannel().close();
     }

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java
Patch:
@@ -278,7 +278,9 @@ else if (line.equals("")) {
 
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
-            logger.warn("Unexpected exception", e.getCause());
+            fireExceptionCaught(
+                    HttpTunnelingClientSocketChannel.this,
+                    e.getCause());
             channel.close();
         }
     }

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalChannel.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalClientChannelFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalServerChannel.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalServerChannelFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalAddress.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalChannel.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannel.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelAddress.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingChannelHandler.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingContextListener.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingServlet.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingSessionListener.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/xnio/AbstractXnioChannelHandler.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/channel/xnio/XnioClientChannelHandler.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServer.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerPipelineFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/snoop/HttpClient.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/snoop/HttpClientPipelineFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/snoop/HttpRequestHandler.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/snoop/HttpResponseHandler.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/snoop/HttpServer.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/snoop/HttpServerPipelineFactory.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/tunnel/HttpTunnelingClientExample.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/http/tunnel/LocalTransportRegister.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/example/local/LocalExample.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/Cookie.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpRequest.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpResponse.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCodecUtil.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessage.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMethod.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequest.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponse.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseEncoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseStatus.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/HttpVersion.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/util/internal/CaseIgnoringComparator.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/test/java/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/test/java/org/jboss/netty/handler/codec/http/CookieEncoderTest.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/test/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderTest.java
Patch:
@@ -1,7 +1,8 @@
 /*
  * JBoss, Home of Professional Open Source
- * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors
- * by the @authors tag. See the copyright.txt in the distribution for a
+ *
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
+ * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it

File: src/main/java/org/jboss/netty/handler/codec/serialization/CompactObjectInputStream.java
Patch:
@@ -67,9 +67,9 @@ protected ObjectStreamClass readClassDescriptor()
             throw new EOFException();
         }
         switch (type) {
-        case CompactObjectOutputStream.TYPE_PRIMITIVE:
+        case CompactObjectOutputStream.TYPE_FAT_DESCRIPTOR:
             return super.readClassDescriptor();
-        case CompactObjectOutputStream.TYPE_NON_PRIMITIVE:
+        case CompactObjectOutputStream.TYPE_THIN_DESCRIPTOR:
             String className = readUTF();
             Class<?> clazz = loadClass(className);
             return ObjectStreamClass.lookup(clazz);

File: src/main/java/org/jboss/netty/channel/xnio/XnioClientChannelFactory.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * A client-side {@link ChannelFactory} which uses
- * <a href="http://www.jboss.org/xnio/>JBoss XNIO</a> as its I/O provider.
+ * <a href="http://www.jboss.org/xnio/">JBoss XNIO</a> as its I/O provider.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/channel/xnio/XnioChannel.java
Patch:
@@ -25,7 +25,7 @@
 import org.jboss.netty.channel.Channel;
 
 /**
- * A {@link Channel} which uses <a href="http://www.jboss.org/xnio/>JBoss XNIO</a>
+ * A {@link Channel} which uses <a href="http://www.jboss.org/xnio/">JBoss XNIO</a>
  * as its I/O provider.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)

File: src/main/java/org/jboss/netty/channel/xnio/XnioServerChannel.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * A {@link ServerChannel} which uses
- * <a href="http://www.jboss.org/xnio/>JBoss XNIO</a> as its I/O provider.
+ * <a href="http://www.jboss.org/xnio/">JBoss XNIO</a> as its I/O provider.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/channel/xnio/XnioServerChannelFactory.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * A {@link ServerChannelFactory} which uses
- * <a href="http://www.jboss.org/xnio/>JBoss XNIO</a> as its I/O provider.
+ * <a href="http://www.jboss.org/xnio/">JBoss XNIO</a> as its I/O provider.
  * <p>
  * Please note that you must specify an {@link XnioAcceptedChannelHandlerFactory}
  * when you create a {@link BoundServer} to integrate XNIO into Netty.

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingChannelHandler.java
Patch:
@@ -48,6 +48,7 @@
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
 @ChannelPipelineCoverage("one")

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannelFactory.java
Patch:
@@ -33,6 +33,7 @@
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
 public class HttpTunnelingClientSocketChannelFactory implements ClientSocketChannelFactory {

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java
Patch:
@@ -41,6 +41,7 @@
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
 final class HttpTunnelingClientSocketPipelineSink extends AbstractChannelSink {

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingServlet.java
Patch:
@@ -42,6 +42,7 @@
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
+ * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
 public class HttpTunnelingServlet extends HttpServlet {

File: src/main/java/org/jboss/netty/buffer/HeapChannelBuffer.java
Patch:
@@ -198,7 +198,7 @@ public ChannelBuffer slice(int index, int length) {
     }
 
     public ByteBuffer toByteBuffer(int index, int length) {
-        return ByteBuffer.wrap(array, index, length);
+        return ByteBuffer.wrap(array, index, length).order(order());
     }
 
     public String toString(int index, int length, String charsetName) {

File: src/main/java/org/jboss/netty/example/http/snoop/HttpClient.java
Patch:
@@ -19,7 +19,7 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.example.http;
+package org.jboss.netty.example.http.snoop;
 
 import java.net.InetSocketAddress;
 import java.net.URI;

File: src/main/java/org/jboss/netty/example/http/snoop/HttpClientPipelineFactory.java
Patch:
@@ -19,7 +19,7 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.example.http;
+package org.jboss.netty.example.http.snoop;
 
 import static org.jboss.netty.channel.Channels.*;
 

File: src/main/java/org/jboss/netty/example/http/snoop/HttpRequestHandler.java
Patch:
@@ -19,7 +19,7 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.example.http;
+package org.jboss.netty.example.http.snoop;
 
 import java.util.List;
 import java.util.Map;

File: src/main/java/org/jboss/netty/example/http/snoop/HttpResponseHandler.java
Patch:
@@ -19,7 +19,7 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.example.http;
+package org.jboss.netty.example.http.snoop;
 
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.channel.ChannelHandlerContext;

File: src/main/java/org/jboss/netty/example/http/snoop/HttpServer.java
Patch:
@@ -19,7 +19,7 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.example.http;
+package org.jboss.netty.example.http.snoop;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.Executors;

File: src/main/java/org/jboss/netty/example/http/snoop/HttpServerPipelineFactory.java
Patch:
@@ -19,7 +19,7 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.example.http;
+package org.jboss.netty.example.http.snoop;
 
 import static org.jboss.netty.channel.Channels.*;
 

File: src/main/java/org/jboss/netty/handler/stream/ChunkedFile.java
Patch:
@@ -35,16 +35,14 @@
  */
 public class ChunkedFile implements ChunkedInput {
 
-    private static final int DEFAULT_CHUNK_SIZE = 8192;
-
     private final RandomAccessFile file;
     private final long startOffset;
     private final long endOffset;
     private final int chunkSize;
     private volatile long offset;
 
     public ChunkedFile(File file) throws IOException {
-        this(file, DEFAULT_CHUNK_SIZE);
+        this(file, ChunkedStream.DEFAULT_CHUNK_SIZE);
     }
 
     public ChunkedFile(File file, int chunkSize) throws IOException {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -45,8 +45,8 @@ public abstract class HttpMessageDecoder extends ReplayingDecoder<HttpMessageDec
     private final int maxChunkSize;
     protected volatile HttpMessage message;
     private volatile ChannelBuffer content;
-    private volatile int headerSize;
     private volatile long chunkSize;
+    private int headerSize;
 
     /**
      * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -120,7 +120,6 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
 
             message = createMessage(initialLine);
             checkpoint(State.READ_HEADER);
-            headerSize = 0;
         }
         case READ_HEADER: {
             State nextState = readHeaders(buffer);
@@ -356,6 +355,7 @@ private void readFixedLengthContent(ChannelBuffer buffer) {
     }
 
     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {
+        headerSize = 0;
         final HttpMessage message = this.message;
         String line = readHeader(buffer);
         String lastHeader = null;

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -372,8 +372,9 @@ private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {
                     String[] header = splitHeader(line);
                     message.addHeader(header[0], header[1]);
                     lastHeader = header[0];
-                    line = readHeader(buffer);
                 }
+
+                line = readHeader(buffer);
             } while (line.length() != 0);
         }
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -40,11 +40,11 @@ public class HttpRequestEncoder extends HttpMessageEncoder {
     @Override
     protected void encodeInitialLine(ChannelBuffer buf, HttpMessage message) throws Exception {
         HttpRequest request = (HttpRequest) message;
-        buf.writeBytes(request.getMethod().toString().getBytes());
+        buf.writeBytes(request.getMethod().toString().getBytes("ASCII"));
         buf.writeByte(SP);
-        buf.writeBytes(request.getUri().getBytes());
+        buf.writeBytes(request.getUri().getBytes("ASCII"));
         buf.writeByte(SP);
-        buf.writeBytes(request.getProtocolVersion().toString().getBytes());
+        buf.writeBytes(request.getProtocolVersion().toString().getBytes("ASCII"));
         buf.writeBytes(CRLF);
     }
 }

File: src/main/java/org/jboss/netty/example/proxy/HexDumpProxyInboundHandler.java
Patch:
@@ -80,7 +80,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                     inboundChannel.setReadable(true);
                 } else {
                     // Close the connection if the connection attempt has failed.
-                    future.getChannel().close();
+                    inboundChannel.close();
                 }
             }
         });

File: src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramPipelineSink.java
Patch:
@@ -138,7 +138,7 @@ private void close(NioDatagramChannel channel, ChannelFuture future) {
 
     /**
      * Will bind the DatagramSocket to the passed-in address.
-     * Every call bind will spawn a new thread using the that basically inturn
+     * Every call bind will spawn a new thread using the that basically in turn
      */
     private void bind(final NioDatagramChannel channel,
             final ChannelFuture future, final InetSocketAddress address) {
@@ -152,7 +152,7 @@ private void bind(final NioDatagramChannel channel,
             future.setSuccess();
             fireChannelBound(channel, address);
 
-            nextWorker().register(channel, null);
+            channel.worker.register(channel, null);
             started = true;
         } catch (final Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java
Patch:
@@ -35,8 +35,8 @@
 import org.jboss.netty.channel.ChannelState;
 import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -48,9 +48,9 @@
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
 import org.jboss.netty.util.internal.LinkedTransferQueue;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  *

File: src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -37,8 +37,8 @@
 
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.SystemPropertyUtil;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  * Provides information which is specific to a NIO service provider

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -43,8 +43,8 @@
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  *

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -51,9 +51,9 @@
 import org.jboss.netty.channel.ReceiveBufferSizePredictor;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
 import org.jboss.netty.util.internal.LinkedTransferQueue;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  *

File: src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketPipelineSink.java
Patch:
@@ -36,8 +36,8 @@
 import org.jboss.netty.channel.ChannelState;
 import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  *

File: src/main/java/org/jboss/netty/channel/socket/oio/OioDatagramPipelineSink.java
Patch:
@@ -35,8 +35,8 @@
 import org.jboss.netty.channel.ChannelState;
 import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  *

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -40,8 +40,8 @@
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.jboss.netty.util.internal.IoWorkerRunnable;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  *

File: src/main/java/org/jboss/netty/util/HashedWheelTimer.java
Patch:
@@ -40,7 +40,6 @@
 import org.jboss.netty.util.internal.ConcurrentIdentityHashMap;
 import org.jboss.netty.util.internal.MapBackedSet;
 import org.jboss.netty.util.internal.ReusableIterator;
-import org.jboss.netty.util.internal.ThreadRenamingRunnable;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)

File: src/main/java/org/jboss/netty/util/internal/StackTraceSimplifier.java
Patch:
@@ -29,6 +29,7 @@
 import org.jboss.netty.channel.DefaultChannelPipeline;
 import org.jboss.netty.channel.SimpleChannelHandler;
 import org.jboss.netty.util.DebugUtil;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 
 /**
  * Simplifies an exception stack trace by removing unnecessary
@@ -47,8 +48,8 @@ public class StackTraceSimplifier {
     private static final Pattern EXCLUDED_STACK_TRACE =
         Pattern.compile(
                 "^org\\.jboss\\.netty\\." +
-                "(util\\.internal\\.(ThreadRenamingRunnable)" +
-                "|channel\\.(SimpleChannelHandler|DefaultChannelPipeline.*))$");
+                "(util\\.(ThreadRenamingRunnable)" +
+                "|channel\\.(SimpleChannel(Upstream|Downstream)?Handler|DefaultChannelPipeline.*))$");
 
     /**
      * Removes unnecessary {@link StackTraceElement}s from the specified

File: src/test/java/org/jboss/netty/util/ThreadRenamingRunnableTest.java
Patch:
@@ -1,7 +1,7 @@
 /*
  * JBoss, Home of Professional Open Source
  *
- * Copyright 2008, Red Hat Middleware LLC, and individual contributors
+ * Copyright 2009, Red Hat Middleware LLC, and individual contributors
  * by the @author tags. See the COPYRIGHT.txt in the distribution for a
  * full listing of individual contributors.
  *
@@ -20,14 +20,15 @@
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
-package org.jboss.netty.util.internal;
+package org.jboss.netty.util;
 
 import static org.easymock.EasyMock.*;
 import static org.junit.Assert.*;
 
 import java.security.Permission;
 import java.util.concurrent.Executor;
 
+import org.jboss.netty.util.internal.ImmediateExecutor;
 import org.junit.Test;
 
 

File: src/test/java/org/jboss/netty/util/internal/StackTraceSimplifierTest.java
Patch:
@@ -30,6 +30,7 @@
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.DefaultChannelPipeline;
 import org.jboss.netty.channel.SimpleChannelHandler;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 import org.junit.Test;
 
 

File: src/main/java/org/jboss/netty/handler/codec/frame/FrameDecoder.java
Patch:
@@ -279,7 +279,7 @@ private void fireMessageReceived(ChannelHandlerContext context, SocketAddress re
                 for (int i = 0; i < length; i ++) {
                     Channels.fireMessageReceived(context, Array.get(result, i), remoteAddress);
                 }
-            } else if (result instanceof Iterable) {
+            } else if (result instanceof Iterable<?>) {
                 for (Object r: (Iterable<?>) result) {
                     Channels.fireMessageReceived(context, r, remoteAddress);
                 }

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -93,7 +93,7 @@ public void setHeader(final String name, final Iterable<String> values) {
             throw new IllegalArgumentException("values is empty.");
         }
 
-        if (values instanceof List) {
+        if (values instanceof List<?>) {
             headers.put(name, (List<String>) values);
         } else {
             List<String> valueList = new LinkedList<String>();

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -457,7 +457,7 @@ private void unfoldAndfireMessageReceived(
                 for (int i = 0; i < length; i ++) {
                     Channels.fireMessageReceived(context, Array.get(result, i), remoteAddress);
                 }
-            } else if (result instanceof Iterable) {
+            } else if (result instanceof Iterable<?>) {
                 for (Object r: (Iterable<?>) result) {
                     Channels.fireMessageReceived(context, r, remoteAddress);
                 }

File: src/main/java/org/jboss/netty/util/DefaultObjectSizeEstimator.java
Patch:
@@ -83,7 +83,7 @@ public int estimateSize(Object o) {
             answer += ((ByteBuffer) o).remaining();
         } else if (o instanceof CharSequence) {
             answer += ((CharSequence) o).length() << 1;
-        } else if (o instanceof Iterable) {
+        } else if (o instanceof Iterable<?>) {
             for (Object m : (Iterable<?>) o) {
                 answer += estimateSize(m);
             }

File: src/main/java/org/jboss/netty/util/internal/ConcurrentHashMap.java
Patch:
@@ -1259,7 +1259,7 @@ public V setValue(V value) {
 
         @Override
         public boolean equals(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             @SuppressWarnings("unchecked")
@@ -1390,7 +1390,7 @@ public Iterator<Map.Entry<K, V>> iterator() {
 
         @Override
         public boolean contains(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
@@ -1400,7 +1400,7 @@ public boolean contains(Object o) {
 
         @Override
         public boolean remove(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;

File: src/main/java/org/jboss/netty/util/internal/ConcurrentIdentityHashMap.java
Patch:
@@ -1261,7 +1261,7 @@ public V setValue(V value) {
 
         @Override
         public boolean equals(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             @SuppressWarnings("unchecked")
@@ -1392,7 +1392,7 @@ public Iterator<Map.Entry<K, V>> iterator() {
 
         @Override
         public boolean contains(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
@@ -1402,7 +1402,7 @@ public boolean contains(Object o) {
 
         @Override
         public boolean remove(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;

File: src/main/java/org/jboss/netty/util/internal/ConcurrentIdentityWeakKeyHashMap.java
Patch:
@@ -1339,7 +1339,7 @@ public V setValue(V value) {
 
         @Override
         public boolean equals(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             @SuppressWarnings("unchecked")
@@ -1470,7 +1470,7 @@ public Iterator<Map.Entry<K, V>> iterator() {
 
         @Override
         public boolean contains(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
@@ -1480,7 +1480,7 @@ public boolean contains(Object o) {
 
         @Override
         public boolean remove(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;

File: src/main/java/org/jboss/netty/util/internal/ConcurrentWeakKeyHashMap.java
Patch:
@@ -1339,7 +1339,7 @@ public V setValue(V value) {
 
         @Override
         public boolean equals(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             @SuppressWarnings("unchecked")
@@ -1470,7 +1470,7 @@ public Iterator<Map.Entry<K, V>> iterator() {
 
         @Override
         public boolean contains(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
@@ -1480,7 +1480,7 @@ public boolean contains(Object o) {
 
         @Override
         public boolean remove(Object o) {
-            if (!(o instanceof Map.Entry)) {
+            if (!(o instanceof Map.Entry<?, ?>)) {
                 return false;
             }
             Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;

File: src/main/java/org/jboss/netty/util/HashedWheelTimer.java
Patch:
@@ -309,12 +309,12 @@ private void fetchExpiredTimeouts(
                 List<HashedWheelTimeout> expiredTimeouts,
                 ReusableIterator<HashedWheelTimeout> i) {
 
-            long currentTime = System.currentTimeMillis();
+            long currentDeadline = System.currentTimeMillis() + tickDuration;
             i.rewind();
             while (i.hasNext()) {
                 HashedWheelTimeout timeout = i.next();
                 if (timeout.remainingRounds <= 0) {
-                    if (timeout.deadline <= currentTime) {
+                    if (timeout.deadline < currentDeadline) {
                         i.remove();
                         expiredTimeouts.add(timeout);
                     } else {

File: src/main/java/org/jboss/netty/channel/socket/oio/OioDatagramChannel.java
Patch:
@@ -54,6 +54,7 @@ final class OioDatagramChannel extends AbstractChannel
                                 implements DatagramChannel {
 
     final MulticastSocket socket;
+    final Object interestOpsLock = new Object();
     private final DatagramChannelConfig config;
     volatile Thread workerThread;
 

File: src/main/java/org/jboss/netty/channel/socket/oio/OioSocketChannel.java
Patch:
@@ -50,6 +50,7 @@ abstract class OioSocketChannel extends AbstractChannel
                                 implements SocketChannel {
 
     final Socket socket;
+    final Object interestOpsLock = new Object();
     private final SocketChannelConfig config;
     volatile Thread workerThread;
 

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderBuffer.java
Patch:
@@ -215,7 +215,7 @@ public ByteOrder order() {
     }
 
     public boolean readable() {
-        return true;
+        return terminated? buffer.readable() : true;
     }
 
     public int readableBytes() {

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -455,6 +455,7 @@ private void unfoldAndfireMessageReceived(
     private void cleanup(ChannelHandlerContext ctx, ChannelStateEvent e)
             throws Exception {
         ChannelBuffer cumulation = cumulation(ctx);
+        replayable.terminate();
         try {
             if (cumulation.readable()) {
                 // Make sure all data was read before notifying a closed channel.

File: src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java
Patch:
@@ -57,7 +57,7 @@ public ByteBufferBackedChannelBuffer(ByteBuffer buffer) {
             throw new NullPointerException("buffer");
         }
 
-        this.buffer = buffer.slice();
+        this.buffer = buffer.slice().order(buffer.order());
         capacity = buffer.remaining();
         writerIndex(capacity);
     }
@@ -337,6 +337,7 @@ public ChannelBuffer copy(int index, int length) {
 
         ByteBuffer dst = buffer.isDirect() ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);
         dst.put(src);
+        dst.order(order());
         dst.clear();
         return new ByteBufferBackedChannelBuffer(dst);
     }

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java
Patch:
@@ -71,6 +71,7 @@ public static void destroy() {
     public void testFailedConnectionAttempt() throws Exception {
         ClientBootstrap bootstrap = new ClientBootstrap();
         bootstrap.setFactory(newClientSocketChannelFactory(executor));
+        bootstrap.getPipeline().addLast("dummy", new DummyHandler());
         bootstrap.setOption("remoteAddress", new InetSocketAddress("255.255.255.255", 1));
         ChannelFuture future = bootstrap.connect();
         future.awaitUninterruptibly();

File: src/main/java/org/jboss/netty/channel/local/DefaultLocalChannel.java
Patch:
@@ -88,7 +88,6 @@ void closeNow(ChannelFuture future) {
         try {
             // Close the self.
             if (!setClosed()) {
-                future.setSuccess();
                 return;
             }
 
@@ -115,6 +114,7 @@ void closeNow(ChannelFuture future) {
             }
             fireChannelClosed(pairedChannel);
         } finally {
+            future.setSuccess();
             if (localAddress != null) {
                 LocalChannelRegistry.unregister(localAddress);
             }

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelWorker.java
Patch:
@@ -142,8 +142,8 @@ static void close(HttpTunnelingClientSocketChannel channel, ChannelFuture future
         boolean bound = channel.isBound();
         try {
             channel.closeSocket();
-            future.setSuccess();
             if (channel.setClosed()) {
+                future.setSuccess();
                 if (connected) {
                     // Notify the worker so it stops reading.
                     Thread currentThread = Thread.currentThread();
@@ -157,6 +157,8 @@ static void close(HttpTunnelingClientSocketChannel channel, ChannelFuture future
                     fireChannelUnbound(channel);
                 }
                 fireChannelClosed(channel);
+            } else {
+                future.setSuccess();
             }
         }
         catch (Throwable t) {

File: src/main/java/org/jboss/netty/channel/socket/oio/OioDatagramWorker.java
Patch:
@@ -191,8 +191,8 @@ static void close(OioDatagramChannel channel, ChannelFuture future) {
         boolean bound = channel.isBound();
         try {
             channel.socket.close();
-            future.setSuccess();
             if (channel.setClosed()) {
+                future.setSuccess();
                 if (connected) {
                     // Notify the worker so it stops reading.
                     Thread currentThread = Thread.currentThread();
@@ -206,6 +206,8 @@ static void close(OioDatagramChannel channel, ChannelFuture future) {
                     fireChannelUnbound(channel);
                 }
                 fireChannelClosed(channel);
+            } else {
+                future.setSuccess();
             }
         } catch (Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -171,12 +171,14 @@ private void close(OioServerSocketChannel channel, ChannelFuture future) {
         boolean bound = channel.isBound();
         try {
             channel.socket.close();
-            future.setSuccess();
             if (channel.setClosed()) {
+                future.setSuccess();
                 if (bound) {
                     fireChannelUnbound(channel);
                 }
                 fireChannelClosed(channel);
+            } else {
+                future.setSuccess();
             }
         } catch (Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/channel/socket/oio/OioWorker.java
Patch:
@@ -180,8 +180,8 @@ static void close(OioSocketChannel channel, ChannelFuture future) {
         boolean bound = channel.isBound();
         try {
             channel.socket.close();
-            future.setSuccess();
             if (channel.setClosed()) {
+                future.setSuccess();
                 if (connected) {
                     // Notify the worker so it stops reading.
                     Thread currentThread = Thread.currentThread();
@@ -195,6 +195,8 @@ static void close(OioSocketChannel channel, ChannelFuture future) {
                     fireChannelUnbound(channel);
                 }
                 fireChannelClosed(channel);
+            } else {
+                future.setSuccess();
             }
         } catch (Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/channel/xnio/DefaultXnioServerChannel.java
Patch:
@@ -126,8 +126,8 @@ void closeNow(ChannelFuture future) {
         SocketAddress localAddress = getLocalAddress();
         boolean bound = localAddress != null;
         try {
-            future.setSuccess();
             if (setClosed()) {
+                future.setSuccess();
                 synchronized (bindLock) {
                     IoUtils.safeClose(xnioChannel);
                     XnioChannelRegistry.unregisterServerChannel(localAddress);
@@ -138,6 +138,8 @@ void closeNow(ChannelFuture future) {
                     fireChannelUnbound(this);
                 }
                 fireChannelClosed(this);
+            } else {
+                future.setSuccess();
             }
         } catch (Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -178,12 +178,14 @@ private void close(NioServerSocketChannel channel, ChannelFuture future) {
         boolean bound = channel.isBound();
         try {
             channel.socket.close();
-            future.setSuccess();
             if (channel.setClosed()) {
+                future.setSuccess();
                 if (bound) {
                     fireChannelUnbound(channel);
                 }
                 fireChannelClosed(channel);
+            } else {
+                future.setSuccess();
             }
         } catch (Throwable t) {
             future.setFailure(t);

File: src/main/java/org/jboss/netty/util/internal/LinkedTransferQueue.java
Patch:
@@ -184,6 +184,7 @@ private static final class PaddedAtomicReference<T> extends AtomicReference<T> {
         private static final long serialVersionUID = 4684288940772921317L;
 
         // enough padding for 64bytes with 4byte refs
+        @SuppressWarnings("unused")
         Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
         PaddedAtomicReference(T r) { super(r); }
     }

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -148,14 +148,14 @@ public void removeHeader(final String name) {
         headers.remove(name);
     }
 
-    public int getContentLength() {
+    public long getContentLength() {
         return getContentLength(0);
     }
 
-    public int getContentLength(int defaultValue) {
+    public long getContentLength(long defaultValue) {
         List<String> contentLength = headers.get(HttpHeaders.Names.CONTENT_LENGTH);
         if (contentLength != null && contentLength.size() > 0) {
-            return Integer.parseInt(contentLength.get(0));
+            return Long.parseLong(contentLength.get(0));
         }
         return defaultValue;
     }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessage.java
Patch:
@@ -55,9 +55,9 @@ public interface HttpMessage {
 
     void removeHeader(String name);
 
-    int getContentLength();
+    long getContentLength();
 
-    int getContentLength(int defaultValue);
+    long getContentLength(long defaultValue);
 
     void setContent(ChannelBuffer content);
 

File: src/main/java/org/jboss/netty/buffer/ChannelBuffer.java
Patch:
@@ -1384,8 +1384,7 @@ public interface ChannelBuffer extends Comparable<ChannelBuffer> {
     /**
      * Returns a slice of this buffer's sub-region. Modifying the content of
      * the returned buffer or this buffer affects each other's content while
-     * they maintain separate indexes and marks.  This method is identical to
-     * {@code buf.slice(buf.readerIndex(), buf.readableBytes())}.
+     * they maintain separate indexes and marks.
      * This method does not modify {@code readerIndex} or {@code writerIndex} of
      * this buffer.
      */

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java
Patch:
@@ -128,7 +128,7 @@ private void connect(
                     new IoWorkerRunnable(
                             new ThreadRenamingRunnable(
                                     new HttpTunnelWorker(channel),
-                                    "Old I/O client worker (channelId: " +
+                                    "HTTP Tunnel I/O client worker (channelId: " +
                                     channel.getId() + ", " +
                                     channel.getLocalAddress() + " => " +
                                     channel.getRemoteAddress() + ')')));

File: src/main/java/org/jboss/netty/channel/ChannelConfig.java
Patch:
@@ -70,7 +70,7 @@
  * @version $Rev$, $Date$
  *
  * @apiviz.has org.jboss.netty.channel.ChannelPipelineFactory
- * @apiviz.has org.jboss.netty.channel.ReceiveBufferSizePredictor
+ * @apiviz.composedOf org.jboss.netty.channel.ReceiveBufferSizePredictor
  */
 public interface ChannelConfig {
 

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -46,6 +46,8 @@
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
+ *
+ * @apiviz.landmark
  */
 public class DefaultChannelGroup extends AbstractSet<Channel> implements ChannelGroup {
 

File: src/main/java/org/jboss/netty/channel/group/package-info.java
Patch:
@@ -26,6 +26,6 @@
  * {@link org.jboss.netty.channel.Channel}s and perform bulk operations on them.
  *
  * @apiviz.exclude ^java
- * @apiviz.exclude \.(Abstract|Default).*$
+ * @apiviz.exclude \.DefaultChannelGroupFuture$
  */
 package org.jboss.netty.channel.group;

File: src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java
Patch:
@@ -242,7 +242,8 @@ private void checkDeadLock() {
         if (IoWorkerRunnable.IN_IO_THREAD.get()) {
             throw new IllegalStateException(
                     "await*() in I/O thread causes a dead lock or " +
-                    "sudden performance drop. Use addListener() instead.");
+                    "sudden performance drop. Use addListener() instead or " +
+                    "call await*() from a different thread.");
         }
     }
 

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -308,7 +308,8 @@ private void checkDeadLock() {
         if (IoWorkerRunnable.IN_IO_THREAD.get()) {
             throw new IllegalStateException(
                     "await*() in I/O thread causes a dead lock or " +
-                    "sudden performance drop. Use addListener() instead.");
+                    "sudden performance drop. Use addListener() instead or " +
+                    "call await*() from a different thread.");
         }
     }
 

File: src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java
Patch:
@@ -242,7 +242,7 @@ private void checkDeadLock() {
         if (IoWorkerRunnable.IN_IO_THREAD.get()) {
             throw new IllegalStateException(
                     "await*() in I/O thread causes a dead lock or " +
-                    "sudden performance drop.");
+                    "sudden performance drop. Use addListener() instead.");
         }
     }
 

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroupFuture.java
Patch:
@@ -308,7 +308,7 @@ private void checkDeadLock() {
         if (IoWorkerRunnable.IN_IO_THREAD.get()) {
             throw new IllegalStateException(
                     "await*() in I/O thread causes a dead lock or " +
-                    "sudden performance drop.");
+                    "sudden performance drop. Use addListener() instead.");
         }
     }
 

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java
Patch:
@@ -152,7 +152,7 @@ void connectAndSendHeaders(boolean reconnect, HttpTunnelAddress remoteAddress) {
             channel = clientSocketChannelFactory.newChannel(channelPipeline);
         }
         SocketAddress connectAddress = new InetSocketAddress(url.getHost(), url.getPort());
-        channel.connect(connectAddress);
+        channel.connect(connectAddress).awaitUninterruptibly();
         StringBuilder builder = new StringBuilder();
         builder.append("POST ").append(url.getRawPath()).append(" HTTP/1.1").append(HttpTunnelingClientSocketPipelineSink.LINE_TERMINATOR).
                 append("Host: ").append(url.getHost()).append(":").append(url.getPort()).append(HttpTunnelingClientSocketPipelineSink.LINE_TERMINATOR).

File: src/main/java/org/jboss/netty/bootstrap/Bootstrap.java
Patch:
@@ -124,7 +124,9 @@ public void setFactory(ChannelFactory factory) {
     public ChannelPipeline getPipeline() {
         ChannelPipeline pipeline = this.pipeline;
         if (pipeline == null) {
-            throw new IllegalStateException("pipelineFactory in use");
+            throw new IllegalStateException(
+                    "getPipeline() cannot be called " +
+                    "if setPipelineFactory() was called.");
         }
         return pipeline;
     }

File: src/main/java/org/jboss/netty/channel/socket/oio/OioWorker.java
Patch:
@@ -46,7 +46,7 @@
 class OioWorker implements Runnable {
 
     private static final Pattern SOCKET_CLOSED_MESSAGE = Pattern.compile(
-            "^.*(?:Socket\\s*closed).*$", Pattern.CASE_INSENSITIVE);
+            "^.*(?:Socket.*closed).*$", Pattern.CASE_INSENSITIVE);
 
     private final OioSocketChannel channel;
 

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -110,7 +110,7 @@ public class SslHandler extends FrameDecoder {
     private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
 
     private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
-            "^.*(?:Connection\\s*reset|Broken\\s*pipe).*$",
+            "^.*(?:Connection.*reset|Broken.*pipe).*$",
             Pattern.CASE_INSENSITIVE);
 
     private static SslBufferPool defaultBufferPool;

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -109,8 +109,9 @@ public class SslHandler extends FrameDecoder {
 
     private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
 
-    private static final Pattern CONNECTION_RESET =
-        Pattern.compile("^.*Connection\\s*reset.*$", Pattern.CASE_INSENSITIVE);
+    private static final Pattern CONNECTION_RESET = Pattern.compile(
+            "^.*(Connection\\s*reset|Broken\\s*pipe).*$",
+            Pattern.CASE_INSENSITIVE);
 
     private static SslBufferPool defaultBufferPool;
 

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelWorker.java
Patch:
@@ -72,9 +72,9 @@ public void run() {
                 break;
             }
 
-            ChannelBuffer buffer = ChannelBuffers.wrappedBuffer(buf);
-
-            fireMessageReceived(channel, buffer);
+            if (buf != null) {
+                fireMessageReceived(channel, ChannelBuffers.wrappedBuffer(buf));
+            }
         }
 
         // Setting the workerThread to null will prevent any channel

File: src/main/java/org/jboss/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -625,7 +625,7 @@ DefaultChannelHandlerContext getActualDownstreamContext(DefaultChannelHandlerCon
         return realCtx;
     }
 
-    void notifyHandlerException(ChannelEvent e, Throwable t) {
+    protected void notifyHandlerException(ChannelEvent e, Throwable t) {
         if (e instanceof ExceptionEvent) {
             logger.warn(
                     "An exception was thrown by a user handler " +

File: src/main/java/org/jboss/netty/util/DefaultObjectSizeEstimator.java
Patch:
@@ -70,6 +70,7 @@ public int estimateSize(Object o) {
 
         int answer = 8 + estimateSize(o.getClass(), null);
 
+        // FIXME: Cyclic dependency
         if (o instanceof ChannelEventRunnable) {
             answer += estimateSize(((ChannelEventRunnable) o).getEvent());
         } else if (o instanceof MessageEvent) {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
Patch:
@@ -58,7 +58,7 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)
             header.writeBytes(CRLF);
 
             ChannelBuffer content = request.getContent();
-            if (content == null) {
+            if (!content.readable()) {
                 return header; // no content
             } else {
                 return wrappedBuffer(header, content);

File: src/main/java/org/jboss/netty/example/http/HttpClient.java
Patch:
@@ -73,8 +73,7 @@ public static void main(String[] args) throws Exception {
                     Executors.newCachedThreadPool());
 
         ClientBootstrap bootstrap = new ClientBootstrap(factory);
-        HttpClientPipelineFactory handler = new HttpClientPipelineFactory(new HttpResponseHandler());
-        bootstrap.setPipelineFactory(handler);
+        bootstrap.setPipelineFactory(new HttpClientPipelineFactory());
 
         // Start the connection attempt.
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));

File: src/main/java/org/jboss/netty/example/http/HttpServer.java
Patch:
@@ -41,8 +41,7 @@ public static void main(String[] args) {
                     Executors.newCachedThreadPool());
 
         ServerBootstrap bootstrap = new ServerBootstrap(factory);
-        HttpServerPipelineFactory pipeline = new HttpServerPipelineFactory(new HttpRequestHandler());
-        bootstrap.setPipelineFactory(pipeline);
+        bootstrap.setPipelineFactory(new HttpServerPipelineFactory());
         bootstrap.setOption("child.tcpNoDelay", true);
         bootstrap.setOption("child.keepAlive", true);
 

File: src/main/java/org/jboss/netty/handler/trafficshaping/package-info.java
Patch:
@@ -51,7 +51,8 @@
  * sometimes it will block for a while which can turn to "timeout" operations.
  * For instance, let says that you've got 2 NioWorkers, and 10 clients wants to send data to your server. If you set a bandwidth limitation
  * of 100KB/s for each channel (client), you could have a final limitation of about 60KB/s for each channel since NioWorkers are
- * stopping by this handler.<br><br>
+ * stopping by this handler.<br>
+ * When it is used as a read traffic shaper, the handler will set the channel as not readable, so as to relax the NioWorkers.<br><br>
  * The method <tt>getMessageSize(MessageEvent)</tt> has to be implemented to specify what is the size of the object to be read or write
  * accordingly to the type of object. In simple case, it can be as simple as a call to <tt>getChannelBufferMessageSize(MessageEvent)</tt>.<br>
  * </ul></P>

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCodecUtil.java
Patch:
@@ -70,6 +70,8 @@ class HttpCodecUtil {
 
     static final byte DOUBLE_QUOTE = '"';
 
+    static final String DEFAULT_CHARSET = "UTF-8";
+
     private HttpCodecUtil() {
         super();
     }

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -44,7 +44,7 @@ public class QueryStringEncoder {
     private final List<Param> params = new ArrayList<Param>();
 
     public QueryStringEncoder(String uri) {
-        this(uri, QueryStringDecoder.DEFAULT_CHARSET);
+        this(uri, HttpCodecUtil.DEFAULT_CHARSET);
     }
 
     public QueryStringEncoder(String uri, String charset) {

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java
Patch:
@@ -43,7 +43,7 @@ public class DefaultCookie implements Cookie {
     private boolean discard;
     private Set<Integer> ports = Collections.emptySet();
     private Set<Integer> unmodifiablePorts = ports;
-    private int maxAge;
+    private int maxAge = -1;
     private int version;
     private boolean secure;
 

File: src/main/java/org/jboss/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -101,7 +101,7 @@ public String encode() {
                     add(sb, CookieHeaderNames.COMMENT, QueryStringEncoder.encodeComponent(cookie.getComment(), charset));
                 }
 
-                add(sb, CookieHeaderNames.VERSION, encodingVersion);
+                add(sb, CookieHeaderNames.VERSION, 1);
             }
 
             if (encodingVersion == 2) {

File: src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java
Patch:
@@ -105,6 +105,8 @@ else if (CookieHeaderNames.PATH.equalsIgnoreCase(name)) {
                             path = QueryStringDecoder.decodeComponent(value, charset);
                         }
                         else if (CookieHeaderNames.EXPIRES.equalsIgnoreCase(name)) {
+                            // FIXME: Expires attribute has different representation from Max-Age.
+                            //        Format: Wdy, DD-Mon-YYYY HH:MM:SS GMT
                             maxAge = Integer.valueOf(value);
                         }
                         else if (CookieHeaderNames.MAX_AGE.equalsIgnoreCase(name)) {

File: src/main/java/org/jboss/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -81,6 +81,8 @@ public String encode() {
             Cookie cookie = cookies.get(cookieName);
             add(sb, cookieName, QueryStringEncoder.encodeComponent(cookie.getValue(), charset));
 
+            // FIXME: Expires attribute has different representation from Max-Age.
+            //        Format: Wdy, DD-Mon-YYYY HH:MM:SS GMT
             add(sb, CookieHeaderNames.getMaxAgeString(encodingVersion), cookie.getMaxAge());
 
             if (cookie.getPath() != null) {

File: src/test/java/org/jboss/netty/handler/codec/http/CookieEncoderTest.java
Patch:
@@ -66,7 +66,7 @@ public void testEncodingSingleCookieV1() {
     }
     @Test
     public void testEncodingSingleCookieV2() {
-        String result = "myCookie=myValue;max-age=50;path=%2Fapathsomewhere;domain=%2Fadomainsomewhere;secure;comment=this%20is%20a%20comment;version=2;commentURL=http%2F%3Aaurl.com;port=80,8080;discard;";
+        String result = "myCookie=myValue;max-age=50;path=%2Fapathsomewhere;domain=%2Fadomainsomewhere;secure;comment=this%20is%20a%20comment;version=2;commentURL=\"http%2F%3Aaurl.com\";port=\"80,8080\";discard;";
         Cookie cookie = new DefaultCookie("myCookie", "myValue");
         CookieEncoder encoder = new CookieEncoder(2);
         encoder.addCookie(cookie);
@@ -84,8 +84,8 @@ public void testEncodingSingleCookieV2() {
 
     @Test
     public void testEncodingMultipleCookies() {
-        String c1 = "myCookie=myValue;max-age=50;path=%2Fapathsomewhere;domain=%2Fadomainsomewhere;secure;comment=this%20is%20a%20comment;version=2;commentURL=http%2F%3Aaurl.com;port=80,8080;discard;";
-        String c2 = "myCookie2=myValue2;max-age=0;path=%2Fanotherpathsomewhere;domain=%2Fanotherdomainsomewhere;comment=this%20is%20another%20comment;version=2;commentURL=http%2F%3Aanotherurl.com;";
+        String c1 = "myCookie=myValue;max-age=50;path=%2Fapathsomewhere;domain=%2Fadomainsomewhere;secure;comment=this%20is%20a%20comment;version=2;commentURL=\"http%2F%3Aaurl.com\";port=\"80,8080\";discard;";
+        String c2 = "myCookie2=myValue2;max-age=0;path=%2Fanotherpathsomewhere;domain=%2Fanotherdomainsomewhere;comment=this%20is%20another%20comment;version=2;commentURL=\"http%2F%3Aanotherurl.com\";";
         String c3 = "myCookie3=myValue3;max-age=0;version=2;";
         CookieEncoder encoder = new CookieEncoder(2);
         Cookie cookie = new DefaultCookie("myCookie", "myValue");

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCodecUtil.java
Patch:
@@ -68,6 +68,8 @@ class HttpCodecUtil {
     */
     static final byte COMMA = 44;
 
+    static final byte DOUBLE_QUOTE = '"';
+
     private HttpCodecUtil() {
         super();
     }

File: src/main/java/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
Patch:
@@ -41,7 +41,7 @@ public class CookieHeaderNames {
 
     public static final String DISCARD = "discard";
 
-    public static final String PORTLIST = "port";
+    public static final String PORT = "port";
 
     public static final String VERSION = "version";
 

File: src/main/java/org/jboss/netty/handler/codec/http/Cookie.java
Patch:
@@ -47,5 +47,5 @@ public interface Cookie extends Comparable<Cookie> {
     boolean isDiscard();
     void setDiscard(boolean discard);
     int[] getPortList();
-    void setPortList(int[] portList);
+    void setPortList(int... portList);
 }
\ No newline at end of file

File: src/main/java/org/jboss/netty/buffer/ChannelBuffer.java
Patch:
@@ -1228,12 +1228,14 @@ public interface ChannelBuffer extends Comparable<ChannelBuffer> {
      *
      * @param length the number of bytes to transfer
      *
+     * @return the actual number of bytes read in from the specified stream
+     *
      * @throws IndexOutOfBoundsException
      *         if {@code length} is greater than {@code this.writableBytes}
      * @throws IOException
      *         if the specified stream threw an exception during I/O
      */
-    void writeBytes(InputStream in, int length) throws IOException;
+    int  writeBytes(InputStream in, int length) throws IOException;
 
     /**
      * Transfers the content of the specified channel to this buffer

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderBuffer.java
Patch:
@@ -502,7 +502,7 @@ public void writeBytes(ChannelBuffer src) {
         throw new UnreplayableOperationException();
     }
 
-    public void writeBytes(InputStream in, int length) throws IOException {
+    public int writeBytes(InputStream in, int length) throws IOException {
         throw new UnreplayableOperationException();
     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/DefaultNioSocketChannelConfig.java
Patch:
@@ -25,7 +25,7 @@
 import java.net.Socket;
 import java.util.Map;
 
-import org.jboss.netty.channel.DefaultReceiveBufferSizePredictor;
+import org.jboss.netty.channel.AdaptiveReceiveBufferSizePredictor;
 import org.jboss.netty.channel.ReceiveBufferSizePredictor;
 import org.jboss.netty.channel.socket.DefaultSocketChannelConfig;
 import org.jboss.netty.logging.InternalLogger;
@@ -50,7 +50,7 @@ class DefaultNioSocketChannelConfig extends DefaultSocketChannelConfig
     private volatile int writeBufferHighWaterMark = 64 * 1024;
     private volatile int writeBufferLowWaterMark  = 32 * 1024;
     private volatile ReceiveBufferSizePredictor predictor =
-        new DefaultReceiveBufferSizePredictor();
+        new AdaptiveReceiveBufferSizePredictor();
     private volatile int writeSpinCount = 16;
 
     DefaultNioSocketChannelConfig(Socket socket) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannelConfig.java
Patch:
@@ -26,7 +26,7 @@
 import java.nio.channels.WritableByteChannel;
 
 import org.jboss.netty.channel.ChannelConfig;
-import org.jboss.netty.channel.DefaultReceiveBufferSizePredictor;
+import org.jboss.netty.channel.AdaptiveReceiveBufferSizePredictor;
 import org.jboss.netty.channel.ReceiveBufferSizePredictor;
 import org.jboss.netty.channel.socket.SocketChannel;
 import org.jboss.netty.channel.socket.SocketChannelConfig;
@@ -89,14 +89,14 @@ public interface NioSocketChannelConfig extends SocketChannelConfig {
     /**
      * Returns the {@link ReceiveBufferSizePredictor} which predicts the
      * number of readable bytes in the socket receive buffer.  The default
-     * predictor is {@link DefaultReceiveBufferSizePredictor}.
+     * predictor is {@link AdaptiveReceiveBufferSizePredictor}.
      */
     ReceiveBufferSizePredictor getReceiveBufferSizePredictor();
 
     /**
      * Sets the {@link ReceiveBufferSizePredictor} which predicts the
      * number of readable bytes in the socket receive buffer.  The default
-     * predictor is {@link DefaultReceiveBufferSizePredictor}.
+     * predictor is {@link AdaptiveReceiveBufferSizePredictor}.
      */
     void setReceiveBufferSizePredictor(ReceiveBufferSizePredictor predictor);
 

File: src/main/java/org/jboss/netty/channel/xnio/DefaultXnioChannelConfig.java
Patch:
@@ -28,7 +28,7 @@
 import org.jboss.netty.buffer.ChannelBufferFactory;
 import org.jboss.netty.buffer.HeapChannelBufferFactory;
 import org.jboss.netty.channel.ChannelPipelineFactory;
-import org.jboss.netty.channel.DefaultReceiveBufferSizePredictor;
+import org.jboss.netty.channel.AdaptiveReceiveBufferSizePredictor;
 import org.jboss.netty.channel.ReceiveBufferSizePredictor;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
@@ -53,7 +53,7 @@ final class DefaultXnioChannelConfig implements XnioChannelConfig {
     private volatile int writeBufferHighWaterMark = 64 * 1024;
     private volatile int writeBufferLowWaterMark  = 32 * 1024;
     private volatile ReceiveBufferSizePredictor predictor =
-        new DefaultReceiveBufferSizePredictor();
+        new AdaptiveReceiveBufferSizePredictor();
     private volatile int writeSpinCount = 16;
 
     DefaultXnioChannelConfig() {

File: src/main/java/org/jboss/netty/channel/xnio/XnioChannelConfig.java
Patch:
@@ -26,7 +26,7 @@
 import java.nio.channels.WritableByteChannel;
 
 import org.jboss.netty.channel.ChannelConfig;
-import org.jboss.netty.channel.DefaultReceiveBufferSizePredictor;
+import org.jboss.netty.channel.AdaptiveReceiveBufferSizePredictor;
 import org.jboss.netty.channel.ReceiveBufferSizePredictor;
 import org.jboss.netty.channel.socket.SocketChannelConfig;
 
@@ -86,14 +86,14 @@ public interface XnioChannelConfig extends ChannelConfig {
     /**
      * Returns the {@link ReceiveBufferSizePredictor} which predicts the
      * number of readable bytes in the socket receive buffer.  The default
-     * predictor is {@link DefaultReceiveBufferSizePredictor}.
+     * predictor is {@link AdaptiveReceiveBufferSizePredictor}.
      */
     ReceiveBufferSizePredictor getReceiveBufferSizePredictor();
 
     /**
      * Sets the {@link ReceiveBufferSizePredictor} which predicts the
      * number of readable bytes in the socket receive buffer.  The default
-     * predictor is {@link DefaultReceiveBufferSizePredictor}.
+     * predictor is {@link AdaptiveReceiveBufferSizePredictor}.
      */
     void setReceiveBufferSizePredictor(ReceiveBufferSizePredictor predictor);
 }
\ No newline at end of file

File: src/main/java/org/jboss/netty/example/http/HttpClientPipelineFactory.java
Patch:
@@ -43,7 +43,7 @@ public HttpClientPipelineFactory(HttpResponseHandler handler) {
     public ChannelPipeline getPipeline() throws Exception {
         // Create a default pipeline implementation.
         ChannelPipeline pipeline = pipeline();
-        pipeline.addLast("decoder", new HttpResponseDecoder(8192, 8192, 8192));
+        pipeline.addLast("decoder", new HttpResponseDecoder());
         //pipeline.addLast("aggregator", new HttpChunkAggregator(1048576));
         pipeline.addLast("encoder", new HttpRequestEncoder());
         pipeline.addLast("handler", handler);

File: src/main/java/org/jboss/netty/example/http/HttpServerPipelineFactory.java
Patch:
@@ -44,7 +44,7 @@ public ChannelPipeline getPipeline() throws Exception {
         // Create a default pipeline implementation.
         ChannelPipeline pipeline = pipeline();
 
-        pipeline.addLast("decoder", new HttpRequestDecoder(8192, 8192, 8192));
+        pipeline.addLast("decoder", new HttpRequestDecoder());
         //pipeline.addLast("aggregator", new HttpChunkAggregator(1048576));
         pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("handler", handler);

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseStatus.java
Patch:
@@ -152,7 +152,7 @@ public int compareTo(HttpResponseStatus o) {
 
     @Override
     public String toString() {
-        StringBuilder buf = new StringBuilder(reasonPhrase + 5);
+        StringBuilder buf = new StringBuilder(reasonPhrase.length() + 5);
         buf.append(code);
         buf.append(' ');
         buf.append(reasonPhrase);

File: src/main/java/org/jboss/netty/example/http/HttpServerPipelineFactory.java
Patch:
@@ -44,7 +44,7 @@ public ChannelPipeline getPipeline() throws Exception {
         // Create a default pipeline implementation.
         ChannelPipeline pipeline = pipeline();
 
-        pipeline.addLast("decoder", new HttpRequestDecoder(8192));
+        pipeline.addLast("decoder", new HttpRequestDecoder(8192, 8192, 8192));
         pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("handler", handler);
         return pipeline;

File: src/main/java/org/jboss/netty/example/http/HttpServerPipelineFactory.java
Patch:
@@ -44,7 +44,7 @@ public ChannelPipeline getPipeline() throws Exception {
         // Create a default pipeline implementation.
         ChannelPipeline pipeline = pipeline();
 
-        pipeline.addLast("decoder", new HttpRequestDecoder(false));
+        pipeline.addLast("decoder", new HttpRequestDecoder(8192));
         pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("handler", handler);
         return pipeline;

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.TreeMap;
 
 import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.util.CaseIgnoringComparator;
 
 /**
@@ -42,7 +43,7 @@ public class DefaultHttpMessage implements HttpMessage {
 
     private final HttpVersion version;
     private final Map<String, List<String>> headers = new TreeMap<String, List<String>>(CaseIgnoringComparator.INSTANCE);
-    private ChannelBuffer content;
+    private ChannelBuffer content = ChannelBuffers.EMPTY_BUFFER;
 
     protected DefaultHttpMessage(final HttpVersion version) {
         this.version = version;

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java
Patch:
@@ -37,8 +37,8 @@ public HttpRequestDecoder() {
         super();
     }
 
-    public HttpRequestDecoder(boolean mergeChunks) {
-        super(mergeChunks);
+    public HttpRequestDecoder(int maxChunkSize) {
+        super(maxChunkSize);
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java
Patch:
@@ -37,8 +37,8 @@ public HttpResponseDecoder() {
         super();
     }
 
-    public HttpResponseDecoder(boolean mergeChunks) {
-        super(mergeChunks);
+    public HttpResponseDecoder(int maxChunkSize) {
+        super(maxChunkSize);
     }
 
     @Override

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -88,7 +88,8 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
         else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
             DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
-            channel.writeBuffer.offer(event);
+            boolean offered = channel.writeBuffer.offer(event);
+            assert offered;
             channel.flushWriteBuffer();
         }
     }

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -109,7 +109,8 @@ private void handleAcceptedChannel(ChannelEvent e) {
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
             DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
-            channel.writeBuffer.offer(event);
+            boolean offered = channel.writeBuffer.offer(event);
+            assert offered;
             channel.flushWriteBuffer();
         }
     }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -134,7 +134,8 @@ private void handleAcceptedSocket(ChannelEvent e) {
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
             NioSocketChannel channel = (NioSocketChannel) event.getChannel();
-            channel.writeBuffer.offer(event);
+            boolean offered = channel.writeBuffer.offer(event);
+            assert offered;
             NioWorker.write(channel, true);
         }
     }

File: src/main/java/org/jboss/netty/channel/xnio/XnioClientChannelSink.java
Patch:
@@ -141,7 +141,8 @@ public void notify(
             if (xnioChannel instanceof GatheringByteChannel ||
                 xnioChannel instanceof MultipointWritableMessageChannel ||
                 xnioChannel instanceof WritableMessageChannel) {
-                channel.writeBuffer.offer(event);
+                boolean offered = channel.writeBuffer.offer(event);
+                assert offered;
                 if (xnioChannel instanceof SuspendableWriteChannel) {
                     ((SuspendableWriteChannel) xnioChannel).resumeWrites();
                 }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -53,7 +53,6 @@ public abstract class HttpMessageDecoder extends ReplayingDecoder<HttpMessageDec
     private volatile ChannelBuffer content;
     private volatile int chunkSize;
 
-
     /**
      * @author The Netty Project (netty-dev@lists.jboss.org)
      * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/handler/codec/embedder/AbstractCodecEmbedder.java
Patch:
@@ -135,7 +135,8 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) {
 
         private void handleEvent(ChannelEvent e) {
             if (e instanceof MessageEvent) {
-                productQueue.offer(((MessageEvent) e).getMessage());
+                boolean offered = productQueue.offer(((MessageEvent) e).getMessage());
+                assert offered;
             } else if (e instanceof ExceptionEvent) {
                 throw new CodecEmbedderException(((ExceptionEvent) e).getCause());
             }

File: src/main/java/org/jboss/netty/buffer/CompositeChannelBuffer.java
Patch:
@@ -220,7 +220,7 @@ public int getBytes(int index, GatheringByteChannel out, int length)
             throws IOException {
         // XXX Gathering write is not supported because of a known issue.
         //     See http://bugs.sun.com/view_bug.do?bug_id=6210541
-        return out.write(toByteBuffer());
+        return out.write(toByteBuffer(index, length));
     }
 
     public void getBytes(int index, OutputStream out, int length)

File: src/main/java/org/jboss/netty/container/spring/NettyResourceFactory.java
Patch:
@@ -60,7 +60,7 @@ public synchronized void destroy() {
         unterminatableExecutor = null;
     }
 
-    public Executor getChannelFactoryExecutor() {
+    public synchronized Executor getChannelFactoryExecutor() {
         return unterminatableExecutor;
     }
 }

File: src/main/java/org/jboss/netty/container/microcontainer/NettyResourceFactory.java
Patch:
@@ -63,7 +63,7 @@ public synchronized void destroy() {
         unterminatableExecutor = null;
     }
 
-    public Executor getChannelFactoryExecutor() {
+    public synchronized Executor getChannelFactoryExecutor() {
         return unterminatableExecutor;
     }
 }

File: src/main/java/org/jboss/netty/buffer/DynamicChannelBuffer.java
Patch:
@@ -275,7 +275,7 @@ private void ensureWritableBytes(int requestedBytes) {
         }
 
         ChannelBuffer newBuffer = factory().getBuffer(order(), newCapacity);
-        newBuffer.writeBytes(buffer, readerIndex(), readableBytes());
+        newBuffer.writeBytes(buffer, 0, writerIndex());
         buffer = newBuffer;
     }
 }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannelConfig.java
Patch:
@@ -56,8 +56,6 @@
  * @author Trustin Lee (tlee@redhat.com)
  *
  * @version $Rev$, $Date$
- *
- * @apiviz.has org.jboss.netty.channel.socket.nio.ReceiveBufferSizePredictor
  */
 public interface NioSocketChannelConfig extends SocketChannelConfig {
 

File: src/main/java/org/jboss/netty/channel/xnio/XnioChannelConfig.java
Patch:
@@ -53,8 +53,6 @@
  * @author Trustin Lee (tlee@redhat.com)
  *
  * @version $Rev$, $Date$
- *
- * @apiviz.has org.jboss.netty.channel.socket.nio.ReceiveBufferSizePredictor
  */
 public interface XnioChannelConfig extends ChannelConfig {
 

File: src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java
Patch:
@@ -80,7 +80,7 @@ public synchronized boolean isDone() {
     }
 
     public synchronized boolean isSuccess() {
-        return cause == null;
+        return done && cause == null;
     }
 
     public synchronized Throwable getCause() {

File: src/main/java/org/jboss/netty/handler/codec/serialization/CompatibleObjectDecoder.java
Patch:
@@ -85,7 +85,6 @@ protected Object decode(
         case READ_HEADER:
             oin = newObjectInputStream(bin);
             checkpoint(CompatibleObjectDecoderState.READ_OBJECT);
-            return null;
         case READ_OBJECT:
             return oin.readObject();
         default:

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -92,11 +92,9 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
             } finally {
                 checkpoint();
             }
-            return null;
         }
         case READ_INITIAL: {
             readInitial(buffer);
-            return null;
         }
         case READ_HEADER: {
             readHeaders(buffer);
@@ -137,10 +135,10 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
             chunkSize = getChunkSize(line);
             if (chunkSize == 0) {
                 checkpoint(State.READ_CHUNK_FOOTER);
+                return null;
             } else {
                 checkpoint(State.READ_CHUNKED_CONTENT);
             }
-            return null;
         }
         case READ_CHUNKED_CONTENT: {
             if (mergeChunks) {

File: src/main/java/org/jboss/netty/example/http/HttpClient.java
Patch:
@@ -35,7 +35,7 @@
 import org.jboss.netty.handler.codec.http.HttpMethod;
 import org.jboss.netty.handler.codec.http.HttpRequest;
 import org.jboss.netty.handler.codec.http.HttpVersion;
-import org.jboss.netty.handler.codec.http.HttpCookieEncoder;
+import org.jboss.netty.handler.codec.http.CookieEncoder;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -91,7 +91,7 @@ public static void main(String[] args) throws Exception {
         HttpRequest request = new DefaultHttpRequest(
                 HttpVersion.HTTP_1_0, HttpMethod.GET, uri.toASCIIString());
         request.addHeader(HttpHeaders.Names.HOST, host);
-        HttpCookieEncoder httpCookieEncoder = new HttpCookieEncoder();
+        CookieEncoder httpCookieEncoder = new CookieEncoder();
         httpCookieEncoder.addCookie("my-cookie", "foo");
         httpCookieEncoder.addCookie("another-cookie", "bar");
         request.addHeader(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());

File: src/main/java/org/jboss/netty/example/http/LocalTransportRegister.java
Patch:
@@ -37,8 +37,6 @@
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
  * @version $Rev$, $Date$
- *
- * FIXME: Better name
  */
 public class LocalTransportRegister {
 

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -114,21 +114,21 @@ private void decodeParams(String s) {
         String[] params = s.split("&");
         for (String param : params) {
             String[] split = param.split("=");
-            String key = decodeComponent(split[0]);
+            String key = decodeComponent(split[0], charset);
             List<String> values = this.params.get(key);
             if(values == null) {
                 values = new ArrayList<String>();
                 this.params.put(key,values);
             }
             if (split.length > 1) {
-                values.add(decodeComponent(split[1]));
+                values.add(decodeComponent(split[1], charset));
             } else {
                 values.add("");
             }
         }
     }
 
-    private String decodeComponent(String s) {
+    static String decodeComponent(String s, String charset) {
         try {
             return URLDecoder.decode(s, charset);
         } catch (UnsupportedEncodingException e) {

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -81,9 +81,9 @@ public String toString() {
             StringBuilder sb = new StringBuilder(uri).append("?");
             for (int i = 0; i < params.size(); i++) {
                 Param param = params.get(i);
-                sb.append(encodeComponent(param.name));
+                sb.append(encodeComponent(param.name, charset));
                 sb.append("=");
-                sb.append(encodeComponent(param.value));
+                sb.append(encodeComponent(param.value, charset));
                 if(i != params.size() - 1) {
                     sb.append("&");
                 }
@@ -92,7 +92,7 @@ public String toString() {
         }
     }
 
-    private String encodeComponent(String s) {
+    static String encodeComponent(String s, String charset) {
         try {
             return URLEncoder.encode(s, charset).replaceAll("\\+", "%20");
         } catch (UnsupportedEncodingException e) {

File: src/main/java/org/jboss/netty/handler/codec/http/CookieEncoder.java
Patch:
@@ -34,7 +34,6 @@
  */
 public class CookieEncoder {
 
-    // TODO: Add domain, path, maxAge, and version (and perhaps secure and comment?)
     private final Map<String, Cookie> cookies = new TreeMap<String, Cookie>(CaseIgnoringComparator.INSTANCE);
 
     public void addCookie(String name, String val) {
@@ -46,6 +45,9 @@ public void addCookie(Cookie cookie) {
     }
 
     public String encode() {
+        // FIXME: Support both version 0 and 1 cookies
+        // FIXME: Encode all cookie fields, including domain, path, maxAge, secure, and comment.
+        // FIXME: Check RFC 2109 - http://www.ietf.org/rfc/rfc2109.txt
         StringBuffer sb = new StringBuffer();
         Collection<String> cookieNames = cookies.keySet();
         if(cookieNames.isEmpty()) {

File: src/main/java/org/jboss/netty/channel/xnio/XnioClientChannelSink.java
Patch:
@@ -49,7 +49,7 @@
  */
 final class XnioClientChannelSink extends AbstractChannelSink {
 
-    private static final XnioChannelHandler HANDLER = new XnioChannelHandler();
+    private static final XnioClientChannelHandler HANDLER = new XnioClientChannelHandler();
 
     XnioClientChannelSink() {
         super();

File: src/main/java/org/jboss/netty/channel/UnfailingChannelFuture.java
Patch:
@@ -48,6 +48,6 @@ public UnfailingChannelFuture(Channel channel, boolean cancellable) {
 
     @Override
     public boolean setFailure(Throwable cause) {
-        throw new IllegalStateException("Can not fail");
+        throw new IllegalStateException("Can not fail", cause);
     }
 }

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketServerBootstrapTest.java
Patch:
@@ -41,6 +41,7 @@
 import org.jboss.netty.channel.ChannelPipelineException;
 import org.jboss.netty.channel.ChannelPipelineFactory;
 import org.jboss.netty.channel.ChildChannelStateEvent;
+import org.jboss.netty.channel.ServerChannelFactory;
 import org.jboss.netty.channel.SimpleChannelHandler;
 import org.jboss.netty.channel.socket.SocketChannelConfig;
 import org.jboss.netty.util.DummyHandler;
@@ -159,13 +160,13 @@ public void testFailedPipelineInitialization() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void shouldHaveLocalAddressOption() {
-        new ServerBootstrap(createMock(ChannelFactory.class)).bind();
+        new ServerBootstrap(createMock(ServerChannelFactory.class)).bind();
     }
 
 
     @Test(expected = NullPointerException.class)
     public void shouldDisallowNullLocalAddressParameter() {
-        new ServerBootstrap(createMock(ChannelFactory.class)).bind(null);
+        new ServerBootstrap(createMock(ServerChannelFactory.class)).bind(null);
     }
 
     @ChannelPipelineCoverage("all")

File: src/test/java/org/jboss/netty/bootstrap/BootstrapTest.java
Patch:
@@ -55,7 +55,7 @@ public void shouldNotReturnNullFactory() {
 
     @Test(expected = IllegalStateException.class)
     public void shouldNotAllowInitialFactoryToChange() {
-        new Bootstrap(createMock(ChannelFactory.class)).setFactory(null);
+        new Bootstrap(createMock(ChannelFactory.class)).setFactory(createMock(ChannelFactory.class));
     }
 
     @Test

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingContextListener.java
Patch:
@@ -26,7 +26,7 @@
 
 import org.jboss.netty.bootstrap.ClientBootstrap;
 import org.jboss.netty.channel.ChannelFactory;
-import org.jboss.netty.channel.local.LocalClientChannelFactory;
+import org.jboss.netty.channel.local.DefaultLocalClientChannelFactory;
 
 /**
  * A context listener that creates a client bootstrap that uses a local channel factory. The local channel factory should
@@ -50,7 +50,7 @@ public class HttpTunnelingContextListener implements ServletContextListener {
 
     static final String BOOTSTRAP_PROP = "bootstrap";
 
-    private final ChannelFactory factory = new LocalClientChannelFactory();
+    private final ChannelFactory factory = new DefaultLocalClientChannelFactory();
 
     public void contextInitialized(ServletContextEvent context) {
         context.getServletContext().setAttribute(BOOTSTRAP_PROP, new ClientBootstrap(factory));

File: src/main/java/org/jboss/netty/example/http/LocalTransportRegister.java
Patch:
@@ -24,8 +24,8 @@
 import org.jboss.netty.bootstrap.ServerBootstrap;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
+import org.jboss.netty.channel.local.DefaultLocalServerChannelFactory;
 import org.jboss.netty.channel.local.LocalAddress;
-import org.jboss.netty.channel.local.LocalServerChannelFactory;
 import org.jboss.netty.example.echo.EchoHandler;
 
 /**
@@ -42,7 +42,7 @@
  */
 public class LocalTransportRegister {
 
-    private final ChannelFactory factory = new LocalServerChannelFactory();
+    private final ChannelFactory factory = new DefaultLocalServerChannelFactory();
     private volatile Channel serverChannel;
 
     public void start() {

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelFactory.java
Patch:
@@ -21,7 +21,6 @@
  */
 package org.jboss.netty.channel.local;
 
-import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
 import org.jboss.netty.channel.ChannelPipeline;
 import org.jboss.netty.channel.ChannelSink;
@@ -40,7 +39,7 @@ public LocalClientChannelFactory() {
         sink = new LocalClientChannelSink();
     }
 
-    public Channel newChannel(ChannelPipeline pipeline) {
+    public LocalChannel newChannel(ChannelPipeline pipeline) {
         return new DefaultLocalChannel(null, this, pipeline, sink, null);
     }
 

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -115,12 +115,12 @@ private void bind(DefaultLocalChannel channel, ChannelFuture future, LocalAddres
 
     private void connect(DefaultLocalChannel channel, ChannelFuture future, LocalAddress remoteAddress) {
         Channel remoteChannel = LocalChannelRegistry.getChannel(remoteAddress);
-        if (!(remoteChannel instanceof LocalServerChannel)) {
+        if (!(remoteChannel instanceof DefaultLocalServerChannel)) {
             future.setFailure(new ConnectException("connection refused"));
             return;
         }
 
-        LocalServerChannel serverChannel = (LocalServerChannel) remoteChannel;
+        DefaultLocalServerChannel serverChannel = (DefaultLocalServerChannel) remoteChannel;
         ChannelPipeline pipeline;
         try {
             pipeline = serverChannel.getConfig().getPipelineFactory().getPipeline();

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelFactory.java
Patch:
@@ -21,7 +21,6 @@
  */
 package org.jboss.netty.channel.local;
 
-import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
 import org.jboss.netty.channel.ChannelPipeline;
 import org.jboss.netty.channel.ChannelSink;
@@ -40,8 +39,8 @@ public LocalServerChannelFactory() {
         super();
     }
 
-    public Channel newChannel(ChannelPipeline pipeline) {
-        return new LocalServerChannel(this, pipeline, sink);
+    public LocalServerChannel newChannel(ChannelPipeline pipeline) {
+        return new DefaultLocalServerChannel(this, pipeline, sink);
     }
 
     public void releaseExternalResources() {

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelFactory.java
Patch:
@@ -41,7 +41,7 @@ public LocalClientChannelFactory() {
     }
 
     public Channel newChannel(ChannelPipeline pipeline) {
-        return new LocalClientChannel(this, pipeline, sink, null);
+        return new DefaultLocalChannel(null, this, pipeline, sink, null);
     }
 
     public void releaseExternalResources() {

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -50,7 +50,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
         if (channel instanceof LocalServerChannel) {
             handleServerChannel(e);
         }
-        else if (channel instanceof AbstractLocalChannel) {
+        else if (channel instanceof DefaultLocalChannel) {
             handleAcceptedChannel(e);
         }
     }
@@ -85,7 +85,7 @@ private void handleServerChannel(ChannelEvent e) {
     private void handleAcceptedChannel(ChannelEvent e) {
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
-            AbstractLocalChannel channel = (AbstractLocalChannel) event.getChannel();
+            DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -108,7 +108,7 @@ private void handleAcceptedChannel(ChannelEvent e) {
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            AbstractLocalChannel channel = (AbstractLocalChannel) event.getChannel();
+            DefaultLocalChannel channel = (DefaultLocalChannel) event.getChannel();
             channel.writeBuffer.offer(event);
             channel.flushWriteBuffer();
         }

File: src/main/java/org/jboss/netty/channel/local/LocalAcceptedChannel.java
Patch:
@@ -31,10 +31,10 @@
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
-final class LocalAcceptedChannel extends LocalChannel {
+final class LocalAcceptedChannel extends AbstractLocalChannel {
     LocalAcceptedChannel(LocalServerChannel parent, ChannelFactory factory,
             ChannelPipeline pipeline, ChannelSink sink,
-            LocalChannel pairedChannel) {
+            AbstractLocalChannel pairedChannel) {
         super(parent, factory, pipeline, sink, pairedChannel);
     }
 }

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannel.java
Patch:
@@ -31,10 +31,10 @@
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
-final class LocalClientChannel extends LocalChannel {
+final class LocalClientChannel extends AbstractLocalChannel {
     LocalClientChannel(ChannelFactory factory,
             ChannelPipeline pipeline, ChannelSink sink,
-            LocalChannel pairedChannel) {
+            AbstractLocalChannel pairedChannel) {
         super(null, factory, pipeline, sink, pairedChannel);
     }
 }

File: src/main/java/org/jboss/netty/channel/local/LocalServerChannelSink.java
Patch:
@@ -50,7 +50,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
         if (channel instanceof LocalServerChannel) {
             handleServerChannel(e);
         }
-        else if (channel instanceof LocalChannel) {
+        else if (channel instanceof AbstractLocalChannel) {
             handleAcceptedChannel(e);
         }
     }
@@ -85,7 +85,7 @@ private void handleServerChannel(ChannelEvent e) {
     private void handleAcceptedChannel(ChannelEvent e) {
         if (e instanceof ChannelStateEvent) {
             ChannelStateEvent event = (ChannelStateEvent) e;
-            LocalChannel channel = (LocalChannel) event.getChannel();
+            AbstractLocalChannel channel = (AbstractLocalChannel) event.getChannel();
             ChannelFuture future = event.getFuture();
             ChannelState state = event.getState();
             Object value = event.getValue();
@@ -108,7 +108,7 @@ private void handleAcceptedChannel(ChannelEvent e) {
             }
         } else if (e instanceof MessageEvent) {
             MessageEvent event = (MessageEvent) e;
-            LocalChannel channel = (LocalChannel) event.getChannel();
+            AbstractLocalChannel channel = (AbstractLocalChannel) event.getChannel();
             channel.writeBuffer.offer(event);
             channel.flushWriteBuffer();
         }

File: src/main/java/org/jboss/netty/example/http/LocalTransportRegister.java
Patch:
@@ -37,6 +37,8 @@
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
  * @version $Rev$, $Date$
+ *
+ * FIXME: Better name
  */
 public class LocalTransportRegister {
 

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelAddress.java
Patch:
@@ -25,8 +25,10 @@
 import java.net.URI;
 
 /**
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
+ * @version $Rev$, $Date$
  */
 public class HttpTunnelAddress extends SocketAddress implements Comparable<HttpTunnelAddress> {
 

File: src/main/java/org/jboss/netty/example/http/HttpTunnelingClientExample.java
Patch:
@@ -82,7 +82,9 @@
    </servlet-mapping>
 </web-app>
 
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @version $Rev$, $Date$
  */
 public class HttpTunnelingClientExample {
     public static void main(String[] args) throws Exception {

File: src/main/java/org/jboss/netty/example/http/LocalTransportRegister.java
Patch:
@@ -34,7 +34,9 @@
  * <bean name="org.jboss.netty.example.servlet.LocalTransportRegister"
         class="org.jboss.netty.example.servlet.LocalTransportRegister" />
  *
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @version $Rev$, $Date$
  */
 public class LocalTransportRegister {
 

File: src/main/java/org/jboss/netty/example/local/LocalExample.java
Patch:
@@ -41,7 +41,9 @@
 import org.jboss.netty.handler.codec.string.StringEncoder;
 
 /**
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @version $Rev$, $Date$
  */
 public class LocalExample {
     public static void main(String[] args) throws Exception {

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCookie.java
Patch:
@@ -22,8 +22,10 @@
 package org.jboss.netty.handler.codec.http;
 
 /**
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
+ * @version $Rev$, $Date$
  */
 public class HttpCookie implements Comparable<HttpCookie> {
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCookieDecoder.java
Patch:
@@ -27,7 +27,9 @@
 import org.jboss.netty.util.CaseIgnoringComparator;
 
 /**
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @version $Rev$, $Date$
  */
 public class HttpCookieDecoder {
     private final static String semicolon = ";";

File: src/main/java/org/jboss/netty/handler/codec/http/HttpCookieEncoder.java
Patch:
@@ -28,7 +28,9 @@
 import org.jboss.netty.util.CaseIgnoringComparator;
 
 /**
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
+ * @version $Rev$, $Date$
  */
 public class HttpCookieEncoder {
 

File: src/main/java/org/jboss/netty/util/CaseIgnoringComparator.java
Patch:
@@ -25,8 +25,10 @@
 import java.util.Comparator;
 
 /**
- * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
+ * @author The Netty Project (netty-dev@lists.jboss.org)
+ * @author Andy Taylor (andy.taylor@jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
+ * @version $Rev$, $Date$
  */
 public final class CaseIgnoringComparator implements Comparator<String>, Serializable {
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpHeaders.java
Patch:
@@ -46,6 +46,7 @@ public static final class Names {
         public static final String CONTENT_MD5 = "Content-MD5";
         public static final String CONTENT_RANGE = "Content-Range";
         public static final String CONTENT_TYPE= "Content-Type";
+        public static final String COOKIE = "Cookie";
         public static final String DATE = "Date";
         public static final String ETAG = "ETag";
         public static final String EXPECT = "Expect";
@@ -67,6 +68,7 @@ public static final class Names {
         public static final String REFERER = "Referer";
         public static final String RETRY_AFTER = "Retry-After";
         public static final String SERVER = "Server";
+        public static final String SET_COOKIE = "Set-Cookie";
         public static final String TE = "TE";
         public static final String TRAILER = "Trailer";
         public static final String TRANSFER_ENCODING = "Transfer-Encoding";

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -258,7 +258,6 @@ private void readHeaders(ChannelBuffer buffer) {
     }
 
     protected abstract boolean isDecodingRequest();
-    protected abstract String getCookieHeaderName();
     protected abstract void readInitial(ChannelBuffer buffer) throws Exception;
 
     private int getChunkSize(String hex) {

File: src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelClientSocketChannelFactory.java
Patch:
@@ -22,7 +22,6 @@
  */
 package org.jboss.netty.channel.socket.http;
 
-import java.net.URL;
 import java.util.concurrent.Executor;
 
 import org.jboss.netty.channel.ChannelPipeline;

File: src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java
Patch:
@@ -49,6 +49,7 @@ protected void encodeInitialLine(ChannelBuffer buf, HttpMessage message) throws
         buf.writeBytes(CRLF);
     }
 
+    @Override
     public byte[] getCookieHeaderName() {
         return COOKIE_HEADER;
     }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpResponseEncoder.java
Patch:
@@ -47,7 +47,8 @@ protected void encodeInitialLine(ChannelBuffer buf, HttpMessage message) {
         buf.writeBytes(CRLF);
     }
 
+    @Override
     public byte[] getCookieHeaderName() {
-            return COOKIE_HEADER;
-        }
+        return COOKIE_HEADER;
+    }
 }

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.UUID;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -94,7 +93,7 @@ public Channel find(Integer id) {
 
     @Override
     public boolean contains(Object o) {
-        if (o instanceof UUID) {
+        if (o instanceof Integer) {
             return nonServerChannels.containsKey(o) || serverChannels.containsKey(o);
         } else if (o instanceof Channel) {
             Channel c = (Channel) o;
@@ -123,7 +122,7 @@ public boolean add(Channel channel) {
     @Override
     public boolean remove(Object o) {
         Channel c = null;
-        if (o instanceof UUID) {
+        if (o instanceof Integer) {
             c = nonServerChannels.remove(o);
             if (c == null) {
                 c = serverChannels.remove(o);

File: src/main/java/org/jboss/netty/channel/Channel.java
Patch:
@@ -24,7 +24,6 @@
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.util.UUID;
 
 
 /**
@@ -92,9 +91,9 @@ public interface Channel extends Comparable<Channel>{
     static int OP_READ_WRITE = OP_READ | OP_WRITE;
 
     /**
-     * Returns the {@link UUID} of this channel.
+     * Returns the unique integer ID of this channel.
      */
-    UUID getId();
+    Integer getId();
 
     /**
      * Returns the {@link ChannelFactory} which created this channel.

File: src/main/java/org/jboss/netty/channel/DefaultExceptionEvent.java
Patch:
@@ -69,6 +69,6 @@ public Throwable getCause() {
 
     @Override
     public String toString() {
-        return getChannel().toString() + " - (EXCEPTION: " + cause + ')';
+        return getChannel().toString() + " EXCEPTION: " + cause;
     }
 }

File: src/main/java/org/jboss/netty/channel/DefaultWriteCompletionEvent.java
Patch:
@@ -70,9 +70,8 @@ public String toString() {
         String channelString = getChannel().toString();
         StringBuilder buf = new StringBuilder(channelString.length() + 32);
         buf.append(channelString);
-        buf.append(" - (WRITTEN_AMOUNT: ");
+        buf.append(" WRITTEN_AMOUNT: ");
         buf.append(getWrittenAmount());
-        buf.append(')');
         return buf.toString();
     }
 }

File: src/main/java/org/jboss/netty/channel/group/ChannelGroup.java
Patch:
@@ -24,7 +24,6 @@
 
 import java.net.SocketAddress;
 import java.util.Set;
-import java.util.UUID;
 
 import org.jboss.netty.channel.Channel;
 
@@ -38,7 +37,7 @@
  */
 public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
     String getName();
-    Channel find(UUID id);
+    Channel find(Integer id);
     ChannelGroupFuture setInterestOps(int interestOps);
     ChannelGroupFuture setReadable(boolean readable);
     ChannelGroupFuture write(Object message);

File: src/main/java/org/jboss/netty/channel/group/ChannelGroupFuture.java
Patch:
@@ -22,7 +22,6 @@
  */
 package org.jboss.netty.channel.group;
 
-import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 
 import org.jboss.netty.channel.Channel;
@@ -39,7 +38,7 @@ public interface ChannelGroupFuture extends Iterable<ChannelFuture>{
 
     ChannelGroup getGroup();
 
-    ChannelFuture find(UUID channelId);
+    ChannelFuture find(Integer channelId);
     ChannelFuture find(Channel channel);
 
     /**

File: src/main/java/org/jboss/netty/handler/timeout/DefaultIdleStateEvent.java
Patch:
@@ -73,9 +73,9 @@ public long getLastActivityTimeMillis() {
 
     @Override
     public String toString() {
-        return getChannel().toString() + " - (" + getState() + " since " +
+        return getChannel().toString() + ' ' + getState() + " since " +
                DateFormat.getDateTimeInstance(
                        DateFormat.SHORT, DateFormat.SHORT, Locale.US).format(
-                               new Date(getLastActivityTimeMillis())) + ')';
+                               new Date(getLastActivityTimeMillis()));
     }
 }

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -237,7 +237,7 @@ public void run(Timeout timeout) throws Exception {
                 writerIdleTimeout =
                     timer.newTimeout(this, writerIdleTimeMillis, TimeUnit.MILLISECONDS);
                 try {
-                    channelIdle(ctx, IdleState.WRITER_IDLE, lastReadTime);
+                    channelIdle(ctx, IdleState.WRITER_IDLE, lastWriteTime);
                 } catch (Throwable t) {
                     fireExceptionCaught(ctx, t);
                 }
@@ -271,7 +271,7 @@ public void run(Timeout timeout) throws Exception {
                 allIdleTimeout =
                     timer.newTimeout(this, allIdleTimeMillis, TimeUnit.MILLISECONDS);
                 try {
-                    channelIdle(ctx, IdleState.ALL_IDLE, lastReadTime);
+                    channelIdle(ctx, IdleState.ALL_IDLE, lastIoTime);
                 } catch (Throwable t) {
                     fireExceptionCaught(ctx, t);
                 }

File: src/main/java/org/jboss/netty/handler/codec/base64/Base64.java
Patch:
@@ -75,7 +75,7 @@ private static final boolean breakLines(Base64Dialect dialect) {
         if (dialect == null) {
             throw new NullPointerException("dialect");
         }
-        return breakLines(dialect);
+        return dialect.breakLinesByDefault;
     }
 
     public static ChannelBuffer encode(ChannelBuffer src) {

File: src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -300,7 +300,8 @@ public void channelOpen(
             // Apply parent options.
             evt.getChannel().getConfig().setOptions(parentOptions);
 
-            futureQueue.offer(evt.getChannel().bind(localAddress));
+            boolean finished = futureQueue.offer(evt.getChannel().bind(localAddress));
+            assert finished;
             ctx.sendUpstream(evt);
         }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -240,7 +240,8 @@ public void run() {
                     try {
                         level = autodetectWithoutTimeout();
                     } finally {
-                        resultQueue.offer(Integer.valueOf(level));
+                        boolean finished = resultQueue.offer(Integer.valueOf(level));
+                        assert finished;
                     }
                 }
             }, "NIO constraint level detector");

File: src/main/java/org/jboss/netty/example/factorial/FactorialClientHandler.java
Patch:
@@ -106,7 +106,8 @@ public void messageReceived(
             // Offer the answer after closing the connection.
             e.getChannel().close().addListener(new ChannelFutureListener() {
                 public void operationComplete(ChannelFuture future) {
-                    answer.offer((BigInteger) e.getMessage());
+                    boolean offered = answer.offer((BigInteger) e.getMessage());
+                    assert offered;
                 }
             });
         }

File: src/main/java/org/jboss/netty/example/localtime/LocalTimeClientHandler.java
Patch:
@@ -119,7 +119,8 @@ public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e)
     @Override
     public void messageReceived(
             ChannelHandlerContext ctx, final MessageEvent e) {
-        answer.offer((LocalTimes) e.getMessage());
+        boolean offered = answer.offer((LocalTimes) e.getMessage());
+        assert offered;
     }
 
     @Override

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -92,9 +92,11 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
             } finally {
                 checkpoint();
             }
+            return null;
         }
         case READ_INITIAL: {
             readInitial(buffer);
+            return null;
         }
         case READ_HEADER: {
             readHeaders(buffer);
@@ -135,10 +137,10 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
             chunkSize = getChunkSize(line);
             if (chunkSize == 0) {
                 checkpoint(State.READ_CHUNK_FOOTER);
-                return null;
             } else {
                 checkpoint(State.READ_CHUNKED_CONTENT);
             }
+            return null;
         }
         case READ_CHUNKED_CONTENT: {
             if (mergeChunks) {

File: src/main/java/org/jboss/netty/handler/codec/serialization/CompatibleObjectDecoder.java
Patch:
@@ -85,6 +85,7 @@ protected Object decode(
         case READ_HEADER:
             oin = newObjectInputStream(bin);
             checkpoint(CompatibleObjectDecoderState.READ_OBJECT);
+            return null;
         case READ_OBJECT:
             return oin.readObject();
         default:

File: src/main/java/org/jboss/netty/channel/socket/servlet/ServletClientSocketChannel.java
Patch:
@@ -193,7 +193,6 @@ public void sendChunk(ChannelBuffer a) throws IOException {
             if (closed) {
                 throw e;
             }
-            lock.lock();
             if (lock.tryLock()) {
                 try {
                     connectAndSendHeaders(true, getRemoteAddress());

File: src/main/java/org/jboss/netty/channel/group/DefaultChannelGroup.java
Patch:
@@ -283,6 +283,7 @@ public int compareTo(ChannelGroup o) {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + '(' + name + ')';
+        return getClass().getSimpleName() +
+               "(name: " + getName() + ", size: " + size() + ')';
     }
 }

File: src/main/java/org/jboss/netty/channel/ChannelLocal.java
Patch:
@@ -24,7 +24,7 @@
 
 import java.util.concurrent.ConcurrentMap;
 
-import org.jboss.netty.util.ConcurrentIdentityWeakHashMap;
+import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -35,7 +35,7 @@
  */
 public class ChannelLocal<T> {
     private final ConcurrentMap<Channel, T> map =
-        new ConcurrentIdentityWeakHashMap<Channel, T>();
+        new ConcurrentIdentityWeakKeyHashMap<Channel, T>();
 
     /**
      * Creates a {@link Channel} local variable.

File: src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java
Patch:
@@ -37,6 +37,7 @@
  */
 public class ChannelGroupFactory {
 
+    // FIXME: Memory leak - use ConcurrentWeakValueHashMap
     private static final ConcurrentMap<String, ChannelGroup> groups =
         new ConcurrentHashMap<String, ChannelGroup>();
 

File: src/main/java/org/jboss/netty/channel/local/LocalAddress.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.jboss.netty.channel.ChannelException;
-import org.jboss.netty.util.ConcurrentWeakHashMap;
+import org.jboss.netty.util.ConcurrentHashMap;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -37,8 +37,9 @@
 public final class LocalAddress extends SocketAddress implements Comparable<LocalAddress> {
     private static final long serialVersionUID = -3601961747680808645L;
 
+    // FIXME: Memory leak - use ConcurrentWeakValueHashMap
     private static final ConcurrentMap<String, LocalAddress> addresses =
-        new ConcurrentWeakHashMap<String, LocalAddress>();
+        new ConcurrentHashMap<String, LocalAddress>();
 
     private static final AtomicInteger nextEphemeralPort = new AtomicInteger();
 

File: src/main/java/org/jboss/netty/handler/execution/DefaultObjectSizeEstimator.java
Patch:
@@ -31,7 +31,7 @@
 
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.util.ConcurrentHashMap;
+import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;
 
 /**
  * The default {@link ObjectSizeEstimator} implementation for general purpose.
@@ -45,7 +45,7 @@
 public class DefaultObjectSizeEstimator implements ObjectSizeEstimator {
 
     private final ConcurrentMap<Class<?>, Integer> class2size =
-        new ConcurrentHashMap<Class<?>, Integer>();
+        new ConcurrentIdentityWeakKeyHashMap<Class<?>, Integer>();
 
     /**
      * Creates a new instance.

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -63,9 +63,9 @@ public class IdleStateHandler extends SimpleChannelUpstreamHandler
 
     public IdleStateHandler(
             Timer timer,
-            long readerIdleTimeSeconds,
-            long writerIdleTimeSeconds,
-            long allIdleTimeSeconds) {
+            int readerIdleTimeSeconds,
+            int writerIdleTimeSeconds,
+            int allIdleTimeSeconds) {
 
         this(timer,
              readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds,

File: src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -51,7 +51,7 @@ public class ReadTimeoutHandler extends SimpleChannelUpstreamHandler implements
     private volatile ReadTimeoutTask task;
     volatile long lastReadTime;
 
-    public ReadTimeoutHandler(Timer timer, long timeoutSeconds) {
+    public ReadTimeoutHandler(Timer timer, int timeoutSeconds) {
         this(timer, timeoutSeconds, TimeUnit.SECONDS);
     }
 

File: src/main/java/org/jboss/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -48,7 +48,7 @@ public class WriteTimeoutHandler extends SimpleChannelDownstreamHandler implemen
     private final Timer timer;
     private final long timeoutMillis;
 
-    public WriteTimeoutHandler(Timer timer, long timeoutSeconds) {
+    public WriteTimeoutHandler(Timer timer, int timeoutSeconds) {
         this(timer, timeoutSeconds, TimeUnit.SECONDS);
     }
 

File: src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
Patch:
@@ -144,6 +144,7 @@ private void initialize(ChannelHandlerContext ctx) {
         lastReadTime = lastWriteTime = System.currentTimeMillis();
         readerIdleTimeoutTask = new ReaderIdleTimeoutTask(ctx);
         writerIdleTimeoutTask = new WriterIdleTimeoutTask(ctx);
+        allIdleTimeoutTask = new AllIdleTimeoutTask(ctx);
         if (readerIdleTimeMillis > 0) {
             readerIdleTimeout = timer.newTimeout(
                     readerIdleTimeoutTask, readerIdleTimeMillis, TimeUnit.MILLISECONDS);

File: src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -49,8 +49,8 @@ public class ReadTimeoutHandler extends SimpleChannelUpstreamHandler implements
     private volatile ReadTimeoutTask task;
     volatile long lastReadTime;
 
-    public ReadTimeoutHandler(Timer timer, long timeoutMillis) {
-        this(timer, timeoutMillis, TimeUnit.MILLISECONDS);
+    public ReadTimeoutHandler(Timer timer, long timeoutSeconds) {
+        this(timer, timeoutSeconds, TimeUnit.SECONDS);
     }
 
     public ReadTimeoutHandler(Timer timer, long timeout, TimeUnit unit) {

File: src/main/java/org/jboss/netty/handler/timeout/WriteTimeoutHandler.java
Patch:
@@ -46,8 +46,8 @@ public class WriteTimeoutHandler extends SimpleChannelDownstreamHandler implemen
     private final Timer timer;
     private final long timeoutMillis;
 
-    public WriteTimeoutHandler(Timer timer, long timeoutMillis) {
-        this(timer, timeoutMillis, TimeUnit.MILLISECONDS);
+    public WriteTimeoutHandler(Timer timer, long timeoutSeconds) {
+        this(timer, timeoutSeconds, TimeUnit.SECONDS);
     }
 
     public WriteTimeoutHandler(Timer timer, long timeout, TimeUnit unit) {

File: src/main/java/org/jboss/netty/handler/timeout/IdlenessEvent.java
Patch:
@@ -30,6 +30,5 @@
  * @version $Rev$, $Date$
  */
 public interface IdlenessEvent extends ChannelEvent {
-    boolean isReaderIdle();
-    boolean isWriterIdle();
+    // This is a tag interface.
 }

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessage.java
Patch:
@@ -57,6 +57,8 @@ public interface HttpMessage {
 
     int getContentLength();
 
+    int getContentLength(int defaultValue);
+
     void setContent(ChannelBuffer content);
 
     boolean isChunked();

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -180,8 +180,8 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe
                 }
             } else {
                 checkpoint(State.READ_CHUNK_FOOTER);
-                return null;
             }
+            return null;
         }
         default: {
             throw new Error("Shouldn't reach here.");

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpChunk.java
Patch:
@@ -38,7 +38,7 @@ public DefaultHttpChunk(ChannelBuffer content) {
         if (content == null) {
             throw new NullPointerException("content");
         }
-        last = content.readable();
+        last = !content.readable();
         this.content = content;
     }
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java
Patch:
@@ -224,7 +224,7 @@ private void readHeaders(ChannelBuffer buffer) {
     private int getChunkSize(String hex) {
         int delimPos = hex.indexOf(';');
         if (delimPos >= 0) {
-            hex = hex.substring(delimPos).trim();
+            hex = hex.substring(0, delimPos).trim();
         }
         return Integer.parseInt(hex, 16);
     }

File: src/main/java/org/jboss/netty/example/http/HttpClient.java
Patch:
@@ -89,7 +89,7 @@ public static void main(String[] args) throws Exception {
         // Send the HTTP request.
         HttpRequest request = new DefaultHttpRequest(
                 HttpVersion.HTTP_1_0, HttpMethod.GET, uri.toASCIIString());
-        request.addHeader(HttpHeaders.HOST, host);
+        request.addHeader(HttpHeaders.Names.HOST, host);
 
         channel.write(request);
 

File: src/main/java/org/jboss/netty/example/http/HttpRequestHandler.java
Patch:
@@ -63,7 +63,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
         String message = "and its hello from me";
         ChannelBuffer buf = ChannelBuffers.wrappedBuffer(message.getBytes());
         response.setContent(buf);
-        response.addHeader(HttpHeaders.CONTENT_LENGTH, String.valueOf(buf.writerIndex()));
+        response.addHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buf.writerIndex()));
         e.getChannel().write(response);
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/http/DefaultHttpMessage.java
Patch:
@@ -82,16 +82,16 @@ public void removeHeader(final String name) {
     }
 
     public int getContentLength() {
-        List<String> contentLength = headers.get(HttpHeaders.CONTENT_LENGTH);
+        List<String> contentLength = headers.get(HttpHeaders.Names.CONTENT_LENGTH);
         if (contentLength != null && contentLength.size() > 0) {
             return Integer.valueOf(contentLength.get(0));
         }
         return 0;
     }
 
     public boolean isChunked() {
-        List<String> chunked = headers.get(HttpHeaders.TRANSFER_ENCODING.KEY);
-        return chunked != null && chunked.size() > 0 && chunked.get(0).equalsIgnoreCase(HttpHeaders.TRANSFER_ENCODING.CHUNKED);
+        List<String> chunked = headers.get(HttpHeaders.Names.TRANSFER_ENCODING);
+        return chunked != null && chunked.size() > 0 && chunked.get(0).equalsIgnoreCase(HttpHeaders.Values.CHUNKED);
     }
 
     public void clearHeaders() {

File: src/main/java/org/jboss/netty/servlet/NettyServlet.java
Patch:
@@ -37,7 +37,7 @@
 import org.jboss.netty.channel.MessageEvent;
 
 /**
- * A servlet that acts as a proxy for a netty channel
+ * A Servlet that acts as a proxy for a netty channel
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)

File: src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java
Patch:
@@ -318,7 +318,7 @@ private void waitForNextTick() {
                 }
 
                 try {
-                    Thread.sleep(sleepTime / 1000000, (int) (sleepTime % 1000000));
+                    Thread.sleep(sleepTime);
                 } catch (InterruptedException e) {
                     if (shutdown.get()) {
                         return;
@@ -401,10 +401,10 @@ public String toString() {
 
             buf.append("deadline: ");
             if (remaining > 0) {
-                buf.append(remaining / 1000000);
+                buf.append(remaining);
                 buf.append(" ms later, ");
             } else if (remaining < 0) {
-                buf.append(-remaining / 1000000);
+                buf.append(-remaining);
                 buf.append(" ms ago, ");
             } else {
                 buf.append("now, ");

File: src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java
Patch:
@@ -102,7 +102,7 @@ public HashedWheelTimer(
         iterators = createIterators(wheel);
         mask = wheel.length - 1;
 
-        // Convert checkInterval to nanoseconds.
+        // Convert tickDuration to milliseconds.
         this.tickDuration = tickDuration = unit.toMillis(tickDuration);
 
         // Prevent overflow.

File: src/main/java/org/jboss/netty/channel/local/LocalChannel.java
Patch:
@@ -41,7 +41,7 @@
  * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
  * @author Trustin Lee (tlee@redhat.com)
  */
-public class LocalChannel extends AbstractChannel {
+class LocalChannel extends AbstractChannel {
     private final ThreadLocal<Boolean> delivering = new ThreadLocal<Boolean>() {
         @Override
         protected Boolean initialValue() {

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelFactory.java
Patch:
@@ -39,7 +39,7 @@ public LocalClientChannelFactory() {
     }
 
     public Channel newChannel(ChannelPipeline pipeline) {
-        return new LocalChannel(null, this, pipeline, sink, null);
+        return new LocalClientChannel(this, pipeline, sink, null);
     }
 
     public void releaseExternalResources() {

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -129,7 +129,8 @@ private void connect(LocalChannel channel, ChannelFuture future, LocalAddress re
         }
 
         future.setSuccess();
-        LocalChannel acceptedChannel = new LocalChannel(serverChannel, serverChannel.getFactory(), pipeline, this, channel);
+        LocalChannel acceptedChannel = new LocalAcceptedChannel(
+                serverChannel, serverChannel.getFactory(), pipeline, this, channel);
         channel.pairedChannel = acceptedChannel;
 
         bind(channel, succeededFuture(channel), LocalAddress.newEphemeralInstance());

File: src/main/java/org/jboss/netty/channel/local/LocalChannel.java
Patch:
@@ -159,6 +159,7 @@ void flushWriteBuffer() {
 
                         e.getFuture().setSuccess();
                         fireMessageReceived(pairedChannel, e.getMessage());
+                        fireWriteComplete(this, 1);
                     }
                 } finally {
                     delivering.set(false);

File: src/main/java/org/jboss/netty/channel/local/LocalChannel.java
Patch:
@@ -71,7 +71,8 @@ public boolean isBound() {
     }
 
     public boolean isConnected() {
-        return pairedChannel != null;
+        return localAddress != null &&
+               pairedChannel != null && pairedChannel.localAddress != null;
     }
 
     public LocalAddress getLocalAddress() {

File: src/main/java/org/jboss/netty/channel/local/LocalChannel.java
Patch:
@@ -55,8 +55,8 @@ protected Boolean initialValue() {
     private final LocalChannelConfig config;
     final Queue<MessageEvent> writeBuffer = new LinkedTransferQueue<MessageEvent>();
 
-    LocalChannel(ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink, LocalChannel pairedChannel) {
-        super(null, factory, pipeline, sink);
+    LocalChannel(LocalServerChannel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink, LocalChannel pairedChannel) {
+        super(parent, factory, pipeline, sink);
         this.pairedChannel = pairedChannel;
         config = new LocalChannelConfig();
         fireChannelOpen(this);

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelFactory.java
Patch:
@@ -39,7 +39,7 @@ public LocalClientChannelFactory() {
     }
 
     public Channel newChannel(ChannelPipeline pipeline) {
-        return new LocalChannel(this, pipeline, sink, null);
+        return new LocalChannel(null, this, pipeline, sink, null);
     }
 
     public void releaseExternalResources() {

File: src/main/java/org/jboss/netty/channel/local/LocalClientChannelSink.java
Patch:
@@ -129,7 +129,7 @@ private void connect(LocalChannel channel, ChannelFuture future, LocalAddress re
         }
 
         future.setSuccess();
-        LocalChannel acceptedChannel = new LocalChannel(serverChannel.getFactory(), pipeline, this, channel);
+        LocalChannel acceptedChannel = new LocalChannel(serverChannel, serverChannel.getFactory(), pipeline, this, channel);
         channel.pairedChannel = acceptedChannel;
 
         bind(channel, succeededFuture(channel), LocalAddress.newEphemeralInstance());

File: src/main/java/org/jboss/netty/util/ConcurrentWeakHashMap.java
Patch:
@@ -46,8 +46,8 @@
 import java.util.concurrent.locks.ReentrantLock;
 
 /**
- * An alternative weak-key identity-comparing {@link ConcurrentMap} which is
- * similar to {@link java.util.concurrent.ConcurrentHashMap}.
+ * An alternative weak-key {@link ConcurrentMap} which is similar to
+ * {@link java.util.concurrent.ConcurrentHashMap}.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Doug Lea

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderBuffer.java
Patch:
@@ -178,7 +178,7 @@ public int hashCode() {
     }
 
     public int indexOf(int fromIndex, int toIndex, byte value) {
-        int endIndex = buffer.indexOf(buffer.readerIndex(), buffer.writerIndex(), value);
+        int endIndex = buffer.indexOf(fromIndex, toIndex, value);
         if (endIndex < 0) {
             throw REPLAY;
         }
@@ -187,7 +187,7 @@ public int indexOf(int fromIndex, int toIndex, byte value) {
 
     public int indexOf(int fromIndex, int toIndex,
             ChannelBufferIndexFinder indexFinder) {
-        int endIndex = buffer.indexOf(buffer.readerIndex(), buffer.writerIndex(), indexFinder);
+        int endIndex = buffer.indexOf(fromIndex, toIndex, indexFinder);
         if (endIndex < 0) {
             throw REPLAY;
         }

File: src/main/java/org/jboss/netty/handler/logging/LoggingHandler.java
Patch:
@@ -26,6 +26,7 @@
 import org.jboss.netty.channel.ChannelEvent;
 import org.jboss.netty.channel.ChannelHandler;
 import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipelineCoverage;
 import org.jboss.netty.channel.ChannelUpstreamHandler;
 import org.jboss.netty.channel.ExceptionEvent;
 import org.jboss.netty.logging.InternalLogger;
@@ -40,6 +41,7 @@
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
+@ChannelPipelineCoverage("all")
 public class LoggingHandler implements ChannelUpstreamHandler, ChannelDownstreamHandler {
 
     private final InternalLogger logger = InternalLoggerFactory.getInstance(getClass());

File: src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
Patch:
@@ -90,21 +90,21 @@ public void afterRemove(ChannelHandlerContext ctx) throws Exception {
     public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e)
             throws Exception {
         initialize(ctx);
-        super.channelOpen(ctx, e);
+        ctx.sendUpstream(e);
     }
 
     @Override
     public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e)
             throws Exception {
         destroy();
-        super.channelOpen(ctx, e);
+        ctx.sendUpstream(e);
     }
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             throws Exception {
         lastReadTime = System.nanoTime();
-        super.messageReceived(ctx, e);
+        ctx.sendUpstream(e);
     }
 
     private void initialize(ChannelHandlerContext ctx) {

File: src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannelFactory.java
Patch:
@@ -22,6 +22,7 @@
  */
 package org.jboss.netty.handler.codec.embedder;
 
+import org.jboss.netty.channel.AbstractChannelFactory;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
 import org.jboss.netty.channel.ChannelPipeline;
@@ -31,7 +32,7 @@
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
-class EmbeddedChannelFactory implements ChannelFactory {
+class EmbeddedChannelFactory extends AbstractChannelFactory {
 
     static final ChannelFactory INSTANCE = new EmbeddedChannelFactory();
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -201,7 +201,7 @@ private final class Boss implements Runnable {
         public void run() {
             for (;;) {
                 try {
-                    SocketChannel acceptedSocket = channel.socket.accept();
+                    SocketChannel acceptedSocket = channel.socket.socket().accept().getChannel();
                     try {
                         ChannelPipeline pipeline =
                             channel.getConfig().getPipelineFactory().getPipeline();

File: src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java
Patch:
@@ -74,7 +74,7 @@ public HashedWheelTimer(
         this(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);
     }
 
-        public HashedWheelTimer(ThreadFactory threadFactory) {
+    public HashedWheelTimer(ThreadFactory threadFactory) {
         this(threadFactory, 100, TimeUnit.MILLISECONDS, 512); // about 50 sec
     }
 

File: src/main/java/org/jboss/netty/util/TimeBasedUuidGenerator.java
Patch:
@@ -95,7 +95,7 @@ public class TimeBasedUuidGenerator {
 
             nodeKey.append(':');
             nodeKey.append(vmId);
-        } catch (Exception e) {
+        } catch (Throwable t) {
             // Perhaps running with a security manager (e.g. Applet) or on a
             // platform without the java.lang.management package (e.g. Android.)
             nodeKey.append(":?");

File: src/main/java/org/jboss/netty/channel/ChannelFactory.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.concurrent.Executor;
 
 import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
+import org.jboss.netty.util.ExternalResourceReleasable;
 
 
 /**
@@ -58,7 +59,7 @@
  * @apiviz.landmark
  * @apiviz.has        org.jboss.netty.channel.Channel oneway - - creates
  */
-public interface ChannelFactory {
+public interface ChannelFactory extends ExternalResourceReleasable {
 
     /**
      * Creates and opens a new {@link Channel} and attaches the specified

File: src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannelFactory.java
Patch:
@@ -44,6 +44,6 @@ public Channel newChannel(ChannelPipeline pipeline) {
     }
 
     public void releaseExternalResources() {
-        throw new UnsupportedOperationException();
+        // No external resources
     }
 }

File: src/main/java/org/jboss/netty/handler/execution/ExecutionHandler.java
Patch:
@@ -30,6 +30,7 @@
 import org.jboss.netty.channel.ChannelPipelineCoverage;
 import org.jboss.netty.channel.ChannelUpstreamHandler;
 import org.jboss.netty.util.ExecutorShutdownUtil;
+import org.jboss.netty.util.ExternalResourceReleasable;
 
 /**
  * Forwards an upstream {@link ChannelEvent} to an {@link Executor}.
@@ -61,7 +62,7 @@
  * @apiviz.has java.util.concurrent.ThreadPoolExecutor
  */
 @ChannelPipelineCoverage("all")
-public class ExecutionHandler implements ChannelUpstreamHandler {
+public class ExecutionHandler implements ChannelUpstreamHandler, ExternalResourceReleasable {
 
     private final Executor executor;
 
@@ -86,7 +87,7 @@ public Executor getExecutor() {
      * Shuts down the {@link Executor} which was specified with the constructor
      * and wait for its termination.
      */
-    public void terminateExecutor() {
+    public void releaseExternalResources() {
         ExecutorShutdownUtil.shutdown(getExecutor());
     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -267,6 +267,7 @@ private static void read(SelectionKey k) {
 
         if (preallocatedBuffer == null) {
             // TODO Magic number
+            // FIXME: OOPS - the new buffer should not be shared by more than one connection
             preallocatedBuffer = channel.getConfig().getBufferFactory().getBuffer(1048576);
         }
 

File: src/main/java/org/jboss/netty/channel/group/ChannelGroup.java
Patch:
@@ -34,7 +34,7 @@
  * @version $Rev$, $Date$
  *
  * @apiviz.landmark
- * @apiviz.has org.jboss.netty.group.ChannelGroupFuture oneway - - returns
+ * @apiviz.has org.jboss.netty.channel.group.ChannelGroupFuture oneway - - returns
  */
 public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
     String getName();

File: src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java
Patch:
@@ -32,7 +32,7 @@
  * @version $Rev$, $Date$
  *
  * @apiviz.landmark
- * @apiviz.has        org.jboss.netty.group.ChannelGroup oneway - - creates
+ * @apiviz.has        org.jboss.netty.channel.group.ChannelGroup oneway - - creates
  */
 public class ChannelGroupFactory {
 

File: src/main/java/org/jboss/netty/channel/group/ChannelGroupFuture.java
Patch:
@@ -33,7 +33,7 @@
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  *
- * @apiviz.owns org.jboss.netty.group.ChannelGroupFutureListener - - notifies
+ * @apiviz.owns org.jboss.netty.channel.group.ChannelGroupFutureListener - - notifies
  */
 public interface ChannelGroupFuture extends Iterable<ChannelFuture>{
 

File: src/main/java/org/jboss/netty/handler/codec/frame/LengthFieldPrepender.java
Patch:
@@ -80,14 +80,14 @@ protected Object encode(
         case 2:
             if (length >= 65536) {
                 throw new IllegalArgumentException(
-                        "length does not fit into a byte: " + length);
+                        "length does not fit into a short integer: " + length);
             }
             header.writeShort((short) length);
             break;
         case 3:
             if (length >= 16777216) {
                 throw new IllegalArgumentException(
-                        "length does not fit into a byte: " + length);
+                        "length does not fit into a medium integer: " + length);
             }
             header.writeMedium(length);
             break;

File: src/main/java/org/jboss/netty/handler/codec/frame/LengthFieldPrepender.java
Patch:
@@ -68,7 +68,7 @@ protected Object encode(
         ChannelBuffer body = (ChannelBuffer) msg;
 
         int length = lengthIncludesLengthFieldLength?
-                body.readableBytes() : body.readableBytes() + lengthFieldLength;
+                body.readableBytes() + lengthFieldLength : body.readableBytes();
         switch (lengthFieldLength) {
         case 1:
             header.writeByte((byte) length);

File: src/main/java/org/jboss/netty/example/localtime/LocalTimeServerHandler.java
Patch:
@@ -83,7 +83,7 @@ public void messageReceived(
                     setMonth(calendar.get(MONTH) + 1).
                     setDayOfMonth(calendar.get(DAY_OF_MONTH)).
                     setDayOfWeek(DayOfWeek.valueOf(calendar.get(DAY_OF_WEEK))).
-                    setHour(calendar.get(HOUR)).
+                    setHour(calendar.get(HOUR_OF_DAY)).
                     setMinute(calendar.get(MINUTE)).
                     setSecond(calendar.get(SECOND)).build());
         }

File: src/main/java/org/jboss/netty/handler/codec/frame/LengthFieldBasedFrameDecoder.java
Patch:
@@ -40,7 +40,7 @@ public class LengthFieldBasedFrameDecoder extends FrameDecoder {
 
     private final int maxFrameLength;
     private final int lengthFieldOffset;
-    private final int lengthFieldLength;
+    final int lengthFieldLength;
     private final int lengthFieldEndOffset;
     private final int lengthAdjustment;
     private volatile boolean discardingTooLongFrame;

File: src/main/java/org/jboss/netty/handler/codec/serialization/ObjectDecoderInputStream.java
Patch:
@@ -125,9 +125,6 @@ public Object readObject() throws ClassNotFoundException, IOException {
                     "data length too big: " + dataLen + " (max: " + maxObjectSize + ')');
         }
 
-        byte[] data = new byte[dataLen];
-        readFully(data);
-
         return new CompactObjectInputStream(in, classLoader).readObject();
     }
 

File: src/main/java/org/jboss/netty/channel/LifeCycleAwareChannelHandler.java
Patch:
@@ -32,7 +32,7 @@
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
  */
-public interface LifeCycleAwareChannelHandler extends ChannelHandlerContext {
+public interface LifeCycleAwareChannelHandler extends ChannelHandler {
     void beforeAdd(ChannelHandlerContext ctx) throws Exception;
     void afterAdd(ChannelHandlerContext ctx) throws Exception;
     void beforeRemove(ChannelHandlerContext ctx) throws Exception;

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -338,7 +338,7 @@ private void close(SelectionKey k) {
         }
     }
 
-    private final class RegisterTask implements Runnable {
+    private static final class RegisterTask implements Runnable {
         private final Boss boss;
         private final NioSocketChannel channel;
 

File: src/main/java/org/jboss/netty/handler/codec/http/HttpVersion.java
Patch:
@@ -36,12 +36,12 @@
  */
 public class HttpVersion implements Comparable<HttpVersion> {
 
+    private static final Pattern VERSION_PATTERN =
+        Pattern.compile("(\\S+)/(\\d+)\\.(\\d+)");
+
     public static final HttpVersion HTTP_1_0 = new HttpVersion("HTTP", 1, 0);
     public static final HttpVersion HTTP_1_1 = new HttpVersion("HTTP", 1, 1);
 
-    private static final Pattern VERSION_PATTERN =
-            Pattern.compile("(\\S+)/(\\d+)\\.(\\d+)");
-
     public static HttpVersion valueOf(String value) {
         value = value.toUpperCase();
         if (value.equals("HTTP/1.1")) {

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java
Patch:
@@ -176,6 +176,8 @@ private final class Boss implements Runnable {
         }
 
         void register(NioSocketChannel channel) {
+            // FIXME: Infinite loop on selector creation failure.
+            // Apply the same fix with what's applied in NioWorker.register()
             boolean firstChannel = started.compareAndSet(false, true);
             Selector selector;
             if (firstChannel) {
@@ -312,6 +314,7 @@ private void connect(SelectionKey k) {
         }
 
         private void close(SelectionKey k) {
+            k.cancel();
             NioSocketChannel ch = (NioSocketChannel) k.attachment();
             NioWorker.close(ch, ch.getSucceededFuture());
         }

File: src/main/java/org/jboss/netty/buffer/DirectChannelBufferFactory.java
Patch:
@@ -66,7 +66,7 @@ public static ChannelBufferFactory getInstance(ByteOrder endianness) {
 
     private final Object bigEndianLock = new Object();
     private final Object littleEndianLock = new Object();
-    private final int preallocatedBufferCapacity = 1048576;
+    private final int preallocatedBufferCapacity = 1048576; // FIXME Magic number
     private ChannelBuffer preallocatedBigEndianBuffer = null;
     private int preallocatedBigEndianBufferPosition;
     private ChannelBuffer preallocatedLittleEndianBuffer = null;

File: src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -267,6 +267,7 @@ public ChannelBuffer readBytes(int length) {
         if (length == 0) {
             return ChannelBuffers.EMPTY_BUFFER;
         }
+        // TODO: Allow a user to specify the buffer factory as an overloaded method.
         ChannelBuffer buf = ChannelBuffers.buffer(order(), length);
         buf.writeBytes(this, readerIndex, length);
         readerIndex += length;
@@ -278,7 +279,7 @@ public ChannelBuffer readBytes(ChannelBufferIndexFinder endIndexFinder) {
         if (endIndex < 0) {
             throw new NoSuchElementException();
         }
-        return readBytes(endIndex);
+        return readBytes(endIndex - readerIndex);
     }
 
     public ChannelBuffer readSlice(int length) {
@@ -292,7 +293,7 @@ public ChannelBuffer readSlice(ChannelBufferIndexFinder endIndexFinder) {
         if (endIndex < 0) {
             throw new NoSuchElementException();
         }
-        return readSlice(endIndex);
+        return readSlice(endIndex - readerIndex);
     }
 
     public void readBytes(byte[] dst, int dstIndex, int length) {

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderBuffer.java
Patch:
@@ -57,7 +57,7 @@ public int capacity() {
     public void clear() {
         reject();
     }
-    
+
     @Override
     public boolean equals(Object obj) {
         return this == obj;
@@ -255,7 +255,7 @@ public ChannelBuffer readBytes(ChannelBufferIndexFinder endIndexFinder) {
         if (endIndex < 0) {
             throw REPLAY;
         }
-        return readBytes(endIndex);
+        return buffer.readBytes(endIndex - buffer.readerIndex());
     }
 
     public int readBytes(GatheringByteChannel out, int length)
@@ -275,7 +275,7 @@ public ChannelBuffer readSlice(
         if (endIndex < 0) {
             throw REPLAY;
         }
-        return readSlice(endIndex);
+        return buffer.readSlice(endIndex - buffer.readerIndex());
     }
 
     public ChannelBuffer readSlice(int length) {

File: src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -267,7 +267,7 @@ public ChannelBuffer readBytes(int length) {
         if (length == 0) {
             return ChannelBuffers.EMPTY_BUFFER;
         }
-        ChannelBuffer buf = ChannelBuffers.buffer(length);
+        ChannelBuffer buf = ChannelBuffers.buffer(order(), length);
         buf.writeBytes(this, readerIndex, length);
         readerIndex += length;
         return buf;

File: src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java
Patch:
@@ -30,6 +30,8 @@
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
+ *
+ * @apiviz.landmark
  */
 public class DecoderEmbedder<T> extends AbstractCodecEmbedder<T> {
 

File: src/main/java/org/jboss/netty/handler/codec/embedder/EncoderEmbedder.java
Patch:
@@ -30,6 +30,8 @@
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
  * @version $Rev$, $Date$
+ *
+ * @apiviz.landmark
  */
 public class EncoderEmbedder<T> extends AbstractCodecEmbedder<T> {
 

File: src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java
Patch:
@@ -38,7 +38,7 @@ public DecoderEmbedder(ChannelUpstreamHandler handler) {
     }
 
     public boolean offer(Object input) {
-        fireMessageReceived(context, context.getChannel(), input);
-        return !context.productQueue.isEmpty();
+        fireMessageReceived(getChannel(), input);
+        return !super.isEmpty();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannel.java
Patch:
@@ -27,6 +27,7 @@
 import org.jboss.netty.channel.AbstractChannel;
 import org.jboss.netty.channel.ChannelConfig;
 import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelSink;
 
 /**
  * @author The Netty Project (netty-dev@lists.jboss.org)
@@ -38,9 +39,8 @@ class EmbeddedChannel extends AbstractChannel {
     private final SocketAddress localAddress = new EmbeddedSocketAddress();
     private final SocketAddress remoteAddress = new EmbeddedSocketAddress();
 
-    EmbeddedChannel(
-            EmbeddedChannelHandlerContext context, ChannelPipeline pipeline) {
-        super(null, EmbeddedChannelFactory.INSTANCE, pipeline, context);
+    EmbeddedChannel(ChannelPipeline pipeline, ChannelSink sink) {
+        super(null, EmbeddedChannelFactory.INSTANCE, pipeline, sink);
     }
 
     public ChannelConfig getConfig() {

File: src/main/java/org/jboss/netty/handler/codec/embedder/AbstractCodecEmbedder.java
Patch:
@@ -55,7 +55,7 @@ public boolean finish() {
         fireChannelDisconnected(context, channel);
         fireChannelUnbound(context, channel);
         fireChannelClosed(context, channel);
-        return context.productQueue.isEmpty();
+        return !context.productQueue.isEmpty();
     }
 
     @SuppressWarnings("unchecked")

File: src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java
Patch:
@@ -38,7 +38,7 @@ public DecoderEmbedder(ChannelUpstreamHandler handler) {
     }
 
     public boolean offer(Object input) {
-        fireMessageReceived(context.getChannel(), input);
-        return context.productQueue.isEmpty();
+        fireMessageReceived(context, context.getChannel(), input);
+        return !context.productQueue.isEmpty();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/embedder/EncoderEmbedder.java
Patch:
@@ -41,6 +41,6 @@ public EncoderEmbedder(ChannelDownstreamHandler handler) {
     public boolean offer(Object input) {
         Channel channel = context.getChannel();
         write(context, channel, succeededFuture(channel), input);
-        return context.productQueue.isEmpty();
+        return !context.productQueue.isEmpty();
     }
 }

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -88,9 +88,9 @@
  * <h3>How does this work?</h3>
  * <p>
  * {@link ReplayingDecoder} passes a specialized {@link ChannelBuffer}
- * implementation which throws a {@link Error} of certain type when there's not
+ * implementation which throws an {@link Error} of certain type when there's not
  * enough data in the buffer.  In the {@code IntegerHeaderFrameDecoder} above,
- * you just assumed that there will be more than 4 bytes in the buffer when
+ * you just assumed that there will be 4 or more bytes in the buffer when
  * you call {@code buf.readInt()}.  If there's really 4 bytes in the buffer,
  * it will return the integer header as you expected.  Otherwise, the
  * {@link Error} will be raised and the control will be returned to

File: src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java
Patch:
@@ -103,7 +103,7 @@
  * {@link ClientBootstrap} instances as you want to apply different settings
  * for different {@link Channel}s.
  *
- * TODO: Show how to shut down a service using ChannelFactoryResource.release().
+ * TODO: Show how to shut down a service.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -137,7 +137,7 @@
  * {@link ServerBootstrap} instances as you want to apply different settings
  * for different {@link Channel}s.
  *
- * TODO: Show how to shut down a service using ChannelFactoryResource.release().
+ * TODO: Show how to shut down a service.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/channel/socket/nio/DefaultNioSocketChannelConfig.java
Patch:
@@ -44,8 +44,8 @@ class DefaultNioSocketChannelConfig extends DefaultSocketChannelConfig
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(DefaultNioSocketChannelConfig.class);
 
-    private volatile int writeBufferHighWaterMark = 256 * 1024;
-    private volatile int writeBufferLowWaterMark  = 128 * 1024;
+    private volatile int writeBufferHighWaterMark = 64 * 1024;
+    private volatile int writeBufferLowWaterMark  = 32 * 1024;
     private volatile ReceiveBufferSizePredictor predictor =
         new DefaultReceiveBufferSizePredictor();
     private volatile int writeSpinCount = 16;

File: src/main/java/org/jboss/netty/example/discard/DiscardClient.java
Patch:
@@ -69,6 +69,7 @@ public static void main(String[] args) throws Exception {
         ClientBootstrap bootstrap = new ClientBootstrap(factory);
         DiscardClientHandler handler = new DiscardClientHandler(firstMessageSize);
 
+        //bootstrap.getPipeline().addLast("executor", new ExecutionHandler(new MemoryAwareThreadPoolExecutor(16, 0, 0)));
         bootstrap.getPipeline().addLast("handler", handler);
         bootstrap.setOption("tcpNoDelay", true);
         bootstrap.setOption("keepAlive", true);
@@ -80,6 +81,6 @@ public static void main(String[] args) throws Exception {
         future.getChannel().getCloseFuture().awaitUninterruptibly();
 
         // Shut down thread pools to exit.
-        factory.getExternalResource().release();
+        factory.releaseExternalResources();
     }
 }

File: src/main/java/org/jboss/netty/example/factorial/FactorialClient.java
Patch:
@@ -87,6 +87,6 @@ public static void main(String[] args) throws Exception {
                 "Factorial of %,d is: %,d", count, handler.getFactorial());
 
         // Shut down all thread pools to exit.
-        factory.getExternalResource().release();
+        factory.releaseExternalResources();
     }
 }

File: src/main/java/org/jboss/netty/example/http/HttpClient.java
Patch:
@@ -82,7 +82,7 @@ public static void main(String[] args) throws Exception {
         Channel channel = future.awaitUninterruptibly().getChannel();
         if (!future.isSuccess()) {
             future.getCause().printStackTrace();
-            factory.getExternalResource().release();
+            factory.releaseExternalResources();
             return;
         }
 
@@ -95,6 +95,6 @@ public static void main(String[] args) throws Exception {
         channel.getCloseFuture().awaitUninterruptibly();
 
         // Shut down executor threads to exit.
-        factory.getExternalResource().release();
+        factory.releaseExternalResources();
     }
 }
\ No newline at end of file

File: src/main/java/org/jboss/netty/example/securechat/SecureChatClient.java
Patch:
@@ -78,7 +78,7 @@ public static void main(String[] args) throws Exception {
         Channel channel = future.awaitUninterruptibly().getChannel();
         if (!future.isSuccess()) {
             future.getCause().printStackTrace();
-            factory.getExternalResource().release();
+            factory.releaseExternalResources();
             return;
         }
 
@@ -103,6 +103,6 @@ public static void main(String[] args) throws Exception {
         channel.close().awaitUninterruptibly();
 
         // Shut down all thread pools to exit.
-        factory.getExternalResource().release();
+        factory.releaseExternalResources();
     }
 }

File: src/main/java/org/jboss/netty/example/telnet/TelnetClient.java
Patch:
@@ -76,7 +76,7 @@ public static void main(String[] args) throws Exception {
         Channel channel = future.awaitUninterruptibly().getChannel();
         if (!future.isSuccess()) {
             future.getCause().printStackTrace();
-            factory.getExternalResource();
+            factory.releaseExternalResources();
             return;
         }
 
@@ -103,6 +103,6 @@ public static void main(String[] args) throws Exception {
         channel.close().awaitUninterruptibly();
 
         // Shut down all thread pools to exit.
-        factory.getExternalResource().release();
+        factory.releaseExternalResources();
     }
 }

File: src/test/java/org/jboss/netty/channel/socket/NioClientSocketShutdownTimeTest.java
Patch:
@@ -85,7 +85,7 @@ public void testShutdownTime() throws Throwable {
 
             f.getChannel().close().awaitUninterruptibly();
         } finally {
-            b.getFactory().getExternalResource().release();
+            b.getFactory().releaseExternalResources();
 
             try {
                 serverSocket.close();

File: src/test/java/org/jboss/netty/channel/socket/NioServerSocketShutdownTimeTest.java
Patch:
@@ -106,7 +106,7 @@ public void testSuccessfulBindAttempt() throws Exception {
                 }
             }
             channel.close().awaitUninterruptibly();
-            bootstrap.getFactory().getExternalResource().release();
+            bootstrap.getFactory().releaseExternalResources();
         }
 
         long shutdownTime = System.currentTimeMillis() - startTime;

File: src/main/java/org/jboss/netty/example/http/HttpClient.java
Patch:
@@ -40,6 +40,8 @@
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Andy Taylor (andy.taylor@jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
+ *
+ * @version $Rev$, $Date$
  */
 public class HttpClient {
 

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringDecoder.java
Patch:
@@ -77,7 +77,7 @@ private void decode() {
         path = split[0];
         decodeParams(split[1]);
     }
-    //todo - just replacing spaces at the minute, should we check for all characters or leave this to the user?
+
     private void decodeParams(String s) {
         String[] params = s.split("&");
         for (String param : params) {
@@ -92,6 +92,7 @@ private void decodeParams(String s) {
         }
     }
 
+    // FIXME Use URLDecoder or something equivalent
     private String removeSpaceDelimeters(String s) {
         return s.replaceAll("%20", " ");
     }

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -67,6 +67,7 @@ public URI toUri() throws URISyntaxException {
         }
     }
 
+    // FIXME Use URLEncoder or something equivalent
     private String replaceSpaces(String s) {
         return s.replaceAll(" ", "%20");
     }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -265,7 +265,6 @@ public void run() {
         }
 
         int autodetectWithoutTimeout() {
-            // TODO Code cleanup - what a mess.
             final int constraintLevel;
             ExecutorService executor = Executors.newCachedThreadPool();
             boolean success;

File: src/main/java/org/jboss/netty/handler/codec/http/QueryStringEncoder.java
Patch:
@@ -71,12 +71,12 @@ private String replaceSpaces(String s) {
         return s.replaceAll(" ", "%20");
     }
 
-    class Param {
-        final String name;
+    private static class Param {
 
+        final String name;
         final String value;
 
-        public Param(String name, String value) {
+        Param(String name, String value) {
             this.value = value;
             this.name = name;
         }

File: src/main/java/org/jboss/netty/util/LinkedTransferQueue.java
Patch:
@@ -128,8 +128,8 @@ public class LinkedTransferQueue<E> extends AbstractQueue<E> implements Blocking
     private static final class QNode extends AtomicReference<Object> {
         private static final long serialVersionUID = 5925596372370723938L;
 
-        volatile QNode next;
-        volatile Thread waiter;       // to control park/unpark
+        transient volatile QNode next;
+        transient volatile Thread waiter;       // to control park/unpark
         final boolean isData;
         QNode(Object item, boolean isData) {
             super(item);

File: src/test/java/org/jboss/netty/handler/ssl/AbstractSocketSslEchoTest.java
Patch:
@@ -155,6 +155,9 @@ public void testSslEcho() throws Throwable {
         hf.awaitUninterruptibly();
         if (!hf.isSuccess()) {
             logger.error("Handshake failed", hf.getCause());
+            sh.channel.close().awaitUninterruptibly();
+            ch.channel.close().awaitUninterruptibly();
+            sc.close().awaitUninterruptibly();
         }
 
         assertTrue(hf.isSuccess());

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -273,14 +273,13 @@ public ChannelFuture handshake(Channel channel) throws SSLException {
             if (handshaking) {
                 return this.handshakeFuture;
             } else {
+                engine.beginHandshake();
                 handshakeFuture = this.handshakeFuture = newHandshakeFuture(channel);
                 handshaking = true;
             }
         }
 
-        ChannelHandlerContext ctx = context(channel);
-        engine.beginHandshake();
-        wrapNonAppData(ctx, channel);
+        wrapNonAppData(context(channel), channel);
         return handshakeFuture;
     }
 

File: src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java
Patch:
@@ -50,8 +50,8 @@ public class DefaultChannelFuture implements ChannelFuture {
     private final Channel channel;
     private final boolean cancellable;
 
-    private ChannelFutureListener firstListener;
-    private List<ChannelFutureListener> otherListeners;
+    private volatile ChannelFutureListener firstListener;
+    private volatile List<ChannelFutureListener> otherListeners;
     private boolean done;
     private Throwable cause;
     private int waiters;

File: src/main/java/org/jboss/netty/channel/DefaultChannelPipeline.java
Patch:
@@ -412,6 +412,7 @@ public void sendDownstream(ChannelEvent e) {
                 return;
             } catch (Throwable t) {
                 notifyHandlerException(e, t);
+                return;
             }
         }
 

File: src/main/java/org/jboss/netty/example/discard/ThroughputMonitor.java
Patch:
@@ -53,7 +53,7 @@ public void run() {
             long newCounter = handler.getTransferredBytes();
             System.err.format(
                     "%4.3f MiB/s%n",
-                    (newCounter - oldCounter) * 1000 / (endTime - startTime) /
+                    (newCounter - oldCounter) * 1000.0 / (endTime - startTime) /
                     1048576.0);
             oldCounter = newCounter;
             startTime = endTime;

File: src/main/java/org/jboss/netty/example/echo/ThroughputMonitor.java
Patch:
@@ -53,7 +53,7 @@ public void run() {
             long newCounter = handler.getTransferredBytes();
             System.err.format(
                     "%4.3f MiB/s%n",
-                    (newCounter - oldCounter) * 1000 / (endTime - startTime) /
+                    (newCounter - oldCounter) * 1000.0 / (endTime - startTime) /
                     1048576.0);
             oldCounter = newCounter;
             startTime = endTime;

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoderBuffer.java
Patch:
@@ -178,7 +178,7 @@ public int hashCode() {
     }
 
     public int indexOf(int fromIndex, int toIndex, byte value) {
-        int endIndex = indexOf(buffer.readerIndex(), buffer.writerIndex(), value);
+        int endIndex = buffer.indexOf(buffer.readerIndex(), buffer.writerIndex(), value);
         if (endIndex < 0) {
             throw REPLAY;
         }
@@ -187,7 +187,7 @@ public int indexOf(int fromIndex, int toIndex, byte value) {
 
     public int indexOf(int fromIndex, int toIndex,
             ChannelBufferIndexFinder indexFinder) {
-        int endIndex = indexOf(buffer.readerIndex(), buffer.writerIndex(), indexFinder);
+        int endIndex = buffer.indexOf(buffer.readerIndex(), buffer.writerIndex(), indexFinder);
         if (endIndex < 0) {
             throw REPLAY;
         }

File: src/main/java/org/jboss/netty/handler/ssl/SslBufferPool.java
Patch:
@@ -77,7 +77,6 @@ public SslBufferPool(int maxPoolSize) {
         if (maxPoolSize % MAX_PACKET_SIZE != 0) {
             maxBufferCount ++;
         }
-        maxPoolSize = maxBufferCount * MAX_PACKET_SIZE;
 
         pool = new ByteBuffer[maxBufferCount];
         this.maxBufferCount = maxBufferCount;

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -616,6 +616,8 @@ private ChannelBuffer unwrap(
                     break;
                 case FINISHED:
                     setHandshakeSuccess(channel);
+                    wrap(ctx, channel);
+                    break loop;
                 case NOT_HANDSHAKING:
                     wrap(ctx, channel);
                     break loop;

File: src/main/java/org/jboss/netty/util/LinkedTransferQueue.java
Patch:
@@ -128,7 +128,7 @@ private static final class QNode extends AtomicReference<Object> {
         private static final long serialVersionUID = 5925596372370723938L;
 
         volatile QNode next;
-        volatile Thread waiter;       // to control park/unpark
+        transient volatile Thread waiter;       // to control park/unpark
         final boolean isData;
 
         QNode(Object item, boolean isData) {

File: src/main/java/org/jboss/netty/buffer/CompositeChannelBuffer.java
Patch:
@@ -261,7 +261,7 @@ public void setMedium(int index, int value) {
         if (index + 3 <= indices[sliceId + 1]) {
             slices[sliceId].setMedium(index - indices[sliceId], value);
         } else if (order() == ByteOrder.BIG_ENDIAN) {
-            setShort(index, (short) (value >>> 8));
+            setShort(index, (short) (value >> 8));
             setByte(index + 2, (byte) value);
         } else {
             setShort(index    , (short) value);

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -104,7 +104,7 @@ public class ChannelBuffers {
     /**
      * A buffer whose capacity is {@code 0}.
      */
-    public static ChannelBuffer EMPTY_BUFFER = new BigEndianHeapChannelBuffer(0);
+    public static final ChannelBuffer EMPTY_BUFFER = new BigEndianHeapChannelBuffer(0);
 
     private static final char[] HEXDUMP_TABLE = new char[65536 * 4];
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -89,11 +89,14 @@ void register(NioSocketChannel channel, ChannelFuture future) {
         boolean firstChannel = started.compareAndSet(false, true);
         Selector selector;
         if (firstChannel) {
+            selectorGuard.writeLock().lock();
             try {
                 this.selector = selector = Selector.open();
             } catch (IOException e) {
                 throw new ChannelException(
                         "Failed to create a selector.", e);
+            } finally {
+                selectorGuard.writeLock().unlock();
             }
         } else {
             selector = this.selector;

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -39,7 +39,6 @@
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelDownstreamHandler;
 import org.jboss.netty.channel.ChannelEvent;
 import org.jboss.netty.channel.ChannelFuture;
 import org.jboss.netty.channel.ChannelFutureListener;
@@ -96,7 +95,7 @@
  * @apiviz.landmark
  * @apiviz.uses org.jboss.netty.handler.ssl.SslBufferPool
  */
-public class SslHandler extends FrameDecoder implements ChannelDownstreamHandler {
+public class SslHandler extends FrameDecoder {
 
     private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
 
@@ -293,6 +292,7 @@ private ChannelHandlerContext context(Channel channel) {
         return channel.getPipeline().getContext(getClass());
     }
 
+    @Override
     public void handleDownstream(
             final ChannelHandlerContext context, final ChannelEvent evt) throws Exception {
         if (evt instanceof ChannelStateEvent) {

File: src/main/java/org/jboss/netty/handler/codec/serialization/ObjectDecoder.java
Patch:
@@ -119,7 +119,7 @@ protected Object decode(
         }
 
         buffer.skipBytes(4);
-        return new CompactObjectInputStream(new ChannelBufferInputStream(
-                        buffer, dataLen), classLoader).readObject();
+        return new CompactObjectInputStream(
+                new ChannelBufferInputStream(buffer, dataLen), classLoader).readObject();
     }
 }

File: src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java
Patch:
@@ -50,9 +50,11 @@ abstract class NioSocketChannel extends AbstractChannel
     final SocketChannel socket;
     private final NioSocketChannelConfig config;
 
+    final Object interestOpsLock = new Object();
+    final Object writeLock = new Object();
+
     final AtomicBoolean writeTaskInTaskQueue = new AtomicBoolean();
     final Runnable writeTask = new WriteTask();
-    final Object writeLock = new Object();
     final Queue<MessageEvent> writeBuffer = new LinkedTransferQueue<MessageEvent>();
     MessageEvent currentWriteEvent;
     int currentWriteIndex;

File: src/main/java/org/jboss/netty/channel/socket/nio/DefaultReceiveBufferSizePredictor.java
Patch:
@@ -41,7 +41,7 @@ public class DefaultReceiveBufferSizePredictor implements
         ReceiveBufferSizePredictor {
     private static final int DEFAULT_MINIMUM = 256;
     private static final int DEFAULT_INITIAL = 1024;
-    private static final int DEFAULT_MAXIMUM = 1048576;
+    private static final int DEFAULT_MAXIMUM = 65536;
 
     private final int minimum;
     private final int maximum;

File: src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketChannelFactory.java
Patch:
@@ -62,8 +62,8 @@
  *
  * <ol>
  * <li>close all channels created by the factory,</li>
- * <li>call {@link ExecutorService#shutdownNow()} or {@link ExecutorService#shutdown()}
- *     for the {@code workerExecutor} which was specified to create the factory, and</li>
+ * <li>call {@link ExecutorService#shutdownNow()} for the executor which was
+ *     specified to create the factory, and</li>
  * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}
  *     until it returns {@code true}.</li>
  * </ol>

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketChannelFactory.java
Patch:
@@ -74,8 +74,8 @@
  * <ol>
  * <li>unbind all channels created by the factory,
  * <li>close all child channels accepted by the unbound channels,</li>
- * <li>call {@link ExecutorService#shutdownNow()} or {@link ExecutorService#shutdown()}
- *     for all executors which were specified to create the factory, and</li>
+ * <li>call {@link ExecutorService#shutdownNow()} for all executors which were
+ *     specified to create the factory, and</li>
  * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}
  *     until it returns {@code true}.</li>
  * </ol>

File: src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java
Patch:
@@ -48,7 +48,7 @@
 import org.jboss.netty.channel.SimpleChannelHandler;
 
 /**
- * A helper class which creates a new server-side {@link Channel} and accept
+ * A helper class which creates a new server-side {@link Channel} and accepts
  * incoming connections.
  *
  * <h3>Parent channel and its children</h3>
@@ -175,7 +175,7 @@ public void setParentHandler(ChannelHandler parentHandler) {
     }
 
     /**
-     * Creates a new channel which is bound to the local address which were
+     * Creates a new channel which is bound to the local address which was
      * specified in the current {@code "localAddress"} option.  This method is
      * similar to the following code:
      *

File: src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -538,7 +538,7 @@ public String toString() {
     }
 
     /**
-     * Throws an {@link IndexOutOfBoundsException} is the current
+     * Throws an {@link IndexOutOfBoundsException} if the current
      * {@linkplain #readableBytes() readable bytes} of this buffer is less
      * than the specified value.
      */

File: src/main/java/org/jboss/netty/channel/AbstractChannelSink.java
Patch:
@@ -42,7 +42,8 @@ protected AbstractChannelSink() {
     }
 
     /**
-     * Fires an {@link ExceptionEvent} upstream with the specified {@code cause}.
+     * Sends an {@link ExceptionEvent} upstream with the specified
+     * {@code cause}.
      *
      * @param event the {@link ChannelEvent} which caused a
      *              {@link ChannelHandler} to raise an exception

File: src/main/java/org/jboss/netty/channel/ChannelFutureListener.java
Patch:
@@ -37,7 +37,7 @@
 public interface ChannelFutureListener extends EventListener {
 
     /**
-     * An {@link ChannelFutureListener} that closes the {@link Channel} which is
+     * A {@link ChannelFutureListener} that closes the {@link Channel} which is
      * associated with the specified {@link ChannelFuture}.
      */
     static ChannelFutureListener CLOSE = new ChannelFutureListener() {

File: src/main/java/org/jboss/netty/channel/ChannelHandler.java
Patch:
@@ -23,7 +23,7 @@
 package org.jboss.netty.channel;
 
 /**
- * Handles or intercepts a {@link ChannelEvent}, and fires a
+ * Handles or intercepts a {@link ChannelEvent}, and sends a
  * {@link ChannelEvent} to the next or previous handler in a
  * {@link ChannelPipeline}.
  *
@@ -46,7 +46,7 @@
  * A {@link ChannelHandler} is provided with a {@link ChannelHandlerContext}
  * object.  The {@link ChannelHandler} is supposed to interact with the
  * {@link ChannelPipeline} it belongs to via the context object.  Using the
- * context object, the {@link ChannelHandler} can fire events to the next
+ * context object, the {@link ChannelHandler} can pass events to the next
  * or previous handler or modify the behavior of the pipeline by adding or
  * removing a handler for example.
  *

File: src/main/java/org/jboss/netty/channel/ChannelPipeline.java
Patch:
@@ -375,7 +375,7 @@ public interface ChannelPipeline {
 
 
     /**
-     * Fires the specified {@link ChannelEvent} to the first
+     * Sends the specified {@link ChannelEvent} to the first
      * {@link ChannelUpstreamHandler} in this pipeline.
      *
      * @throws NullPointerException
@@ -384,7 +384,7 @@ public interface ChannelPipeline {
     void sendUpstream(ChannelEvent e);
 
     /**
-     * Fires the specified {@link ChannelEvent} to the last
+     * Sends the specified {@link ChannelEvent} to the last
      * {@link ChannelDownstreamHandler} in this pipeline.
      *
      * @throws NullPointerException

File: src/main/java/org/jboss/netty/channel/ChannelPipelineCoverage.java
Patch:
@@ -61,7 +61,7 @@
  *         ChannelBuffer header = ChannelBuffers.buffer(4);
  *         header.writeInt(body.readableBytes());
  *
- *         // Create a message prepended with the header and fire a new event.
+ *         // Create a message prepended with the header and send a new event.
  *         ChannelBuffer message = ChannelBuffers.wrappedBuffer(header, body);
  *         Channels.fireMessageReceived(ctx, message, e.getRemoteAddress());
  *     }
@@ -94,7 +94,7 @@
  *         // Update the stateful property.
  *         messageId ++;
  *
- *         // Create a message prepended with the header and fire a new event.
+ *         // Create a message prepended with the header and send a new event.
  *         ChannelBuffer message = ChannelBuffers.wrappedBuffer(header, body);
  *         Channels.fireMessageReceived(ctx, message, e.getRemoteAddress());
  *     }

File: src/main/java/org/jboss/netty/channel/CompleteChannelFuture.java
Patch:
@@ -28,8 +28,8 @@
 import org.jboss.netty.logging.InternalLoggerFactory;
 
 /**
- * A skeletal {@link ChannelFuture} implementation which represents a future
- * which is complete (done) already.
+ * A skeletal {@link ChannelFuture} implementation which represents a
+ * {@link ChannelFuture} which has been completed already.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/channel/SimpleChannelHandler.java
Patch:
@@ -125,7 +125,7 @@ public void handleUpstream(
     }
 
     /**
-     * Invoked when a message object (e.g. {@link ChannelBuffer}) was received
+     * Invoked when a message object (e.g: {@link ChannelBuffer}) was received
      * from a remote peer.
      */
     public void messageReceived(

File: src/main/java/org/jboss/netty/channel/socket/nio/ReceiveBufferSizePredictor.java
Patch:
@@ -54,7 +54,7 @@ public interface ReceiveBufferSizePredictor {
     int nextReceiveBufferSize();
 
     /**
-     * Updates this predictor by telling the actual number of read bytes
+     * Updates this predictor by specifying the actual number of read bytes
      * in the previous read operation.
      *
      * @param previousReceiveBufferSize

File: src/main/java/org/jboss/netty/channel/socket/nio/package-info.java
Patch:
@@ -23,6 +23,6 @@
 
 /**
  * <a href="http://en.wikipedia.org/wiki/New_I/O">NIO</a>-based socket channel
- * API implementation - recommended for large number of connections (&gt;= 1000).
+ * API implementation - recommended for a large number of connections (&gt;= 1000).
  */
 package org.jboss.netty.channel.socket.nio;

File: src/main/java/org/jboss/netty/channel/socket/oio/package-info.java
Patch:
@@ -23,6 +23,6 @@
 
 /**
  * Old blocking I/O based socket channel API implementation - recommended for
- * small number of connections (&lt; 1000).
+ * a small number of connections (&lt; 1000).
  */
 package org.jboss.netty.channel.socket.oio;

File: src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoder.java
Patch:
@@ -192,7 +192,7 @@ public abstract class ReplayingDecoder<T extends Enum<T>> extends SimpleChannelH
     private volatile int checkpoint;
 
     /**
-     * Creates a new instance with no initial state (i.e. {@code null}).
+     * Creates a new instance with no initial state (i.e: {@code null}).
      */
     protected ReplayingDecoder() {
         this(null);

File: src/main/java/org/jboss/netty/handler/codec/replay/VoidEnum.java
Patch:
@@ -24,8 +24,8 @@
 
 /**
  * A placeholder {@link Enum} which could be specified as a type parameter of
- * {@link ReplayingDecoder} when a user wants to manage the decoder state by
- * oneself or there's no state to manage.
+ * {@link ReplayingDecoder} when a user wants to manage the decoder state or
+ * there's no state to manage.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)

File: src/main/java/org/jboss/netty/handler/execution/ObjectSizeEstimator.java
Patch:
@@ -23,7 +23,7 @@
 package org.jboss.netty.handler.execution;
 
 /**
- * Estimates the size of an object in byte unit.
+ * Estimates the size of an object in bytes.
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)
  * @author Trustin Lee (tlee@redhat.com)
@@ -34,7 +34,7 @@
 public interface ObjectSizeEstimator {
 
     /**
-     * Returns the estimated size of the specified object in byte unit.
+     * Returns the estimated size of the specified object in bytes.
      * This method must be implemented to return the same value for the same
      * object.  {@link MemoryAwareThreadPoolExecutor} and
      * {@link OrderedMemoryAwareThreadPoolExecutor} will malfunction otherwise.

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -257,7 +257,7 @@ public SSLEngine getEngine() {
     }
 
     /**
-     * Starts SSL / TLS handshake for the specified channel.
+     * Starts an SSL / TLS handshake for the specified channel.
      *
      * @return a {@link ChannelFuture} which is notified when the handshake
      *         succeeds or fails.
@@ -280,7 +280,7 @@ public ChannelFuture handshake(Channel channel) throws SSLException {
     }
 
     /**
-     * Sends a SSL {@code close_notify} message to the specified channel and
+     * Sends an SSL {@code close_notify} message to the specified channel and
      * destroys the underlying {@link SSLEngine}.
      */
     public ChannelFuture close(Channel channel) throws SSLException {

File: src/test/java/org/jboss/netty/handler/ssl/AbstractSocketSslEchoTest.java
Patch:
@@ -109,8 +109,8 @@ public void testSslEcho() throws Throwable {
         cse.setUseClientMode(true);
 
         // Workaround for blocking I/O transport write-write dead lock.
-        sb.setOption("receiveBuffer", 1048576);
-        sb.setOption("receiveBuffer", 1048576);
+        sb.setOption("receiveBufferSize", 1048576);
+        sb.setOption("receiveBufferSize", 1048576);
 
         sb.getPipeline().addFirst("ssl", new SslHandler(sse));
         sb.getPipeline().addLast("handler", sh);

File: src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -427,7 +427,9 @@ public void writeBytes(InputStream in, int length)
     public int writeBytes(ScatteringByteChannel in, int length)
             throws IOException {
         int writtenBytes = setBytes(writerIndex, in, length);
-        writerIndex += writtenBytes;
+        if (writtenBytes > 0) {
+            writerIndex += writtenBytes;
+        }
         return writtenBytes;
     }
 

File: src/test/java/org/jboss/netty/channel/socket/AbstractSocketEchoTest.java
Patch:
@@ -146,8 +146,8 @@ public void testSimpleEcho() throws Throwable {
             }
         }
 
-        ch.channel.close().awaitUninterruptibly();
         sh.channel.close().awaitUninterruptibly();
+        ch.channel.close().awaitUninterruptibly();
         sc.close().awaitUninterruptibly();
 
         if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
@@ -191,11 +191,12 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             for (int i = 0; i < actual.length; i ++) {
                 assertEquals(data[i + lastIdx], actual[i]);
             }
-            counter += actual.length;
 
             if (channel.getParent() != null) {
                 channel.write(m);
             }
+
+            counter += actual.length;
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/frame/AbstractSocketFixedLengthEchoTest.java
Patch:
@@ -148,8 +148,8 @@ public void testFixedLengthEcho() throws Throwable {
             }
         }
 
-        ch.channel.close().awaitUninterruptibly();
         sh.channel.close().awaitUninterruptibly();
+        ch.channel.close().awaitUninterruptibly();
         sc.close().awaitUninterruptibly();
 
         if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
@@ -195,11 +195,12 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             for (int i = 0; i < actual.length; i ++) {
                 assertEquals(data[i + lastIdx], actual[i]);
             }
-            counter += actual.length;
 
             if (channel.getParent() != null) {
                 channel.write(m);
             }
+
+            counter += actual.length;
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketCompatibleObjectStreamEchoTest.java
Patch:
@@ -155,8 +155,8 @@ public void testCompatibleObjectEcho() throws Throwable {
             }
         }
 
-        ch.channel.close().awaitUninterruptibly();
         sh.channel.close().awaitUninterruptibly();
+        ch.channel.close().awaitUninterruptibly();
         sc.close().awaitUninterruptibly();
 
         if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
@@ -196,11 +196,11 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             String m = (String) e.getMessage();
             assertEquals(data[counter], m);
 
-            counter ++;
-
             if (channel.getParent() != null) {
                 channel.write(m);
             }
+
+            counter ++;
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketObjectStreamEchoTest.java
Patch:
@@ -155,8 +155,8 @@ public void testObjectEcho() throws Throwable {
             }
         }
 
-        ch.channel.close().awaitUninterruptibly();
         sh.channel.close().awaitUninterruptibly();
+        ch.channel.close().awaitUninterruptibly();
         sc.close().awaitUninterruptibly();
 
         if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
@@ -196,11 +196,11 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             String m = (String) e.getMessage();
             assertEquals(data[counter], m);
 
-            counter ++;
-
             if (channel.getParent() != null) {
                 channel.write(m);
             }
+
+            counter ++;
         }
 
         @Override

File: src/test/java/org/jboss/netty/handler/codec/string/AbstractSocketStringEchoTest.java
Patch:
@@ -160,8 +160,8 @@ public void testStringEcho() throws Throwable {
             }
         }
 
-        ch.channel.close().awaitUninterruptibly();
         sh.channel.close().awaitUninterruptibly();
+        ch.channel.close().awaitUninterruptibly();
         sc.close().awaitUninterruptibly();
 
         if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {

File: src/test/java/org/jboss/netty/handler/ssl/AbstractSocketSslEchoTest.java
Patch:
@@ -158,8 +158,8 @@ public void testSslEcho() throws Throwable {
             }
         }
 
-        ch.channel.close().awaitUninterruptibly();
         sh.channel.close().awaitUninterruptibly();
+        ch.channel.close().awaitUninterruptibly();
         sc.close().awaitUninterruptibly();
 
         if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
@@ -203,11 +203,12 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             for (int i = 0; i < actual.length; i ++) {
                 assertEquals(data[i + lastIdx], actual[i]);
             }
-            counter += actual.length;
 
             if (channel.getParent() != null) {
                 channel.write(m);
             }
+
+            counter += actual.length;
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java
Patch:
@@ -76,7 +76,7 @@
  *
  * <ol>
  * <li>close all channels created by the factory,</li>
- * <li>call {@link ExecutorService#shutdown()} for all executors which were
+ * <li>call {@link ExecutorService#shutdownNow()} for all executors which were
  *     specified to create the factory, and</li>
  * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}
  *     until it returns {@code true}.</li>

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannelFactory.java
Patch:
@@ -79,7 +79,7 @@
  * <ol>
  * <li>unbind all channels created by the factory,
  * <li>close all child channels accepted by the unbound channels,</li>
- * <li>call {@link ExecutorService#shutdown()} for all executors which were
+ * <li>call {@link ExecutorService#shutdownNow()} for all executors which were
  *     specified to create the factory, and</li>
  * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}
  *     until it returns {@code true}.</li>

File: src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketChannelFactory.java
Patch:
@@ -62,7 +62,7 @@
  *
  * <ol>
  * <li>close all channels created by the factory,</li>
- * <li>call {@link ExecutorService#shutdown()} for the {@code workerExecutor}
+ * <li>call {@link ExecutorService#shutdownNow()} for the {@code workerExecutor}
  *     which was specified to create the factory, and</li>
  * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}
  *     until it returns {@code true}.</li>

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketChannelFactory.java
Patch:
@@ -74,7 +74,7 @@
  * <ol>
  * <li>unbind all channels created by the factory,
  * <li>close all child channels accepted by the unbound channels,</li>
- * <li>call {@link ExecutorService#shutdown()} for all executors which were
+ * <li>call {@link ExecutorService#shutdownNow()} for all executors which were
  *     specified to create the factory, and</li>
  * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}
  *     until it returns {@code true}.</li>

File: src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -337,7 +337,7 @@ private static int detectConstraintLevel() {
                 loop.done = true;
                 loop.selector.wakeup();
                 try {
-                    executor.shutdown();
+                    executor.shutdownNow();
                     for (;;) {
                         try {
                             if (executor.awaitTermination(1, TimeUnit.SECONDS)) {

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java
Patch:
@@ -61,7 +61,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketServerBootstrapTest.java
Patch:
@@ -67,7 +67,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/channel/socket/AbstractSocketEchoTest.java
Patch:
@@ -77,7 +77,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/handler/codec/frame/AbstractSocketFixedLengthEchoTest.java
Patch:
@@ -47,7 +47,6 @@
 import org.jboss.netty.channel.ExceptionEvent;
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.channel.SimpleChannelHandler;
-import org.jboss.netty.handler.codec.frame.FixedLengthFrameDecoder;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -78,7 +77,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketCompatibleObjectStreamEchoTest.java
Patch:
@@ -83,7 +83,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/handler/codec/serialization/AbstractSocketObjectStreamEchoTest.java
Patch:
@@ -83,7 +83,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/handler/codec/string/AbstractSocketStringEchoTest.java
Patch:
@@ -85,7 +85,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/test/java/org/jboss/netty/handler/ssl/AbstractSocketSslEchoTest.java
Patch:
@@ -80,7 +80,7 @@ public static void init() {
 
     @AfterClass
     public static void destroy() {
-        executor.shutdown();
+        executor.shutdownNow();
         for (;;) {
             try {
                 if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -108,6 +108,7 @@ public ChannelBuffer duplicate() {
     }
 
     public ChannelBuffer copy(int index, int length) {
+        checkIndex(index, length);
         return buffer.copy(index + adjustment, length);
     }
 

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -102,6 +102,7 @@ public ChannelBuffer duplicate() {
     }
 
     public ChannelBuffer copy(int index, int length) {
+        checkIndex(index, length);
         return buffer.copy(index, length);
     }
 

File: src/test/java/org/jboss/netty/handler/codec/string/AbstractSocketStringEchoTest.java
Patch:
@@ -201,12 +201,12 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
             String m = (String) e.getMessage();
             assertEquals(data[counter], m);
 
-            counter ++;
-
             if (channel.getParent() != null) {
                 String delimiter = random.nextBoolean() ? "\r\n" : "\n";
                 channel.write(m + delimiter);
             }
+
+            counter ++;
         }
 
         @Override

File: src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java
Patch:
@@ -120,7 +120,7 @@ public NioClientSocketChannelFactory(
      * @param workerExecutor
      *        the {@link Executor} which will execute the I/O worker threads
      * @param workerCount
-     *        the number of I/O worker threads to start
+     *        the maximum number of I/O worker threads
      */
     public NioClientSocketChannelFactory(
             Executor bossExecutor, Executor workerExecutor,

File: src/main/java/org/jboss/netty/channel/Channels.java
Patch:
@@ -27,8 +27,8 @@
 
 
 /**
- * Provides various factory methods related with {@link Channel} and
- * {@link ChannelPipeline}, and fires an I/O event and request.
+ * A helper class which provides various convenience methods related with
+ * {@link Channel}, {@link ChannelHandler}, and {@link ChannelPipeline}.
  *
  * <h3>Factory methods</h3>
  * <p>

File: src/main/java/org/jboss/netty/channel/Channel.java
Patch:
@@ -33,12 +33,11 @@
  * <p>
  * A channel provides a user:
  * <ul>
- * <li>the current state of the channel (e.g. open, bound, and connected),</li>
+ * <li>the current state of the channel (e.g. is it open? is it connected?),</li>
  * <li>the configuration parameters of the channel (e.g. receive buffer size),</li>
  * <li>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and</li>
  * <li>the {@link ChannelPipeline} which handles all I/O events and requests
- *     associated with the channel.  This is the most important place, where
- *     your application logic kicks into an action.</li>
+ *     associated with the channel.</li>
  * </ul>
  *
  * @author The Netty Project (netty-dev@lists.jboss.org)

File: src/main/java/org/jboss/netty/channel/ChannelUpstreamHandler.java
Patch:
@@ -113,8 +113,9 @@
  * <p>
  * You also might want to refer to {@link ChannelDownstreamHandler} to see
  * how a {@link ChannelEvent} is interpreted when going downstream.  Also,
- * please refer to {@link ChannelEvent} to understand the fundamental difference
- * between a upstream event and a downstream event.
+ * please refer to the {@link ChannelEvent} documentation to find out what a
+ * upstream event and a downstream event are and what fundamental differences
+ * they have, if you didn't read yet.
  * <p>
  * In most cases, you will get to use a {@link SimpleChannelHandler} to
  * implement a upstream handler because it provides an individual handler

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -218,7 +218,7 @@ public void run() {
                 } catch (IOException e) {
                     // Don't log the exception if the server socket was closed
                     // by a user.
-                    if (!channel.isBound() || !channel.isOpen()) {
+                    if (!channel.socket.isBound() || channel.socket.isClosed()) {
                         break;
                     }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -25,6 +25,7 @@
 import static org.jboss.netty.channel.Channels.*;
 
 import java.io.IOException;
+import java.nio.channels.AsynchronousCloseException;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.channels.SelectionKey;
@@ -238,6 +239,8 @@ private static void read(SelectionKey k) {
                 }
             }
             failure = false;
+        } catch (AsynchronousCloseException e) {
+            // Can happen, and doesn't need a user attention.
         } catch (Throwable t) {
             fireExceptionCaught(channel, t);
         }

File: src/main/java/org/jboss/netty/handler/codec/frame/Delimiters.java
Patch:
@@ -43,7 +43,7 @@ public static ChannelBuffer[] lineDelimiter() {
         return new ChannelBuffer[] {
                 ChannelBuffers.wrappedBuffer(new byte[] { '\r', '\n' }),
                 ChannelBuffers.wrappedBuffer(new byte[] { '\n' }),
-                ChannelBuffers.wrappedBuffer(new byte[] { '\r' }) };
+        };
     }
 
     private Delimiters() {

File: src/test/java/org/jboss/netty/handler/ssl/OioOioSocketSslEchoTest.java
Patch:
@@ -50,7 +50,7 @@ protected ChannelFactory newServerSocketChannelFactory(Executor executor) {
 
     @Test
     @Override
-    public void testEcho() throws Throwable {
+    public void testSslEcho() throws Throwable {
         // FIXME Disabled temporarily
     }
 }

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -218,7 +218,7 @@ public void run() {
                 } catch (IOException e) {
                     // Don't log the exception if the server socket was closed
                     // by a user.
-                    if (!channel.isBound()) {
+                    if (!channel.isBound() || !channel.isOpen()) {
                         break;
                     }
 

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java
Patch:
@@ -64,7 +64,7 @@ public static void destroy() {
         executor.shutdown();
         for (;;) {
             try {
-                if (executor.awaitTermination(1, TimeUnit.SECONDS)) {
+                if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {
                     break;
                 }
             } catch (InterruptedException e) {

File: src/test/java/org/jboss/netty/bootstrap/AbstractSocketServerBootstrapTest.java
Patch:
@@ -70,7 +70,7 @@ public static void destroy() {
         executor.shutdown();
         for (;;) {
             try {
-                if (executor.awaitTermination(1, TimeUnit.SECONDS)) {
+                if (executor.awaitTermination(1, TimeUnit.MILLISECONDS)) {
                     break;
                 }
             } catch (InterruptedException e) {

File: src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
Patch:
@@ -353,7 +353,7 @@ public static ChannelBuffer wrappedBuffer(ChannelBuffer... buffers) {
             break;
         default:
             for (ChannelBuffer b: buffers) {
-                if (b.capacity() != 0) {
+                if (b.readable()) {
                     return new CompositeChannelBuffer(buffers);
                 }
             }

File: src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java
Patch:
@@ -296,6 +296,9 @@ public ChannelBuffer slice(int index, int length) {
         if (index == 0 && length == capacity()) {
             return duplicate();
         } else {
+            if (index >= 0 && length == 0) {
+                return ChannelBuffers.EMPTY_BUFFER;
+            }
             return new ByteBufferBackedChannelBuffer(
                     ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)));
         }

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -110,6 +110,9 @@ public ChannelBuffer copy(int index, int length) {
 
     public ChannelBuffer slice(int index, int length) {
         checkIndex(index, length);
+        if (length == 0) {
+            return ChannelBuffers.EMPTY_BUFFER;
+        }
         return new SlicedChannelBuffer(buffer, index + adjustment, length);
     }
 

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -104,6 +104,9 @@ public ChannelBuffer copy(int index, int length) {
 
     public ChannelBuffer slice(int index, int length) {
         checkIndex(index, length);
+        if (length == 0) {
+            return ChannelBuffers.EMPTY_BUFFER;
+        }
         return buffer.slice(index, length);
     }
 

File: src/test/java/org/jboss/netty/buffer/BigEndianCompositeChannelBufferTest.java
Patch:
@@ -30,7 +30,7 @@
 
 
 
-public class CompositeChannelBufferTest extends AbstractChannelBufferTest {
+public class BigEndianCompositeChannelBufferTest extends AbstractChannelBufferTest {
 
     private List<ChannelBuffer> buffers;
     private ChannelBuffer buffer;

File: src/main/java/org/jboss/netty/buffer/CompositeChannelBuffer.java
Patch:
@@ -412,7 +412,9 @@ public int setBytes(int index, ScatteringByteChannel in, int length)
     }
 
     public ChannelBuffer duplicate() {
-        return new CompositeChannelBuffer(this);
+        ChannelBuffer duplicate = new CompositeChannelBuffer(this);
+        duplicate.setIndex(readerIndex(), writerIndex());
+        return duplicate;
     }
 
     public ChannelBuffer copy(int index, int length) {

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -99,7 +99,9 @@ public long getLong(int index) {
     }
 
     public ChannelBuffer duplicate() {
-        return new SlicedChannelBuffer(buffer, adjustment, length);
+        ChannelBuffer duplicate = new SlicedChannelBuffer(buffer, adjustment, length);
+        duplicate.setIndex(readerIndex(), writerIndex());
+        return duplicate;
     }
 
     public ChannelBuffer copy(int index, int length) {

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -93,7 +93,9 @@ public long getLong(int index) {
     }
 
     public ChannelBuffer duplicate() {
-        return new TruncatedChannelBuffer(buffer, length);
+        ChannelBuffer duplicate = new TruncatedChannelBuffer(buffer, length);
+        duplicate.setIndex(readerIndex(), writerIndex());
+        return duplicate;
     }
 
     public ChannelBuffer copy(int index, int length) {

File: src/test/java/org/jboss/netty/buffer/DuplicateChannelBufferTest.java
Patch:
@@ -33,7 +33,7 @@ public class DuplicateChannelBufferTest extends AbstractChannelBufferTest {
 
     @Override
     protected ChannelBuffer newBuffer(int length) {
-        buffer = ChannelBuffers.buffer(length).duplicate();
+        buffer = new DuplicatedChannelBuffer(ChannelBuffers.buffer(length));
         assertEquals(0, buffer.writerIndex());
         return buffer;
     }

File: src/test/java/org/jboss/netty/bootstrap/BootstrapTest.java
Patch:
@@ -31,8 +31,6 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Map.Entry;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.jboss.netty.channel.ChannelDownstreamHandler;
 import org.jboss.netty.channel.ChannelFactory;
@@ -174,7 +172,6 @@ public void shouldNotAllowUnorderedPipelineMap() {
 
     @Test
     public void shouldHaveOrderedPipelineWhenSetFromMap() {
-        Logger.getGlobal().setLevel(Level.SEVERE);
         Map<String, ChannelHandler> m = new LinkedHashMap<String, ChannelHandler>();
         m.put("a", createMock(ChannelDownstreamHandler.class));
         m.put("b", createMock(ChannelDownstreamHandler.class));

File: src/test/java/org/jboss/netty/bootstrap/ClientBootstrapTest.java
Patch:
@@ -98,7 +98,7 @@ public void testSuccessfulConnectionAttempt() throws Exception {
             bootstrap.setOption(
                     "remoteAddress",
                     new InetSocketAddress(
-                            InetAddress.getLoopbackAddress(),
+                            InetAddress.getLocalHost(),
                             serverSocket.socket().getLocalPort()));
 
             ChannelFuture future = bootstrap.connect();
@@ -129,7 +129,7 @@ public void testSuccessfulConnectionAttemptWithLocalAddress() throws Exception {
             bootstrap.setOption(
                     "remoteAddress",
                     new InetSocketAddress(
-                            InetAddress.getLoopbackAddress(),
+                            InetAddress.getLocalHost(),
                             serverSocket.socket().getLocalPort()));
             bootstrap.setOption("localAddress", new InetSocketAddress(0));
 
@@ -157,7 +157,7 @@ public void testFailedPipelineInitialization() throws Exception {
         expect(pipelineFactory.getPipeline()).andThrow(new ChannelPipelineException());
         replay(pipelineFactory);
 
-        bootstrap.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), 1));
+        bootstrap.connect(new InetSocketAddress(InetAddress.getLocalHost(), 1));
     }
 
     @Test(expected = IllegalStateException.class)

File: src/test/java/org/jboss/netty/bootstrap/ServerBootstrapTest.java
Patch:
@@ -104,7 +104,7 @@ public void testSuccessfulBindAttempt() throws Exception {
         Socket socket = null;
         try {
             socket = new Socket(
-                    InetAddress.getLoopbackAddress(),
+                    InetAddress.getLocalHost(),
                     ((InetSocketAddress) channel.getLocalAddress()).getPort());
 
             // Wait until the connection is open in the server side.
@@ -158,7 +158,7 @@ public void testFailedPipelineInitialization() throws Exception {
         expect(pipelineFactory.getPipeline()).andThrow(new ChannelPipelineException());
         replay(pipelineFactory);
 
-        bootstrap.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), 1));
+        bootstrap.connect(new InetSocketAddress(InetAddress.getLocalHost(), 1));
     }
 
     @Test(expected = IllegalStateException.class)

File: src/main/java/org/jboss/netty/logging/JdkLoggerFactory.java
Patch:
@@ -40,6 +40,6 @@ public class JdkLoggerFactory extends InternalLoggerFactory {
     public InternalLogger newInstance(String name) {
         final java.util.logging.Logger logger =
             java.util.logging.Logger.getLogger(name);
-        return new JdkLogger(logger);
+        return new JdkLogger(logger, name);
     }
 }

File: src/main/java/org/jboss/netty/buffer/ChannelBufferInputStream.java
Patch:
@@ -232,7 +232,7 @@ public int skipBytes(int n) throws IOException {
 
     private void checkAvailable(int fieldSize) throws IOException {
         if (fieldSize < 0) {
-            throw new IllegalArgumentException();
+            throw new IndexOutOfBoundsException();
         }
         if (fieldSize > available()) {
             throw new EOFException();

File: src/main/java/org/jboss/netty/logging/CommonsLoggerFactory.java
Patch:
@@ -41,6 +41,6 @@ public class CommonsLoggerFactory extends InternalLoggerFactory {
     public InternalLogger newInstance(String name) {
         final org.apache.commons.logging.Log logger =
             org.apache.commons.logging.LogFactory.getLog(name);
-        return new CommonsLogger(logger);
+        return new CommonsLogger(logger, name);
     }
 }

File: src/main/java/org/jboss/netty/channel/AbstractChannel.java
Patch:
@@ -94,8 +94,8 @@ public final boolean equals(Object o) {
         return this == o;
     }
 
-    public int compareTo(Channel o) {
-        return System.identityHashCode(this) - System.identityHashCode(o);
+    public final int compareTo(Channel o) {
+        return getId().compareTo(o.getId());
     }
 
     public boolean isOpen() {

File: src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -265,7 +265,7 @@ public long readLong() {
     public ChannelBuffer readBytes(int length) {
         checkReadableBytes(length);
         if (length == 0) {
-            return ChannelBuffer.EMPTY_BUFFER;
+            return ChannelBuffers.EMPTY_BUFFER;
         }
         ChannelBuffer buf = ChannelBuffers.buffer(length);
         buf.writeBytes(this, readerIndex, length);

File: src/main/java/org/jboss/netty/buffer/DynamicChannelBuffer.java
Patch:
@@ -44,7 +44,7 @@ public class DynamicChannelBuffer extends AbstractChannelBuffer {
 
     private final int initialCapacity;
     private final ByteOrder endianness;
-    private ChannelBuffer buffer = ChannelBuffer.EMPTY_BUFFER;
+    private ChannelBuffer buffer = ChannelBuffers.EMPTY_BUFFER;
 
     public DynamicChannelBuffer(int estimatedLength) {
         this(ByteOrder.BIG_ENDIAN, estimatedLength);
@@ -216,7 +216,7 @@ public ChannelBuffer copy(int index, int length) {
         DynamicChannelBuffer copiedBuffer = new DynamicChannelBuffer(endianness, Math.max(length, 64));
         copiedBuffer.buffer = buffer.copy();
         if (copiedBuffer.buffer.capacity() == 0) {
-            copiedBuffer.buffer = ChannelBuffer.EMPTY_BUFFER;
+            copiedBuffer.buffer = ChannelBuffers.EMPTY_BUFFER;
         }
         return copiedBuffer;
     }

File: src/main/java/org/jboss/netty/example/echo/EchoHandler.java
Patch:
@@ -58,7 +58,7 @@ public class EchoHandler extends SimpleChannelHandler {
      * Creates a server-side handler.
      */
     public EchoHandler() {
-        firstMessage = ChannelBuffer.EMPTY_BUFFER;
+        firstMessage = ChannelBuffers.EMPTY_BUFFER;
     }
 
     /**

File: src/main/java/org/jboss/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java
Patch:
@@ -23,6 +23,7 @@
 package org.jboss.netty.handler.codec.frame;
 
 import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelHandlerContext;
 
@@ -81,7 +82,7 @@ protected Object decode(
                 return frame;
             } else if (delimIndex == 0) {
                 buffer.skipBytes(delim.capacity());
-                return ChannelBuffer.EMPTY_BUFFER;
+                return ChannelBuffers.EMPTY_BUFFER;
             }
         }
 

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -210,7 +210,7 @@ public void handleDownstream(
     public void channelDisconnected(ChannelHandlerContext ctx,
             ChannelStateEvent e) throws Exception {
         super.channelDisconnected(ctx, e);
-        unwrap(ctx, e.getChannel(), ChannelBuffer.EMPTY_BUFFER, 0, 0);
+        unwrap(ctx, e.getChannel(), ChannelBuffers.EMPTY_BUFFER, 0, 0);
         engine.closeOutbound();
         if (!sentCloseNotify.get() && handshaken) {
             try {
@@ -524,7 +524,7 @@ private void setHandshakeFailure(Channel channel, SSLException cause) {
 
     private void closeOutboundAndChannel(
             final ChannelHandlerContext context, final ChannelStateEvent e) throws SSLException {
-        unwrap(context, e.getChannel(), ChannelBuffer.EMPTY_BUFFER, 0, 0);
+        unwrap(context, e.getChannel(), ChannelBuffers.EMPTY_BUFFER, 0, 0);
         if (!engine.isInboundDone()) {
             if (sentCloseNotify.compareAndSet(false, true)) {
                 engine.closeOutbound();

File: src/main/java/org/jboss/netty/channel/DefaultExceptionEvent.java
Patch:
@@ -22,6 +22,8 @@
  */
 package org.jboss.netty.channel;
 
+import org.jboss.netty.util.StackTraceSimplifier;
+
 
 public class DefaultExceptionEvent extends DefaultChannelEvent implements
         ExceptionEvent {
@@ -34,6 +36,7 @@ public DefaultExceptionEvent(Channel channel, ChannelFuture future, Throwable ca
             throw new NullPointerException("cause");
         }
         this.cause = cause;
+        StackTraceSimplifier.simplify(cause);
     }
 
     public Throwable getCause() {

File: src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
Patch:
@@ -503,7 +503,7 @@ private void setHandshakeSuccess(Channel channel) {
             handshaking = false;
             handshaken = true;
 
-            if (handshakeFuture != null) {
+            if (handshakeFuture == null) {
                 handshakeFuture = newHandshakeFuture(channel);
             }
         }
@@ -515,7 +515,7 @@ private void setHandshakeFailure(Channel channel, SSLException cause) {
             handshaking = false;
             handshaken = false;
 
-            if (handshakeFuture != null) {
+            if (handshakeFuture == null) {
                 handshakeFuture = newHandshakeFuture(channel);
             }
         }

File: src/main/java/org/jboss/netty/buffer/DuplicatedChannelBuffer.java
Patch:
@@ -156,9 +156,9 @@ public int getBytes(int index, GatheringByteChannel out, int length)
         return buffer.getBytes(index, out, length);
     }
 
-    public void setBytes(int index, InputStream in, int length)
+    public int setBytes(int index, InputStream in, int length)
             throws IOException {
-        buffer.setBytes(index, in, length);
+        return buffer.setBytes(index, in, length);
     }
 
     public int setBytes(int index, ScatteringByteChannel in, int length)

File: src/main/java/org/jboss/netty/buffer/DynamicChannelBuffer.java
Patch:
@@ -144,9 +144,9 @@ public void setBytes(int index, ByteBuffer src) {
         buffer.setBytes(index, src);
     }
 
-    public void setBytes(int index, InputStream in, int length)
+    public int setBytes(int index, InputStream in, int length)
             throws IOException {
-        buffer.setBytes(index, in, length);
+        return buffer.setBytes(index, in, length);
     }
 
     public int setBytes(int index, ScatteringByteChannel in, int length)

File: src/main/java/org/jboss/netty/buffer/ReadOnlyChannelBuffer.java
Patch:
@@ -101,9 +101,10 @@ public void setLong(int index, long value) {
         rejectModification();
     }
 
-    public void setBytes(int index, InputStream in, int length)
+    public int setBytes(int index, InputStream in, int length)
             throws IOException {
         rejectModification();
+        return 0;
     }
 
     public int setBytes(int index, ScatteringByteChannel in, int length)

File: src/main/java/org/jboss/netty/buffer/SlicedChannelBuffer.java
Patch:
@@ -178,10 +178,10 @@ public int getBytes(int index, GatheringByteChannel out, int length)
         return buffer.getBytes(index + adjustment, out, length);
     }
 
-    public void setBytes(int index, InputStream in, int length)
+    public int setBytes(int index, InputStream in, int length)
             throws IOException {
         checkIndex(index, length);
-        buffer.setBytes(index + adjustment, in, length);
+        return buffer.setBytes(index + adjustment, in, length);
     }
 
     public int setBytes(int index, ScatteringByteChannel in, int length)

File: src/main/java/org/jboss/netty/buffer/TruncatedChannelBuffer.java
Patch:
@@ -172,10 +172,10 @@ public int getBytes(int index, GatheringByteChannel out, int length)
         return buffer.getBytes(index, out, length);
     }
 
-    public void setBytes(int index, InputStream in, int length)
+    public int setBytes(int index, InputStream in, int length)
             throws IOException {
         checkIndex(index, length);
-        buffer.setBytes(index, in, length);
+        return buffer.setBytes(index, in, length);
     }
 
     public int setBytes(int index, ScatteringByteChannel in, int length)

File: src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java
Patch:
@@ -85,7 +85,7 @@ class NioProviderMetadata {
 
         if (CONSTRAINT_LEVEL < 0 || CONSTRAINT_LEVEL > 2) {
             throw new Error(
-                    "Unexpected wakeup requirement level: " +
+                    "Unexpected NIO constraint level: " +
                     CONSTRAINT_LEVEL + ", please report this error.");
         }
     }

File: src/main/java/org/jboss/netty/handler/codec/serialization/ObjectEncoderOutputStream.java
Patch:
@@ -49,7 +49,7 @@ public ObjectEncoderOutputStream(OutputStream out, int estimatedLength) {
         if (out == null) {
             throw new NullPointerException("out");
         }
-        if (estimatedLength < 8) {
+        if (estimatedLength < 0) {
             throw new IllegalArgumentException("estimatedLength: " + estimatedLength);
         }
 

File: src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java
Patch:
@@ -42,7 +42,7 @@
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
-import org.jboss.netty.util.NamePreservingRunnable;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 
 class NioServerSocketPipelineSink extends AbstractChannelSink {
 
@@ -146,7 +146,7 @@ private void bind(
 
             Executor bossExecutor =
                 ((NioServerSocketChannelFactory) channel.getFactory()).bossExecutor;
-            bossExecutor.execute(new NamePreservingRunnable(
+            bossExecutor.execute(new ThreadRenamingRunnable(
                     new Boss(channel),
                     "New I/O server boss #" + id +" (channelId: " + channel.getId() +
                     ", " + channel.getLocalAddress() + ')'));

File: src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java
Patch:
@@ -42,7 +42,7 @@
 import org.jboss.netty.channel.ChannelFuture;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
-import org.jboss.netty.util.NamePreservingRunnable;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 
 class NioWorker implements Runnable {
 
@@ -106,7 +106,7 @@ void register(NioSocketChannel channel, ChannelFuture future) {
                 (server ? "New I/O server worker #"
                         : "New I/O client worker #") + bossId + '-' + id;
 
-            executor.execute(new NamePreservingRunnable(this, threadName));
+            executor.execute(new ThreadRenamingRunnable(this, threadName));
         } else {
             synchronized (selectorGuard) {
                 selector.wakeup();

File: src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketPipelineSink.java
Patch:
@@ -36,7 +36,7 @@
 import org.jboss.netty.channel.ChannelState;
 import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.util.NamePreservingRunnable;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 
 class OioClientSocketPipelineSink extends AbstractChannelSink {
 
@@ -131,7 +131,7 @@ public void operationComplete(ChannelFuture future) {
             fireChannelConnected(channel, channel.getRemoteAddress());
 
             // Start the business.
-            workerExecutor.execute(new NamePreservingRunnable(
+            workerExecutor.execute(new ThreadRenamingRunnable(
                     new OioWorker(channel),
                     "Old I/O client worker (channelId: " + channel.getId() + ", " +
                     channel.getLocalAddress() + " => " +

File: src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketPipelineSink.java
Patch:
@@ -40,7 +40,7 @@
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.logging.InternalLogger;
 import org.jboss.netty.logging.InternalLoggerFactory;
-import org.jboss.netty.util.NamePreservingRunnable;
+import org.jboss.netty.util.ThreadRenamingRunnable;
 
 class OioServerSocketPipelineSink extends AbstractChannelSink {
 
@@ -141,7 +141,7 @@ private void bind(
 
             Executor bossExecutor =
                 ((OioServerSocketChannelFactory) channel.getFactory()).bossExecutor;
-            bossExecutor.execute(new NamePreservingRunnable(
+            bossExecutor.execute(new ThreadRenamingRunnable(
                     new Boss(channel),
                     "Old I/O server boss (channelId: " + channel.getId() +
                     ", " + localAddress + ')'));
@@ -195,7 +195,7 @@ public void run() {
                                     OioServerSocketPipelineSink.this,
                                     acceptedSocket);
                         workerExecutor.execute(
-                                new NamePreservingRunnable(
+                                new ThreadRenamingRunnable(
                                         new OioWorker(acceptedChannel),
                                         "Old I/O server worker (parentId: " +
                                         channel.getId() +

File: src/main/java/org/jboss/netty/channel/socket/nio/DefaultNioSocketChannelConfig.java
Patch:
@@ -66,6 +66,7 @@ public void setWriteSpinCount(int writeSpinCount) {
             throw new IllegalArgumentException(
                     "writeSpinCount must be a positive integer.");
         }
+        this.writeSpinCount = writeSpinCount;
     }
 
     public ReceiveBufferSizePredictor getReceiveBufferSizePredictor() {

File: src/main/java/org/jboss/netty/buffer/ChannelBuffer.java
Patch:
@@ -910,7 +910,7 @@ public interface ChannelBuffer extends Comparable<ChannelBuffer> {
      * {@code readerIndex} and {@code writerIndex} are {@code 0} and
      * the number of the transferred bytes respectively.
      *
-     * @param length the number of bytes to transfer
+     * @param indexFinder finds the end index of the sub-region
      *
      * @return the newly created buffer which contains the transferred bytes
      *
@@ -938,7 +938,7 @@ public interface ChannelBuffer extends Comparable<ChannelBuffer> {
      * {@code readerIndex} and increases the {@code readerIndex} by the size
      * of the new slice (determined by {@code indexFinder}).
      *
-     * @param indexFinder finds the end index of the sub-region to be sliced
+     * @param indexFinder finds the end index of the sub-region
      *
      * @return the newly created slice
      *

File: src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java
Patch:
@@ -153,6 +153,7 @@ public void getBytes(int index, ChannelBuffer dst) {
 
     public void getBytes(int index, ChannelBuffer dst, int length) {
         getBytes(index, dst, dst.writerIndex(), length);
+        dst.writerIndex(dst.writerIndex() + length);
     }
 
     public void setBytes(int index, byte[] src) {
@@ -165,6 +166,7 @@ public void setBytes(int index, ChannelBuffer src) {
 
     public void setBytes(int index, ChannelBuffer src, int length) {
         setBytes(index, src, src.readerIndex(), length);
+        src.readerIndex(src.readerIndex() + length);
     }
 
     public void setZero(int index, int length) {

File: src/main/java/org/jboss/netty/logging/InternalLoggerFactory.java
Patch:
@@ -44,7 +44,7 @@ public static void setDefault(InternalLoggerFactory defaultInstance) {
     }
 
     public static InternalLogger getInstance(Class<?> clazz) {
-        return getInstance(clazz);
+        return getInstance(clazz.getName());
     }
 
     public static InternalLogger getInstance(String name) {

File: src/main/java/org/jboss/netty/channel/package-info.java
Patch:
@@ -28,10 +28,10 @@
  *
  * @apiviz.landmark
  * @apiviz.exclude ^java
- * @apiviz.exclude ^net\.gleamynode\.netty\.channel\.[^\.]+\.
- * @apiviz.exclude ^net\.gleamynode\.netty\.(bootstrap|handler)\.
+ * @apiviz.exclude ^org\.jboss\.netty\.channel\.[^\.]+\.
+ * @apiviz.exclude ^org\.jboss\.netty\.(bootstrap|handler)\.
  * @apiviz.exclude \.(Abstract|Default).*$
  * @apiviz.exclude \.[A-Za-z]+ChannelFuture$
  * @apiviz.exclude \.ChannelState$
  */
-package org.jboss.netty.channel;
\ No newline at end of file
+package org.jboss.netty.channel;

