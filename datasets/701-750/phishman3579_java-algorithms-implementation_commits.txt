File: src/com/jwetherell/algorithms/data_structures/BinaryHeap.java
Patch:
@@ -372,7 +372,7 @@ public String toString() {
         protected static class HeapPrinter {
 
             public static <T extends Comparable<T>> String getString(BinaryHeapArray<T> tree) {
-                if (tree.array.length == 0)
+                if (tree.size == 0 || tree.array.length == 0)
                     return "Tree has no nodes.";
 
                 T root = tree.array[0];

File: src/com/jwetherell/algorithms/data_structures/Queue.java
Patch:
@@ -563,7 +563,7 @@ public boolean hasNext() {
             public T next() {
                 if (queue.firstIndex+index < queue.lastIndex) {
                     last = queue.firstIndex+index;
-                    return queue.array[queue.firstIndex+index++];
+                    return queue.array[(queue.firstIndex + index++) % queue.array.length];
                 }
                 return null;
             }

File: src/com/jwetherell/algorithms/data_structures/BinaryHeap.java
Patch:
@@ -341,7 +341,7 @@ public T[] getHeap() {
          */
         @Override
         public T getHeadValue() {
-            if (array.length == 0) return null;
+            if (size == 0 || array.length == 0) return null;
             return array[0];
         }
 

File: test/com/jwetherell/algorithms/data_structures/test/QueueTests.java
Patch:
@@ -16,7 +16,7 @@ public class QueueTests {
 
     @Test
     public void testArrayQueue() {
-        TestData data = Utils.generateTestData(100000);
+        TestData data = Utils.generateTestData(2500);
 
         String aName = "Queue [array]";
         Queue.ArrayQueue<Integer> aQueue = new Queue.ArrayQueue<Integer>();
@@ -30,7 +30,7 @@ public void testArrayQueue() {
 
     @Test
     public void testLinkedQueue() {
-        TestData data = Utils.generateTestData(100);
+        TestData data = Utils.generateTestData(250);
 
         String lName = "Queue [linked]";
         Queue.LinkedQueue<Integer> lQueue = new Queue.LinkedQueue<Integer>();

File: src/com/jwetherell/algorithms/data_structures/Queue.java
Patch:
@@ -111,7 +111,7 @@ private boolean remove(int index) {
             return true;
         }
 
-        // Grow the array by 50% and rearrange to make sequential
+        // Triple the size of the underlying array and rearrange to make sequential
         private void grow(int size) {
             int growSize = (size + (size<<1));
             T[] temp = (T[]) new Object[growSize];

File: test/com/jwetherell/algorithms/data_structures/test/QueueTests.java
Patch:
@@ -16,7 +16,7 @@ public class QueueTests {
 
     @Test
     public void testArrayQueue() {
-        TestData data = Utils.generateTestData(100);
+        TestData data = Utils.generateTestData(100000);
 
         String aName = "Queue [array]";
         Queue.ArrayQueue<Integer> aQueue = new Queue.ArrayQueue<Integer>();

File: test/com/jwetherell/algorithms/sequence/test/Sequences.java
Patch:
@@ -141,7 +141,7 @@ public void testLongestIncreasingSubsequence() {
         sequencesLis.add(new int[]{1, 2, 3});
 
         sequences.add(new int[]{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15});
-        sequencesLis.add(new int[]{0, 1, 3, 7, 11, 15});
+        sequencesLis.add(new int[]{0, 2, 6, 9, 11, 15});
 
         assertTrue("Longest increasing subsequence error. Sequences size=" + sequences.size() + " SequencesList size:" + sequencesLis.size(), sequences.size() == sequencesLis.size());
 

File: src/com/jwetherell/algorithms/mathematics/Knapsack.java
Patch:
@@ -40,7 +40,7 @@ public static final int[] zeroOneKnapsack(int[] values, int[] weights, int capac
         final List<Integer> list = new ArrayList<Integer>();
         int i = height - 1;
         int j = width - 1;
-        while (i != 0 || j != 0) {
+        while (i != 0 && j != 0) {
             int current = output[i][j];
             int above = output[i - 1][j];
             if (current == above) {

File: src/com/jwetherell/algorithms/data_structures/BTree.java
Patch:
@@ -109,7 +109,7 @@ public boolean add(T value) {
     /**
      * The node's key size is greater than maxKeySize, split down the middle.
      * 
-     * @param node
+     * @param nodeToSplit
      *            to split.
      */
     private void split(Node<T> nodeToSplit) {

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -212,9 +212,6 @@ private void initializeMap(int length) {
          * 
          * @param h
          *            hash to get index of.
-         * @param length
-         *            length of array
-         * 
          * @return Integer which represents the key.
          */
         private int indexOf(int h) {

File: src/com/jwetherell/algorithms/data_structures/SegmentTree.java
Patch:
@@ -696,7 +696,7 @@ public IntervalData(long start, long end, O object) {
             /**
              * Interval data list which should all be unique
              * 
-             * @param list
+             * @param set
              *            of interval data objects
              */
             public IntervalData(long start, long end, Set<O> set) {

File: src/com/jwetherell/algorithms/graph/ConnectedComponents.java
Patch:
@@ -25,7 +25,8 @@ private ConnectedComponents() { }
     /**
      * Finds the connected components subsets of the Graph.
      * 
-     * @param g Graph to find connected components.
+     * @param graph
+     *               to find connected components.
      * @return List of connected components in the Graph.
      */
     public static final <T extends Comparable<T>> List<List<Vertex<T>>> getConnectedComponents(Graph<T> graph) {

File: src/com/jwetherell/algorithms/numbers/Integers.java
Patch:
@@ -129,12 +129,12 @@ public static final boolean powerOfTwoUsingBits(int numberToCheck) {
         multiDigits.put(10,"ten");
         multiDigits.put(20,"twenty");
         multiDigits.put(30,"thirty");
-        multiDigits.put(40,"fourty");
+        multiDigits.put(40,"forty");
         multiDigits.put(50,"fifty");
         multiDigits.put(60,"sixty");
         multiDigits.put(70,"seventy");
         multiDigits.put(80,"eighty");
-        multiDigits.put(90,"ninty");
+        multiDigits.put(90,"ninety");
     }
 
     private static final int BILLION = 1000000000;

File: test/com/jwetherell/algorithms/numbers/test/Numbers.java
Patch:
@@ -91,17 +91,17 @@ public void testToEnglish() {
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
 
         a = 199;
-        check = "one-hundred ninty-nine";
+        check = "one-hundred ninety-nine";
         english = Integers.toEnglish(a);
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
 
         a = Integer.MAX_VALUE; // 2,147,483,647
-        check = "two-billion one-hundred fourty-seven-million four-hundred eighty-three-thousand six-hundred fourty-seven";
+        check = "two-billion one-hundred forty-seven-million four-hundred eighty-three-thousand six-hundred forty-seven";
         english = Integers.toEnglish(a);
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
 
         a = Integer.MIN_VALUE+1; // -2,147,483,647
-        check = "negative two-billion one-hundred fourty-seven-million four-hundred eighty-three-thousand six-hundred fourty-seven";
+        check = "negative two-billion one-hundred forty-seven-million four-hundred eighty-three-thousand six-hundred forty-seven";
         english = Integers.toEnglish(a);
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
     }

File: src/com/jwetherell/algorithms/graph/ConnectedComponents.java
Patch:
@@ -25,7 +25,8 @@ private ConnectedComponents() { }
     /**
      * Finds the connected components subsets of the Graph.
      * 
-     * @param g Graph to find connected components.
+     * @param graph
+     *               to find connected components.
      * @return List of connected components in the Graph.
      */
     public static final <T extends Comparable<T>> List<List<Vertex<T>>> getConnectedComponents(Graph<T> graph) {

File: src/com/jwetherell/algorithms/data_structures/SegmentTree.java
Patch:
@@ -696,7 +696,7 @@ public IntervalData(long start, long end, O object) {
             /**
              * Interval data list which should all be unique
              * 
-             * @param list
+             * @param set
              *            of interval data objects
              */
             public IntervalData(long start, long end, Set<O> set) {

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -212,9 +212,6 @@ private void initializeMap(int length) {
          * 
          * @param h
          *            hash to get index of.
-         * @param length
-         *            length of array
-         * 
          * @return Integer which represents the key.
          */
         private int indexOf(int h) {

File: test/com/jwetherell/algorithms/numbers/test/Numbers.java
Patch:
@@ -91,17 +91,17 @@ public void testToEnglish() {
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
 
         a = 199;
-        check = "one-hundred ninty-nine";
+        check = "one-hundred ninety-nine";
         english = Integers.toEnglish(a);
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
 
         a = Integer.MAX_VALUE; // 2,147,483,647
-        check = "two-billion one-hundred fourty-seven-million four-hundred eighty-three-thousand six-hundred fourty-seven";
+        check = "two-billion one-hundred forty-seven-million four-hundred eighty-three-thousand six-hundred forty-seven";
         english = Integers.toEnglish(a);
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
 
         a = Integer.MIN_VALUE+1; // -2,147,483,647
-        check = "negative two-billion one-hundred fourty-seven-million four-hundred eighty-three-thousand six-hundred fourty-seven";
+        check = "negative two-billion one-hundred forty-seven-million four-hundred eighty-three-thousand six-hundred forty-seven";
         english = Integers.toEnglish(a);
         assertTrue("toEnglish error. a="+a+" expected="+check+" got="+english, (check.equals(english)));
     }

File: src/com/jwetherell/algorithms/numbers/Integers.java
Patch:
@@ -129,12 +129,12 @@ public static final boolean powerOfTwoUsingBits(int numberToCheck) {
         multiDigits.put(10,"ten");
         multiDigits.put(20,"twenty");
         multiDigits.put(30,"thirty");
-        multiDigits.put(40,"fourty");
+        multiDigits.put(40,"forty");
         multiDigits.put(50,"fifty");
         multiDigits.put(60,"sixty");
         multiDigits.put(70,"seventy");
         multiDigits.put(80,"eighty");
-        multiDigits.put(90,"ninty");
+        multiDigits.put(90,"ninety");
     }
 
     private static final int BILLION = 1000000000;

File: src/com/jwetherell/algorithms/data_structures/BinaryHeap.java
Patch:
@@ -289,8 +289,8 @@ public boolean validate() {
         /**
          * Validate the node for the heap invariants.
          * 
-         * @param node
-         *            to validate for.
+         * @param index
+         *            of node to validate for.
          * @return True if node is valid.
          */
         private boolean validateNode(int index) {

File: src/com/jwetherell/algorithms/data_structures/BinaryHeap.java
Patch:
@@ -449,8 +449,8 @@ public int size() {
         /**
          * Get the navigation directions through the tree to the index.
          * 
-         * @param index
-         *            of the Node to get directions for.
+         * @param idx
+         *           index of the Node to get directions for.
          * @return Integer array representing the directions to the index.
          */
         private static int[] getDirections(int idx) {

File: src/com/jwetherell/algorithms/data_structures/BTree.java
Patch:
@@ -109,7 +109,7 @@ public boolean add(T value) {
     /**
      * The node's key size is greater than maxKeySize, split down the middle.
      * 
-     * @param node
+     * @param nodeToSplit
      *            to split.
      */
     private void split(Node<T> nodeToSplit) {

File: src/com/jwetherell/algorithms/numbers/Integers.java
Patch:
@@ -119,7 +119,7 @@ public static final boolean powerOfTwoUsingBits(int numberToCheck) {
         singleDigits.put(14,"fourteen");
         singleDigits.put(15,"fifteen");
         singleDigits.put(16,"sixteen");
-        singleDigits.put(17,"seventee");
+        singleDigits.put(17,"seventeen");
         singleDigits.put(18,"eighteen");
         singleDigits.put(19,"nineteen");
     }

File: src/com/jwetherell/algorithms/numbers/Integers.java
Patch:
@@ -119,7 +119,7 @@ public static final boolean powerOfTwoUsingBits(int numberToCheck) {
         singleDigits.put(14,"fourteen");
         singleDigits.put(15,"fifteen");
         singleDigits.put(16,"sixteen");
-        singleDigits.put(17,"seventee");
+        singleDigits.put(17,"seventeen");
         singleDigits.put(18,"eighteen");
         singleDigits.put(19,"nineteen");
     }

File: src/com/jwetherell/algorithms/data_structures/PatriciaTrie.java
Patch:
@@ -524,6 +524,8 @@ protected static interface INodeCreator {
     protected static class PatriciaTriePrinter {
 
         protected static <C extends CharSequence> String getString(PatriciaTrie<C> tree) {
+            if (tree.root == null) 
+                return "Tree has no nodes.";
             return getString(tree.root, "", null, true);
         }
 

File: src/com/jwetherell/algorithms/data_structures/Treap.java
Patch:
@@ -182,7 +182,8 @@ public String toString() {
     protected static class TreapPrinter {
 
         public static <T extends Comparable<T>> String getString(Treap<T> tree) {
-            if (tree.root == null) return "Tree has no nodes.";
+            if (tree.root == null) 
+                return "Tree has no nodes.";
             return getString((TreapNode<T>) tree.root, "", true);
         }
 

File: src/com/jwetherell/algorithms/data_structures/Trie.java
Patch:
@@ -350,6 +350,8 @@ public static <C extends CharSequence> void print(Trie<C> trie) {
         }
 
         public static <C extends CharSequence> String getString(Trie<C> tree) {
+            if (tree.root == null) 
+                return "Tree has no nodes.";
             return getString(tree.root, "", null, true);
         }
 

File: src/com/jwetherell/algorithms/mathematics/LUDecomposition.java
Patch:
@@ -29,7 +29,7 @@ public Matrix<Double> getU() {
     }
 
     public List<Integer> getPermutation() {
-        return new ArrayList<>(Arrays.asList(permutation));
+        return new ArrayList<Integer>(Arrays.asList(permutation));
     }
 
     public LUDecomposition(Matrix<Double> input) {

File: src/com/jwetherell/algorithms/graph/TurboMatching.java
Patch:
@@ -27,11 +27,11 @@ public class TurboMatching {
      * @return a MatchingResult class instance containg a map of mates for each paired vertex and number of pairs
      */
     public static <T extends Comparable<T>> MatchingResult<T> getMaximumMatching(Graph<T> graph){
-        Map<Graph.Vertex<T>, Graph.Vertex<T>> mate = new HashMap<>();
+        Map<Graph.Vertex<T>, Graph.Vertex<T>> mate = new HashMap<Graph.Vertex<T>, Graph.Vertex<T>>();
 
         while(pathset(graph, mate));
 
-        return new MatchingResult<>(mate);
+        return new MatchingResult<T>(mate);
     }
 
     /**
@@ -42,7 +42,7 @@ public static <T extends Comparable<T>> MatchingResult<T> getMaximumMatching(Gra
      * @return              information if any augmenting path was found
      */
     private static <T extends Comparable<T>> boolean pathset(Graph<T> graph, Map<Graph.Vertex<T>, Graph.Vertex<T>> mate){
-        Set<Graph.Vertex<T>> visited = new HashSet<>();
+        Set<Graph.Vertex<T>> visited = new HashSet<Graph.Vertex<T>>();
 
         boolean result = false;
 

File: src/com/jwetherell/algorithms/data_structures/Matrix.java
Patch:
@@ -251,7 +251,7 @@ public Matrix<T> multiply(Matrix<T> input) {
                         T m2 = column[i];
                     
                         BigDecimal result2 = ((BigDecimal)m1).multiply(((BigDecimal)m2));
-                        result.add(result2);
+                        result = result.add(result2);
                     }
                     output.set(r, c, (T)result);
                 } else if (test instanceof BigInteger) {
@@ -261,7 +261,7 @@ public Matrix<T> multiply(Matrix<T> input) {
                         T m2 = column[i];
                     
                         BigInteger result2 = ((BigInteger)m1).multiply(((BigInteger)m2));
-                        result.add(result2);
+                        result = result.add(result2);
                     }
                     output.set(r, c, (T)result);
                 } else if (test instanceof Long) {

File: src/com/jwetherell/algorithms/data_structures/SkipList.java
Patch:
@@ -373,9 +373,9 @@ protected Node<T> getNext(int idx) {
         public String toString() {
             StringBuilder builder = new StringBuilder();
             builder.append("data=").append(data);
-            int size = next.length;
             if (next!=null) {
                 builder.append("\n").append("next=[");
+                int size = next.length;
                 for (int i=0; i<size; i++) {
                     Node<T> n = next[i];
                     if (n!=null) builder.append(n.data);

File: src/com/jwetherell/algorithms/data_structures/SplayTree.java
Patch:
@@ -67,7 +67,7 @@ public boolean contains(T value) {
     private void splay(Node<T> node) {
         Node<T> parent = node.parent;
         Node<T> grandParent = (parent != null) ? parent.parent : null;
-        if (parent == root) {
+        if (parent != null && parent == root) {
             grandParent = parent.parent;
             // Zig step
             root = node;

File: src/com/jwetherell/algorithms/mathematics/Multiplication.java
Patch:
@@ -183,7 +183,7 @@ public static String multiplyUsingLoopWithStringInput(String a, String b) {
             sb.append('-');
         boolean zeroCheck = true;
         for (Integer s : res) {
-            if (zeroCheck && s.equals("0"))
+            if (zeroCheck && s.equals(0))
                 continue;
             zeroCheck = false;
             sb.append(s);

File: src/com/jwetherell/algorithms/numbers/Integers.java
Patch:
@@ -87,7 +87,7 @@ public static final boolean powerOfTwoUsingLog(int numberToCheck) {
         int number = numberToCheck;
         double doubleLog = Math.log10(number) / Math.log10(2);
         int intLog = (int) doubleLog;
-        if (doubleLog == intLog)
+        if (Double.compare(doubleLog, intLog) == 0)
             return true;
         return false;
     }

File: src/com/jwetherell/algorithms/strings/StringFunctions.java
Patch:
@@ -197,7 +197,7 @@ public static final boolean isPalindromeWithAdditionalStorage(String string) {
     public static final boolean isPalindromeInPlace(String string) {
         final char[] array = string.toCharArray();
         final int length = array.length - 1;
-        final int half = Math.round(array.length / 2);
+        final int half = Math.round(array.length / 2f);
         char a, b;
         for (int i = length; i >= half; i--) {
             a = array[length - i];

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -597,9 +597,9 @@ private int getNextIndex(int input) {
          * @return Integer which represents the key.
          */
         private int indexOf(K key) {
-            int k = key.hashCode() % hashingKey;
-            if (k>=array.length)
-                k = k - ((k/array.length) * array.length);
+            int k = Math.abs(key.hashCode()) % hashingKey;
+            if (k >= array.length)
+                k = k - ((k / array.length) * array.length);
             return k;
         }
 

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -597,9 +597,9 @@ private int getNextIndex(int input) {
          * @return Integer which represents the key.
          */
         private int indexOf(K key) {
-            int k = key.hashCode() % hashingKey;
-            if (k>=array.length)
-                k = k - ((k/array.length) * array.length);
+            int k = Math.abs(key.hashCode()) % hashingKey;
+            if (k >= array.length)
+                k = k - ((k / array.length) * array.length);
             return k;
         }
 

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -514,7 +514,7 @@ public V remove(K key) {
         @Override
         public void clear() {
             for (int i=0; i<array.length; i++)
-                array = null;
+                array[i] = null;
             size = 0;
         }
 

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -514,7 +514,7 @@ public V remove(K key) {
         @Override
         public void clear() {
             for (int i=0; i<array.length; i++)
-                array = null;
+                array[i] = null;
             size = 0;
         }
 

File: src/com/jwetherell/algorithms/data_structures/DisjointSet.java
Patch:
@@ -120,7 +120,7 @@ public boolean equals(Object o) {
             final Item<T> i = (Item<T>) o;
             if ((i.parent!=null && parent!=null) && !(i.parent.value.equals(parent.value)))
                 return false;
-            if ((i.value!=null && value!=null) && !(value.equals(value)))
+            if ((i.value!=null && value!=null) && !(i.value.equals(value)))
                 return false;
             return true;
         }

File: src/com/jwetherell/algorithms/data_structures/DisjointSet.java
Patch:
@@ -120,7 +120,7 @@ public boolean equals(Object o) {
             final Item<T> i = (Item<T>) o;
             if ((i.parent!=null && parent!=null) && !(i.parent.value.equals(parent.value)))
                 return false;
-            if ((i.value!=null && value!=null) && !(value.equals(value)))
+            if ((i.value!=null && value!=null) && !(i.value.equals(value)))
                 return false;
             return true;
         }

File: src/com/jwetherell/algorithms/strings/KnuthMorrisPratt.java
Patch:
@@ -42,7 +42,6 @@ public static List<Integer> getPrefSufTable(String text) {
             int sizeOfPrefSuf = prefSufTable.get(i-1);
             while (sizeOfPrefSuf > 0 && (chars[i] != chars[sizeOfPrefSuf]))
                 sizeOfPrefSuf = prefSufTable.get(sizeOfPrefSuf-1); // because string is 0-indexed
-            System.out.println("a="+chars[i]+" b="+chars[sizeOfPrefSuf]);
 
             // if characters at this positions are different then sizeOfPrefSuf is equal to zero,
             // so there is no proper prefix-suffix
@@ -51,7 +50,6 @@ public static List<Integer> getPrefSufTable(String text) {
             } else {
                 prefSufTable.add(0);
             }
-            System.out.println("prefSufTable.size="+prefSufTable.size());
         }
         return prefSufTable;
     }

File: test/com/jwetherell/algorithms/strings/test/KnuthMorrisPrattTests.java
Patch:
@@ -31,9 +31,7 @@ public void getPrefixSuffixes() throws Exception {
             String input = (String) testCase[0];
             List<Integer> expected = (List<Integer>) testCase[1];
             List<Integer> result = KnuthMorrisPratt.getPrefSufTable(input);
-            System.out.println("expected="+expected+" result="+result);
             assertEquals(expected, result);
-            result.clear();
         }
     }
 }
\ No newline at end of file

File: src/com/jwetherell/algorithms/data_structures/List.java
Patch:
@@ -46,6 +46,7 @@ public boolean add(int index, T value) {
                 // Shift the array down one spot
                 System.arraycopy(array, index, array, index+1, size - index);
                 array[index] = value;
+                size++;
             }
             return true;
         }

File: src/com/jwetherell/algorithms/data_structures/KdTree.java
Patch:
@@ -149,12 +149,12 @@ else if (axis == Y_AXIS)
                 }
             }
 
-            if ((medianIndex - 1) >= 0 && less.size() > 0) {
+            if ((medianIndex-1 >= 0) && less.size() > 0) {
                 node.lesser = createNode(less, k, depth + 1);
                 node.lesser.parent = node;
             }
 
-            if ((medianIndex + 1) <= (list.size() - 1) && more.size() > 0) {
+            if ((medianIndex <= list.size()-1) && more.size() > 0) {
                 node.greater = createNode(more, k, depth + 1);
                 node.greater.parent = node;
             }

File: test/com/jwetherell/algorithms/data_structures/timing/DataStructuresTiming.java
Patch:
@@ -38,11 +38,11 @@ public class DataStructuresTiming {
     private static final Random RANDOM = new Random();
     private static final DecimalFormat FORMAT = new DecimalFormat("0.##");
     private static final int NUMBER_OF_TESTS = 3; // There will always be NUMBER_OF_TESTS+1 runs since the first round is thrown away (JITing)
-    private static final int ARRAY_SIZE = 1024*20; // Number of items to add/remove/look-up from each data structure
+    private static final int ARRAY_SIZE = 1024*10; // Number of items to add/remove/look-up from each data structure
     private static final int RANDOM_SIZE = 1000 * ARRAY_SIZE;
     private static final Integer INVALID = RANDOM_SIZE + 10;
 
-    private static final int TESTS = 39; // Max number of dynamic data structures to test
+    private static final int TESTS = 40; // Max number of dynamic data structures to test
     private static final String[] TEST_NAMES = new String[TESTS]; // Array to hold the test names
     private static final long[][] TEST_RESULTS = new long[TESTS][]; // Array to hold the test results
 

File: src/com/jwetherell/algorithms/sorts/timing/SortsTiming.java
Patch:
@@ -89,8 +89,8 @@ public static void main(String[] args) {
         showComparison();
 
         mergeResults = new double[2 * 3];
-        mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);
         mergeCount = runTest(new MergeInPlace(), unsorted, sorted, mergeResults, mergeCount);
+        mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);
         showComparison();
 
         quickResults = new double[3 * 3];

File: src/com/jwetherell/algorithms/sorts/timing/SortsTiming.java
Patch:
@@ -130,7 +130,7 @@ private static final int runTest(Testable testable, Integer[] unsorted, Integer[
         putOutTheGarbage();
 
         bInsertion = System.nanoTime();
-        result = InsertionSort.sort(sorted.clone());
+        result = testable.sort(sorted.clone());
         if (checkResults && !check(result))
             System.err.println(testable.getName()+" failed.");
         aInsertion = System.nanoTime();
@@ -142,9 +142,9 @@ private static final int runTest(Testable testable, Integer[] unsorted, Integer[
         putOutTheGarbage();
 
         bInsertion = System.nanoTime();
-        result = InsertionSort.sort(reverse.clone());
+        result = testable.sort(reverse.clone());
         if (checkResults && !check(result))
-            System.err.println(testable.getName()+"InsertionSort.");
+            System.err.println(testable.getName()+" failed.");
         aInsertion = System.nanoTime();
         diff = (aInsertion - bInsertion) / 1000000d / 1000d;
         System.out.println("Reverse sorted: "+testable.getName()+"=" + FORMAT.format(diff) + " secs");

File: src/com/jwetherell/algorithms/graph/test/Graphs.java
Patch:
@@ -853,7 +853,7 @@ public void topologicalSortOnDirectedGraph() {
             Graph<Integer> digraph = new Graph<Integer>(Graph.TYPE.DIRECTED, verticies, edges);
             if (debug > 0) System.out.println(digraph.toString());
 
-            System.out.println("Topological sort of the directed graph.");
+            if (debug > 0) System.out.println("Topological sort of the directed graph.");
             List<Graph.Vertex<Integer>> results = TopologicalSort.sort(digraph);
             if (debug > 0) System.out.println("result=" + results);
             assertTrue("Topological sort error. results="+results, results.size()!=0);

File: src/com/jwetherell/algorithms/sorts/AmericanFlagSort.java
Patch:
@@ -22,8 +22,7 @@ public class AmericanFlagSort {
 
     private static final int NUMBER_OF_BUCKETS = 10; // 10 for base 10 numbers
 
-    private AmericanFlagSort() {
-    }
+    private AmericanFlagSort() { }
 
     public static Integer[] sort(Integer[] unsorted) {
         int numberOfDigits = getMaxNumberOfDigits(unsorted); // Max number of digits

File: src/com/jwetherell/algorithms/sorts/BubbleSort.java
Patch:
@@ -18,8 +18,7 @@
  */
 public class BubbleSort<T extends Comparable<T>> {
 
-    private BubbleSort() {
-    }
+    private BubbleSort() { }
 
     public static <T extends Comparable<T>> T[] sort(T[] unsorted) {
         boolean swapped = true;

File: src/com/jwetherell/algorithms/sorts/CountingSort.java
Patch:
@@ -20,8 +20,7 @@
  */
 public class CountingSort {
 
-    private CountingSort() {
-    }
+    private CountingSort() { }
 
     public static Integer[] sort(Integer[] unsorted) {
         int maxValue = findMax(unsorted);

File: src/com/jwetherell/algorithms/sorts/HeapSort.java
Patch:
@@ -18,8 +18,7 @@
  */
 public class HeapSort<T extends Comparable<T>> {
 
-    private HeapSort() {
-    }
+    private HeapSort() { }
 
     public static <T extends Comparable<T>> T[] sort(T[] unsorted) {
         createHeap(unsorted);

File: src/com/jwetherell/algorithms/sorts/InsertionSort.java
Patch:
@@ -18,8 +18,7 @@
  */
 public class InsertionSort<T extends Comparable<T>> {
 
-    private InsertionSort() {
-    }
+    private InsertionSort() { }
 
     public static <T extends Comparable<T>> T[] sort(T[] unsorted) {
         int length = unsorted.length;

File: src/com/jwetherell/algorithms/sorts/RadixSort.java
Patch:
@@ -25,8 +25,7 @@ public class RadixSort {
 
     private static final int NUMBER_OF_BUCKETS = 10; // 10 for base 10 numbers
 
-    private RadixSort() {
-    }
+    private RadixSort() { }
 
     public static Integer[] sort(Integer[] unsorted) {
         int[][] buckets = new int[NUMBER_OF_BUCKETS][10];
@@ -78,6 +77,6 @@ private static int[] add(int integer, int[] bucket) {
         }
         result[size] = integer;
         result[0] = ++size;
-        return bucket;
+        return result;
     }
 }

File: src/com/jwetherell/algorithms/sorts/ShellSort.java
Patch:
@@ -21,8 +21,7 @@
  */
 public abstract class ShellSort<T extends Comparable<T>> {
 
-    private ShellSort() {
-    }
+    private ShellSort() { }
 
     public static <T extends Comparable<T>> T[] sort(int[] shells, T[] unsorted) {
         for (int gap : shells) {

File: src/com/jwetherell/algorithms/data_structures/BinaryHeap.java
Patch:
@@ -140,7 +140,7 @@ protected void heapUp(int nodeIndex) {
                 if ((type == Type.MIN && parent != null && value.compareTo(parent) < 0)
                     || (type == Type.MAX && parent != null && value.compareTo(parent) > 0)
                 ) {
-                    // Node is less than parent, switch node with parent
+                    // Node is greater/lesser than parent, switch node with parent
                     this.array[parentIndex] = value;
                     this.array[nodeIndex] = parent;
                 } else {

File: src/com/jwetherell/algorithms/sorts/QuickSort.java
Patch:
@@ -11,7 +11,7 @@
  * Space: In-place. 
  * Stable: False.
  * 
- * Average case = O(n) Worst case = O(n^2) Best case = O(n*log n)
+ * Average case = O(n*log n), Worst case = O(n^2), Best case = O(n) [three-way partition and equal keys]
  * 
  * http://en.wikipedia.org/wiki/Quick_sort
  * 

File: src/com/jwetherell/algorithms/data_structures/IntervalTree.java
Patch:
@@ -198,8 +198,8 @@ else if (temp != null)
             } else if (index >= center) {
                 // overlapEnd is sorted by end point
                 List<IntervalData<O>> overlapEnd = new ArrayList<IntervalData<O>>();
-                Collections.sort(overlapEnd,endComparator);
                 overlapEnd.addAll(overlap);
+                Collections.sort(overlapEnd,endComparator);
                 for (IntervalData<O> data : overlapEnd) {
                     if (data.end < index)
                         break;

File: src/com/jwetherell/algorithms/data_structures/HashArrayMappedTrie.java
Patch:
@@ -208,6 +208,8 @@ public V remove(K key) {
                 numOfChildren = parent.getNumberOfChildren();
             }
         }
+        kvNode.key = 0;
+        kvNode.value = null;
         size--;
         return value;
     }

File: src/com/jwetherell/algorithms/data_structures/SkipListMap.java
Patch:
@@ -69,6 +69,8 @@ public V remove(K key) {
         if (node instanceof SkipListMapNode) {
             SkipListMapNode<K, V> treeMapNode = (SkipListMapNode<K, V>) node;
             value = treeMapNode.value;
+            treeMapNode.data = null;
+            treeMapNode.value = null;
         }
         return value;
     }

File: src/com/jwetherell/algorithms/data_structures/TreeMap.java
Patch:
@@ -73,6 +73,8 @@ public V remove(K key) {
         if (node instanceof TreeMapNode) {
             TreeMapNode<K, V> treeMapNode = (TreeMapNode<K, V>) node;
             value = treeMapNode.value;
+            treeMapNode.id = null;
+            treeMapNode.value = null;
         }
         return value;
     }

File: src/com/jwetherell/algorithms/data_structures/TrieMap.java
Patch:
@@ -71,6 +71,7 @@ public V remove(K key) {
             if (node instanceof TrieMapNode) {
                 TrieMapNode<V> tmn = (TrieMapNode<V>)node;
                 value = tmn.value;
+                tmn.value = null;
             }
             trie.remove(node);
         }

File: src/com/jwetherell/algorithms/graph/CycleDetection.java
Patch:
@@ -40,8 +40,7 @@ private static final boolean depthFirstSearch(Graph.Vertex<Integer> vertex) {
                     boolean result = false;
                     if (to != null && !visitedEdges.contains(edge)) {
                         visitedEdges.add(edge);
-                        Graph.Edge<Integer> recip = new Graph.Edge<Integer>(edge.getCost(), edge.getToVertex(),
-                                edge.getFromVertex());
+                        Graph.Edge<Integer> recip = new Graph.Edge<Integer>(edge.getCost(), edge.getToVertex(), edge.getFromVertex());
                         visitedEdges.add(recip);
                         result = depthFirstSearch(to);
                     }

File: src/com/jwetherell/algorithms/graph/FloydWarshall.java
Patch:
@@ -19,8 +19,7 @@ public class FloydWarshall {
     private FloydWarshall() {
     }
 
-    public static Map<Graph.Vertex<Integer>, Map<Graph.Vertex<Integer>, Integer>> getAllPairsShortestPaths(
-            Graph<Integer> g) {
+    public static Map<Graph.Vertex<Integer>, Map<Graph.Vertex<Integer>, Integer>> getAllPairsShortestPaths(Graph<Integer> g) {
         Map<Graph.Vertex<Integer>, Map<Graph.Vertex<Integer>, Integer>> allShortestPaths = new HashMap<Graph.Vertex<Integer>, Map<Graph.Vertex<Integer>, Integer>>();
 
         List<Graph.Vertex<Integer>> vertices = g.getVerticies();

File: src/com/jwetherell/algorithms/data_structures/Graph.java
Patch:
@@ -1,6 +1,7 @@
 package com.jwetherell.algorithms.data_structures;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
@@ -57,11 +58,11 @@ public Graph(TYPE type) {
         this.type = type;
     }
 
-    public Graph(List<Vertex<T>> verticies, List<Edge<T>> edges) {
+    public Graph(Collection<Vertex<T>> verticies, Collection<Edge<T>> edges) {
         this(TYPE.UNDIRECTED, verticies, edges);
     }
 
-    public Graph(TYPE type, List<Vertex<T>> verticies, List<Edge<T>> edges) {
+    public Graph(TYPE type, Collection<Vertex<T>> verticies, Collection<Edge<T>> edges) {
         this(type);
         this.verticies.addAll(verticies);
         this.edges.addAll(edges);

File: src/com/jwetherell/algorithms/data_structures/KdTree.java
Patch:
@@ -556,7 +556,7 @@ public XYZPoint(double x, double y) {
             this.z = 0;
         }
 
-        public XYZPoint(double x, int y, double z) {
+        public XYZPoint(double x, double y, double z) {
             this.x = x;
             this.y = y;
             this.z = z;

File: src/com/jwetherell/algorithms/data_structures/KdTree.java
Patch:
@@ -642,7 +642,7 @@ public static <T extends XYZPoint> String getString(KdTree<T> tree) {
             return getString(tree.root, "", true);
         }
 
-        private static <T extends Comparable<T>> String getString(KdNode node, String prefix, boolean isTail) {
+        private static String getString(KdNode node, String prefix, boolean isTail) {
             StringBuilder builder = new StringBuilder();
 
             if (node.parent != null) {

File: src/com/jwetherell/algorithms/data_structures/PatriciaTrie.java
Patch:
@@ -331,7 +331,7 @@ public boolean validate() {
 
     private boolean validate(Node node, String string, java.util.Set<C> keys) {
         StringBuilder builder = new StringBuilder(string);
-        builder.append(node.string);
+        if (node.string!=null) builder.append(node.string);
         String s = builder.toString();
 
         if (node.type == WHITE) {

File: src/com/jwetherell/algorithms/data_structures/RadixTrie.java
Patch:
@@ -106,7 +106,7 @@ private boolean validate(PatriciaTrie.Node node, String string, java.util.Set<K>
         RadixNode<K,V> tmn = (RadixNode<K,V>)node;
 
         StringBuilder builder = new StringBuilder(string);
-        builder.append(tmn.string);
+        if (tmn.string!=null) builder.append(tmn.string);
         String s = builder.toString();
 
         if (tmn.type == PatriciaTrie.WHITE) {

File: src/com/jwetherell/algorithms/data_structures/KdTree.java
Patch:
@@ -338,7 +338,7 @@ private static final <T extends KdTree.XYZPoint> void searchNode(T value, KdNode
         }
         Double nodeDistance = node.id.euclideanDistance(value);
         if (nodeDistance.compareTo(lastDistance)<0) {
-            if (results.size()==K) results.remove(lastNode);
+            if (results.size()==K && lastNode!=null) results.remove(lastNode);
             results.add(node);
         } else if (nodeDistance.equals(lastDistance)) {
             results.add(node);

File: src/com/jwetherell/algorithms/data_structures/KdTree.java
Patch:
@@ -398,7 +398,7 @@ private static <T extends Comparable<T>> String getString(KdNode node, String pr
 
             if (node.parent!=null) {
                 String side = "left";
-                if (node.equals(node.parent.greater)) side = "right";
+                if (node.parent.greater!=null && node.id.equals(node.parent.greater.id)) side = "right";
                 builder.append(prefix + (isTail ? "└── " : "├── ") + "[" + side + "] " + "depth=" + node.depth + " id=" + node.id + "\n");
             } else {
                 builder.append(prefix + (isTail ? "└── " : "├── ") + "depth=" + node.depth + " id=" + node.id + "\n");

File: src/com/jwetherell/algorithms/Sorts.java
Patch:
@@ -42,9 +42,9 @@ public class Sorts {
     private static int americanFlagCount = 0;
     private static final double[] americanFlagResults = new double[1*3];
 
-    private static final boolean showInsertion = false;
-    private static final boolean showBubble = false;
-    private static final boolean showShell = false;
+    private static final boolean showInsertion = true;
+    private static final boolean showBubble = true;
+    private static final boolean showShell = true;
     private static final boolean showMerge = true;
     private static final boolean showQuick = true;
     private static final boolean showHeap = true;

File: src/com/jwetherell/algorithms/data_structures/SuffixTree.java
Patch:
@@ -116,7 +116,7 @@ private Set<String> getSuffixes(int start) {
             if (n == null) {
                 int index = s.indexOf(END_SEQ_CHAR);
                 if (index>=0) s = s.substring(0, index);
-                if (s.length() > 0) set.add(s);
+                set.add(s);
             } else {
                 Set<String> set2 = getSuffixes(e.endNode);
                 for (String s2 : set2) {

File: src/com/jwetherell/algorithms/data_structures/IntervalTree.java
Patch:
@@ -157,9 +157,8 @@ public IntervalData<O> query(long index) {
             IntervalData<O> results = null;
             if (index==center) {
                 for (IntervalData<O> data : overlapStart) {
-                    IntervalData<O> temp = data.query(index);
-                    if (results==null && temp!=null) results = temp.copy();
-                    else if (temp!=null) results.combined(temp);
+                    if (results==null) results = data.copy();
+                    else results.combined(data);
                 }
             } else {
                 for (IntervalData<O> data : overlapStart) {

File: src/com/jwetherell/algorithms/data_structures/SuffixTree.java
Patch:
@@ -311,7 +311,7 @@ private int[] searchEdges(char[] query) {
     public String toString() {
         StringBuilder builder = new StringBuilder();
         builder.append("String = ").append(this.string).append("\n");
-        builder.append("End of word character 1 = ").append(END_SEQ_CHAR).append("\n");
+        builder.append("End of word character = ").append(END_SEQ_CHAR).append("\n");
         builder.append(TreePrinter.getString(this));
         return builder.toString();
     }

File: src/com/jwetherell/algorithms/data_structures/SuffixTrie.java
Patch:
@@ -7,7 +7,8 @@
 /**
  * A suffix trie is a data structure that presents the suffixes of a given
  * string in a way that allows for a particularly fast implementation of many
- * important string operations.
+ * important string operations. This implementation is based upon a Trie which
+ * is NOT a compact trie.
  * 
  * http://en.wikipedia.org/wiki/Suffix_trie
  * 

File: src/com/jwetherell/algorithms/data_structures/Trie.java
Patch:
@@ -174,9 +174,9 @@ public String toString() {
     protected static class Node {
         
         private static final int GROW_IN_CHUNKS = 10;
-        private Node[] children = new Node[2];
-        private int childrenSize = 0;
-
+        
+        protected Node[] children = new Node[2];
+        protected int childrenSize = 0;
         protected Node parent = null;
         protected boolean isWord = false; //Signifies this node represents a word
         protected Character character = null; //First character that is different the parent's string

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -44,11 +44,11 @@ public class DataStructures {
     private static Integer[] unsorted = null;
     private static String string = null;
 
-    private static int debug = 0; //debug level. 0=None, 1=Time and Memory (if enabled), 2=Time, Memory, data structure debug
+    private static int debug = 1; //debug level. 0=None, 1=Time and Memory (if enabled), 2=Time, Memory, data structure debug
     private static boolean debugTime = true; //How much time to: add all, remove all, add all items in reverse order, remove all
     private static boolean debugMemory = true; //How much memory is used by the data structure
     private static boolean validateStructure = true; //Is the data structure valid (passed invariants) and proper size
-    private static boolean validateContents = false; //Was the item added/removed really added/removed from the structure
+    private static boolean validateContents = true; //Was the item added/removed really added/removed from the structure
 
     private static final int TESTS = 16; //Number of dynamic data structures to test
     private static int test = 0;

File: src/com/jwetherell/algorithms/data_structures/TrieMap.java
Patch:
@@ -42,13 +42,15 @@ public boolean put(C key, V value) {
                 n.character = c;
                 n.string = key;
                 n.value = value;
+                size++;
                 return true;
             } else {
                 return false;
             }
         } else {
             n = new MapNode<C, V>(prev, c, key, value);
             prev.children.add(n);
+            size++;
             return true;
         }
     }

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -40,12 +40,12 @@ public class DataStructures {
 
     private static final int NUMBER_OF_TESTS = 100;
     private static final Random RANDOM = new Random();
-    private static final int ARRAY_SIZE = 100;
+    private static final int ARRAY_SIZE = 25;
 
     private static Integer[] unsorted = null;
     private static String string = null;
     private static boolean debug = false;
-    private static boolean debugTime = false;
+    private static boolean debugTime = true;
 
 
     public static void main(String[] args) {

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -45,7 +45,7 @@ public class DataStructures {
     private static Integer[] unsorted = null;
     private static String string = null;
     private static boolean debug = false;
-    private static boolean debugTime = true;
+    private static boolean debugTime = false;
 
 
     public static void main(String[] args) {

File: src/com/jwetherell/algorithms/data_structures/Trie.java
Patch:
@@ -18,11 +18,11 @@ public class Trie<C extends CharSequence> {
 
     protected Node<C> root = null;
 
-    public Trie() {
-        root = new Node<C>(null, null);
-    }
+    public Trie() { }
 
     public boolean add(C key) {
+        if (root==null) root = new Node<C>(null, null);
+
         int length = (key.length() - 1);
         Node<C> prev = root;
         for (int i = 0; i < length; i++) {

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -38,7 +38,7 @@
 
 public class DataStructures {
 
-    private static final int SIZE = 25;
+    private static final int SIZE = 1000;
     private static Integer[] unsorted = null;
 
     public static void main(String[] args) {
@@ -580,7 +580,7 @@ public static void main(String[] args) {
             HashMap<Integer,Integer> hash = new HashMap<Integer,Integer>();
             for (int i : unsorted) {
                 hash.put(i, i);
-                boolean exists = hash.contains(i);
+                boolean exists = hash.containsValue(i);
                 if (!exists) {
                     System.err.println("YIKES!! "+i+" doesn't exists.");
                     System.err.println(hash.toString());
@@ -591,7 +591,7 @@ public static void main(String[] args) {
 
             for (int i : unsorted) {
                 hash.remove(i);
-                boolean exists = hash.contains(i);
+                boolean exists = hash.containsValue(i);
                 if (exists) {
                     System.err.println("YIKES!! "+i+" still exists.");
                     System.err.println(hash.toString());

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -38,7 +38,7 @@
 
 public class DataStructures {
 
-    private static final int SIZE = 25;
+    private static final int SIZE = 250;
     private static Integer[] unsorted = null;
 
     public static void main(String[] args) {
@@ -64,6 +64,8 @@ public static void main(String[] args) {
             unsorted[i] = j;
             System.out.print(j+",");
         }
+        
+        unsorted = new Integer[]{621,2135,326,777,1424,694,1555,1964,1647,2193,2311,1356,699,2023,1457,1852,867,357,399,1835,511,1447,215,1298,1910,361,719,1244,1862,904,2308,42,2221,2462,103,847,1540,1673,2119,765,626,1239,580,1267,310,1754,2365,1788,143,1138,1598,252,1366,50,1352,269,2219,712,2229,2096,957,126,21,2318,1430,1706,1184,468,306,1537,15,679,1041,656,244,2485,1997,1807,1237,1981,1243,1675,785,1965,448,2148,519,1889,1832,646,2037,600,268,2066,1266,1217,1308,1279,2123,779,949,1734,86,1546,1572,757,542,2415,142,2074,689,1878,568,2186,2275,2353,1292,1232,1752,439,513,92,1676,2242,1609,444,918,1334,1921,690,140,1606,1046,554,1678,839,1258,1755,1240,534,940,2442,1877,1528,1713,176,555,591,4,1398,352,89,1972,1044,1689,962,1502,1173,748,432,1892,1800,1140,1276,971,1825,94,1884,1744,1229,2464,2170,1741,2161,1263,2214,1787,1824,162,2391,1618,811,863,2002,2288,1422,2166,1030,525,1612,1794,1579,1906,766,2073,1119,2307,425,128,265,2084,213,2398,2076,1028,426,378,2041,645,984,1441,2254,1120,2352,1769,413,2174,1172,1510,896,2092,1248,2430,705,1750,632,2452,2164,2400,758,1643,892,2289,504,186,1327,2374,1379,1125,701,1372,1111,1165,200,1358,138,129,363,1185,649};
 
         System.out.println();
         System.out.println();

File: src/com/jwetherell/algorithms/data_structures/HashMap.java
Patch:
@@ -37,7 +37,7 @@ public boolean put(K key, V value) {
         // Do not add duplicates
         for (int i=0; i<list.size(); i++) {
             V v = list.get(i);
-            if (v == value) return false;
+            if (v.equals(value)) return false;
         }
         list.add(value);
         size++;
@@ -71,7 +71,7 @@ public boolean contains(V value) {
             List<V> list = map[key];
             for (int item=0; item<list.size(); item++) {
                 V v = list.get(item);
-                if (v == value) return true;
+                if (v.equals(value)) return true;
             }
         }
         return false;

File: src/com/jwetherell/algorithms/data_structures/SuffixTrie.java
Patch:
@@ -18,7 +18,7 @@ public class SuffixTrie<C extends CharSequence> extends Trie<C> {
 
     @SuppressWarnings("unchecked")
     public SuffixTrie(String string) {
-        root = new Node<C>(null);
+        root = new Node<C>(null,null);
         int length = string.length();
         for (int i=0; i<length; i++) {
             CharSequence seq = string.substring(i, length);

File: src/com/jwetherell/algorithms/data_structures/RadixTree.java
Patch:
@@ -113,9 +113,9 @@ protected static <C extends CharSequence, V> String getString(Node<C> node, Stri
             StringBuilder builder = new StringBuilder();
             if (node instanceof RadixNode) {
                 RadixNode<C,V> radix = (RadixNode<C,V>) node;
-                builder.append(prefix + (isTail ? "└── " : "├── ") + ((radix.string!=null)?radix.string+" = "+radix.value:"null")+"\n");
+                builder.append(prefix + (isTail ? "└── " : "├── ") + ((radix.string!=null)?radix.string+" ("+radix.type+") "+" = "+radix.value:"null"+" ("+node.type+")")+"\n");
             } else {
-                builder.append(prefix + (isTail ? "└── " : "├── ") + ((node.string!=null)?node.string:"")+"\n");
+                builder.append(prefix + (isTail ? "└── " : "├── ") + ((node.string!=null)?node.string+" ("+node.type+") ":"null"+" ("+node.type+")")+"\n");
             }
             if (node.children != null) {
                 for (int i = 0; i < node.children.size() - 1; i++) {

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -903,7 +903,7 @@ public static void main(String[] args) {
             System.out.println();
         }
     }
-    
+
     private static final String getPathMapString(Graph.Vertex<Integer> start, Map<Graph.Vertex<Integer>, Graph.CostPathPair<Integer>> map) {
         StringBuilder builder = new StringBuilder();
         for (Graph.Vertex<Integer> v : map.keySet()) {

File: src/com/jwetherell/algorithms/data_structures/SuffixTrie.java
Patch:
@@ -2,12 +2,12 @@
 
 
 /**
- * A suffix tree is a data structure that presents the suffixes of a given string in a way that allows 
+ * A suffix trie is a data structure that presents the suffixes of a given string in a way that allows 
  * for a particularly fast implementation of many important string operations. 
  * 
  * == This is NOT a compact tree. ==
  * 
- * http://en.wikipedia.org/wiki/Suffix_tree
+ * http://en.wikipedia.org/wiki/Suffix_trie
  * 
  * @author Justin Wetherell <phishman3579@gmail.com>
  */

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -697,7 +697,7 @@ public static void main(String[] args) {
         	//Treap
         	Treap<Character> treap = new Treap<Character>();
 
-        	String alphabet = new String("ABHIJKLMUFGNRSTVWXYZCDEOPQ");
+        	String alphabet = new String("TVWXYABHIJKLMUFGNRSZCDEOPQ");
         	for (int i=0; i<alphabet.length(); i++) {
         	    treap.add(alphabet.charAt(i));
         	}
@@ -719,7 +719,7 @@ public static void main(String[] args) {
             //SplayTree
             SplayTree<Character> splay = new SplayTree<Character>();
 
-            String alphabet = new String("ABHIJKLMUFGNRSTVWXYZCDEOPQ");
+            String alphabet = new String("KLMUFGNRSTABHIJVWXYZCDEOPQ");
             for (int i=0; i<alphabet.length(); i++) {
                 splay.add(alphabet.charAt(i));
             }

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -732,8 +732,8 @@ public static void main(String[] args) {
                 contains = splay.contains(letter);
                 contains = splay.contains(letter);
                 System.out.println("Does "+letter+" exist in the Treap? "+contains);            
-                //boolean removed = splay.remove(letter);
-                //System.out.println("Was "+letter+" removed from the Treap? "+removed);
+                boolean removed = splay.remove(letter);
+                System.out.println("Was "+letter+" removed from the Treap? "+removed);
                 System.out.println(splay.toString());
             }
             

File: src/com/jwetherell/algorithms/search/BinarySearch.java
Patch:
@@ -33,7 +33,7 @@ private static int recursiveFind(int value, int start, int end, boolean optimize
             if ((end-middle)<=SWITCH_TO_BRUTE_FORCE) return linearSearch(value,middle+1,end);
             return recursiveFind(value,middle+1,end,optimize);
         } else {
-            if ((end-middle)<=SWITCH_TO_BRUTE_FORCE) return linearSearch(value,middle+1,end);
+            if ((end-middle)<=SWITCH_TO_BRUTE_FORCE) return linearSearch(value,start,middle-1);
             return recursiveFind(value,start,middle-1,optimize);
         }
     }

File: src/com/jwetherell/algorithms/search/InterpolationSearch.java
Patch:
@@ -23,6 +23,7 @@ private static int recursiveFind(int value, int start, int end) {
         }
         
         int mid = start + ( (value-sorted[start])*(end-start)) / (sorted[end]-sorted[start] );
+        if (mid<0 || mid>end) return Integer.MAX_VALUE;
         int midValue = sorted[mid];
         if (value==midValue) return mid;
         if (value>midValue) {

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -199,7 +199,6 @@ public static void main(String[] args) {
         }
         
         {
-
             // MAX-HEAP
             System.out.println("Max-Heap.");
             BinaryHeap maxHeap = new BinaryHeap(unsorted,TYPE.MAX);

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -195,6 +195,7 @@ public static void main(String[] args) {
             System.out.println("Removing a previously added node "+next);
             minHeap.remove(next);
             System.out.println(minHeap.toString());
+            System.out.println();
         }
         
         {

File: src/com/jwetherell/algorithms/DataStructures.java
Patch:
@@ -11,7 +11,7 @@
 import com.jwetherell.algorithms.data_structures.Stack;
 
 public class DataStructures {
-    private static final int SIZE = 6;
+    private static final int SIZE = 100;
     
     private static int[] unsorted = null;
     

File: src/com/jwetherell/algorithms/sequence/FibonacciSequence.java
Patch:
@@ -39,7 +39,7 @@ public static final long fibonacciSequenceUsingMatrix(int n) {
         int counter = n-1;
         while (counter>0) {
             temp = multiplyMatrices(matrix, temp);
-            // Subtract an additional 1 when n==0 because the first multiplication is 
+            // Subtract an additional 1 the first time in the loop because the first multiplication is 
             // actually n -= 2 since it multiplying two matrices
             counter -= (counter==(n-1))?2:1;
         }

