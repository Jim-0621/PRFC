File: support/guice/src/test/java/org/apache/shiro/guice/ShiroModuleTest.java
Patch:
@@ -31,14 +31,15 @@
 import org.apache.shiro.event.EventBus;
 import org.apache.shiro.event.EventBusAware;
 import org.apache.shiro.event.Subscribe;
+import org.apache.shiro.lang.util.Destroyable;
 import org.apache.shiro.mgt.DefaultSecurityManager;
 import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.realm.Realm;
 import org.apache.shiro.session.mgt.DefaultSessionManager;
 import org.apache.shiro.session.mgt.SessionManager;
 import org.apache.shiro.subject.Subject;
 import org.junit.jupiter.api.Test;
-import org.apache.shiro.lang.util.Destroyable;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.util.Collection;
 
@@ -51,6 +52,7 @@
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+@Isolated("System property usage")
 public class ShiroModuleTest {
 
     @Test

File: support/guice/src/test/java/org/apache/shiro/guice/web/ShiroWebModuleTest.java
Patch:
@@ -47,6 +47,7 @@
 import org.junit.jupiter.api.Assumptions;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import javax.inject.Named;
 import javax.servlet.Filter;
@@ -76,6 +77,7 @@
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 
+@Isolated("System property usage")
 public class ShiroWebModuleTest {
 
 

File: support/guice/src/test/java/org/apache/shiro/guice/ShiroModuleTest.java
Patch:
@@ -31,14 +31,15 @@
 import org.apache.shiro.event.EventBus;
 import org.apache.shiro.event.EventBusAware;
 import org.apache.shiro.event.Subscribe;
+import org.apache.shiro.lang.util.Destroyable;
 import org.apache.shiro.mgt.DefaultSecurityManager;
 import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.realm.Realm;
 import org.apache.shiro.session.mgt.DefaultSessionManager;
 import org.apache.shiro.session.mgt.SessionManager;
 import org.apache.shiro.subject.Subject;
 import org.junit.jupiter.api.Test;
-import org.apache.shiro.lang.util.Destroyable;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.util.Collection;
 
@@ -51,6 +52,7 @@
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+@Isolated("System property usage")
 public class ShiroModuleTest {
 
     @Test

File: support/guice/src/test/java/org/apache/shiro/guice/web/ShiroWebModuleTest.java
Patch:
@@ -47,6 +47,7 @@
 import org.junit.jupiter.api.Assumptions;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import javax.inject.Named;
 import javax.servlet.Filter;
@@ -76,6 +77,7 @@
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 
+@Isolated("System property usage")
 public class ShiroWebModuleTest {
 
 

File: core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.io.Serializable;
 
@@ -32,6 +33,7 @@
 /**
  * Unit test for the {@link DelegatingSession} class.
  */
+@Isolated
 public class DelegatingSessionTest {
 
     DelegatingSession session;

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -355,7 +355,7 @@ public Subject createSubject(SubjectContext subjectContext) {
         //(this is needed here in case rememberMe principals were resolved and they need to be stored in the
         //session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).
         //Added in 1.2:
-        if (subjectContext.isSessionCreationEnabled()) {
+        if (context.isSessionCreationEnabled()) {
             save(subject);
         }
 

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -355,7 +355,7 @@ public Subject createSubject(SubjectContext subjectContext) {
         //(this is needed here in case rememberMe principals were resolved and they need to be stored in the
         //session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).
         //Added in 1.2:
-        if (subjectContext.isSessionCreationEnabled()) {
+        if (context.isSessionCreationEnabled()) {
             save(subject);
         }
 

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthenticatedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthenticatedException} to HTTP status codes.
- * {@link UnauthenticatedException} will be mapped to 403.
+ * {@link UnauthenticatedException} will be mapped to 401.
  *
  * @since 1.4
  */
@@ -43,6 +43,6 @@ public Response toResponse(UnauthenticatedException exception) {
             LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.FORBIDDEN).build();
+        return Response.status(Status.UNAUTHORIZED).build();
     }
 }

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthorizedException} to HTTP status codes.
- * {@link UnauthorizedException} will be mapped to 401.
+ * {@link UnauthorizedException} will be mapped to 403.
  *
  * @since 1.4
  */
@@ -41,9 +41,9 @@ public class UnauthorizedExceptionExceptionMapper implements ExceptionMapper<Una
     public Response toResponse(UnauthorizedException exception) {
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("unauthenticated.", exception);
+            LOG.debug("unauthorized.", exception);
         }
 
-        return Response.status(Status.UNAUTHORIZED).build();
+        return Response.status(Status.FORBIDDEN).build();
     }
 }

File: core/src/test/java/org/apache/shiro/authc/AbstractAuthenticatorTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.net.URI;
 
@@ -40,6 +41,7 @@
 /**
  * @since 0.1
  */
+@Isolated
 public class AbstractAuthenticatorTest {
 
     static ListAppender listAppender;

File: core/src/test/java/org/apache/shiro/mgt/DefaultSecurityManagerTest.java
Patch:
@@ -34,9 +34,11 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import java.io.Serializable;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -47,6 +49,7 @@
 /**
  * @since 0.2
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class DefaultSecurityManagerTest extends AbstractSecurityManagerTest {
 
     DefaultSecurityManager sm;

File: core/src/test/java/org/apache/shiro/mgt/VMSingletonDefaultSecurityManagerTest.java
Patch:
@@ -28,14 +28,17 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 
 /**
  * @since May 8, 2008 12:26:23 AM
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class VMSingletonDefaultSecurityManagerTest {
 
     @BeforeEach

File: core/src/test/java/org/apache/shiro/realm/activedirectory/ActiveDirectoryRealmTest.java
Patch:
@@ -43,6 +43,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import javax.naming.NamingEnumeration;
 import javax.naming.NamingException;
@@ -52,6 +53,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.easymock.EasyMock.anyObject;
 import static org.easymock.EasyMock.anyString;
 import static org.easymock.EasyMock.capture;
@@ -75,6 +77,7 @@
  * This version was intended to mimic my current usage scenario in an effort to debug upgrade issues which were not related
  * to LDAP connectivity.
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class ActiveDirectoryRealmTest {
 
     private static final String USERNAME = "testuser";

File: core/src/test/java/org/apache/shiro/realm/jdbc/JDBCRealmTest.java
Patch:
@@ -37,6 +37,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import javax.sql.DataSource;
 
@@ -47,6 +48,7 @@
 import java.util.HashMap;
 import java.util.Optional;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
@@ -55,6 +57,7 @@
 /**
  * Test case for JDBCRealm.
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class JDBCRealmTest {
 
     protected DefaultSecurityManager securityManager;

File: core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
Patch:
@@ -30,9 +30,11 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import java.util.UUID;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.easymock.EasyMock.createMock;
 import static org.easymock.EasyMock.eq;
 import static org.easymock.EasyMock.expect;
@@ -48,6 +50,7 @@
 /**
  * Unit test for the {@link DefaultSessionManager DefaultSessionManager} implementation.
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class DefaultSessionManagerTest {
 
     DefaultSessionManager sm;

File: core/src/test/java/org/apache/shiro/test/ExampleShiroIntegrationTest.java
Patch:
@@ -23,12 +23,15 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 
 /**
  * Simple example test class to be used to show how one might write Shiro-compatible unit tests.
  *
  * @since 1.2
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class ExampleShiroIntegrationTest extends AbstractShiroTest {
 
     @BeforeAll

File: core/src/test/java/org/apache/shiro/test/ExampleShiroUnitTest.java
Patch:
@@ -21,7 +21,9 @@
 import org.apache.shiro.subject.Subject;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.easymock.EasyMock.createNiceMock;
 import static org.easymock.EasyMock.expect;
 
@@ -30,6 +32,7 @@
  *
  * @since 1.2
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class ExampleShiroUnitTest extends AbstractShiroTest {
 
     @Test

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: support/ehcache/src/test/java/org/apache/shiro/cache/ehcache/EhCacheManagerTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -37,6 +38,7 @@
  *
  * @since May 11, 2010 12:41:38 PM
  */
+@Isolated
 public class EhCacheManagerTest {
 
     private EhCacheManager cacheManager;

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthenticatedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthenticatedException} to HTTP status codes.
- * {@link UnauthenticatedException} will be mapped to 401.
+ * {@link UnauthenticatedException} will be mapped to 403.
  *
  * @since 1.4
  */
@@ -43,6 +43,6 @@ public Response toResponse(UnauthenticatedException exception) {
             LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.UNAUTHORIZED).build();
+        return Response.status(Status.FORBIDDEN).build();
     }
 }

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthorizedException} to HTTP status codes.
- * {@link UnauthorizedException} will be mapped to 403.
+ * {@link UnauthorizedException} will be mapped to 401.
  *
  * @since 1.4
  */
@@ -41,9 +41,9 @@ public class UnauthorizedExceptionExceptionMapper implements ExceptionMapper<Una
     public Response toResponse(UnauthorizedException exception) {
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("unauthorized.", exception);
+            LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.FORBIDDEN).build();
+        return Response.status(Status.UNAUTHORIZED).build();
     }
 }

File: tools/hasher/src/test/java/org/apache/shiro/tools/hasher/HasherTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -42,6 +43,7 @@
 /**
  * @since 2.0
  */
+@Isolated("Uses System Input")
 public class HasherTest {
 
     private final InputStream systemIn = System.in;

File: web/src/test/java/org/apache/shiro/web/mgt/DefaultWebSecurityManagerTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -56,6 +57,7 @@
 /**
  * @since 0.9
  */
+@Isolated
 public class DefaultWebSecurityManagerTest extends AbstractWebSecurityManagerTest {
 
     private DefaultWebSecurityManager sm;

File: core/src/test/java/org/apache/shiro/authc/AbstractAuthenticatorTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.net.URI;
 
@@ -40,6 +41,7 @@
 /**
  * @since 0.1
  */
+@Isolated
 public class AbstractAuthenticatorTest {
 
     static ListAppender listAppender;

File: core/src/test/java/org/apache/shiro/mgt/DefaultSecurityManagerTest.java
Patch:
@@ -34,9 +34,11 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import java.io.Serializable;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -47,6 +49,7 @@
 /**
  * @since 0.2
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class DefaultSecurityManagerTest extends AbstractSecurityManagerTest {
 
     DefaultSecurityManager sm;

File: core/src/test/java/org/apache/shiro/mgt/VMSingletonDefaultSecurityManagerTest.java
Patch:
@@ -28,14 +28,17 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 
 /**
  * @since May 8, 2008 12:26:23 AM
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class VMSingletonDefaultSecurityManagerTest {
 
     @BeforeEach

File: core/src/test/java/org/apache/shiro/realm/activedirectory/ActiveDirectoryRealmTest.java
Patch:
@@ -43,6 +43,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import javax.naming.NamingEnumeration;
 import javax.naming.NamingException;
@@ -52,6 +53,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.easymock.EasyMock.anyObject;
 import static org.easymock.EasyMock.anyString;
 import static org.easymock.EasyMock.capture;
@@ -75,6 +77,7 @@
  * This version was intended to mimic my current usage scenario in an effort to debug upgrade issues which were not related
  * to LDAP connectivity.
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class ActiveDirectoryRealmTest {
 
     private static final String USERNAME = "testuser";

File: core/src/test/java/org/apache/shiro/realm/jdbc/JDBCRealmTest.java
Patch:
@@ -37,6 +37,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import javax.sql.DataSource;
 
@@ -47,6 +48,7 @@
 import java.util.HashMap;
 import java.util.Optional;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
@@ -55,6 +57,7 @@
 /**
  * Test case for JDBCRealm.
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class JDBCRealmTest {
 
     protected DefaultSecurityManager securityManager;

File: core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
Patch:
@@ -30,9 +30,11 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
 import java.util.UUID;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.easymock.EasyMock.createMock;
 import static org.easymock.EasyMock.eq;
 import static org.easymock.EasyMock.expect;
@@ -48,6 +50,7 @@
 /**
  * Unit test for the {@link DefaultSessionManager DefaultSessionManager} implementation.
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class DefaultSessionManagerTest {
 
     DefaultSessionManager sm;

File: core/src/test/java/org/apache/shiro/test/ExampleShiroIntegrationTest.java
Patch:
@@ -23,12 +23,15 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 
 /**
  * Simple example test class to be used to show how one might write Shiro-compatible unit tests.
  *
  * @since 1.2
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class ExampleShiroIntegrationTest extends AbstractShiroTest {
 
     @BeforeAll

File: core/src/test/java/org/apache/shiro/test/ExampleShiroUnitTest.java
Patch:
@@ -21,7 +21,9 @@
 import org.apache.shiro.subject.Subject;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
 
+import static org.apache.shiro.test.AbstractShiroTest.GLOBAL_SECURITY_MANAGER_RESOURCE;
 import static org.easymock.EasyMock.createNiceMock;
 import static org.easymock.EasyMock.expect;
 
@@ -30,6 +32,7 @@
  *
  * @since 1.2
  */
+@ResourceLock(GLOBAL_SECURITY_MANAGER_RESOURCE)
 public class ExampleShiroUnitTest extends AbstractShiroTest {
 
     @Test

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: support/ehcache/src/test/java/org/apache/shiro/cache/ehcache/EhCacheManagerTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -37,6 +38,7 @@
  *
  * @since May 11, 2010 12:41:38 PM
  */
+@Isolated
 public class EhCacheManagerTest {
 
     private EhCacheManager cacheManager;

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthenticatedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthenticatedException} to HTTP status codes.
- * {@link UnauthenticatedException} will be mapped to 401.
+ * {@link UnauthenticatedException} will be mapped to 403.
  *
  * @since 1.4
  */
@@ -43,6 +43,6 @@ public Response toResponse(UnauthenticatedException exception) {
             LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.UNAUTHORIZED).build();
+        return Response.status(Status.FORBIDDEN).build();
     }
 }

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthorizedException} to HTTP status codes.
- * {@link UnauthorizedException} will be mapped to 403.
+ * {@link UnauthorizedException} will be mapped to 401.
  *
  * @since 1.4
  */
@@ -41,9 +41,9 @@ public class UnauthorizedExceptionExceptionMapper implements ExceptionMapper<Una
     public Response toResponse(UnauthorizedException exception) {
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("unauthorized.", exception);
+            LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.FORBIDDEN).build();
+        return Response.status(Status.UNAUTHORIZED).build();
     }
 }

File: tools/hasher/src/test/java/org/apache/shiro/tools/hasher/HasherTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -42,6 +43,7 @@
 /**
  * @since 2.0
  */
+@Isolated("Uses System Input")
 public class HasherTest {
 
     private final InputStream systemIn = System.in;

File: web/src/test/java/org/apache/shiro/web/mgt/DefaultWebSecurityManagerTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Isolated;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -56,6 +57,7 @@
 /**
  * @since 0.9
  */
+@Isolated
 public class DefaultWebSecurityManagerTest extends AbstractWebSecurityManagerTest {
 
     private DefaultWebSecurityManager sm;

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthenticatedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthenticatedException} to HTTP status codes.
- * {@link UnauthenticatedException} will be mapped to 403.
+ * {@link UnauthenticatedException} will be mapped to 401.
  *
  * @since 1.4
  */

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * JAX-RS exception mapper used to map Shiro {@link UnauthorizedException} to HTTP status codes.
- * {@link UnauthorizedException} will be mapped to 401.
+ * {@link UnauthorizedException} will be mapped to 403.
  *
  * @since 1.4
  */

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthenticatedExceptionExceptionMapper.java
Patch:
@@ -43,6 +43,6 @@ public Response toResponse(UnauthenticatedException exception) {
             LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.FORBIDDEN).build();
+        return Response.status(Status.UNAUTHORIZED).build();
     }
 }

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java
Patch:
@@ -41,9 +41,9 @@ public class UnauthorizedExceptionExceptionMapper implements ExceptionMapper<Una
     public Response toResponse(UnauthorizedException exception) {
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("unauthenticated.", exception);
+            LOG.debug("unauthorized.", exception);
         }
 
-        return Response.status(Status.UNAUTHORIZED).build();
+        return Response.status(Status.FORBIDDEN).build();
     }
 }

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthenticatedExceptionExceptionMapper.java
Patch:
@@ -43,6 +43,6 @@ public Response toResponse(UnauthenticatedException exception) {
             LOG.debug("unauthenticated.", exception);
         }
 
-        return Response.status(Status.FORBIDDEN).build();
+        return Response.status(Status.UNAUTHORIZED).build();
     }
 }

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/UnauthorizedExceptionExceptionMapper.java
Patch:
@@ -41,9 +41,9 @@ public class UnauthorizedExceptionExceptionMapper implements ExceptionMapper<Una
     public Response toResponse(UnauthorizedException exception) {
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("unauthenticated.", exception);
+            LOG.debug("unauthorized.", exception);
         }
 
-        return Response.status(Status.UNAUTHORIZED).build();
+        return Response.status(Status.FORBIDDEN).build();
     }
 }

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -355,7 +355,9 @@ public Subject createSubject(SubjectContext subjectContext) {
         //(this is needed here in case rememberMe principals were resolved and they need to be stored in the
         //session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).
         //Added in 1.2:
-        save(subject);
+        if (subjectContext.isSessionCreationEnabled()) {
+            save(subject);
+        }
 
         return subject;
     }

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -355,7 +355,9 @@ public Subject createSubject(SubjectContext subjectContext) {
         //(this is needed here in case rememberMe principals were resolved and they need to be stored in the
         //session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).
         //Added in 1.2:
-        save(subject);
+        if (subjectContext.isSessionCreationEnabled()) {
+            save(subject);
+        }
 
         return subject;
     }

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: integration-tests/jaxrs/tests/src/main/java/org/apache/shiro/testing/jaxrs/tests/AbstractShiroJaxRsIT.java
Patch:
@@ -58,7 +58,7 @@ public void testGetUsersUnauthenticated() {
         final Response usersResponse = usersTarget.request(MediaType.APPLICATION_JSON_TYPE)
                 .buildGet()
                 .invoke();
-        assertEquals(Status.UNAUTHORIZED.getStatusCode(), usersResponse.getStatus());
+        assertEquals(Status.FORBIDDEN.getStatusCode(), usersResponse.getStatus());
     }
 
     @SuppressWarnings({"checkstyle:MagicNumber"})

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/faces/tags/SecureComponent.java
Patch:
@@ -33,7 +33,7 @@ protected Subject getSubject() {
     }
 
     @Override
-    public void encodeAll(FacesContext ctx) throws IOException {
+    public void encodeEnd(FacesContext ctx) throws IOException {
         verifyAttributes();
         doEncodeAll(ctx);
     }

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/faces/tags/SecureComponent.java
Patch:
@@ -33,7 +33,7 @@ protected Subject getSubject() {
     }
 
     @Override
-    public void encodeAll(FacesContext ctx) throws IOException {
+    public void encodeEnd(FacesContext ctx) throws IOException {
         verifyAttributes();
         doEncodeAll(ctx);
     }

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/listeners/EnvironmentLoaderListener.java
Patch:
@@ -13,6 +13,7 @@
  */
 package org.apache.shiro.ee.listeners;
 
+import java.util.Optional;
 import java.util.Set;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletContextEvent;
@@ -61,7 +62,8 @@ public void contextInitialized(ServletContextEvent sce) {
             sce.getServletContext().setAttribute(FORM_RESUBMIT_DISABLED_PARAM, Boolean.TRUE);
         }
         String secureCookiesStr = sce.getServletContext().getInitParameter(FORM_RESUBMIT_SECURE_COOKIES);
-        if (secureCookiesStr == null || Boolean.parseBoolean(secureCookiesStr)) {
+        if (Optional.ofNullable(System.getProperty(FORM_RESUBMIT_SECURE_COOKIES)).map(Boolean::valueOf)
+                        .or(() -> Optional.ofNullable(secureCookiesStr).map(Boolean::valueOf)).orElse(true)) {
             sce.getServletContext().setAttribute(FORM_RESUBMIT_SECURE_COOKIES, Boolean.TRUE);
         } else {
             sce.getServletContext().setAttribute(FORM_RESUBMIT_SECURE_COOKIES, Boolean.FALSE);

File: core/src/main/java/org/apache/shiro/authc/credential/DefaultPasswordService.java
Patch:
@@ -141,7 +141,9 @@ protected void checkHashFormatDurability() {
     }
 
     protected HashRequest createHashRequest(ByteSource plaintext) {
-        return new HashRequest.Builder().setSource(plaintext).build();
+        return new HashRequest.Builder().setSource(plaintext)
+                .setAlgorithmName(getHashService().getDefaultAlgorithmName())
+                .build();
     }
 
     protected ByteSource createByteSource(Object o) {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/DefaultHashService.java
Patch:
@@ -108,6 +108,7 @@ public void setDefaultAlgorithmName(String name) {
         this.defaultAlgorithmName = name;
     }
 
+    @Override
     public String getDefaultAlgorithmName() {
         return this.defaultAlgorithmName;
     }

File: core/src/main/java/org/apache/shiro/authc/credential/DefaultPasswordService.java
Patch:
@@ -141,7 +141,9 @@ protected void checkHashFormatDurability() {
     }
 
     protected HashRequest createHashRequest(ByteSource plaintext) {
-        return new HashRequest.Builder().setSource(plaintext).build();
+        return new HashRequest.Builder().setSource(plaintext)
+                .setAlgorithmName(getHashService().getDefaultAlgorithmName())
+                .build();
     }
 
     protected ByteSource createByteSource(Object o) {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/DefaultHashService.java
Patch:
@@ -108,6 +108,7 @@ public void setDefaultAlgorithmName(String name) {
         this.defaultAlgorithmName = name;
     }
 
+    @Override
     public String getDefaultAlgorithmName() {
         return this.defaultAlgorithmName;
     }

File: cache/src/main/java/org/apache/shiro/cache/MemoryConstrainedCacheManager.java
Patch:
@@ -42,7 +42,7 @@ public class MemoryConstrainedCacheManager extends AbstractCacheManager {
      * @return a new {@link MapCache MapCache} instance backed by a {@link SoftHashMap}.
      */
     @Override
-    protected Cache createCache(String name) {
-        return new MapCache<Object, Object>(name, new SoftHashMap<Object, Object>());
+    protected <K, V> Cache<K, V> createCache(String name) {
+        return new MapCache<>(name, new SoftHashMap<>());
     }
 }

File: core/src/main/java/org/apache/shiro/authc/credential/Sha256CredentialsMatcher.java
Patch:
@@ -29,6 +29,7 @@
  * @deprecated since 1.1 - use the HashedCredentialsMatcher directly and set its
  * {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
  */
+@Deprecated
 public class Sha256CredentialsMatcher extends HashedCredentialsMatcher {
 
     public Sha256CredentialsMatcher() {

File: core/src/main/java/org/apache/shiro/authc/credential/Sha384CredentialsMatcher.java
Patch:
@@ -29,6 +29,7 @@
  * @deprecated since 1.1 - use the HashedCredentialsMatcher directly and set its
  * {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
  */
+@Deprecated
 public class Sha384CredentialsMatcher extends HashedCredentialsMatcher {
 
     public Sha384CredentialsMatcher() {

File: core/src/main/java/org/apache/shiro/authc/credential/Sha512CredentialsMatcher.java
Patch:
@@ -29,6 +29,7 @@
  * @deprecated since 1.1 - use the HashedCredentialsMatcher directly and set its
  * {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
  */
+@Deprecated
 public class Sha512CredentialsMatcher extends HashedCredentialsMatcher {
 
     public Sha512CredentialsMatcher() {

File: core/src/main/java/org/apache/shiro/jndi/JndiObjectFactory.java
Patch:
@@ -33,6 +33,7 @@ public class JndiObjectFactory<T> extends JndiLocator implements Factory<T> {
     private String resourceName;
     private Class<? extends T> requiredType;
 
+    @SuppressWarnings("unchecked")
     public T getInstance() {
         try {
             if (requiredType != null) {

File: core/src/main/java/org/apache/shiro/realm/AuthenticatingRealm.java
Patch:
@@ -223,7 +223,7 @@ public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) {
      * @return the authenticationToken class supported by this realm.
      * @see #setAuthenticationTokenClass
      */
-    public Class getAuthenticationTokenClass() {
+    public Class<? extends AuthenticationToken> getAuthenticationTokenClass() {
         return authenticationTokenClass;
     }
 

File: core/src/main/java/org/apache/shiro/realm/ldap/JndiLdapRealm.java
Patch:
@@ -25,6 +25,7 @@
  * @since 1.1
  * @deprecated Renamed to {@link DefaultLdapRealm}, this class will be removed prior to 2.0
  */
+@Deprecated
 public class JndiLdapRealm extends DefaultLdapRealm {
 
 }

File: core/src/main/java/org/apache/shiro/session/mgt/eis/EnterpriseCacheSessionDAO.java
Patch:
@@ -54,8 +54,8 @@ public class EnterpriseCacheSessionDAO extends CachingSessionDAO {
     public EnterpriseCacheSessionDAO() {
         setCacheManager(new AbstractCacheManager() {
             @Override
-            protected Cache<Serializable, Session> createCache(String name) throws CacheException {
-                return new MapCache<Serializable, Session>(name, new ConcurrentHashMap<Serializable, Session>());
+            protected <Serializable, Session> Cache<Serializable, Session> createCache(String name) throws CacheException {
+                return new MapCache<>(name, new ConcurrentHashMap<>());
             }
         });
     }

File: core/src/main/java/org/apache/shiro/util/CollectionUtils.java
Patch:
@@ -38,6 +38,7 @@ public final class CollectionUtils {
     private CollectionUtils() {
     }
 
+    @SafeVarargs
     public static <E> Set<E> asSet(E... elements) {
         if (elements == null || elements.length == 0) {
             return Collections.emptySet();
@@ -116,6 +117,7 @@ public static boolean isEmpty(PrincipalCollection principals) {
         return principals == null || principals.isEmpty();
     }
 
+    @SafeVarargs
     public static <E> List<E> asList(E... elements) {
         if (elements == null || elements.length == 0) {
             return Collections.emptyList();

File: core/src/test/java/org/apache/shiro/authc/credential/AbstractHashedCredentialsMatcherTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.shiro.authc.AuthenticationToken;
 import org.apache.shiro.authc.SimpleAuthenticationInfo;
 import org.apache.shiro.authc.UsernamePasswordToken;
-import org.apache.shiro.crypto.hash.AbstractHash;
+import org.apache.shiro.crypto.hash.SimpleHash;
 import org.apache.shiro.lang.util.ClassUtils;
 import org.junit.jupiter.api.Test;
 
@@ -36,7 +36,7 @@ public abstract class AbstractHashedCredentialsMatcherTest {
 
     public abstract Class<? extends HashedCredentialsMatcher> getMatcherClass();
 
-    public abstract AbstractHash hash(Object credentials);
+    public abstract SimpleHash hash(Object credentials);
 
     @Test
     void testBasic() {

File: core/src/test/java/org/apache/shiro/authc/credential/HashedCredentialsMatcherTest.java
Patch:
@@ -95,6 +95,7 @@ public Object getCredentials() {
      * <a href="https://issues.apache.org/jira/browse/SHIRO-186">SHIRO-186</a> edits.
      */
     @Test
+    @SuppressWarnings("deprecation")
     void testBackwardsCompatibleSaltedAuthenticationInfo() {
         HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(Sha512Hash.ALGORITHM_NAME);
         //enable this for Shiro 1.0 backwards compatibility:

File: core/src/test/java/org/apache/shiro/authc/credential/Sha256CredentialsMatcherTest.java
Patch:
@@ -18,20 +18,21 @@
  */
 package org.apache.shiro.authc.credential;
 
-import org.apache.shiro.crypto.hash.AbstractHash;
 import org.apache.shiro.crypto.hash.Sha256Hash;
+import org.apache.shiro.crypto.hash.SimpleHash;
 
 
 /**
  * @since Jun 10, 2008 5:01:00 PM
  */
+@Deprecated
 public class Sha256CredentialsMatcherTest extends AbstractHashedCredentialsMatcherTest {
 
     public Class<? extends HashedCredentialsMatcher> getMatcherClass() {
         return Sha256CredentialsMatcher.class;
     }
 
-    public AbstractHash hash(Object credentials) {
+    public SimpleHash hash(Object credentials) {
         return new Sha256Hash(credentials);
     }
 }

File: core/src/test/java/org/apache/shiro/authc/credential/Sha384CredentialsMatcherTest.java
Patch:
@@ -18,20 +18,21 @@
  */
 package org.apache.shiro.authc.credential;
 
-import org.apache.shiro.crypto.hash.AbstractHash;
 import org.apache.shiro.crypto.hash.Sha384Hash;
+import org.apache.shiro.crypto.hash.SimpleHash;
 
 
 /**
  * @since Jun 10, 2008 5:02:27 PM
  */
+@Deprecated
 public class Sha384CredentialsMatcherTest extends AbstractHashedCredentialsMatcherTest {
 
     public Class<? extends HashedCredentialsMatcher> getMatcherClass() {
         return Sha384CredentialsMatcher.class;
     }
 
-    public AbstractHash hash(Object credentials) {
+    public SimpleHash hash(Object credentials) {
         return new Sha384Hash(credentials);
     }
 }

File: core/src/test/java/org/apache/shiro/authc/credential/Sha512CredentialsMatcherTest.java
Patch:
@@ -18,20 +18,21 @@
  */
 package org.apache.shiro.authc.credential;
 
-import org.apache.shiro.crypto.hash.AbstractHash;
 import org.apache.shiro.crypto.hash.Sha512Hash;
+import org.apache.shiro.crypto.hash.SimpleHash;
 
 
 /**
  * @since Jun 10, 2008 5:02:58 PM
  */
+@Deprecated
 public class Sha512CredentialsMatcherTest extends AbstractHashedCredentialsMatcherTest {
 
     public Class<? extends HashedCredentialsMatcher> getMatcherClass() {
         return Sha512CredentialsMatcher.class;
     }
 
-    public AbstractHash hash(Object credentials) {
+    public SimpleHash hash(Object credentials) {
         return new Sha512Hash(credentials);
     }
 }

File: core/src/test/java/org/apache/shiro/config/HashMapCacheManager.java
Patch:
@@ -35,8 +35,8 @@
 public class HashMapCacheManager<K, V> extends AbstractCacheManager {
 
     @Override
-    protected Cache createCache(String name) throws CacheException {
-        return new HashMapCache<K, V>(name);
+    protected <K, V> Cache<K, V> createCache(String name) throws CacheException {
+        return new HashMapCache<>(name);
     }
 
     //This class is not strictly necessary - it exists to verify a test case only.

File: core/src/test/java/org/apache/shiro/realm/jdbc/JDBCRealmTest.java
Patch:
@@ -22,10 +22,10 @@
 import org.apache.shiro.authc.AuthenticationException;
 import org.apache.shiro.authc.IncorrectCredentialsException;
 import org.apache.shiro.authc.UsernamePasswordToken;
+import org.apache.shiro.env.BasicIniEnvironment;
 import org.apache.shiro.lang.codec.Base64;
 import org.apache.shiro.lang.codec.CodecSupport;
 import org.apache.shiro.config.Ini;
-import org.apache.shiro.ini.IniSecurityManagerFactory;
 import org.apache.shiro.crypto.hash.Sha256Hash;
 import org.apache.shiro.mgt.DefaultSecurityManager;
 import org.apache.shiro.realm.AuthorizingRealm;
@@ -84,8 +84,8 @@ public void setup(TestInfo testInfo) {
         config.setSectionProperty("main", "myRealm.credentialsMatcher", "$myRealmCredentialsMatcher");
         config.setSectionProperty("main", "securityManager.sessionManager.sessionValidationSchedulerEnabled", "false");
 
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(config);
-        securityManager = (DefaultSecurityManager) factory.createInstance();
+        var basicIniEnvironment = new BasicIniEnvironment(config);
+        securityManager = (DefaultSecurityManager) basicIniEnvironment.getSecurityManager();
         SecurityUtils.setSecurityManager(securityManager);
 
         // Create a database and realm for the test

File: core/src/test/java/org/apache/shiro/realm/ldap/JndiLdapRealmTest.java
Patch:
@@ -29,6 +29,7 @@
  * @deprecated Replaced by {@link DefaultLdapRealmTest}
  */
 @SuppressWarnings({"ThrowableInstanceNeverThrown", "deprecation"})
+@Deprecated
 public class JndiLdapRealmTest extends DefaultLdapRealmTest {
 
     protected DefaultLdapRealm getNewRealmUnderTest() {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/format/ProvidedHashFormat.java
Patch:
@@ -30,11 +30,13 @@ public enum ProvidedHashFormat {
     /**
      * Value representing the {@link HexFormat} implementation.
      */
+    @Deprecated
     HEX(HexFormat.class),
 
     /**
      * Value representing the {@link Base64Format} implementation.
      */
+    @Deprecated
     BASE64(Base64Format.class),
 
     /**

File: integration-tests/guice3/src/main/java/org/apache/shiro/samples/guice/SampleShiroServletModule.java
Patch:
@@ -45,6 +45,7 @@ public SampleShiroServletModule(ServletContext servletContext) {
     }
 
     @Override
+    @SuppressWarnings({"unchecked", "deprecation"})
     protected void configureShiroWeb() {
         bindConstant().annotatedWith(Names.named("shiro.loginUrl")).to("/login.jsp");
         try {

File: integration-tests/support/src/main/java/org/apache/shiro/testing/web/AbstractContainerIT.java
Patch:
@@ -30,7 +30,7 @@
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.server.SslConnectionFactory;
-import org.eclipse.jetty.util.resource.FileResource;
+import org.eclipse.jetty.util.resource.PathResource;
 import org.eclipse.jetty.util.ssl.SslContextFactory;
 import org.eclipse.jetty.webapp.Configuration;
 import org.eclipse.jetty.webapp.FragmentConfiguration;
@@ -55,7 +55,6 @@
 import java.nio.file.StandardCopyOption;
 
 import static org.apache.commons.lang3.StringUtils.isNotBlank;
-import static org.eclipse.jetty.util.resource.Resource.newResource;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -113,7 +112,7 @@ protected WebAppContext createdWebAppContext() throws Exception {
                     // See: http://stackoverflow.com/questions/13222071/spring-3-1-webapplicationinitializer-embedded-jetty-8-annotationconfiguration
                     // And more precisely: http://stackoverflow.com/a/18449506/1215828
                     File classes = new File(classpath);
-                    FileResource containerResources = new FileResource(classes.toURI());
+                    var containerResources = new PathResource(classes.toURI());
                     ctx.getMetaData().addContainerResource(containerResources);
                 }
 

File: lang/src/main/java/org/apache/shiro/lang/io/XmlSerializer.java
Patch:
@@ -36,6 +36,7 @@
  * @since 0.9
  * @deprecated This class should not be used directly because of unsecure XMLEncoder/XMLDecoder usage.
  */
+@Deprecated(forRemoval = true)
 public class XmlSerializer implements Serializer {
 
     /**

File: lang/src/main/java/org/apache/shiro/lang/util/Assert.java
Patch:
@@ -388,7 +388,7 @@ public static void isAssignable(Class superType, Class subType) {
      *                  ok when prepended to it.
      * @throws IllegalArgumentException if the classes are not assignable
      */
-    public static void isAssignable(Class superType, Class subType, String message) {
+    public static void isAssignable(Class<?> superType, Class<?> subType, String message) {
         notNull(superType, "Type to check against must not be null");
         if (subType == null || !superType.isAssignableFrom(subType)) {
             throw new IllegalArgumentException(message + subType + " is not assignable to " + superType);

File: lang/src/main/java/org/apache/shiro/lang/util/SoftHashMap.java
Patch:
@@ -236,6 +236,7 @@ public Set<K> keySet() {
         return map.keySet();
     }
 
+    @SuppressWarnings("unchecked")
     public Collection<V> values() {
         processQueue();
         Collection<K> keys = map.keySet();
@@ -289,6 +290,7 @@ public int size() {
         return map.size();
     }
 
+    @SuppressWarnings("unchecked")
     public Set<Map.Entry<K, V>> entrySet() {
         // throw out garbage collected values first
         processQueue();

File: lang/src/main/java/org/apache/shiro/lang/util/StringUtils.java
Patch:
@@ -535,6 +535,7 @@ public static String uppercaseFirstChar(String in) {
     // CollectionUtils cannot be removed from shiro-core until 2.0 as it has a dependency on PrincipalCollection
 
 
+    @SafeVarargs
     private static <E> Set<E> asSet(E... elements) {
         if (elements == null || elements.length == 0) {
             return Collections.emptySet();

File: samples/quickstart/src/main/java/Quickstart.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.apache.shiro.SecurityUtils;
 import org.apache.shiro.authc.*;
+import org.apache.shiro.env.BasicIniEnvironment;
 import org.apache.shiro.ini.IniSecurityManagerFactory;
 import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.session.Session;
@@ -46,14 +47,13 @@ public static void main(String[] args) {
 
         // Use the shiro.ini file at the root of the classpath
         // (file: and url: prefixes load from files and urls respectively):
-        Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
-        SecurityManager securityManager = factory.getInstance();
+        SecurityManager securityManager = new BasicIniEnvironment("classpath:shiro.ini").getSecurityManager();
 
         // for this simple example quickstart, make the SecurityManager
         // accessible as a JVM singleton.  Most applications wouldn't do this
         // and instead rely on their container configuration or web.xml for
         // webapps.  That is outside the scope of this simple quickstart, so
-        // we'll just do the bare minimum so you can continue to get a feel
+        // we'll just do the bare minimum, so you can continue to get a feel
         // for things.
         SecurityUtils.setSecurityManager(securityManager);
 

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/dao/HibernateUserDAO.java
Patch:
@@ -18,9 +18,9 @@
  */
 package org.apache.shiro.samples.sprhib.dao;
 
+import org.apache.shiro.lang.util.Assert;
 import org.apache.shiro.samples.sprhib.model.User;
 import org.springframework.stereotype.Repository;
-import org.springframework.util.Assert;
 
 import java.util.List;
 
@@ -35,7 +35,7 @@ public User getUser(Long userId) {
     public User findUser(String username) {
         Assert.hasText(username);
         String query = "from User u where u.username = :username";
-        return (User) getSession().createQuery(query).setString("username", username).uniqueResult();
+        return (User) getSession().createQuery(query).setParameter("username", username).uniqueResult();
     }
 
     public void createUser(User user) {

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/security/SampleRealm.java
Patch:
@@ -49,6 +49,7 @@ public class SampleRealm extends AuthorizingRealm {
 
     protected UserDAO userDAO;
 
+    @SuppressWarnings("deprecation")
     public SampleRealm() {
         //This name must match the name in the User class's getPrincipals() method
         setName("SampleRealm");

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/CurrentUserInterceptor.java
Patch:
@@ -22,8 +22,8 @@
 import org.apache.shiro.samples.sprhib.service.UserService;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Component;
+import org.springframework.web.servlet.HandlerInterceptor;
 import org.springframework.web.servlet.ModelAndView;
-import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
 
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -34,7 +34,7 @@
  * cached in the Hibernate second-level cache.
  */
 @Component
-public class CurrentUserInterceptor extends HandlerInterceptorAdapter {
+public class CurrentUserInterceptor implements HandlerInterceptor {
 
     private UserService userService;
 

File: samples/spring-mvc/src/main/java/org/apache/shiro/samples/spring/config/RemotingServletConfig.java
Patch:
@@ -33,6 +33,7 @@
 public class RemotingServletConfig {
 
     @Bean(name = "/sampleManager")
+    @SuppressWarnings("deprecation")
     public HttpInvokerServiceExporter accountServiceExporter(SampleManager sampleManager,
                                                              SecureRemoteInvocationExecutor secureRemoteInvocationExecutor) {
 

File: support/ehcache/src/main/java/org/apache/shiro/cache/ehcache/EhCache.java
Patch:
@@ -69,6 +69,7 @@ public EhCache(net.sf.ehcache.Ehcache cache) {
      * @param key the key of the element to return.
      * @return The value placed into the cache with an earlier put, or null if not found or expired
      */
+    @SuppressWarnings("unchecked")
     public V get(K key) throws CacheException {
         try {
             if (LOGGER.isTraceEnabled()) {
@@ -84,7 +85,6 @@ public V get(K key) throws CacheException {
                     }
                     return null;
                 } else {
-                    //noinspection unchecked
                     return (V) element.getObjectValue();
                 }
             }

File: support/guice/src/test/java/org/apache/shiro/guice/BeanTypeListenerTest.java
Patch:
@@ -73,15 +73,18 @@ void testMatchedPackage() throws Exception {
 
     @Test
     void testPropertySetting() throws Exception {
+        @SuppressWarnings("unchecked")
         TypeEncounter<SomeInjectableBean> encounter = mock(TypeEncounter.class);
 
+        @SuppressWarnings("unchecked")
         Provider<Injector> injectorProvider = mock(Provider.class);
         Injector injector = mock(Injector.class);
 
         when(encounter.getProvider(Injector.class)).then(args -> injectorProvider);
 
         when(injectorProvider.get()).then(args -> injector);
 
+        @SuppressWarnings("unchecked")
         ArgumentCaptor<MembersInjector<SomeInjectableBean>> captor = ArgumentCaptor.forClass(MembersInjector.class);
 
         SecurityManager securityManager = mock(SecurityManager.class);

File: support/guice/src/test/java/org/apache/shiro/guice/LifecycleTypeListenerTest.java
Patch:
@@ -33,6 +33,7 @@
 
 public class LifecycleTypeListenerTest {
     @Test
+    @SuppressWarnings({"unchecked", "rawtypes"})
     void testHearInitializable() throws Exception {
         TypeEncounter encounter = createMock(TypeEncounter.class);
 
@@ -48,7 +49,9 @@ void testHearInitializable() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     void testHearDestroyable() throws Exception {
+        @SuppressWarnings("rawtypes")
         TypeEncounter encounter = createMock(TypeEncounter.class);
 
         encounter.register(anyObject(DestroyableInjectionListener.class));

File: support/guice/src/test/java/org/apache/shiro/guice/web/AbstractInjectionProviderTest.java
Patch:
@@ -49,6 +49,7 @@ public class AbstractInjectionProviderTest {
     static Key keyF1 = Key.get(Object.class, Names.named("field1"));
 
     @Test
+    @SuppressWarnings("unchecked")
     void testGet() throws Exception {
         Injector mockInjector = createMock(Injector.class);
 

File: support/guice/src/test/java/org/apache/shiro/guice/web/DefaultFiltersTest.java
Patch:
@@ -36,6 +36,7 @@ void checkDefaultFilters() throws Exception {
         EnumSet<DefaultFilter> defaultFilters = EnumSet.allOf(DefaultFilter.class);
         for (Field field : ShiroWebModule.class.getFields()) {
             if (Modifier.isStatic(field.getModifiers()) && Key.class.isAssignableFrom(field.getType())) {
+                @SuppressWarnings("unchecked")
                 Class<? extends Filter> filterType = ((Key) field.get(null)).getTypeLiteral().getRawType();
                 boolean found = false;
                 for (DefaultFilter filter : defaultFilters) {

File: support/guice/src/test/java/org/apache/shiro/guice/web/FilterChainResolverProviderTest.java
Patch:
@@ -51,8 +51,9 @@ public class FilterChainResolverProviderTest {
     private FilterChainResolverProvider underTest;
 
     @BeforeEach
+    @SuppressWarnings("unchecked")
     public void setup() {
-        chains = new LinkedHashMap<String, Key<? extends Filter>[]>();
+        chains = new LinkedHashMap<>();
 
         key1a = Key.get(Filter.class, Names.named("key1a"));
         key1b = Key.get(Filter.class, Names.named("key1b"));
@@ -66,6 +67,7 @@ public void setup() {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     void testGetDependencies() throws Exception {
 
         Set<Dependency<?>> dependencySet = underTest.getDependencies();

File: support/guice/src/test/java/org/apache/shiro/guice/web/PathMatchingFilterProviderTest.java
Patch:
@@ -32,6 +32,7 @@
 
 public class PathMatchingFilterProviderTest {
     @Test
+    @SuppressWarnings("unchecked")
     void testPostProcess() {
         PathMatchingFilter filter = createMock(PathMatchingFilter.class);
 

File: support/guice/src/test/java/org/apache/shiro/guice/web/SimpleFilterChainResolverTest.java
Patch:
@@ -49,6 +49,7 @@
 public class SimpleFilterChainResolverTest {
 
     @Test
+    @SuppressWarnings("unchecked")
     void testGetChain() throws Exception {
         // test that it uses the pattern matcher - check
         // test that the FIRST chain found is the one that gets returned - check

File: web/src/main/java/org/apache/shiro/web/config/IniFilterChainResolverFactory.java
Patch:
@@ -43,6 +43,7 @@
  *
  * @since 1.0
  */
+@SuppressWarnings("deprecation")
 public class IniFilterChainResolverFactory extends IniFactorySupport<FilterChainResolver> {
 
     /**

File: web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManager.java
Patch:
@@ -31,7 +31,6 @@
 import javax.servlet.FilterConfig;
 import javax.servlet.ServletException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -359,8 +358,7 @@ public boolean hasChains() {
     }
 
     public Set<String> getChainNames() {
-        //noinspection unchecked
-        return this.filterChains != null ? this.filterChains.keySet() : Collections.EMPTY_SET;
+        return this.filterChains != null ? this.filterChains.keySet() : Set.of();
     }
 
     public FilterChain proxy(FilterChain original, String chainName) {

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroHttpServletRequest.java
Patch:
@@ -222,6 +222,7 @@ public boolean isRequestedSessionIdFromURL() {
         }
     }
 
+    @Deprecated
     public boolean isRequestedSessionIdFromUrl() {
         return isRequestedSessionIdFromURL();
     }

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroHttpServletResponse.java
Patch:
@@ -91,7 +91,7 @@ public String encodeRedirectURL(String url) {
         }
     }
 
-
+    @Deprecated
     public String encodeRedirectUrl(String s) {
         return encodeRedirectURL(s);
     }
@@ -116,6 +116,7 @@ public String encodeURL(String url) {
         }
     }
 
+    @Deprecated
     public String encodeUrl(String s) {
         return encodeURL(s);
     }

File: web/src/test/java/org/apache/shiro/web/config/WebIniSecurityManagerFactoryTest.java
Patch:
@@ -47,9 +47,11 @@ void testDefaultFiltersPresent() {
         Ini ini = new Ini();
         //just a normal configuration line in the MAIN section for any of the default filters should work
         //out of the box.  So, create the main section and just config one of them:
+        @SuppressWarnings("deprecation")
         Ini.Section section = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
         section.put("authc.loginUrl", "/login.jsp");
 
+        @SuppressWarnings("deprecation")
         WebIniSecurityManagerFactory factory = new WebIniSecurityManagerFactory(ini);
         org.apache.shiro.mgt.SecurityManager sm = factory.getInstance();
         assertNotNull(sm);

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/FormResubmitSupportCookies.java
Patch:
@@ -70,8 +70,9 @@ static int getCookieAge(ServletRequest request, org.apache.shiro.mgt.SecurityMan
         } else {
             try {
                 return (int) Duration.ofMinutes(request.getServletContext().getSessionTimeout()).toSeconds();
-            } catch (Throwable e) {
-                // workaround for https://github.com/eclipse/jetty.project/issues/8556
+            } catch (NoSuchMethodError noSuchMethodError) {
+                // Older servers (e.g. Jetty 9.x) do not support getSessionTimeout() at all
+                log.debug("ServletContext.getSessionTimeout() not supported", noSuchMethodError);
                 return (int) Duration.ofHours(1).toSeconds();
             }
         }

File: samples/web-jakarta/src/test/java/org/apache/shiro/test/web/jakarta/WebContainerIT.java
Patch:
@@ -31,7 +31,7 @@
 import static jakarta.ws.rs.core.MediaType.APPLICATION_FORM_URLENCODED;
 import static jakarta.ws.rs.core.MediaType.TEXT_HTML_TYPE;
 
-public class WebContainerTest extends JakartaAbstractContainerIT {
+public class WebContainerIT extends JakartaAbstractContainerIT {
 
     @SuppressWarnings("checkstyle:MagicNumber")
     @Test

File: samples/web-jakarta/src/test/java/org/apache/shiro/test/web/jakarta/WebContainerIT.java
Patch:
@@ -31,7 +31,7 @@
 import static jakarta.ws.rs.core.MediaType.APPLICATION_FORM_URLENCODED;
 import static jakarta.ws.rs.core.MediaType.TEXT_HTML_TYPE;
 
-public class WebContainerTest extends JakartaAbstractContainerIT {
+public class WebContainerIT extends JakartaAbstractContainerIT {
 
     @SuppressWarnings("checkstyle:MagicNumber")
     @Test

File: cache/src/main/java/org/apache/shiro/cache/CacheException.java
Patch:
@@ -26,8 +26,7 @@
  *
  * @since 0.2
  */
-public class CacheException extends ShiroException
-{
+public class CacheException extends ShiroException {
 
     /**
      * Creates a new <code>CacheException</code>.

File: cache/src/main/java/org/apache/shiro/cache/CacheManager.java
Patch:
@@ -38,5 +38,5 @@ public interface CacheManager {
      * @return the Cache with the given name
      * @throws CacheException if there is an error acquiring the Cache instance.
      */
-    public <K, V> Cache<K, V> getCache(String name) throws CacheException;
+    <K, V> Cache<K, V> getCache(String name) throws CacheException;
 }

File: cache/src/main/java/org/apache/shiro/cache/MapCache.java
Patch:
@@ -27,6 +27,8 @@
  * A <code>MapCache</code> is a {@link Cache Cache} implementation that uses a backing {@link Map} instance to store
  * and retrieve cached data.
  *
+ * @param <K> K
+ * @param <V> V
  * @since 1.0
  */
 public class MapCache<K, V> implements Cache<K, V> {

File: config/core/src/main/java/org/apache/shiro/config/ConfigurationException.java
Patch:
@@ -26,8 +26,7 @@
  *
  * @since 0.9
  */
-public class ConfigurationException extends ShiroException
-{
+public class ConfigurationException extends ShiroException {
 
     /**
      * Creates a new ConfigurationException.

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/CommonsInterpolator.java
Patch:
@@ -55,7 +55,7 @@
  */
 public class CommonsInterpolator implements Interpolator {
 
-    final private ConfigurationInterpolator interpolator;
+    private final ConfigurationInterpolator interpolator;
 
     public CommonsInterpolator() {
         this.interpolator = new ConfigurationInterpolator();

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/Interpolator.java
Patch:
@@ -28,6 +28,7 @@ public interface Interpolator {
 
     /**
      * Interpolates <code>value</code> and returns the result.
+     *
      * @param value the source text
      * @return the String result of the interpolation, or <code>value</code>, if there was not change.
      */

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/event/ConfiguredBeanEvent.java
Patch:
@@ -24,11 +24,11 @@
  * Event triggered when a configured bean has been instantiated and fully configured but right before the bean has been
  * initialized.
  *
- * @since 1.3
  * @see InstantiatedBeanEvent
  * @see org.apache.shiro.lang.util.Initializable Initializable
  * @see InitializedBeanEvent
  * @see DestroyedBeanEvent
+ * @since 1.3
  */
 public class ConfiguredBeanEvent extends BeanEvent {
 

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/event/DestroyedBeanEvent.java
Patch:
@@ -23,11 +23,11 @@
 /**
  * Event triggered when a configured bean has been destroyed.
  *
- * @since 1.3
  * @see org.apache.shiro.lang.util.Destroyable Destroyable
  * @see InstantiatedBeanEvent
  * @see ConfiguredBeanEvent
  * @see InitializedBeanEvent
+ * @since 1.3
  */
 public class DestroyedBeanEvent extends BeanEvent {
 

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/event/InitializedBeanEvent.java
Patch:
@@ -23,11 +23,11 @@
 /**
  * Event triggered when a configured bean has been instantiated, fully configured and initialized.
  *
- * @since 1.3
  * @see org.apache.shiro.lang.util.Initializable Initializable
  * @see InstantiatedBeanEvent
  * @see ConfiguredBeanEvent
  * @see DestroyedBeanEvent
+ * @since 1.3
  */
 public class InitializedBeanEvent extends BeanEvent {
 

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/event/InstantiatedBeanEvent.java
Patch:
@@ -23,11 +23,11 @@
 /**
  * Event triggered when a configured bean has been instantiated but before it is configured or initialized.
  *
- * @since 1.3
  * @see ConfiguredBeanEvent
  * @see InitializedBeanEvent
  * @see DestroyedBeanEvent
  * @see org.apache.shiro.lang.util.Initializable Initializable
+ * @since 1.3
  */
 public class InstantiatedBeanEvent extends BeanEvent {
 

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/event/LoggingBeanEventListener.java
Patch:
@@ -29,14 +29,14 @@
  */
 public class LoggingBeanEventListener {
 
-    private static final Logger logger = LoggerFactory.getLogger(LoggingBeanEventListener.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(LoggingBeanEventListener.class);
     private static final String SUFFIX = BeanEvent.class.getSimpleName();
 
     @Subscribe
     public void onEvent(BeanEvent e) {
         String className = e.getClass().getSimpleName();
         int i = className.lastIndexOf(SUFFIX);
         String subclassPrefix = i > 0 ? className.substring(0, i) : className;
-        logger.trace("{} bean '{}' [{}]", new Object[]{subclassPrefix, e.getBeanName(), e.getBean()});
+        LOGGER.trace("{} bean '{}' [{}]", subclassPrefix, e.getBeanName(), e.getBean());
     }
 }

File: core/src/main/java/org/apache/shiro/aop/AnnotationHandler.java
Patch:
@@ -49,7 +49,8 @@ public AnnotationHandler(Class<? extends Annotation> annotationClass) {
     /**
      * Returns the {@link org.apache.shiro.subject.Subject Subject} associated with the currently-executing code.
      * <p/>
-     * This default implementation merely calls <code>{@link org.apache.shiro.SecurityUtils#getSubject SecurityUtils.getSubject()}</code>.
+     * This default implementation merely calls
+     * <code>{@link org.apache.shiro.SecurityUtils#getSubject SecurityUtils.getSubject()}</code>.
      *
      * @return the {@link org.apache.shiro.subject.Subject Subject} associated with the currently-executing code.
      */

File: core/src/main/java/org/apache/shiro/aop/AnnotationMethodInterceptor.java
Patch:
@@ -75,7 +75,7 @@ public AnnotationMethodInterceptor(AnnotationHandler handler, AnnotationResolver
      * an annotation discovered at runtime.
      *
      * @return the {@code AnnotationHandler} used to perform authorization behavior based on
-     *         an annotation discovered at runtime.
+     * an annotation discovered at runtime.
      */
     public AnnotationHandler getHandler() {
         return handler;
@@ -98,7 +98,7 @@ public void setHandler(AnnotationHandler handler) {
      * perform authorization logic.
      *
      * @return the {@code AnnotationResolver} to use to acquire annotations from intercepted
-     *         methods at runtime.
+     * methods at runtime.
      * @since 1.1
      */
     public AnnotationResolver getResolver() {
@@ -128,7 +128,7 @@ public void setResolver(AnnotationResolver resolver) {
      *
      * @param mi the <code>MethodInvocation</code> for the method being invoked.
      * @return <code>true</code> if this interceptor supports, that is, should inspect, the specified
-     *         <code>MethodInvocation</code>, <code>false</code> otherwise.
+     * <code>MethodInvocation</code>, <code>false</code> otherwise.
      */
     public boolean supports(MethodInvocation mi) {
         return getAnnotation(mi) != null;

File: core/src/main/java/org/apache/shiro/aop/MethodInterceptorSupport.java
Patch:
@@ -40,7 +40,8 @@ public MethodInterceptorSupport() {
     /**
      * Returns the {@link Subject Subject} associated with the currently-executing code.
      * <p/>
-     * This default implementation merely calls <code>{@link org.apache.shiro.SecurityUtils#getSubject SecurityUtils.getSubject()}</code>.
+     * This default implementation merely calls
+     * <code>{@link org.apache.shiro.SecurityUtils#getSubject SecurityUtils.getSubject()}</code>.
      *
      * @return the {@link org.apache.shiro.subject.Subject Subject} associated with the currently-executing code.
      */

File: core/src/main/java/org/apache/shiro/aop/package-info.java
Patch:
@@ -23,4 +23,4 @@
  * useful for any AOP environment and/or function. Feature-dependent AOP classes (e.g. authorization,
  * authentication, etc.) will use these classes as their base in their respective packages.
  */
-package org.apache.shiro.aop;
\ No newline at end of file
+package org.apache.shiro.aop;

File: core/src/main/java/org/apache/shiro/authc/AuthenticationException.java
Patch:
@@ -26,8 +26,7 @@
  *
  * @since 0.1
  */
-public class AuthenticationException extends ShiroException
-{
+public class AuthenticationException extends ShiroException {
 
     /**
      * Creates a new AuthenticationException.

File: core/src/main/java/org/apache/shiro/authc/AuthenticationInfo.java
Patch:
@@ -46,8 +46,9 @@
  * preferences.
  * <p/>
  * <p><b>Please note:</b>  Since Shiro sometimes logs authentication operations, please ensure your AuthenticationInfo's
- * <code>toString()</code> implementation does <em>not</em> print out account credentials (password, etc.), as these might be viewable to
- * someone reading your logs.  This is good practice anyway, and account credentials should rarely (if ever) be printed
+ * <code>toString()</code> implementation does <em>not</em> print out account credentials (password, etc.),
+ * as these might be viewable to someone reading your logs.
+ * This is good practice anyway, and account credentials should rarely (if ever) be printed
  * out for any reason.  If you're using Shiro's default implementations of this interface, they only ever print the
  * account {@link #getPrincipals() principals}, so you do not need to do anything additional.</p>
  *

File: core/src/main/java/org/apache/shiro/authc/Authenticator.java
Patch:
@@ -62,6 +62,6 @@ public interface Authenticator {
      * @see ConcurrentAccessException
      * @see UnknownAccountException
      */
-    public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)
+    AuthenticationInfo authenticate(AuthenticationToken authenticationToken)
             throws AuthenticationException;
 }

File: core/src/main/java/org/apache/shiro/authc/HostAuthenticationToken.java
Patch:
@@ -36,9 +36,9 @@ public interface HostAuthenticationToken extends AuthenticationToken {
      * {@code ServletRequest.getRemoteHost()} value.
      *
      * @return the fully qualified name of the client from where the
-     *         authentication attempt originates or the String representation
-     *         of the client's IP address is hostname resolution is not
-     *         available or disabled.
+     * authentication attempt originates or the String representation
+     * of the client's IP address is hostname resolution is not
+     * available or disabled.
      */
     String getHost();
 }

File: core/src/main/java/org/apache/shiro/authc/LogoutAware.java
Patch:
@@ -37,5 +37,5 @@ public interface LogoutAware {
      *
      * @param principals the identifying principals of the Subject logging out.
      */
-    public void onLogout(PrincipalCollection principals);
+    void onLogout(PrincipalCollection principals);
 }

File: core/src/main/java/org/apache/shiro/authc/RememberMeAuthenticationToken.java
Patch:
@@ -36,7 +36,7 @@ public interface RememberMeAuthenticationToken extends AuthenticationToken {
      * across sessions, {@code false} otherwise.
      *
      * @return {@code true} if the submitting user wishes their identity (principal(s)) to be remembered
-     *         across sessions, {@code false} otherwise.
+     * across sessions, {@code false} otherwise.
      */
     boolean isRememberMe();
 

File: core/src/main/java/org/apache/shiro/authc/SimpleAuthenticationInfo.java
Patch:
@@ -165,7 +165,7 @@ public void setCredentials(Object credentials) {
      * use for salts.  Therefore it doesn't make sense to 'merge' salts in a multi-realm scenario.
      *
      * @return the salt used to hash the credentials, or {@code null} if no salt was used or credentials were not
-     *         hashed at all.
+     * hashed at all.
      * @since 1.1
      */
     @Override
@@ -196,7 +196,7 @@ public void setCredentialsSalt(ByteSource salt) {
      * @param info the <code>AuthenticationInfo</code> to add into this instance.
      */
     @Override
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "checkstyle:NPathComplexity"})
     public void merge(AuthenticationInfo info) {
         if (info == null || info.getPrincipals() == null || info.getPrincipals().isEmpty()) {
             return;
@@ -254,7 +254,7 @@ public void merge(AuthenticationInfo info) {
      *
      * @param o the object to compare for equality.
      * @return <code>true</code> if the Object argument is an <code>instanceof SimpleAuthenticationInfo</code> and
-     *         its {@link #getPrincipals() principals} are equal to this instance's principals, <code>false</code> otherwise.
+     * its {@link #getPrincipals() principals} are equal to this instance's principals, <code>false</code> otherwise.
      */
     @Override
     public boolean equals(Object o) {

File: core/src/main/java/org/apache/shiro/authc/credential/AllowAllCredentialsMatcher.java
Patch:
@@ -33,8 +33,8 @@ public class AllowAllCredentialsMatcher implements CredentialsMatcher {
     /**
      * Returns <code>true</code> <em>always</em> no matter what the method arguments are.
      *
-     * @param token   the token submitted for authentication.
-     * @param info    the account being verified for access
+     * @param token the token submitted for authentication.
+     * @param info  the account being verified for access
      * @return <code>true</code> <em>always</em>.
      */
     public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {

File: core/src/main/java/org/apache/shiro/authc/credential/PasswordService.java
Patch:
@@ -140,7 +140,7 @@ public interface PasswordService {
      *                           {@link #encryptPassword(Object) encryptPassword} method (typically
      *                           when the account is created or the account's password is reset).
      * @return {@code true} if the {@code submittedPlaintext} password matches the existing {@code saved} password,
-     *         {@code false} otherwise.
+     * {@code false} otherwise.
      * @see ByteSource.Util#isCompatible(Object)
      */
     boolean passwordsMatch(Object submittedPlaintext, String encrypted);

File: core/src/main/java/org/apache/shiro/authc/credential/Sha256CredentialsMatcher.java
Patch:
@@ -18,8 +18,6 @@
  */
 package org.apache.shiro.authc.credential;
 
-import org.apache.shiro.crypto.hash.AbstractHash;
-import org.apache.shiro.crypto.hash.Hash;
 import org.apache.shiro.crypto.hash.Sha256Hash;
 
 
@@ -29,7 +27,7 @@
  *
  * @since 0.9
  * @deprecated since 1.1 - use the HashedCredentialsMatcher directly and set its
- *             {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
+ * {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
  */
 public class Sha256CredentialsMatcher extends HashedCredentialsMatcher {
 

File: core/src/main/java/org/apache/shiro/authc/credential/Sha384CredentialsMatcher.java
Patch:
@@ -18,8 +18,6 @@
  */
 package org.apache.shiro.authc.credential;
 
-import org.apache.shiro.crypto.hash.AbstractHash;
-import org.apache.shiro.crypto.hash.Hash;
 import org.apache.shiro.crypto.hash.Sha384Hash;
 
 
@@ -29,7 +27,7 @@
  *
  * @since 0.9
  * @deprecated since 1.1 - use the HashedCredentialsMatcher directly and set its
- *             {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
+ * {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
  */
 public class Sha384CredentialsMatcher extends HashedCredentialsMatcher {
 

File: core/src/main/java/org/apache/shiro/authc/credential/Sha512CredentialsMatcher.java
Patch:
@@ -18,8 +18,6 @@
  */
 package org.apache.shiro.authc.credential;
 
-import org.apache.shiro.crypto.hash.AbstractHash;
-import org.apache.shiro.crypto.hash.Hash;
 import org.apache.shiro.crypto.hash.Sha512Hash;
 
 
@@ -29,7 +27,7 @@
  *
  * @since 0.9
  * @deprecated since 1.1 - use the HashedCredentialsMatcher directly and set its
- *             {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
+ * {@link HashedCredentialsMatcher#setHashAlgorithmName(String) hashAlgorithmName} property.
  */
 public class Sha512CredentialsMatcher extends HashedCredentialsMatcher {
 

File: core/src/main/java/org/apache/shiro/authz/AuthorizationException.java
Patch:
@@ -26,8 +26,7 @@
  *
  * @since 0.1
  */
-public class AuthorizationException extends ShiroException
-{
+public class AuthorizationException extends ShiroException {
 
     /**
      * Creates a new AuthorizationException.

File: core/src/main/java/org/apache/shiro/authz/Permission.java
Patch:
@@ -79,7 +79,7 @@ public interface Permission {
      *
      * @param p the permission to check for behavior/functionality comparison.
      * @return {@code true} if this current instance <em>implies</em> all the functionality and/or resource access
-     *         described by the specified {@code Permission} argument, {@code false} otherwise.
+     * described by the specified {@code Permission} argument, {@code false} otherwise.
      */
     boolean implies(Permission p);
 }

File: core/src/main/java/org/apache/shiro/authz/SimpleRole.java
Patch:
@@ -31,7 +31,7 @@
  */
 public class SimpleRole implements Serializable {
 
-    protected String name = null;
+    protected String name;
     protected Set<Permission> permissions;
 
     public SimpleRole() {

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresAuthentication.java
Patch:
@@ -30,15 +30,15 @@
  * {@link RequiresUser RequiresUser} annotation.
  * <p/>
  * This annotation basically ensures that
- * <code>{@link org.apache.shiro.subject.Subject subject}.{@link org.apache.shiro.subject.Subject#isAuthenticated() isAuthenticated()} === true</code>
+ * <code>{@link org.apache.shiro.subject.Subject subject}.
+ * {@link org.apache.shiro.subject.Subject#isAuthenticated() isAuthenticated()} === true</code>
  * <p/>
  * See the {@link RequiresUser RequiresUser} and
  * {@link org.apache.shiro.authc.RememberMeAuthenticationToken RememberMeAuthenticationToken} JavaDoc for an
  * explanation of why these two states are considered different.
  *
  * @see RequiresUser
  * @see RequiresGuest
- *
  * @since 0.9.0
  */
 @Target({ElementType.TYPE, ElementType.METHOD})

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresGuest.java
Patch:
@@ -35,7 +35,6 @@
  *
  * @see RequiresAuthentication
  * @see RequiresUser
- *
  * @since 0.9.0
  */
 @Target({ElementType.TYPE, ElementType.METHOD})

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresPermissions.java
Patch:
@@ -54,12 +54,12 @@
      * to determine if the user is allowed to invoke the code protected by this annotation.
      */
     String[] value();
-    
+
     /**
      * The logical operation for the permission checks in case multiple roles are specified. AND is the default
+     *
      * @since 1.1.0
      */
-    Logical logical() default Logical.AND; 
+    Logical logical() default Logical.AND;
 
 }
-

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresUser.java
Patch:
@@ -43,7 +43,6 @@
  *
  * @see RequiresAuthentication
  * @see RequiresGuest
- *
  * @since 0.9.0
  */
 @Target({ElementType.TYPE, ElementType.METHOD})

File: core/src/main/java/org/apache/shiro/authz/aop/AnnotationsAuthorizingMethodInterceptor.java
Patch:
@@ -45,7 +45,7 @@ public abstract class AnnotationsAuthorizingMethodInterceptor extends Authorizin
     protected Collection<AuthorizingAnnotationMethodInterceptor> methodInterceptors;
 
     /**
-     * Default no-argument constructor that defaults the 
+     * Default no-argument constructor that defaults the
      * {@link #methodInterceptors methodInterceptors} attribute to contain two interceptors by default - the
      * {@link RoleAnnotationMethodInterceptor RoleAnnotationMethodInterceptor} and the
      * {@link PermissionAnnotationMethodInterceptor PermissionAnnotationMethodInterceptor} to
@@ -68,6 +68,7 @@ public AnnotationsAuthorizingMethodInterceptor() {
      * {@link RoleAnnotationMethodInterceptor RoleAnnotationMethodInterceptor} and a
      * {@link PermissionAnnotationMethodInterceptor PermissionAnnotationMethodInterceptor} to
      * support role and permission annotations automatically.
+     *
      * @return the method interceptors to execute for the annotated method.
      */
     public Collection<AuthorizingAnnotationMethodInterceptor> getMethodInterceptors() {
@@ -76,6 +77,7 @@ public Collection<AuthorizingAnnotationMethodInterceptor> getMethodInterceptors(
 
     /**
      * Sets the method interceptors to execute for the annotated method.
+     *
      * @param methodInterceptors the method interceptors to execute for the annotated method.
      * @see #getMethodInterceptors()
      */

File: core/src/main/java/org/apache/shiro/authz/aop/AuthorizingMethodInterceptor.java
Patch:
@@ -42,6 +42,7 @@ public Object invoke(MethodInvocation methodInvocation) throws Throwable {
     /**
      * Asserts that the specified MethodInvocation is allowed to continue by performing any necessary authorization
      * (access control) checks first.
+     *
      * @param methodInvocation the <code>MethodInvocation</code> to invoke.
      * @throws AuthorizationException if the <code>methodInvocation</code> should not be allowed to continue/execute.
      */

File: core/src/main/java/org/apache/shiro/authz/aop/DenyAllAnnotationHandler.java
Patch:
@@ -35,7 +35,7 @@ public class DenyAllAnnotationHandler extends AuthorizingAnnotationHandler {
 
     /**
      * Default no-argument constructor that ensures this interceptor looks for
-     *
+     * <p>
      * {@link org.apache.shiro.authz.annotation.RequiresGuest RequiresGuest} annotations in a method
      * declaration.
      */

File: core/src/main/java/org/apache/shiro/authz/aop/GuestAnnotationMethodInterceptor.java
Patch:
@@ -25,7 +25,8 @@
  * is declared, and if so, ensures the calling <code>Subject</code> does <em>not</em>
  * have an {@link org.apache.shiro.subject.Subject#getPrincipal() identity} before invoking the method.
  * <p>
- * This annotation essentially ensures that <code>subject.{@link org.apache.shiro.subject.Subject#getPrincipal() getPrincipal()} == null</code>.
+ * This annotation essentially ensures that <code>subject.
+ * {@link org.apache.shiro.subject.Subject#getPrincipal() getPrincipal()} == null</code>.
  *
  * @since 0.9.0
  */

File: core/src/main/java/org/apache/shiro/authz/aop/PermitAllAnnotationHandler.java
Patch:
@@ -44,5 +44,6 @@ public PermitAllAnnotationHandler() {
      * @param a the annotation to check for one or more roles
      */
     @Override
-    public void assertAuthorized(Annotation a) { }
+    public void assertAuthorized(Annotation a) {
+    }
 }

File: core/src/main/java/org/apache/shiro/authz/aop/RoleAnnotationMethodInterceptor.java
Patch:
@@ -35,7 +35,7 @@ public class RoleAnnotationMethodInterceptor extends AuthorizingAnnotationMethod
      * {@link RequiresRoles RequiresRoles} annotations in a method declaration.
      */
     public RoleAnnotationMethodInterceptor() {
-        super( new RoleAnnotationHandler() );
+        super(new RoleAnnotationHandler());
     }
 
     /**

File: core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
Patch:
@@ -32,12 +32,12 @@
  */
 public class DomainPermission extends WildcardPermission {
 
+    private static final long serialVersionUID = 1L;
+
     private String domain;
     private Set<String> actions;
     private Set<String> targets;
 
-    private static final long serialVersionUID = 1l;
-
     /**
      * Creates a domain permission with *all* actions for *all* targets;
      */

File: core/src/main/java/org/apache/shiro/authz/permission/InvalidPermissionStringException.java
Patch:
@@ -27,10 +27,9 @@
  *
  * @since 0.9
  */
-public class InvalidPermissionStringException extends ShiroException
-{
+public class InvalidPermissionStringException extends ShiroException {
 
-    private String permissionString;
+    private final String permissionString;
 
     /**
      * Constructs a new exception with the given message and permission string.

File: core/src/main/java/org/apache/shiro/authz/permission/PermissionResolverAware.java
Patch:
@@ -36,5 +36,5 @@ public interface PermissionResolverAware {
      *
      * @param pr the <tt>PermissionResolver</tt> being set.
      */
-    public void setPermissionResolver(PermissionResolver pr);
+    void setPermissionResolver(PermissionResolver pr);
 }

File: core/src/main/java/org/apache/shiro/authz/permission/RolePermissionResolver.java
Patch:
@@ -28,7 +28,6 @@
  * <p/>
  * In some cases a {@link org.apache.shiro.realm.Realm} my only be able to return a list of roles.  This
  * component allows an application to resolve the roles into permissions.
- *
  */
 public interface RolePermissionResolver {
 

File: core/src/main/java/org/apache/shiro/authz/permission/RolePermissionResolverAware.java
Patch:
@@ -36,5 +36,5 @@ public interface RolePermissionResolverAware {
      *
      * @param rpr the <tt>RolePermissionResolver</tt> being set.
      */
-    public void setRolePermissionResolver(RolePermissionResolver rpr);
+    void setRolePermissionResolver(RolePermissionResolver rpr);
 }

File: core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutor.java
Patch:
@@ -95,7 +95,7 @@ public void setTargetExecutor(Executor targetExecutor) {
      * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()}.
      *
      * @return the currently Subject instance that should be associated with Runnable or Callable instances before
-     *         being dispatched to the target {@code Executor} instance.
+     * being dispatched to the target {@code Executor} instance.
      */
     protected Subject getSubject() {
         return SecurityUtils.getSubject();

File: core/src/main/java/org/apache/shiro/dao/package-info.java
Patch:
@@ -23,4 +23,4 @@
  *
  * @since 1.2
  */
-package org.apache.shiro.dao;
\ No newline at end of file
+package org.apache.shiro.dao;

File: core/src/main/java/org/apache/shiro/env/BasicIniEnvironment.java
Patch:
@@ -19,6 +19,7 @@
 package org.apache.shiro.env;
 
 import java.util.function.Function;
+
 import org.apache.shiro.config.Ini;
 import org.apache.shiro.ini.IniSecurityManagerFactory;
 

File: core/src/main/java/org/apache/shiro/env/NamedObjectEnvironment.java
Patch:
@@ -29,12 +29,12 @@ public interface NamedObjectEnvironment extends Environment {
      * Returns the object in Shiro's environment with the specified name and type or {@code null} if
      * no object with that name was found.
      *
-     * @param name the assigned name of the object.
+     * @param name         the assigned name of the object.
      * @param requiredType the class to which the discovered object must be assignable.
-     * @param <T> the type of the class
-     * @throws RequiredTypeException if the discovered object does not equal, extend, or implement the specified class.
+     * @param <T>          the type of the class
      * @return the object in Shiro's environment with the specified name (of the specified type) or {@code null} if
      * no object with that name was found.
+     * @throws RequiredTypeException if the discovered object does not equal, extend, or implement the specified class.
      */
     <T> T getObject(String name, Class<T> requiredType) throws RequiredTypeException;
 }

File: core/src/main/java/org/apache/shiro/jndi/JndiObjectFactory.java
Patch:
@@ -24,6 +24,7 @@
 
 /**
  * A factory implementation intended to be used to look up objects in jndi.
+ *
  * @param <T>
  * @since 1.2
  */
@@ -34,7 +35,7 @@ public class JndiObjectFactory<T> extends JndiLocator implements Factory<T> {
 
     public T getInstance() {
         try {
-            if(requiredType != null) {
+            if (requiredType != null) {
                 return requiredType.cast(this.lookup(resourceName, requiredType));
             } else {
                 return (T) this.lookup(resourceName);

File: core/src/main/java/org/apache/shiro/ldap/package-info.java
Patch:
@@ -17,10 +17,9 @@
  * under the License.
  */
 
-package org.apache.shiro.ldap;
-
 /**
  * Support for accessing <a href="http://en.wikipedia.org/wiki/LDAP">LDAP</a> data sources.
  *
  * @since 1.2
- */
\ No newline at end of file
+ */
+package org.apache.shiro.ldap;

File: core/src/main/java/org/apache/shiro/mgt/AuthenticatingSecurityManager.java
Patch:
@@ -65,7 +65,7 @@ public AuthenticatingSecurityManager() {
      * {@link org.apache.shiro.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator}.
      *
      * @return the delegate <code>Authenticator</code> instance that this SecurityManager uses to perform all
-     *         authentication operations.
+     * authentication operations.
      */
     public Authenticator getAuthenticator() {
         return authenticator;

File: core/src/main/java/org/apache/shiro/mgt/CachingSecurityManager.java
Patch:
@@ -46,6 +46,7 @@ public abstract class CachingSecurityManager implements SecurityManager, Destroy
 
     /**
      * The EventBus to use to use to publish and receive events of interest during Shiro's lifecycle.
+     *
      * @since 1.3
      */
     private EventBus eventBus;
@@ -111,7 +112,7 @@ public EventBus getEventBus() {
      * eventBus is available.
      *
      * @param eventBus the EventBus used by this {@code SecurityManager} and potentially any of its
-     *                     children components.
+     *                 children components.
      * @since 1.3
      */
     public void setEventBus(EventBus eventBus) {
@@ -124,7 +125,7 @@ public void setEventBus(EventBus eventBus) {
      */
     protected void applyEventBusToCacheManager() {
         if (this.eventBus != null && this.cacheManager != null && this.cacheManager instanceof EventBusAware) {
-            ((EventBusAware)this.cacheManager).setEventBus(this.eventBus);
+            ((EventBusAware) this.cacheManager).setEventBus(this.eventBus);
         }
     }
 

File: core/src/main/java/org/apache/shiro/mgt/DefaultSessionStorageEvaluator.java
Patch:
@@ -73,7 +73,7 @@ public boolean isSessionStorageEnabled(Subject subject) {
      * authenticate on every request).
      *
      * @return {@code true} if any Subject's {@code Session} may be used to persist that {@code Subject}'s state,
-     *         {@code false} otherwise.
+     * {@code false} otherwise.
      */
     public boolean isSessionStorageEnabled() {
         return sessionStorageEnabled;

File: core/src/main/java/org/apache/shiro/mgt/DefaultSubjectFactory.java
Patch:
@@ -26,7 +26,8 @@
 
 
 /**
- * Default {@link SubjectFactory SubjectFactory} implementation that creates {@link org.apache.shiro.subject.support.DelegatingSubject DelegatingSubject}
+ * Default {@link SubjectFactory SubjectFactory} implementation that creates
+ * {@link org.apache.shiro.subject.support.DelegatingSubject DelegatingSubject}
  * instances.
  *
  * @since 1.0
@@ -49,7 +50,7 @@ public Subject createSubject(SubjectContext context) {
 
     /**
      * @deprecated since 1.2 - override {@link #createSubject(org.apache.shiro.subject.SubjectContext)} directly if you
-     *             need to instantiate a custom {@link Subject} class.
+     * need to instantiate a custom {@link Subject} class.
      */
     @Deprecated
     protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated, String host,

File: core/src/main/java/org/apache/shiro/mgt/SessionStorageEvaluator.java
Patch:
@@ -54,8 +54,8 @@ public interface SessionStorageEvaluator {
      *
      * @param subject the {@code Subject} for which session state persistence may be enabled
      * @return {@code true} if the specified {@code Subject}'s
-     *         {@link org.apache.shiro.subject.Subject#getSession() session} may be used to persist that Subject's
-     *         state, {@code false} otherwise.
+     * {@link org.apache.shiro.subject.Subject#getSession() session} may be used to persist that Subject's
+     * state, {@code false} otherwise.
      * @see Subject#getSession()
      * @see Subject#getSession(boolean)
      */

File: core/src/main/java/org/apache/shiro/realm/RealmFactory.java
Patch:
@@ -46,7 +46,7 @@ public interface RealmFactory {
      * {@link java.util.Iterator Iterator} determines the order in which Realms are used.
      *
      * @return the <code>Collection</code> of Realms that the application's <code>SecurityManager</code> will use
-     *         for security data access.
+     * for security data access.
      */
     Collection<Realm> getRealms();
 

File: core/src/main/java/org/apache/shiro/realm/jdbc/package-info.java
Patch:
@@ -16,8 +16,9 @@
  * specific language governing permissions and limitations
  * under the License.
  */
+
 /**
- * Realms that acquire security data from an RDBMS (Relational Database Management System) using the 
+ * Realms that acquire security data from an RDBMS (Relational Database Management System) using the
  * JDBC API.
  */
 package org.apache.shiro.realm.jdbc;

File: core/src/main/java/org/apache/shiro/realm/jndi/package-info.java
Patch:
@@ -17,5 +17,6 @@
  * under the License.
  */
 /**
- * Support for acquiring Realms from JNDI, particularly useful for configuring Shiro in JEE or EJB environments. */
+ * Support for acquiring Realms from JNDI, particularly useful for configuring Shiro in JEE or EJB environments.
+ */
 package org.apache.shiro.realm.jndi;

File: core/src/main/java/org/apache/shiro/realm/ldap/JndiLdapRealm.java
Patch:
@@ -20,10 +20,10 @@
 
 /**
  * This class has been replaced with DefaultLdapRealm.
+ *
  * @see DefaultLdapRealm
- * @deprecated Renamed to {@link DefaultLdapRealm}, this class will be removed prior to 2.0
  * @since 1.1
- *
+ * @deprecated Renamed to {@link DefaultLdapRealm}, this class will be removed prior to 2.0
  */
 public class JndiLdapRealm extends DefaultLdapRealm {
 

File: core/src/main/java/org/apache/shiro/realm/ldap/LdapContextFactory.java
Patch:
@@ -34,7 +34,7 @@ public interface LdapContextFactory {
      * anonymously if no system account is configured.
      *
      * @return a {@code LdapContext} bound by the system account, or bound anonymously if no system account
-     *         is configured.
+     * is configured.
      * @throws javax.naming.NamingException if there is an error creating the context.
      */
     LdapContext getSystemLdapContext() throws NamingException;
@@ -59,5 +59,5 @@ public interface LdapContextFactory {
      * @since 1.1
      */
     LdapContext getLdapContext(Object principal, Object credentials) throws NamingException;
-    
+
 }

File: core/src/main/java/org/apache/shiro/realm/text/TextConfigurationRealm.java
Patch:
@@ -62,8 +62,8 @@ public TextConfigurationRealm() {
     /**
      * Will call 'processDefinitions' on startup.
      *
-     * @since 1.2
      * @see <a href="https://issues.apache.org/jira/browse/SHIRO-223">SHIRO-223</a>
+     * @since 1.2
      */
     @Override
     protected void onInit() {
@@ -148,7 +148,7 @@ protected void processRoleDefinitions(Map<String, String> roleDefs) {
         if (roleDefs == null || roleDefs.isEmpty()) {
             return;
         }
-        for (Map.Entry<String,String> entry : roleDefs.entrySet()) {
+        for (Map.Entry<String, String> entry : roleDefs.entrySet()) {
             String rolename = entry.getKey();
             String value = entry.getValue();
 
@@ -178,7 +178,7 @@ protected void processUserDefinitions(Map<String, String> userDefs) {
         if (userDefs == null || userDefs.isEmpty()) {
             return;
         }
-        for (Map.Entry<String,String> entry : userDefs.entrySet()) {
+        for (Map.Entry<String, String> entry : userDefs.entrySet()) {
             String username = entry.getKey();
             String value = entry.getValue();
 

File: core/src/main/java/org/apache/shiro/session/mgt/ImmutableProxiedSession.java
Patch:
@@ -58,8 +58,8 @@ public ImmutableProxiedSession(Session target) {
      * @throws InvalidSessionException in all cases - used by the Session 'write' method implementations.
      */
     protected void throwImmutableException() throws InvalidSessionException {
-        String msg = "This session is immutable and read-only - it cannot be altered.  This is usually because " +
-                "the session has been stopped or expired already.";
+        String msg = "This session is immutable and read-only - it cannot be altered.  This is usually because "
+                + "the session has been stopped or expired already.";
         throw new InvalidSessionException(msg);
     }
 

File: core/src/main/java/org/apache/shiro/session/mgt/SessionContext.java
Patch:
@@ -79,7 +79,7 @@ public interface SessionContext extends Map<String, Object> {
      * {@code Session} host.
      *
      * @return the originating host name or IP address (as a String) from where the {@code Subject} is initiating the
-     *         {@code Session}.
+     * {@code Session}.
      * @see #setHost(String) setHost(String)
      */
     String getHost();

File: core/src/main/java/org/apache/shiro/session/mgt/SessionManager.java
Patch:
@@ -53,7 +53,7 @@ public interface SessionManager {
      *
      * @param key the Session key to use to look-up the Session
      * @return the {@code Session} instance corresponding to the given lookup key or {@code null} if no session
-     *         could be acquired.
+     * could be acquired.
      * @throws SessionException if a session was found but it was invalid (stopped/expired).
      * @since 1.0
      */

File: core/src/main/java/org/apache/shiro/session/mgt/SessionValidationScheduler.java
Patch:
@@ -20,7 +20,8 @@
 
 /**
  * Interface that should be implemented by classes that can control validating sessions on a regular
- * basis.  This interface is used as a delegate for session validation by the {@link org.apache.shiro.session.mgt.DefaultSessionManager}
+ * basis.  This interface is used as a delegate for session validation
+ * by the {@link org.apache.shiro.session.mgt.DefaultSessionManager}
  *
  * @see org.apache.shiro.session.mgt.DefaultSessionManager#setSessionValidationScheduler(SessionValidationScheduler)
  * @since 0.1
@@ -49,4 +50,4 @@ public interface SessionValidationScheduler {
      */
     void disableSessionValidation();
 
-}
\ No newline at end of file
+}

File: core/src/main/java/org/apache/shiro/session/mgt/ValidatingSession.java
Patch:
@@ -28,7 +28,7 @@
  * <p/>
  * Validation is usually an exercise of determining when the session was last accessed or modified and determining if
  * that time is longer than a specified allowed duration.
- * 
+ *
  * @since 0.9
  */
 public interface ValidatingSession extends Session {

File: core/src/main/java/org/apache/shiro/session/mgt/eis/AbstractSessionDAO.java
Patch:
@@ -65,7 +65,7 @@ public AbstractSessionDAO() {
      * is a {@link JavaUuidSessionIdGenerator}.
      *
      * @return the {@code SessionIdGenerator} used by the {@link #generateSessionId(org.apache.shiro.session.Session)}
-     *         method.
+     * method.
      */
     public SessionIdGenerator getSessionIdGenerator() {
         return sessionIdGenerator;
@@ -151,7 +151,7 @@ protected void assignSessionId(Session session, Serializable sessionId) {
      *
      * @param session the Session instance to persist to the EIS.
      * @return the id of the session created in the EIS (i.e. this is almost always a primary key and should be the
-     *         value returned from {@link org.apache.shiro.session.Session#getId() Session.getId()}.
+     * value returned from {@link org.apache.shiro.session.Session#getId() Session.getId()}.
      */
     protected abstract Serializable doCreate(Session session);
 
@@ -178,7 +178,7 @@ public Session readSession(Serializable sessionId) throws UnknownSessionExceptio
      *
      * @param sessionId the id of the <tt>Session</tt> to retrieve.
      * @return the Session in the EIS identified by <tt>sessionId</tt> or {@code null} if a
-     *         session with that ID could not be found.
+     * session with that ID could not be found.
      */
     protected abstract Session doReadSession(Serializable sessionId);
 

File: core/src/main/java/org/apache/shiro/session/mgt/eis/CachingSessionDAO.java
Patch:
@@ -120,7 +120,7 @@ public void setActiveSessionsCacheName(String activeSessionsCacheName) {
      * {@code CacheManager} using the {@link #getActiveSessionsCacheName() activeSessionsCacheName}.
      *
      * @return the cache instance to use for storing active sessions or {@code null} if the {@code Cache} instance
-     *         should be retrieved from the
+     * should be retrieved from the
      */
     public Cache<Serializable, Session> getActiveSessionsCache() {
         return this.activeSessions;
@@ -162,7 +162,7 @@ private Cache<Serializable, Session> getActiveSessionsCacheLazy() {
      * cacheManager.getCache(name);</pre>
      *
      * @return a cache instance used to store active sessions, or {@code null} if the {@code CacheManager} has
-     *         not been set.
+     * not been set.
      */
     protected Cache<Serializable, Session> createActiveSessionsCache() {
         Cache<Serializable, Session> cache = null;
@@ -192,7 +192,7 @@ public Serializable create(Session session) {
      *
      * @param sessionId the id of the cached session to acquire.
      * @return the cached session with the corresponding {@code sessionId}, or {@code null} if the session
-     *         does not exist or is not cached.
+     * does not exist or is not cached.
      */
     protected Session getCachedSession(Serializable sessionId) {
         Session cached = null;

File: core/src/main/java/org/apache/shiro/session/mgt/eis/EnterpriseCacheSessionDAO.java
Patch:
@@ -67,9 +67,10 @@ protected Serializable doCreate(Session session) {
     }
 
     protected Session doReadSession(Serializable sessionId) {
-        return null; //should never execute because this implementation relies on parent class to access cache, which
+        //should never execute because this implementation relies on parent class to access cache, which
         //is where all sessions reside - it is the cache implementation that determines if the
         //cache is memory only or disk-persistent, etc.
+        return null;
     }
 
     protected void doUpdate(Session session) {

File: core/src/main/java/org/apache/shiro/session/mgt/eis/MemorySessionDAO.java
Patch:
@@ -55,9 +55,9 @@
  */
 public class MemorySessionDAO extends AbstractSessionDAO {
 
-    private static final Logger log = LoggerFactory.getLogger(MemorySessionDAO.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(MemorySessionDAO.class);
 
-    private ConcurrentMap<Serializable, Session> sessions;
+    private final ConcurrentMap<Serializable, Session> sessions;
 
     public MemorySessionDAO() {
         this.sessions = new ConcurrentHashMap<Serializable, Session>();

File: core/src/main/java/org/apache/shiro/session/mgt/eis/RandomSessionIdGenerator.java
Patch:
@@ -33,7 +33,7 @@
  */
 public class RandomSessionIdGenerator implements SessionIdGenerator {
 
-    private static final Logger log = LoggerFactory.getLogger(RandomSessionIdGenerator.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(RandomSessionIdGenerator.class);
 
     private static final String RANDOM_NUM_GENERATOR_ALGORITHM_NAME = "SHA1PRNG";
     private Random random;
@@ -42,8 +42,8 @@ public RandomSessionIdGenerator() {
         try {
             this.random = java.security.SecureRandom.getInstance(RANDOM_NUM_GENERATOR_ALGORITHM_NAME);
         } catch (java.security.NoSuchAlgorithmException e) {
-            log.debug("The SecureRandom SHA1PRNG algorithm is not available on the current platform.  Using the " +
-                    "platform's default SecureRandom algorithm.", e);
+            LOGGER.debug("The SecureRandom SHA1PRNG algorithm is not available on the current platform.  Using the "
+                    + "platform's default SecureRandom algorithm.", e);
             this.random = new java.security.SecureRandom();
         }
     }

File: core/src/main/java/org/apache/shiro/subject/PrincipalMap.java
Patch:
@@ -47,11 +47,11 @@
  *
  * @since 1.2
  */
-public interface PrincipalMap extends PrincipalCollection, Map<String,Object> {
+public interface PrincipalMap extends PrincipalCollection, Map<String, Object> {
 
-    Map<String,Object> getRealmPrincipals(String realmName);
+    Map<String, Object> getRealmPrincipals(String realmName);
 
-    Map<String,Object> setRealmPrincipals(String realmName, Map<String,Object> principals);
+    Map<String, Object> setRealmPrincipals(String realmName, Map<String, Object> principals);
 
     Object setRealmPrincipal(String realmName, String principalName, Object principal);
 

File: core/src/main/java/org/apache/shiro/subject/support/SubjectCallable.java
Patch:
@@ -44,7 +44,7 @@
  * invocations. It also guarantees that the running thread remains 'clean' in any thread-pooled environments.
  *
  * <h3>Usage</h3>
- *
+ * <p>
  * This is typically considered a support class and is not often directly referenced.  Most people prefer to use
  * the {@code Subject.}{@link Subject#associateWith(Callable) associateWith} method, which will automatically return
  * an instance of this class.
@@ -53,6 +53,7 @@
  * {@link org.apache.shiro.concurrent.SubjectAwareExecutorService SubjectAwareExecutorService}, which
  * transparently uses instances of this class.
  *
+ * @param <V> V
  * @see Subject#associateWith(Callable)
  * @see org.apache.shiro.concurrent.SubjectAwareExecutorService SubjectAwareExecutorService
  * @since 1.0

File: core/src/main/java/org/apache/shiro/subject/support/SubjectRunnable.java
Patch:
@@ -40,7 +40,7 @@
  * <p/>
  *
  * <h3>Usage</h3>
- *
+ * <p>
  * This is typically considered a support class and is not often directly referenced.  Most people prefer to use
  * the {@code Subject.}{@link Subject#execute(Runnable) execute} or
  * {@code Subject.}{@link Subject#associateWith(Runnable) associateWith} methods, which transparently perform the

File: core/src/main/java/org/apache/shiro/subject/support/package-info.java
Patch:
@@ -19,4 +19,4 @@
 /**
  * Concrete support implementations of most of the {@code org.apache.shiro.subject} interfaces.
  */
-package org.apache.shiro.subject.support;
\ No newline at end of file
+package org.apache.shiro.subject.support;

File: core/src/main/java/org/apache/shiro/util/AbstractFactory.java
Patch:
@@ -21,8 +21,9 @@
 import org.apache.shiro.lang.util.Factory;
 
 /**
- * TODO - Class JavaDoc
+ * AbstractFactory.
  *
+ * @param <T> T
  * @since 1.0
  */
 public abstract class AbstractFactory<T> implements Factory<T> {

File: core/src/main/java/org/apache/shiro/util/PatternMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * Different implementations can support different pattern types, for example, Ant style path expressions, or
  * regular expressions, or other types of text based patterns.
  *
- * @see org.apache.shiro.lang.util.AntPathMatcher AntPathMatcher
+ * @see AntPathMatcher AntPathMatcher
  * @since 0.9 RC2
  */
 public interface PatternMatcher {
@@ -36,7 +36,7 @@ public interface PatternMatcher {
      * @param pattern the pattern to match against
      * @param source  the source to match
      * @return <code>true</code> if the given <code>source</code> matches the specified <code>pattern</code>,
-     *         <code>false</code> otherwise.
+     * <code>false</code> otherwise.
      */
     boolean matches(String pattern, String source);
 }

File: core/src/test/java/org/apache/shiro/ExceptionTest.java
Patch:
@@ -23,6 +23,7 @@
 
 
 /**
+ *
  */
 @SuppressWarnings({"ThrowableInstanceNeverThrown"})
 public abstract class ExceptionTest {

File: core/src/test/java/org/apache/shiro/authc/credential/AbstractHashedCredentialsMatcherTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.shiro.authc.AuthenticationInfo;
 
 import static org.junit.jupiter.api.Assertions.assertTrue;
+
 import org.apache.shiro.authc.AuthenticationToken;
 import org.apache.shiro.authc.SimpleAuthenticationInfo;
 import org.apache.shiro.authc.UsernamePasswordToken;

File: core/src/test/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategyTest.java
Patch:
@@ -24,7 +24,9 @@
 import org.apache.shiro.subject.PrincipalCollection;
 import org.apache.shiro.subject.SimplePrincipalCollection;
 
-import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;

File: core/src/test/java/org/apache/shiro/authz/aop/PermitAllAnnotationHandlerTest.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.apache.shiro.authz.aop;
 
-import org.apache.shiro.subject.Subject;
 import org.apache.shiro.test.SecurityManagerTestSupport;
 import org.junit.jupiter.api.Test;
 

File: core/src/test/java/org/apache/shiro/authz/aop/RoleAnnotationHandlerTest.java
Patch:
@@ -47,7 +47,7 @@ public void testGuestSingleRoleAssertion() throws Throwable {
         Annotation requiresRolesAnnotation = new RequiresRoles() {
             @Override
             public String[] value() {
-                return new String[]{"blah"};
+                return new String[] {"blah"};
             }
 
             @Override
@@ -75,7 +75,7 @@ public void testGuestMultipleRolesAssertion() throws Throwable {
         Annotation requiresRolesAnnotation = new RequiresRoles() {
             @Override
             public String[] value() {
-                return new String[]{"blah", "blah2"};
+                return new String[] {"blah", "blah2"};
             }
 
             @Override
@@ -110,7 +110,7 @@ protected Subject getSubject() {
         Annotation requiresRolesAnnotation = new RequiresRoles() {
             @Override
             public String[] value() {
-                return new String[]{"blah", "blah2"};
+                return new String[] {"blah", "blah2"};
             }
 
             @Override

File: core/src/test/java/org/apache/shiro/authz/aop/RolesAllowedAnnotationHandlerTest.java
Patch:
@@ -53,7 +53,7 @@ protected Subject getSubject() {
             Annotation rolesAllowedAnnotation = new RolesAllowed() {
                 @Override
                 public String[] value() {
-                    return new String[]{"blah"};
+                    return new String[] {"blah"};
                 }
 
                 @Override
@@ -85,7 +85,7 @@ protected Subject getSubject() {
             Annotation rolesAllowedAnnotation = new RolesAllowed() {
                 @Override
                 public String[] value() {
-                    return new String[]{"blah", "blah2"};
+                    return new String[] {"blah", "blah2"};
                 }
 
                 @Override
@@ -114,7 +114,7 @@ protected Subject getSubject() {
         Annotation rolesAllowedAnnotation = new RolesAllowed() {
             @Override
             public String[] value() {
-                return new String[]{"blah", "blah2"};
+                return new String[] {"blah", "blah2"};
             }
 
             @Override

File: core/src/test/java/org/apache/shiro/authz/permission/AllPermissionTest.java
Patch:
@@ -24,6 +24,7 @@
 
 
 /**
+ *
  */
 public class AllPermissionTest {
 

File: core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorServiceTest.java
Patch:
@@ -56,7 +56,7 @@ public void testSubmitRunnable() {
         });
     }
 
-    private static class DummyFuture<V> implements Future<V> {
+    private static final class DummyFuture<V> implements Future<V> {
 
         @Override
         public boolean cancel(boolean b) {

File: core/src/test/java/org/apache/shiro/config/HashMapCacheManager.java
Patch:
@@ -31,6 +31,7 @@
  *
  * @since 1.0
  */
+@SuppressWarnings("checkstyle:JavadocType")
 public class HashMapCacheManager<K, V> extends AbstractCacheManager {
 
     @Override

File: core/src/test/java/org/apache/shiro/lang/io/SerializationExceptionTest.java
Patch:
@@ -22,6 +22,7 @@
 
 
 /**
+ *
  */
 public class SerializationExceptionTest extends ExceptionTest {
 

File: core/src/test/java/org/apache/shiro/mgt/AbstractRememberMeManagerTest.java
Patch:
@@ -56,6 +56,7 @@ protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext)
         assertNull(principals);
     }
 
+    @SuppressWarnings("checkstyle:FinalClass")
     private static class DummyRememberMeManager extends AbstractRememberMeManager {
         public void forgetIdentity(SubjectContext subjectContext) {
             //do nothing

File: core/src/test/java/org/apache/shiro/realm/UserIdPrincipal.java
Patch:
@@ -36,4 +36,4 @@ public int getUserId() {
     public String getName() {
         return String.valueOf(userId);
     }
-}
\ No newline at end of file
+}

File: core/src/test/java/org/apache/shiro/realm/text/IniRealmTest.java
Patch:
@@ -23,7 +23,9 @@
 import org.apache.shiro.config.Ini;
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 /**
  * Unit tests for the {@link IniRealm} class.

File: core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
Patch:
@@ -34,8 +34,8 @@
  */
 public class DelegatingSessionTest {
 
-    DelegatingSession session = null;
-    DefaultSessionManager sm = null;
+    DelegatingSession session;
+    DefaultSessionManager sm;
 
     @BeforeEach
     public void setup() {
@@ -58,6 +58,7 @@ public void sleep(long millis) {
         }
     }
 
+    @SuppressWarnings("checkstyle:MagicNumber")
     @Test
     void testTimeout() {
         Serializable origId = session.getId();

File: core/src/test/java/org/apache/shiro/session/mgt/ExecutorServiceSessionValidationSchedulerTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
+@SuppressWarnings("checkstyle:MagicNumber")
 public class ExecutorServiceSessionValidationSchedulerTest {
 
     ExecutorServiceSessionValidationScheduler executorServiceSessionValidationScheduler;
@@ -96,7 +97,7 @@ public void tearDown() throws Exception {
         executorServiceSessionValidationScheduler.disableSessionValidation();
     }
 
-    private class FakeDefaultSessionManager extends DefaultSessionManager {
+    private static final class FakeDefaultSessionManager extends DefaultSessionManager {
         public void validateSessions() throws RuntimeException {
             throw new RuntimeException("Session test exception");
         }

File: core/src/test/java/org/apache/shiro/subject/SimplePrincipalCollectionTest.java
Patch:
@@ -30,8 +30,7 @@ public class SimplePrincipalCollectionTest {
     private static final Logger LOG = LoggerFactory.getLogger(SimplePrincipalCollectionTest.class);
 
     @Test
-    void multiplePrincipalsTest()
-    {
+    void multiplePrincipalsTest() {
         SimplePrincipalCollection principalCollection = new SimplePrincipalCollection();
         principalCollection.add("frank", "realm1");
         principalCollection.add("johnny", "realm1");

File: core/src/test/java/org/apache/shiro/test/SecurityManagerTestSupport.java
Patch:
@@ -72,7 +72,8 @@ protected Subject createSubject() {
     /**
      * Associates the {@code consumer} with the {@code subject} and executes. If an exeception was thrown by the
      * consumer, it is re-thrown by this method.
-     * @param subject The subject to bind to the current thread.
+     *
+     * @param subject  The subject to bind to the current thread.
      * @param consumer The block of code to run under the context of the subject.
      * @throws Exception propagates any exception thrown by the consumer.
      */

File: core/src/test/java/org/apache/shiro/util/PermissionUtilsTest.java
Patch:
@@ -35,6 +35,7 @@ class PermissionUtilsTest {
 
     private static final PermissionResolver RESOLVER = new WildcardPermissionResolver(true);
 
+    @SuppressWarnings("checkstyle:MethodName")
     @Test
     void SHIRO_902_quoted_permissions() {
         // given

File: crypto/cipher/src/main/java/org/apache/shiro/crypto/cipher/BlowfishCipherService.java
Patch:
@@ -87,6 +87,7 @@ public class BlowfishCipherService extends DefaultBlockCipherService {
      */
     public BlowfishCipherService() {
         super(ALGORITHM_NAME);
-        setInitializationVectorSize(BLOCK_SIZE); //like most block ciphers, the IV size is the same as the block size
+        //like most block ciphers, the IV size is the same as the block size
+        setInitializationVectorSize(BLOCK_SIZE);
     }
 }

File: crypto/cipher/src/main/java/org/apache/shiro/crypto/cipher/PaddingScheme.java
Patch:
@@ -147,7 +147,7 @@ public enum PaddingScheme {
 
     private final String transformationName;
 
-    private PaddingScheme(String transformationName) {
+    PaddingScheme(String transformationName) {
         this.transformationName = transformationName;
     }
 
@@ -156,7 +156,7 @@ private PaddingScheme(String transformationName) {
      * {@code transformation string}.
      *
      * @return the actual string name to use when building the {@link javax.crypto.Cipher Cipher}
-     *         {@code transformation string}.
+     * {@code transformation string}.
      * @see javax.crypto.Cipher#getInstance(String)
      */
     public String getTransformationName() {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/DefaultHashService.java
Patch:
@@ -78,7 +78,7 @@ public DefaultHashService() {
      *
      * @param request the request to process
      * @return the response containing the result of the hash computation, as well as any hash salt used that should be
-     *         exposed to the caller.
+     * exposed to the caller.
      */
     @Override
     public Hash computeHash(HashRequest request) {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/HashRequest.java
Patch:
@@ -54,7 +54,7 @@ public interface HashRequest {
      * strategy for a request, even if the request did not specify one.
      *
      * @return a salt to be used by the {@link HashService} during hash computation, or {@code null} if no salt is
-     *         provided as part of the request.
+     * provided as part of the request.
      */
     Optional<ByteSource> getSalt();
 
@@ -94,11 +94,11 @@ public interface HashRequest {
      * @see SimpleHashRequest
      * @since 1.2
      */
-    public static class Builder {
+    class Builder {
 
         private ByteSource source;
         private ByteSource salt = SimpleByteSource.empty();
-        private Map<String, Object> parameters = new ConcurrentHashMap<>();
+        private final Map<String, Object> parameters = new ConcurrentHashMap<>();
         private String algorithmName;
 
         /**

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/HashService.java
Patch:
@@ -56,7 +56,7 @@ public interface HashService {
      * Computes a hash based on the given request.
      *
      * <h3>Salt Notice</h3>
-     *
+     * <p>
      * If a salt accompanies the return value
      * (i.e. <code>returnedHash.{@link org.apache.shiro.crypto.hash.Hash#getSalt() getSalt()} != null</code>), this
      * same exact salt <b><em>MUST</em></b> be presented back to the {@code HashService} if hash

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/HashSpi.java
Patch:
@@ -77,10 +77,11 @@ interface HashFactory {
          * should use default parameters where applicable.</p>
          * <p>If the hash requests salt is missing or empty, the implementation should create a salt
          * with a default size.</p>
+         *
          * @param hashRequest the request to build a Hash from.
          * @return a generated Hash according to the specs.
          * @throws IllegalArgumentException if any of the parameters is outside of valid boundaries (algorithm-specific)
-         * or if the given algorithm is not applicable for this {@link HashFactory}.
+         *                                  or if the given algorithm is not applicable for this {@link HashFactory}.
          */
         Hash generate(HashRequest hashRequest);
     }

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/Sha256Hash.java
Patch:
@@ -34,8 +34,9 @@
  */
 public class Sha256Hash extends SimpleHash {
 
-    //TODO - complete JavaDoc
-
+    /**
+     * Sha256 algorithm name.
+     */
     public static final String ALGORITHM_NAME = "SHA-256";
 
     public Sha256Hash() {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/Sha384Hash.java
Patch:
@@ -35,8 +35,9 @@
  */
 public class Sha384Hash extends SimpleHash {
 
-    //TODO - complete JavaDoc
-
+    /**
+     * Sha384 algorithm name.
+     */
     public static final String ALGORITHM_NAME = "SHA-384";
 
     public Sha384Hash() {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/Sha512Hash.java
Patch:
@@ -34,8 +34,9 @@
  */
 public class Sha512Hash extends SimpleHash {
 
-    //TODO - complete JavaDoc
-
+    /**
+     * Sha512 algorithm name.
+     */
     public static final String ALGORITHM_NAME = "SHA-512";
 
     public Sha512Hash() {

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/format/ParsableHashFormat.java
Patch:
@@ -28,7 +28,6 @@
  * (like Unix Crypt(3)) only support one way conversion and therefore wouldn't implement this interface.
  *
  * @see Shiro1CryptFormat
- *
  * @since 1.2
  */
 public interface ParsableHashFormat extends HashFormat {

File: event/src/main/java/org/apache/shiro/event/support/AnnotationEventListenerResolver.java
Patch:
@@ -51,7 +51,7 @@ public AnnotationEventListenerResolver() {
      *
      * @param instance the instance to inspect for annotated event handler methods.
      * @return a new collection of {@link EventListener} instances, each instance corresponding to an annotated
-     *         method discovered on the specified {@code instance} argument.
+     * method discovered on the specified {@code instance} argument.
      */
     public List<EventListener> getEventListeners(Object instance) {
         if (instance == null) {
@@ -77,7 +77,7 @@ public List<EventListener> getEventListeners(Object instance) {
      * defaults to {@link Subscribe}.
      *
      * @return the type of annotation that indicates a method that should be represented as an {@link EventListener},
-     *         defaults to {@link Subscribe}.
+     * defaults to {@link Subscribe}.
      */
     public Class<? extends Annotation> getAnnotationClass() {
         return annotationClass;

File: event/src/main/java/org/apache/shiro/event/support/EventClassComparator.java
Patch:
@@ -37,7 +37,7 @@
  * &#64;Subscribe
  * public void onEvent(B b) { ... }
  * </pre>
- *
+ * <p>
  * The {@code onEvent(B b)} method will be invoked on the subscriber and the
  * {@code onEvent(A a)} method will <em>not</em> be invoked.  This is to prevent multiple dispatching of a single event
  * to the same consumer.

File: event/src/main/java/org/apache/shiro/event/support/EventListener.java
Patch:
@@ -34,13 +34,13 @@
  *
  * @see SingleArgumentMethodEventListener
  * @see AnnotationEventListenerResolver
- *
  * @since 1.3
  */
 public interface EventListener {
 
     /**
      * Returns {@code true} if the listener instance can process the specified event object, {@code false} otherwise.
+     *
      * @param event the event object to test
      * @return {@code true} if the listener instance can process the specified event object, {@code false} otherwise.
      */

File: integration-tests/guice3/src/test/java/org/apache/shiro/samples/guice/ContainerIntegrationIT.java
Patch:
@@ -40,8 +40,7 @@ public void logOut() throws IOException {
         final HtmlPage homePage = webClient.getPage(getBaseUri());
         try {
             homePage.getAnchorByHref("/logout").click();
-        }
-        catch (ElementNotFoundException e) {
+        } catch (ElementNotFoundException e) {
             //Ignore
         }
     }

File: integration-tests/guice4/src/test/java/org/apache/shiro/samples/guice/ContainerIntegrationIT.java
Patch:
@@ -40,8 +40,7 @@ public void logOut() throws IOException {
         final HtmlPage homePage = webClient.getPage(getBaseUri());
         try {
             homePage.getAnchorByHref("/logout").click();
-        }
-        catch (ElementNotFoundException e) {
+        } catch (ElementNotFoundException e) {
             //Ignore
         }
     }

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/cdi/CipherKeyGenerator.java
Patch:
@@ -14,6 +14,7 @@
 package org.apache.shiro.testing.cdi;
 
 import javax.enterprise.context.ApplicationScoped;
+
 import org.apache.shiro.cdi.annotations.CipherKeySupplier;
 
 @ApplicationScoped

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/cdi/ComponentInjectionBean.java
Patch:
@@ -15,13 +15,15 @@
 
 import javax.enterprise.context.ApplicationScoped;
 import javax.inject.Inject;
+
 import lombok.Getter;
 import org.apache.shiro.cdi.annotations.NoSessionCreation;
 import org.apache.shiro.cdi.annotations.Principal;
 import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.session.Session;
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.testing.jakarta.ee.PropertyPrincipal;
+
 import java.util.function.Supplier;
 
 @ApplicationScoped

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/jakarta/ee/FormBean.java
Patch:
@@ -14,6 +14,7 @@
 package org.apache.shiro.testing.jakarta.ee;
 
 import javax.enterprise.inject.Model;
+
 import lombok.Getter;
 import lombok.Setter;
 import lombok.extern.slf4j.Slf4j;
@@ -25,7 +26,8 @@
  * form's backing bean
  */
 @Model
-@Getter @Setter
+@Getter
+@Setter
 @Slf4j
 public class FormBean {
     private String firstName;

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/jakarta/ee/PropertyPrincipal.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.io.Serializable;
 import javax.enterprise.inject.Vetoed;
+
 import lombok.AllArgsConstructor;
 import lombok.Getter;
 

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/jakarta/ee/PropertyRealm.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Map;
 import javax.enterprise.context.ApplicationScoped;
 import javax.inject.Named;
+
 import lombok.Getter;
 import lombok.Setter;
 import org.apache.shiro.authc.SimpleAccount;
@@ -27,7 +28,8 @@
 @Named
 @ApplicationScoped
 public class PropertyRealm extends IniRealm {
-    @Getter @Setter
+    @Getter
+    @Setter
     private IniRealm iniRealm;
 
     @Override

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/jakarta/ee/ProtectedFacesViewScopedBean.java
Patch:
@@ -14,13 +14,15 @@
 package org.apache.shiro.testing.jakarta.ee;
 
 import static org.apache.shiro.testing.jakarta.ee.StatisticsResource.increment;
+
 import java.io.Serializable;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.PostConstruct;
 import javax.annotation.PreDestroy;
 import javax.faces.context.FacesContext;
 import javax.faces.view.ViewScoped;
 import javax.inject.Named;
+
 import lombok.extern.slf4j.Slf4j;
 import org.apache.shiro.authz.annotation.RequiresUser;
 
@@ -49,6 +51,6 @@ void preDestroy() {
 
     public String hello() {
         return String.format("Hello from FacesViewScoped %s - %s", count,
-        FacesContext.class.getPackage().getImplementationVersion());
+                FacesContext.class.getPackage().getImplementationVersion());
     }
 }

File: integration-tests/jakarta-ee/src/main/java/org/apache/shiro/testing/jakarta/ee/ProtectedOmniViewScopedBean.java
Patch:
@@ -14,12 +14,14 @@
 package org.apache.shiro.testing.jakarta.ee;
 
 import static org.apache.shiro.testing.jakarta.ee.StatisticsResource.increment;
+
 import java.io.Serializable;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.PostConstruct;
 import javax.annotation.PreDestroy;
 import javax.faces.context.FacesContext;
 import javax.inject.Named;
+
 import lombok.extern.slf4j.Slf4j;
 import org.apache.shiro.authz.annotation.RequiresUser;
 import org.omnifaces.cdi.ViewScoped;
@@ -49,6 +51,6 @@ void preDestroy() {
 
     public String hello() {
         return String.format("Hello from OmniViewScoped %s - %s", count,
-        FacesContext.class.getPackage().getImplementationVersion());
+                FacesContext.class.getPackage().getImplementationVersion());
     }
 }

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/AuthenticationFilterDelegate.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.shiro.ee.filters.Forms.FallbackPredicate;
 import static org.apache.shiro.ee.filters.LogoutFilter.LOGOUT_PREDICATE_ATTR_NAME;
 import static org.apache.shiro.ee.filters.LogoutFilter.YES_PREDICATE;
-import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;
+import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResubmitDisabled;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 import javax.servlet.ServletRequest;
@@ -102,7 +102,7 @@ public boolean isAccessAllowed(ServletRequest request, ServletResponse response,
      * @throws IOException
      */
     public void redirectToLogin(ServletRequest request, ServletResponse response) throws IOException {
-        if (request instanceof HttpServletRequest && !isFormResumbitDisabled(request.getServletContext())) {
+        if (request instanceof HttpServletRequest && !isFormResubmitDisabled(request.getServletContext())) {
             savePostDataForResubmit(WebUtils.toHttp(request), WebUtils.toHttp(response),
                     methods.getLoginUrl());
         }

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/FormResubmitSupport.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.shiro.ee.filters.Forms.FallbackPredicate;
 import org.apache.shiro.ee.filters.ShiroFilter.WrappedSecurityManager;
 import static org.apache.shiro.ee.filters.FormResubmitSupportCookies.transformCookieHeader;
-import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;
+import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResubmitDisabled;
 import java.io.IOException;
 import java.net.CookieManager;
 import java.net.HttpCookie;
@@ -233,7 +233,7 @@ static String getReferer(HttpServletRequest request) {
 
     /**
      * Redirects the user to saved request after login, if available
-     * Resumbits the form that caused the logout upon successfull login.Form resumnission supports JSF and Ajax forms
+     * Resubmits the form that caused the logout upon successfull login.Form resumnission supports JSF and Ajax forms
      * @param request
      * @param response
      * @param useFallbackPath predicate whether to use fall back path
@@ -263,7 +263,7 @@ static void redirectToSaved(HttpServletRequest request, HttpServletResponse resp
     static void redirectToSaved(HttpServletRequest request, HttpServletResponse response,
             FallbackPredicate useFallbackPath, String fallbackPath) {
         redirectToSaved(request, response, useFallbackPath, fallbackPath,
-                !isFormResumbitDisabled(request.getServletContext()));
+                !isFormResubmitDisabled(request.getServletContext()));
     }
 
 

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/Forms.java
Patch:
@@ -18,7 +18,7 @@
 import static org.apache.shiro.ee.filters.FormResubmitSupport.FORM_IS_RESUBMITTED;
 import static org.apache.shiro.ee.filters.FormResubmitSupport.SESSION_EXPIRED_PARAMETER;
 import static org.apache.shiro.ee.filters.LogoutFilter.LOGOUT_PREDICATE_ATTR_NAME;
-import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;
+import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResubmitDisabled;
 import java.util.concurrent.TimeUnit;
 import javax.enterprise.context.ApplicationScoped;
 import javax.inject.Named;
@@ -130,7 +130,7 @@ public interface FallbackPredicate {
      */
     public static void redirectToSaved(FallbackPredicate useFallbackPath, String fallbackPath) {
         FormResubmitSupport.redirectToSaved(Faces.getRequest(), Faces.getResponse(), useFallbackPath, fallbackPath,
-                !isFormResumbitDisabled(Faces.getRequest().getServletContext()));
+                !isFormResubmitDisabled(Faces.getRequest().getServletContext()));
     }
 
     /**

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/AuthenticationFilterDelegate.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.shiro.ee.filters.Forms.FallbackPredicate;
 import static org.apache.shiro.ee.filters.LogoutFilter.LOGOUT_PREDICATE_ATTR_NAME;
 import static org.apache.shiro.ee.filters.LogoutFilter.YES_PREDICATE;
-import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;
+import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResubmitDisabled;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 import javax.servlet.ServletRequest;
@@ -102,7 +102,7 @@ public boolean isAccessAllowed(ServletRequest request, ServletResponse response,
      * @throws IOException
      */
     public void redirectToLogin(ServletRequest request, ServletResponse response) throws IOException {
-        if (request instanceof HttpServletRequest && !isFormResumbitDisabled(request.getServletContext())) {
+        if (request instanceof HttpServletRequest && !isFormResubmitDisabled(request.getServletContext())) {
             savePostDataForResubmit(WebUtils.toHttp(request), WebUtils.toHttp(response),
                     methods.getLoginUrl());
         }

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/FormResubmitSupport.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.shiro.ee.filters.Forms.FallbackPredicate;
 import org.apache.shiro.ee.filters.ShiroFilter.WrappedSecurityManager;
 import static org.apache.shiro.ee.filters.FormResubmitSupportCookies.transformCookieHeader;
-import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;
+import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResubmitDisabled;
 import java.io.IOException;
 import java.net.CookieManager;
 import java.net.HttpCookie;
@@ -233,7 +233,7 @@ static String getReferer(HttpServletRequest request) {
 
     /**
      * Redirects the user to saved request after login, if available
-     * Resumbits the form that caused the logout upon successfull login.Form resumnission supports JSF and Ajax forms
+     * Resubmits the form that caused the logout upon successfull login.Form resumnission supports JSF and Ajax forms
      * @param request
      * @param response
      * @param useFallbackPath predicate whether to use fall back path
@@ -263,7 +263,7 @@ static void redirectToSaved(HttpServletRequest request, HttpServletResponse resp
     static void redirectToSaved(HttpServletRequest request, HttpServletResponse response,
             FallbackPredicate useFallbackPath, String fallbackPath) {
         redirectToSaved(request, response, useFallbackPath, fallbackPath,
-                !isFormResumbitDisabled(request.getServletContext()));
+                !isFormResubmitDisabled(request.getServletContext()));
     }
 
 

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/Forms.java
Patch:
@@ -18,7 +18,7 @@
 import static org.apache.shiro.ee.filters.FormResubmitSupport.FORM_IS_RESUBMITTED;
 import static org.apache.shiro.ee.filters.FormResubmitSupport.SESSION_EXPIRED_PARAMETER;
 import static org.apache.shiro.ee.filters.LogoutFilter.LOGOUT_PREDICATE_ATTR_NAME;
-import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResumbitDisabled;
+import static org.apache.shiro.ee.listeners.EnvironmentLoaderListener.isFormResubmitDisabled;
 import java.util.concurrent.TimeUnit;
 import javax.enterprise.context.ApplicationScoped;
 import javax.inject.Named;
@@ -130,7 +130,7 @@ public interface FallbackPredicate {
      */
     public static void redirectToSaved(FallbackPredicate useFallbackPath, String fallbackPath) {
         FormResubmitSupport.redirectToSaved(Faces.getRequest(), Faces.getResponse(), useFallbackPath, fallbackPath,
-                !isFormResumbitDisabled(Faces.getRequest().getServletContext()));
+                !isFormResubmitDisabled(Faces.getRequest().getServletContext()));
     }
 
     /**

File: integration-tests/jaxrs/app/src/main/java/org/apache/shiro/testing/jaxrs/app/dao/InMemoryStormtrooperDao.java
Patch:
@@ -45,7 +45,7 @@ public class InMemoryStormtrooperDao implements StormtrooperDao {
     static {
         Faker faker = new Faker();
         final FakeValuesService fakeValuesService = new FakeValuesService(Locale.ENGLISH, new RandomService());
-        for (int ii = 0; ii < 50; ii++) {
+        while (TROOPERS.size() < 50) {
             final StormtrooperId stormtrooperId = new StormtrooperId(fakeValuesService.numerify("u######"));
             final Name name = faker.name();
             final Instant registeredAt = faker.date().birthday(16, 67).toInstant();

File: integration-tests/jaxrs/app/src/main/java/org/apache/shiro/testing/jaxrs/app/dao/InMemoryStormtrooperDao.java
Patch:
@@ -45,7 +45,7 @@ public class InMemoryStormtrooperDao implements StormtrooperDao {
     static {
         Faker faker = new Faker();
         final FakeValuesService fakeValuesService = new FakeValuesService(Locale.ENGLISH, new RandomService());
-        for (int ii = 0; ii < 50; ii++) {
+        while (TROOPERS.size() < 50) {
             final StormtrooperId stormtrooperId = new StormtrooperId(fakeValuesService.numerify("u######"));
             final Name name = faker.name();
             final Instant registeredAt = faker.date().birthday(16, 67).toInstant();

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/filters/FormResubmitSupport.java
Patch:
@@ -376,8 +376,8 @@ static String resubmitSavedForm(@NonNull String savedFormData, @NonNull String s
             deleteCookie(originalResponse, servletContext, SHIRO_FORM_DATA_KEY);
             return processResubmitResponse(response, originalRequest, originalResponse,
                     response.headers(), savedRequest, servletContext,
-                    decodedFormData.isStatelessRequest ? false : decodedFormData.isPartialAjaxRequest,
-                    rememberedAjaxResubmit);
+                    (rememberedAjaxResubmit && decodedFormData.isStatelessRequest) ? false
+                            : decodedFormData.isPartialAjaxRequest, rememberedAjaxResubmit);
         }
     }
 

File: support/jakarta-ee/src/main/java/org/apache/shiro/ee/listeners/IniEnvironment.java
Patch:
@@ -65,7 +65,8 @@ protected SecurityManager createDefaultInstance() {
         }
 
         private byte[] generateCipherKey() {
-            var cipherKeySupplier = Beans.getReference(CipherKeySupplier.class);
+            var cipherKeySupplier = Beans.getManager() == null ? null
+                    : Beans.getReference(CipherKeySupplier.class);
             if (cipherKeySupplier == null || isBlank(cipherKeySupplier.get())) {
                 return cipherService.get().generateNewKey().getEncoded();
             } else {

File: web/src/main/java/org/apache/shiro/web/servlet/HttpSessionContext.java
Patch:
@@ -16,10 +16,10 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package jakarta.servlet.http;
+package org.apache.shiro.web.servlet;
 
 /**
- * Shim for class that no longer exists in Jakarta EE,
+ * Shim for interface that no longer exists in Jakarta EE,
  * but still exists in Java EE
  *
  * @author lprimak

File: core/src/main/java/org/apache/shiro/realm/activedirectory/ActiveDirectoryRealm.java
Patch:
@@ -163,7 +163,7 @@ protected Set<String> getRoleNamesForUser(String username, LdapContext ldapConte
         searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);
 
         String userPrincipalName = username;
-        if (principalSuffix != null) {
+        if (principalSuffix != null && !userPrincipalName.toLowerCase(Locale.ROOT).endsWith(principalSuffix.toLowerCase(Locale.ROOT))) {
             userPrincipalName += principalSuffix;
         }
 

File: core/src/main/java/org/apache/shiro/realm/activedirectory/ActiveDirectoryRealm.java
Patch:
@@ -163,7 +163,7 @@ protected Set<String> getRoleNamesForUser(String username, LdapContext ldapConte
         searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);
 
         String userPrincipalName = username;
-        if (principalSuffix != null) {
+        if (principalSuffix != null && !userPrincipalName.toLowerCase(Locale.ROOT).endsWith(principalSuffix.toLowerCase(Locale.ROOT))) {
             userPrincipalName += principalSuffix;
         }
 

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresAuthentication.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.apache.shiro.authz.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -42,5 +43,6 @@
  */
 @Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
+@Documented
 public @interface RequiresAuthentication {
 }

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresGuest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.apache.shiro.authz.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -39,5 +40,6 @@
  */
 @Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
+@Documented
 public @interface RequiresGuest {
 }

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresPermissions.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.apache.shiro.authz.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -45,6 +46,7 @@
  */
 @Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
+@Documented
 public @interface RequiresPermissions {
 
     /**

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresRoles.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.apache.shiro.authz.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -52,6 +53,7 @@
  */
 @Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
+@Documented
 public @interface RequiresRoles {
 
     /**

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresUser.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.apache.shiro.authz.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -47,5 +48,6 @@
  */
 @Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
+@Documented
 public @interface RequiresUser {
 }

File: event/src/main/java/org/apache/shiro/event/Subscribe.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.apache.shiro.event;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -41,5 +42,6 @@
  */
 @Retention(value = RetentionPolicy.RUNTIME)
 @Target(value = ElementType.METHOD)
+@Documented
 public @interface Subscribe {
 }

File: cache/src/main/java/org/apache/shiro/cache/Cache.java
Patch:
@@ -27,7 +27,7 @@
  * <p>Shiro doesn't implement a full Cache mechanism itself, since that is outside the core competency of a
  * Security framework.  Instead, this interface provides an abstraction (wrapper) API on top of an underlying
  * cache framework's cache instance (e.g. JCache, Ehcache, JCS, OSCache, JBossCache, TerraCotta, Coherence,
- * GigaSpaces, etc, etc), allowing a Shiro user to configure any cache mechanism they choose.
+ * GigaSpaces, etc., etc.), allowing a Shiro user to configure any cache mechanism they choose.
  *
  * @since 0.2
  */

File: cache/src/main/java/org/apache/shiro/cache/CacheManager.java
Patch:
@@ -24,7 +24,7 @@
  * <p>Shiro doesn't implement a full Cache mechanism itself, since that is outside the core competency of a
  * Security framework.  Instead, this interface provides an abstraction (wrapper) API on top of an underlying
  * cache framework's main Manager component (e.g. JCache, Ehcache, JCS, OSCache, JBossCache, TerraCotta, Coherence,
- * GigaSpaces, etc, etc), allowing a Shiro user to configure any cache mechanism they choose.
+ * GigaSpaces, etc., etc.), allowing a Shiro user to configure any cache mechanism they choose.
  *
  * @since 0.9
  */

File: cache/src/main/java/org/apache/shiro/cache/MemoryConstrainedCacheManager.java
Patch:
@@ -29,7 +29,7 @@
  * While the {@code Cache} instances created are thread-safe, they do not offer any enterprise-level features such as
  * cache coherency, optimistic locking, failover or other similar features.  For more enterprise features, consider
  * using a different {@code CacheManager} implementation backed by an enterprise-grade caching product (Hazelcast,
- * EhCache, TerraCotta, Coherence, GigaSpaces, etc, etc).
+ * EhCache, TerraCotta, Coherence, GigaSpaces, etc., etc.).
  *
  * @since 1.0
  */

File: core/src/main/java/org/apache/shiro/aop/MethodInvocation.java
Patch:
@@ -51,10 +51,10 @@ public interface MethodInvocation {
     Object[] getArguments();
 
     /**
-     * Returns the object that holds the current joinpoint's static part.
+     * Returns the object that holds the current join point's static part.
      * For instance, the target object for an invocation.
      *
-     * @return the object that holds the current joinpoint's static part.
+     * @return the object that holds the current join point's static part.
      * @since 1.0
      */
     Object getThis();

File: core/src/main/java/org/apache/shiro/aop/package-info.java
Patch:
@@ -21,6 +21,6 @@
  * <p/>
  * As this package is a root-level package under <tt>org.apache.shiro</tt>, it contains AOP support classes
  * useful for any AOP environment and/or function. Feature-dependent AOP classes (e.g. authorization,
- * authentication, etc) will use these classes as their base in their respective packages.
+ * authentication, etc.) will use these classes as their base in their respective packages.
  */
 package org.apache.shiro.aop;
\ No newline at end of file

File: core/src/main/java/org/apache/shiro/authc/AbstractAuthenticator.java
Patch:
@@ -247,7 +247,7 @@ public final AuthenticationInfo authenticate(AuthenticationToken token) throws A
      * {@code AuthenticationException} if there is a problem during
      * authentication instead of returning {@code null}.  A {@code null} return value indicates
      * a configuration or programming error, since {@code AuthenticationException}s should
-     * indicate any expected problem (such as an unknown account or username, or invalid password, etc).
+     * indicate any expected problem (such as an unknown account or username, or invalid password, etc.).
      *
      * @param token the authentication token encapsulating the user's login information.
      * @return an {@code AuthenticationInfo} object encapsulating the user's account information

File: core/src/main/java/org/apache/shiro/authc/Account.java
Patch:
@@ -29,7 +29,7 @@
  * encapsulate both the authentication and authorization information used by both authc and authz operations.
  * <p/>
  * <b>Please Note</b>:  Since Shiro sometimes logs account operations, please ensure your Account's <code>toString()</code>
- * implementation does <em>not</em> print out account credentials (password, etc), as these might be viewable to
+ * implementation does <em>not</em> print out account credentials (password, etc.), as these might be viewable to
  * someone reading your logs.  This is good practice anyway, and account principals should rarely (if ever) be printed
  * out for any reason.  If you're using Shiro's default implementations of this interface, they only ever print the
  * account {@link #getPrincipals() principals}, so you do not need to do anything additional.

File: core/src/main/java/org/apache/shiro/authc/AuthenticationInfo.java
Patch:
@@ -46,7 +46,7 @@
  * preferences.
  * <p/>
  * <p><b>Please note:</b>  Since Shiro sometimes logs authentication operations, please ensure your AuthenticationInfo's
- * <code>toString()</code> implementation does <em>not</em> print out account credentials (password, etc), as these might be viewable to
+ * <code>toString()</code> implementation does <em>not</em> print out account credentials (password, etc.), as these might be viewable to
  * someone reading your logs.  This is good practice anyway, and account credentials should rarely (if ever) be printed
  * out for any reason.  If you're using Shiro's default implementations of this interface, they only ever print the
  * account {@link #getPrincipals() principals}, so you do not need to do anything additional.</p>
@@ -59,7 +59,7 @@ public interface AuthenticationInfo extends Serializable {
 
     /**
      * Returns all principals associated with the corresponding Subject.  Each principal is an identifying piece of
-     * information useful to the application such as a username, or user id, a given name, etc - anything useful
+     * information useful to the application such as a username, or user id, a given name, etc. - anything useful
      * to the application to identify the current <code>Subject</code>.
      * <p/>
      * The returned PrincipalCollection should <em>not</em> contain any credentials used to verify principals, such

File: core/src/main/java/org/apache/shiro/authc/AuthenticationToken.java
Patch:
@@ -34,7 +34,7 @@
  * <p/>
  * <p>Because applications represent user data and credentials in different ways, implementations
  * of this interface are application-specific.  You are free to acquire a user's principals and
- * credentials however you wish (e.g. web form, Swing form, fingerprint identification, etc) and
+ * credentials however you wish (e.g. web form, Swing form, fingerprint identification, etc.) and
  * then submit them to the Shiro framework in the form of an implementation of this
  * interface.
  * <p/>
@@ -68,7 +68,7 @@ public interface AuthenticationToken extends Serializable {
      * sufficient for your use.
      * <p/>
      * <p>Ultimately, the object returned is application specific and can represent
-     * any account identity (user id, X.509 certificate, etc).
+     * any account identity (user id, X.509 certificate, etc.).
      *
      * @return the account identity submitted during the authentication process.
      * @see UsernamePasswordToken

File: core/src/main/java/org/apache/shiro/authc/LogoutAware.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * An SPI interface allowing cleanup logic to be executed during logout of a previously authenticated Subject/user.
  *
- * <p>As it is an SPI interface, it is really intended for SPI implementors such as those implementing Realms.
+ * <p>As it is an SPI interface, it is really intended for SPI implementers such as those implementing Realms.
  *
  * <p>All of Shiro's concrete Realm implementations implement this interface as a convenience for those wishing
  * to subclass them.

File: core/src/main/java/org/apache/shiro/authc/SimpleAuthenticationInfo.java
Patch:
@@ -135,7 +135,7 @@ public PrincipalCollection getPrincipals() {
     /**
      * Sets the identifying principal(s) represented by this instance.
      *
-     * @param principals the indentifying attributes of the corresponding Realm account.
+     * @param principals the identifying attributes of the corresponding Realm account.
      */
     public void setPrincipals(PrincipalCollection principals) {
         this.principals = principals;

File: core/src/main/java/org/apache/shiro/authc/credential/DefaultPasswordService.java
Patch:
@@ -60,7 +60,7 @@ public class DefaultPasswordService implements HashingPasswordService {
     /**
      * Constructs a new PasswordService with a default hash service and the default
      * algorithm name {@value #DEFAULT_HASH_ALGORITHM}, a default hash format (shiro2) and
-     * a default hashformat factory.
+     * a default hash format factory.
      *
      * <p>The default algorithm can change between minor versions and does not introduce
      * API incompatibility by design.</p>

File: core/src/main/java/org/apache/shiro/authc/credential/HashedCredentialsMatcher.java
Patch:
@@ -93,7 +93,7 @@
  * If this is not possible for some reason, this class will retain 1.0 backwards-compatible behavior of obtaining
  * the salt via the now-deprecated {@link #getSalt(AuthenticationToken) getSalt(AuthenticationToken)} method.  This
  * method will only be invoked if a {@code Realm} <em>does not</em> return
- * {@link SaltedAuthenticationInfo SaltedAutenticationInfo} instances and {@link #isHashSalted() hashSalted} is
+ * {@link SaltedAuthenticationInfo SaltedAuthenticationInfo} instances and {@link #isHashSalted() hashSalted} is
  * {@code true}.
  * But please note that the {@link #isHashSalted() hashSalted} property and the
  * {@link #getSalt(AuthenticationToken) getSalt(AuthenticationToken)} methods will be removed before the Shiro 2.0

File: core/src/main/java/org/apache/shiro/authc/credential/HashingPasswordService.java
Patch:
@@ -58,7 +58,7 @@ public interface HashingPasswordService extends PasswordService {
      * </pre>
      *
      * @param plaintext the raw password as 'byte-backed' object (String, character array, {@link ByteSource},
-     *                  etc) usually acquired from your application's 'new user' or 'password reset' workflow.
+     *                  etc.) usually acquired from your application's 'new user' or 'password reset' workflow.
      * @return the hashed password.
      * @throws IllegalArgumentException if the argument cannot be easily converted to bytes as defined by
      *                                  {@link ByteSource.Util#isCompatible(Object)}.

File: core/src/main/java/org/apache/shiro/authc/credential/PasswordService.java
Patch:
@@ -106,7 +106,7 @@ public interface PasswordService {
      * </pre>
      *
      * @param plaintextPassword the raw password as 'byte-backed' object (String, character array, {@link ByteSource},
-     *                          etc) usually acquired from your application's 'new user' or 'password reset' workflow.
+     *                          etc.) usually acquired from your application's 'new user' or 'password reset' workflow.
      * @return the encrypted password, formatted for storage.
      * @throws IllegalArgumentException if the argument cannot be easily converted to bytes as defined by
      *                                  {@link ByteSource.Util#isCompatible(Object)}.

File: core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
Patch:
@@ -210,7 +210,7 @@ protected AuthenticationInfo doMultiRealmAuthentication(Collection<Realm> realms
             try {
                 aggregate = strategy.beforeAttempt(realm, token, aggregate);
             } catch (ShortCircuitIterationException shortCircuitSignal) {
-                // Break from continuing with subsequnet realms on receiving 
+                // Break from continuing with subsequent realms on receiving 
                 // short circuit signal from strategy
                 break;
             }

File: core/src/main/java/org/apache/shiro/authc/pam/package-info.java
Patch:
@@ -26,7 +26,7 @@
  * one or more Realm instances.
  * <p/>
  * How the <code>ModularRealmAuthenticator</code> actually coordinates this behavior is configurable based on your
- * application's needs using an injectible
+ * application's needs using an injectable
  * {@link AuthenticationStrategy}.
  */
 package org.apache.shiro.authc.pam;

File: core/src/main/java/org/apache/shiro/authz/AuthorizationInfo.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Collection;
 
 /**
- * <code>AuthorizationInfo</code> represents a single Subject's stored authorization data (roles, permissions, etc)
+ * <code>AuthorizationInfo</code> represents a single Subject's stored authorization data (roles, permissions, etc.)
  * used during authorization (access control) checks only.
  * <p/>
  * Roles are represented as a <code>Collection</code> of Strings
@@ -40,7 +40,7 @@
  * <p/>
  * Because the act of authorization (access control) is orthogonal to authentication (log-in), this interface is
  * intended to represent only the account data needed by Shiro during an access control check
- * (role, permission, etc).  Shiro also has a parallel
+ * (role, permission, etc.).  Shiro also has a parallel
  * {@link org.apache.shiro.authc.AuthenticationInfo AuthenticationInfo} interface for use during the authentication
  * process that represents identity data such as principals and credentials.
  * <p/>

File: core/src/main/java/org/apache/shiro/authz/Permission.java
Patch:
@@ -36,7 +36,7 @@
  * <em>permissions</em> are assigned to these roles.
  * <p/>
  * Under this paradigm, permissions are immutable and reflect an application's raw functionality
- * (opening files, accessing a web URL, creating users, etc).  This is what allows a system's security policy
+ * (opening files, accessing a web URL, creating users, etc.).  This is what allows a system's security policy
  * to be dynamic: because Permissions represent raw functionality and only change when the application's
  * source code changes, they are immutable at runtime - they represent 'what' the system can do.  Roles, users, and
  * groups are the 'who' of the application.  Determining 'who' can do 'what' then becomes a simple exercise of
@@ -46,7 +46,7 @@
  * Permissions) and then associate users with roles (i.e. a user 'has a' collection of roles) so that by transitive
  * association, the user 'has' the permissions in their roles.  There are numerous variations on this theme
  * (permissions assigned directly to users, or assigned to groups, and users added to groups and these groups in turn
- * have roles, etc, etc).  When employing a permission-based security model instead of a role-based one, users, roles,
+ * have roles, etc., etc.).  When employing a permission-based security model instead of a role-based one, users, roles,
  * and groups can all be created, configured and/or deleted at runtime.  This enables  an extremely powerful security
  * model.
  * <p/>

File: core/src/main/java/org/apache/shiro/authz/UnauthenticatedException.java
Patch:
@@ -23,7 +23,7 @@
  * authentication hasn't yet occurred.
  *
  * <p>Authorizations can only be performed after a successful
- * authentication because authorization data (roles, permissions, etc) must always be associated
+ * authentication because authorization data (roles, permissions, etc.) must always be associated
  * with a known identity.  Such a known identity can only be obtained upon a successful log-in.
  *
  * @since 0.1

File: core/src/main/java/org/apache/shiro/authz/aop/PermissionAnnotationMethodInterceptor.java
Patch:
@@ -53,7 +53,7 @@ public PermissionAnnotationMethodInterceptor(AnnotationResolver resolver) {
      * @param methodArgs the <code>MethodInvocation</code> method arguments.
      * @param namePath the Annotation 'name' value, which is a string-based permission definition.
      * @return the String permission representation.
-     * @throws Exception if there is an error infering the target.
+     * @throws Exception if there is an error inferring the target.
      *
     protected String inferTargetFromPath(Object[] methodArgs, String namePath) throws Exception {
         int propertyStartIndex = -1;

File: core/src/main/java/org/apache/shiro/authz/permission/PermissionResolver.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.shiro.authz.Permission;
 
 /**
- * A {@code PermisisonResolver} resolves a String value and converts it into a
+ * A {@code PermissionResolver} resolves a String value and converts it into a
  * {@link org.apache.shiro.authz.Permission Permission} instance.
  * <p/>
  * The default {@link WildcardPermissionResolver} should be

File: core/src/main/java/org/apache/shiro/authz/permission/WildcardPermissionResolver.java
Patch:
@@ -31,7 +31,7 @@ public class WildcardPermissionResolver implements PermissionResolver {
     boolean caseSensitive;
     
     /**
-     * Constructor to specify case sensitivity for the resolved premissions.
+     * Constructor to specify case sensitivity for the resolved permissions.
      * @param caseSensitive true if permissions should be case sensitive.
      */
     public WildcardPermissionResolver(boolean caseSensitive) {

File: core/src/main/java/org/apache/shiro/ldap/UnsupportedAuthenticationMechanismException.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Exception thrown when a configured LDAP
  * <a href="http://download.oracle.com/javase/jndi/tutorial/ldap/security/auth.html">
- * Authentication Mechanism</a> is unsupported by the target LDAP server. (e.g. DIGEST-MD5, simple, etc)
+ * Authentication Mechanism</a> is unsupported by the target LDAP server. (e.g. DIGEST-MD5, simple, etc.)
  *
  * @since 1.2
  */

File: core/src/main/java/org/apache/shiro/mgt/AuthenticatingSecurityManager.java
Patch:
@@ -33,7 +33,7 @@
  * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'
  * <tt>Authenticator</tt> instance.
  *
- * <p>All other <tt>SecurityManager</tt> (authorization, session, etc) methods are left to be implemented by subclasses.
+ * <p>All other <tt>SecurityManager</tt> (authorization, session, etc.) methods are left to be implemented by subclasses.
  *
  * <p>In keeping with the other classes in this hierarchy and Shiro's desire to minimize configuration whenever
  * possible, suitable default instances for all dependencies are created upon instantiation.

File: core/src/main/java/org/apache/shiro/realm/AuthenticatingRealm.java
Patch:
@@ -216,7 +216,7 @@ public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) {
      * <p/>
      * <p>The default value is <tt>{@link org.apache.shiro.authc.UsernamePasswordToken UsernamePasswordToken.class}</tt>, since
      * about 90% of realms use username/password authentication, regardless of their protocol (e.g. over jdbc, ldap,
-     * kerberos, http, etc).
+     * kerberos, http, etc.).
      * <p/>
      * <p>If subclasses haven't already overridden the {@link Realm#supports Realm.supports(AuthenticationToken)} method,
      * they must {@link #setAuthenticationTokenClass(Class) set a new class} if they won't support
@@ -695,7 +695,7 @@ protected void clearCachedAuthenticationInfo(PrincipalCollection principals) {
     }
 
     /**
-     * Retrieves authentication data from an implementation-specific datasource (RDBMS, LDAP, etc) for the given
+     * Retrieves authentication data from an implementation-specific datasource (RDBMS, LDAP, etc.) for the given
      * authentication token.
      * <p/>
      * For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing

File: core/src/main/java/org/apache/shiro/realm/Realm.java
Patch:
@@ -28,7 +28,7 @@
  *
  * <p><tt>Realm</tt>s usually have a 1-to-1 correspondence with a datasource such as a relational database,
  * file system, or other similar resource.  As such, implementations of this interface use datasource-specific APIs to
- * determine authorization data (roles, permissions, etc), such as JDBC, File IO, Hibernate or JPA, or any other
+ * determine authorization data (roles, permissions, etc.), such as JDBC, File IO, Hibernate or JPA, or any other
  * Data Access API.  They are essentially security-specific
  * <a href="http://en.wikipedia.org/wiki/Data_Access_Object" target="_blank">DAO</a>s.
  *
@@ -51,7 +51,7 @@
  * practically any application environment.
  *
  * <p>Most users will not implement the <tt>Realm</tt> interface directly, but will extend one of the subclasses,
- * {@link org.apache.shiro.realm.AuthenticatingRealm AuthenticatingRealm} or {@link org.apache.shiro.realm.AuthorizingRealm}, greatly reducing the effort requird
+ * {@link org.apache.shiro.realm.AuthenticatingRealm AuthenticatingRealm} or {@link org.apache.shiro.realm.AuthorizingRealm}, greatly reducing the effort required
  * to implement a <tt>Realm</tt> from scratch.</p>
  *
  * @see org.apache.shiro.realm.CachingRealm CachingRealm

File: core/src/main/java/org/apache/shiro/realm/jdbc/JdbcRealm.java
Patch:
@@ -206,7 +206,7 @@ public void setSaltStyle(SaltStyle saltStyle) {
 
     /**
      * Makes it possible to switch off base64 encoding of password salt.
-     * The default value is true, ie. expect the salt from a string
+     * The default value is true, i.e. expect the salt from a string
      * value in a database to be base64 encoded.
      *
      * @param saltIsBase64Encoded the saltIsBase64Encoded to set

File: core/src/main/java/org/apache/shiro/realm/jndi/JndiRealmFactory.java
Patch:
@@ -58,7 +58,7 @@ public Collection<String> getJndiNames() {
      * <p/>
      * The order of the collection determines the order that the Realms will be returned to the SecurityManager.
      * <p/>
-     * If you find it easier to specify these names as a comma-delmited string, you may use the
+     * If you find it easier to specify these names as a comma-delimited string, you may use the
      * {@link #setJndiNames(String)} method instead.
      *
      * @param jndiNames the JNDI names that will be used to look up Realm(s) from JNDI.

File: core/src/main/java/org/apache/shiro/realm/ldap/DefaultLdapRealm.java
Patch:
@@ -96,7 +96,7 @@ public class DefaultLdapRealm extends AuthorizingRealm {
     ============================================*/
     /**
      * The LdapContextFactory instance used to acquire {@link javax.naming.ldap.LdapContext LdapContext}'s at runtime
-     * to acquire connections to the LDAP directory to perform authentication attempts and authorizatino queries.
+     * to acquire connections to the LDAP directory to perform authentication attempts and authorization queries.
      */
     private LdapContextFactory contextFactory;
 

File: core/src/main/java/org/apache/shiro/realm/ldap/JndiLdapContextFactory.java
Patch:
@@ -421,15 +421,15 @@ protected boolean isPoolingConnections(Object principal) {
 
     /**
      * This implementation returns an LdapContext based on the configured JNDI/LDAP environment configuration.
-     * The environnmet (Map) used at runtime is created by merging the default/configured
+     * The environment (Map) used at runtime is created by merging the default/configured
      * {@link #getEnvironment() environment template} with some runtime values as necessary (e.g. a principal and
      * credential available at runtime only).
      * <p/>
      * After the merged Map instance is created, the LdapContext connection is
      * {@link #createLdapContext(java.util.Hashtable) created} and returned.
      *
      * @param principal   the principal to use when acquiring a connection to the LDAP directory
-     * @param credentials the credentials (password, X.509 certificate, etc) to use when acquiring a connection to the
+     * @param credentials the credentials (password, X.509 certificate, etc.) to use when acquiring a connection to the
      *                    LDAP directory
      * @return the acquired {@code LdapContext} connection bound using the specified principal and credentials.
      * @throws NamingException

File: core/src/main/java/org/apache/shiro/realm/ldap/LdapContextFactory.java
Patch:
@@ -52,7 +52,7 @@ public interface LdapContextFactory {
      * {@code X.509} certificate.
      *
      * @param principal   the principal to use when acquiring a connection to the LDAP directory
-     * @param credentials the credentials (password, X.509 certificate, etc) to use when acquiring a connection to the
+     * @param credentials the credentials (password, X.509 certificate, etc.) to use when acquiring a connection to the
      *                    LDAP directory
      * @return the acquired {@code LdapContext} connection bound using the specified principal and credentials.
      * @throws NamingException if unable to acquire a connection.

File: core/src/main/java/org/apache/shiro/realm/text/IniRealm.java
Patch:
@@ -58,7 +58,7 @@ public IniRealm() {
 
     /**
      * This constructor will immediately process the definitions in the {@code Ini} argument.  If you need to perform
-     * additional configuration before processing (e.g. setting a permissionResolver, etc), do not call this
+     * additional configuration before processing (e.g. setting a permissionResolver, etc.), do not call this
      * constructor.  Instead, do the following:
      * <ol>
      * <li>Call the default no-arg constructor</li>
@@ -77,7 +77,7 @@ public IniRealm(Ini ini) {
     /**
      * This constructor will immediately process the definitions in the {@code Ini} resolved from the specified
      * {@code resourcePath}.  If you need to perform additional configuration before processing (e.g. setting a
-     * permissionResolver, etc), do not call this constructor.  Instead, do the following:
+     * permissionResolver, etc.), do not call this constructor.  Instead, do the following:
      * <ol>
      * <li>Call the default no-arg constructor</li>
      * <li>Set the Ini instance you wish to use via {@code #setIni}</li>

File: core/src/main/java/org/apache/shiro/session/Session.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * A {@code Session} is a stateful data context associated with a single Subject (user, daemon process,
- * etc) who interacts with a software system over a period of time.
+ * etc.) who interacts with a software system over a period of time.
  * <p/>
  * A {@code Session} is intended to be managed by the business tier and accessible via other
  * tiers without being tied to any given client technology.  This is a <em>great</em> benefit to Java
@@ -149,7 +149,7 @@ public interface Session {
      * It is common for a {@code Subject} implementation to retain authentication state in the
      * {@code Session}.  If the session
      * is explicitly stopped by application code by calling this method directly, it could clear out any
-     * authentication state that might exist, thereby effectively &quot;unauthenticating&quot; the {@code Subject}.
+     * authentication state that might exist, thereby effectively removing the &quot;authenticated&quot; state of the {@code Subject}.
      * <p/>
      * As such, you might consider {@link org.apache.shiro.subject.Subject#logout logging-out} the 'owning'
      * {@code Subject} instead of manually calling this method, as a log out is expected to stop the

File: core/src/main/java/org/apache/shiro/session/mgt/DefaultSessionManager.java
Patch:
@@ -101,7 +101,7 @@ public void setSessionFactory(SessionFactory sessionFactory) {
      * This property is provided because some systems need the ability to perform querying/reporting against sessions in
      * the data store, even after they have stopped or expired.  Setting this attribute to {@code false} will allow
      * such querying, but with the caveat that the application developer/configurer deletes the sessions themselves by
-     * some other means (cron, quartz, etc).
+     * some other means (cron, quartz, etc.).
      *
      * @return {@code true} if sessions should be automatically deleted after they are discovered to be invalid,
      *         {@code false} if invalid sessions will be manually deleted by some process external to Shiro's control.
@@ -116,7 +116,7 @@ public boolean isDeleteInvalidSessions() {
      * value is {@code true} to ensure no orphans will exist in the underlying data store.
      * <h4>WARNING</h4>
      * Only set this value to {@code false} if you are manually going to delete sessions yourself by some process
-     * (quartz, cron, etc) external to Shiro's control.  See the
+     * (quartz, cron, etc.) external to Shiro's control.  See the
      * {@link #isDeleteInvalidSessions() isDeleteInvalidSessions()} JavaDoc for more.
      *
      * @param deleteInvalidSessions whether or not sessions should be automatically deleted after they are discovered

File: core/src/main/java/org/apache/shiro/session/mgt/eis/CachingSessionDAO.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * An CachingSessionDAO is a SessionDAO that provides a transparent caching layer between the components that
  * use it and the underlying EIS (Enterprise Information System) session backing store (for example, filesystem,
- * database, enterprise grid/cloud, etc).
+ * database, enterprise grid/cloud, etc.).
  * <p/>
  * This implementation caches all active sessions in a configured
  * {@link #getActiveSessionsCache() activeSessionsCache}.  This property is {@code null} by default and if one is
@@ -41,7 +41,7 @@
  * <p/>
  * All {@code SessionDAO} methods are implemented by this class to employ
  * caching behavior and delegates the actual EIS operations to respective do* methods to be implemented by
- * subclasses (doCreate, doRead, etc).
+ * subclasses (doCreate, doRead, etc.).
  *
  * @since 0.2
  */

File: core/src/main/java/org/apache/shiro/session/mgt/eis/MemorySessionDAO.java
Patch:
@@ -43,7 +43,7 @@
  * <p/>
  * In this case, it is recommended to instead use a custom
  * {@link CachingSessionDAO} implementation that communicates with a higher-capacity data store of your choice
- * (file system, database, etc).
+ * (file system, database, etc.).
  * <h2>Changes in 1.0</h2>
  * This implementation prior to 1.0 used to subclass the {@link CachingSessionDAO}, but this caused problems with many
  * cache implementations that would expunge entries due to TTL settings, resulting in Sessions that would be randomly

File: core/src/main/java/org/apache/shiro/session/mgt/eis/SessionDAO.java
Patch:
@@ -31,7 +31,7 @@
  * {@link #create}, {@link #readSession(java.io.Serializable)}, {@link #update(org.apache.shiro.session.Session)},
  * and {@link #delete(org.apache.shiro.session.Session)}.
  * <p/>
- * The remaining {@link #getActiveSessions()} method exists as a support mechanism to pre-emptively orphaned sessions,
+ * The remaining {@link #getActiveSessions()} method exists as a support mechanism to preemptively orphaned sessions,
  * typically by {@link org.apache.shiro.session.mgt.ValidatingSessionManager ValidatingSessionManager}s), and should
  * be as efficient as possible, especially if there are thousands of active sessions.  Large scale/high performance
  * implementations will often return a subset of the total active sessions and perform validation a little more
@@ -43,7 +43,7 @@ public interface SessionDAO {
 
     /**
      * Inserts a new Session record into the underling EIS (e.g. Relational database, file system, persistent cache,
-     * etc, depending on the DAO implementation).
+     * etc., depending on the DAO implementation).
      * <p/>
      * After this method is invoked, the {@link org.apache.shiro.session.Session#getId()}
      * method executed on the argument must return a valid session identifier.  That is, the following should

File: core/src/main/java/org/apache/shiro/subject/Subject.java
Patch:
@@ -97,7 +97,7 @@ public interface Subject {
      * <p/>
      * The word &quot;principals&quot; is nothing more than a fancy security term for identifying attributes associated
      * with a Subject, aka, application user.  For example, user id, a surname (family/last name), given (first) name,
-     * social security number, nickname, username, etc, are all examples of a principal.
+     * social security number, nickname, username, etc., are all examples of a principal.
      *
      * @return all of this Subject's principals (identifying attributes).
      * @see #getPrincipal()
@@ -432,7 +432,7 @@ public interface Subject {
      * <h3>Web Environment Warning</h3>
      * Calling this method in web environments will usually remove any associated session cookie as part of
      * session invalidation.  Because cookies are part of the HTTP header, and headers can only be set before the
-     * response body (html, image, etc) is sent, this method in web environments must be called before <em>any</em>
+     * response body (html, image, etc.) is sent, this method in web environments must be called before <em>any</em>
      * content has been rendered.
      * <p/>
      * The typical approach most applications use in this scenario is to redirect the user to a different
@@ -670,7 +670,7 @@ protected SubjectContext getSubjectContext() {
          * specified {@code sessionId}.
          * <p/>
          * Usually when specifying a {@code sessionId}, no other {@code Builder} methods would be specified because
-         * everything else (principals, inet address, etc) can usually be reconstructed based on the referenced
+         * everything else (principals, inet address, etc.) can usually be reconstructed based on the referenced
          * session alone.  In other words, this is almost always sufficient:
          * <pre>
          * new Subject.Builder().sessionId(sessionId).buildSubject();</pre>

File: core/src/main/java/org/apache/shiro/subject/support/DelegatingSubject.java
Patch:
@@ -55,7 +55,7 @@
  * architecture.  It instead asks the underlying {@code SecurityManager} every time to perform
  * the authorization check.
  * <p/>
- * A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would
+ * A common misconception in using this implementation is that an EIS resource (RDBMS, etc.) would
  * be &quot;hit&quot; every time a method is called.  This is not necessarily the case and is
  * up to the implementation of the underlying {@code SecurityManager} instance.  If caching of authorization
  * data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered

File: core/src/test/java/org/apache/shiro/authz/ModularRealmAuthorizerTest.java
Patch:
@@ -83,7 +83,7 @@ public Collection<Permission> resolvePermissionsInRole( String roleString )
         assertTrue( ((AuthorizingRealm) mockRealm).getRolePermissionResolver() == rolePermissionResolver );
         
         
-        // TODO: no way to unset them, not sure if that is a valid use case, but this is conistent with the PermissionResolver logic
+        // TODO: no way to unset them, not sure if that is a valid use case, but this is consistent with the PermissionResolver logic
 //        // now just to be sure, unset them
 //        modRealmAuthz.setRolePermissionResolver( null );
 //        for ( Realm realm : realms )

File: core/src/test/java/org/apache/shiro/realm/activedirectory/ActiveDirectoryRealmTest.java
Patch:
@@ -47,7 +47,7 @@
  * Simple test case for ActiveDirectoryRealm.
  * <p/>
  * todo:  While the original incarnation of this test case does not actually test the
- * heart of ActiveDirectoryRealm (no meaningful implemenation of queryForLdapAccount, etc) it obviously should.
+ * heart of ActiveDirectoryRealm (no meaningful implementation of queryForLdapAccount, etc.) it obviously should.
  * This version was intended to mimic my current usage scenario in an effort to debug upgrade issues which were not related
  * to LDAP connectivity.
  *

File: core/src/test/java/org/apache/shiro/realm/text/TextConfigurationRealmTest.java
Patch:
@@ -35,7 +35,7 @@ public class TextConfigurationRealmTest {
     private void setRoles() {
         StringBuilder roleDefinitions = new StringBuilder()
                 .append("role1 = role1_permission1\n")
-                .append("role2 = role2_persission1, role2_permission2\n");
+                .append("role2 = role2_permission1, role2_permission2\n");
         realm.setRoleDefinitions(roleDefinitions.toString());
     }
 

File: core/src/test/java/org/apache/shiro/subject/DelegatingSubjectTest.java
Patch:
@@ -232,8 +232,8 @@ public void testToString() {
 
         // then
         final Session session = sourceSubject.getSession(true);
-        String sesionId = (String) session.getId();
-        assertFalse("toString must not leak sessionId", subjectToString.contains(sesionId));
+        String sessionId = (String) session.getId();
+        assertFalse("toString must not leak sessionId", subjectToString.contains(sessionId));
         assertFalse("toString must not leak host", subjectToString.contains(hostname));
     }
 

File: core/src/test/java/org/apache/shiro/util/AntPathMatcherTests.java
Patch:
@@ -215,7 +215,7 @@ public void matchStart() {
     }
 
     @Test
-    public void uniqueDeliminator() {
+    public void uniqueDelimiter() {
         pathMatcher.setPathSeparator(".");
 
         // test exact matching

File: crypto/cipher/src/main/java/org/apache/shiro/crypto/cipher/DefaultBlockCipherService.java
Patch:
@@ -95,7 +95,7 @@
  * <p/>
  * You may set a padding scheme via the {@link #setPaddingScheme(PaddingScheme) paddingScheme} attribute, which
  * accepts a type-safe {@link PaddingScheme PaddingScheme} enum instance.  Like the {@link OperationMode} enum,
- * this enum offers type safety to help avoid typos and guarantees that the mode will be recongized by the underlying
+ * this enum offers type safety to help avoid typos and guarantees that the mode will be recognized by the underlying
  * JCA provider.
  * <p/>
  * <b>*</b>If no padding scheme is specified, this class defaults to the {@link PaddingScheme#PKCS5} scheme, specifically

File: crypto/cipher/src/main/java/org/apache/shiro/crypto/cipher/JcaCipherService.java
Patch:
@@ -136,7 +136,7 @@ protected JcaCipherService(String algorithmName) {
 
     /**
      * Returns the cipher algorithm name that will be used for all encryption, decryption, and key operations (for
-     * example, 'AES', 'Blowfish', 'RSA', 'DSA', 'TripleDES', etc).
+     * example, 'AES', 'Blowfish', 'RSA', 'DSA', 'TripleDES', etc.).
      *
      * @return the cipher algorithm name that will be used for all encryption, decryption, and key operations
      */
@@ -399,7 +399,7 @@ private ByteSource decryptInternal(byte[] ciphertext, byte[] key, byte[] iv) thr
     /**
      * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations.  The
      * Cipher's {@code transformationString} for the {@code Cipher}.{@link javax.crypto.Cipher#getInstance getInstance}
-     * call is obtaind via the {@link #getTransformationString(boolean) getTransformationString} method.
+     * call is obtained via the {@link #getTransformationString(boolean) getTransformationString} method.
      *
      * @param streaming {@code true} if the cipher instance will be used as a stream cipher, {@code false} if it will be
      *                  used as a block cipher.
@@ -454,7 +454,7 @@ private byte[] crypt(byte[] bytes, byte[] key, byte[] iv, int mode) throws Illeg
      * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that
      * might arise in an {@link CryptoException}
      *
-     * @param cipher the JDK Cipher to finalize (perform the actual cryption)
+     * @param cipher the JDK Cipher to finalize (perform the actual encryption)
      * @param bytes  the bytes to crypt
      * @return the resulting crypted byte array.
      * @throws CryptoException if there is an illegal block size or bad padding

File: crypto/cipher/src/main/java/org/apache/shiro/crypto/cipher/OperationMode.java
Patch:
@@ -78,7 +78,7 @@ public enum OperationMode {
     CTR,
 
     /**
-     * <a href="http://en.wikipedia.org/wiki/EAX_mode">EAX Mode</a><b>*</b>.  This is a patent-free but less-effecient
+     * <a href="http://en.wikipedia.org/wiki/EAX_mode">EAX Mode</a><b>*</b>.  This is a patent-free but less-efficient
      * alternative to {@link #OCB OCB} and has capabilities beyond what {@link #CCM CCM} can provide.
      * <p/>
      * <b>*THIS IS A NON-STANDARD MODE</b>. It is not guaranteed to be supported across JDK installations.  You must

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/HashService.java
Patch:
@@ -40,7 +40,7 @@
  * save(hash);
  * </pre>
  * In this example, often only the input source will change during runtime, while the hashing strategy (how salts
- * are generated or acquired, how many hash iterations will be performed, etc) usually remain consistent.  A HashService
+ * are generated or acquired, how many hash iterations will be performed, etc.) usually remain consistent.  A HashService
  * internalizes this logic so the above becomes simply this:
  * <pre>
  * HashRequest request = new HashRequest.Builder().source(source).build();

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/SimpleHash.java
Patch:
@@ -37,7 +37,7 @@
 /**
  * A {@code Hash} implementation that allows any {@link java.security.MessageDigest MessageDigest} algorithm name to
  * be used.  This class is a less type-safe variant than the other {@code AbstractHash} subclasses
- * (e.g. {@link Sha512Hash}, etc), but it does allow for any algorithm name to be specified in case the other subclass
+ * (e.g. {@link Sha512Hash}, etc.), but it does allow for any algorithm name to be specified in case the other subclass
  * implementations do not represent an algorithm that you may want to use.
  * <p/>
  * As of Shiro 1.1, this class effectively replaces the (now-deprecated) {@link AbstractHash} class.  It subclasses

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/format/Base64Format.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * {@code HashFormat} that outputs <em>only</em> the hash's digest bytes in Base64 format.  It does not print out
- * anything else (salt, iterations, etc).  This implementation is mostly provided as a convenience for
+ * anything else (salt, iterations, etc.).  This implementation is mostly provided as a convenience for
  * command-line hashing.
  *
  * @since 1.2

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/format/HexFormat.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * {@code HashFormat} that outputs <em>only</em> The hash's digest bytes in hex format.  It does not print out
- * anything else (salt, iterations, etc).  This implementation is mostly provided as a convenience for
+ * anything else (salt, iterations, etc.).  This implementation is mostly provided as a convenience for
  * command-line hashing.
  *
  * @since 1.2

File: event/src/main/java/org/apache/shiro/event/support/EventListener.java
Patch:
@@ -27,7 +27,7 @@
  * {@link org.apache.shiro.event.Subscribe Subscribe} annotation on methods they wish to receive events.
  * <p/>
  * This interface therefore mainly represents a 'middle man' between the event bus and the actual subscribing
- * component.  As such, event bus implementors (or framework/infrastructural implementors) or those that wish to
+ * component.  As such, event bus implementers (or framework/infrastructural implementers) or those that wish to
  * customize listener/dispatch functionality might find this concept useful.
  * <p/>
  * It is a concept almost always used in conjunction with a {@link EventListenerResolver} implementation.

File: integration-tests/guice3/src/test/java/org/apache/shiro/samples/guice/ContainerIntegrationIT.java
Patch:
@@ -55,7 +55,7 @@ public void logIn() throws FailingHttpStatusCodeException, MalformedURLException
         form.<HtmlInput>getInputByName("username").setValueAttribute("root");
         form.<HtmlInput>getInputByName("password").setValueAttribute("secret");
         page = form.<HtmlInput>getInputByName("submit").click();
-        // This'll throw an expection if not logged in
+        // This'll throw an exception if not logged in
         page.getAnchorByHref("/logout");
     }
 

File: integration-tests/guice4/src/test/java/org/apache/shiro/samples/guice/ContainerIntegrationIT.java
Patch:
@@ -55,7 +55,7 @@ public void logIn() throws FailingHttpStatusCodeException, MalformedURLException
         form.<HtmlInput>getInputByName("username").setValueAttribute("root");
         form.<HtmlInput>getInputByName("password").setValueAttribute("secret");
         page = form.<HtmlInput>getInputByName("submit").click();
-        // This'll throw an expection if not logged in
+        // This'll throw an exception if not logged in
         page.getAnchorByHref("/logout");
     }
 

File: lang/src/main/java/org/apache/shiro/lang/io/ClassResolvingObjectInputStream.java
Patch:
@@ -27,7 +27,7 @@
 import java.io.ObjectStreamClass;
 
 /**
- * Enables correct ClassLoader lookup in various environments (e.g. JEE Servers, etc).
+ * Enables correct ClassLoader lookup in various environments (e.g. JEE Servers, etc.).
  *
  * @since 1.2
  * @see <a href="https://issues.apache.org/jira/browse/SHIRO-334">SHIRO-334</a>

File: lang/src/main/java/org/apache/shiro/lang/util/Assert.java
Patch:
@@ -35,7 +35,7 @@
  * <p>Typically used to validate method arguments rather than configuration
  * properties, to check for cases that are usually programmer errors rather than
  * configuration errors. In contrast to config initialization code, there is
- * usally no point in falling back to defaults in such methods.
+ * usually no point in falling back to defaults in such methods.
  *
  * <p>This class is similar to JUnit's assertion library. If an argument value is
  * deemed invalid, an {@link IllegalArgumentException} is thrown (typically).

File: lang/src/main/java/org/apache/shiro/lang/util/SoftHashMap.java
Patch:
@@ -87,7 +87,7 @@ public SoftHashMap() {
      * Creates a new SoftHashMap with the specified retention size.
      * <p/>
      * The retention size (n) is the total number of most recent entries in the map that will be strongly referenced
-     * (ie 'retained') to prevent them from being eagerly garbage collected.  That is, the point of a SoftHashMap is to
+     * (i.e.'retained') to prevent them from being eagerly garbage collected.  That is, the point of a SoftHashMap is to
      * allow the garbage collector to remove as many entries from this map as it desires, but there will always be (n)
      * elements retained after a GC due to the strong references.
      * <p/>
@@ -124,7 +124,7 @@ public SoftHashMap(Map<K, V> source) {
      * Creates a {@code SoftHashMap} backed by the specified {@code source}, with the specified retention size.
      * <p/>
      * The retention size (n) is the total number of most recent entries in the map that will be strongly referenced
-     * (ie 'retained') to prevent them from being eagerly garbage collected.  That is, the point of a SoftHashMap is to
+     * (i.e.'retained') to prevent them from being eagerly garbage collected.  That is, the point of a SoftHashMap is to
      * allow the garbage collector to remove as many entries from this map as it desires, but there will always be (n)
      * elements retained after a GC due to the strong references.
      * <p/>

File: samples/guice/src/test/java/org/apache/shiro/samples/guice/ContainerIntegrationIT.java
Patch:
@@ -54,7 +54,7 @@ public void logIn() throws FailingHttpStatusCodeException, MalformedURLException
         form.<HtmlInput>getInputByName("username").setValueAttribute("root");
         form.<HtmlInput>getInputByName("password").setValueAttribute("secret");
         page = form.<HtmlInput>getInputByName("submit").click();
-        // This'll throw an expection if not logged in
+        // This'll throw an exception if not logged in
         page.getAnchorByHref("/logout");
     }
 

File: samples/servlet-plugin/src/test/java/org/apache/shiro/test/ContainerIntegrationIT.java
Patch:
@@ -52,7 +52,7 @@ public void logIn() throws FailingHttpStatusCodeException, MalformedURLException
         form.<HtmlInput>getInputByName("username").setValueAttribute("root");
         form.<HtmlInput>getInputByName("password").setValueAttribute("secret");
         page = form.<HtmlInput>getInputByName("submit").click();
-        // This'll throw an expection if not logged in
+        // This'll throw an exception if not logged in
         page.getAnchorByHref("/logout");
     }
 }

File: samples/spring-hibernate/src/test/java/org/apache/shiro/samples/ContainerIntegrationIT.java
Patch:
@@ -56,7 +56,7 @@ public void logIn() throws FailingHttpStatusCodeException, IOException, Interrup
         form.<HtmlInput>getInputByName("username").setValueAttribute("admin");
         form.<HtmlInput>getInputByName("password").setValueAttribute("admin");
         page = form.<HtmlInput>getInputByValue("Login").click();
-        // This'll throw an expection if not logged in
+        // This'll throw an exception if not logged in
         page.getAnchorByHref("/s/logout");
     }
 }

File: samples/spring-mvc/src/main/java/org/apache/shiro/samples/spring/BootstrapDataPopulator.java
Patch:
@@ -73,7 +73,7 @@ public void afterPropertiesSet() throws Exception {
         jdbcTemplate.execute(CREATE_TABLES);
 
         //password is 'user1' SHA hashed and base64 encoded:
-        //The first argument to the hash constructor is the actual value to be hased.  The 2nd is the
+        //The first argument to the hash constructor is the actual value to be hashed.  The 2nd is the
         //salt.  In this simple demo scenario, the username and the password are the same, but to clarify the
         //distinction, you would see this in practice:
         //new Sha256Hash( <password>, <cryptographically strong randomly generated salt> (not the username!) )

File: samples/spring-mvc/src/main/java/org/apache/shiro/samples/spring/config/ApplicationConfig.java
Patch:
@@ -74,7 +74,7 @@ protected BootstrapDataPopulator bootstrapDataPopulator(DataSource dataSource) {
 
 
     /**
-     * Used by the SecurityManager to access security data (users, roles, etc).
+     * Used by the SecurityManager to access security data (users, roles, etc.).
      * Many other realm implementations can be used too (PropertiesRealm,
      * LdapRealm, etc.
      * @param dataSource
@@ -109,7 +109,7 @@ protected EhCacheManager cacheManager() {
         EhCacheManager ehCacheManager = new EhCacheManager();
 
         // Set a net.sf.ehcache.CacheManager instance here if you already have one.
-        // If not, a new one will be creaed with a default config:
+        // If not, a new one will be created with a default config:
         // ehCacheManager.setCacheManager(...);
 
         // If you don't have a pre-built net.sf.ehcache.CacheManager instance to inject, but you want

File: samples/web/src/test/java/org/apache/shiro/test/WebAppContainerIntegrationIT.java
Patch:
@@ -55,7 +55,7 @@ public void logIn() throws FailingHttpStatusCodeException, MalformedURLException
         form.<HtmlInput>getInputByName("username").setValueAttribute("root");
         form.<HtmlInput>getInputByName("password").setValueAttribute("secret");
         page = form.<HtmlInput>getInputByName("submit").click();
-        // This'll throw an expection if not logged in
+        // This'll throw an exception if not logged in
         page.getAnchorByHref("/logout");
     }
 }

File: support/aspectj/src/main/java/org/apache/shiro/aspectj/AspectjAnnotationsAuthorizingMethodInterceptor.java
Patch:
@@ -28,8 +28,8 @@
 import java.util.Arrays;
 
 /**
- * Extends the annotations authorizing method interceptor class hierarchie to adapt
- * an aspectj {@link JoinPoint} into a {@link MethodInvocation} amd to perform the
+ * Extends the annotations authorizing method interceptor class hierarchy to adapt
+ * an aspectj {@link JoinPoint} into a {@link MethodInvocation} and to perform the
  * authorization of method invocations.
  *
  * @since 1.0
@@ -44,7 +44,7 @@ public class AspectjAnnotationsAuthorizingMethodInterceptor extends AnnotationsA
      * Performs the method interception of the before advice at the specified joint point.
      *
      * @param aJoinPoint The joint point to intercept.
-     * @throws Throwable If an error occurs berforming the method invocation.
+     * @throws Throwable If an error occurs performing the method invocation.
      */
     protected void performBeforeInterception(JoinPoint aJoinPoint) throws Throwable {
         if (log.isTraceEnabled()) log.trace("#### Invoking a method decorated with a Shiro annotation" +

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -317,7 +317,7 @@ protected static <T extends Filter> FilterConfig<T> filterConfig(Key<T> baseKey)
 
     /**
      * Builds a FilterConfig from a Filer and configuration String
-     * @param typeLiteral The TyleLiteral of the filter key to be used.
+     * @param typeLiteral The TypeLiteral of the filter key to be used.
      * @param configValue the configuration used.
      * @param <T> A Servlet Filter class.
      * @return A FilterConfig used to map a String path to this configuration.

File: support/guice/src/main/java/org/apache/shiro/guice/web/SimpleFilterChain.java
Patch:
@@ -47,7 +47,7 @@ public void doFilter(ServletRequest request, ServletResponse response) throws IO
 
     /**
      * Exposed for testing, not part of public API.
-     * @return an Iterater of filters.
+     * @return an Iterator of filters.
      */
     Iterator<? extends Filter> getFilters() {
         return chain;

File: support/guice/src/test/java/org/apache/shiro/guice/web/DefaultFiltersTest.java
Patch:
@@ -45,7 +45,7 @@ public void checkDefaultFilters() throws Exception {
                     }
                 }
                 if(!found) {
-                    fail("Guice ShiroWebModule containts a default filter that Shiro proper does not. (" + filterType.getName() + ")");
+                    fail("Guice ShiroWebModule contains a default filter that Shiro proper does not. (" + filterType.getName() + ")");
                 }
             }
         }

File: support/guice/src/test/java/org/apache/shiro/guice/web/ShiroWebModuleTest.java
Patch:
@@ -261,7 +261,7 @@ public ShiroModuleTest.MockRealm createRealm() {
     @Test
     public void testAddFilterChainGuice3Only() {
 
-        Assume.assumeTrue("This test only runs agains Guice 3.x", ShiroWebModule.isGuiceVersion3());
+        Assume.assumeTrue("This test only runs against Guice 3.x", ShiroWebModule.isGuiceVersion3());
 
         final ShiroModuleTest.MockRealm mockRealm = createMock(ShiroModuleTest.MockRealm.class);
         ServletContext servletContext = createMock(ServletContext.class);

File: support/quartz/src/main/java/org/apache/shiro/session/mgt/quartz/package-info.java
Patch:
@@ -19,6 +19,6 @@
 /**
  * <a href="http://www.opensymphony.com/quartz/" target="_top">Quartz</a>-based implementations of
  * components that help <tt>SessionManager</tt> implementations maintain sessions (timed expiration, orphan cleanup,
- * etc).
+ * etc.).
  */
 package org.apache.shiro.session.mgt.quartz;

File: support/spring/src/main/java/org/apache/shiro/spring/ShiroEventBusBeanPostProcessor.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Spring {@link BeanPostProcessor} that detects, {@link EventBusAware} and classes containing {@link Subscribe @Subscribe} methods.
  * Any classes implementing EventBusAware will have the setEventBus() method called with the <code>eventBus</code>. Any
- * classes discovered with methods that are annotated with @Subscribe will be automaticly registered with the EventBus.
+ * classes discovered with methods that are annotated with @Subscribe will be automatically registered with the EventBus.
  *
  * <p><strong>NOTE:</strong> in a Spring environment implementing EventBusAware is not necessary, as you can just inject the EventBus with
  * {@link org.springframework.beans.factory.annotation.Autowire @Autowire}.</p>

File: support/spring/src/main/java/org/apache/shiro/spring/security/interceptor/AopAllianceAnnotationsAuthorizingMethodInterceptor.java
Patch:
@@ -57,7 +57,7 @@ public AopAllianceAnnotationsAuthorizingMethodInterceptor() {
      * Creates a {@link MethodInvocation MethodInvocation} that wraps an
      * {@link org.aopalliance.intercept.MethodInvocation org.aopalliance.intercept.MethodInvocation} instance,
      * enabling Shiro Annotations in <a href="http://aopalliance.sourceforge.net/">AOP Alliance</a> environments
-     * (Spring, etc).
+     * (Spring, etc.).
      *
      * @param implSpecificMethodInvocation AOP Alliance {@link org.aopalliance.intercept.MethodInvocation MethodInvocation}
      * @return a Shiro {@link MethodInvocation MethodInvocation} instance that wraps the AOP Alliance instance.

File: tools/hasher/src/main/java/org/apache/shiro/tools/hasher/Hasher.java
Patch:
@@ -54,7 +54,7 @@
 import static java.util.Collections.emptyMap;
 
 /**
- * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc).
+ * Commandline line utility to hash data such as strings, passwords, resources (files, urls, etc.).
  * <p/>
  * Usage:
  * <pre>
@@ -174,7 +174,7 @@ public static void main(String[] args) {
                 generateSalt = true;
                 generatedSaltSize = getRequiredPositiveInt(line, SALT_GEN_SIZE);
                 if (generatedSaltSize % 8 != 0) {
-                    throw new IllegalArgumentException("Generated salt size must be a multiple of 8 (e.g. 128, 192, 256, 512, etc).");
+                    throw new IllegalArgumentException("Generated salt size must be a multiple of 8 (e.g. 128, 192, 256, 512, etc.).");
                 }
             }
             if (line.hasOption(PRIVATE_SALT.getOpt())) {

File: web/src/main/java/org/apache/shiro/web/env/EnvironmentLoader.java
Patch:
@@ -40,7 +40,7 @@
  * {@code ServletContext} at application startup.
  * <p/>
  * In Shiro 1.1 and earlier, the Shiro ServletFilter was responsible for creating the {@code WebSecurityManager} and
- * any additional objects (security filters, etc).  However, any component not filtered by the Shiro Filter (such
+ * any additional objects (security filters, etc.).  However, any component not filtered by the Shiro Filter (such
  * as other context listeners) was not able to easily acquire the these objects to perform security operations.
  * <p/>
  * Due to this, in Shiro 1.2 and later, this {@code EnvironmentLoader} (or more likely, the

File: web/src/main/java/org/apache/shiro/web/env/IniWebEnvironment.java
Patch:
@@ -324,7 +324,7 @@ protected String[] getDefaultConfigLocations() {
      */
     private Ini convertPathToIni(String path, boolean required) {
 
-        //TODO - this logic is ugly - it'd be ideal if we had a Resource API to polymorphically encaspulate this behavior
+        //TODO - this logic is ugly - it'd be ideal if we had a Resource API to polymorphically encapsulate this behavior
 
         Ini ini = null;
 
@@ -360,7 +360,7 @@ private Ini convertPathToIni(String path, boolean required) {
         return ini;
     }
 
-    //TODO - this logic is ugly - it'd be ideal if we had a Resource API to polymorphically encaspulate this behavior
+    //TODO - this logic is ugly - it'd be ideal if we had a Resource API to polymorphically encapsulate this behavior
     private InputStream getServletContextResourceStream(String path) {
         InputStream is = null;
 

File: web/src/main/java/org/apache/shiro/web/filter/PathMatchingFilter.java
Patch:
@@ -64,7 +64,7 @@ public abstract class PathMatchingFilter extends AdviceFilter implements PathCon
     protected Map<String, Object> appliedPaths = new LinkedHashMap<String, Object>();
 
     /**
-     * Splits any comma-delmited values that might be found in the <code>config</code> argument and sets the resulting
+     * Splits any comma-delimited values that might be found in the <code>config</code> argument and sets the resulting
      * <code>String[]</code> array on the <code>appliedPaths</code> internal Map.
      * <p/>
      * That is:

File: web/src/main/java/org/apache/shiro/web/filter/authc/AnonymousFilter.java
Patch:
@@ -24,7 +24,7 @@
 import javax.servlet.ServletResponse;
 
 /**
- * Filter that allows access to a path immeidately without performing security checks of any kind.
+ * Filter that allows access to a path immediately without performing security checks of any kind.
  * <p/>
  * This filter is useful primarily in exclusionary policies, where you have defined a url pattern
  * to require a certain security level, but maybe only subset of urls in that pattern should allow any access.

File: web/src/main/java/org/apache/shiro/web/filter/authc/AuthenticatingFilter.java
Patch:
@@ -99,7 +99,7 @@ protected String getHost(ServletRequest request) {
      * current <code>request</code>, <code>false</code> otherwise.
      * <p/>
      * This implementation always returns <code>false</code> and is provided as a template hook to subclasses that
-     * support <code>rememberMe</code> logins and wish to determine <code>rememberMe</code> in a custom mannner
+     * support <code>rememberMe</code> logins and wish to determine <code>rememberMe</code> in a custom manner
      * based on the current <code>request</code>.
      *
      * @param request the incoming ServletRequest

File: web/src/main/java/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.java
Patch:
@@ -47,7 +47,7 @@
  * <p>If the login attempt fails, the resulting <code>AuthenticationException</code> fully qualified class name will
  * be set as a request attribute under the {@link #setFailureKeyAttribute(String) failureKeyAttribute} key.  This
  * FQCN can be used as an i18n key or lookup mechanism to explain to the user why their login attempt failed
- * (e.g. no account, incorrect password, etc).
+ * (e.g. no account, incorrect password, etc.).
  * <p/>
  * <p>If you would prefer to handle the authentication validation and login in your own code, consider using the
  * {@link PassThruAuthenticationFilter} instead, which allows requests to the

File: web/src/main/java/org/apache/shiro/web/filter/authz/IpFilter.java
Patch:
@@ -101,7 +101,7 @@ public void setIpSource(IpSource source) {
 
     /**
      * Returns the remote host for a given HTTP request. By default uses the
-     * remote method ServletRequest.getRemoteAddr(). May be overriden by
+     * remote method ServletRequest.getRemoteAddr(). May be overridden by
      * subclasses to obtain address information from specific headers (e.g. XFF
      * or Forwarded) in situations with reverse proxies.
      */

File: web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java
Patch:
@@ -114,7 +114,7 @@ public FilterChain getChain(ServletRequest request, ServletResponse response, Fi
                 return filterChainManager.proxy(originalChain, pathPattern);
             } else {
 
-                // in spring web, the requestURI "/resource/menus" ---- "resource/menus/" bose can access the resource
+                // in spring web, the requestURI "/resource/menus" ---- "resource/menus/" both can access the resource
                 // but the pathPattern match "/resource/menus" can not match "resource/menus/"
                 // user can use requestURI + "/" to simply bypassed chain filter, to bypassed shiro protect
 
@@ -139,7 +139,7 @@ public FilterChain getChain(ServletRequest request, ServletResponse response, Fi
      * <p/>
      * Simply delegates to
      * <b><code>{@link #getPathMatcher() getPathMatcher()}.{@link org.apache.shiro.lang.util.PatternMatcher#matches(String, String) matches(pattern,path)}</code></b>.
-     * Subclass implementors should think carefully before overriding this method, as typically a custom
+     * Subclass implementers should think carefully before overriding this method, as typically a custom
      * {@code PathMatcher} should be configured for custom path matching behavior instead.  Favor OO composition
      * rather than inheritance to limit your exposure to Shiro implementation details which may change over time.
      *
@@ -159,7 +159,7 @@ protected boolean pathMatches(String pattern, String path) {
      * and can be overridden by subclasses for custom request-to-application-path resolution behavior.
      *
      * @param request the incoming {@code ServletRequest}
-     * @return the request's path within the appliation.
+     * @return the request's path within the application.
      */
     protected String getPathWithinApplication(ServletRequest request) {
         return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));

File: web/src/main/java/org/apache/shiro/web/mgt/CookieRememberMeManager.java
Patch:
@@ -40,7 +40,7 @@
  * Remembers a Subject's identity by saving the Subject's {@link Subject#getPrincipals() principals} to a {@link Cookie}
  * for later retrieval.
  * <p/>
- * Cookie attributes (path, domain, maxAge, etc) may be set on this class's default
+ * Cookie attributes (path, domain, maxAge, etc.) may be set on this class's default
  * {@link #getCookie() cookie} attribute, which acts as a template to use to set all properties of outgoing cookies
  * created by this implementation.
  * <p/>

File: web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java
Patch:
@@ -40,7 +40,7 @@
 
 /**
  * Abstract base class that provides all standard Shiro request filtering behavior and expects
- * subclasses to implement configuration-specific logic (INI, XML, .properties, etc).
+ * subclasses to implement configuration-specific logic (INI, XML, .properties, etc.).
  * <p/>
  * Subclasses should perform configuration and construction logic in an overridden
  * {@link #init()} method implementation.  That implementation should make available any constructed

File: web/src/main/java/org/apache/shiro/web/servlet/IniShiroFilter.java
Patch:
@@ -342,7 +342,7 @@ protected Ini convertPathToIni(String path) {
             ini = getServletContextIniResource(path);
             if (ini == null) {
                 String msg = "There is no servlet context resource corresponding to configPath '" + path + "'  If " +
-                        "the resource is located elsewhere (not immediately resolveable in the servlet context), " +
+                        "the resource is located elsewhere (not immediately resolvable in the servlet context), " +
                         "specify an appropriate classpath:, url:, or file: resource prefix accordingly.";
                 throw new ConfigurationException(msg);
             }

File: web/src/main/java/org/apache/shiro/web/servlet/OncePerRequestFilter.java
Patch:
@@ -37,7 +37,7 @@
  * is based on the configured name of the concrete filter instance.
  * <h3>Controlling filter execution</h3>
  * 1.2 introduced the {@link #isEnabled(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method and
- * {@link #isEnabled()} property to allow explicit controll over whether the filter executes (or allows passthrough)
+ * {@link #isEnabled()} property to allow explicit control over whether the filter executes (or allows passthrough)
  * for any given request.
  * <p/>
  * <b>NOTE</b> This class was initially borrowed from the Spring framework but has continued modifications.

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroFilter.java
Patch:
@@ -50,7 +50,7 @@
  *     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  * &lt;/filter-mapping&gt;
  * </pre>
- * Configuration options (configuration file paths, etc) are specified as part of the
+ * Configuration options (configuration file paths, etc.) are specified as part of the
  * {@code EnvironmentLoaderListener} configuration.  See the
  * {@link org.apache.shiro.web.env.EnvironmentLoader EnvironmentLoader} JavaDoc for configuration options.
  *

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroHttpServletRequest.java
Patch:
@@ -34,7 +34,7 @@
 /**
  * A {@code ShiroHttpServletRequest} wraps the Servlet container's original {@code ServletRequest} instance, but ensures
  * that all {@link HttpServletRequest} invocations that require Shiro's support ({@link #getRemoteUser getRemoteUser},
- * {@link #getSession getSession}, etc) can be executed first by Shiro as necessary before allowing the underlying
+ * {@link #getSession getSession}, etc.) can be executed first by Shiro as necessary before allowing the underlying
  * Servlet container instance's method to be invoked.
  *
  * @since 0.2

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroHttpServletResponse.java
Patch:
@@ -295,7 +295,7 @@ private boolean hasScheme(String uri) {
      *
      * @param url       URL to be encoded with the session id
      * @param sessionId Session id to be included in the encoded URL
-     * @return the url with the session identifer properly encoded.
+     * @return the url with the session identifier properly encoded.
      */
     protected String toEncoded(String url, String sessionId) {
 

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroHttpSession.java
Patch:
@@ -33,7 +33,7 @@
 /**
  * Wrapper class that uses a Shiro {@link Session Session} under the hood for all session operations instead of the
  * Servlet Container's session mechanism.  This is required in heterogeneous client environments where the Session
- * is used on both the business tier as well as in multiple client technologies (web, swing, flash, etc) since
+ * is used on both the business tier as well as in multiple client technologies (web, swing, flash, etc.) since
  * Servlet container sessions alone cannot support this feature.
  *
  * @since 0.2

File: web/src/main/java/org/apache/shiro/web/servlet/package-info.java
Patch:
@@ -17,7 +17,7 @@
  * under the License.
  */
 /**
- * Shiro-specific implementations of the Servlet API (Servlet Filters, et al).
+ * Shiro-specific implementations of the Servlet API (Servlet Filters, et al.).
  *
  * @see ShiroFilter
  */

File: web/src/main/java/org/apache/shiro/web/session/HttpServletSession.java
Patch:
@@ -33,7 +33,7 @@
 /**
  * {@link Session Session} implementation that is backed entirely by a standard servlet container
  * {@link HttpSession HttpSession} instance.  It does not interact with any of Shiro's session-related components
- * {@code SessionManager}, {@code SecurityManager}, etc, and instead satisfies all method implementations by interacting
+ * {@code SessionManager}, {@code SecurityManager}, etc., and instead satisfies all method implementations by interacting
  * with a servlet container provided {@link HttpSession HttpSession} instance.
  *
  * @since 1.0

File: web/src/main/java/org/apache/shiro/web/session/mgt/ServletContainerSessionManager.java
Patch:
@@ -44,7 +44,7 @@
  * protocol.
  * <p/>
  * Therefore, if you need {@code Session} support for heterogeneous clients (e.g. web browsers,
- * RMI clients, etc), use the {@link DefaultWebSessionManager DefaultWebSessionManager}
+ * RMI clients, etc.), use the {@link DefaultWebSessionManager DefaultWebSessionManager}
  * instead.  The {@code DefaultWebSessionManager} supports both traditional web-based access as well as non web-based
  * clients.
  *

File: web/src/main/java/org/apache/shiro/web/tags/package-info.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Provides the Shiro JSP Tag Library implementations.
  * <p/>
- * Shiro JSP Tags can be used to evalute or not evaluate (show or not show) parts of a JSP page based on the
+ * Shiro JSP Tags can be used to evaluate or not evaluate (show or not show) parts of a JSP page based on the
  * current user's authentication status and/or authorization (access control) abilities.
  */
 package org.apache.shiro.web.tags;

File: web/src/test/java/org/apache/shiro/web/config/WebIniSecurityManagerFactoryTest.java
Patch:
@@ -45,7 +45,7 @@ public class WebIniSecurityManagerFactoryTest {
     @Test
     public void testDefaultFiltersPresent() {
         Ini ini = new Ini();
-        //just a normal configuration line in the MAIN section for any of the default filtes should work
+        //just a normal configuration line in the MAIN section for any of the default filters should work
         //out of the box.  So, create the main section and just config one of them:
         Ini.Section section = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
         section.put("authc.loginUrl", "/login.jsp");

File: web/src/test/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilterTest.java
Patch:
@@ -25,7 +25,7 @@
 public class HttpMethodPermissionFilterTest {
 
     @Test
-    public void testPermisisonMapping() {
+    public void testPermissionMapping() {
         // Testing the isAccessAllowed would be easier, but would need to mock out the servlet request
 
         HttpMethodPermissionFilter filter = new HttpMethodPermissionFilter();

File: web/src/test/java/org/apache/shiro/web/servlet/ShiroHttpServletRequestTest.java
Patch:
@@ -54,7 +54,7 @@ public void setUp() throws Exception {
      * Test asserting <a href="https://issues.apache.org/jira/browse/SHIRO-637">SHIRO-637<a/>.
      */
     @Test
-    public void testRegetSession() {
+    public void testReGetSession() {
         Session session1 = mock(Session.class);
         Session session2 = mock(Session.class);
         AtomicInteger counter = new AtomicInteger();

File: web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java
Patch:
@@ -125,7 +125,7 @@ public FilterChain getChain(ServletRequest request, ServletResponse response, Fi
                         log.trace("Matched path pattern [{}] for requestURI [{}].  " +
                                   "Utilizing corresponding filter chain...", pathPattern, Encode.forHtml(requestURINoTrailingSlash));
                     }
-                    return filterChainManager.proxy(originalChain, requestURINoTrailingSlash);
+                    return filterChainManager.proxy(originalChain, pathPattern);
                 }
             }
         }

File: web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java
Patch:
@@ -125,7 +125,7 @@ public FilterChain getChain(ServletRequest request, ServletResponse response, Fi
                         log.trace("Matched path pattern [{}] for requestURI [{}].  " +
                                   "Utilizing corresponding filter chain...", pathPattern, Encode.forHtml(requestURINoTrailingSlash));
                     }
-                    return filterChainManager.proxy(originalChain, requestURINoTrailingSlash);
+                    return filterChainManager.proxy(originalChain, pathPattern);
                 }
             }
         }

File: config/ogdl/src/main/java/org/apache/shiro/config/ogdl/CommonsInterpolator.java
Patch:
@@ -35,12 +35,12 @@
  *     </tr>
  *     <tr>
  *         <td>sys</td>
- *         <td>${sys:os.name}</td>
+ *         <td>${os.name}</td>
  *         <td>mac os x</td>
  *     </tr>
  *     <tr>
  *         <td>env</td>
- *         <td>${env:EDITOR}</td>
+ *         <td>${EDITOR}</td>
  *         <td>vi</td>
  *     </tr>
  *     <tr>

File: samples/quickstart-guice/src/main/java/QuickstartGuice.java
Patch:
@@ -96,7 +96,7 @@ public static void main(String[] args) {
         }
 
         //test a typed permission (not instance-level)
-        if (currentUser.isPermitted("lightsaber:weild")) {
+        if (currentUser.isPermitted("lightsaber:wield")) {
             log.info("You may use a lightsaber ring.  Use it wisely.");
         } else {
             log.info("Sorry, lightsaber rings are for schwartz masters only.");

File: core/src/main/java/org/apache/shiro/realm/text/TextConfigurationRealm.java
Patch:
@@ -184,6 +184,7 @@ protected void processUserDefinitions(Map<String, String> userDefs) {
 
             String[] passwordAndRolesArray = StringUtils.split(value);
 
+            // the first token is expected to be the password.
             String password = passwordAndRolesArray[0];
 
             SimpleAccount account = getUser(username);

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/format/DefaultHashFormatFactory.java
Patch:
@@ -111,13 +111,14 @@ public void setSearchPackages(Set<String> searchPackages) {
         this.searchPackages = searchPackages;
     }
 
+    @Override
     public HashFormat getInstance(String in) {
         if (in == null) {
             return null;
         }
 
         HashFormat hashFormat = null;
-        Class clazz = null;
+        Class<?> clazz = null;
 
         //NOTE: this code block occurs BEFORE calling getHashFormatClass(in) on purpose as a performance
         //optimization.  If the input arg is an MCF-formatted string, there will be many unnecessary ClassLoader
@@ -128,7 +129,7 @@ public HashFormat getInstance(String in) {
             String test = in.substring(ModularCryptFormat.TOKEN_DELIMITER.length());
             String[] tokens = test.split("\\" + ModularCryptFormat.TOKEN_DELIMITER);
             //the MCF ID is always the first token in the delimited string:
-            String possibleMcfId = (tokens != null && tokens.length > 0) ? tokens[0] : null;
+            String possibleMcfId = tokens.length > 0 ? tokens[0] : null;
             if (possibleMcfId != null) {
                 //found a possible MCF ID - test it using our heuristics to see if we can find a corresponding class:
                 clazz = getHashFormatClass(possibleMcfId);

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/format/HashFormat.java
Patch:
@@ -24,13 +24,11 @@
  * A {@code HashFormat} is able to format a {@link Hash} instance into a well-defined formatted String.
  * <p/>
  * Note that not all HashFormat algorithms are reversible.  That is, they can't be parsed and reconstituted to the
- * original Hash instance.  The traditional <a href="http://en.wikipedia.org/wiki/Crypt_(Unix)">
- * Unix crypt(3)</a> is one such format.
+ * original Hash instance.
  * <p/>
  * The formats that <em>are</em> reversible however will be represented as {@link ParsableHashFormat} instances.
  *
  * @see ParsableHashFormat
- *
  * @since 1.2
  */
 public interface HashFormat {
@@ -40,6 +38,7 @@ public interface HashFormat {
      *
      * @param hash the hash instance to format into a String.
      * @return a formatted string representing the specified Hash instance.
+     * @throws NullPointerException if given parameter hash is {@code null}.
      */
     String format(Hash hash);
 }

File: samples/quickstart-guice/src/main/java/QuickstartGuice.java
Patch:
@@ -96,7 +96,7 @@ public static void main(String[] args) {
         }
 
         //test a typed permission (not instance-level)
-        if (currentUser.isPermitted("lightsaber:weild")) {
+        if (currentUser.isPermitted("lightsaber:wield")) {
             log.info("You may use a lightsaber ring.  Use it wisely.");
         } else {
             log.info("Sorry, lightsaber rings are for schwartz masters only.");

File: web/src/main/java/org/apache/shiro/web/session/HttpServletSession.java
Patch:
@@ -83,7 +83,7 @@ public long getTimeout() throws InvalidSessionException {
 
     public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {
         try {
-            int timeout = Long.valueOf(maxIdleTimeInMillis / 1000).intValue();
+            int timeout = (int) (maxIdleTimeInMillis / 1000);
             httpSession.setMaxInactiveInterval(timeout);
         } catch (Exception e) {
             throw new InvalidSessionException(e);

File: web/src/main/java/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.java
Patch:
@@ -82,9 +82,10 @@ public BasicHttpAuthenticationFilter() {
      * </ol>
      *
      * @param request  incoming ServletRequest
-     * @param response outgoing ServletResponse
+     * @param response outgoing ServletResponse (never used)
      * @return the AuthenticationToken used to execute the login attempt
      */
+    @Override
     protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) {
         String authorizationHeader = getAuthzHeader(request);
         if (authorizationHeader == null || authorizationHeader.length() == 0) {
@@ -125,6 +126,7 @@ protected AuthenticationToken createToken(ServletRequest request, ServletRespons
      * @param encoded the Base64-encoded username:password value found after the scheme in the header
      * @return the username (index 0)/password (index 1) pair obtained from the encoded header data.
      */
+    @Override
     protected String[] getPrincipalsAndCredentials(String scheme, String encoded) {
         String decoded = Base64.decodeToString(encoded);
         return decoded.split(":", 2);

File: lang/src/main/java/org/apache/shiro/lang/io/DefaultSerializer.java
Patch:
@@ -47,6 +47,7 @@ public byte[] serialize(T o) throws SerializationException {
             ObjectOutputStream oos = new ObjectOutputStream(bos);
             oos.writeObject(o);
             oos.close();
+            baos.flush();
             return baos.toByteArray();
         } catch (IOException e) {
             String msg = "Unable to serialize object [" + o + "].  " +

File: lang/src/main/java/org/apache/shiro/lang/io/DefaultSerializer.java
Patch:
@@ -47,7 +47,7 @@ public byte[] serialize(T o) throws SerializationException {
             ObjectOutputStream oos = new ObjectOutputStream(bos);
             oos.writeObject(o);
             oos.close();
-	    baos.flush();
+            baos.flush();
             return baos.toByteArray();
         } catch (IOException e) {
             String msg = "Unable to serialize object [" + o + "].  " +

File: lang/src/main/java/org/apache/shiro/lang/io/DefaultSerializer.java
Patch:
@@ -47,6 +47,7 @@ public byte[] serialize(T o) throws SerializationException {
             ObjectOutputStream oos = new ObjectOutputStream(bos);
             oos.writeObject(o);
             oos.close();
+	    baos.flush();
             return baos.toByteArray();
         } catch (IOException e) {
             String msg = "Unable to serialize object [" + o + "].  " +

File: support/spring/src/main/java/org/apache/shiro/spring/web/config/AbstractShiroWebConfiguration.java
Patch:
@@ -43,7 +43,7 @@ public class AbstractShiroWebConfiguration extends AbstractShiroConfiguration {
     @Value("#{ @environment['shiro.sessionManager.sessionIdCookieEnabled'] ?: true }")
     protected boolean sessionIdCookieEnabled;
 
-    @Value("#{ @environment['shiro.sessionManager.sessionIdUrlRewritingEnabled'] ?: true }")
+    @Value("#{ @environment['shiro.sessionManager.sessionIdUrlRewritingEnabled'] ?: false }")
     protected boolean sessionIdUrlRewritingEnabled;
 
     @Value("#{ @environment['shiro.userNativeSessionManager'] ?: false }")

File: web/src/main/java/org/apache/shiro/web/session/mgt/DefaultWebSessionManager.java
Patch:
@@ -58,7 +58,7 @@ public DefaultWebSessionManager() {
         cookie.setHttpOnly(true); //more secure, protects against XSS attacks
         this.sessionIdCookie = cookie;
         this.sessionIdCookieEnabled = true;
-        this.sessionIdUrlRewritingEnabled = true;
+        this.sessionIdUrlRewritingEnabled = false;
     }
 
     public Cookie getSessionIdCookie() {

File: web/src/main/java/org/apache/shiro/web/util/WebUtils.java
Patch:
@@ -57,6 +57,8 @@ public class WebUtils {
     public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + "_SHIRO_THREAD_CONTEXT_KEY";
     public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + "_SHIRO_THREAD_CONTEXT_KEY";
 
+    public static final String ALLOW_BACKSLASH = "org.apache.shiro.web.ALLOW_BACKSLASH";
+
     /**
      * {@link org.apache.shiro.session.Session Session} key used to save a request and later restore it, for example when redirecting to a
      * requested page after login, equal to {@code shiroSavedRequest}.
@@ -163,7 +165,7 @@ private static String valueOrEmpty(String input) {
      * @return normalized path
      */
     public static String normalize(String path) {
-        return normalize(path, true);
+        return normalize(path, Boolean.getBoolean(ALLOW_BACKSLASH));
     }
 
     /**

File: web/src/main/java/org/apache/shiro/web/servlet/SimpleCookie.java
Patch:
@@ -398,7 +398,7 @@ public void removeFrom(HttpServletRequest request, HttpServletResponse response)
         int version = getVersion();
         boolean secure = isSecure();
         boolean httpOnly = false; //no need to add the extra text, plus the value 'deleteMe' is not sensitive at all
-        SameSiteOptions sameSite = null;
+        SameSiteOptions sameSite = getSameSite();
 
         addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly, sameSite);
 

File: core/src/main/java/org/apache/shiro/realm/AuthenticatingRealm.java
Patch:
@@ -198,7 +198,7 @@ public CredentialsMatcher getCredentialsMatcher() {
     }
 
     /**
-     * Sets the CrendialsMatcher used during an authentication attempt to verify submitted credentials with those
+     * Sets the CredentialsMatcher used during an authentication attempt to verify submitted credentials with those
      * stored in the system.  The implementation of this matcher can be switched via configuration to
      * support any number of schemes, including plain text comparisons, hashing comparisons, and others.
      * <p/>

File: core/src/main/java/org/apache/shiro/realm/AuthenticatingRealm.java
Patch:
@@ -198,7 +198,7 @@ public CredentialsMatcher getCredentialsMatcher() {
     }
 
     /**
-     * Sets the CrendialsMatcher used during an authentication attempt to verify submitted credentials with those
+     * Sets the CredentialsMatcher used during an authentication attempt to verify submitted credentials with those
      * stored in the system.  The implementation of this matcher can be switched via configuration to
      * support any number of schemes, including plain text comparisons, hashing comparisons, and others.
      * <p/>

File: web/src/test/java/org/apache/shiro/web/mgt/CookieRememberMeManagerTest.java
Patch:
@@ -213,7 +213,7 @@ public void getRememberedPrincipalsDecryptionError() {
         CookieRememberMeManager mgr = new CookieRememberMeManager();
         try {
             mgr.getRememberedPrincipals(context);
-        } catch (CryptoException expected) {
+        } catch (IllegalArgumentException expected) {
             return;
         }
         fail("CryptoException was expected to be thrown");

File: web/src/test/java/org/apache/shiro/web/mgt/CookieRememberMeManagerTest.java
Patch:
@@ -211,7 +211,7 @@ public void getRememberedPrincipalsDecryptionError() {
         CookieRememberMeManager mgr = new CookieRememberMeManager();
         try {
             mgr.getRememberedPrincipals(context);
-        } catch (CryptoException expected) {
+        } catch (IllegalArgumentException expected) {
             return;
         }
         fail("CryptoException was expected to be thrown");

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.shiro.web.filter.authc.LogoutFilter;
 import org.apache.shiro.web.filter.authc.UserFilter;
 import org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;
+import org.apache.shiro.web.filter.authz.IpFilter;
 import org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;
 import org.apache.shiro.web.filter.authz.PortFilter;
 import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;
@@ -86,6 +87,8 @@ public abstract class ShiroWebModule extends ShiroModule {
     @SuppressWarnings({"UnusedDeclaration"})
     public static final Key<SslFilter> SSL = Key.get(SslFilter.class);
     @SuppressWarnings({"UnusedDeclaration"})
+    public static final Key<IpFilter> IP = Key.get(IpFilter.class);
+    @SuppressWarnings({"UnusedDeclaration"})
     public static final Key<UserFilter> USER = Key.get(UserFilter.class);
 
 

File: web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilter.java
Patch:
@@ -41,6 +41,7 @@ public enum DefaultFilter {
     authc(FormAuthenticationFilter.class),
     authcBasic(BasicHttpAuthenticationFilter.class),
     authcBearer(BearerHttpAuthenticationFilter.class),
+    ip(IpFilter.class),
     logout(LogoutFilter.class),
     noSessionCreation(NoSessionCreationFilter.class),
     perms(PermissionsAuthorizationFilter.class),

File: support/guice/src/test/java/org/apache/shiro/guice/web/FilterConfigTest.java
Patch:
@@ -85,8 +85,7 @@ public void testWithConfig() throws Exception {
     private HttpServletRequest createMockRequest(String path) {
         HttpServletRequest request = createNiceMock(HttpServletRequest.class);
 
-        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();
-        expect(request.getContextPath()).andReturn("");
+        expect(request.getServletPath()).andReturn("");
         expect(request.getPathInfo()).andReturn(path);
         replay(request);
         return request;

File: core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java
Patch:
@@ -64,7 +64,7 @@ public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms,
      * otherwise.
      */
     public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {
-        if (getStopAfterFirstSuccess() && aggregate != null && isEmpty(aggregate.getPrincipals())) {
+        if (getStopAfterFirstSuccess() && aggregate != null && !isEmpty(aggregate.getPrincipals())) {
             throw new ShortCircuitIterationException();
         }
         return aggregate;

File: crypto/cipher/src/main/java/org/apache/shiro/crypto/JcaCipherService.java
Patch:
@@ -306,7 +306,7 @@ public ByteSource encrypt(byte[] plaintext, byte[] key) {
         if (generate) {
             ivBytes = generateInitializationVector(false);
             if (ivBytes == null || ivBytes.length == 0) {
-                throw new IllegalStateException("Initialization vector generation is enabled - generated vector" +
+                throw new IllegalStateException("Initialization vector generation is enabled - generated vector " +
                         "cannot be null or empty.");
             }
         }
@@ -503,7 +503,7 @@ public void encrypt(InputStream in, OutputStream out, byte[] key) throws CryptoE
         if (generate) {
             iv = generateInitializationVector(true);
             if (iv == null || iv.length == 0) {
-                throw new IllegalStateException("Initialization vector generation is enabled - generated vector" +
+                throw new IllegalStateException("Initialization vector generation is enabled - generated vector " +
                         "cannot be null or empty.");
             }
         }

File: web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java
Patch:
@@ -314,7 +314,7 @@ protected void updateSessionLastAccessTime(ServletRequest request, ServletRespon
                     try {
                         session.touch();
                     } catch (Throwable t) {
-                        log.error("session.touch() method invocation has failed.  Unable to update" +
+                        log.error("session.touch() method invocation has failed.  Unable to update " +
                                 "the corresponding session's last access time based on the incoming request.", t);
                     }
                 }

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroHttpSession.java
Patch:
@@ -107,7 +107,7 @@ public ServletContext getServletContext() {
 
     public void setMaxInactiveInterval(int i) {
         try {
-            getSession().setTimeout(i * 1000);
+            getSession().setTimeout(i * 1000L);
         } catch (InvalidSessionException e) {
             throw new IllegalStateException(e);
         }

File: core/src/main/java/org/apache/shiro/subject/support/DelegatingSubject.java
Patch:
@@ -294,7 +294,7 @@ public void login(AuthenticationToken token) throws AuthenticationException {
     }
 
     public boolean isAuthenticated() {
-        return authenticated;
+        return authenticated && hasPrincipals();
     }
 
     public boolean isRemembered() {

File: web/src/main/java/org/apache/shiro/web/filter/authc/AuthenticationFilter.java
Patch:
@@ -78,7 +78,7 @@ public void setSuccessUrl(String successUrl) {
      */
     protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
         Subject subject = getSubject(request, response);
-        return subject.isAuthenticated();
+        return subject.isAuthenticated() && subject.getPrincipal() != null;
     }
 
     /**

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.shiro.web.filter.PathMatchingFilter;
 import org.apache.shiro.web.filter.authc.AnonymousFilter;
 import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;
+import org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter;
 import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;
 import org.apache.shiro.web.filter.authc.LogoutFilter;
 import org.apache.shiro.web.filter.authc.UserFilter;
@@ -69,6 +70,8 @@ public abstract class ShiroWebModule extends ShiroModule {
     @SuppressWarnings({"UnusedDeclaration"})
     public static final Key<BasicHttpAuthenticationFilter> AUTHC_BASIC = Key.get(BasicHttpAuthenticationFilter.class);
     @SuppressWarnings({"UnusedDeclaration"})
+    public static final Key<BearerHttpAuthenticationFilter> AUTHC_BEARER = Key.get(BearerHttpAuthenticationFilter.class);
+    @SuppressWarnings({"UnusedDeclaration"})
     public static final Key<NoSessionCreationFilter> NO_SESSION_CREATION = Key.get(NoSessionCreationFilter.class);
     @SuppressWarnings({"UnusedDeclaration"})
     public static final Key<LogoutFilter> LOGOUT = Key.get(LogoutFilter.class);

File: web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilter.java
Patch:
@@ -40,6 +40,7 @@ public enum DefaultFilter {
     anon(AnonymousFilter.class),
     authc(FormAuthenticationFilter.class),
     authcBasic(BasicHttpAuthenticationFilter.class),
+    authcBearer(BearerHttpAuthenticationFilter.class),
     logout(LogoutFilter.class),
     noSessionCreation(NoSessionCreationFilter.class),
     perms(PermissionsAuthorizationFilter.class),

File: core/src/main/java/org/apache/shiro/authz/Permission.java
Patch:
@@ -32,7 +32,7 @@
  * <em>User</em> or <em>Guest</em> roles, etc.
  * <p/>
  * But if you have a dynamic security model, where roles can be created and deleted at runtime, you can't hard-code
- * role names in your code.  In this environment, roles themselves aren't aren't very useful.  What matters is what
+ * role names in your code.  In this environment, roles themselves aren't very useful.  What matters is what
  * <em>permissions</em> are assigned to these roles.
  * <p/>
  * Under this paradigm, permissions are immutable and reflect an application's raw functionality

File: core/src/main/java/org/apache/shiro/authz/Permission.java
Patch:
@@ -32,7 +32,7 @@
  * <em>User</em> or <em>Guest</em> roles, etc.
  * <p/>
  * But if you have a dynamic security model, where roles can be created and deleted at runtime, you can't hard-code
- * role names in your code.  In this environment, roles themselves aren't aren't very useful.  What matters is what
+ * role names in your code.  In this environment, roles themselves aren't very useful.  What matters is what
  * <em>permissions</em> are assigned to these roles.
  * <p/>
  * Under this paradigm, permissions are immutable and reflect an application's raw functionality

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -181,6 +181,7 @@ protected Subject createSubject(AuthenticationToken token, AuthenticationInfo in
         context.setAuthenticated(true);
         context.setAuthenticationToken(token);
         context.setAuthenticationInfo(info);
+        context.setSecurityManager(this);
         if (existing != null) {
             context.setSubject(existing);
         }

File: core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java
Patch:
@@ -57,7 +57,7 @@ private static boolean isEmpty(PrincipalCollection pc) {
      * since this strategy mandates that only the info from the first successfully authenticated realm be used.
      */
     protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {
-        if (aggregate != null && isEmpty(aggregate.getPrincipals())) {
+        if (aggregate != null && !isEmpty(aggregate.getPrincipals())) {
             return aggregate;
         }
         return info != null ? info : aggregate;

File: core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java
Patch:
@@ -57,7 +57,7 @@ private static boolean isEmpty(PrincipalCollection pc) {
      * since this strategy mandates that only the info from the first successfully authenticated realm be used.
      */
     protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {
-        if (aggregate != null && isEmpty(aggregate.getPrincipals())) {
+        if (aggregate != null && !isEmpty(aggregate.getPrincipals())) {
             return aggregate;
         }
         return info != null ? info : aggregate;

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -158,7 +158,8 @@ private Map<String, Key<? extends Filter>[]> setupFilterChainConfigs() {
 
                 // initialize key in filterToPathToConfig, if it doesn't exist
                 if (filterToPathToConfig.get(key) == null) {
-                    filterToPathToConfig.put((key), new HashMap<String, String>());
+                	// Fix for SHIRO-621: REST filter bypassing matched path
+                    filterToPathToConfig.put((key), new LinkedHashMap<String, String>());
                 }
                 // now set the value
                 filterToPathToConfig.get(key).put(path, config);

File: web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSecurityManager.java
Patch:
@@ -69,11 +69,13 @@ public class DefaultWebSecurityManager extends DefaultSecurityManager implements
 
     public DefaultWebSecurityManager() {
         super();
-        ((DefaultSubjectDAO) this.subjectDAO).setSessionStorageEvaluator(new DefaultWebSessionStorageEvaluator());
+        DefaultWebSessionStorageEvaluator webEvalutator = new DefaultWebSessionStorageEvaluator();  
+        ((DefaultSubjectDAO) this.subjectDAO).setSessionStorageEvaluator(webEvalutator);
         this.sessionMode = HTTP_SESSION_MODE;
         setSubjectFactory(new DefaultWebSubjectFactory());
         setRememberMeManager(new CookieRememberMeManager());
         setSessionManager(new ServletContainerSessionManager());
+        webEvalutator.setSessionManager(getSessionManager());
     }
 
     @SuppressWarnings({"UnusedDeclaration"})

File: web/src/test/java/org/apache/shiro/web/mgt/DefaultWebSecurityManagerTest.java
Patch:
@@ -234,5 +234,5 @@ public void testBuildNonWebSubjectWithDefaultServletContainerSessionManager() {
         assertNotNull(subject);
         assertEquals("user1", subject.getPrincipal());
     }
-
+    
 }

File: core/src/main/java/org/apache/shiro/authz/permission/WildcardPermissionResolver.java
Patch:
@@ -45,7 +45,7 @@ public WildcardPermissionResolver(boolean caseSensitive) {
      * @see WildcardPermissionResolver#WildcardPermissionResolver(boolean)
      */
     public WildcardPermissionResolver() {
-        this(false);
+        this(WildcardPermission.DEFAULT_CASE_SENSITIVE);
     }
 
     /**

File: support/spring/src/main/java/org/apache/shiro/spring/web/config/DefaultShiroFilterChainDefinition.java
Patch:
@@ -18,16 +18,15 @@
  */
 package org.apache.shiro.spring.web.config;
 
-
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 /**
  * @since 1.4.0
  */
 public class DefaultShiroFilterChainDefinition implements ShiroFilterChainDefinition {
 
-    final private Map<String, String> filterChainDefinitionMap = new HashMap<String, String>();
+    final private Map<String, String> filterChainDefinitionMap = new LinkedHashMap<String, String>();
 
     public void addPathDefinition(String antPath, String definition) {
         filterChainDefinitionMap.put(antPath, definition);

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/model/Role.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
-import org.hibernate.annotations.CollectionOfElements;
 import org.hibernate.annotations.Index;
 
 import javax.persistence.*;

File: samples/spring/src/main/java/org/apache/shiro/samples/spring/config/JspViewsConfig.java
Patch:
@@ -29,8 +29,6 @@
 import org.springframework.web.servlet.view.InternalResourceViewResolver;
 import org.springframework.web.servlet.view.JstlView;
 
-import static javafx.application.ConditionalFeature.WEB;
-
 /**
  * JSP / HTML views and resource bean definitions.
  */

File: support/jaxrs/src/main/java/org/apache/shiro/web/jaxrs/ShiroSecurityContext.java
Patch:
@@ -35,9 +35,11 @@
 public class ShiroSecurityContext implements SecurityContext {
 
     final private ContainerRequestContext containerRequestContext;
+    final private SecurityContext originalSecurityContext;
 
     public ShiroSecurityContext(ContainerRequestContext containerRequestContext) {
         this.containerRequestContext = containerRequestContext;
+        this.originalSecurityContext = containerRequestContext.getSecurityContext();
     }
 
     @Override
@@ -55,7 +57,7 @@ public Principal getUserPrincipal() {
             }
         }
         else {
-            result = containerRequestContext.getSecurityContext().getUserPrincipal();
+            result = originalSecurityContext.getUserPrincipal();
         }
 
         return result;

File: core/src/main/java/org/apache/shiro/authc/AbstractAuthenticator.java
Patch:
@@ -172,7 +172,7 @@ public void onLogout(PrincipalCollection principals) {
      * authentication behavior.</li>
      * <li>If an {@code AuthenticationException} is thrown during {@code doAuthenticate},
      * {@link #notifyFailure(AuthenticationToken, AuthenticationException) notify} any registered
-     * {@link AuthenticationListener AuthenticationListener}s of the exception and then propogate the exception
+     * {@link AuthenticationListener AuthenticationListener}s of the exception and then propagate the exception
      * for the caller to handle.</li>
      * <li>If no exception is thrown (indicating a successful login),
      * {@link #notifySuccess(AuthenticationToken, AuthenticationInfo) notify} any registered

File: core/src/main/java/org/apache/shiro/authc/AuthenticationInfo.java
Patch:
@@ -45,7 +45,7 @@
  * <code>Account</code> interface for a given <code>Realm</code> is entirely based on your application's needs or your
  * preferences.
  * <p/>
- * <p><b>Pleae note:</b>  Since Shiro sometimes logs authentication operations, please ensure your AuthenticationInfo's
+ * <p><b>Please note:</b>  Since Shiro sometimes logs authentication operations, please ensure your AuthenticationInfo's
  * <code>toString()</code> implementation does <em>not</em> print out account credentials (password, etc), as these might be viewable to
  * someone reading your logs.  This is good practice anyway, and account credentials should rarely (if ever) be printed
  * out for any reason.  If you're using Shiro's default implementations of this interface, they only ever print the

File: core/src/main/java/org/apache/shiro/authc/AuthenticationToken.java
Patch:
@@ -43,7 +43,7 @@
  * {@link UsernamePasswordToken UsernamePasswordToken} class, as it is probably sufficient for your needs.
  * <p/>
  * <p>RememberMe services are enabled for a token if they implement a sub-interface of this one, called
- * {@link RememberMeAuthenticationToken RememberMeAuthenticationToken}.  Implement that interfac if you need
+ * {@link RememberMeAuthenticationToken RememberMeAuthenticationToken}.  Implement that interface if you need
  * RememberMe services (the <tt>UsernamePasswordToken</tt> already implements this interface).
  * <p/>
  * <p>If you are familiar with JAAS, an <tt>AuthenticationToken</tt> replaces the concept of a

File: core/src/main/java/org/apache/shiro/authc/credential/HashedCredentialsMatcher.java
Patch:
@@ -128,7 +128,7 @@ public class HashedCredentialsMatcher extends SimpleCredentialsMatcher {
     private boolean storedCredentialsHexEncoded;
 
     /**
-     * JavaBeans-compatibile no-arg constructor intended for use in IoC/Dependency Injection environments.  If you
+     * JavaBeans-compatible no-arg constructor intended for use in IoC/Dependency Injection environments.  If you
      * use this constructor, you <em>MUST</em> also additionally set the
      * {@link #setHashAlgorithmName(String) hashAlgorithmName} property.
      */

File: core/src/main/java/org/apache/shiro/authc/package-info.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Core interfaces and exceptions concerning Authentication (the act of logging-in).
  * <p/>
- * Shiro abbreviates the word 'AuthentiCation' as <tt>authc</tt> to distinguish it seperately from
+ * Shiro abbreviates the word 'AuthentiCation' as <tt>authc</tt> to distinguish it separately from
  * 'AuthoriZation', abbreviated as <tt>authz</tt>.
  * <p/>
  * The primary item of interest in this package is the <tt>Authenticator</tt> interface, which acts as the

File: core/src/main/java/org/apache/shiro/authc/pam/AtLeastOneSuccessfulStrategy.java
Patch:
@@ -52,7 +52,7 @@ private static boolean isEmpty(PrincipalCollection pc) {
      * that none of the realms authenticated successfully.
      */
     public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {
-        //we know if one or more were able to succesfully authenticate if the aggregated account object does not
+        //we know if one or more were able to successfully authenticate if the aggregated account object does not
         //contain null or empty data:
         if (aggregate == null || isEmpty(aggregate.getPrincipals())) {
             throw new AuthenticationException("Authentication token of type [" + token.getClass() + "] " +

File: core/src/main/java/org/apache/shiro/authc/pam/AuthenticationStrategy.java
Patch:
@@ -100,7 +100,7 @@ AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, Authenti
 
     /**
      * Method invoked by the ModularAuthenticator signifying that all of its configured Realms have been consulted
-     * for account data, allowing post-proccessing after all realms have completed.
+     * for account data, allowing post-processing after all realms have completed.
      *
      * <p>Returns the final AuthenticationInfo object that will be returned from the Authenticator to the authenticate() caller.
      * This is most likely the aggregate AuthenticationInfo object that has been populated by many realms, but the actual return value is

File: core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Collection;
 
 /**
- * A {@code ModularRealmAuthenticator} delgates account lookups to a pluggable (modular) collection of
+ * A {@code ModularRealmAuthenticator} delegates account lookups to a pluggable (modular) collection of
  * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in Shiro.
  * In addition to authorization duties, a Shiro Realm can also be thought of a PAM 'module'.
  * <p/>
@@ -50,7 +50,7 @@
  * <p/>
  * The strategy object provides callback methods that allow you to
  * determine what constitutes a success or failure in a multi-realm (PAM) scenario.  And because this only makes sense
- * in a mult-realm scenario, the strategy object is only utilized when more than one Realm is configured.
+ * in a multi-realm scenario, the strategy object is only utilized when more than one Realm is configured.
  * <p/>
  * As most multi-realm applications require at least one Realm authenticates successfully, the default
  * implementation is the {@link AtLeastOneSuccessfulStrategy}.

File: core/src/main/java/org/apache/shiro/authz/AuthorizationInfo.java
Patch:
@@ -38,7 +38,7 @@
  * Both permission collections together represent the total aggregate collection of permissions.  You may use one
  * or both depending on your preference and needs.
  * <p/>
- * Because the act of authorization (access control) is orthoganal to authentication (log-in), this interface is
+ * Because the act of authorization (access control) is orthogonal to authentication (log-in), this interface is
  * intended to represent only the account data needed by Shiro during an access control check
  * (role, permission, etc).  Shiro also has a parallel
  * {@link org.apache.shiro.authc.AuthenticationInfo AuthenticationInfo} interface for use during the authentication

File: core/src/main/java/org/apache/shiro/authz/Permission.java
Patch:
@@ -28,7 +28,7 @@
  * configuration, typically by assigning Permissions to users, roles and/or groups.
  * <p/>
  * Most typical systems are what the Shiro team calls <em>role-based</em> in nature, where a role represents
- * common behavior for certain user types.  For example, a system might have an <em>Aministrator</em> role, a
+ * common behavior for certain user types.  For example, a system might have an <em>Administrator</em> role, a
  * <em>User</em> or <em>Guest</em> roles, etc.
  * <p/>
  * But if you have a dynamic security model, where roles can be created and deleted at runtime, you can't hard-code
@@ -69,7 +69,7 @@ public interface Permission {
      * Returns {@code true} if this current instance <em>implies</em> all the functionality and/or resource access
      * described by the specified {@code Permission} argument, {@code false} otherwise.
      * <p/>
-     * <p>That is, this current instance must be exactly equal to or a <em>superset</em> of the functionalty
+     * <p>That is, this current instance must be exactly equal to or a <em>superset</em> of the functionality
      * and/or resource access described by the given {@code Permission} argument.  Yet another way of saying this
      * would be:
      * <p/>

File: core/src/main/java/org/apache/shiro/authz/SimpleAuthorizationInfo.java
Patch:
@@ -42,7 +42,7 @@ public class SimpleAuthorizationInfo implements AuthorizationInfo {
     protected Set<String> stringPermissions;
 
     /**
-     * Collection of all object-based permissions associaed with the account.
+     * Collection of all object-based permissions associated with the account.
      */
     protected Set<Permission> objectPermissions;
 

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresAuthentication.java
Patch:
@@ -33,7 +33,7 @@
  * <p/>
  * See the {@link RequiresUser RequiresUser} and
  * {@link org.apache.shiro.authc.RememberMeAuthenticationToken RememberMeAuthenticationToken} JavaDoc for an
- * explaination of why these two states are considered different.
+ * explanation of why these two states are considered different.
  *
  * @see RequiresUser
  * @see RequiresGuest

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresRoles.java
Patch:
@@ -55,7 +55,7 @@
 public @interface RequiresRoles {
 
     /**
-     * A single String role name or multiple comma-delimitted role names required in order for the method
+     * A single String role name or multiple comma-delimited role names required in order for the method
      * invocation to be allowed.
      */
     String[] value();

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresUser.java
Patch:
@@ -38,7 +38,7 @@
  * </ul>
  * <p/>
  * See the {@link org.apache.shiro.authc.RememberMeAuthenticationToken RememberMeAuthenticationToken} JavaDoc for an
- * explaination of why these two states are considered different.
+ * explanation of why these two states are considered different.
  *
  * @see RequiresAuthentication
  * @see RequiresGuest

File: core/src/main/java/org/apache/shiro/authz/annotation/package-info.java
Patch:
@@ -20,7 +20,7 @@
  * Annotations used to restrict which classes, instances, or methods may be accessed or invoked depending on the
  * caller's access abilities or authentication state.
  * 
- * Since 1.1, all core annotations were extends to accept Target ElementType.TYPE in additon to ElementType.METHOD 
+ * Since 1.1, all core annotations were extends to accept Target ElementType.TYPE in addition to ElementType.METHOD 
  */
 package org.apache.shiro.authz.annotation;
 import java.lang.annotation.ElementType;

File: core/src/main/java/org/apache/shiro/authz/package-info.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Core interfaces and exceptions supporting Authorization (access control).
  * <p/>
- * Shiro abbreviates the word 'AuthoriZation' as <tt>authz</tt> to distinguish it seperately from
+ * Shiro abbreviates the word 'AuthoriZation' as <tt>authz</tt> to distinguish it separately from
  * 'AuthentiCation', abbreviated as <tt>authc</tt>.
  * <p/>
  * This package's primary interface of interest, which is the core of Shiro authorization functionality,

File: core/src/main/java/org/apache/shiro/realm/Realm.java
Patch:
@@ -26,8 +26,8 @@
  * A <tt>Realm</tt> is a security component that can access application-specific security entities
  * such as users, roles, and permissions to determine authentication and authorization operations.
  *
- * <p><tt>Realm</tt>s usually have a 1-to-1 correspondance with a datasource such as a relational database,
- * file sysetem, or other similar resource.  As such, implementations of this interface use datasource-specific APIs to
+ * <p><tt>Realm</tt>s usually have a 1-to-1 correspondence with a datasource such as a relational database,
+ * file system, or other similar resource.  As such, implementations of this interface use datasource-specific APIs to
  * determine authorization data (roles, permissions, etc), such as JDBC, File IO, Hibernate or JPA, or any other
  * Data Access API.  They are essentially security-specific
  * <a href="http://en.wikipedia.org/wiki/Data_Access_Object" target="_blank">DAO</a>s.
@@ -98,7 +98,7 @@ public interface Realm {
      *         or <tt>null</tt> if no account could be found.
      * @throws org.apache.shiro.authc.AuthenticationException
      *          if there is an error obtaining or constructing an AuthenticationInfo object based on the
-     *          specified <tt>token</tt> or implementation-specifc login behavior fails.
+     *          specified <tt>token</tt> or implementation-specific login behavior fails.
      */
     AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;
 

File: core/src/main/java/org/apache/shiro/realm/text/PropertiesRealm.java
Patch:
@@ -124,7 +124,7 @@ public void setUseXmlFormat(boolean useXmlFormat) {
 
     /**
      * Sets the path of the properties file to load user, role, and permission information from.  The properties
-     * file will be loaded using {@link ResourceUtils#getInputStreamForPath(String)} so any convention recongized
+     * file will be loaded using {@link ResourceUtils#getInputStreamForPath(String)} so any convention recognized
      * by that method is accepted here.  For example, to load a file from the classpath use
      * {@code classpath:myfile.properties}; to load a file from disk simply specify the full path; to load
      * a file from a URL use {@code url:www.mysite.com/myfile.properties}.
@@ -138,7 +138,7 @@ public void setResourcePath(String resourcePath) {
     /**
      * Sets the interval in seconds at which the property file will be checked for changes and reloaded.  If this is
      * set to zero or less, property file reloading will be disabled.  If it is set to 1 or greater, then a
-     * separate thread will be created to monitor the propery file for changes and reload the file if it is updated.
+     * separate thread will be created to monitor the property file for changes and reload the file if it is updated.
      *
      * @param reloadIntervalSeconds the interval in seconds at which the property file should be examined for changes.
      *                              If set to zero or less, reloading is disabled.

File: core/src/main/java/org/apache/shiro/realm/text/TextConfigurationRealm.java
Patch:
@@ -109,7 +109,7 @@ public String getRoleDefinitions() {
      * <p/>
      * <p>where <em>permissionDefinition</em> is an arbitrary String, but must people will want to use
      * Strings that conform to the {@link org.apache.shiro.authz.permission.WildcardPermission WildcardPermission}
-     * format for ease of use and flexibility.  Note that if an individual <em>permissionDefnition</em> needs to
+     * format for ease of use and flexibility.  Note that if an individual <em>permissionDefinition</em> needs to
      * be internally comma-delimited (e.g. <code>printer:5thFloor:print,info</code>), you will need to surround that
      * definition with double quotes (&quot;) to avoid parsing errors (e.g.
      * <code>&quot;printer:5thFloor:print,info&quot;</code>).

File: core/src/main/java/org/apache/shiro/session/Session.java
Patch:
@@ -116,7 +116,7 @@ public interface Session {
      * automatically as a result of an incoming web request or remote procedure call/method invocation.
      * <p/>
      * However, this method is particularly useful when supporting rich-client applications such as
-     * Java Web Start appp, Java or Flash applets, etc.  Although rare, it is possible in a rich-client
+     * Java Web Start app, Java or Flash applets, etc.  Although rare, it is possible in a rich-client
      * environment that a user continuously interacts with the client-side application without a
      * server-side method call ever being invoked.  If this happens over a long enough period of
      * time, the user's server-side session could time-out.  Again, such cases are rare since most
@@ -183,7 +183,7 @@ public interface Session {
     Object getAttribute(Object key) throws InvalidSessionException;
 
     /**
-     * Binds the specified {@code value} to this session, uniquely identified by the specifed
+     * Binds the specified {@code value} to this session, uniquely identified by the specified
      * {@code key} name.  If there is already an object bound under the {@code key} name, that
      * existing object will be replaced by the new {@code value}.
      * <p/>

File: core/src/main/java/org/apache/shiro/session/SessionListenerAdapter.java
Patch:
@@ -27,7 +27,7 @@
 public class SessionListenerAdapter implements SessionListener {
 
     /**
-     * Adapter no-op implemenation - does nothing and returns immediately.
+     * Adapter no-op implementation - does nothing and returns immediately.
      *
      * @param session the session that has started.
      */
@@ -36,7 +36,7 @@ public void onStart(Session session) {
     }
 
     /**
-     * Adapter no-op implemenation - does nothing and returns immediately.
+     * Adapter no-op implementation - does nothing and returns immediately.
      *
      * @param session the session that has stopped.
      */
@@ -45,7 +45,7 @@ public void onStop(Session session) {
     }
 
     /**
-     * Adapter no-op implemenation - does nothing and returns immediately.
+     * Adapter no-op implementation - does nothing and returns immediately.
      *
      * @param session the session that has expired.
      */

File: core/src/main/java/org/apache/shiro/session/mgt/AbstractSessionManager.java
Patch:
@@ -79,7 +79,7 @@ public long getGlobalSessionTimeout() {
      * <p/>
      * Unless overridden by calling this method, the default value is {@link #DEFAULT_GLOBAL_SESSION_TIMEOUT}.
      *
-     * @param globalSessionTimeout the time in milliseconds that any session may remain idel before expiring.
+     * @param globalSessionTimeout the time in milliseconds that any session may remain idle before expiring.
      */
     public void setGlobalSessionTimeout(long globalSessionTimeout) {
         this.globalSessionTimeout = globalSessionTimeout;

File: core/src/main/java/org/apache/shiro/session/mgt/ValidatingSessionManager.java
Patch:
@@ -41,7 +41,7 @@ public interface ValidatingSessionManager extends SessionManager {
      * This is obvious in the case of web applications due to the HTTP protocol, but it is
      * equally true of remote client applications making remote method invocations.  The server
      * essentially sits idle and only &quot;works&quot; when responding to client requests and/or
-     * method invocations.  This type of model is particularly efficent since it means the
+     * method invocations.  This type of model is particularly efficient since it means the
      * security system only has to validate a session during those cases.  Such
      * &quot;lazy&quot; behavior enables the system to lie stateless and/or idle and only incur
      * overhead for session validation when necessary.

File: core/src/main/java/org/apache/shiro/session/package-info.java
Patch:
@@ -21,12 +21,12 @@
  * interacts with an application.
  * <p/>
  * Sessions in Shiro are completely POJO-based and do not <em>require</em> an application to use Web-based
- * or EJB-based session management infrastructure - the client and/or server technoloy is irrelevent in
+ * or EJB-based session management infrastructure - the client and/or server technology is irrelevant in
  * Shiro's architecture, allowing session management to be employed in the smallest standalone application
  * to the largest enterprise deployments.
  * <p/>
  * This design decision opens up a new world to Java applications - most notably the ability to participate in
- * a session regardless if the client is using HTTP, custom sockets, web services, or even non-Java progamming
+ * a session regardless if the client is using HTTP, custom sockets, web services, or even non-Java programming
  * languages. Aside from Shiro, there is currently no technology in Java today allows this heterogenous
  * client-session capability.
  * <p/>

File: core/src/main/java/org/apache/shiro/subject/PrincipalCollection.java
Patch:
@@ -62,7 +62,7 @@ public interface PrincipalCollection extends Iterable, Serializable {
      * Shiro's default implementations of this interface make this
      * assumption by usually simply returning {@link #iterator()}.{@link java.util.Iterator#next() next()}, which just
      * returns the first returned principal obtained from the first consulted/configured {@code Realm} during the
-     * authentication attempt.  This means in a multi-{@code Realm} application, {@code Realm} configuraiton order
+     * authentication attempt.  This means in a multi-{@code Realm} application, {@code Realm} configuration order
      * matters if you want to retain this default heuristic.
      * <p/>
      * If this heuristic is not sufficient, most Shiro end-users will need to implement a custom

File: core/src/main/java/org/apache/shiro/subject/SimplePrincipalCollection.java
Patch:
@@ -264,7 +264,7 @@ public String toString() {
      * Serialization write support.
      * <p/>
      * NOTE: Don't forget to change the serialVersionUID constant at the top of this class
-     * if you make any backwards-incompatible serializatoin changes!!!
+     * if you make any backwards-incompatible serialization changes!!!
      * (use the JDK 'serialver' program for this)
      *
      * @param out output stream provided by Java serialization
@@ -284,7 +284,7 @@ private void writeObject(ObjectOutputStream out) throws IOException {
      * input stream.
      * <p/>
      * NOTE: Don't forget to change the serialVersionUID constant at the top of this class
-     * if you make any backwards-incompatible serializatoin changes!!!
+     * if you make any backwards-incompatible serialization changes!!!
      * (use the JDK 'serialver' program for this)
      *
      * @param in input stream provided by

File: core/src/main/java/org/apache/shiro/subject/Subject.java
Patch:
@@ -52,7 +52,7 @@
  * type-safe method.  (Shiro's default implementations do String-to-Permission conversion for these methods using
  * {@link org.apache.shiro.authz.permission.PermissionResolver PermissionResolver}s.)
  * <p/>
- * These overloaded *Permission methods forgo type-saftey for the benefit of convenience and simplicity,
+ * These overloaded *Permission methods forgo type-safety for the benefit of convenience and simplicity,
  * so you should choose which ones to use based on your preferences and needs.
  *
  * @since 0.1
@@ -557,7 +557,7 @@ public interface Subject {
      * Releases the current 'run as' (assumed) identity and reverts back to the previous 'pre run as'
      * identity that existed before {@code #runAs runAs} was called.
      * <p/>
-     * This method returne 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not
+     * This method returns 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not
      * operating under an assumed identity.
      *
      * @return the 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not operating

File: core/src/main/java/org/apache/shiro/subject/package-info.java
Patch:
@@ -20,7 +20,7 @@
  * Components supporting the {@link org.apache.shiro.subject.Subject Subject} interface, the most important concept in
  * Shiro's API.
  * <p/>
- * A <code>Subject</code> is <em>the</em> primary component when using Shiro programatically for single-user
+ * A <code>Subject</code> is <em>the</em> primary component when using Shiro programmatically for single-user
  * security operations, and it is the handle to any accessible user security data.  All single-user
  * authentication, authorization and session operations are performed via a <code>Subject</code> instance.
  */

File: core/src/main/java/org/apache/shiro/util/ThreadContext.java
Patch:
@@ -256,7 +256,7 @@ public static void bind(SecurityManager securityManager) {
      * Convenience method that simplifies removal of the application's SecurityManager instance from the thread.
      * <p/>
      * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is
-     * merely a conveient wrapper for the following:
+     * merely a convenient wrapper for the following:
      * <p/>
      * <code>return (SecurityManager)remove( SECURITY_MANAGER_KEY );</code>
      * <p/>
@@ -315,7 +315,7 @@ public static void bind(Subject subject) {
      * Convenience method that simplifies removal of a thread-local Subject from the thread.
      * <p/>
      * The implementation just helps reduce casting and remembering of the ThreadContext key name, i.e it is
-     * merely a conveient wrapper for the following:
+     * merely a convenient wrapper for the following:
      * <p/>
      * <code>return (Subject)remove( SUBJECT_KEY );</code>
      * <p/>

File: core/src/main/java/org/apache/shiro/util/package-info.java
Patch:
@@ -17,7 +17,7 @@
  * under the License.
  */
 /**
- * Your run-of-the-mill 'util' pacakge for components and logic widely used across the framework that can't
+ * Your run-of-the-mill 'util' package for components and logic widely used across the framework that can't
  * find their home into a proper OO hierarchy (or, most likely for things used across many hierarchies).
  */
 package org.apache.shiro.util;

File: core/src/test/java/org/apache/shiro/realm/AuthorizingRealmTest.java
Patch:
@@ -40,7 +40,7 @@
 /**
  * Simple test case for AuthorizingRealm.
  * <p/>
- * TODO - this could/should be expaned to be more robust end to end test for the AuthorizingRealm
+ * TODO - this could/should be expanded to be more robust end to end test for the AuthorizingRealm
  */
 public class AuthorizingRealmTest {
 
@@ -252,4 +252,4 @@ protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object cr
 
     }
 
-}
\ No newline at end of file
+}

File: lang/src/main/java/org/apache/shiro/codec/Base64.java
Patch:
@@ -26,7 +26,7 @@
  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
  * <p/>
  * This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications
- * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of
+ * to enable Base64 conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of
  * great work they've done, but also didn't want to force every Shiro user to depend on the commons-codec.jar
  * <p/>
  * As per the Apache 2.0 license, the original copyright notice and all author and copyright information have
@@ -152,7 +152,7 @@ public class Base64 {
     }
 
     /**
-     * Returns whether or not the <code>octect</code> is in the base 64 alphabet.
+     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
      *
      * @param octect The value to test
      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
@@ -415,7 +415,7 @@ public static byte[] decode(String base64Encoded) {
     }
 
     /**
-     * Decodes Base64 data into octects
+     * Decodes Base64 data into octets
      *
      * @param base64Data Byte array containing Base64 data
      * @return Array containing decoded data.

File: lang/src/main/java/org/apache/shiro/io/DefaultSerializer.java
Patch:
@@ -78,7 +78,7 @@ public T deserialize(byte[] serialized) throws SerializationException {
             ois.close();
             return deserialized;
         } catch (Exception e) {
-            String msg = "Unable to deserialze argument byte array.";
+            String msg = "Unable to deserialize argument byte array.";
             throw new SerializationException(msg, e);
         }
     }

File: lang/src/main/java/org/apache/shiro/io/ResourceUtils.java
Patch:
@@ -116,7 +116,7 @@ public static boolean resourceExists(String resourcePath) {
      * {@link FileInputStream FileInputStream}.
      *
      * @param resourcePath the String path representing the resource to obtain.
-     * @return the InputStraem for the specified resource.
+     * @return the InputStream for the specified resource.
      * @throws IOException if there is a problem acquiring the resource at the specified path.
      */
     public static InputStream getInputStreamForPath(String resourcePath) throws IOException {

File: lang/src/main/java/org/apache/shiro/io/Serializer.java
Patch:
@@ -37,7 +37,7 @@ public interface Serializer<T> {
      *
      * @param o the Object to convert into a byte[] array.
      * @return a byte[] array representing the Object's state that can be restored later.
-     * @throws SerializationException if an error occurrs converting the Object into a byte[] array.
+     * @throws SerializationException if an error occurs converting the Object into a byte[] array.
      */
     byte[] serialize(T o) throws SerializationException;
 
@@ -47,7 +47,7 @@ public interface Serializer<T> {
      *
      * @param serialized the raw data resulting from a previous {@link #serialize(Object) serialize} call.
      * @return the Object that was previously serialized into the raw byte[] array.
-     * @throws SerializationException if an error occurrs converting the raw byte[] array back into an Object.
+     * @throws SerializationException if an error occurs converting the raw byte[] array back into an Object.
      */
     T deserialize(byte[] serialized) throws SerializationException;
 }

File: samples/quickstart/src/main/java/Quickstart.java
Patch:
@@ -103,7 +103,7 @@ public static void main(String[] args) {
         }
 
         //test a typed permission (not instance-level)
-        if (currentUser.isPermitted("lightsaber:weild")) {
+        if (currentUser.isPermitted("lightsaber:wield")) {
             log.info("You may use a lightsaber ring.  Use it wisely.");
         } else {
             log.info("Sorry, lightsaber rings are for schwartz masters only.");

File: support/ehcache/src/main/java/org/apache/shiro/cache/ehcache/EhCacheManager.java
Patch:
@@ -36,7 +36,7 @@
  * This class can {@link #setCacheManager(net.sf.ehcache.CacheManager) accept} a manually configured
  * {@link net.sf.ehcache.CacheManager net.sf.ehcache.CacheManager} instance,
  * or an {@code ehcache.xml} path location can be specified instead and one will be constructed. If neither are
- * specified, Shiro's failsafe <code><a href="./ehcache.xml">ehcache.xml</a>} file will be used by default.
+ * specified, Shiro's failsafe <code><a href="./ehcache.xml">ehcache.xml</a></code> file will be used by default.
  * <p/>
  * This implementation requires EhCache 1.2 and above. Make sure EhCache 1.1 or earlier
  * is not in the classpath or it will not work.
@@ -179,7 +179,7 @@ public final <K, V> Cache<K, V> getCache(String name) throws CacheException {
      * Initializes this instance.
      * <p/>
      * If a {@link #setCacheManager CacheManager} has been
-     * explicitly set (e.g. via Dependency Injection or programatically) prior to calling this
+     * explicitly set (e.g. via Dependency Injection or programmatically) prior to calling this
      * method, this method does nothing.
      * <p/>
      * However, if no {@code CacheManager} has been set, the default Ehcache singleton will be initialized, where
@@ -228,7 +228,7 @@ private net.sf.ehcache.CacheManager ensureCacheManager() {
      * Shuts-down the wrapped Ehcache CacheManager <b>only if implicitly created</b>.
      * <p/>
      * If another component injected
-     * a non-null CacheManager into this instace before calling {@link #init() init}, this instance expects that same
+     * a non-null CacheManager into this instance before calling {@link #init() init}, this instance expects that same
      * component to also destroy the CacheManager instance, and it will not attempt to do so.
      */
     public void destroy() {

File: support/quartz/src/main/java/org/apache/shiro/session/mgt/quartz/QuartzSessionValidationScheduler.java
Patch:
@@ -64,7 +64,7 @@ public class QuartzSessionValidationScheduler implements SessionValidationSchedu
 
     /**
      * The configured Quartz scheduler to use to schedule the Quartz job.  If no scheduler is
-     * configured, the schedular will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}
+     * configured, the scheduler will be retrieved by calling {@link StdSchedulerFactory#getDefaultScheduler()}
      */
     private Scheduler scheduler;
 

File: support/spring/src/main/java/org/apache/shiro/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -96,7 +96,7 @@ public Object invoke(final RemoteInvocation invocation, final Object targetObjec
                 if (log.isTraceEnabled()) {
                     log.trace("RemoteInvocation did not contain a Shiro Session id attribute under " +
                             "key [" + SecureRemoteInvocationFactory.SESSION_ID_KEY + "].  A Subject based " +
-                            "on an existing Session will not be available during the method invocatin.");
+                            "on an existing Session will not be available during the method invocation.");
                 }
             }
 

File: core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
Patch:
@@ -219,9 +219,9 @@ protected AuthenticationInfo doMultiRealmAuthentication(Collection<Realm> realms
                     info = realm.getAuthenticationInfo(token);
                 } catch (Throwable throwable) {
                     t = throwable;
-                    if (log.isWarnEnabled()) {
+                    if (log.isDebugEnabled()) {
                         String msg = "Realm [" + realm + "] threw an exception during a multi-realm authentication attempt:";
-                        log.warn(msg, t);
+                        log.debug(msg, t);
                     }
                 }
 

File: web/src/main/java/org/apache/shiro/web/util/WebUtils.java
Patch:
@@ -248,11 +248,12 @@ public static String getContextPath(HttpServletRequest request) {
         if (contextPath == null) {
             contextPath = request.getContextPath();
         }
+        contextPath = normalize(decodeRequestString(request, contextPath));
         if ("/".equals(contextPath)) {
-            // Invalid case, but happens for includes on Jetty: silently adapt it.
+            // the normalize method will return a "/" and includes on Jetty, will also be a "/".
             contextPath = "";
         }
-        return decodeRequestString(request, contextPath);
+        return contextPath;
     }
 
     /**

File: config/ogdl/src/main/java/org/apache/shiro/config/event/LoggingBeanEventListener.java
Patch:
@@ -36,7 +36,7 @@ public class LoggingBeanEventListener {
     public void onEvent(BeanEvent e) {
         String className = e.getClass().getSimpleName();
         int i = className.lastIndexOf(SUFFIX);
-        String subclassPrefix = className.substring(0, i);
+        String subclassPrefix = i > 0 ? className.substring(0, i) : className;
         logger.trace("{} bean '{}' [{}]", new Object[]{subclassPrefix, e.getBeanName(), e.getBean()});
     }
 }

File: core/src/main/java/org/apache/shiro/realm/ldap/JndiLdapContextFactory.java
Patch:
@@ -49,14 +49,14 @@
  * For example, consider the following two identical configurations:
  * <pre>
  * [main]
- * ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealm
+ * ldapRealm = org.apache.shiro.realm.ldap.DefaultLdapRealm
  * ldapRealm.contextFactory.url = ldap://localhost:389
  * ldapRealm.contextFactory.authenticationMechanism = DIGEST-MD5
  * </pre>
  * and
  * <pre>
  * [main]
- * ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealm
+ * ldapRealm = org.apache.shiro.realm.ldap.DefaultLdapRealm
  * ldapRealm.contextFactory.environment[java.naming.provider.url] = ldap://localhost:389
  * ldapRealm.contextFactory.environment[java.naming.security.authentication] = DIGEST-MD5
  * </pre>
@@ -68,7 +68,7 @@
  * For example:
  * <pre>
  * [main]
- * ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealm
+ * ldapRealm = org.apache.shiro.realm.ldap.DefaultLdapRealm
  * ldapRealm.contextFactory.url = ldap://localhost:389
  * ldapRealm.contextFactory.authenticationMechanism = DIGEST-MD5
  * ldapRealm.contextFactory.environment[some.other.obscure.jndi.key] = some value

File: core/src/main/java/org/apache/shiro/realm/ldap/LdapContextFactory.java
Patch:
@@ -22,7 +22,7 @@
 import javax.naming.ldap.LdapContext;
 
 /**
- * Interface that encapsulates the creation of {@code LdapContext} objects that are used by {@link JndiLdapRealm}s to
+ * Interface that encapsulates the creation of {@code LdapContext} objects that are used by {@link DefaultLdapRealm}s to
  * perform authentication attempts and query for authorization data.
  *
  * @since 0.2

File: core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
Patch:
@@ -131,7 +131,6 @@ public Set<String> getTargets() {
     }
 
     protected void setTargets(Set<String> targets) {
-        this.targets = targets;
         if (this.targets != null && this.targets.equals(targets)) {
             return;
         }

File: crypto/hash/src/main/java/org/apache/shiro/crypto/hash/SimpleHash.java
Patch:
@@ -346,7 +346,7 @@ protected byte[] hash(byte[] bytes, byte[] salt, int hashIterations) throws Unkn
             digest.update(salt);
         }
         byte[] hashed = digest.digest(bytes);
-        int iterations = hashIterations - DEFAULT_ITERATIONS; //already hashed once above
+        int iterations = hashIterations - 1; //already hashed once above
         //iterate remaining number:
         for (int i = 0; i < iterations; i++) {
             digest.reset();

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -179,7 +179,7 @@ private Key<? extends PathMatchingFilter> castToPathMatching(Key<? extends Filte
     @SuppressWarnings({"unchecked"})
     @Override
     protected final void bindSecurityManager(AnnotatedBindingBuilder<? super SecurityManager> bind) {
-        bindWebSecurityManager(bind);
+        bind.to(WebSecurityManager.class); // SHIRO-435
     }
 
     /**
@@ -211,7 +211,7 @@ protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind)
 
     @Override
     protected final void bindEnvironment(AnnotatedBindingBuilder<Environment> bind) {
-        bindWebEnvironment(bind);
+        bind.to(WebEnvironment.class); // SHIRO-435
     }
 
     protected void bindWebEnvironment(AnnotatedBindingBuilder<? super WebEnvironment> bind) {

File: core/src/main/java/org/apache/shiro/realm/AuthorizingRealm.java
Patch:
@@ -244,8 +244,8 @@ private Cache<Object, AuthorizationInfo> getAuthorizationCacheLazy() {
                 }
                 this.authorizationCache = cacheManager.getCache(cacheName);
             } else {
-                if (log.isInfoEnabled()) {
-                    log.info("No cache or cacheManager properties have been set.  Authorization cache cannot " +
+                if (log.isDebugEnabled()) {
+                    log.debug("No cache or cacheManager properties have been set.  Authorization cache cannot " +
                             "be obtained.");
                 }
             }

File: core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
Patch:
@@ -219,9 +219,9 @@ protected AuthenticationInfo doMultiRealmAuthentication(Collection<Realm> realms
                     info = realm.getAuthenticationInfo(token);
                 } catch (Throwable throwable) {
                     t = throwable;
-                    if (log.isDebugEnabled()) {
+                    if (log.isWarnEnabled()) {
                         String msg = "Realm [" + realm + "] threw an exception during a multi-realm authentication attempt:";
-                        log.debug(msg, t);
+                        log.warn(msg, t);
                     }
                 }
 

File: core/src/main/java/org/apache/shiro/realm/text/PropertiesRealm.java
Patch:
@@ -265,7 +265,9 @@ private boolean isSourceModified() {
     }
 
     private boolean isFileModified() {
-        File propertyFile = new File(this.resourcePath);
+        //SHIRO-394: strip file prefix before constructing the File instance:
+        String fileNameWithoutPrefix = this.resourcePath.substring(this.resourcePath.indexOf(":") + 1);
+        File propertyFile = new File(fileNameWithoutPrefix);
         long currentLastModified = propertyFile.lastModified();
         if (currentLastModified > this.fileLastModified) {
             this.fileLastModified = currentLastModified;

File: core/src/main/java/org/apache/shiro/config/ReflectionBuilder.java
Patch:
@@ -260,6 +260,9 @@ private String parseBeanId(String lhs) {
             processor.execute();
         }
 
+        //SHIRO-413: init method must be called for constructed objects that are Initializable
+        LifecycleUtils.init(objects.values());
+
         return objects;
     }
 

File: core/src/main/java/org/apache/shiro/cache/MemoryConstrainedCacheManager.java
Patch:
@@ -28,8 +28,8 @@
  * <p/>
  * While the {@code Cache} instances created are thread-safe, they do not offer any enterprise-level features such as
  * cache coherency, optimistic locking, failover or other similar features.  For more enterprise features, consider
- * using a different {@code CacheManager} implementation backed by an enterprise-grade caching product (EhCache,
- * TerraCotta, Coherence, GigaSpaces, etc, etc).
+ * using a different {@code CacheManager} implementation backed by an enterprise-grade caching product (Hazelcast,
+ * EhCache, TerraCotta, Coherence, GigaSpaces, etc, etc).
  *
  * @since 1.0
  */

File: samples/quickstart-guice/src/main/java/QuickstartGuice.java
Patch:
@@ -21,15 +21,12 @@
 import com.google.inject.Injector;
 import org.apache.shiro.SecurityUtils;
 import org.apache.shiro.authc.*;
-import org.apache.shiro.config.IniSecurityManagerFactory;
 import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.session.Session;
 import org.apache.shiro.subject.Subject;
-import org.apache.shiro.util.Factory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-
 /**
  * Simple Quickstart application showing how to use Shiro's API with Guice integration.
  *

File: core/src/main/java/org/apache/shiro/realm/text/PropertiesRealm.java
Patch:
@@ -163,7 +163,7 @@ protected void afterRoleCacheSet() {
         loadProperties();
         //we can only determine if files have been modified at runtime (not classpath entries or urls), so only
         //start the thread in this case:
-        if (this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && scheduler != null) {
+        if (this.resourcePath.startsWith(ResourceUtils.FILE_PREFIX) && scheduler == null) {
             startReloadThread();
         }
     }

File: core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
Patch:
@@ -55,7 +55,7 @@ public DomainPermission(String actions) {
     public DomainPermission(String actions, String targets) {
         this.domain = getDomain(getClass());
         this.actions = StringUtils.splitToSet(actions, SUBPART_DIVIDER_TOKEN);
-        this.targets = StringUtils.splitToSet(actions, SUBPART_DIVIDER_TOKEN);
+        this.targets = StringUtils.splitToSet(targets, SUBPART_DIVIDER_TOKEN);
         encodeParts(this.domain, actions, targets);
     }
 

File: support/guice/src/main/java/org/apache/shiro/guice/ShiroModule.java
Patch:
@@ -51,6 +51,7 @@ public abstract class ShiroModule extends PrivateModule implements Destroyable {
     private Set<Destroyable> destroyables = Sets.newSetFromMap(new WeakHashMap<Destroyable, Boolean>());
 
     public void configure() {
+        this.binder().requireExplicitBindings();
         // setup security manager
         bindSecurityManager(bind(SecurityManager.class));
         bindSessionManager(bind(SessionManager.class));

File: web/src/main/java/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.java
Patch:
@@ -362,6 +362,6 @@ protected String[] getPrincipalsAndCredentials(String authorizationHeader, Servl
      */
     protected String[] getPrincipalsAndCredentials(String scheme, String encoded) {
         String decoded = Base64.decodeToString(encoded);
-        return decoded.split(":");
+        return decoded.split(":", 2);
     }
 }

File: core/src/main/java/org/apache/shiro/config/ReflectionBuilder.java
Patch:
@@ -133,7 +133,7 @@ protected void createNewInstance(Map<String, Object> objects, String name, Strin
         Object currentInstance = objects.get(name);
         if (currentInstance != null) {
             log.info("An instance with name '{}' already exists.  " +
-                    "Redefining this object as a new instance of type []", name, value);
+                    "Redefining this object as a new instance of type {}", name, value);
         }
 
         Object instance;//name with no property, assume right hand side of equals sign is the class name:

File: core/src/main/java/org/apache/shiro/io/DefaultSerializer.java
Patch:
@@ -72,7 +72,7 @@ public T deserialize(byte[] serialized) throws SerializationException {
         ByteArrayInputStream bais = new ByteArrayInputStream(serialized);
         BufferedInputStream bis = new BufferedInputStream(bais);
         try {
-            ObjectInputStream ois = new ObjectInputStream(bis);
+            ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);
             @SuppressWarnings({"unchecked"})
             T deserialized = (T) ois.readObject();
             ois.close();

File: core/src/main/java/org/apache/shiro/realm/text/TextConfigurationRealm.java
Patch:
@@ -38,7 +38,7 @@
  * specifies a name and an optional collection of assigned Permissions.  Users can be assigned Roles, and Roles can be
  * assigned Permissions.  By transitive association, each User 'has' all of their Role's Permissions.
  * <p/>
- * User and user-to-role definitinos are specified via the {@link #setUserDefinitions} method and
+ * User and user-to-role definitions are specified via the {@link #setUserDefinitions} method and
  * Role-to-permission definitions are specified via the {@link #setRoleDefinitions} method.
  *
  * @since 0.9

File: core/src/main/java/org/apache/shiro/env/NamedObjectEnvironment.java
Patch:
@@ -12,7 +12,7 @@ public interface NamedObjectEnvironment extends Environment {
      * no object with that name was found.
      *
      * @param name the assigned name of the object.
-     * @param requiredType the class that the discovered object should be.  If the object is not the specified type, a
+     * @param requiredType the class to which the discovered object must be assignable.
      * @param <T> the type of the class
      * @throws RequiredTypeException if the discovered object does not equal, extend, or implement the specified class.
      * @return the object in Shiro's environment with the specified name (of the specified type) or {@code null} if

File: core/src/main/java/org/apache/shiro/crypto/hash/format/HashFormatFactory.java
Patch:
@@ -23,5 +23,5 @@
  */
 public interface HashFormatFactory {
 
-    HashFormat getInstance(String id);
+    HashFormat getInstance(String token);
 }

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -39,7 +39,7 @@
 import org.apache.shiro.web.filter.session.NoSessionCreationFilter;
 import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
 import org.apache.shiro.web.mgt.WebSecurityManager;
-import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
+import org.apache.shiro.web.session.mgt.ServletContainerSessionManager;
 
 import javax.servlet.Filter;
 import javax.servlet.ServletContext;
@@ -195,7 +195,7 @@ protected void bindWebSecurityManager(AnnotatedBindingBuilder<? super WebSecurit
      */
     @Override
     protected void bindSessionManager(AnnotatedBindingBuilder<SessionManager> bind) {
-        bind.to(DefaultWebSessionManager.class).asEagerSingleton();
+        bind.to(ServletContainerSessionManager.class).asEagerSingleton();
     }
 
     @Override

File: support/guice/src/test/java/org/apache/shiro/guice/web/ShiroWebModuleTest.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
 import org.apache.shiro.web.mgt.WebSecurityManager;
 import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
+import org.apache.shiro.web.session.mgt.ServletContainerSessionManager;
 import org.junit.Test;
 
 import javax.inject.Named;
@@ -71,8 +72,8 @@ public ShiroModuleTest.MockRealm createRealm() {
         assertTrue(securityManager instanceof WebSecurityManager);
         SessionManager sessionManager = injector.getInstance(SessionManager.class);
         assertNotNull(sessionManager);
-        assertTrue(sessionManager instanceof DefaultWebSessionManager);
-        assertTrue(((DefaultWebSecurityManager)securityManager).getSessionManager() instanceof DefaultWebSessionManager);
+        assertTrue(sessionManager instanceof ServletContainerSessionManager);
+        assertTrue(((DefaultWebSecurityManager)securityManager).getSessionManager() instanceof ServletContainerSessionManager);
     }
 
     @Test

File: support/guice/src/main/java/org/apache/shiro/guice/web/ShiroWebModule.java
Patch:
@@ -116,6 +116,7 @@ protected void configureServlets() {
 
     @Override
     protected final void configureShiro() {
+        bindBeanType(TypeLiteral.get(ServletContext.class), Key.get(ServletContext.class, Names.named(NAME)));
         bind(Key.get(ServletContext.class, Names.named(NAME))).toInstance(this.servletContext);
         bindWebSecurityManager(bind(WebSecurityManager.class));
         bindWebEnvironment(bind(WebEnvironment.class));

File: support/guice/src/test/java/org/apache/shiro/guice/BeanTypeListenerTest.java
Patch:
@@ -83,6 +83,7 @@ public void testPropertySetting() throws Exception {
         expect(injector.getInstance(Key.get(String.class, Names.named("shiro.myProperty")))).andReturn(property);
         expect(injector.getInstance(Key.get(String.class, Names.named("shiro.unavailableProperty"))))
                 .andThrow(new ConfigurationException(Collections.singleton(new Message("Not Available!"))));
+        expect(injector.getInstance(BeanTypeListener.MAP_KEY)).andReturn(Collections.EMPTY_MAP).anyTimes();
 
         control.replay();
 

File: web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilter.java
Patch:
@@ -41,7 +41,7 @@ public enum DefaultFilter {
     authc(FormAuthenticationFilter.class),
     authcBasic(BasicHttpAuthenticationFilter.class),
     logout(LogoutFilter.class),
-    noSession(NoSessionCreationFilter.class),
+    noSessionCreation(NoSessionCreationFilter.class),
     perms(PermissionsAuthorizationFilter.class),
     port(PortFilter.class),
     rest(HttpMethodPermissionFilter.class),

File: core/src/main/java/org/apache/shiro/crypto/hash/DefaultHasher.java
Patch:
@@ -153,7 +153,7 @@ public HashResponse computeHash(HashRequest request) {
             publicSaltBytes = null;
         }
         if (publicSaltBytes == null) {
-            getRandomNumberGenerator().nextBytes().getBytes();
+        	publicSaltBytes = getRandomNumberGenerator().nextBytes().getBytes();
         }
 
         String algorithmName = getHashAlgorithmName();

File: web/src/main/java/org/apache/shiro/web/util/WebUtils.java
Patch:
@@ -145,9 +145,9 @@ public static String getRequestUri(HttpServletRequest request) {
      * Tomcat trunk, r939305
      *
      * @param path Relative path to be normalized
-     * 
+     * @return normalized path
      */
-    private static String normalize(String path) {
+    public static String normalize(String path) {
         return normalize(path, true);
     }
 
@@ -161,6 +161,7 @@ private static String normalize(String path) {
      *
      * @param path Relative path to be normalized
      * @param replaceBackSlash Should '\\' be replaced with '/'
+     * @return normalized path
      */
     private static String normalize(String path, boolean replaceBackSlash) {
 

File: core/src/main/java/org/apache/shiro/realm/ldap/JndiLdapRealm.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;
 import org.apache.shiro.authz.AuthorizationException;
 import org.apache.shiro.authz.AuthorizationInfo;
+import org.apache.shiro.ldap.UnsupportedAuthenticationMechanismException;
 import org.apache.shiro.realm.AuthorizingRealm;
 import org.apache.shiro.subject.PrincipalCollection;
 import org.apache.shiro.util.StringUtils;

File: core/src/main/java/org/apache/shiro/subject/support/DelegatingSubject.java
Patch:
@@ -235,6 +235,8 @@ public void checkRole(String role) throws AuthorizationException {
     }
     
     public void checkRoles(String... roleIdentifiers) throws AuthorizationException {
+        assertAuthzCheckPossible();
+        securityManager.checkRoles(getPrincipals(), roleIdentifiers);
     }
 
     public void checkRoles(Collection<String> roles) throws AuthorizationException {

File: core/src/test/java/org/apache/shiro/mgt/VMSingletonDefaultSecurityManagerTest.java
Patch:
@@ -70,6 +70,7 @@ public void testVMSingleton() {
             assertTrue(subject.getSession().getAttribute("key").equals("value"));
         } finally {
             sm.destroy();
+            //SHIRO-270:
             SecurityUtils.setSecurityManager(null);
         }
     }

File: core/src/main/java/org/apache/shiro/authz/aop/AuthorizingAnnotationMethodInterceptor.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.apache.shiro.authz.aop;
 
-import org.apache.shiro.aop.AnnotationHandler;
 import org.apache.shiro.aop.AnnotationMethodInterceptor;
 import org.apache.shiro.aop.AnnotationResolver;
 import org.apache.shiro.aop.MethodInvocation;

File: core/src/main/java/org/apache/shiro/config/IniSecurityManagerFactory.java
Patch:
@@ -173,7 +173,8 @@ private Collection<Realm> getRealms(SecurityManager securityManager) {
     private void addToRealms(Collection<Realm> realms, RealmFactory factory) {
         LifecycleUtils.init(factory);
         Collection<Realm> factoryRealms = factory.getRealms();
-        if (!CollectionUtils.isEmpty(realms)) {
+        //SHIRO-238: check factoryRealms (was 'realms'):
+        if (!CollectionUtils.isEmpty(factoryRealms)) {
             realms.addAll(factoryRealms);
         }
     }

File: core/src/main/java/org/apache/shiro/realm/Realm.java
Patch:
@@ -21,8 +21,6 @@
 import org.apache.shiro.authc.AuthenticationException;
 import org.apache.shiro.authc.AuthenticationInfo;
 import org.apache.shiro.authc.AuthenticationToken;
-import org.apache.shiro.authz.Authorizer;
-
 
 /**
  * A <tt>Realm</tt> is a security component that can access application-specific security entities

File: core/src/main/java/org/apache/shiro/realm/AuthorizingRealm.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.shiro.authc.credential.CredentialsMatcher;
 import org.apache.shiro.authz.AuthorizationException;
 import org.apache.shiro.authz.AuthorizationInfo;
+import org.apache.shiro.authz.Authorizer;
 import org.apache.shiro.authz.Permission;
 import org.apache.shiro.authz.UnauthorizedException;
 import org.apache.shiro.authz.permission.*;
@@ -56,7 +57,7 @@
  * @since 0.2
  */
 public abstract class AuthorizingRealm extends AuthenticatingRealm
-        implements Initializable, PermissionResolverAware, RolePermissionResolverAware {
+        implements Authorizer, Initializable, PermissionResolverAware, RolePermissionResolverAware {
 
     //TODO - complete JavaDoc
 

File: core/src/main/java/org/apache/shiro/realm/Realm.java
Patch:
@@ -62,7 +62,7 @@
  * @see org.apache.shiro.authc.pam.ModularRealmAuthenticator ModularRealmAuthenticator
  * @since 0.1
  */
-public interface Realm extends Authorizer {
+public interface Realm {
 
     /**
      * Returns the (application-unique) name assigned to this <code>Realm</code>. All realms configured for a single

File: core/src/test/java/org/apache/shiro/realm/AuthorizingRealmTest.java
Patch:
@@ -86,7 +86,7 @@ public void testDefaultConfig() {
     @Test
     public void testCreateAccountOverride() {
 
-        Realm realm = new AllowAllRealm() {
+        AuthorizingRealm realm = new AllowAllRealm() {
             @Override
             protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object credentials) {
                 String username = (String) principal;
@@ -107,7 +107,7 @@ protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object cr
 
     @Test
     public void testNullAuthzInfo() {
-        Realm realm = new AuthorizingRealm() {
+	AuthorizingRealm realm = new AuthorizingRealm() {
             protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
                 return null;
             }

File: core/src/test/java/org/apache/shiro/test/ExampleShiroUnitTest.java
Patch:
@@ -1,6 +1,8 @@
 package org.apache.shiro.test;
 
+import org.apache.shiro.mgt.*;
 import org.apache.shiro.subject.Subject;
+import org.apache.shiro.mgt.SecurityManager;
 import org.junit.After;
 import org.junit.Test;
 
@@ -14,10 +16,10 @@ public class ExampleShiroUnitTest extends AbstractShiroTest {
 
     @Test
     public void testSimple() {
-
         //1.  Create a mock Subject instance for the test to run
         //    (for example, as an authenticated Subject):
         Subject subjectUnderTest = createNiceMock(Subject.class);
+
         expect(subjectUnderTest.isAuthenticated()).andReturn(true);
 
         //2. Bind the subject to the current thread:

File: core/src/test/java/org/apache/shiro/subject/DelegatingSubjectTest.java
Patch:
@@ -180,5 +180,4 @@ public void testRunAs() {
         subject.logout();
         LifecycleUtils.destroy(sm);
     }
-    */
 }

File: web/src/test/java/org/apache/shiro/web/servlet/SimpleCookieTest.java
Patch:
@@ -88,8 +88,6 @@ private void testRootContextPath(String contextPath) {
                 .append(SimpleCookie.ATTRIBUTE_DELIMITER)
                 .append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(Cookie.ROOT_PATH)
                 .append(SimpleCookie.ATTRIBUTE_DELIMITER)
-                .append(SimpleCookie.MAXAGE_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(SimpleCookie.DEFAULT_MAX_AGE)
-                .append(SimpleCookie.ATTRIBUTE_DELIMITER)
                 .append(SimpleCookie.HTTP_ONLY_ATTRIBUTE_NAME)
                 .toString();
 

File: core/src/main/java/org/apache/shiro/authc/AuthenticationInfo.java
Patch:
@@ -27,13 +27,13 @@
  * <code>AuthenticationInfo</code> represents a Subject's (aka user's) stored account information relevant to the
  * authentication/log-in process only.
  * <p/>
- * It is important to understand the differnce between this interface and the
+ * It is important to understand the difference between this interface and the
  * {@link AuthenticationToken AuthenticationToken} interface.  <code>AuthenticationInfo</code> implementations
  * represent already-verified and stored account data, whereas an <code>AuthenticationToken</code> represents data
  * submitted for any given login attempt (which may or may not successfully match the verified and stored account
  * <code>AuthenticationInfo</code>).
  * <p/>
- * Because the act of authentication (log-in) is orthoganal to authorization (access control), this interface is
+ * Because the act of authentication (log-in) is orthogonal to authorization (access control), this interface is
  * intended to represent only the account data needed by Shiro during an authentication attempt.  Shiro also
  * has a parallel {@link org.apache.shiro.authz.AuthorizationInfo AuthorizationInfo} interface for use during the
  * authorization process that references access control data such as roles and permissions.

File: core/src/main/java/org/apache/shiro/authc/HostAuthenticationToken.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @since 1.0
  */
-public interface HostAuthenticationToken {
+public interface HostAuthenticationToken extends AuthenticationToken {
 
     /**
      * Returns the host name of the client from where the

File: core/src/main/java/org/apache/shiro/mgt/SessionsSecurityManager.java
Patch:
@@ -128,5 +128,6 @@ public Session getSession(SessionKey key) throws SessionException {
     public void destroy() {
         LifecycleUtils.destroy(getSessionManager());
         this.sessionManager = null;
+        super.destroy();
     }
 }

File: web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilter.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;
 import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;
 import org.apache.shiro.web.filter.authc.UserFilter;
+import org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter;
 import org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;
 import org.apache.shiro.web.filter.authz.PortFilter;
 import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;
@@ -47,6 +48,7 @@ public enum DefaultFilter {
     authcBasic(BasicHttpAuthenticationFilter.class),
     perms(PermissionsAuthorizationFilter.class),
     port(PortFilter.class),
+    rest(HttpMethodPermissionFilter.class),
     roles(RolesAuthorizationFilter.class),
     ssl(SslFilter.class),
     user(UserFilter.class);

File: web/src/test/java/org/apache/shiro/web/servlet/SimpleCookieTest.java
Patch:
@@ -88,6 +88,8 @@ private void testRootContextPath(String contextPath) {
                 .append(SimpleCookie.ATTRIBUTE_DELIMITER)
                 .append(SimpleCookie.PATH_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(Cookie.ROOT_PATH)
                 .append(SimpleCookie.ATTRIBUTE_DELIMITER)
+                .append(SimpleCookie.MAXAGE_ATTRIBUTE_NAME).append(SimpleCookie.NAME_VALUE_DELIMITER).append(SimpleCookie.DEFAULT_MAX_AGE)
+                .append(SimpleCookie.ATTRIBUTE_DELIMITER)
                 .append(SimpleCookie.HTTP_ONLY_ATTRIBUTE_NAME)
                 .toString();
 

File: web/src/main/java/org/apache/shiro/web/mgt/CookieRememberMeManager.java
Patch:
@@ -203,6 +203,9 @@ protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext)
         HttpServletResponse response = WebUtils.getHttpResponse(wsc);
 
         String base64 = getCookie().readValue(request, response);
+        // Browsers do not always remove cookies immediately (SHIRO-183)
+        // ignore cookies that are scheduled for removal
+        if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;
 
         if (base64 != null) {
             base64 = ensurePadding(base64);

File: web/src/main/java/org/apache/shiro/web/servlet/SimpleCookie.java
Patch:
@@ -334,7 +334,7 @@ private static String toCookieDate(Date date) {
 
     public void removeFrom(HttpServletRequest request, HttpServletResponse response) {
         String name = getName();
-        String value = "deleteMe";
+        String value = DELETED_COOKIE_VALUE;
         String comment = null; //don't need to add extra size to the response - comments are irrelevant for deletions
         String domain = getDomain();
         String path = calculatePath(request);

File: core/src/main/java/org/apache/shiro/realm/ldap/JndiLdapContextFactory.java
Patch:
@@ -436,7 +436,7 @@ protected boolean isPoolingConnections(Object principal) {
 
     /**
      * This implementation returns an LdapContext based on the configured JNDI/LDAP environment configuration.
-     * The environmet (Map) used at runtime is created by merging the default/configured
+     * The environnmet (Map) used at runtime is created by merging the default/configured
      * {@link #getEnvironment() environment template} with some runtime values as necessary (e.g. a principal and
      * credential available at runtime only).
      * <p/>
@@ -464,7 +464,7 @@ public LdapContext getLdapContext(Object principal, Object credentials) throws N
 
         Object authcMech = getAuthenticationMechanism();
         if (authcMech == null && (principal != null || credentials != null)) {
-            //No authenticationMechanism has not been set, but either a principal and/or credentials were
+            //authenticationMechanism has not been set, but either a principal and/or credentials were
             //supplied, indicating that at least a 'simple' authentication attempt is indeed occurring - the Shiro
             //end-user just didn't configure it explicitly.  So we set it to be 'simple' here as a convenience;
             //the Sun provider implementation already does this same logic, but by repeating that logic here, we ensure

File: web/src/main/java/org/apache/shiro/web/filter/authz/PortFilter.java
Patch:
@@ -102,12 +102,12 @@ protected boolean onAccessDenied(ServletRequest request, ServletResponse respons
 
         String scheme = getScheme(request.getScheme(), port);
 
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
         sb.append(scheme).append("://");
         sb.append(request.getServerName());
-        if (port != 80 && port != 443) {
+        if (port != DEFAULT_HTTP_PORT && port != SslFilter.DEFAULT_HTTPS_PORT) {
             sb.append(":");
-            sb.append(request.getServerPort());
+            sb.append(port);
         }
         if (request instanceof HttpServletRequest) {
             sb.append(WebUtils.toHttp(request).getRequestURI());

File: core/src/main/java/org/apache/shiro/subject/support/DelegatingSubject.java
Patch:
@@ -233,6 +233,9 @@ public void checkRole(String role) throws AuthorizationException {
         assertAuthzCheckPossible();
         securityManager.checkRole(getPrincipals(), role);
     }
+    
+    public void checkRoles(String... roleIdentifiers) throws AuthorizationException {
+    }
 
     public void checkRoles(Collection<String> roles) throws AuthorizationException {
         assertAuthzCheckPossible();
@@ -456,5 +459,4 @@ private PrincipalCollection popIdentity() {
 
         return popped;
     }
-
 }

File: core/src/test/java/org/apache/shiro/realm/AuthorizingRealmTest.java
Patch:
@@ -249,6 +249,7 @@ protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object cr
             principals.add(USER_ID + USERNAME);
             return new SimpleAuthenticationInfo(principals, PASSWORD, getName());
         }
+
     }
 
 }
\ No newline at end of file

File: core/src/main/java/org/apache/shiro/aop/AnnotationResolver.java
Patch:
@@ -30,7 +30,8 @@ public interface AnnotationResolver {
     /**
      * Returns an {@link Annotation} instance of the specified type based on the given
      * {@link MethodInvocation MethodInvocation} argument, or {@code null} if no annotation
-     * of that type could be found.
+     * of that type could be found. First checks the invoked method itself and if not found, 
+     * then the class for the existence of the same annotation. 
      *
      * @param mi the intercepted method to be invoked.
      * @param clazz the annotation class of the annotation to find.

File: core/src/main/java/org/apache/shiro/aop/DefaultAnnotationResolver.java
Patch:
@@ -58,6 +58,7 @@ public Annotation getAnnotation(MethodInvocation mi, Class<? extends Annotation>
             throw new IllegalArgumentException(msg);
 
         }
-        return m.getAnnotation(clazz);
+        Annotation annotation = m.getAnnotation(clazz);
+        return annotation == null ? mi.getThis().getClass().getAnnotation(clazz) : annotation;
     }
 }

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresAuthentication.java
Patch:
@@ -40,7 +40,7 @@
  *
  * @since 0.9.0
  */
-@Target(ElementType.METHOD)
+@Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface RequiresAuthentication {
 }

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresGuest.java
Patch:
@@ -37,7 +37,7 @@
  *
  * @since 0.9.0
  */
-@Target(ElementType.METHOD)
+@Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface RequiresGuest {
 }

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresPermissions.java
Patch:
@@ -43,15 +43,15 @@
  * @see org.apache.shiro.subject.Subject#checkPermission
  * @since 0.1
  */
-@Target(ElementType.METHOD)
+@Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface RequiresPermissions {
 
     /**
      * The permission string which will be passed to {@link org.apache.shiro.subject.Subject#isPermitted(String)}
      * to determine if the user is allowed to invoke the code protected by this annotation.
      */
-    String value();
+    String[] value();
 
 }
 

File: core/src/main/java/org/apache/shiro/authz/annotation/RequiresUser.java
Patch:
@@ -45,7 +45,7 @@
  *
  * @since 0.9.0
  */
-@Target(ElementType.METHOD)
+@Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface RequiresUser {
 }

File: core/src/main/java/org/apache/shiro/subject/Subject.java
Patch:
@@ -781,7 +781,6 @@ public Builder authenticated(boolean authenticated) {
          * @throws IllegalArgumentException if the {@code attributeKey} is {@code null}.
          * @see SubjectFactory#createSubject(SubjectContext)
          */
-        @SuppressWarnings({"UnusedDeclaration"})
         public Builder contextAttribute(String attributeKey, Object attributeValue) {
             if (attributeKey == null) {
                 String msg = "Subject context map key cannot be null.";

File: support/aspectj/src/main/aspect/org/apache/shiro/aspectj/ShiroAnnotationAuthorizingAspect.java
Patch:
@@ -37,6 +37,9 @@ public class ShiroAnnotationAuthorizingAspect {
                     "execution(@org.apache.shiro.authz.annotation.RequiresRoles * *(..)) || " +
                     "execution(@org.apache.shiro.authz.annotation.RequiresUser * *(..))";
 
+    @Pointcut(pointCupExpression)
+    public void anyShiroAnnotatedMethod(){}
+
     @Pointcut(pointCupExpression)
     void anyShiroAnnotatedMethodCall(JoinPoint thisJoinPoint) {
     }

File: support/aspectj/src/test/java/org/apache/shiro/aspectj/SecuredDummyService.java
Patch:
@@ -19,6 +19,7 @@
 package org.apache.shiro.aspectj;
 
 import org.apache.shiro.authz.annotation.RequiresAuthentication;
+import org.apache.shiro.authz.annotation.RequiresGuest;
 import org.apache.shiro.authz.annotation.RequiresPermissions;
 import org.apache.shiro.authz.annotation.RequiresUser;
 
@@ -42,7 +43,7 @@ public void anonymous() {
         log("anonymous");
     }
 
-    @RequiresAuthentication
+    @RequiresGuest
     public void guest() {
         log("guest");
     }

File: core/src/main/java/org/apache/shiro/session/mgt/SimpleSession.java
Patch:
@@ -500,7 +500,7 @@ private short getAlteredFieldsBitMask() {
         bitMask = stopTimestamp != null ? bitMask | STOP_TIMESTAMP_BIT_MASK : bitMask;
         bitMask = lastAccessTime != null ? bitMask | LAST_ACCESS_TIME_BIT_MASK : bitMask;
         bitMask = timeout != 0l ? bitMask | TIMEOUT_BIT_MASK : bitMask;
-        bitMask = !expired ? bitMask | EXPIRED_BIT_MASK : bitMask;
+        bitMask = expired ? bitMask | EXPIRED_BIT_MASK : bitMask;
         bitMask = host != null ? bitMask | HOST_BIT_MASK : bitMask;
         bitMask = !CollectionUtils.isEmpty(attributes) ? bitMask | ATTRIBUTES_BIT_MASK : bitMask;
         return (short) bitMask;

File: web/src/main/java/org/apache/shiro/web/servlet/SimpleCookie.java
Patch:
@@ -28,6 +28,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
+import java.util.Locale;
 import java.util.TimeZone;
 
 /**
@@ -326,7 +327,7 @@ private void appendHttpOnly(StringBuffer sb, boolean httpOnly) {
      */
     private static String toCookieDate(Date date) {
         TimeZone tz = TimeZone.getTimeZone(GMT_TIME_ZONE_ID);
-        DateFormat fmt = new SimpleDateFormat(COOKIE_DATE_FORMAT_STRING);
+        DateFormat fmt = new SimpleDateFormat(COOKIE_DATE_FORMAT_STRING, Locale.US);
         fmt.setTimeZone(tz);
         return fmt.format(date);
     }

File: web/src/main/java/org/apache/shiro/web/servlet/IniShiroFilter.java
Patch:
@@ -63,7 +63,7 @@
  * #
  * # myRealm = example.pkg.security.MyRealm
  * #
- * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into
+ * # This would instantiate the example.pkg.security.MyRealm class with a default no-arg constructor and inject it into
  * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference
  * # other beans ('$' bean reference notation) while defining Realms and other objects:
  * #
@@ -86,7 +86,7 @@
  * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the
  * # SecurityManager just as the individual Realms are.  For example:
  * #
- * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory
+ * # aRealmFactory = example.pkg.ClassThatImplementsRealmFactory
  * #
  * # --- SessionManager properties ---
  * #

File: support/spring/src/main/java/org/apache/shiro/spring/web/package-info.java
Patch:
@@ -21,4 +21,4 @@
  * 
  * @see ShiroFilterFactoryBean ShiroFilterFactoryBean
  */
-package or.apache.shiro.spring.web;
\ No newline at end of file
+package org.apache.shiro.spring.web;
\ No newline at end of file

File: core/src/test/java/org/apache/shiro/config/IniSecurityManagerFactoryTest.java
Patch:
@@ -92,6 +92,8 @@ public void testGetInstanceWithConfiguredRealm() {
         Ini ini = new Ini();
         Ini.Section section = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
         section.put("propsRealm", PropertiesRealm.class.getName());
+        section.put("propsRealm.resourcePath",
+                "classpath:org/apache/shiro/config/IniSecurityManagerFactoryTest.propsRealm.properties");
 
         IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
         SecurityManager sm = factory.getInstance();

File: core/src/main/java/org/apache/shiro/authz/ModularRealmAuthorizer.java
Patch:
@@ -89,6 +89,7 @@ public Collection<Realm> getRealms() {
     public void setRealms(Collection<Realm> realms) {
         this.realms = realms;
         applyPermissionResolverToRealms();
+        applyRolePermissionResolverToRealms();
     }
 
     /**

File: core/src/main/java/org/apache/shiro/util/ThreadContext.java
Patch:
@@ -40,6 +40,7 @@
  * execution, respectively (i.e. individually explicitly or all via the <tt>clear</tt> method).</p>
  *
  * @author Les Hazlewood
+ * @author Kalle Korhonen
  * @see #remove()
  * @since 0.1
  */

File: core/src/main/java/org/apache/shiro/util/ThreadContext.java
Patch:
@@ -76,7 +76,7 @@ public static Map<Object, Object> getResources() {
      * previously in the ThreadContext - if you need to retain what was on the thread prior to calling this method,
      * call the {@link #getResources()} method, which will give you the existing state.
      *
-     * @param resources the resources to replace the existing {@link #getResources() resources}.
+     * @param newResources the resources to replace the existing {@link #getResources() resources}.
      * @since 1.0
      */
     public static void setResources(Map<Object, Object> newResources) {
@@ -178,8 +178,7 @@ public static Object remove(Object key) {
     }
 
     /**
-     * First {@link #clear clears} the {@code ThreadContext} values and then
-     * {@link ThreadLocal#remove removes} the underlying {@link ThreadLocal ThreadLocal} from the thread.
+     * {@link ThreadLocal#remove Remove}s the underlying {@link ThreadLocal ThreadLocal} from the thread.
      * <p/>
      * This method is meant to be the final 'clean up' operation that is called at the end of thread execution to
      * prevent thread corruption in pooled thread environments.

File: web/src/main/java/org/apache/shiro/web/mgt/CookieRememberMeManager.java
Patch:
@@ -87,6 +87,7 @@ public class CookieRememberMeManager extends AbstractRememberMeManager {
      */
     public CookieRememberMeManager() {
         Cookie cookie = new SimpleCookie(DEFAULT_REMEMBER_ME_COOKIE_NAME);
+        cookie.setHttpOnly(true);
         //One year should be long enough - most sites won't object to requiring a user to log in if they haven't visited
         //in a year:
         cookie.setMaxAge(Cookie.ONE_YEAR);

File: web/src/main/java/org/apache/shiro/web/session/DefaultWebSessionManager.java
Patch:
@@ -50,7 +50,9 @@ public class DefaultWebSessionManager extends DefaultSessionManager implements W
     private boolean sessionIdCookieEnabled;
 
     public DefaultWebSessionManager() {
-        this.sessionIdCookie = new SimpleCookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);
+        Cookie cookie = new SimpleCookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);
+        cookie.setHttpOnly(true); //more secure, protects against XSS attacks
+        this.sessionIdCookie = cookie;
         this.sessionIdCookieEnabled = true;
     }
 

File: web/src/test/java/org/apache/shiro/web/session/DefaultWebSessionManagerTest.java
Patch:
@@ -69,6 +69,7 @@ public void testOnStart() {
         expect(cookie.getPath()).andReturn("/");
         expect(cookie.getVersion()).andReturn(SimpleCookie.DEFAULT_VERSION);
         expect(cookie.isSecure()).andReturn(true);
+        expect(cookie.isHttpOnly()).andReturn(true);
 
         replay(cookie);
 

File: web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java
Patch:
@@ -299,9 +299,10 @@ protected void doFilterInternal(ServletRequest servletRequest, ServletResponse s
         ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);
         ServletResponse response = prepareServletResponse(request, servletResponse, chain);
 
-        ThreadState threadState = bind(request, response);
+        ThreadState threadState = null;
 
         try {
+            threadState = bind(request, response);
             updateSessionLastAccessTime(request, response);
             executeChain(request, response, chain);
         } finally {

File: web/src/main/java/org/apache/shiro/web/mgt/CookieRememberMeManager.java
Patch:
@@ -87,7 +87,6 @@ public class CookieRememberMeManager extends AbstractRememberMeManager {
      */
     public CookieRememberMeManager() {
         Cookie cookie = new SimpleCookie(DEFAULT_REMEMBER_ME_COOKIE_NAME);
-        cookie.setPath(Cookie.ROOT_PATH);
         //One year should be long enough - most sites won't object to requiring a user to log in if they haven't visited
         //in a year:
         cookie.setMaxAge(Cookie.ONE_YEAR);

File: web/src/main/java/org/apache/shiro/web/session/DefaultWebSessionManager.java
Patch:
@@ -51,7 +51,6 @@ public class DefaultWebSessionManager extends DefaultSessionManager implements W
 
     public DefaultWebSessionManager() {
         this.sessionIdCookie = new SimpleCookie(ShiroHttpSession.DEFAULT_SESSION_ID_NAME);
-        this.sessionIdCookie.setPath(Cookie.ROOT_PATH);
         this.sessionIdCookieEnabled = true;
     }
 

File: support/ehcache/src/main/java/org/apache/shiro/cache/ehcache/EhCache.java
Patch:
@@ -51,7 +51,7 @@ public class EhCache<K, V> implements Cache<K, V> {
      *
      * @param cache - delegate EhCache instance this Shiro cache instance will wrap.
      */
-    public EhCache(net.sf.ehcache.Cache cache) {
+    public EhCache(net.sf.ehcache.Ehcache cache) {
         if (cache == null) {
             throw new IllegalArgumentException("Cache argument cannot be null.");
         }

File: core/src/main/java/org/apache/shiro/cache/AbstractCacheManager.java
Patch:
@@ -56,7 +56,7 @@ public AbstractCacheManager() {
      * @throws IllegalArgumentException if the {@code name} argument is {@code null} or does not contain text.
      * @throws CacheException           if there is a problem lazily creating a {@code Cache} instance.
      */
-    public Cache getCache(String name) throws IllegalArgumentException, CacheException {
+    public <K, V> Cache<K, V> getCache(String name) throws IllegalArgumentException, CacheException {
         if (!StringUtils.hasText(name)) {
             throw new IllegalArgumentException("Cache name cannot be null or empty.");
         }
@@ -72,6 +72,7 @@ public Cache getCache(String name) throws IllegalArgumentException, CacheExcepti
             }
         }
 
+        //noinspection unchecked
         return cache;
     }
 

File: core/src/main/java/org/apache/shiro/cache/CacheManager.java
Patch:
@@ -39,5 +39,5 @@ public interface CacheManager {
      * @return the Cache with the given name
      * @throws CacheException if there is an error acquiring the Cache instance.
      */
-    public Cache getCache(String name) throws CacheException;
+    public <K, V> Cache<K, V> getCache(String name) throws CacheException;
 }

File: core/src/main/java/org/apache/shiro/cache/MemoryConstrainedCacheManager.java
Patch:
@@ -43,6 +43,6 @@ public class MemoryConstrainedCacheManager extends AbstractCacheManager {
      */
     @Override
     protected Cache createCache(String name) {
-        return new MapCache(name, new SoftHashMap());
+        return new MapCache<Object, Object>(name, new SoftHashMap<Object, Object>());
     }
 }

File: core/src/main/java/org/apache/shiro/realm/text/IniRealm.java
Patch:
@@ -77,8 +77,6 @@ public void setResourcePath(String resourcePath) {
 
     @Override
     protected void onInit() {
-        // We override init() instead of onInit() because we _don't_ want any caches to be created
-        // (see the superclass init() code).
         // This is an in-memory realm only - no need for an additional cache when we're already
         // as memory-efficient as we can be.
         String resourcePath = getResourcePath();

File: core/src/main/java/org/apache/shiro/session/mgt/DefaultSessionManager.java
Patch:
@@ -62,7 +62,6 @@ public void setSessionDAO(SessionDAO sessionDAO) {
         this.sessionDAO = sessionDAO;
     }
 
-    @SuppressWarnings({"UnusedDeclaration"})
     public SessionDAO getSessionDAO() {
         return this.sessionDAO;
     }

File: core/src/main/java/org/apache/shiro/session/mgt/eis/EnterpriseCacheSessionDAO.java
Patch:
@@ -27,7 +27,6 @@
 import java.io.Serializable;
 import java.util.concurrent.ConcurrentHashMap;
 
-
 /**
  * SessionDAO implementation that relies on an enterprise caching product as the EIS system of record for all sessions.
  * It is expected that an injected {@link org.apache.shiro.cache.Cache Cache} or
@@ -55,8 +54,8 @@ public class EnterpriseCacheSessionDAO extends CachingSessionDAO {
     public EnterpriseCacheSessionDAO() {
         setCacheManager(new AbstractCacheManager() {
             @Override
-            protected Cache createCache(String name) throws CacheException {
-                return new MapCache(name, new ConcurrentHashMap());
+            protected Cache<Serializable, Session> createCache(String name) throws CacheException {
+                return new MapCache<Serializable, Session>(name, new ConcurrentHashMap<Serializable, Session>());
             }
         });
     }

File: web/src/main/java/org/apache/shiro/web/DefaultWebSecurityManager.java
Patch:
@@ -58,10 +58,11 @@ public class DefaultWebSecurityManager extends DefaultSecurityManager implements
     public static final String HTTP_SESSION_MODE = "http";
     public static final String NATIVE_SESSION_MODE = "native";
 
-    private String sessionMode = HTTP_SESSION_MODE; //default
+    private String sessionMode;
 
     public DefaultWebSecurityManager() {
         super();
+        this.sessionMode = HTTP_SESSION_MODE;
         setSubjectFactory(new DefaultWebSubjectFactory());
         setRememberMeManager(new CookieRememberMeManager());
         setSessionManager(new ServletContainerSessionManager());

File: web/src/main/java/org/apache/shiro/web/config/IniFilterChainResolverFactory.java
Patch:
@@ -97,8 +97,8 @@ protected void buildChains(FilterChainManager manager, Ini ini) {
         Ini.Section section = ini.getSection(FILTERS);
 
         if (!CollectionUtils.isEmpty(section)) {
-            String msg = "The [{}] section is being removed in the upcoming release!  Please immediately " +
-                    "move all object configuration (filters and all other objects) to the [{}] section immediately.";
+            String msg = "The [{}] section has been deprecated and will be removed in a future release!  Please " +
+                    "move all object configuration (filters and all other objects) to the [{}] section.";
             log.warn(msg, FILTERS, IniSecurityManagerFactory.MAIN_SECTION_NAME);
         }
 

File: core/src/main/java/org/apache/shiro/mgt/RememberMeManager.java
Patch:
@@ -23,8 +23,7 @@
 import org.apache.shiro.authc.AuthenticationToken;
 import org.apache.shiro.subject.PrincipalCollection;
 import org.apache.shiro.subject.Subject;
-
-import java.util.Map;
+import org.apache.shiro.subject.SubjectContext;
 
 /**
  * A RememberMeManager is responsible for remembering a Subject's identity across that Subject's sessions with
@@ -47,7 +46,7 @@ public interface RememberMeManager {
      * @return he remembered principals or {@code null} if none could be acquired.
      * @since 1.0
      */
-    PrincipalCollection getRememberedPrincipals(Map subjectContext);
+    PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext);
 
     /**
      * Reacts to a successful authentication attempt, typically saving the principals to be retrieved ('remembered')

File: core/src/main/java/org/apache/shiro/subject/support/SubjectThreadState.java
Patch:
@@ -19,7 +19,6 @@
 package org.apache.shiro.subject.support;
 
 import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.subject.DelegatingSubject;
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.util.ThreadContext;
 import org.apache.shiro.util.ThreadState;

File: support/spring/src/test/java/org/apache/shiro/spring/remoting/SecureRemoteInvocationFactoryTest.java
Patch:
@@ -87,7 +87,7 @@ public void testSessionManagerProxyNonStartRemoteInvocation() throws Exception {
 
         verify(mi);
 
-        assertEquals(ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY), dummySessionId);
+        assertEquals(dummySessionId, ri.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY));
     }
 
     /*@Test

File: samples/spring-client/src/main/java/org/apache/shiro/samples/spring/ui/WebStartDriver.java
Patch:
@@ -29,8 +29,11 @@
  * @since 0.1
  */
 public class WebStartDriver {
+    public static String LAUNCH_SESSION_ID;
 
     public static void main(String[] args) {
+        // Store the session id given as argument to a static property to make it available for Spring context 
+        if (args.length > 0) LAUNCH_SESSION_ID = args[0];
         new ClassPathXmlApplicationContext("webstart.spring.xml");
     }
 }

File: core/src/main/java/org/apache/shiro/session/Session.java
Patch:
@@ -85,8 +85,8 @@ public interface Session {
     /**
      * Sets the time in milliseconds that the session may remain idle before expiring.
      * <ul>
-     * <li>A negative return value means the session will never expire.</li>
-     * <li>A non-negative return value (0 or greater) means the session expiration will occur if idle for that
+     * <li>A negative value means the session will never expire.</li>
+     * <li>A non-negative value (0 or greater) means the session expiration will occur if idle for that
      * length of time.</li>
      * </ul>
      * <p/>

File: core/src/main/java/org/apache/shiro/cache/AbstractCacheManager.java
Patch:
@@ -108,6 +108,7 @@ public String toString() {
                 sb.append(", ");
             }
             sb.append(cache.toString());
+            i++;
         }
         sb.append("]");
         return sb.toString();

File: core/src/main/java/org/apache/shiro/mgt/CachingSecurityManager.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.apache.shiro.cache.CacheManager;
 import org.apache.shiro.cache.CacheManagerAware;
-import org.apache.shiro.cache.DefaultCacheManager;
+import org.apache.shiro.cache.MemoryConstrainedCacheManager;
 import org.apache.shiro.util.Destroyable;
 import org.apache.shiro.util.LifecycleUtils;
 
@@ -48,7 +48,7 @@ public abstract class CachingSecurityManager implements SecurityManager, Destroy
      * Default no-arg constructor that will automatically attempt to initialize a default cacheManager
      */
     public CachingSecurityManager() {
-        this.cacheManager = new DefaultCacheManager();
+        this.cacheManager = new MemoryConstrainedCacheManager();
     }
 
     /**
@@ -91,4 +91,5 @@ public void destroy() {
         LifecycleUtils.destroy(getCacheManager());
         this.cacheManager = null;
     }
+
 }

File: core/src/main/java/org/apache/shiro/aop/MethodInvocation.java
Patch:
@@ -70,12 +70,13 @@ public interface MethodInvocation {
      * @return the (possibly null) arguments to be supplied to the method invocation.
      */
     Object[] getArguments();
-    
+
     /**
      * Returns the object that holds the current joinpoint's static part.
      * For instance, the target object for an invocation.
-     *      
+     *
      * @return the object that holds the current joinpoint's static part.
+     * @since 1.0
      */
     Object getThis();
 

File: samples/quickstart/src/main/java/Quickstart.java
Patch:
@@ -43,7 +43,7 @@ public static void main(String[] args) {
 
         // The easiest way to create a Shiro SecurityManager with configured
         // realms, users, roles and permissions is to use the simple INI config.
-        // We'll do that by using a factory that can injest a .ini file and
+        // We'll do that by using a factory that can ingest a .ini file and
         // return a SecurityManager instance:
 
         // Use the shiro.ini file at the root of the classpath

File: core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutorService.java
Patch:
@@ -56,7 +56,7 @@
  *
  * @since 1.0
  */
-public class SubjectAwareExecutorService extends SubjectAwareExecutor implements ExecutorService {
+public abstract class SubjectAwareExecutorService extends SubjectAwareExecutor implements ExecutorService {
 
     private ExecutorService targetExecutorService;
 

File: core/src/main/java/org/apache/shiro/concurrent/SubjectAwareScheduledExecutorService.java
Patch:
@@ -27,7 +27,7 @@
  * Same concept as the {@link SubjectAwareExecutorService} but additionally supports the
  * {@link ScheduledExecutorService} interface.
  */
-public class SubjectAwareScheduledExecutorService extends SubjectAwareExecutorService implements ScheduledExecutorService {
+public abstract class SubjectAwareScheduledExecutorService extends SubjectAwareExecutorService implements ScheduledExecutorService {
 
     private ScheduledExecutorService targetScheduledExecutorService;
 

File: core/src/main/java/org/apache/shiro/mgt/DefaultSubjectFactory.java
Patch:
@@ -103,7 +103,7 @@ protected PrincipalCollection getPrincipals(Map context, Session session) {
         if (CollectionUtils.isEmpty(principals)) {
             //try the session:
             if (session != null) {
-                principals = (PrincipalCollection) session.getAttribute(SessionSubjectBinder.PRINCIPALS_SESSION_KEY);
+                principals = (PrincipalCollection) session.getAttribute(SubjectFactory.PRINCIPALS_SESSION_KEY);
             }
         }
 
@@ -155,7 +155,7 @@ protected boolean isAuthenticated(Map context, Session session) {
         if (!authc) {
             //fall back to a session check:
             if (session != null) {
-                Boolean sessionAuthc = (Boolean) session.getAttribute(SessionSubjectBinder.AUTHENTICATED_SESSION_KEY);
+                Boolean sessionAuthc = (Boolean) session.getAttribute(SubjectFactory.AUTHENTICATED_SESSION_KEY);
                 authc = sessionAuthc != null && sessionAuthc;
             }
         }

File: core/src/main/java/org/apache/shiro/authc/credential/SimpleCredentialsMatcher.java
Patch:
@@ -83,7 +83,7 @@ protected Object getCredentials(AuthenticationInfo info) {
      * <tt>accountCredentials</tt> argument.
      * <p/>
      * <p>If both arguments are either a byte array (byte[]), char array (char[]) or String, they will be both be
-     * converted to raw byte arrays via the {@link #toBytes convertPrincipalsToBytes} method first, and then resulting byte arrays
+     * converted to raw byte arrays via the {@link #toBytes toBytes} method first, and then resulting byte arrays
      * are compared via {@link Arrays#equals(byte[], byte[]) Arrays.equals(byte[],byte[])}.</p>
      * <p/>
      * <p>If either argument cannot be converted to a byte array as described, a simple Object <code>equals</code>

File: core/src/main/java/org/apache/shiro/authc/credential/HashedCredentialsMatcher.java
Patch:
@@ -219,8 +219,8 @@ protected Object getCredentials(AuthenticationToken token) {
      * <p>This implementation's reconstruction effort functions as follows:
      *
      * <ol>
-     * <li>Convert <code>account.getCredentials()</code> to a byte array via the {@link #toBytes toBytes} method.
-     * <li>If <code>account.getCredentials()</code> was originally a String or char[] before <tt>toBytes</tt> was
+     * <li>Convert <code>account.getCredentials()</code> to a byte array via the {@link #toBytes convertPrincipalsToBytes} method.
+     * <li>If <code>account.getCredentials()</code> was originally a String or char[] before <tt>convertPrincipalsToBytes</tt> was
      * called, check for encoding:
      * <li>If {@link #storedCredentialsHexEncoded storedCredentialsHexEncoded}, Hex decode that byte array, otherwise
      * Base64 decode the byte array</li>

File: core/src/main/java/org/apache/shiro/authc/credential/SimpleCredentialsMatcher.java
Patch:
@@ -83,7 +83,7 @@ protected Object getCredentials(AuthenticationInfo info) {
      * <tt>accountCredentials</tt> argument.
      * <p/>
      * <p>If both arguments are either a byte array (byte[]), char array (char[]) or String, they will be both be
-     * converted to raw byte arrays via the {@link #toBytes toBytes} method first, and then resulting byte arrays
+     * converted to raw byte arrays via the {@link #toBytes convertPrincipalsToBytes} method first, and then resulting byte arrays
      * are compared via {@link Arrays#equals(byte[], byte[]) Arrays.equals(byte[],byte[])}.</p>
      * <p/>
      * <p>If either argument cannot be converted to a byte array as described, a simple Object <code>equals</code>

File: core/src/main/java/org/apache/shiro/mgt/SubjectFactory.java
Patch:
@@ -61,7 +61,8 @@ public interface SubjectFactory {
     /**
      * Creates a new Subject instance reflecting the state of the specified contextual data.  The data would be
      * anything required to required to construct a {@code Subject} instance and its contents can vary based on
-     * environment.
+     * environment.  Any data supported by Shiro core will be keyed by one of the static String constants
+     * in this class.
      *
      * @param context the contextual data to be used by the implementation to construct an appropriate {@code Subject}
      *                instance.

File: core/src/main/java/org/apache/shiro/realm/text/IniRealm.java
Patch:
@@ -39,6 +39,8 @@
  * <p/>
  * This class also supports setting the {@link #setResourcePath(String) resourcePath} property to create account
  * data from an .ini resource.  This will only be used if there isn't already account data in the Realm.
+ *
+ * @since 1.0
  */
 public class IniRealm extends TextConfigurationRealm {
 

File: core/src/main/java/org/apache/shiro/session/mgt/SimpleSession.java
Patch:
@@ -89,7 +89,7 @@ public void setStartTimestamp(Date startTimestamp) {
      * <ul>
      * <li>If the user logs out of the system, their current session is terminated (released).</li>
      * <li>If the session expires</li>
-     * <li>The application explicitly calls {@link #stop() destroy()}</li>
+     * <li>The application explicitly calls {@link #stop()}</li>
      * <li>If there is an internal system error and the session state can no longer accurately
      * reflect the user's behavior, such in the case of a system crash</li>
      * </ul>

File: core/src/main/java/org/apache/shiro/subject/Subject.java
Patch:
@@ -434,7 +434,7 @@ public interface Subject {
     void logout();
 
     /**
-     * Associates the specified {@code Runnable} with this {@code Subject} instance and then executes it on the
+     * Associates the specified {@code Callable} with this {@code Subject} instance and then executes it on the
      * currently running thread.  If you want to execute the {@code Callable} on a different thread, it is better to
      * use the {@link #associateWith(Callable)} method instead.
      *

File: web/src/main/java/org/apache/shiro/web/servlet/ShiroFilter.java
Patch:
@@ -530,12 +530,13 @@ protected ServletResponse prepareServletResponse(ServletRequest request, Servlet
      * @since 1.0
      */
     protected ThreadState bind(ServletRequest request, ServletResponse response) {
-        ThreadContext.bind(getSecurityManager());
+        SecurityManager securityManager = getSecurityManager();
+        ThreadContext.bind(securityManager);
         //currently the WebRememberMeManager needs the request/response bound in order to create the subject instance:
         WebUtils.bind(request);
         WebUtils.bind(response);
 
-        WebSubject subject = new WebSubject.Builder().buildWebSubject();
+        WebSubject subject = new WebSubject.Builder(securityManager, request, response).buildWebSubject();
         ThreadState threadState = new WebSubjectThreadState(subject);
         threadState.bind();
         return threadState;

File: web/src/main/java/org/apache/shiro/web/DefaultWebSecurityManager.java
Patch:
@@ -47,7 +47,7 @@
  * @author Les Hazlewood
  * @since 0.2
  */
-public class DefaultWebSecurityManager extends DefaultSecurityManager {
+public class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {
 
     //TODO - complete JavaDoc
 

File: core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
Patch:
@@ -62,6 +62,7 @@ public void sleep(long millis) {
     public void testTimeout() {
         Serializable origId = session.getId();
         assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
+        session.touch();
         session.setTimeout(100);
         assertEquals(100, session.getTimeout());
         sleep(150);

File: core/src/main/java/org/apache/shiro/session/mgt/ExecutorServiceSessionValidationScheduler.java
Patch:
@@ -79,6 +79,8 @@ public boolean isEnabled() {
      * Creates a single thread {@link ScheduledExecutorService} to validate sessions at fixed intervals 
      * and enables this scheduler. The executor is created as a daemon thread to allow JVM to shut down
      */
+    //TODO Implement an integration test to test for jvm exit as part of the standalone example
+    // (so we don't have to change the unit test execution model for the core module)
     public void enableSessionValidation() {
         if (this.interval > 0l) {
             this.service = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {  

File: core/src/main/java/org/apache/shiro/session/Session.java
Patch:
@@ -41,7 +41,7 @@ public interface Session {
      * Returns the unique identifier assigned by the system upon session creation.
      * <p/>
      * All return values from this method are expected to have proper {@code toString()},
-     * {@code equals()}, and {@code hashCode()} implementations. Good candiadates for such
+     * {@code equals()}, and {@code hashCode()} implementations. Good candidates for such
      * an identifier are {@link java.util.UUID UUID}s, {@link java.lang.Integer Integer}s, and
      * {@link java.lang.String String}s.
      *

File: core/src/main/java/org/apache/shiro/config/Ini.java
Patch:
@@ -49,6 +49,9 @@ public Ini() {
 
     public Ini(Ini defaults) {
         this();
+        if (defaults == null) {
+            throw new NullPointerException("Defaults cannot be null.");
+        }
         for (Section section : defaults.getSections()) {
             Section copy = new Section(section);
             this.sections.put(section.getName(), copy);

File: core/src/main/java/org/apache/shiro/crypto/hash/Md2Hash.java
Patch:
@@ -25,8 +25,8 @@
 /**
  * Generates an MD2 Hash (RFC 1319) from a given input <tt>source</tt> with an optional <tt>salt</tt> and
  * hash iterations.
- *
- * <p>See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing
+ * <p/>
+ * See the {@link AbstractHash AbstractHash} parent class JavaDoc for a detailed explanation of Hashing
  * techniques and how the overloaded constructors function.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -307,6 +307,7 @@ public Subject login(Subject subject, AuthenticationToken token) throws Authenti
             throw ae; //propagate
         }
         Subject replaced = createSubject(token, info, subject);
+        //TODO - is binding necessary anymore?  Shouldn't the Builders or Builder callers do this now?
         bind(replaced);
         return replaced;
     }

File: web/src/main/java/org/apache/shiro/web/WebUtils.java
Patch:
@@ -61,7 +61,7 @@ public class WebUtils {
      * Message displayed when a servlet request or response is not bound to the current thread context when expected.
      */
     private static final String NOT_BOUND_ERROR_MESSAGE =
-            "Make sure WebUtils.bind() is being called. (typically called by ShiroFilter)  " +
+            "Make sure WebUtils.bind() is being called. (typically called by AbstractShiroFilter)  " +
                     "This could also happen when running integration tests that don't properly call WebUtils.bind().";
 
     public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + "_SHIRO_THREAD_CONTEXT_KEY";

File: web/src/main/java/org/apache/shiro/web/filter/authc/AnonymousFilter.java
Patch:
@@ -32,7 +32,7 @@
  * For example, if you had a user-only section of a website, you might want to require that access to
  * any url in that section must be from an authenticated user.
  * <p/>
- * Here is how that would look in the ShiroFilter configuration:
+ * Here is how that would look in the IniShiroFilter configuration:
  * <p/>
  * <code>[urls]<br/>
  * /user/** = authc</code>
@@ -59,7 +59,7 @@ public class AnonymousFilter extends PathMatchingFilter {
      * @return <code>true</code> always, allowing unchecked access to the underlying path or resource.
      */
     @Override
-    public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) {
+    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) {
         // Always return true since we allow access to anyone
         return true;
     }

File: web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainResolver.java
Patch:
@@ -45,7 +45,7 @@ public interface FilterChainResolver {
      *
      * @param request       the incoming ServletRequest
      * @param response      the outgoing ServletResponse
-     * @param originalChain the original {@code FilterChain} intercepted by the ShiroFilter.
+     * @param originalChain the original {@code FilterChain} intercepted by the ShiroFilter implementation.
      * @return the filter chain that should be executed for the given request, or {@code null} if the
      *         original chain should be used.
      */

File: web/src/test/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManagerTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.apache.shiro.config.ConfigurationException;
 import org.apache.shiro.web.filter.authz.SslFilter;
-import org.apache.shiro.web.servlet.ShiroFilter;
+import org.apache.shiro.web.servlet.IniShiroFilter;
 import static org.easymock.EasyMock.*;
 import static org.junit.Assert.*;
 import org.junit.Before;
@@ -185,7 +185,7 @@ public void testAddToChainNotPathProcessor() {
         replay(mockFilterConfig);
         this.manager = new DefaultFilterChainManager(mockFilterConfig);
 
-        manager.addFilter("nonPathProcessor", new ShiroFilter());
+        manager.addFilter("nonPathProcessor", new IniShiroFilter());
         manager.createChain("test", "nonPathProcessor");
 
         try {

File: core/src/main/java/org/apache/shiro/util/SoftHashMap.java
Patch:
@@ -249,6 +249,7 @@ public V put(K key, V value) {
         processQueue(); // throw out garbage collected values first
         SoftValue<V, K> sv = new SoftValue<V, K>(value, key, queue);
         SoftValue<V, K> previous = map.put(key, sv);
+        addToStrongReferences(value);
         return previous != null ? previous.get() : null;
     }
 

File: core/src/main/java/org/apache/shiro/util/SoftHashMap.java
Patch:
@@ -36,7 +36,7 @@
  * limitations and garbage collection.  This ensures that the cache will not cause memory leaks by holding strong
  * references to all of its values.
  * <p/>
- * This class is a generics-enabled Map based on initial ideas from Hienz Kabutz's and Sydney Redelinghuys's
+ * This class is a generics-enabled Map based on initial ideas from Heinz Kabutz's and Sydney Redelinghuys's
  * <a href="http://www.javaspecialists.eu/archive/Issue015.html">publicly posted version</a>, with continued
  * modifications.
  * <p/>

File: core/src/main/java/org/apache/shiro/subject/PrincipalCollection.java
Patch:
@@ -41,7 +41,7 @@
 public interface PrincipalCollection extends Iterable, Serializable {
 
     /**
-     * Returns the primary principal used to uniquely identify the owning account/Subject.
+     * Returns the primary principal used application-wide to uniquely identify the owning account/Subject.
      * <p/>
      * The value is usually always a uniquely identifying attribute specific to the data source that retrieved the
      * account data.  Some examples:

File: core/src/main/java/org/apache/shiro/subject/Subject.java
Patch:
@@ -63,7 +63,7 @@
 public interface Subject {
 
     /**
-     * Returns this Subject's uniquely-identifying principal, or {@code null} if this
+     * Returns this Subject's application-wide uniquely identifying principal, or {@code null} if this
      * Subject doesn't yet have account data associated with it (for example, if they haven't logged in).
      * <p/>
      * The term <em>principal</em> is just a fancy security term for any identifying attribute(s) of an application
@@ -490,7 +490,7 @@ public interface Subject {
      * <code>Subject.{@link #Builder(org.apache.shiro.mgt.SecurityManager) Builder(securityManager)}</code>
      * constructor if desired.
      * <p/>
-     * All other methods may be called before {@link #buildSubject() buildSubject()} call to
+     * All other methods may be called before the {@link #buildSubject() buildSubject()} method to
      * provide context on how to construct the {@code Subject} instance.  For example, if you have a session id and
      * want to acquire the {@code Subject} that 'owns' that session (assuming the session exists and is not expired):
      * <pre>
@@ -520,7 +520,7 @@ public static class Builder {
         /**
          * The SecurityManager to invoke during the {@link #buildSubject} call.
          */
-        private final org.apache.shiro.mgt.SecurityManager securityManager;
+        private final SecurityManager securityManager;
 
         /**
          * Constructs a new {@link Subject.Builder} instance, using the {@code SecurityManager} instance available

File: web/src/main/java/org/apache/shiro/web/filter/authz/AuthorizationFilter.java
Patch:
@@ -115,7 +115,7 @@ protected boolean onAccessDenied(ServletRequest request, ServletResponse respons
         } else {
             // If subject is known but not authorized, redirect to the unauthorized URL if there is one
             // If no unauthorized URL is specified, just return an unauthorized HTTP status code
-            WebUtils.toHttp(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+            WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);
             if (StringUtils.hasText(getUnauthorizedUrl())) {
                 WebUtils.issueRedirect(request, response, getUnauthorizedUrl());
             }

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -496,7 +496,7 @@ public void logout(Subject subject) {
 
         if (principals != null && !principals.isEmpty()) {
             if (log.isDebugEnabled()) {
-                log.debug("Logging out subject with primary id {}" + principals.iterator().next());
+                log.debug("Logging out subject with primary principal {}" + principals.getPrimaryPrincipal());
             }
             beforeLogout(principals);
             Authenticator authc = getAuthenticator();

File: core/src/main/java/org/apache/shiro/subject/DelegatingSubject.java
Patch:
@@ -138,7 +138,7 @@ public InetAddress getInetAddress() {
 
     protected Object getPrimaryPrincipal(PrincipalCollection principals) {
         if (!CollectionUtils.isEmpty(principals)) {
-            return principals.iterator().next();
+            return principals.getPrimaryPrincipal();
         }
         return null;
     }

File: core/src/test/java/org/apache/shiro/realm/AuthorizingRealmTest.java
Patch:
@@ -86,7 +86,7 @@ public void testDefaultConfig() {
         assertNotNull(info);
         assertTrue(realm.hasRole(info.getPrincipals(), ROLE));
 
-        Object principal = info.getPrincipals().iterator().next();
+        Object principal = info.getPrincipals().getPrimaryPrincipal();
         assertTrue(principal instanceof UserIdPrincipal);
 
         UsernamePrincipal usernamePrincipal = info.getPrincipals().oneByType(UsernamePrincipal.class);
@@ -114,7 +114,7 @@ protected AuthenticationInfo buildAuthenticationInfo(Object principal, Object cr
         AuthenticationInfo info = realm.getAuthenticationInfo(new UsernamePasswordToken(USERNAME, PASSWORD, localhost));
         assertNotNull(info);
         assertTrue(realm.hasRole(info.getPrincipals(), ROLE));
-        Object principal = info.getPrincipals().iterator().next();
+        Object principal = info.getPrincipals().getPrimaryPrincipal();
         assertTrue(principal instanceof UsernamePrincipal);
         assertEquals(USERNAME, ((UsernamePrincipal) principal).getUsername());
 

File: web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainManager.java
Patch:
@@ -116,7 +116,7 @@ public interface FilterChainManager {
      * The {@code chainDefinition} method argument is expected to conform to the following format:
      * <pre>
      * filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]</pre>
-     * Where
+     * where
      * <ol>
      * <li>{@code filterN} is the name of a filter previously
      * {@link #addFilter(String, javax.servlet.Filter) registered} with the manager, and</li>
@@ -131,7 +131,7 @@ public interface FilterChainManager {
      * <h3>Examples</h3>
      * <pre>/account/** = authcBasic</pre>
      * This example says &quot;Create a filter named '{@code /account/**}' consisting of only the '{@code authcBasic}'
-     * filter.&quot;.  Also because the {@code authcBasic} filter does not need any path-specific
+     * filter&quot;.  Also because the {@code authcBasic} filter does not need any path-specific
      * config, it doesn't have any config brackets {@code []}.
      * <p/>
      * <pre>/remoting/** = authcBasic, roles[b2bClient], perms[&quot;remote:invoke:wan,lan&quot;]</pre>

File: web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManager.java
Patch:
@@ -50,9 +50,9 @@ public class DefaultFilterChainManager implements FilterChainManager {
 
     private FilterConfig filterConfig;
 
-    private Map<String, Filter> filters; //pool of filters available for creating filters
+    private Map<String, Filter> filters; //pool of filters available for creating chains
 
-    private Map<String, NamedFilterList> filterChains; //name to filter chain mapping
+    private Map<String, NamedFilterList> filterChains; //key: chain name, value: chain
 
     public DefaultFilterChainManager() {
         this.filters = new LinkedHashMap<String, Filter>();

File: web/src/test/java/org/apache/shiro/web/AbstractWebSecurityManagerTest.java
Patch:
@@ -22,7 +22,6 @@
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.util.ThreadContext;
 import org.apache.shiro.web.subject.WebSubject;
-import org.apache.shiro.web.subject.WebSubjectBuilder;
 import org.apache.shiro.web.subject.support.WebSubjectThreadState;
 import org.junit.After;
 
@@ -40,7 +39,9 @@ public void tearDown() {
     }
 
     protected Subject newSubject(SecurityManager sm, ServletRequest request, ServletResponse response) {
-        WebSubject subject = new WebSubjectBuilder(sm, request, response).buildWebSubject();
+        WebUtils.bind(request);
+        WebUtils.bind(response);
+        WebSubject subject = new WebSubject.Builder(sm, request, response).buildWebSubject();
         WebSubjectThreadState threadState = new WebSubjectThreadState(subject);
         threadState.bind();
         return subject;

File: core/src/main/java/org/apache/shiro/mgt/SecurityManager.java
Patch:
@@ -128,7 +128,4 @@ public interface SecurityManager extends Authenticator, Authorizer, SessionManag
      */
     Subject createSubject(Map context);
 
-    //Subject getSubjectBySessionId(Serializable sessionId);
-
-    //Subject getSubject(PrincipalCollection principals);
 }

File: core/src/main/java/org/apache/shiro/subject/DelegatingSubject.java
Patch:
@@ -242,7 +242,7 @@ public void checkRoles(Collection<String> roles) throws AuthorizationException {
     }
 
     public void login(AuthenticationToken token) throws AuthenticationException {
-        Subject subject = securityManager.login(token);
+        Subject subject = securityManager.login(this, token);
         PrincipalCollection principals = subject.getPrincipals();
         if (principals == null || principals.isEmpty()) {
             String msg = "Principals returned from securityManager.login( token ) returned a null or " +

File: core/src/main/java/org/apache/shiro/subject/SubjectBuilder.java
Patch:
@@ -95,7 +95,7 @@ public SubjectBuilder setAuthenticated(boolean authenticated) {
     }
 
     public Subject buildSubject() {
-        return this.securityManager.getSubject(this.subjectContext);
+        return this.securityManager.createSubject(this.subjectContext);
     }
 
 

File: core/src/test/java/org/apache/shiro/mgt/DefaultSecurityManagerTest.java
Patch:
@@ -26,7 +26,6 @@
 import org.apache.shiro.session.Session;
 import org.apache.shiro.session.mgt.AbstractValidatingSessionManager;
 import org.apache.shiro.subject.Subject;
-import org.apache.shiro.util.ThreadContext;
 import org.junit.After;
 import static org.junit.Assert.*;
 import org.junit.Before;
@@ -45,7 +44,6 @@ public class DefaultSecurityManagerTest extends AbstractSecurityManagerTest {
 
     @Before
     public void setup() {
-        ThreadContext.clear();
         sm = new DefaultSecurityManager();
         sm.setRealm(new PropertiesRealm());
         SecurityUtils.setSecurityManager(sm);

File: support/spring/src/main/java/org/apache/shiro/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -101,7 +101,7 @@ public Object invoke(RemoteInvocation invocation, Object targetObject) throws No
                 }
             }
 
-            Subject subject = securityManager.getSubject(context);
+            Subject subject = securityManager.createSubject(context);
             subjectThreadState = new SubjectThreadState(subject);
             subjectThreadState.bind();
 

File: core/src/main/java/org/apache/shiro/package-info.java
Patch:
@@ -21,4 +21,4 @@
  * by applications, {@link org.apache.shiro.SecurityUtils SecurityUtils} and
  * {@link org.apache.shiro.ShiroException ShiroException}.
  */
-package org.shiro;
+package org.apache.shiro;

File: core/src/main/java/org/apache/shiro/mgt/SessionsSecurityManager.java
Patch:
@@ -136,9 +136,9 @@ public void setSessionDAO(SessionDAO sessionDAO) {
         if (sm instanceof SessionDAOAware) {
             ((SessionDAOAware) sm).setSessionDAO(sessionDAO);
         } else {
-            String msg = "The underlying session manager is null or does not implement the " +
-                    SessionDAO.class.getName() + " interface, which is required if the underlying " +
-                    "instance is to receive the sessionDAO argument.";
+            String msg = "The underlying SessionManager is null or does not implement the " +
+                    SessionDAOAware.class.getName() + " interface, which is required if it is " +
+                    "to receive the sessionDAO argument.";
             throw new IllegalArgumentException(msg);
         }
     }

File: web/src/test/java/org/apache/shiro/web/DefaultWebSecurityManagerTest.java
Patch:
@@ -92,7 +92,7 @@ public void testSessionTimeout() {
         assertEquals(session.getTimeout(), globalTimeout);
         session.setTimeout(125);
         assertEquals(session.getTimeout(), 125);
-        sleep(150);
+        sleep(200);
         try {
             session.getTimeout();
             fail("Session should have expired.");

File: core/src/main/java/org/apache/shiro/realm/AuthorizingRealm.java
Patch:
@@ -261,7 +261,7 @@ protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals)
         Cache authzCache = getAuthorizationCache();
         if (authzCache != null) {
             if (log.isTraceEnabled()) {
-                log.trace("Attempting to retrieve the AuthorizationIfno from cache.");
+                log.trace("Attempting to retrieve the AuthorizationInfo from cache.");
             }
             Object key = getAuthorizationCacheKey(principals);
             info = (AuthorizationInfo) authzCache.get(key);

File: core/src/main/java/org/apache/shiro/session/mgt/DefaultSessionManager.java
Patch:
@@ -20,8 +20,8 @@
 
 import org.apache.shiro.cache.CacheManager;
 import org.apache.shiro.cache.CacheManagerAware;
-import org.apache.shiro.session.InvalidSessionException;
 import org.apache.shiro.session.Session;
+import org.apache.shiro.session.UnknownSessionException;
 import org.apache.shiro.session.mgt.eis.MemorySessionDAO;
 import org.apache.shiro.session.mgt.eis.SessionDAO;
 import org.apache.shiro.session.mgt.eis.SessionDAOAware;
@@ -194,11 +194,11 @@ protected void onChange(Session session) {
         sessionDAO.update(session);
     }
 
-    protected Session retrieveSession(Serializable sessionId) throws InvalidSessionException {
+    protected Session retrieveSession(Serializable sessionId) throws UnknownSessionException {
         return retrieveSessionFromDataSource(sessionId);
     }
 
-    protected Session retrieveSessionFromDataSource(Serializable sessionId) throws InvalidSessionException {
+    protected Session retrieveSessionFromDataSource(Serializable sessionId) throws UnknownSessionException {
         return sessionDAO.readSession(sessionId);
     }
 

File: core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
Patch:
@@ -118,8 +118,6 @@ public void onExpiration(Session session) {
 
     @Test
     public void testSessionDeleteOnExpiration() {
-
-        sm.setAutoCreateWhenInvalid(false);
         sm.setGlobalSessionTimeout(100);
 
         SessionDAO sessionDAO = createMock(SessionDAO.class);

File: core/src/main/java/org/apache/shiro/session/SessionListener.java
Patch:
@@ -19,7 +19,7 @@
 package org.apache.shiro.session;
 
 /**
- * Interface to be implemented by components that wish to be notified of events that occur during a 
+ * Interface to be implemented by components that wish to be notified of events that occur during a
  * {@link Session Session}'s lifecycle.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/shiro/mgt/SessionSubjectBinder.java
Patch:
@@ -77,8 +77,8 @@ public class SessionSubjectBinder extends ThreadContextSubjectBinder {
 
     @Override
     public void bind(Subject subject) {
-        bindToSession(subject);
         super.bind(subject);
+        bindToSession(subject);
     }
 
     protected void bindToSession(Subject subject) {

File: core/src/main/java/org/apache/shiro/mgt/SubjectFactory.java
Patch:
@@ -30,6 +30,8 @@
  */
 public interface SubjectFactory {
 
+    public static final String SESSION_ID = SubjectFactory.class.getName() + ".SESSION_ID";
+
     public static final String AUTHENTICATION_TOKEN = SubjectFactory.class.getName() + ".AUTHENTICATION_TOKEN";
 
     public static final String AUTHENTICATION_INFO = SubjectFactory.class.getName() + ".AUTHENTICATION_INFO";

File: core/src/main/java/org/apache/shiro/session/mgt/DefaultSessionManager.java
Patch:
@@ -195,9 +195,6 @@ protected void onChange(Session session) {
     }
 
     protected Session retrieveSession(Serializable sessionId) throws InvalidSessionException {
-        if (log.isTraceEnabled()) {
-            log.trace("Attempting to retrieve session with id [" + sessionId + "]");
-        }
         return retrieveSessionFromDataSource(sessionId);
     }
 

File: core/src/main/java/org/apache/shiro/subject/DelegatingSubject.java
Patch:
@@ -75,7 +75,7 @@ public class DelegatingSubject implements Subject {
     protected InetAddress inetAddress = null;
     protected Session session = null;
 
-    protected SecurityManager securityManager;
+    protected transient SecurityManager securityManager;
 
     public DelegatingSubject(SecurityManager securityManager) {
         this(null, false, null, null, securityManager);

File: core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
Patch:
@@ -63,7 +63,7 @@ public void testTimeout() {
         Serializable origId = session.getId();
         assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
         session.setTimeout(100);
-        assertEquals(session.getTimeout(), 100);
+        assertEquals(100, session.getTimeout());
         sleep(150);
         //now the underlying session should have been expired and a new one replaced by default.
         //so ensure the replaced session has the default session timeout:

File: core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
Patch:
@@ -81,7 +81,6 @@ public void testSessionDeleteOnExpiration() {
         String sessionId1 = UUID.randomUUID().toString();
         final SimpleSession session1 = new SimpleSession();
         session1.setId(sessionId1);
-        System.out.println("Session id 1: " + sessionId1);
 
         final Session[] activeSession = new SimpleSession[]{session1};
         sm.setSessionFactory(new SessionFactory() {

File: core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java
Patch:
@@ -509,7 +509,7 @@ public Subject getSubject() {
      * @see org.apache.shiro.authz.HostUnauthorizedException
      * @since 1.0
      */
-    private Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {
+    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {
         Session session = getSession(sessionId);
 
         Map<String, Object> context = new HashMap<String, Object>(1);

File: core/src/main/java/org/apache/shiro/session/UnknownSessionException.java
Patch:
@@ -71,7 +71,9 @@ public UnknownSessionException(String message, Throwable cause) {
      * @param sessionId the session id given that is unknown to the system.
      */
     public UnknownSessionException(Serializable sessionId) {
-        super(sessionId);
+        super("Unable to locate session with id [" + sessionId + "] either because it is an invalid id " +
+                "or the session has been deleted due to invalidation (stopped, logged out, or expired).",
+                sessionId);
     }
 
     /**

File: core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
Patch:
@@ -63,7 +63,7 @@ public void testTimeout() {
         Serializable origId = session.getId();
         assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
         session.setTimeout(100);
-        assertEquals(100, session.getTimeout());
+        assertEquals(session.getTimeout(), 100);
         sleep(150);
         //now the underlying session should have been expired and a new one replaced by default.
         //so ensure the replaced session has the default session timeout:

File: core/src/main/java/org/apache/shiro/session/mgt/AbstractSessionManager.java
Patch:
@@ -121,6 +121,7 @@ public Serializable start(Map initData) throws AuthorizationException {
 
     protected void applyGlobalSessionTimeout(Session session) {
         session.setTimeout(getGlobalSessionTimeout());
+        onChange(session);
     }
 
     /**

File: core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
Patch:
@@ -44,11 +44,11 @@ public void testTimeout() {
         Serializable origId = session.getId();
         assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
         session.setTimeout(100);
-        assertEquals(session.getTimeout(), 100);
-        sleep(100);
+        assertEquals(100, session.getTimeout());
+        sleep(150);
         //now the underlying session should have been expired and a new one replaced by default.
         //so ensure the replaced session has the default session timeout:
-        assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
+        assertEquals(AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT, session.getTimeout());
         assertFalse(origId.equals(session.getId())); //new ID would have been generated
     }
 

File: web/src/test/java/org/apache/shiro/web/DefaultWebSecurityManagerTest.java
Patch:
@@ -91,7 +91,7 @@ public void testSessionTimeout() {
         assertEquals(session.getTimeout(), globalTimeout);
         session.setTimeout(100);
         assertEquals(session.getTimeout(), 100);
-        sleep(100);
+        sleep(150);
         //now the underlying session should have been expired and a new one replaced by default.
         //so ensure the replaced session has the default session timeout:
         assertEquals(session.getTimeout(), globalTimeout);

File: core/src/main/java/org/apache/shiro/mgt/SessionSubjectBinder.java
Patch:
@@ -55,7 +55,7 @@
  * </ol>
  * <p/>
  * Indeed this is exactly how Shiro's default behavior works in enterprise server and web-based environments.  It is
- * enabled in the <code>KiFilter</code> for web-based environments as well as remote-method-invocation-based
+ * enabled in the <code>ShiroFilter</code> for web-based environments as well as remote-method-invocation-based
  * components for non-web environments.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/shiro/package-info.java
Patch:
@@ -19,6 +19,6 @@
 /**
  * This package primarily exists as a root classpath distinction, but it does contain two core classes widely used
  * by applications, {@link org.apache.shiro.SecurityUtils SecurityUtils} and
- * {@link org.apache.shiro.ShiroException KiException}.
+ * {@link org.apache.shiro.ShiroException ShiroException}.
  */
 package org.shiro;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/dao/BootstrapDataPopulator.java
Patch:
@@ -16,10 +16,10 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.dao;
+package org.apache.shiro.samples.sprhib.dao;
 
-import org.hibernate.SessionFactory;
 import org.apache.shiro.crypto.hash.Sha256Hash;
+import org.hibernate.SessionFactory;
 import org.springframework.beans.factory.InitializingBean;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.jdbc.core.JdbcTemplate;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/dao/HibernateDao.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.dao;
+package org.apache.shiro.samples.sprhib.dao;
 
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/dao/HibernateUserDAO.java
Patch:
@@ -16,9 +16,9 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.dao;
+package org.apache.shiro.samples.sprhib.dao;
 
-import org.jsecurity.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.model.User;
 import org.springframework.stereotype.Repository;
 import org.springframework.util.Assert;
 

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/dao/UserDAO.java
Patch:
@@ -16,9 +16,9 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.dao;
+package org.apache.shiro.samples.sprhib.dao;
 
-import org.jsecurity.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.model.User;
 
 import java.util.List;
 

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/model/Role.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.model;
+package org.apache.shiro.samples.sprhib.model;
 
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.CacheConcurrencyStrategy;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/model/User.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.model;
+package org.apache.shiro.samples.sprhib.model;
 
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.CacheConcurrencyStrategy;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/service/DefaultUserService.java
Patch:
@@ -16,12 +16,12 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.service;
+package org.apache.shiro.samples.sprhib.service;
 
 import org.apache.shiro.SecurityUtils;
 import org.apache.shiro.crypto.hash.Sha256Hash;
-import org.jsecurity.samples.sprhib.dao.UserDAO;
-import org.jsecurity.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.dao.UserDAO;
+import org.apache.shiro.samples.sprhib.model.User;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/service/UserService.java
Patch:
@@ -16,9 +16,9 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.service;
+package org.apache.shiro.samples.sprhib.service;
 
-import org.jsecurity.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.model.User;
 
 import java.util.List;
 

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/CurrentUserInterceptor.java
Patch:
@@ -16,10 +16,10 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
-import org.jsecurity.samples.sprhib.model.User;
-import org.jsecurity.samples.sprhib.service.UserService;
+import org.apache.shiro.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.service.UserService;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Component;
 import org.springframework.web.servlet.ModelAndView;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/EditUserCommand.java
Patch:
@@ -16,10 +16,10 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.apache.shiro.crypto.hash.Sha256Hash;
-import org.jsecurity.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.model.User;
 import org.springframework.util.Assert;
 import org.springframework.util.StringUtils;
 

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/EditUserValidator.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.apache.shiro.util.StringUtils;
 import org.springframework.validation.Errors;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/HomeController.java
Patch:
@@ -16,9 +16,9 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
-import org.jsecurity.samples.sprhib.service.UserService;
+import org.apache.shiro.samples.sprhib.service.UserService;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Controller;
 import org.springframework.ui.Model;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/LoginCommand.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 /**
  * Command binding object for logging in.

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/LoginValidator.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.springframework.validation.Errors;
 import org.springframework.validation.ValidationUtils;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/ManageUsersController.java
Patch:
@@ -16,11 +16,11 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.apache.shiro.authz.annotation.RequiresPermissions;
-import org.jsecurity.samples.sprhib.model.User;
-import org.jsecurity.samples.sprhib.service.UserService;
+import org.apache.shiro.samples.sprhib.model.User;
+import org.apache.shiro.samples.sprhib.service.UserService;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Controller;
 import org.springframework.ui.Model;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/SecurityController.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.apache.shiro.SecurityUtils;
 import org.apache.shiro.authc.AuthenticationException;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/SignupCommand.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 /**
  * Command binding object for signing up for a new account. 

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/SignupController.java
Patch:
@@ -16,11 +16,11 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.apache.shiro.SecurityUtils;
 import org.apache.shiro.authc.UsernamePasswordToken;
-import org.jsecurity.samples.sprhib.service.UserService;
+import org.apache.shiro.samples.sprhib.service.UserService;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Controller;
 import org.springframework.ui.Model;

File: samples/spring-hibernate/src/main/java/org/apache/shiro/samples/sprhib/web/SignupValidator.java
Patch:
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.jsecurity.samples.sprhib.web;
+package org.apache.shiro.samples.sprhib.web;
 
 import org.apache.shiro.util.StringUtils;
 import org.springframework.validation.Errors;

File: support/spring/src/main/java/org/apache/shiro/spring/SpringShiroFilter.java
Patch:
@@ -22,13 +22,13 @@
 
 
 /**
- * Extension of KiFilter that uses {@link SpringIniWebConfiguration} to configure Shiro in a Spring web
+ * Extension of ShiroFilter that uses {@link SpringIniWebConfiguration} to configure Shiro in a Spring web
  * environment.
  * <p/>
  * Using this class in web.xml essentially enables the following:
  * <pre>&lt;filter&gt;
- * &lt;filter-name&gt;KiFilter&lt;/filter-name&gt;
- * &lt;filter-class&gt;org.apache.shiro.web.servlet.KiFilter&lt;/filter-class&gt;
+ * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
+ * &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;
  * &lt;init-param&gt;
  *     &lt;param-name&gt;configClassName&lt;/param-name&gt;
  *     &lt;param-value&gt;org.apache.shiro.spring.SpringIniWebConfiguration&lt;param-value&gt;

File: web/src/main/java/org/apache/shiro/web/config/WebConfiguration.java
Patch:
@@ -18,13 +18,13 @@
  */
 package org.apache.shiro.web.config;
 
+import org.apache.shiro.config.Configuration;
+
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 
-import org.apache.shiro.config.Configuration;
-
 /**
  * A <code>WebConfiguration</code> configures Shiro components in a web-enabled application.
  * <p/>
@@ -50,7 +50,7 @@ public interface WebConfiguration extends Configuration {
      *
      * @param request       the incoming ServletRequest
      * @param response      the outgoing ServletResponse
-     * @param originalChain the original <code>FilterChain</code> intercepted by the KiFilter.
+     * @param originalChain the original <code>FilterChain</code> intercepted by the ShiroFilter.
      * @return the filter chain that should be executed for the given request, or <code>null</code> if the
      *         original chain should be used.
      */

File: web/src/main/java/org/apache/shiro/web/filter/authc/AnonymousFilter.java
Patch:
@@ -18,11 +18,11 @@
  */
 package org.apache.shiro.web.filter.authc;
 
+import org.apache.shiro.web.filter.PathMatchingFilter;
+
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 
-import org.apache.shiro.web.filter.PathMatchingFilter;
-
 /**
  * Filter that allows access to a path immeidately without performing security checks of any kind.
  * <p/>
@@ -32,7 +32,7 @@
  * For example, if you had a user-only section of a website, you might want to require that access to
  * any url in that section must be from an authenticated user.
  * <p/>
- * Here is how that would look in the KiFilter configuration:
+ * Here is how that would look in the ShiroFilter configuration:
  * <p/>
  * <code>[urls]<br/>
  * /user/** = authc</code>

File: core/src/main/java/org/apache/ki/session/mgt/DefaultSessionManager.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.ki.session.Session;
 import org.apache.ki.session.mgt.eis.MemorySessionDAO;
 import org.apache.ki.session.mgt.eis.SessionDAO;
+import org.apache.ki.session.mgt.eis.SessionDAOAware;
 import org.apache.ki.util.CollectionUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -42,7 +43,7 @@
  * @since 0.1
  */
 public class DefaultSessionManager extends AbstractValidatingSessionManager
-        implements CacheManagerAware, SessionFactoryAware {
+        implements CacheManagerAware, SessionFactoryAware, SessionDAOAware {
 
     //TODO - complete JavaDoc
 
@@ -126,7 +127,7 @@ protected Session createSessionFromFactory(InetAddress originatingHost) {
      * delegates and calls
      * <code>this.{@link SessionDAO sessionDAO}.{@link SessionDAO#create(org.apache.ki.session.Session) create}(session);<code>
      *
-     * @param session
+     * @param session the Session instance to persist to the underlying EIS.
      */
     protected void create(Session session) {
         if (log.isDebugEnabled()) {

File: web/src/main/java/org/apache/ki/web/DefaultWebSecurityManager.java
Patch:
@@ -182,7 +182,6 @@ protected void beforeLogout(PrincipalCollection subjectIdentifier) {
         super.beforeLogout(subjectIdentifier);
         //also ensure a request attribute is set so the Subject is not reacquired later during the request:
         removeRequestIdentity();
-
     }
 
     protected void removeRequestIdentity() {

File: web/src/main/java/org/apache/ki/web/filter/authc/FormAuthenticationFilter.java
Patch:
@@ -63,7 +63,7 @@ public class FormAuthenticationFilter extends AuthenticatingFilter {
 
     //TODO - complete JavaDoc
 
-    public static final String DEFAULT_ERROR_KEY_ATTRIBUTE_NAME = "ki.authenticationExceptionClassName";
+    public static final String DEFAULT_ERROR_KEY_ATTRIBUTE_NAME = "kiLoginFailure";
 
     public static final String DEFAULT_USERNAME_PARAM = "username";
     public static final String DEFAULT_PASSWORD_PARAM = "password";

File: web/src/main/java/org/apache/ki/web/filter/authc/FormAuthenticationFilter.java
Patch:
@@ -63,7 +63,7 @@ public class FormAuthenticationFilter extends AuthenticatingFilter {
 
     //TODO - complete JavaDoc
 
-    public static final String DEFAULT_ERROR_KEY_ATTRIBUTE_NAME = "jsecLoginFailure";
+    public static final String DEFAULT_ERROR_KEY_ATTRIBUTE_NAME = "ki.authenticationExceptionClassName";
 
     public static final String DEFAULT_USERNAME_PARAM = "username";
     public static final String DEFAULT_PASSWORD_PARAM = "password";

File: web/src/main/java/org/apache/ki/web/servlet/KiHttpServletRequest.java
Patch:
@@ -95,9 +95,6 @@ public String getRemoteUser() {
     }
 
     protected Subject getSubject() {
-        if ( isLoggedOut() ) {
-            return null;
-        }
         return SecurityUtils.getSubject();
     }
 

File: web/src/main/java/org/apache/ki/web/DefaultWebSecurityManager.java
Patch:
@@ -154,6 +154,8 @@ public void setSessionMode(String sessionMode) {
             LifecycleUtils.destroy(getSessionManager());
             WebSessionManager sessionManager = createSessionManager(mode);
             setSessionManager(sessionManager);
+            //the factory needs to reflect this new SessionManager:
+            setSubjectFactory(new WebSubjectFactory(this,sessionManager));
         }
     }
 

File: core/src/main/java/org/apache/ki/aop/MethodInterceptor.java
Patch:
@@ -40,7 +40,7 @@
 /**
  * A <tt>MethodInterceptor</tt> intercepts a <tt>MethodInvocation</tt> to perform before or after logic (aka 'advice').
  *
- * <p>Apache Ki's implementations of this interface mostly have to deal with ensuring a current Subject has the
+ * <p>Ki's implementations of this interface mostly have to deal with ensuring a current Subject has the
  * ability to execute the method before allowing it to continue.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/aop/MethodInterceptorSupport.java
Patch:
@@ -42,7 +42,7 @@
 
 
 /**
- * This class is an abstraction of AOP method interceptor behavior specific to Apache Ki that
+ * This class is an abstraction of AOP method interceptor behavior specific to Ki that
  * leaves AOP implementation specifics to be handled by subclass implementations.  This implementation primarily
  * enables a <tt>Log</tt> and makes available the currently executing {@link Subject Subject}.
  *

File: core/src/main/java/org/apache/ki/aop/MethodInvocation.java
Patch:
@@ -40,7 +40,7 @@
 import java.lang.reflect.Method;
 
 /**
- * 3rd-party API independent representation of a method invocation.  This is needed so Apache Ki can support other
+ * 3rd-party API independent representation of a method invocation.  This is needed so Ki can support other
  * MethodInvocation instances from other AOP frameworks/APIs.
  *
  * @author Jeremy Haile

File: core/src/main/java/org/apache/ki/authc/AbstractAuthenticator.java
Patch:
@@ -238,7 +238,7 @@ public final AuthenticationInfo authenticate(AuthenticationToken token)
      *
      * @param token the authentication token encapsulating the user's login information.
      * @return an <tt>AuthenticationInfo</tt> object encapsulating the user's account information
-     *         important to Apache Ki.
+     *         important to Ki.
      * @throws AuthenticationException if there is a problem logging in the user.
      */
     protected abstract AuthenticationInfo doAuthenticate(AuthenticationToken token)

File: core/src/main/java/org/apache/ki/authc/Account.java
Patch:
@@ -28,10 +28,10 @@
  * This interface can be useful when an Realm implementation finds it more convenient to use a single object to
  * encapsulate both the authentication and authorization information used by both authc and authz operations.
  * <p/>
- * <b>Please Note</b>:  Since Apache Ki sometimes logs account operations, please ensure your Account's <code>toString()</code>
+ * <b>Please Note</b>:  Since Ki sometimes logs account operations, please ensure your Account's <code>toString()</code>
  * implementation does <em>not</em> print out account credentials (password, etc), as these might be viewable to
  * someone reading your logs.  This is good practice anyway, and account principals should rarely (if ever) be printed
- * out for any reason.  If you're using Apache Ki's default implementations of this interface, they only ever print the
+ * out for any reason.  If you're using Ki's default implementations of this interface, they only ever print the
  * account {@link #getPrincipals() principals}, so you do not need to do anything additional.
  *
  * @author Jeremy Haile

File: core/src/main/java/org/apache/ki/authc/AuthenticationToken.java
Patch:
@@ -35,7 +35,7 @@
  * <p>Because applications represent user data and credentials in different ways, implementations
  * of this interface are application-specific.  You are free to acquire a user's principals and
  * credentials however you wish (e.g. web form, Swing form, fingerprint identification, etc) and
- * then submit them to the Apache Ki framework in the form of an implementation of this
+ * then submit them to the Ki framework in the form of an implementation of this
  * interface.
  *
  * <p>If your application's authentication process is  username/password based

File: core/src/main/java/org/apache/ki/authc/LogoutAware.java
Patch:
@@ -25,7 +25,7 @@
  *
  * <p>As it is an SPI interface, it is really intended for SPI implementors such as those implementing Realms.
  *
- * <p>All of Apache Ki's concrete Realm implementations implement this interface as a convenience for those wishing
+ * <p>All of Ki's concrete Realm implementations implement this interface as a convenience for those wishing
  * to subclass them.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/authc/UsernamePasswordToken.java
Patch:
@@ -276,7 +276,7 @@ public Object getCredentials() {
      * is unknown or explicitly omitted.  It is up to the Authenticator implementation processing this token if
      * an authentication attempt without an inetAddress is valid or not.
      *
-     * <p>(Apache Ki's default Authenticator
+     * <p>(Ki's default Authenticator
      * allows <tt>null</tt> IPs to support localhost and proxy server environments).</p>
      *
      * @return the inetAddress from where the authentication attempt occurs, or <tt>null</tt> if it is unknown or
@@ -291,7 +291,7 @@ public InetAddress getInetAddress() {
      * Sets the inetAddress from where the authentication attempt occurs.  It is up to the Authenticator
      * implementation processing this token if an authentication attempt without an inetAddress is valid or not.
      *
-     * <p>(Apache Ki's default Authenticator
+     * <p>(Ki's default Authenticator
      * allows <tt>null</tt> IPs to allow localhost and proxy server environments).</p>
      *
      * @param inetAddress the inetAddress from where the authentication attempt occurs.

File: core/src/main/java/org/apache/ki/authc/credential/HashedCredentialsMatcher.java
Patch:
@@ -48,7 +48,7 @@
  * salting and multiple iterations and why you might want to use them. (Note of sections 5
  * &quot;Why add salt?&quot; and 6 "Hardening against the attacker's attack").
  *
- * <p>We should also note here that all of Apache Ki's Hash implementations (for example,
+ * <p>We should also note here that all of Ki's Hash implementations (for example,
  * {@link org.apache.ki.crypto.hash.Md5Hash Md5Hash}, {@link org.apache.ki.crypto.hash.Sha1Hash Sha1Hash}, etc)
  * support salting and multiple hash iterations via overloaded constructors.</p>
  *
@@ -91,7 +91,7 @@ public abstract class HashedCredentialsMatcher extends SimpleCredentialsMatcher
      * Returns <tt>true</tt> if the system's stored credential hash is Hex encoded, <tt>false</tt> if it
      * is Base64 encoded.
      *
-     * <p>Default value is <tt>true</tt> for convenience - all of Apache Ki's {@link Hash Hash#toString()}
+     * <p>Default value is <tt>true</tt> for convenience - all of Ki's {@link Hash Hash#toString()}
      * implementations return Hex encoded values by default, making this class's use with those implementations
      * easier.</p>
      *
@@ -108,7 +108,7 @@ public boolean isStoredCredentialsHexEncoded() {
      * <p>A value of <tt>true</tt> will cause this class to decode the system credential from Hex, a
      * value of <tt>false</tt> will cause this class to decode the system credential from Base64.</p>
      *
-     * <p>Unless overridden via this method, the default value is <tt>true</tt> for convenience - all of Apache Ki's
+     * <p>Unless overridden via this method, the default value is <tt>true</tt> for convenience - all of Ki's
      * {@link Hash Hash#toString()} implementations return Hex encoded values by default, making this class's use with
      * those implementations easier.</p>.
      *

File: core/src/main/java/org/apache/ki/authc/pam/AbstractAuthenticationStrategy.java
Patch:
@@ -29,7 +29,7 @@
 
 
 /**
- * Abstract base implementation for Apache Ki's concrete <code>AuthenticationStrategy</code>
+ * Abstract base implementation for Ki's concrete <code>AuthenticationStrategy</code>
  * implementations.
  *
  * @author Jeremy Haile

File: core/src/main/java/org/apache/ki/authc/pam/ModularRealmAuthenticator.java
Patch:
@@ -36,8 +36,8 @@
 
 /**
  * A <tt>ModularRealmAuthenticator</tt> delgates account lookups to a pluggable (modular) collection of
- * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in Apache Ki.
- * In addition to authorization duties, a Apache Ki Realm can also be thought of a PAM 'module'.
+ * {@link Realm}s.  This enables PAM (Pluggable Authentication Module) behavior in Ki.
+ * In addition to authorization duties, a Ki Realm can also be thought of a PAM 'module'.
  *
  * <p>Using this Authenticator allows you to &quot;plug-in&quot; your own
  * <tt>Realm</tt>s as you see fit.  Common realms are those based on accessing
@@ -322,7 +322,7 @@ protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationTo
      * <code>((LogoutAware)realm).onLogout(principals)</code> to allow each realm the opportunity to perform
      * logout/cleanup operations during an user-logout.
      *
-     * <p>Apache Ki's Realm implementations all implement the <tt>LogoutAware</tt> interface by default and can be
+     * <p>Ki's Realm implementations all implement the <tt>LogoutAware</tt> interface by default and can be
      * overridden for realm-specific logout logic.
      *
      * @param principals the application-specific Subject/user identifier.

File: core/src/main/java/org/apache/ki/authz/AuthorizationInfo.java
Patch:
@@ -39,8 +39,8 @@
  * or both depending on your preference and needs.
  * <p/>
  * Because the act of authorization (access control) is orthoganal to authentication (log-in), this interface is
- * intended to represent only the account data needed by Apache Ki during an access control check
- * (role, permission, etc).  Apache Ki also has a parallel
+ * intended to represent only the account data needed by Ki during an access control check
+ * (role, permission, etc).  Ki also has a parallel
  * {@link org.apache.ki.authc.AuthenticationInfo AuthenticationInfo} interface for use during the authentication
  * process that represents identity data such as principals and credentials.
  * <p/>
@@ -77,7 +77,7 @@ public interface AuthorizationInfo extends Serializable {
      * {@link org.apache.ki.authz.permission.PermissionResolver PermissionResolver}
      * in order to perform the actual permission check.  This is not a requirement of course, since <code>Realm</code>s
      * can perform security checks in whatever manner deemed necessary, but this explains the conversion mechanism that
-     * most Apache Ki Realms execute for string-based permission checks.
+     * most Ki Realms execute for string-based permission checks.
      *
      * @return all string-based permissions assigned to the corresponding Subject.
      */

File: core/src/main/java/org/apache/ki/authz/Authorizer.java
Patch:
@@ -37,7 +37,7 @@
  * {@link Permission Permission} instances. They are a convenience allowing the caller to use a String representation of
  * a {@link Permission Permission} if desired.  Most implementations of this interface will simply convert these
  * String values to {@link Permission Permission} instances and then just call the corresponding type-safe method.
- * (Apache Ki's default implementations do String-to-Permission conversion for these methods using
+ * (Ki's default implementations do String-to-Permission conversion for these methods using
  * {@link org.apache.ki.authz.permission.PermissionResolver PermissionResolver}s.)
  *
  * <p>These overloaded *Permission methods <em>do</em> forego type-saftey for the benefit of convenience and simplicity,

File: core/src/main/java/org/apache/ki/authz/AuthorizingAccount.java
Patch:
@@ -29,7 +29,7 @@
  * implementations that want to cache authorization state when doing an account lookup so multiple authorization checks
  * do not need to access the Realm's underlying data store repeatedly.
  * <p/>
- * Of course, an <tt>AuthorizingAccount</tt> concept is only a convenience mechansim if Apache Ki account caching
+ * Of course, an <tt>AuthorizingAccount</tt> concept is only a convenience mechansim if Ki account caching
  * is enabled.  Realm implementations are free to ignore this interface entirely and implement/override any of their
  * <tt>Realm</tt>'s {@link Authorizer Authorizer} methods to execute the authorization checks as they see fit.
  * ({@link org.apache.ki.realm.Realm Realm} is a sub-interface of {@link Authorizer Authorizer} and therefore must
@@ -40,7 +40,7 @@
  * return an {@link Account} instance, or if you want fine-grained control over authorization behavior, extend
  * a subclass of {@link org.apache.ki.realm.AuthorizingRealm} and implement your own security checks in the
  * Realm itself instead of forcing this logic in your entity/domain classes where it could be error prone and
- * unnecessarily couple these objects to Apache Ki.
+ * unnecessarily couple these objects to Ki.
  *
  * @author Jeremy Haile
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/authz/Permission.java
Patch:
@@ -27,7 +27,7 @@
  * Granting access to an application functionality or a particular resource is done by the application's security
  * configuration, typically by assigning Permissions to users, roles and/or groups.
  *
- * <p>Most typical systems are what the Apache Ki team calls <em>role-based</em> in nature, where a role represents
+ * <p>Most typical systems are what the Ki team calls <em>role-based</em> in nature, where a role represents
  * common behavior for certain user types.  For example, a system might have an <em>Aministrator</em> role, a
  * <em>User</em> or <em>Guest</em> roles, etc.
  *
@@ -50,13 +50,13 @@
  * and groups can all be created, configured and/or deleted at runtime.  This enables  an extremely powerful security
  * model.
  *
- * <p>A benefit to Apache Ki is that, although it assumes most systems are based on these types of static role or
+ * <p>A benefit to Ki is that, although it assumes most systems are based on these types of static role or
  * dynamic role w/ permission schemes, it does not require a system to model their security data this way - all
  * Permission checks are relegated to {@link org.apache.ki.realm.Realm} implementations, and only those implementatons
  * really determine how a user 'has' a permission or not.  The Realm could use the semantics described here, or it
  * could utilize some other mechanism entirely - it is always up to the application developer.
  *
- * <p>Apache Ki provides a very powerful default implementation of this interface in the form of the
+ * <p>Ki provides a very powerful default implementation of this interface in the form of the
  * {@link org.apache.ki.authz.permission.WildcardPermission WildcardPermission}.  We highly recommend that you
  * investigate this class before trying to implement your own <code>Permission</code>s.
  *

File: core/src/main/java/org/apache/ki/authz/annotation/RequiresUser.java
Patch:
@@ -28,7 +28,7 @@
  * accessed or invoked.  This is <em>less</em> restrictive than the {@link RequiresAuthentication RequiresAuthentication}
  * annotation.
  * <p/>
- * Apache Ki defines a &quot;user&quot; as a Subject that is either
+ * Ki defines a &quot;user&quot; as a Subject that is either
  * &quot;remembered&quot; <b><em>or</em></b> authenticated:
  * <ul>
  * <li>An <b>authenticated</b> user is a Subject that has successfully logged in (proven their identity)

File: core/src/main/java/org/apache/ki/authz/permission/WildcardPermission.java
Patch:
@@ -97,8 +97,8 @@
  * <code>subject.isPermitted( &quot;newsletter:edit:13&quot; )</code>
  * <p/>
  * There is no limit to the number of tokens that can be used, so it is up to your imagination in terms of ways that
- * this could be used in your application.  However, the Apache Ki team likes to standardize some common usages shown
- * above to help people get started and provide consistency in the Apache Ki community.
+ * this could be used in your application.  However, the Ki team likes to standardize some common usages shown
+ * above to help people get started and provide consistency in the Ki community.
  *
  * @author Jeremy Haile
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/codec/Base64.java
Patch:
@@ -28,7 +28,7 @@
  *
  * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 618419) with modifications
  * to enable Base64 conversion without a full dependecny on Commons Codec.  We didn't want to reinvent the wheel of
- * great work they've done, but also didn't want to force every Apache Ki user to depend on the commons-codec.jar</p>
+ * great work they've done, but also didn't want to force every Ki user to depend on the commons-codec.jar</p>
  *
  * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have
  * remained in tact.</p>
@@ -223,7 +223,7 @@ static byte[] discardWhitespace(byte[] data) {
     }
 
     /**
-     * Base64 encodes the specified byte array and then encodes it as a String using Apache Ki's preferred character
+     * Base64 encodes the specified byte array and then encodes it as a String using Ki's preferred character
      * encoding (UTF-8).
      *
      * @param bytes the byte array to Base64 encode.

File: core/src/main/java/org/apache/ki/codec/Hex.java
Patch:
@@ -23,7 +23,7 @@
  *
  * <p>This class was borrowed from Apache Commons Codec SVN repository (rev. 560660 ) with modifications
  * to enable Hex conversion without a full dependency on Commons Codec.  We didn't want to reinvent the wheel of
- * great work they've done, but also didn't want to force every Apache Ki user to depend on the commons-codec.jar</p>
+ * great work they've done, but also didn't want to force every Ki user to depend on the commons-codec.jar</p>
  *
  * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have
  * remained in tact.</p>

File: core/src/main/java/org/apache/ki/codec/package-info.java
Patch:
@@ -17,7 +17,7 @@
  * under the License.
  */
 /**
- * Components for encoding and decoding of data across multiple formats, especially useful in Apache Ki's
+ * Components for encoding and decoding of data across multiple formats, especially useful in Ki's
  * cryptography and web functionality.
  */
 package org.apache.ki.codec;

File: core/src/main/java/org/apache/ki/config/Configuration.java
Patch:
@@ -22,7 +22,7 @@
 
 
 /**
- * A <code>Configuration</code> is responsible for 'wiring' together all the Apache Ki components for an
+ * A <code>Configuration</code> is responsible for 'wiring' together all the Ki components for an
  * application, such as the {@link org.apache.ki.mgt.SecurityManager SecurityManager}, and any of its
  * dependencies.
  * <p/>

File: core/src/main/java/org/apache/ki/config/ConfigurationException.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.ki.KiException;
 
 /**
- * Root exception indicating there was a problem parsing or processing the Apache Ki configuration.
+ * Root exception indicating there was a problem parsing or processing the Ki configuration.
  *
  * @author Les Hazlewood
  * @since 0.9

File: core/src/main/java/org/apache/ki/config/IniConfiguration.java
Patch:
@@ -96,11 +96,11 @@ public void init() throws KiException {
             } else {
                 if (ignoreResourceNotFound) {
                     if (log.isDebugEnabled()) {
-                        log.debug("Apache Ki resource [" + configUrl + "] not found.  Ignoring since " +
+                        log.debug("Ki resource [" + configUrl + "] not found.  Ignoring since " +
                                 "'ignoreResourceNotFound' is set to true.");
                     }
                 } else {
-                    throw new ConfigurationException("Apache Ki resource [" + configUrl + "] specified as a 'configUrl' " +
+                    throw new ConfigurationException("Ki resource [" + configUrl + "] specified as a 'configUrl' " +
                             "cannot be found.  If you want to fall back on default configuration specified " +
                             "via the 'config' parameter, then set 'ignoreResourceNotFound' to true.");
                 }

File: core/src/main/java/org/apache/ki/config/ReflectionBuilder.java
Patch:
@@ -34,7 +34,7 @@
 
 /**
  * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a
- * map of "property values".  Typically these come from the Apache Ki INI configuration and are used
+ * map of "property values".  Typically these come from the Ki INI configuration and are used
  * to construct or modify the SecurityManager, its dependencies, and web-based security filters.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/crypto/Cipher.java
Patch:
@@ -40,9 +40,9 @@
  * data shared between two parties, the same Key must also be shared and may be compromised.
  *
  * <p>Note that a symmetric cipher is perfectly fine to use if you just want to encode data in a format no one else
- * can understand and you never give away the key.  Apache Ki uses a symmetric cipher when using certain
+ * can understand and you never give away the key.  Ki uses a symmetric cipher when using certain
  * HTTP Cookies for example - because it is often undesireable to have user's identity stored in a plain-text cookie,
- * that identity can be converted via a symmetric cipher.  Since the the same exact Apache Ki application will receive
+ * that identity can be converted via a symmetric cipher.  Since the the same exact Ki application will receive
  * the cookie, it can decrypt it via the same <tt>Key</tt> and there is no potential for discovery since that Key
  * is never shared with anyone.
  *

File: core/src/main/java/org/apache/ki/crypto/hash/AbstractHash.java
Patch:
@@ -28,7 +28,7 @@
 import org.apache.ki.codec.Hex;
 
 /**
- * Provides a base for all Apache Ki Hash algorithms with support for salts and multiple hash iterations.
+ * Provides a base for all Ki Hash algorithms with support for salts and multiple hash iterations.
  *
  * <p>Read <a href="http://www.owasp.org/index.php/Hashing_Java" target="blank">http://www.owasp.org/index.php/Hashing_Java</a> for a
  * good article on the benefits of hashing, including what a 'salt' is as well as why it and multiple hash iterations

File: core/src/main/java/org/apache/ki/crypto/package-info.java
Patch:
@@ -21,6 +21,6 @@
  * add additional convenient behavior.
  * <p/>
  * The most important interface in this package is the {@link org.apache.ki.crypto.Cipher Cipher} interface, which
- * allows other Apache Ki components to encrypt and decrypt potentially sensitive data.
+ * allows other Ki components to encrypt and decrypt potentially sensitive data.
  */
 package org.apache.ki.crypto;

File: core/src/main/java/org/apache/ki/io/Serializer.java
Patch:
@@ -23,7 +23,7 @@
  * of objects to files, HTTP cookies, or other mechanism.
  * <p/>
  * A <code>Serializer</code> should only do conversion, never change the data, such as encoding/decoding or
- * encryption.  These orthoganal concerns are handled elsewhere by Apache Ki, for example, via
+ * encryption.  These orthoganal concerns are handled elsewhere by Ki, for example, via
  * {@link org.apache.ki.codec.CodecSupport CodecSupport} and {@link org.apache.ki.crypto.Cipher Cipher}s.
  * @author Les Hazlewood
  * @since 0.9

File: core/src/main/java/org/apache/ki/jndi/JndiCallback.java
Patch:
@@ -34,7 +34,7 @@
  * <p>Note that this interface is an exact copy of the Spring Framework's identically named interface from
  * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the
  * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.
- * Since Apache Ki is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
+ * Since Ki is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
  *
  * @author Rod Johnson
  * @see JndiTemplate

File: core/src/main/java/org/apache/ki/jndi/JndiLocator.java
Patch:
@@ -31,7 +31,7 @@
  * <p>Note that this implementation is an almost exact combined copy of the Spring Framework's 'JndiAccessor' and
  * 'JndiLocatorSupport' classes from their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require
  * a full dependency on the Spring framework, nor does Spring make available only its JNDI classes in a small jar, or
- * we would have used that. Since Apache Ki is also Apache 2.0 licensed, all regular licenses and conditions and
+ * we would have used that. Since Ki is also Apache 2.0 licensed, all regular licenses and conditions and
  * authors have remained in tact.
  *
  * @author Juergen Hoeller

File: core/src/main/java/org/apache/ki/jndi/JndiTemplate.java
Patch:
@@ -37,7 +37,7 @@
  * <p>Note that this implementation is an almost exact copy of the Spring Framework's identically named class from
  * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the
  * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.
- * Since Apache Ki is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
+ * Since Ki is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
  *
  * @author Rod Johnson
  * @author Juergen Hoeller

File: core/src/main/java/org/apache/ki/mgt/AuthenticatingSecurityManager.java
Patch:
@@ -32,15 +32,15 @@
 
 
 /**
- * Apache Ki support of a {@link SecurityManager} class hierarchy that delegates all
+ * Ki support of a {@link SecurityManager} class hierarchy that delegates all
  * authentication operations to a wrapped {@link Authenticator Authenticator} instance.  That is, this class
  * implements all the <tt>Authenticator</tt> methods in the {@link SecurityManager SecurityManager}
  * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'
  * <tt>Authenticator</tt> instance.
  *
  * <p>All other <tt>SecurityManager</tt> (authorization, session, etc) methods are left to be implemented by subclasses.
  *
- * <p>In keeping with the other classes in this hierarchy and Apache Ki's desire to minimize configuration whenever
+ * <p>In keeping with the other classes in this hierarchy and Ki's desire to minimize configuration whenever
  * possible, suitable default instances for all dependencies are created upon instantiation.
  *
  * @author Les Hazlewood
@@ -125,7 +125,7 @@ public void setAuthenticationStrategy(AuthenticationStrategy strategy) {
      * interface in order for these listeners to be applied.  If it does not implement this interface, it is
      * considered a configuration error and an exception will be thrown.
      *
-     * <p>All of Apache Ki's <tt>Authenticator</tt> implementations implement the
+     * <p>All of Ki's <tt>Authenticator</tt> implementations implement the
      * <tt>AuthenticationListenerRegistrar</tt> interface, so you would only need
      * to worry about an exception being thrown if you provided your own Authenticator instance and did not
      * implement it.

File: core/src/main/java/org/apache/ki/mgt/AuthorizingSecurityManager.java
Patch:
@@ -32,7 +32,7 @@
 
 
 /**
- * Apache Ki support of a {@link SecurityManager} class hierarchy that delegates all
+ * Ki support of a {@link SecurityManager} class hierarchy that delegates all
  * authorization (access control) operations to a wrapped {@link Authorizer Authorizer} instance.  That is,
  * this class implements all the <tt>Authorizer</tt> methods in the {@link SecurityManager SecurityManager}
  * interface, but in reality, those methods are merely passthrough calls to the underlying 'real'
@@ -41,7 +41,7 @@
  * <p>All remaining <tt>SecurityManager</tt> methods not covered by this class or its parents (mostly Session support)
  * are left to be implemented by subclasses.
  *
- * <p>In keeping with the other classes in this hierarchy and Apache Ki's desire to minimize configuration whenever
+ * <p>In keeping with the other classes in this hierarchy and Ki's desire to minimize configuration whenever
  * possible, suitable default instances for all dependencies will be created upon instantiation.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/mgt/RealmSecurityManager.java
Patch:
@@ -28,7 +28,7 @@
 
 
 /**
- * Apache Ki support of a {@link SecurityManager} class hierarchy based around a collection of
+ * Ki support of a {@link SecurityManager} class hierarchy based around a collection of
  * {@link org.apache.ki.realm.Realm}s.  All actual {@code SecurityManager} method implementations are left to
  * subclasses.
  *

File: core/src/main/java/org/apache/ki/mgt/SecurityManagerAware.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Interface providing a callback method that allows an implementation of this interface to receive a reference to
  * the {@link org.apache.ki.mgt.SecurityManager SecurityManager} if they require one.  This is mostly used by core implementation classes
- * for framework code and is rarely necessary for software developers enabling Apache Ki in their applications.
+ * for framework code and is rarely necessary for software developers enabling Ki in their applications.
  *
  * @author Les Hazlewood
  * @since 1.0

File: core/src/main/java/org/apache/ki/mgt/SessionSubjectBinder.java
Patch:
@@ -54,8 +54,8 @@
  * end of request/thread execution, and a new one is created on the next request/method invocation as per step #1.</li>
  * </ol>
  * <p/>
- * Indeed this is exactly how Apache Ki's default behavior works in enterprise server and web-based environments.  It is
- * enabled in the <code>Apache KiFilter</code> for web-based environments as well as remote-method-invocation-based
+ * Indeed this is exactly how Ki's default behavior works in enterprise server and web-based environments.  It is
+ * enabled in the <code>KiFilter</code> for web-based environments as well as remote-method-invocation-based
  * components for non-web environments.
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/mgt/SessionsSecurityManager.java
Patch:
@@ -37,7 +37,7 @@
 
 
 /**
- * Apache Ki support of a {@link SecurityManager} class hierarchy that delegates all
+ * Ki support of a {@link SecurityManager} class hierarchy that delegates all
  * {@link org.apache.ki.session.Session session} operations to a wrapped {@link org.apache.ki.session.mgt.SessionManager SessionManager}
  * instance.  That is, this class implements the methods in the
  * {@link SessionManager SessionManager} interface, but in reality, those methods are merely passthrough calls to
@@ -46,7 +46,7 @@
  * The remaining {@code SecurityManager} methods not implemented by this class or its parents are left to be
  * implemented by subclasses.
  * <p/>
- * In keeping with the other classes in this hierarchy and Apache Ki's desire to minimize configuration whenever
+ * In keeping with the other classes in this hierarchy and Ki's desire to minimize configuration whenever
  * possible, suitable default instances for all dependencies will be created upon instantiation.
  *
  * @author Les Hazlewood
@@ -158,7 +158,7 @@ private void assertSessionManager(Class<? extends SessionManager> requiredType)
                     "This might occur for example if you're trying to set the validation interval or auto session " +
                     "creation in a servlet container-backed session environment ('http' session mode).  If that is " +
                     "the case however, that property is only useful when using 'ki' session mode and using " +
-                    "Apache Ki enterprise sessions which do not rely on a servlet container.";
+                    "Ki enterprise sessions which do not rely on a servlet container.";
             throw new IllegalStateException(msg);
         }
     }

File: core/src/main/java/org/apache/ki/mgt/package-info.java
Patch:
@@ -18,6 +18,6 @@
  */
 /**
  * Provides the master {@link org.apache.ki.mgt.SecurityManager SecurityManager} interface and a default implementation
- * hierarchy for managing all aspects of Apache Ki's functionality in an application.
+ * hierarchy for managing all aspects of Ki's functionality in an application.
  */
 package org.apache.ki.mgt;

File: core/src/main/java/org/apache/ki/realm/AuthenticatingRealm.java
Patch:
@@ -206,7 +206,7 @@ public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)
      * authentication token.
      *
      * <p>For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing
-     * more and letting Apache Ki do the rest.  But in some systems, this method could actually perform EIS specific
+     * more and letting Ki do the rest.  But in some systems, this method could actually perform EIS specific
      * log-in logic in addition to just retrieving data - it is up to the Realm implementation.
      *
      * <p>A <tt>null</tt> return value means that no account could be associated with the specified token.
@@ -224,11 +224,11 @@ public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)
      * Default implementation that does nothing (no-op) and exists as a convenience mechanism in case subclasses
      * wish to override it to implement realm-specific logout logic for the given user account logging out.</p>
      * <p/>
-     * In a single-realm Apache Ki configuration (most applications), the <code>principals</code> method
+     * In a single-realm Ki configuration (most applications), the <code>principals</code> method
      * argument will be the same as that which is contained in the <code>AuthenticationInfo</code> object returned by the
      * {@link #doGetAuthenticationInfo} method (that is, {@link AuthenticationInfo#getPrincipals info.getPrincipals()}).
      * <p/>
-     * In a multi-realm Apache Ki configuration, the given <code>principals</code> method
+     * In a multi-realm Ki configuration, the given <code>principals</code> method
      * argument could contain principals returned by many realms.  Therefore the subclass implementation would need
      * to know how to extract the principal(s) relevant to only itself and ignore other realms' principals.  This is
      * usually done by calling {@link org.apache.ki.subject.PrincipalCollection#fromRealm(String) principals.fromRealm(name)},

File: core/src/main/java/org/apache/ki/realm/RealmFactory.java
Patch:
@@ -21,10 +21,10 @@
 import java.util.Collection;
 
 /**
- * Enables Apache Ki end-users to configure and initialize one or more {@link Realm Realm} instances
+ * Enables Ki end-users to configure and initialize one or more {@link Realm Realm} instances
  * in any manner desired.
  * <p/>
- * This interface exists to support environments where end-users may not wish to use Apache Ki's default
+ * This interface exists to support environments where end-users may not wish to use Ki's default
  * text-based configuration to create and configure realms, and instead wish to retrieve a realm configured in a
  * proprietary manner.  An implementation of this interface can access that proprietary mechanism to retrieve the
  * already-created <tt>Realm</tt>s.

File: core/src/main/java/org/apache/ki/realm/text/PropertiesRealm.java
Patch:
@@ -136,7 +136,7 @@ public void afterRoleCacheSet() {
         } catch (Exception e) {
             if (log.isInfoEnabled()) {
                 log.info("Unable to find a ki-users.properties file at location [" + this.resourcePath + "].  " +
-                        "Defaulting to Apache Ki's failsafe properties file (demo use only).");
+                        "Defaulting to Ki's failsafe properties file (demo use only).");
             }
             this.resourcePath = FAILSAFE_RESOURCE_PATH;
             loadProperties();

File: core/src/main/java/org/apache/ki/session/mgt/ValidatingSessionManager.java
Patch:
@@ -67,8 +67,8 @@ public interface ValidatingSessionManager extends SessionManager {
      * proactive systems, this {@link #validateSessions()} method should be invoked regularaly
      * anyway to <em>guarantee</em> no orphans exist.
      *
-     * <p><b>Note:</b> Apache Ki supports automatic execution of this method at a regular interval
-     * by using {@link SessionValidationScheduler}s.  The Apache Ki default SecurityManager implementations
+     * <p><b>Note:</b> Ki supports automatic execution of this method at a regular interval
+     * by using {@link SessionValidationScheduler}s.  The Ki default SecurityManager implementations
      * needing session validation will create and use one by default if one is not provided by the
      * application configuration.
      */

File: core/src/main/java/org/apache/ki/session/mgt/eis/MemorySessionDAO.java
Patch:
@@ -48,7 +48,7 @@
  * <li>If you need session information beyond their transient start/stop lifetimes, you should subclass this one and
  * override the <tt>do*</tt> methods to perform CRUD operations using an EIS-tier API (e.g. Hibernate/JPA/JCR/etc).
  * This class implementation does not retain sessions after they have been stopped or expired, so you would need to
- * override these methods to ensure Sessions can be accessed beyond Apache Ki's needs.</li>
+ * override these methods to ensure Sessions can be accessed beyond Ki's needs.</li>
  * </ul>
  *
  * @author Les Hazlewood

File: core/src/main/java/org/apache/ki/util/AntPathMatcher.java
Patch:
@@ -50,7 +50,7 @@
  *
  * <p><b>N.B.</b>: This class was borrowed (with much appreciation) from the
  * <a href="http://www.springframework.org">Spring Framework</a> with modifications.  We didn't want to reinvent the
- * wheel of great work they've done, but also didn't want to force every Apache Ki user to depend on Spring</p>
+ * wheel of great work they've done, but also didn't want to force every Ki user to depend on Spring</p>
  *
  * <p>As per the Apache 2.0 license, the original copyright notice and all author and copyright information have
  * remained in tact.</p>

File: core/src/main/java/org/apache/ki/util/CollectionUtils.java
Patch:
@@ -38,7 +38,7 @@ public class CollectionUtils {
 
     /**
      * Simple method that just returns <code>Collections.EMPTY_SET</code>.
-     * This exists to enable type-safe empty collections so other locations in Apache Ki code
+     * This exists to enable type-safe empty collections so other locations in Ki code
      * do not need to worry about suppressing warnings.
      *
      * @param clazz the class of the collection type to return

File: core/src/main/java/org/apache/ki/util/Destroyable.java
Patch:
@@ -19,7 +19,7 @@
 package org.apache.ki.util;
 
 /**
- * Apache Ki container-agnostic interface that indicates that this object requires a callback during destruction.
+ * Ki container-agnostic interface that indicates that this object requires a callback during destruction.
  *
  * @author Les Hazlewood
  * @author Jeremy Haile

File: core/src/main/java/org/apache/ki/util/Initializable.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.ki.KiException;
 
 /**
- * Apache Ki container-agnostic interface that indicates that this object requires initialization.
+ * Ki container-agnostic interface that indicates that this object requires initialization.
  *
  * @author Les Hazlewood
  * @author Jeremy Haile

File: core/src/main/java/org/apache/ki/util/JavaEnvironment.java
Patch:
@@ -20,10 +20,10 @@
 
 /**
  * Internal helper class used to find the Java/JDK version
- * that Apache Ki is operating within, to allow for automatically
+ * that Ki is operating within, to allow for automatically
  * adapting to the present platform's capabilities.
  *
- * <p>Note that Apache Ki does not support 1.2 or earlier JVMs - only 1.3 and later.
+ * <p>Note that Ki does not support 1.2 or earlier JVMs - only 1.3 and later.
  *
  * <p><em>This class was borrowed and heavily based upon a nearly identical version found in
  * the <a href="http://www.springframework.org/">Spring Framework</a>, with minor modifications.

File: core/src/main/java/org/apache/ki/util/JdbcUtils.java
Patch:
@@ -30,7 +30,7 @@
  * A set of static helper methods for managing JDBC API objects.
  * <p/>
  * <em>Note:</em> Some parts of this class were copied from the Spring Framework and then modified.
- * They were copied here to prevent Spring dependencies in the Apache Ki core API.  The original license conditions
+ * They were copied here to prevent Spring dependencies in the Ki core API.  The original license conditions
  * (Apache 2.0) have been maintained.
  *
  * @author Jeremy Haile

File: core/src/main/java/org/apache/ki/util/UnknownClassException.java
Patch:
@@ -22,7 +22,7 @@
 
 
 /**
- * The Apache Ki framework's <code>RuntimeException</code> equivalent of the JDK's
+ * The Ki framework's <code>RuntimeException</code> equivalent of the JDK's
  * <code>ClassNotFoundException</code>, to maintain a RuntimeException paradigm.
  *
  * @author Les Hazlewood

File: samples/quickstart/src/main/java/Quickstart.java
Patch:
@@ -43,8 +43,8 @@ public class Quickstart {
     public static void main( String[] args ) {
 
         //Most applications would never instantiate a SecurityManager directly - you would instead configure
-        //Apache Ki in web.xml or a container (JEE, Spring, etc).
-        //But, since this is a quickstart, we just want you to get a feel for how the Apache Ki API looks, so this
+        //Ki in web.xml or a container (JEE, Spring, etc).
+        //But, since this is a quickstart, we just want you to get a feel for how the Ki API looks, so this
         //is sufficient to have a simple working example:
         DefaultSecurityManager securityManager = new DefaultSecurityManager();
 
@@ -55,7 +55,7 @@ public static void main( String[] args ) {
         SecurityUtils.setSecurityManager( securityManager );
 
 
-        //now that a simple Apache Ki environment is set up, let's see what you can do:
+        //now that a simple Ki environment is set up, let's see what you can do:
 
         //get the currently executing user:
         Subject currentUser = SecurityUtils.getSubject();

File: samples/spring/src/main/java/org/apache/ki/samples/spring/BootstrapDataPopulator.java
Patch:
@@ -30,7 +30,7 @@
 
 /**
  * A data populator that creates a set of security tables and test data that can be used by the
- * Apache Ki Spring sample application to demonstrate the use of the {@link org.apache.ki.realm.jdbc.JdbcRealm}
+ * Ki Spring sample application to demonstrate the use of the {@link org.apache.ki.realm.jdbc.JdbcRealm}
  * The tables created by this class follow the default table and column names that {@link org.apache.ki.realm.jdbc.JdbcRealm} uses.
  *
  * @author Les Hazlewood

File: samples/spring/src/main/java/org/apache/ki/samples/spring/ui/WebStartView.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * Simple web start application that helps to demo single sign-on and
- * remoting authorization using Apache Ki.  The injected <tt>SampleManager</tt>
+ * remoting authorization using Ki.  The injected <tt>SampleManager</tt>
  * is hosted by the Spring sample web application and remotely invoked
  * when the buttons in this view are clicked.
  *

File: samples/spring/src/main/java/org/apache/ki/samples/spring/web/IndexController.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.ki.subject.Subject;
 
 /**
- * Spring MVC controller responsible for rendering the Apache Ki Spring sample
+ * Spring MVC controller responsible for rendering the Ki Spring sample
  * application index page.
  *
  * @author Jeremy Haile

File: samples/spring/src/main/java/org/apache/ki/samples/spring/web/JnlpController.java
Patch:
@@ -31,7 +31,7 @@
 import org.apache.ki.subject.Subject;
 
 /**
- * Controller used to dynamically build a JNLP file used to launch the Apache Ki
+ * Controller used to dynamically build a JNLP file used to launch the Ki
  * Spring WebStart sample application.
  *
  * @author Jeremy Haile
@@ -73,7 +73,7 @@ protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpSer
             session = subject.getSession();
         }
         if (session == null) {
-            String msg = "Expected a non-null Apache Ki session.";
+            String msg = "Expected a non-null Ki session.";
             throw new IllegalArgumentException(msg);
         }
 

File: support/ehcache/src/main/java/org/apache/ki/cache/ehcache/EhCache.java
Patch:
@@ -32,7 +32,7 @@
 import org.apache.ki.cache.CacheException;
 
 /**
- * Apache Ki {@link org.apache.ki.cache.Cache} implementation that wraps an {@link net.sf.ehcache.Ehcache} instance.
+ * Ki {@link org.apache.ki.cache.Cache} implementation that wraps an {@link net.sf.ehcache.Ehcache} instance.
  *
  * @author Jeremy Haile
  * @author Les Hazlewood
@@ -52,7 +52,7 @@ public class EhCache implements Cache {
     /**
      * Constructs a new EhCache instance with the given cache.
      *
-     * @param cache - delegate EhCache instance this Apache Ki cache instance will wrap.
+     * @param cache - delegate EhCache instance this Ki cache instance will wrap.
      */
     public EhCache(net.sf.ehcache.Cache cache) {
         if (cache == null) {

File: support/ehcache/src/main/java/org/apache/ki/cache/ehcache/package-info.java
Patch:
@@ -17,7 +17,7 @@
  * under the License.
  */
 /**
- * <a href="http://ehcache.sourceforge.net" target="_top">Ehcache</a>-based implementations of Apache Ki's
+ * <a href="http://ehcache.sourceforge.net" target="_top">Ehcache</a>-based implementations of Ki's
  * cache interfaces.
  */
 package org.apache.ki.cache.ehcache;

File: support/spring/src/main/java/org/apache/ki/spring/SpringKiFilter.java
Patch:
@@ -22,7 +22,7 @@
 
 
 /**
- * Extension of KiFilter that uses {@link SpringIniWebConfiguration} to configure Apache Ki in a Spring web
+ * Extension of KiFilter that uses {@link SpringIniWebConfiguration} to configure Ki in a Spring web
  * environment.
  * <p/>
  * Using this class in web.xml essentially enables the following:

File: support/spring/src/main/java/org/apache/ki/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -83,7 +83,7 @@ public Object invoke(RemoteInvocation invocation, Object targetObject) throws No
                 ThreadContext.bindSessionId(sessionId);
             } else {
                 if (log.isTraceEnabled()) {
-                    log.trace("RemoteInvocation did not contain a Apache Ki Session id attribute under " +
+                    log.trace("RemoteInvocation did not contain a Ki Session id attribute under " +
                             "key [" + SecureRemoteInvocationFactory.SESSION_ID_KEY + "].  A Subject based " +
                             "on an existing Session will not be available during the method invocatin.");
                 }

File: support/spring/src/main/java/org/apache/ki/spring/remoting/SecureRemoteInvocationFactory.java
Patch:
@@ -37,7 +37,7 @@
  * A {@link RemoteInvocationFactory} that passes the session ID to the server via a
  * {@link RemoteInvocation} {@link RemoteInvocation#getAttribute(String) attribute}.
  * This factory is the client-side part of
- * the Apache Ki Spring remoting invocation.  A {@link SecureRemoteInvocationExecutor} should
+ * the Ki Spring remoting invocation.  A {@link SecureRemoteInvocationExecutor} should
  * be used to export the server-side remote services to ensure that the appropriate
  * Subject and Session are bound to the remote thread during execution.
  *

File: web/src/main/java/org/apache/ki/web/WebRememberMeManager.java
Patch:
@@ -75,7 +75,7 @@ public WebRememberMeManager() {
         attr.setCheckRequestParams(false);
         //Peter (Apache Ki developer) said that Jetty didn't like the CookieAttribute.INDEFINITE value
         // (Tomcat was ok with it), so just default to a few years for now.  If anyone doesn't visit a site in 3 years
-        // after last login, I doubt any Apache Ki users would mind their end-users to be forced to log in. - LAH.
+        // after last login, I doubt any Ki users would mind their end-users to be forced to log in. - LAH.
         attr.setMaxAge(CookieAttribute.ONE_YEAR * 3);
         this.identityAttribute = attr;
     }

File: web/src/main/java/org/apache/ki/web/WebUtils.java
Patch:
@@ -61,7 +61,7 @@ public class WebUtils {
      * Message displayed when a servlet request or response is not bound to the current thread context when expected.
      */
     private static final String NOT_BOUND_ERROR_MESSAGE =
-            "Make sure WebUtils.bind() is being called. (typically called by Apache KiFilter)  " +
+            "Make sure WebUtils.bind() is being called. (typically called by KiFilter)  " +
                     "This could also happen when running integration tests that don't properly call WebUtils.bind().";
 
     public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + "_KI_THREAD_CONTEXT_KEY";
@@ -319,7 +319,7 @@ public static void unbindInetAddressFromThread() {
      * {@link #getRequiredServletRequest() getRequiredServletRequest()} method always assumes a
      * servlet-only environment.
      * <p/>
-     * <b>THIS IS NOT PART OF APACHE KI'S PUBLIC API.</b>  It exists for Apache Ki implementation requirements only.
+     * <b>THIS IS NOT PART OF APACHE KI'S PUBLIC API.</b>  It exists for Ki implementation requirements only.
      * 
      * @return the current thread-bound {@code ServletRequest} or {@code null} if there is not one bound.
      * @since 1.0
@@ -405,7 +405,7 @@ public static ServletRequest unbindServletRequest() {
      * {@link #getRequiredServletResponse() getRequiredServletResponse()} method always assumes a
      * servlet-only environment.
      * <p/>
-     * <b>THIS IS NOT PART OF APACHE KI'S PUBLIC API.</b>  It exists for Apache Ki implementation requirements only.
+     * <b>THIS IS NOT PART OF APACHE KI'S PUBLIC API.</b>  It exists for Ki implementation requirements only.
      *
      * @return the current thread-bound {@code ServletResponse} or {@code null} if there is not one bound.
      * @since 1.0

File: web/src/main/java/org/apache/ki/web/config/IniWebConfiguration.java
Patch:
@@ -221,13 +221,13 @@ protected String getPathWithinApplication(ServletRequest request) {
 
     /**
      * Creates a new, uninitialized <code>SecurityManager</code> instance that will be used to build up
-     * the Apache Ki environment for the web application.
+     * the Ki environment for the web application.
      * <p/>
      * The default implementation simply returns
      * <code>new {@link org.apache.ki.web.DefaultWebSecurityManager DefaultWebSecurityManager()};</code>
      *
      * @return a new, uninitialized <code>SecurityManager</code> instance that will be used to build up
-     *         the Apache Ki environment for the web application.
+     *         the Ki environment for the web application.
      */
     protected RealmSecurityManager newSecurityManagerInstance() {
         return new DefaultWebSecurityManager();

File: web/src/main/java/org/apache/ki/web/config/WebConfiguration.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.ki.config.Configuration;
 
 /**
- * A <code>WebConfiguration</code> configures Apache Ki components in a web-enabled application.
+ * A <code>WebConfiguration</code> configures Ki components in a web-enabled application.
  * <p/>
  * In addition to enabling configuration of a <code>SecurityManager</code>, as required by the parent interface,
  * it also allows configuration of arbitrary filter chains to be executed for any given request or URI/URL.
@@ -50,7 +50,7 @@ public interface WebConfiguration extends Configuration {
      *
      * @param request       the incoming ServletRequest
      * @param response      the outgoing ServletResponse
-     * @param originalChain the original <code>FilterChain</code> intercepted by the Apache KiFilter.
+     * @param originalChain the original <code>FilterChain</code> intercepted by the KiFilter.
      * @return the filter chain that should be executed for the given request, or <code>null</code> if the
      *         original chain should be used.
      */

File: web/src/main/java/org/apache/ki/web/filter/AccessControlFilter.java
Patch:
@@ -62,7 +62,7 @@ public abstract class AccessControlFilter extends PathMatchingFilter {
     /**
      * Returns the login URL used to authenticate a user.
      * <p/>
-     * Most Apache Ki filters use this url
+     * Most Ki filters use this url
      * as the location to redirect a user when the filter requires authentication.  Unless overridden, the
      * {@link #DEFAULT_LOGIN_URL DEFAULT_LOGIN_URL} is assumed, which can be overridden via
      * {@link #setLoginUrl(String) setLoginUrl}.
@@ -76,7 +76,7 @@ protected String getLoginUrl() {
     /**
      * Sets the login URL used to authenticate a user.
      * <p/>
-     * Most Apache Ki filters use this url as the location to redirect a user when the filter requires
+     * Most Ki filters use this url as the location to redirect a user when the filter requires
      * authentication.  Unless overridden, the {@link #DEFAULT_LOGIN_URL DEFAULT_LOGIN_URL} is assumed.
      *
      * @param loginUrl the login URL used to authenticate a user, used when redirecting users if authentication is required.

File: web/src/main/java/org/apache/ki/web/filter/authc/AnonymousFilter.java
Patch:
@@ -32,7 +32,7 @@
  * For example, if you had a user-only section of a website, you might want to require that access to
  * any url in that section must be from an authenticated user.
  * <p/>
- * Here is how that would look in the Apache KiFilter configuration:
+ * Here is how that would look in the KiFilter configuration:
  * <p/>
  * <code>[urls]<br/>
  * /user/** = authc</code>

File: web/src/main/java/org/apache/ki/web/filter/authc/BasicHttpAuthenticationFilter.java
Patch:
@@ -123,7 +123,7 @@ public String getApplicationName() {
      * <p/>
      * Side note: As you can see from the header text, the HTTP Basic specification calls
      * this the authentication 'realm', but we call this the 'applicationName' instead to avoid confusion with
-     * Apache Ki's Realm constructs.
+     * Ki's Realm constructs.
      *
      * @param applicationName the name to use in the ServletResponse's 'WWW-Authenticate' header.
      */

File: web/src/main/java/org/apache/ki/web/servlet/KiHttpServletRequest.java
Patch:
@@ -40,7 +40,7 @@ public class KiHttpServletRequest extends HttpServletRequestWrapper {
 
     //TODO - complete JavaDoc
 
-    //The following 7 constants support the Apache Ki's implementation of the Servlet Specification
+    //The following 7 constants support the Ki's implementation of the Servlet Specification
     public static final String COOKIE_SESSION_ID_SOURCE = "cookie";
     public static final String URL_SESSION_ID_SOURCE = "url";
     public static final String REFERENCED_SESSION_ID = KiHttpServletRequest.class.getName() + "_REQUESTED_SESSION_ID";
@@ -49,7 +49,7 @@ public class KiHttpServletRequest extends HttpServletRequestWrapper {
     public static final String REFERENCED_SESSION_ID_SOURCE = KiHttpServletRequest.class.getName() + "REFERENCED_SESSION_ID_SOURCE";
     public static final String SESSION_ID_NAME = KiHttpSession.DEFAULT_SESSION_ID_NAME;
     /**
-     * Key that may be used to alert that the request's  referenced Apache Ki Session has expired prior to
+     * Key that may be used to alert that the request's  referenced Ki Session has expired prior to
      * request processing.
      */
     public static final String EXPIRED_SESSION_KEY = KiHttpServletRequest.class.getName() + "_EXPIRED_SESSION_KEY";

File: web/src/main/java/org/apache/ki/web/servlet/KiHttpSession.java
Patch:
@@ -37,7 +37,7 @@
 
 
 /**
- * Wrapper class that uses a Apache Ki session under the hood for all session operations instead of the
+ * Wrapper class that uses a Ki session under the hood for all session operations instead of the
  * Servlet Container's session mechanism.  This is preferred in heterogeneous client environments where the Session
  * is used on both the business tier as well as in multiple client technologies (web, swing, flash, etc).
  *
@@ -73,7 +73,7 @@ public Enumeration getIds() {
 
     protected ServletContext servletContext = null;
     protected HttpServletRequest currentRequest = null;
-    protected Session session = null; //'real' Apache Ki Session
+    protected Session session = null; //'real' Ki Session
 
     public KiHttpSession(Session session, HttpServletRequest currentRequest, ServletContext servletContext) {
         if (session instanceof WebSession) {

File: web/src/main/java/org/apache/ki/web/session/ServletContainerSessionManager.java
Patch:
@@ -38,8 +38,8 @@
  * Servlet container's HttpSession.
  * <p/>
  * Despite its name, this implementation <em>does not</em> itself manage Sessions since the Servlet container
- * provides the actual management support.  This class mainly exists to 'impersonate' a regular Apache Ki
- * <tt>SessionManager</tt> so it can be pluggable into a normal Apache Ki configuration in a pure web application.
+ * provides the actual management support.  This class mainly exists to 'impersonate' a regular Ki
+ * <tt>SessionManager</tt> so it can be pluggable into a normal Ki configuration in a pure web application.
  * <p/>
  * Note that because this implementation relies on the {@link HttpSession HttpSession}, it is only functional in a
  * servlet container.  I.e. it is <em>NOT</em> capable of supporting Sessions any clients other than

File: web/src/main/java/org/apache/ki/web/session/WebSession.java
Patch:
@@ -134,7 +134,7 @@ public Collection<Object> getAttributeKeys() throws InvalidSessionException {
 
     private static String assertString(Object key) {
         if (!(key instanceof String)) {
-            String msg = "HttpSession based implementations of the Apache Ki Session interface requires attribute keys " +
+            String msg = "HttpSession based implementations of the Ki Session interface requires attribute keys " +
                     "to be String objects.  The HttpSession class does not support anything other than String keys.";
             throw new IllegalArgumentException(msg);
         }

File: core/src/org/apache/ki/realm/ldap/AbstractLdapRealm.java
Patch:
@@ -186,6 +186,9 @@ protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)
         AuthenticationInfo info = null;
         try {
             info = queryForAuthenticationInfo(token, this.ldapContextFactory);
+        } catch (javax.naming.AuthenticationException e) {
+            throw new AuthenticationException( "LDAP authentication failed.", e );
+
         } catch (NamingException e) {
             if (log.isErrorEnabled()) {
                 final String message = "LDAP naming error while attempting to authenticate user.";

File: web/src/org/jsecurity/web/DefaultWebSecurityManager.java
Patch:
@@ -75,7 +75,7 @@ public DefaultWebSecurityManager(Collection<Realm> realms) {
         this();
         setRealms(realms);
     }
-
+    
     /**
      * Sets the path used to store the remember me cookie.  This determines which paths
      * are able to view the remember me cookie.
@@ -149,7 +149,6 @@ public void setSessionMode(String sessionMode) {
             LifecycleUtils.destroy(getSessionManager());
             WebSessionManager sessionManager = createSessionManager(mode);
             setSessionManager(sessionManager);
-            setSubjectFactory(new WebSubjectFactory(this, sessionManager));
         }
     }
 

File: web/src/org/jsecurity/web/session/DefaultWebSessionManager.java
Patch:
@@ -229,7 +229,8 @@ protected Serializable start(ServletRequest request, ServletResponse response, I
         return sessionId;
     }
 
-    public Session retrieveSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {
+    @Override
+    protected Session retrieveSession(Serializable sessionId) throws InvalidSessionException, AuthorizationException {
         if (sessionId != null) {
             return super.retrieveSession(sessionId);
         } else {

File: web/src/org/jsecurity/web/attr/CookieAttribute.java
Patch:
@@ -243,8 +243,8 @@ public T onRetrieveValue(ServletRequest request, ServletResponse response) {
         Cookie cookie = getCookie(toHttp(request), getName());
         if (cookie != null && cookie.getMaxAge() != 0) {
             stringValue = cookie.getValue();
-            if (log.isInfoEnabled()) {
-                log.info("Found string value [" + stringValue + "] from HttpServletRequest Cookie [" + getName() + "]");
+            if (log.isDebugEnabled()) {
+                log.debug("Found string value [" + stringValue + "] from HttpServletRequest Cookie [" + getName() + "]");
             }
             value = fromStringValue(stringValue);
         } else {

File: core/src/org/jsecurity/mgt/DefaultSecurityManager.java
Patch:
@@ -476,7 +476,7 @@ protected boolean isAuthenticated(Session session, PrincipalCollection principal
      * @see org.jsecurity.authz.HostUnauthorizedException
      * @since 1.0
      */
-    protected Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {
+    private Subject getSubjectBySessionId(Serializable sessionId) throws InvalidSessionException, AuthorizationException {
         if (!isValid(sessionId)) {
             String msg = "Specified id [" + sessionId + "] does not correspond to a valid Session  It either " +
                     "does not exist or the corresponding session has been stopped or expired.";

File: core/src/org/jsecurity/session/mgt/AbstractSessionManager.java
Patch:
@@ -51,6 +51,7 @@ public abstract class AbstractSessionManager implements SessionManager, SessionL
     private long globalSessionTimeout = DEFAULT_GLOBAL_SESSION_TIMEOUT;
     private Collection<SessionListener> listeners = new ArrayList<SessionListener>();
 
+
     public AbstractSessionManager() {
     }
 

File: core/src/org/jsecurity/subject/DelegatingSubject.java
Patch:
@@ -238,8 +238,8 @@ public void checkRoles(Collection<String> roles) throws AuthorizationException {
     }
 
     public void login(AuthenticationToken token) throws AuthenticationException {
-        Subject authcSecCtx = securityManager.login(token);
-        PrincipalCollection principals = authcSecCtx.getPrincipals();
+        Subject subject = securityManager.login(token);
+        PrincipalCollection principals = subject.getPrincipals();
         if (principals == null || principals.isEmpty()) {
             String msg = "Principals returned from securityManager.login( token ) returned a null or " +
                     "empty value.  This value must be non null and populated with one or more elements.  " +
@@ -248,7 +248,7 @@ public void login(AuthenticationToken token) throws AuthenticationException {
             throw new IllegalStateException(msg);
         }
         this.principals = principals;
-        Session session = authcSecCtx.getSession(false);
+        Session session = subject.getSession(false);
         if (session != null) {
             if (session instanceof StoppingAwareProxiedSession) {
                 this.session = session;

File: web/src/org/jsecurity/web/session/DefaultWebSessionManager.java
Patch:
@@ -259,8 +259,8 @@ public final Session getSession(ServletRequest request, ServletResponse response
             session = doGetSession(request, response);
         } catch (InvalidSessionException ise) {
             if (log.isTraceEnabled()) {
-                log.trace("Request Session is invalid, message: [" + ise.getMessage() + "].  Removing any " +
-                        "associated session cookie...");
+                log.trace("Request Session with id [" + ise.getSessionId() + "] is invalid, message: [" +
+                        ise.getMessage() + "].  Removing any associated session cookie...");
             }
             getSessionIdCookieAttribute().removeValue(request, response);
 

File: core/src/org/jsecurity/util/Nameable.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.jsecurity.util;
 
-BREAK BUILD
 
 /**
  * Interface implemented by components that can be named, such as via configuration, and wish to have that name

File: core/src/org/jsecurity/authz/HostUnauthorizedException.java
Patch:
@@ -26,7 +26,7 @@
  * or access a particular resource.
  *
  * @author Les Hazlewood
- * @see org.jsecurity.session.SessionFactory#start(java.net.InetAddress)
+ * @see org.jsecurity.session.mgt.SessionManager#start(java.net.InetAddress)
  * @since 0.1
  */
 public class HostUnauthorizedException extends UnauthorizedException {

File: core/src/org/jsecurity/session/Session.java
Patch:
@@ -33,7 +33,7 @@
  * {@link javax.servlet.http.HttpSession HttpSession} or Stateful Session EJB's, which many times
  * unnecessarily coupled applications to web or ejb technologies.
  *
- * <p>See the {@link SessionFactory#getSession(java.io.Serializable) SessionFactory.getSession(Serializable)}
+ * <p>See the {@link org.jsecurity.mgt.SecurityManager#getSession(java.io.Serializable) SecurityManager.getSession(Serializable)}
  * JavaDoc for more on the benefits of a POJO-based <tt>Session</tt> framework.
  *
  * @author Les Hazlewood
@@ -107,7 +107,7 @@ public interface Session {
      *
      * @return the <tt>InetAddress</tt> of the host that originated this session, or <tt>null</tt>
      *         if the host address is unknown.
-     * @see SessionFactory#start(java.net.InetAddress)
+     * @see org.jsecurity.session.mgt.SessionManager#start(java.net.InetAddress)
      */
     InetAddress getHostAddress();
 

File: support/spring/src/org/jsecurity/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -111,6 +111,7 @@ public Object invoke(RemoteInvocation invocation, Object targetObject) throws No
             Serializable sessionId = invocation.getAttribute(SecureRemoteInvocationFactory.SESSION_ID_KEY);
 
             if (sessionId != null) {
+
                 session = securityManager.getSession(sessionId);
                 principals = getPrincipals(invocation, targetObject, session);
                 authenticated = isAuthenticated(invocation, targetObject, session, principals);

File: core/test/org/jsecurity/mgt/DefaultSecurityManagerTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.jsecurity.authc.AuthenticationToken;
 import org.jsecurity.authc.UsernamePasswordToken;
+import org.jsecurity.realm.text.PropertiesRealm;
 import org.jsecurity.session.Session;
 import org.jsecurity.subject.Subject;
 import org.jsecurity.util.ThreadContext;
@@ -39,6 +40,7 @@ public class DefaultSecurityManagerTest {
     @Before
     public void setup() {
         sm = new DefaultSecurityManager();
+        sm.setRealm(new PropertiesRealm());
         ThreadContext.clear();
     }
 

File: core/test/org/jsecurity/mgt/VMSingletonDefaultSecurityManagerTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.jsecurity.SecurityUtils;
 import org.jsecurity.authc.AuthenticationToken;
 import org.jsecurity.authc.UsernamePasswordToken;
+import org.jsecurity.realm.text.PropertiesRealm;
 import org.jsecurity.subject.Subject;
 import org.jsecurity.util.ThreadContext;
 import org.junit.After;
@@ -47,6 +48,7 @@ public void tearDown() {
     @Test
     public void testVMSingleton() {
         DefaultSecurityManager sm = new DefaultSecurityManager();
+        sm.setRealm(new PropertiesRealm());
         SecurityUtils.setSecurityManager(sm);
 
         Subject subject = SecurityUtils.getSubject();

File: src/org/jsecurity/aop/AnnotationHandler.java
Patch:
@@ -27,7 +27,7 @@
  * Base support class for implementations that reads and processes JSR-175 annotations.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public abstract class AnnotationHandler {
 

File: src/org/jsecurity/authz/annotation/RequiresAuthentication.java
Patch:
@@ -38,7 +38,7 @@
  * @see RequiresUser
  * @see RequiresGuest
  *
- * @since 0.9.0 RC3
+ * @since 0.9.0
  * @author Les Hazlewood
  */
 @Target(ElementType.METHOD)

File: src/org/jsecurity/authz/annotation/RequiresGuest.java
Patch:
@@ -35,7 +35,7 @@
  * @see RequiresAuthentication
  * @see RequiresUser
  *
- * @since 0.9.0 RC3
+ * @since 0.9.0
  * @author Les Hazlewood
  */
 @Target(ElementType.METHOD)

File: src/org/jsecurity/authz/annotation/RequiresUser.java
Patch:
@@ -43,7 +43,7 @@
  * @see RequiresAuthentication
  * @see RequiresGuest
  *
- * @since 0.9.0 RC3
+ * @since 0.9.0
  * @author Les Hazlewood
  */
 @Target(ElementType.METHOD)

File: src/org/jsecurity/authz/aop/AuthenticatedAnnotationHandler.java
Patch:
@@ -28,7 +28,7 @@
  * authenticated before allowing access.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class AuthenticatedAnnotationHandler extends AuthorizingAnnotationHandler {
 

File: src/org/jsecurity/authz/aop/AuthenticatedAnnotationMethodInterceptor.java
Patch:
@@ -24,7 +24,7 @@
  * <code>Subject</code>.{@link org.jsecurity.subject.Subject#isAuthenticated() isAuthenticated()} before invoking
  * the method.
  *
- * @since 0.9.0 RC3
+ * @since 0.9.0
  * @author Les Hazlewood
  */
 public class AuthenticatedAnnotationMethodInterceptor extends AuthorizingAnnotationMethodInterceptor {

File: src/org/jsecurity/authz/aop/AuthorizingAnnotationHandler.java
Patch:
@@ -27,7 +27,7 @@
  * An AnnotationHandler that executes authorization (access control) behavior based on directive(s) found in a
  * JSR-175 Annotation.
  *
- * @since 0.9.0 RC3
+ * @since 0.9.0
  * @author Les Hazlewood
  */
 public abstract class AuthorizingAnnotationHandler extends AnnotationHandler {

File: src/org/jsecurity/authz/aop/GuestAnnotationHandler.java
Patch:
@@ -32,7 +32,7 @@
  * This annotation essentially ensures that <code>subject.{@link org.jsecurity.subject.Subject#getPrincipal() getPrincipal()} == null</code>.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class GuestAnnotationHandler extends AuthorizingAnnotationHandler {
 

File: src/org/jsecurity/authz/aop/GuestAnnotationMethodInterceptor.java
Patch:
@@ -26,7 +26,7 @@
  * This annotation essentially ensures that <code>subject.{@link org.jsecurity.subject.Subject#getPrincipal() getPrincipal()} == null</code>.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class GuestAnnotationMethodInterceptor extends AuthorizingAnnotationMethodInterceptor {
 

File: src/org/jsecurity/authz/aop/PermissionAnnotationHandler.java
Patch:
@@ -33,7 +33,7 @@
  * access.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class PermissionAnnotationHandler extends AuthorizingAnnotationHandler {
 

File: src/org/jsecurity/authz/aop/RoleAnnotationHandler.java
Patch:
@@ -32,7 +32,7 @@
  * a role check to see if the calling <code>Subject</code> is allowed to proceed.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class RoleAnnotationHandler extends AuthorizingAnnotationHandler {
 

File: src/org/jsecurity/authz/aop/UserAnnotationHandler.java
Patch:
@@ -33,7 +33,7 @@
  * This annotation essentially ensures that <code>subject.{@link org.jsecurity.subject.Subject#getPrincipal() getPrincipal()} != null</code>.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class UserAnnotationHandler extends AuthorizingAnnotationHandler {
 

File: src/org/jsecurity/authz/aop/UserAnnotationMethodInterceptor.java
Patch:
@@ -27,7 +27,7 @@
  * This annotation essentially ensures that <code>subject.{@link org.jsecurity.subject.Subject#getPrincipal() getPrincipal()} != null</code>.
  *
  * @author Les Hazlewood
- * @since 0.9.0 RC3
+ * @since 0.9.0
  */
 public class UserAnnotationMethodInterceptor extends AuthorizingAnnotationMethodInterceptor {
 

File: src/org/jsecurity/web/config/IniWebConfiguration.java
Patch:
@@ -75,7 +75,7 @@ public IniWebConfiguration() {
      *
      * @return the <code>PatternMatcher</code> used when determining if an incoming request's path
      *         matches a configured filter chain path in the <code>[urls]</code> section.
-     * @since 0.9.0 final
+     * @since 0.9.0
      */
     public PatternMatcher getPathMatcher() {
         return pathMatcher;
@@ -88,7 +88,7 @@ public PatternMatcher getPathMatcher() {
      *
      * @param pathMatcher the <code>PatternMatcher</code> used when determining if an incoming request's path
      *                    matches a configured filter chain path in the <code>[urls]</code> section.
-     * @since 0.9.0 final
+     * @since 0.9.0
      */
     public void setPathMatcher(PatternMatcher pathMatcher) {
         this.pathMatcher = pathMatcher;

File: src/org/jsecurity/mgt/CachingSecurityManager.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.commons.logging.LogFactory;
 import org.jsecurity.cache.CacheManager;
 import org.jsecurity.cache.CacheManagerAware;
+import org.jsecurity.cache.HashtableCacheManager;
 import org.jsecurity.util.Destroyable;
 import org.jsecurity.util.LifecycleUtils;
 
@@ -138,6 +139,7 @@ protected CacheManager createCacheManager() {
         }
 
         try {
+            manager = new HashtableCacheManager();
             /**
              * TODO: JSEC-24
              EhCacheManager ehCacheManager = new EhCacheManager();

File: src/org/jsecurity/web/attr/CookieAttribute.java
Patch:
@@ -233,7 +233,7 @@ public T onRetrieveValue(ServletRequest request, ServletResponse response) {
 
         String stringValue;
         Cookie cookie = getCookie(toHttp(request), getName());
-        if (cookie != null) {
+        if (cookie != null && cookie.getMaxAge() != 0 ) {
             stringValue = cookie.getValue();
             if (log.isInfoEnabled()) {
                 log.info("Found string value [" + stringValue + "] from HttpServletRequest Cookie [" + getName() + "]");

File: src/org/jsecurity/SecurityUtils.java
Patch:
@@ -85,7 +85,6 @@ public static Subject getSubject() {
      *
      * <code>DefaultSecurityManager securityManager = new {@link org.jsecurity.mgt.DefaultSecurityManager DefaultSecurityManager}();<br/>
      * securityManager.setRealms( ... ); //one or more Realms<br/>
-     * securityManager.init();<br/>
      * <b>SecurityUtils.setSecurityManager( securityManager );</b></code>
      *
      * <p>And then anywhere in the application code, the following call will return the application's Subject:</p>

File: src/org/jsecurity/authz/aop/PermissionAnnotationMethodInterceptor.java
Patch:
@@ -37,8 +37,7 @@ public class PermissionAnnotationMethodInterceptor extends AuthorizingAnnotation
     private static final char ARRAY_CLOSE_CHAR = ']';
 
     public PermissionAnnotationMethodInterceptor() {
-        setAnnotationClass(RequiresPermissions.class);
-        init();
+        super(RequiresPermissions.class);
     }
 
     protected String inferTargetFromPath(Object[] methodArgs, String namePath) throws Exception {

File: src/org/jsecurity/authz/aop/RoleAnnotationMethodInterceptor.java
Patch:
@@ -34,8 +34,7 @@
 public class RoleAnnotationMethodInterceptor extends AuthorizingAnnotationMethodInterceptor {
 
     public RoleAnnotationMethodInterceptor() {
-        setAnnotationClass(RequiresRoles.class);
-        init();
+        super(RequiresRoles.class);
     }
 
     public void assertAuthorized(MethodInvocation mi) throws AuthorizationException {

File: src/org/jsecurity/cache/ehcache/EhCacheManager.java
Patch:
@@ -62,6 +62,9 @@ public class EhCacheManager implements CacheManager, Initializable, Destroyable
      */
     private String cacheManagerConfigFile = "classpath:org/jsecurity/cache/ehcache/ehcache.xml";
 
+    public EhCacheManager() {
+    }
+
     /**
      * Returns the wrapped Ehcache {@link net.sf.ehcache.CacheManager CacheManager} instance.
      *

File: src/org/jsecurity/realm/SimpleAccountRealm.java
Patch:
@@ -47,6 +47,7 @@ public class SimpleAccountRealm extends AuthorizingRealm {
     protected Map<String, SimpleRole> roles = null;
 
     public SimpleAccountRealm() {
+        init();
     }
 
     public void afterAuthorizationCacheSet() {

File: src/org/jsecurity/realm/ldap/AbstractLdapRealm.java
Patch:
@@ -27,7 +27,6 @@
 import org.jsecurity.realm.AuthorizingRealm;
 import org.jsecurity.realm.Realm;
 import org.jsecurity.subject.PrincipalCollection;
-import org.jsecurity.util.Initializable;
 
 import javax.naming.NamingException;
 
@@ -53,7 +52,7 @@
  * @see # queryForAuthorizationInfo (PrincipalCollection, LdapContextFactory)
  * @since 0.1
  */
-public abstract class AbstractLdapRealm extends AuthorizingRealm implements Initializable {
+public abstract class AbstractLdapRealm extends AuthorizingRealm {
 
     /*--------------------------------------------
     |             C O N S T A N T S             |

File: support/spring/src/org/jsecurity/spring/security/interceptor/AuthorizationAttributeSourceAdvisor.java
Patch:
@@ -78,9 +78,8 @@ public void afterPropertiesSet() throws Exception {
                         "default instance of type [" +
                         AopAllianceAnnotationsAuthorizingMethodInterceptor.class.getName() + "]");
             }
-            AopAllianceAnnotationsAuthorizingMethodInterceptor interceptor = new AopAllianceAnnotationsAuthorizingMethodInterceptor();
-            interceptor.init();
-
+            AopAllianceAnnotationsAuthorizingMethodInterceptor interceptor =
+                    new AopAllianceAnnotationsAuthorizingMethodInterceptor();
             setAdvice(interceptor);
         }
     }

File: test/org/jsecurity/authc/pam/AllSuccessfulModularAuthenticationStrategyTest.java
Patch:
@@ -47,8 +47,7 @@ public void beforeAllAttempts() {
 
     @Test
     public void beforeAttemptSupportingToken() {
-        SimpleAccountRealm realm = new SimpleAccountRealm();
-        realm.init();
+        new SimpleAccountRealm();
     }
 
     @Test(expected = UnsupportedTokenException.class)

File: src/org/jsecurity/session/mgt/ImmutableProxiedSession.java
Patch:
@@ -187,11 +187,10 @@ public Collection<Object> getAttributeKeys() throws InvalidSessionException {
 
     /**
      * Immediately delegates to the underlying proxied session.
-     * param key the unique name of the object bound to this session
      *
+     * @param key the unique name of the object bound to this session
      * @return the object bound under the specified <tt>key</tt> name or <tt>null</tt> if there is
      *         no object bound under that name.
-     * @throws InvalidSessionException
      */
     public Object getAttribute(Object key) throws InvalidSessionException {
         return this.session.getAttribute(key);

File: src/org/jsecurity/session/Session.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.Date;
 
 /**
- * A <tt>Session</tt> is a data/state context associated with a single Subject (user, 3rd party process,
- * etc) that interacts with a software system over a period of time.
+ * A <tt>Session</tt> is a stateful data context associated with a single Subject (user, 3rd party process,
+ * etc) who interacts with a software system over a period of time.
  *
  * <p>A <tt>Session</tt> is intended to be managed by the business tier and accessible via other
  * tiers without being tied to any given client technology.  This is a <em>great</em> benefit to Java

File: src/org/jsecurity/session/mgt/ImmutableProxiedSession.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Implementation of the {@link Session Session} interface that proxies another <code>Session</code>, but does not
- * allow any write operations to the underlying session. It allows read-only operations only.
+ * allow any 'write' operations to the underlying session. It allows 'read' operations only.
  * <p/>
  * The <code>Session</code> write operations are defined as follows.  A call to any of these methods on this
  * proxy will immediately result in an {@link InvalidSessionException} being thrown:

File: src/org/jsecurity/session/mgt/AbstractSessionManager.java
Patch:
@@ -66,7 +66,7 @@ public Serializable start(InetAddress originatingHost) throws HostUnauthorizedEx
 
     /**
      * Returns the session instance to use to pass to registered <code>SessionListener</code>s for notification
-     * that the session has been validated (stopped or expired).
+     * that the session has been invalidated (stopped or expired).
      * <p/>
      * The default implementation returns an
      * {@link org.jsecurity.session.mgt.ImmutableProxiedSession ImmutableProxiedSession} instance to ensure

File: src/org/jsecurity/authz/permission/WildcardPermission.java
Patch:
@@ -133,11 +133,11 @@ public WildcardPermission(String wildcardString, boolean caseSensitive) {
 
         wildcardString = wildcardString.trim();
 
-        List<String> parts = CollectionUtils.newArrayList(wildcardString.split(PART_DIVIDER_TOKEN));
+        List<String> parts = CollectionUtils.asList(wildcardString.split(PART_DIVIDER_TOKEN));
 
         this.parts = new ArrayList<Set<String>>();
         for (String part : parts) {
-            Set<String> subparts = CollectionUtils.newLinkedHashSet(part.split(SUBPART_DIVIDER_TOKEN));
+            Set<String> subparts = CollectionUtils.asSet(part.split(SUBPART_DIVIDER_TOKEN));
 
             if (!caseSensitive) {
                 subparts = lowercase(subparts);

File: src/org/jsecurity/authc/AbstractAuthenticator.java
Patch:
@@ -51,12 +51,13 @@ public abstract class AbstractAuthenticator implements Authenticator, LogoutAwar
     /*--------------------------------------------
     |    I N S T A N C E   V A R I A B L E S    |
     ============================================*/
-    private Collection<AuthenticationListener> listeners = new ArrayList<AuthenticationListener>();
+    private Collection<AuthenticationListener> listeners;
 
     /*--------------------------------------------
     |         C O N S T R U C T O R S           |
     ============================================*/
     public AbstractAuthenticator() {
+        listeners = new ArrayList<AuthenticationListener>();
     }
 
     /*--------------------------------------------

File: src/org/jsecurity/config/TextConfiguration.java
Patch:
@@ -53,6 +53,7 @@ public void setConfig(String config) {
     /**
      * Loads the configuration specified by the 'config' argument by creating a StringReader
      * and using it to load the config.
+     *
      * @param config the config text to be loaded.
      */
     protected void loadTextConfig(String config) {
@@ -77,6 +78,4 @@ public void init() throws JSecurityException {
             }
         }
     }
-
-
 }

File: src/org/jsecurity/web/DefaultWebSecurityManager.java
Patch:
@@ -133,11 +133,12 @@ public void setSessionMode(String sessionMode) {
                     HTTP_SESSION_MODE + "' being the default.";
             throw new IllegalArgumentException(msg);
         }
-        boolean recreate = !this.sessionMode.equals(sessionMode);
+        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(sessionMode);
         this.sessionMode = sessionMode;
         if (recreate) {
             LifecycleUtils.destroy(getSessionManager());
-            createSessionManager();
+            SessionManager sm = createSessionManager();
+            setSessionManager(sm);
         }
     }
 

File: support/spring/src/org/jsecurity/spring/SpringJSecurityFilter.java
Patch:
@@ -21,7 +21,7 @@
 import org.jsecurity.web.servlet.JSecurityFilter;
 
 /**
- * <p>Extension of JSecurityFilter that uses {@link SpringConfiguration} to configure the JSecurity instance.</p>
+ * <p>Extension of JSecurityFilter that uses {@link SpringWebConfiguration} to configure the JSecurity instance.</p>
  *
  * @author Les Hazlewood
  * @author Jeremy Haile
@@ -30,6 +30,6 @@
 public class SpringJSecurityFilter extends JSecurityFilter {
 
     public SpringJSecurityFilter() {
-        this.configClassName = SpringConfiguration.class.getName();
+        this.configClassName = SpringWebConfiguration.class.getName();
     }
 }

File: src/org/jsecurity/session/mgt/AbstractValidatingSessionManager.java
Patch:
@@ -64,6 +64,7 @@ public abstract class AbstractValidatingSessionManager extends AbstractSessionMa
     protected long globalSessionTimeout = DEFAULT_GLOBAL_SESSION_TIMEOUT;
 
     public AbstractValidatingSessionManager() {
+        init();
     }
 
     public boolean isSessionValidationSchedulerEnabled() {

File: src/org/jsecurity/session/mgt/DefaultSessionManager.java
Patch:
@@ -41,7 +41,6 @@ public class DefaultSessionManager extends AbstractValidatingSessionManager impl
     protected SessionDAO sessionDAO = new MemorySessionDAO();
 
     public DefaultSessionManager() {
-        startSessionValidation();
     }
 
     public void setSessionDAO(SessionDAO sessionDAO) {

File: src/org/jsecurity/web/DefaultWebSecurityManager.java
Patch:
@@ -150,7 +150,7 @@ public void setSessionMode(String sessionMode) {
     }
 
     public boolean isHttpSessionMode() {
-        return this.sessionMode != null && this.sessionMode.equals(HTTP_SESSION_MODE);
+        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);
     }
 
     protected SessionManager newSessionManagerInstance() {

File: src/org/jsecurity/web/DefaultWebSecurityManager.java
Patch:
@@ -18,8 +18,6 @@
  */
 package org.jsecurity.web;
 
-import org.jsecurity.authc.AuthenticationInfo;
-import org.jsecurity.authc.AuthenticationToken;
 import org.jsecurity.cache.CacheManager;
 import org.jsecurity.mgt.DefaultSecurityManager;
 import org.jsecurity.realm.Realm;
@@ -219,7 +217,7 @@ protected boolean isAuthenticated(ServletRequest servletRequest, ServletResponse
         return isAuthenticated(existing);
     }
 
-    public Subject createSubject(AuthenticationToken token, AuthenticationInfo info) {
+    public Subject createSubject() {
         ServletRequest request = WebUtils.getServletRequest();
         ServletResponse response = WebUtils.getServletResponse();
         return createSubject(request, response);

File: src/org/jsecurity/authc/pam/ModularRealmAuthenticator.java
Patch:
@@ -204,15 +204,15 @@ protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms,
 
         for (Realm realm : realms) {
 
-            aggregate = strategy.beforeAttempt(realm, token, aggregate);
-
             if (realm.supports(token)) {
 
                 if (log.isDebugEnabled()) {
                     log.debug("Attempting to authenticate token [" + token + "] " +
                             "using realm of type [" + realm + "]");
                 }
 
+                aggregate = strategy.beforeAttempt(realm, token, aggregate);
+
                 Account account = null;
                 Throwable t = null;
                 try {

File: src/org/jsecurity/logging/JSecurityLogFactory.java
Patch:
@@ -65,7 +65,7 @@ public static Log getLog(String name) {
     }
 
     public static Log getLog(Class clazz) {
-        return instance.getLog(clazz.getName());
+        return getLog(clazz.getName());
     }
 
     public static void setLogFactory(LogFactory instance) {

File: src/org/jsecurity/logging/NoOpLog.java
Patch:
@@ -24,6 +24,8 @@
  */
 public class NoOpLog implements Log {
 
+    public static transient final NoOpLog INSTANCE = new NoOpLog("NoOp");
+
     private String name;
 
     public NoOpLog(String name) {

File: src/org/jsecurity/logging/NoOpLogFactory.java
Patch:
@@ -25,6 +25,6 @@
 public class NoOpLogFactory implements LogFactory {
 
     public Log getLog(String name) {
-        return new NoOpLog(name);
+        return NoOpLog.INSTANCE;
     }
 }

File: src/org/jsecurity/io/DefaultSerializer.java
Patch:
@@ -42,7 +42,9 @@ public byte[] serialize(Object o) throws SerializationException {
             oos.close();
             return baos.toByteArray();
         } catch (IOException e) {
-            String msg = "Unable to serialize object [" + o + "].";
+            String msg = "Unable to serialize object [" + o + "].  " +
+                    "In order for the DefaultSerializer to serialize this object, the [" + o.getClass().getName() + "] " +
+                    "class must implement java.io.Serializable.";
             throw new SerializationException(msg, e);
         }
     }

File: src/org/jsecurity/mgt/CachingSecurityManager.java
Patch:
@@ -36,6 +36,7 @@
  * if one has not been provided.
  *
  * @author Les Hazlewood
+ * @author Jeremy Haile
  * @since 0.9
  */
 public abstract class CachingSecurityManager implements SecurityManager, Initializable, Destroyable, CacheManagerAware {
@@ -66,7 +67,7 @@ public void setCacheManager(CacheManager cacheManager) {
 
     public void init() {
         ensureCacheManager();
-        afterCacheManagerSet();
+        afterCacheManagerSet();       
     }
 
     protected void ensureCacheManager() {

File: src/org/jsecurity/web/filter/PathMatchingFilter.java
Patch:
@@ -22,6 +22,7 @@
 import static org.jsecurity.util.StringUtils.split;
 import static org.jsecurity.web.WebUtils.getPathWithinApplication;
 import static org.jsecurity.web.WebUtils.toHttp;
+import org.jsecurity.web.servlet.AdviceFilter;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -32,9 +33,10 @@
  * <p>Base class for Filters that will process only specified paths and allow all others to pass through.</p>
  *
  * @author Les Hazlewood
+ * @author Jeremy Haile
  * @since 0.9
  */
-public abstract class PathMatchingFilter extends RedirectingFilter implements PathConfigProcessor {
+public abstract class PathMatchingFilter extends AdviceFilter implements PathConfigProcessor {
 
     protected AntPathMatcher pathMatcher = new AntPathMatcher();
 

File: src/org/jsecurity/web/filter/authz/PermissionsAuthorizationFilter.java
Patch:
@@ -27,6 +27,7 @@
 
 /**
  * @author Les Hazlewood
+ * @author Jeremy Haile
  * @since 0.9
  */
 public class PermissionsAuthorizationFilter extends AuthorizationFilter {
@@ -48,11 +49,11 @@ public boolean onPreHandle(ServletRequest request, ServletResponse response, Obj
         if (perms != null && perms.length > 0) {
             if (perms.length == 1) {
                 if (!subject.isPermitted(perms[0])) {
-                    issueRedirect(request, response);
+                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());
                 }
             } else {
                 if (!subject.isPermittedAll(perms)) {
-                    issueRedirect(request, response);
+                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());
                 }
             }
         }

File: src/org/jsecurity/web/filter/authz/RolesAuthorizationFilter.java
Patch:
@@ -30,6 +30,7 @@
 
 /**
  * @author Les Hazlewood
+ * @author Jeremy Haile
  * @since 0.9
  */
 public class RolesAuthorizationFilter extends AuthorizationFilter {
@@ -53,11 +54,11 @@ public boolean onPreHandle(ServletRequest request, ServletResponse response, Obj
         if (roles != null && !roles.isEmpty()) {
             if (roles.size() == 1) {
                 if (!subject.hasRole(roles.iterator().next())) {
-                    issueRedirect(request, response);
+                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());
                 }
             } else {
                 if (!subject.hasAllRoles(roles)) {
-                    issueRedirect(request, response);
+                    WebUtils.issueRedirect(request, response, getUnauthorizedUrl());
                 }
             }
         }

File: test/org/jsecurity/web/servlet/JSecurityFilterTest.java
Patch:
@@ -19,7 +19,6 @@
 package org.jsecurity.web.servlet;
 
 import static org.easymock.EasyMock.*;
-import org.jsecurity.mgt.SecurityManager;
 import org.junit.Test;
 
 import javax.servlet.FilterConfig;
@@ -42,8 +41,6 @@ protected void setUp(String config) {
         expect(mockFilterConfig.getServletContext()).andReturn(mockServletContext);
         expect(mockFilterConfig.getInitParameter(JSecurityFilter.CONFIG_CLASS_NAME_INIT_PARAM_NAME)).andReturn(null).once();
         expect(mockFilterConfig.getInitParameter(JSecurityFilter.CONFIG_INIT_PARAM_NAME)).andReturn(config).once();
-
-        mockServletContext.setAttribute(eq(JSecurityFilter.SECURITY_MANAGER_CONTEXT_KEY), isA(SecurityManager.class));
     }
 
     public void tearDown() throws Exception {

File: src/org/jsecurity/authz/aop/AnnotationsAuthorizingMethodInterceptor.java
Patch:
@@ -46,8 +46,8 @@ public void init() {
                         "Enabling default Role and Permission annotation support...");
             }
             methodInterceptors = new ArrayList<AuthorizingAnnotationMethodInterceptor>(2);
-            methodInterceptors.add(new RoleAnnotationMethodInterceptor(getSecurityManager()));
-            methodInterceptors.add(new PermissionAnnotationMethodInterceptor(getSecurityManager()));
+            methodInterceptors.add(new RoleAnnotationMethodInterceptor());
+            methodInterceptors.add(new PermissionAnnotationMethodInterceptor());
         }
 
     }

File: src/org/jsecurity/jndi/JndiLocator.java
Patch:
@@ -133,10 +133,10 @@ protected Object lookup(String jndiName) throws NamingException {
      */
     protected Object lookup(String jndiName, Class requiredType) throws NamingException {
         if (jndiName == null) {
-            throw new IllegalArgumentException("'jndiName' must not be null");
+            throw new IllegalArgumentException("jndiName argument must not be null");
         }
         String convertedName = convertJndiName(jndiName);
-        Object jndiObject = null;
+        Object jndiObject;
         try {
             jndiObject = getJndiTemplate().lookup(convertedName, requiredType);
         }

File: src/org/jsecurity/web/attr/AbstractWebAttribute.java
Patch:
@@ -138,6 +138,7 @@ public void setMutable(boolean mutable) {
     public void init() {
     }
 
+    @SuppressWarnings({"unchecked"})
     protected T fromStringValue(String stringValue) {
         Class clazz = getEditorClass();
         if (clazz == null) {

File: src/org/jsecurity/cache/ehcache/EhCacheManager.java
Patch:
@@ -20,10 +20,10 @@
 import org.jsecurity.cache.Cache;
 import org.jsecurity.cache.CacheException;
 import org.jsecurity.cache.CacheManager;
+import org.jsecurity.io.ResourceUtils;
 import org.jsecurity.session.mgt.eis.CachingSessionDAO;
 import org.jsecurity.util.Destroyable;
 import org.jsecurity.util.Initializable;
-import org.jsecurity.util.ResourceUtils;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -95,7 +95,7 @@ public String getCacheManagerConfigFile() {
     /**
      * Sets the resource location of the config file used to initialize the wrapped
      * EhCache CacheManager instance.  The string can be any resource path supported by the
-     * {@link ResourceUtils#getInputStreamForPath(String)} call.
+     * {@link org.jsecurity.io.ResourceUtils#getInputStreamForPath(String)} call.
      *
      * <p>This property is ignored if the CacheManager instance is injected directly - that is, it is only used to
      * lazily create a CacheManager if one is not already provided.</p>

File: src/org/jsecurity/config/IniConfiguration.java
Patch:
@@ -16,13 +16,13 @@
 package org.jsecurity.config;
 
 import org.jsecurity.io.IniResource;
+import org.jsecurity.io.ResourceUtils;
 import org.jsecurity.mgt.DefaultSecurityManager;
 import org.jsecurity.mgt.RealmSecurityManager;
 import org.jsecurity.mgt.SecurityManager;
 import org.jsecurity.realm.Realm;
 import org.jsecurity.realm.RealmFactory;
 import org.jsecurity.util.LifecycleUtils;
-import org.jsecurity.util.ResourceUtils;
 
 import java.io.InputStream;
 import java.io.Reader;

File: src/org/jsecurity/io/AbstractResource.java
Patch:
@@ -17,7 +17,6 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.jsecurity.util.ResourceUtils;
 
 import java.io.IOException;
 import java.io.InputStream;

File: src/org/jsecurity/realm/text/PropertiesRealm.java
Patch:
@@ -16,8 +16,8 @@
 package org.jsecurity.realm.text;
 
 import org.jsecurity.JSecurityException;
+import org.jsecurity.io.ResourceUtils;
 import org.jsecurity.util.Destroyable;
-import org.jsecurity.util.ResourceUtils;
 
 import java.io.File;
 import java.io.IOException;

File: src/org/jsecurity/crypto/hash/AbstractHash.java
Patch:
@@ -32,7 +32,7 @@
  * can be useful.
  * 
  * <p>This class and its subclasses support hashing with additional capabilities of salting and multiple iterations via
- * overloaded constructors</tt>.
+ * overloaded constructors</p>.
  *
  * @author Les Hazlewood
  * @since 0.9

File: src/org/jsecurity/io/TextResource.java
Patch:
@@ -64,8 +64,8 @@ public void load( String configBodyOrResourcePath ) {
         try {
             super.load(configBodyOrResourcePath);
         } catch ( Exception e ) {
-            if ( log.isDebugEnabled() ) {
-                log.debug( "Unable to load text resource from the string argument.  Attempting to use the string " +
+            if ( log.isTraceEnabled() ) {
+                log.trace( "Unable to load text resource from the string argument.  Attempting to use the string " +
                         "argument as the text resource itself...", e );
             }
             StringReader sr = new StringReader(configBodyOrResourcePath);

File: src/org/jsecurity/aop/AnnotationMethodInterceptor.java
Patch:
@@ -30,7 +30,6 @@ public abstract class AnnotationMethodInterceptor extends MethodInterceptorSuppo
     protected Class<? extends Annotation> annotationClass;
 
     public void init() {
-        super.init();
         if (annotationClass == null) {
             String msg = "annotationClass property must be set";
             throw new IllegalStateException(msg);

File: src/org/jsecurity/aop/MethodInterceptorSupport.java
Patch:
@@ -25,7 +25,7 @@
  * This class is an abstraction of AOP method interceptor behavior specific to JSecurity that
  * leaves AOP implementation specifics to be handled by subclass implementations.  This implementation primarily
  * enables a <tt>Log</tt> and makes available the application's {@link org.jsecurity.mgt.SecurityManager SecurityManager}
- * for use by subclasses.
+ * for use by subclasses, if one is provided (otherwise the subject will be retrieved using SecurityUtils).
  *
  * @since 0.2
  * @author Les Hazlewood

File: src/org/jsecurity/web/WebRememberMeManager.java
Patch:
@@ -38,6 +38,7 @@ public WebRememberMeManager() {
         super();
         CookieAttribute<String> attr = new CookieAttribute<String>(DEFAULT_REMEMBER_ME_COOKIE_NAME);
         attr.setCheckRequestParams(false);
+        attr.setMaxAge(CookieAttribute.INDEFINITE);
         this.identityAttribute = attr;
     }
 

File: src/org/jsecurity/web/attr/CookieAttribute.java
Patch:
@@ -31,8 +31,8 @@
  */
 public class CookieAttribute<T> extends AbstractWebAttribute<T> {
 
-    protected static final int ONE_YEAR = 60 * 60 * 24 * 365;
-    protected static final int INDEFINITE = Integer.MAX_VALUE;
+    public static final int ONE_YEAR = 60 * 60 * 24 * 365;
+    public static final int INDEFINITE = Integer.MAX_VALUE;
 
     private String path = null; //null means set it on the request context root
     private int maxAge = -1; //expire on browser close

File: src/org/jsecurity/web/interceptor/authc/FormAuthenticationWebInterceptor.java
Patch:
@@ -161,9 +161,11 @@ protected boolean isRememberMe( ServletRequest request, ServletResponse response
         String rememberMe = StringUtils.clean(request.getParameter(getRememberMeParam()));
         return rememberMe != null &&
                 (rememberMe.equalsIgnoreCase("true") ||
+                 rememberMe.equalsIgnoreCase("t") ||
                  rememberMe.equalsIgnoreCase("1") ||
                  rememberMe.equalsIgnoreCase("y") || 
-                 rememberMe.equalsIgnoreCase("yes" ) );
+                 rememberMe.equalsIgnoreCase("yes") ||
+                 rememberMe.equalsIgnoreCase("on") );
     }
 
     protected InetAddress getInetAddress( ServletRequest request, ServletResponse response ) {

File: src/org/jsecurity/io/Serializer.java
Patch:
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.jsecurity.util;
+package org.jsecurity.io;
 
 /**
  * @author Les Hazlewood
  * @since 0.9
  */
 public interface Serializer {
 
-    byte[] serialize( Object o );
+    byte[] serialize( Object o ) throws SerializationException;
 
-    Object deserialize( byte[] serialized );
+    Object deserialize( byte[] serialized ) throws SerializationException;
 }

File: src/org/jsecurity/io/XmlSerializer.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.jsecurity.util;
+package org.jsecurity.io;
 
 import java.beans.XMLDecoder;
 import java.beans.XMLEncoder;

File: src/org/jsecurity/mgt/DefaultSecurityManager.java
Patch:
@@ -54,7 +54,7 @@
  * therefore aplication-dependent, if you want <tt>RememberMe</tt> services enabled, you will have to specify an
  * instance yourself before calling {@link #init() init()}.  However if you're reading this JavaDoc with the
  * expectation of operating in a Web environment, take a look at the
- * {@link org.jsecurity.web.WebSecurityManager DefaultWebSecurityManager} implementation, which
+ * {@link org.jsecurity.web.DefaultWebSecurityManager DefaultWebSecurityManager} implementation, which
  * <em>does</em> support <tt>RememberMe</tt> services by default at startup.
  *
  * <p>Finally, the only absolute requirement for a <tt>DefaultSecurityManager</tt> instance to function properly is
@@ -63,7 +63,7 @@
  *
  * @author Les Hazlewood
  * @author Jeremy Haile
- * @see org.jsecurity.web.WebSecurityManager
+ * @see org.jsecurity.web.DefaultWebSecurityManager
  * @since 0.2
  */
 public class DefaultSecurityManager extends SessionsSecurityManager {

File: src/org/jsecurity/web/servlet/JSecurityFilter.java
Patch:
@@ -18,8 +18,8 @@
 import org.jsecurity.mgt.SecurityManager;
 import static org.jsecurity.util.StringUtils.*;
 import org.jsecurity.util.ThreadContext;
+import org.jsecurity.web.DefaultWebSecurityManager;
 import org.jsecurity.web.SecurityWebSupport;
-import org.jsecurity.web.WebSecurityManager;
 import org.jsecurity.web.interceptor.DefaultInterceptorBuilder;
 import org.jsecurity.web.interceptor.InterceptorBuilder;
 import org.jsecurity.web.interceptor.PathConfigWebInterceptor;
@@ -476,8 +476,8 @@ protected void applyUrlMappings() throws ParseException {
 
     protected boolean isHttpSessions() {
         SecurityManager secMgr = getSecurityManager();
-        if ( secMgr instanceof WebSecurityManager) {
-            return ((WebSecurityManager)secMgr).isHttpSessionMode();
+        if ( secMgr instanceof DefaultWebSecurityManager) {
+            return ((DefaultWebSecurityManager)secMgr).isHttpSessionMode();
         } else {
             return super.isHttpSessions();
         }

File: src/org/jsecurity/web/servlet/SecurityManagerLoader.java
Patch:
@@ -18,7 +18,7 @@
 import org.jsecurity.mgt.SecurityManager;
 import org.jsecurity.realm.Realm;
 import org.jsecurity.util.LifecycleUtils;
-import org.jsecurity.web.WebSecurityManager;
+import org.jsecurity.web.DefaultWebSecurityManager;
 
 import java.util.List;
 
@@ -74,7 +74,7 @@ protected void bind(SecurityManager securityManager) {
     }
 
     protected SecurityManager createSecurityManager() {
-        WebSecurityManager defaultSecMgr = new WebSecurityManager();
+        DefaultWebSecurityManager defaultSecMgr = new DefaultWebSecurityManager();
 
         String mode = getSessionMode();
         if ( mode != null ) {

File: src/org/jsecurity/web/servlet/ServletContextSupport.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.jsecurity.web.WebSecurityManager;
+import org.jsecurity.web.DefaultWebSecurityManager;
 
 import javax.servlet.ServletContext;
 
@@ -30,8 +30,8 @@
 public class ServletContextSupport {
 
     public static final String SESSION_MODE_CONTEXT_PARAM_NAME = "sessionMode";
-    public static final String HTTP_SESSION_MODE = WebSecurityManager.HTTP_SESSION_MODE;
-    public static final String JSECURITY_SESSION_MODE = WebSecurityManager.JSECURITY_SESSION_MODE;
+    public static final String HTTP_SESSION_MODE = DefaultWebSecurityManager.HTTP_SESSION_MODE;
+    public static final String JSECURITY_SESSION_MODE = DefaultWebSecurityManager.JSECURITY_SESSION_MODE;
 
     protected transient final Log log = LogFactory.getLog( getClass() );
 

File: support/spring/src/org/jsecurity/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -23,7 +23,7 @@
 import org.jsecurity.subject.PrincipalCollection;
 import org.jsecurity.subject.Subject;
 import org.jsecurity.util.ThreadContext;
-import org.jsecurity.web.WebSecurityManager;
+import org.jsecurity.web.DefaultWebSecurityManager;
 import org.springframework.remoting.support.DefaultRemoteInvocationExecutor;
 import org.springframework.remoting.support.RemoteInvocation;
 
@@ -86,12 +86,12 @@ protected InetAddress getInetAddress( RemoteInvocation invocation, Object target
     }
 
     protected PrincipalCollection getPrincipals( RemoteInvocation invocation, Object targetObject, Session session ) {
-        return (PrincipalCollection)session.getAttribute( WebSecurityManager.PRINCIPALS_SESSION_KEY );
+        return (PrincipalCollection)session.getAttribute( DefaultWebSecurityManager.PRINCIPALS_SESSION_KEY );
     }
 
     protected boolean isAuthenticated( RemoteInvocation invocation, Object targetObject, Session session, PrincipalCollection principals ) {
         if ( principals != null ) {
-            Boolean authc = (Boolean)session.getAttribute(WebSecurityManager.AUTHENTICATED_SESSION_KEY);
+            Boolean authc = (Boolean)session.getAttribute(DefaultWebSecurityManager.AUTHENTICATED_SESSION_KEY);
             return authc != null && authc;
         }
         return false;

File: test/org/jsecurity/web/servlet/JSecurityFilterTest.java
Patch:
@@ -16,7 +16,7 @@
 package org.jsecurity.web.servlet;
 
 import static org.easymock.EasyMock.*;
-import org.jsecurity.web.WebSecurityManager;
+import org.jsecurity.web.DefaultWebSecurityManager;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -42,7 +42,7 @@ public void setUp() throws Exception {
         expect(mockFilterConfig.getServletContext()).andReturn(mockServletContext);
         expect(mockServletContext.getInitParameter(ServletContextSupport.SESSION_MODE_CONTEXT_PARAM_NAME)).andReturn(null).atLeastOnce();
         expect(mockServletContext.getAttribute(SecurityManagerListener.SECURITY_MANAGER_CONTEXT_KEY)).andReturn(null).atLeastOnce();
-        mockServletContext.setAttribute(eq(SecurityManagerListener.SECURITY_MANAGER_CONTEXT_KEY),isA(WebSecurityManager.class));
+        mockServletContext.setAttribute(eq(SecurityManagerListener.SECURITY_MANAGER_CONTEXT_KEY),isA(DefaultWebSecurityManager.class));
     }
 
     @After

File: src/org/jsecurity/web/WebSecurityManager.java
Patch:
@@ -22,6 +22,7 @@
 import org.jsecurity.subject.PrincipalCollection;
 import org.jsecurity.subject.Subject;
 import org.jsecurity.util.ThreadContext;
+import org.jsecurity.web.session.DefaultWebSessionManager;
 import org.jsecurity.web.session.ServletContainerSessionManager;
 import org.jsecurity.web.session.WebSessionManager;
 
@@ -100,7 +101,7 @@ protected SessionManager createSessionManager() {
             if ( log.isInfoEnabled() ) {
                 log.info( JSECURITY_SESSION_MODE + " mode - enabling WebSessionManager (JSecurity heterogenous sessions)");
             }
-            WebSessionManager wsm = new WebSessionManager();
+            DefaultWebSessionManager wsm = new DefaultWebSessionManager();
             wsm.setCacheManager(getCacheManager());
             wsm.setSessionEventListeners(getSessionEventListeners());
             wsm.init();

File: src/org/jsecurity/aop/AnnotationMethodInterceptor.java
Patch:
@@ -45,7 +45,7 @@ public Class<? extends Annotation> getAnnotationClass() {
         return this.annotationClass;
     }
 
-    protected boolean supports(MethodInvocation mi) {
+    public boolean supports(MethodInvocation mi) {
         return getAnnotation( mi ) != null;
     }
 

File: src/org/jsecurity/web/WebSecurityManager.java
Patch:
@@ -83,7 +83,7 @@ public void setSessionMode(String sessionMode) {
         this.sessionMode = sessionMode;
     }
 
-    protected boolean isHttpSessionMode() {
+    public boolean isHttpSessionMode() {
         return this.sessionMode.equals(HTTP_SESSION_MODE);
     }
 

File: src/org/jsecurity/web/servlet/SecurityManagerFilter.java
Patch:
@@ -33,7 +33,7 @@ public SecurityManagerFilter(){}
 
     protected void onFilterConfigSet() throws Exception {
         applySessionMode();
-        org.jsecurity.mgt.SecurityManager securityManager = getSecurityManager();
+        SecurityManager securityManager = getSecurityManager();
         //not using the loader explicitly or not overridden, so lets start one:
         if ( securityManager == null ) {
             securityManagerListener = new SecurityManagerListener();

File: src/org/jsecurity/subject/DelegatingSubject.java
Patch:
@@ -136,7 +136,7 @@ public InetAddress getInetAddress() {
      */
     public Object getPrincipal() {
         PrincipalCollection principals = getPrincipals();
-        if ( principals.isEmpty() ) {
+        if ( principals == null || principals.isEmpty() ) {
             return null;
         }
         return principals.asSet().iterator().next();

File: src/org/jsecurity/web/servlet/JSecurityFilter.java
Patch:
@@ -501,7 +501,8 @@ protected void doFilterInternal(ServletRequest servletRequest, ServletResponse s
 
         ThreadContext.bind(request);
         ThreadContext.bind(response);
-        ThreadContext.bind(getSecurityManager().getSubject());
+        getSecurityManager().getSubject();
+        //ThreadContext.bind(getSecurityManager().getSubject());
 
         try {
             chain.doFilter(request, response);

File: samples/spring/src/org/jsecurity/samples/spring/web/LoginController.java
Patch:
@@ -16,10 +16,8 @@
 package org.jsecurity.samples.spring.web;
 
 import org.jsecurity.authc.AuthenticationException;
-import org.jsecurity.authc.Authenticator;
 import org.jsecurity.authc.UsernamePasswordToken;
 import org.jsecurity.mgt.DefaultSecurityManager;
-import org.jsecurity.subject.Subject;
 import org.springframework.validation.BindException;
 import org.springframework.web.servlet.ModelAndView;
 import org.springframework.web.servlet.mvc.SimpleFormController;
@@ -76,7 +74,7 @@ protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse
         securityManager.init();
 
         try {
-           Subject subject = securityManager.login(token);
+           securityManager.login(token);
         } catch (AuthenticationException e) {
             if (logger.isDebugEnabled()) {
                 logger.debug("Error authenticating.", e);

File: src/org/jsecurity/subject/DelegatingSubject.java
Patch:
@@ -334,7 +334,7 @@ public Session getSession() {
 
     public Session getSession(boolean create) {
         assertValid();
-        if (this.session == null && create) {
+        if ((this.session == null || this.session.getId() == null) && create) {
             this.session = securityManager.start(getInetAddress());
         }
         return this.session;

File: samples/spring/src/org/jsecurity/samples/spring/web/LoginController.java
Patch:
@@ -19,6 +19,7 @@
 import org.jsecurity.authc.Authenticator;
 import org.jsecurity.authc.UsernamePasswordToken;
 import org.jsecurity.mgt.DefaultSecurityManager;
+import org.jsecurity.subject.Subject;
 import org.springframework.validation.BindException;
 import org.springframework.web.servlet.ModelAndView;
 import org.springframework.web.servlet.mvc.SimpleFormController;
@@ -75,7 +76,7 @@ protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse
         securityManager.init();
 
         try {
-            securityManager.login(token);
+           Subject subject = securityManager.login(token);
         } catch (AuthenticationException e) {
             if (logger.isDebugEnabled()) {
                 logger.debug("Error authenticating.", e);

File: src/org/jsecurity/web/attr/AbstractWebAttribute.java
Patch:
@@ -52,7 +52,7 @@ public abstract class AbstractWebAttribute<T> extends SecurityWebSupport impleme
     protected boolean mutable = true;
 
     /**
-     * Property editor class to use to convert IDs to and from strings.
+     * Property editor class to use to convert attributes to and from strings.
      */
     private Class<? extends PropertyEditor> editorClass = null;
 
@@ -164,6 +164,7 @@ protected T fromStringValue( String stringValue ) {
     protected String toStringValue( T value ) {
         Class clazz = getEditorClass();
         if ( clazz == null ) {
+            
             if ( log.isDebugEnabled() ) {
                 log.debug( "No 'editorClass' property set - returning value.toString() as the string value for " +
                     "method argument." );

File: src/org/jsecurity/web/servlet/WebInterceptorFilter.java
Patch:
@@ -26,6 +26,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.jsecurity.util.LifecycleUtils;
 import org.jsecurity.web.interceptor.WebInterceptor;
 
 import javax.servlet.*;
@@ -115,6 +116,6 @@ public void init(FilterConfig filterConfig) throws ServletException {
     }
 
     public void destroy() {
-        //To change body of implemented methods use File | Settings | File Templates.
+        LifecycleUtils.destroy(getWebInterceptor());
     }
 }

File: src/org/jsecurity/realm/jdbc/JdbcRealm.java
Patch:
@@ -176,7 +176,7 @@ public void setPermissionsLookupEnabled( boolean permissionsLookupEnabled ) {
     |               M E T H O D S               |
     ============================================*/
 
-    public void onInit() {
+    public void afterAccountCacheSet() {
         setAuthenticationTokenClass( UsernamePasswordToken.class );
     }
 

File: src/org/jsecurity/realm/ldap/AbstractLdapRealm.java
Patch:
@@ -163,7 +163,7 @@ public void setLdapContextFactory(LdapContextFactory ldapContextFactory) {
     |               M E T H O D S                |
     ============================================*/
 
-    protected void onInit() {
+    protected void afterAccountCacheSet() {
         if( ldapContextFactory == null ) {
 
             if( log.isDebugEnabled() ) {

File: src/org/jsecurity/DefaultSecurityManager.java
Patch:
@@ -182,8 +182,8 @@ protected Subject createSubject(AuthenticationToken token, Account account) {
      *               for later use.
      */
     protected void bind(Subject subject) {
-        if (log.isDebugEnabled()) {
-            log.debug("Binding Subject [" + subject + "] to a thread local...");
+        if (log.isTraceEnabled()) {
+            log.trace("Binding Subject [" + subject + "] to a thread local...");
         }
         ThreadContext.bind(subject);
     }

File: src/org/jsecurity/authc/credential/HashedCredentialsMatcher.java
Patch:
@@ -240,7 +240,7 @@ protected Object getCredentials(Account account) {
             if (isStoredCredentialsHexEncoded()) {
                 storedBytes = Hex.decode( storedBytes );
             } else {
-                storedBytes = Base64.decodeBase64( storedBytes );
+                storedBytes = Base64.decode( storedBytes );
             }
         }
         AbstractHash hash = newHashInstance();

File: src/org/jsecurity/authc/credential/SimpleCredentialsMatcher.java
Patch:
@@ -79,7 +79,7 @@ protected Object getCredentials( Account account ) {
     }
 
     /**
-     * Converts the <tt>AuthenticationToken</tt> to a <tt>byte[]</tt>
+     * Converts the <tt>AuthenticationToken</tt> credentials to a <tt>byte[]</tt>
      *
      * @param token
      * @return a <tt>byte[]</tt> representation of the <tt>token</tt>
@@ -112,7 +112,6 @@ protected byte[] getCredentialsBytes( Account account ) {
      * @return <tt>true</tt> if the <tt>tokenCredentials</tt> are equal to the <tt>accountCredentials</tt>.
      */
     protected boolean equals( byte[] tokenCredentials, byte[] accountCredentials ) {
-
         return Arrays.equals( tokenCredentials, accountCredentials );
     }
 

File: src/org/jsecurity/crypto/hash/AbstractHash.java
Patch:
@@ -241,7 +241,7 @@ public String toHex() {
     public String toBase64() {
         if (this.base64Encoded == null) {
             //cache result in case this method is called multiple times.
-            this.base64Encoded = Base64.encodeBase64ToString(getBytes());
+            this.base64Encoded = Base64.encodeToString(getBytes());
         }
         return this.base64Encoded;
     }

File: src/org/jsecurity/crypto/hash/Md2Hash.java
Patch:
@@ -68,7 +68,7 @@ public static Md2Hash fromHexString(String hex) {
 
     public static Md2Hash fromBase64String(String base64) {
         Md2Hash hash = new Md2Hash();
-        hash.setBytes(Base64.decodeBase64(base64));
+        hash.setBytes(Base64.decode(base64));
         return hash;
     }
 }

File: src/org/jsecurity/crypto/hash/Md5Hash.java
Patch:
@@ -68,7 +68,7 @@ public static Md5Hash fromHexString(String hex) {
 
     public static Md5Hash fromBase64String(String base64) {
         Md5Hash hash = new Md5Hash();
-        hash.setBytes(Base64.decodeBase64(base64));
+        hash.setBytes(Base64.decode(base64));
         return hash;
     }
 }

File: src/org/jsecurity/crypto/hash/Sha1Hash.java
Patch:
@@ -68,7 +68,7 @@ public static Sha1Hash fromHexString( String hex ) {
 
     public static Sha1Hash fromBase64String( String base64 ) {
         Sha1Hash hash = new Sha1Hash();
-        hash.setBytes( Base64.decodeBase64( base64 ) );
+        hash.setBytes( Base64.decode( base64 ) );
         return hash;
     }
 }

File: src/org/jsecurity/crypto/hash/Sha256Hash.java
Patch:
@@ -70,7 +70,7 @@ public static Sha256Hash fromHexString(String hex) {
 
     public static Sha256Hash fromBase64String(String base64) {
         Sha256Hash hash = new Sha256Hash();
-        hash.setBytes(Base64.decodeBase64(base64));
+        hash.setBytes(Base64.decode(base64));
         return hash;
     }
 

File: src/org/jsecurity/crypto/hash/Sha384Hash.java
Patch:
@@ -70,7 +70,7 @@ public static Sha384Hash fromHexString(String hex) {
 
     public static Sha384Hash fromBase64String(String base64) {
         Sha384Hash hash = new Sha384Hash();
-        hash.setBytes(Base64.decodeBase64(base64));
+        hash.setBytes(Base64.decode(base64));
         return hash;
     }
 

File: src/org/jsecurity/crypto/hash/Sha512Hash.java
Patch:
@@ -70,7 +70,7 @@ public static Sha512Hash fromHexString(String hex) {
 
     public static Sha512Hash fromBase64String(String base64) {
         Sha512Hash hash = new Sha512Hash();
-        hash.setBytes(Base64.decodeBase64(base64));
+        hash.setBytes(Base64.decode(base64));
         return hash;
     }
 

File: src/org/jsecurity/realm/PropertiesRealm.java
Patch:
@@ -135,7 +135,7 @@ public void onInit() {
             this.filePath = FAILSAFE_FILE_PATH;
             reloadProperties();
         }
-        startReloadThread();
+        //startReloadThread();
     }
 
     public void destroy() {

File: src/org/jsecurity/web/WebRememberMeManager.java
Patch:
@@ -82,7 +82,7 @@ protected void rememberSerializedIdentity(byte[] serialized) {
         ServletRequest request = ThreadContext.getServletRequest();
         ServletResponse response = ThreadContext.getServletResponse();
         //base 64 encode it and store as a cookie:
-        String base64 = Base64.encodeBase64ToString(serialized);
+        String base64 = Base64.encodeToString(serialized);
         getIdentityAttribute().storeValue(base64, request, response);
     }
 
@@ -91,7 +91,7 @@ protected byte[] getSerializedRememberedIdentity() {
         ServletResponse response = ThreadContext.getServletResponse();
         String base64 = getIdentityAttribute().retrieveValue(request, response);
         if ( base64 != null ) {
-            return Base64.decodeBase64( base64 );
+            return Base64.decode( base64 );
         } else {
             //no cookie set - new site visitor?
             return null;

File: src/org/jsecurity/web/WebSecurityManager.java
Patch:
@@ -133,7 +133,7 @@ public Subject createSubject(ServletRequest request, ServletResponse response) {
             if ( log.isTraceEnabled() ) {
                 log.trace( "No Session exists for the incoming request and is therefore not available to use to " +
                         "construct a Subject instance.  This is perfectly ok and a new Subject instance will be " +
-                        "created.  This can be ignored - logging for traceability only.", ignored );
+                        "created.  This exception can be ignored - logging for traceability only.", ignored );
             }
         }
         return createSubject(session, request, response);

File: src/org/jsecurity/web/authz/AuthenticationWebInterceptor.java
Patch:
@@ -58,7 +58,6 @@ public boolean preHandle(ServletRequest request, ServletResponse response) throw
      */
     private boolean isSubjectAuthenticated(ServletRequest request, ServletResponse response) {
         Subject subject = getSubject(request, response);
-
         return subject.isAuthenticated();
     }
 
@@ -68,8 +67,8 @@ private boolean isSubjectAuthenticated(ServletRequest request, ServletResponse r
      *
      * @param request
      * @param response
-     * @return true if the request should continue to be processed; false if the request should not continue to be
-     * processed.
+     * @return true if the request should continue to be processed; false if the subclass will handle/render 
+     * the response directly.
      */
     protected abstract boolean onUnAuthenticatedRequest(ServletRequest request, ServletResponse response);
 }

File: src/org/jsecurity/DefaultSecurityManager.java
Patch:
@@ -142,11 +142,11 @@ protected Subject createSubject(Object principals, Session existing,
     }
 
     /**
-     * Creates a <tt>Subject</tt> instance for the user represented by the given method argument.
+     * Creates a <tt>Subject</tt> instance for the user represented by the given method arguments.
      *
-     * @param token   the submitted <tt>AuthenticationToken</tt> submitted for the successful authentication.
+     * @param token   the <tt>AuthenticationToken</tt> submitted for the successful authentication.
      * @param account the <tt>Account</tt> of a newly authenticated user.
-     * @return the <tt>Subject</tt> instance that represents the identity and session data for the newly
+     * @return the <tt>Subject</tt> instance that represents the account and session data for the newly
      *         authenticated user.
      */
     protected Subject createSubject(AuthenticationToken token, Account account) {

File: samples/spring/src/org/jsecurity/samples/spring/BootstrapDataPopulator.java
Patch:
@@ -10,8 +10,8 @@
 
 /**
  * A data populator that creates a set of security tables and test data that can be used by the
- * JSecurity Spring sample application to demonstrate the use of the {@link org.jsecurity.realm.support.jdbc.JdbcRealm}
- * The tables created by this class follow the default table and column names that {@link org.jsecurity.realm.support.jdbc.JdbcRealm} uses.
+ * JSecurity Spring sample application to demonstrate the use of the {@link org.jsecurity.realm.jdbc.JdbcRealm}
+ * The tables created by this class follow the default table and column names that {@link org.jsecurity.realm.jdbc.JdbcRealm} uses.
  *  
  *
  * @author Les Hazlewood

File: src/org/jsecurity/DefaultSecurityManager.java
Patch:
@@ -30,7 +30,7 @@
 import org.jsecurity.context.RememberMeManager;
 import org.jsecurity.context.SecurityContext;
 import org.jsecurity.realm.Realm;
-import org.jsecurity.realm.support.file.PropertiesRealm;
+import org.jsecurity.realm.file.PropertiesRealm;
 import org.jsecurity.session.Session;
 import org.jsecurity.session.SessionFactory;
 import org.jsecurity.util.ThreadContext;

File: src/org/jsecurity/RealmSecurityManager.java
Patch:
@@ -25,7 +25,7 @@
 package org.jsecurity;
 
 import org.jsecurity.realm.Realm;
-import org.jsecurity.realm.support.file.PropertiesRealm;
+import org.jsecurity.realm.file.PropertiesRealm;
 import org.jsecurity.util.LifecycleUtils;
 
 import java.util.ArrayList;

File: src/org/jsecurity/realm/AuthenticatingRealm.java
Patch:
@@ -1,4 +1,4 @@
-package org.jsecurity.realm.support;
+package org.jsecurity.realm;
 
 import org.jsecurity.authc.*;
 import org.jsecurity.authc.credential.CredentialsMatcher;

File: src/org/jsecurity/realm/file/PropertiesRealm.java
Patch:
@@ -22,10 +22,10 @@
  * Or, you may view it online at
  * http://www.opensource.org/licenses/lgpl-license.php
  */
-package org.jsecurity.realm.support.file;
+package org.jsecurity.realm.file;
 
 import org.jsecurity.JSecurityException;
-import org.jsecurity.realm.support.memory.MemoryRealm;
+import org.jsecurity.realm.memory.MemoryRealm;
 import org.jsecurity.util.ResourceUtils;
 
 import java.io.File;

File: src/org/jsecurity/realm/ldap/DefaultLdapContextFactory.java
Patch:
@@ -22,7 +22,7 @@
  * Or, you may view it online at
  * http://www.opensource.org/licenses/lgpl-license.php
  */
-package org.jsecurity.realm.support.ldap;
+package org.jsecurity.realm.ldap;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;

File: src/org/jsecurity/realm/ldap/LdapContextFactory.java
Patch:
@@ -22,7 +22,7 @@
  * Or, you may view it online at
  * http://www.opensource.org/licenses/lgpl-license.php
  */
-package org.jsecurity.realm.support.ldap;
+package org.jsecurity.realm.ldap;
 
 import javax.naming.NamingException;
 import javax.naming.ldap.LdapContext;

File: src/org/jsecurity/realm/ldap/LdapUtils.java
Patch:
@@ -22,7 +22,7 @@
  * Or, you may view it online at
  * http://www.opensource.org/licenses/lgpl-license.php
  */
-package org.jsecurity.realm.support.ldap;
+package org.jsecurity.realm.ldap;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;

File: src/org/jsecurity/realm/memory/SimpleUser.java
Patch:
@@ -22,7 +22,7 @@
 * Or, you may view it online at
 * http://www.opensource.org/licenses/lgpl-license.php
 */
-package org.jsecurity.realm.support.memory;
+package org.jsecurity.realm.memory;
 
 import org.jsecurity.authz.Permission;
 

File: src/org/jsecurity/web/servlet/JSecurityHttpSession.java
Patch:
@@ -16,6 +16,7 @@
  * @since 0.2
  * @author Les Hazlewood
  */
+@SuppressWarnings("deprecated")
 public class JSecurityHttpSession implements HttpSession {
 
     public static final String DEFAULT_SESSION_ID_NAME = "JSESSIONID";

File: src/org/jsecurity/web/support/RedirectView.java
Patch:
@@ -245,7 +245,8 @@ protected void appendQueryProperties(StringBuffer targetUrl, Map model, String e
 	 * @see java.net.URLEncoder#encode(String, String)
 	 * @see java.net.URLEncoder#encode(String)
 	 */
-	protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {
+    @SuppressWarnings("deprecated")
+    protected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {
         if ( !JavaEnvironment.isAtLeastVersion14() ) {
 			if (log.isDebugEnabled()) {
 				log.debug("Only JDK 1.3 URLEncoder available: using platform default encoding " +

File: src/org/jsecurity/web/tags/HasPermissionTag.java
Patch:
@@ -24,8 +24,6 @@
  */
 package org.jsecurity.web.tags;
 
-import org.jsecurity.authz.Permission;
-
 /**
  * @since 0.1
  * @author Les Hazlewood
@@ -36,7 +34,7 @@ public class HasPermissionTag extends PermissionTag {
     public HasPermissionTag() {
     }
 
-    protected boolean showTagBody( Permission p ) {
+    protected boolean showTagBody( String p ) {
         return isPermitted( p );
     }
 

File: src/org/jsecurity/web/tags/LacksPermissionTag.java
Patch:
@@ -24,8 +24,6 @@
  */
 package org.jsecurity.web.tags;
 
-import org.jsecurity.authz.Permission;
-
 /**
  * @since 0.1
  * @author Les Hazlewood
@@ -36,7 +34,7 @@ public class LacksPermissionTag extends PermissionTag {
     public LacksPermissionTag() {
     }
 
-    protected boolean showTagBody( Permission p ) {
+    protected boolean showTagBody( String p ) {
         return !isPermitted( p );
     }
 

File: test/org/jsecurity/AuthorizingRealmTest.java
Patch:
@@ -8,10 +8,10 @@
 import org.jsecurity.authc.support.SimpleAccount;
 import org.jsecurity.authz.AuthorizationInfo;
 import org.jsecurity.authz.Permission;
-import org.jsecurity.authz.support.SimpleAuthorizationInfo;
+import org.jsecurity.authz.SimpleAuthorizationInfo;
 import org.jsecurity.context.SecurityContext;
+import org.jsecurity.realm.AuthorizingRealm;
 import org.jsecurity.realm.Realm;
-import org.jsecurity.realm.support.AuthorizingRealm;
 import org.junit.After;
 import static org.junit.Assert.*;
 import org.junit.Before;

File: src/org/jsecurity/authc/support/AtLeastOneSuccessfulModularAuthenticationStrategy.java
Patch:
@@ -70,8 +70,8 @@ public void afterAllAttempts( AuthenticationToken token, AuthenticationInfo aggr
 
         if ( !oneOrMoreSuccessful ) {
             throw new AuthenticationException( "Authentication token of type [" + token.getClass() + "] " +
-                "could not be authenticated by any configured realms.  Check that the authenticator is configured " +
-                "with appropriate realm(s)." );
+                "could not be authenticated by any configured realms.  Please ensure that at least one realm can " +
+                "authenticate these tokens." );
         }
     }
 }

File: src/org/jsecurity/realm/support/AuthenticatingRealm.java
Patch:
@@ -44,8 +44,6 @@ public abstract class AuthenticatingRealm extends AbstractRealm {
 
     /*--------------------------------------------
     |         C O N S T R U C T O R S           |
-    ============================================*//*--------------------------------------------
-    |         C O N S T R U C T O R S           |
     ============================================*/
     public AuthenticatingRealm() {
         super();

File: src/org/jsecurity/web/support/DefaultWebSecurityContextFactory.java
Patch:
@@ -81,8 +81,8 @@ protected void assertWebSessionFactory() {
                     "acquire the SessionFactory from the SecurityManager.";
                 throw new IllegalStateException( msg );
             }
-
-            throw new IllegalStateException( "WebSessionFactory property m ust be set." );
+        } else {
+            throw new IllegalStateException( "WebSessionFactory property must be set." );
         }
     }
 

File: src/org/jsecurity/session/support/DefaultSessionFactory.java
Patch:
@@ -80,8 +80,8 @@ private void assertSessionManagerEventListenerRegistry() {
     }
 
     public void setSessionManager( SessionManager sessionManager ) {
-        assertSessionManagerEventListenerRegistry();
         this.sessionManager = sessionManager;
+        assertSessionManagerEventListenerRegistry();
     }
 
     public void add( SessionEventListener listener ) {

File: src/org/jsecurity/web/servlet/SecurityContextFilter.java
Patch:
@@ -121,7 +121,7 @@ protected SecurityManager getSecurityManager() {
                 getClass().getName() + ".getSecurityManager() method to retrieve it from a custom location.";
             throw new IllegalStateException( msg );
         }
-        return null;
+        return securityManager;
     }
 
     protected WebInterceptor createWebInterceptor() throws Exception {

File: src/org/jsecurity/web/servlet/OncePerRequestFilter.java
Patch:
@@ -79,6 +79,9 @@ public final void init( FilterConfig filterConfig ) throws ServletException {
             if ( e instanceof ServletException ) {
                 throw (ServletException)e;
             } else {
+                if ( log.isErrorEnabled() ) {
+                    log.error( "Unable to start Filter: [" + e.getMessage() + "].", e );
+                }
                 throw new ServletException( e );
             }
         }

File: src/org/jsecurity/web/support/SecurityContextWebInterceptor.java
Patch:
@@ -55,7 +55,7 @@ public boolean preHandle( ServletRequest request, ServletResponse response ) thr
         if ( sc != null ) {
             ThreadContext.bind( sc );
         }
-        return false;  //To change body of implemented methods use File | Settings | File Templates.
+        return true;
     }
 
     protected void bindForSubsequentRequests( ServletRequest request, ServletResponse response, SecurityContext securityContext ) {

File: src/org/jsecurity/web/support/DefaultWebSessionFactory.java
Patch:
@@ -363,9 +363,9 @@ protected Session start( ServletRequest request, ServletResponse response, InetA
      * Starts a brand new Session, associates it with the specified request, and makes that session available for
      * future requests via a Cookie or URL rewriting as specified by the Servlet Specification.
      *
-     * @param request
-     * @param response
-     * @return
+     * @param request incoming ServletRequest
+     * @param response outgoing ServletResponse
+     * @return a new Session for the specified request/response pair.
      */
     public Session start( ServletRequest request, ServletResponse response ) {
         InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );

File: test/org/jsecurity/AuthorizingRealmTest.java
Patch:
@@ -5,6 +5,7 @@
 import org.jsecurity.authc.AuthenticationToken;
 import org.jsecurity.authc.UsernamePasswordToken;
 import org.jsecurity.authc.credential.CredentialMatcher;
+import org.jsecurity.authc.support.SimpleAuthenticationInfo;
 import org.jsecurity.authz.AuthorizationInfo;
 import org.jsecurity.authz.Permission;
 import org.jsecurity.authz.support.SimpleAuthorizationInfo;
@@ -105,7 +106,7 @@ protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authent
             principals.add(new UsernamePrincipal(USERNAME));
             principals.add(USER_ID + USERNAME);
 
-            return createAuthenticationInfo(principals, null);
+            return new SimpleAuthenticationInfo(principals, null);
         }
 
         protected AuthorizationInfo doGetAuthorizationInfo(Object principal) {

File: src/org/jsecurity/context/support/DelegatingSecurityContext.java
Patch:
@@ -80,7 +80,7 @@ private static <T> List<T> toList(T principal) {
         if (principal != null) {
 
             if (principal instanceof Collection) {
-                throw new IllegalArgumentException("principal my not be a collection.  principal is instance of [" + principal.getClass().getName() + "]");
+                throw new IllegalArgumentException("Principal is an instance of [" + principal.getClass().getName() + "]. Principal must not be an instance of java.util.Collection.");
             }
 
             principals = new ArrayList<T>();

File: src/org/jsecurity/realm/support/file/PropertiesFileRealm.java
Patch:
@@ -252,10 +252,10 @@ private void createRealmEntitiesFromProperties( Properties properties ) {
         }
 
         if ( !userProps.isEmpty() ) {
-            setUserProperties( userProps );
+            //setUserPropertie( userProps );
         }
         if ( !roleProps.isEmpty() ) {
-            setRoleProperties( roleProps );
+            //setRoleProperties( roleProps );
         }
     }
 

File: src/org/jsecurity/realm/support/memory/MemoryRealm.java
Patch:
@@ -359,7 +359,7 @@ protected void destroy( Cache cache ) {
                 cache.clear();
             } catch ( Throwable t ) {
                 if ( log.isInfoEnabled() ) {
-                    log.info( "Unable to cleanly clear cache [" + cache + "].  Ingoring (shutting down)." );
+                    log.info( "Unable to cleanly clear cache [" + cache + "].  Ignoring (shutting down)." );
                 }
             }
             try {

File: src/org/jsecurity/cache/ehcache/EhCacheProvider.java
Patch:
@@ -124,7 +124,7 @@ public final Cache buildCache( String name ) throws CacheException {
                     log.debug( "Started EHCache named [" + name + "]" );
                 }
             }
-            return new EhCache( cache );
+            return new EhCache( cache, getCacheManager() );
         } catch ( net.sf.ehcache.CacheException e ) {
             throw new CacheException( e );
         }

File: src/org/jsecurity/web/servlet/SecurityContextFilter.java
Patch:
@@ -41,7 +41,7 @@
  */
 public abstract class SecurityContextFilter extends WebInterceptorFilter {
 
-    public static final String SESSION_REQUIRED_ON_REQUEST_PARAM_NAME = "sessionRequiredOnRequest"; //default is false
+    public static final String REQUIRE_SESSION_ON_REQUEST_PARAM_NAME = "requireSessionOnRequest"; //default is false
     public static final String PREFER_HTTP_SESSION_PARAM_NAME = "preferHttpSessionStorage"; //default is false
 
     protected boolean getBoolean( String paramName, boolean defaultValue ) {
@@ -72,7 +72,7 @@ protected boolean getBoolean( String paramName, boolean defaultValue ) {
     }
 
     protected boolean isSessionRequiredOnRequest() {
-        return getBoolean( SESSION_REQUIRED_ON_REQUEST_PARAM_NAME, false );
+        return getBoolean( REQUIRE_SESSION_ON_REQUEST_PARAM_NAME, false );
     }
 
     protected boolean isPreferHttpSessionStorage() {

File: src/org/jsecurity/session/support/quartz/QuartzSessionValidationScheduler.java
Patch:
@@ -202,8 +202,8 @@ public void stopSessionValidation() {
                 log.debug( "Quartz session validation job stopped successfully." );
             }
         } catch ( SchedulerException e ) {
-            if ( log.isInfoEnabled() ) {
-                log.info( "Could not cleanly remove SessionValidationJob from Quartz scheduler.  " +
+            if ( log.isDebugEnabled() ) {
+                log.debug( "Could not cleanly remove SessionValidationJob from Quartz scheduler.  " +
                     "Ignoring and stopping.", e );
             }
         }

File: src/org/jsecurity/web/support/AbstractWebStore.java
Patch:
@@ -169,7 +169,9 @@ public final T retrieveValue( HttpServletRequest request, HttpServletResponse re
         T value = null;
         if ( isCheckRequestParams() ) {
             value = getFromRequestParam( request );
-        } else {
+        }
+        
+        if ( value == null ) {
             value = onRetrieveValue( request, response );
         }
         return value;

File: support/spring/src/org/jsecurity/spring/servlet/security/AuthenticationInterceptor.java
Patch:
@@ -27,6 +27,7 @@
 import org.jsecurity.web.support.AuthenticationWebInterceptor;
 import org.jsecurity.web.support.RedirectView;
 import org.springframework.beans.factory.InitializingBean;
+import org.springframework.web.servlet.HandlerInterceptor;
 import org.springframework.web.servlet.ModelAndView;
 
 import javax.servlet.http.HttpServletRequest;
@@ -59,7 +60,7 @@
  * @author Jeremy Haile
  */
 public class AuthenticationInterceptor extends AuthenticationWebInterceptor
-    implements InitializingBean {
+    implements HandlerInterceptor, InitializingBean {
                                                     
     public void afterPropertiesSet() throws Exception {
         init();

File: support/spring/src/org/jsecurity/spring/servlet/security/SecurityContextInterceptor.java
Patch:
@@ -54,6 +54,7 @@ public boolean preHandle( HttpServletRequest request, HttpServletResponse respon
 
     public void postHandle( HttpServletRequest request, HttpServletResponse response,
                             Object handler, ModelAndView modelAndView ) throws Exception {
+        //todo What does the comment on the next line mean? -JCH
         //3rd null argument forces parent impl to get from thread (what we want):
         postHandle( request, response );
     }

File: src/org/jsecurity/authz/module/support/PermissionAnnotationAuthorizationModule.java
Patch:
@@ -90,11 +90,11 @@ protected Permission createPermission( AuthorizedAction action ) {
         Class<? extends Permission> clazz = prAnnotation.type();
         String target = prAnnotation.target();
         String targetPath = prAnnotation.targetPath();
-        if ( targetPath.equals( "" ) ) {
+        if (targetPath.length() == 0) {
             targetPath = null;
         }
         String actions = prAnnotation.actions();
-        if ( actions.equals( "" ) ) {
+        if (actions.length() == 0) {
             actions = null;
         }
 

File: src/org/jsecurity/session/support/DefaultSessionManager.java
Patch:
@@ -95,7 +95,7 @@ private boolean isEhcacheAvailable() {
      * @return a lazily created SessionDAO instance.
      */
     protected SessionDAO createSessionDAO() {
-        SessionDAO dao = null;
+        SessionDAO dao;
 
         if ( log.isDebugEnabled() ) {
             log.debug( "No sessionDAO set.  Attempting to create default instance." );

File: src/org/jsecurity/session/support/quartz/QuartzSessionValidationScheduler.java
Patch:
@@ -178,7 +178,7 @@ public void stopSessionValidation() {
             log.debug( "Stopping Quartz session validation job..." );
         }
 
-        Scheduler scheduler = null;
+        Scheduler scheduler;
         try {
             scheduler = getScheduler();
             if ( scheduler == null ) {

File: src/org/jsecurity/web/support/SecurityContextWebInterceptor.java
Patch:
@@ -223,7 +223,7 @@ protected boolean bindInJSecuritySessionForSubsequentRequests( HttpServletReques
                                                                    SecurityContext securityContext ) {
         boolean saved = false;
 
-        Session session = null;
+        Session session;
 
         try {
             session = securityContext.getSession();

File: src/org/jsecurity/web/tags/PermissionTag.java
Patch:
@@ -88,7 +88,7 @@ protected void verifyAttributes() throws JspException {
             setTarget( AbstractPermission.WILDCARD );
         }
 
-        if ( (actions != null ) && actions.trim().equals( "" ) ) {
+        if ( (actions != null ) && actions.trim().length() == 0) {
             String msg = "Empty actions attribute - please remove the attribute or enter " +
                          "one or more meaningful actions.";
             throw new JspException( msg );
@@ -97,7 +97,7 @@ protected void verifyAttributes() throws JspException {
 
     public int onDoStartTag() throws JspException {
 
-        Permission p = null;
+        Permission p;
 
         String actions = getActions();
 

File: src/org/jsecurity/web/support/AttemptedPageStorageScheme.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Represents the method used to store the page that the user was attempting
  * to load, when redirecting to the login page by the
- * {@link org.jsecurity.web.support.AuthenticationWebSupport} (e.g. storing the attempted page in the
+ * {@link org.jsecurity.web.support.AuthenticationWebInterceptor} (e.g. storing the attempted page in the
  * session)
  *
  * @since 0.2

File: src/org/jsecurity/web/support/DefaultWebSessionFactory.java
Patch:
@@ -233,7 +233,7 @@ public void setIdStorageLocation( IdStorageLocation location ) {
     }
 
     public Session start( HttpServletRequest request, HttpServletResponse response ) {
-        InetAddress clientAddress = SecurityWebSupport.getInetAddress( request );
+        InetAddress clientAddress = SecurityWebInterceptor.getInetAddress( request );
         Session session = sessionFactory.start( clientAddress );
         Serializable sessionId = session.getSessionId();
 
@@ -271,7 +271,7 @@ public Session getSession( HttpServletRequest request, HttpServletResponse respo
 
     protected void validateSessionOrigin( HttpServletRequest request, Session session )
         throws HostUnauthorizedException {
-        InetAddress requestIp = SecurityWebSupport.getInetAddress( request );
+        InetAddress requestIp = SecurityWebInterceptor.getInetAddress( request );
         InetAddress originIp = session.getHostAddress();
         Serializable sessionId = session.getSessionId();
 

File: support/spring/src/org/jsecurity/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -31,7 +31,7 @@
 import org.jsecurity.context.support.DelegatingSecurityContext;
 import org.jsecurity.session.Session;
 import org.jsecurity.util.ThreadContext;
-import org.jsecurity.web.support.SecurityContextWebSupport;
+import org.jsecurity.web.support.SecurityContextWebInterceptor;
 import org.springframework.remoting.support.DefaultRemoteInvocationExecutor;
 import org.springframework.remoting.support.RemoteInvocation;
 
@@ -97,7 +97,7 @@ public Object invoke(RemoteInvocation invocation, Object targetObject) throws No
                 ThreadContext.bind( session );
 
                 // Get the principals and realm name from the session
-                List<Principal>principals = (List<Principal>) session.getAttribute( SecurityContextWebSupport.PRINCIPALS_SESSION_KEY );
+                List<Principal>principals = (List<Principal>) session.getAttribute( SecurityContextWebInterceptor.PRINCIPALS_SESSION_KEY );
 
                 // If principals and realm were found in the session, create a delegating authorization context
                 // and bind it to the thread.

File: src/org/jsecurity/web/support/AttemptedPageStorageScheme.java
Patch:
@@ -22,12 +22,12 @@
 * Or, you may view it online at
 * http://www.opensource.org/licenses/lgpl-license.php
 */
-package org.jsecurity.spring.servlet.security;
+package org.jsecurity.web.support;
 
 /**
  * Represents the method used to store the page that the user was attempting
  * to load, when redirecting to the login page by the
- * {@link AuthenticationInterceptor} (e.g. storing the attempted page in the
+ * {@link org.jsecurity.web.support.AuthenticationWebSupport} (e.g. storing the attempted page in the
  * session)
  *
  * @since 0.2

File: support/spring/src/org/jsecurity/spring/servlet/security/AuthenticationInterceptor.java
Patch:
@@ -30,6 +30,7 @@
 import org.jsecurity.context.support.ThreadLocalSecurityContext;
 import org.jsecurity.session.InvalidSessionException;
 import org.jsecurity.session.Session;
+import org.jsecurity.web.support.AttemptedPageStorageScheme;
 import org.springframework.beans.factory.InitializingBean;
 import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
 import org.springframework.web.servlet.view.RedirectView;
@@ -45,7 +46,7 @@
  * page to be viewd.
  *
  * <p>If the user is not authenticated, they will be redirected to the login page located
- * at the URL {@link #getLoginURL() getLoginURL()}.  Just prior to being redirected, the
+ * at the URL {@link #getLoginURL() getRedirectUrl()}.  Just prior to being redirected, the
  * page URL they attempted to view is first saved in a
  * {@link #setAttemptedPageStorageScheme configurable location} for lookup later.
  *

File: src/org/jsecurity/context/SecurityContext.java
Patch:
@@ -192,9 +192,7 @@ public interface SecurityContext {
 
     /**
      * Returns the application <tt>Session</tt> associated with this SecurityContext.  If no session exists when this
-     * method is called, a new session will be created and associated with this context and then returned.
-     *
-     * <p>This is a convenience method and is equivalent to calling {@link #getSession(boolean) getSession(true)}.
+     * method is called, a new session will be created, associated with this context, and then returned.
      * 
      * @see #getSession(boolean)
      *

File: src/org/jsecurity/realm/Realm.java
Patch:
@@ -78,7 +78,6 @@ public interface Realm extends AuthorizationOperations {
      */
     String getName();
 
-
     /**
      * Returns true if this realm can authenticate subjects with
      * {@link org.jsecurity.authc.AuthenticationToken AuthenticationToken} instances of the specified Class,

File: src/org/jsecurity/session/support/eis/SessionDAO.java
Patch:
@@ -111,5 +111,5 @@ public interface SessionDAO {
      * reporting.
      * @return the total number of active sessions (those that haven't been stopped or expired).
      */
-    int getActiveSessionCount();
+    long getActiveSessionCount();
 }

File: src/org/jsecurity/session/support/eis/support/MemorySessionDAO.java
Patch:
@@ -41,6 +41,8 @@
  * <p>If you need session recovery in the event of a server failure or restart, consider using
  * a file-based or RDBMS-based implementation.
  *
+ * @see org.jsecurity.session.support.eis.ehcache.EhcacheSessionDAO EhcacheSessionDAO
+ *
  * @since 0.1
  * @author Les Hazlewood
  */
@@ -51,7 +53,6 @@ public MemorySessionDAO() {
         setMaintainStoppedSessions( true );
     }
 
-
     protected Serializable doCreate(Session session) {
         //no need to do anything with the session - parent class persists to in-memory cache already.  Just return id:
         return session.getSessionId();

File: src/org/jsecurity/util/Destroyable.java
Patch:
@@ -36,7 +36,7 @@
 public interface Destroyable {
 
     /**
-     * Called when this object is being destroyed.
+     * Called when this object is being destroyed, allowing any necessary cleanup of internal resources.
      * @throws Exception if an exception occurs during object destruction.
      */
     void destroy() throws Exception;

File: src/org/jsecurity/web/tags/SecureTag.java
Patch:
@@ -40,10 +40,12 @@ public abstract class SecureTag extends TagSupport {
 
     protected transient final Log log = LogFactory.getLog( getClass() );
 
+    private SecurityContext securityContext = new ThreadLocalSecurityContext();
+
     public SecureTag(){}
 
     protected SecurityContext getSecurityContext() {
-        return ThreadLocalSecurityContext.current();
+        return this.securityContext;
     }
 
     protected void verifyAttributes() throws JspException {

File: src/org/jsecurity/context/support/DelegatingSecurityContext.java
Patch:
@@ -178,7 +178,7 @@ public boolean isAuthenticated() {
     }
 
     public Session getSession() {
-        return getSession( false );
+        return getSession( true );
     }
 
     public Session getSession( boolean create ) {

File: src/org/jsecurity/context/support/DelegatingSecurityContext.java
Patch:
@@ -178,7 +178,7 @@ public boolean isAuthenticated() {
     }
 
     public Session getSession() {
-        return getSession( true );
+        return getSession( false );
     }
 
     public Session getSession( boolean create ) {

File: support/spring/src/org/jsecurity/spring/remoting/SecureRemoteInvocationFactory.java
Patch:
@@ -8,7 +8,6 @@
 import org.springframework.remoting.support.RemoteInvocationFactory;
 
 import java.io.Serializable;
-import java.util.UUID;
 
 /**
  * A {@link RemoteInvocationFactory} that passes the session ID to the server via a
@@ -36,7 +35,7 @@ public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation
         if( session != null ) {
             sessionId = session.getSessionId();
         } else {
-            sessionId = UUID.fromString( System.getProperty( "jsecurity.session.id" ) );
+            sessionId = System.getProperty( "jsecurity.session.id" );
         }
 
         if( sessionId != null ) {

File: src/org/jsecurity/authc/support/AbstractAuthenticator.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.jsecurity.SecurityManager;
+import org.jsecurity.util.Initializable;
 import org.jsecurity.authc.AuthenticationException;
 import org.jsecurity.authc.AuthenticationInfo;
 import org.jsecurity.authc.AuthenticationToken;
@@ -70,7 +71,7 @@
  * @author Jeremy Haile
  * @author Les Hazlewood
  */
-public abstract class AbstractAuthenticator implements Authenticator {
+public abstract class AbstractAuthenticator implements Authenticator, Initializable {
 
     /*--------------------------------------------
     |             C O N S T A N T S             |

File: src/org/jsecurity/cache/support/HashtableCache.java
Patch:
@@ -92,7 +92,7 @@ public void clear() throws CacheException {
     }
 
     public void destroy() throws CacheException {
-
+        clear();
     }
 
     public long getSizeInMemory() {

File: src/org/jsecurity/session/support/AbstractSessionManager.java
Patch:
@@ -30,6 +30,7 @@
 import org.jsecurity.session.*;
 import org.jsecurity.session.event.*;
 import org.jsecurity.session.support.eis.SessionDAO;
+import org.jsecurity.util.Initializable;
 
 import java.io.Serializable;
 import java.net.InetAddress;
@@ -41,7 +42,7 @@
  * @since 0.1
  * @author Les Hazlewood
  */
-public abstract class AbstractSessionManager implements SessionManager {
+public abstract class AbstractSessionManager implements SessionManager, Initializable {
 
     protected static final int GLOBAL_SESSION_TIMEOUT = 60 * 30; //30 minutes by default;
 

File: src/org/jsecurity/session/support/DefaultSessionFactory.java
Patch:
@@ -27,6 +27,7 @@
 import org.jsecurity.authz.AuthorizationException;
 import org.jsecurity.authz.HostUnauthorizedException;
 import org.jsecurity.session.*;
+import org.jsecurity.util.Initializable;
 
 import java.io.Serializable;
 import java.net.InetAddress;
@@ -60,7 +61,7 @@
  * @since 0.1
  * @author Les Hazlewood
  */
-public class DefaultSessionFactory implements SessionFactory {
+public class DefaultSessionFactory implements SessionFactory, Initializable {
 
     private SessionManager sessionManager = null;
 

File: samples/spring/src/org/jsecurity/samples/spring/DefaultSampleManager.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.jsecurity.context.support.ThreadLocalSecurityContext;
 import org.jsecurity.session.Session;
+import org.jsecurity.util.ThreadContext;
 
 /**
  * Insert JavaDoc here.
@@ -35,7 +35,7 @@ public class DefaultSampleManager implements SampleManager {
     ============================================*/
 
     public String getValue() {
-        Session session = ThreadLocalSecurityContext.current().getSession( false );
+        Session session = (Session) ThreadContext.get( ThreadContext.SESSION_KEY );
         if( session != null ) {
             return (String) session.getAttribute( "value" );
         } else {
@@ -44,7 +44,7 @@ public String getValue() {
     }
 
     public void setValue(String newValue) {
-        Session session = ThreadLocalSecurityContext.current().getSession( false );
+        Session session = (Session) ThreadContext.get( ThreadContext.SESSION_KEY );
         if( session != null ) {
             session.setAttribute( "value", newValue );
         }

File: samples/spring/src/org/jsecurity/samples/spring/web/JnlpController.java
Patch:
@@ -53,7 +53,7 @@ protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpSer
             sb.append( ":" );
             sb.append( request.getServerPort() );
         }
-        sb.append( "/jsecurity-spring-sample/" );
+        sb.append( request.getContextPath() );
 
         // prevent JNLP caching by setting response headers
         response.setHeader( "cache-control", "no-cache" );

File: src/org/jsecurity/session/support/SimpleSession.java
Patch:
@@ -55,8 +55,8 @@ public class SimpleSession implements Session, Serializable {
 
     public SimpleSession() {
 
-        //JSecurity uses UUID's by default.  This can be overridden via the setSessionId method:
-        sessionId = java.util.UUID.randomUUID();
+        //JSecurity uses String UUIDs by default.  This can be overridden via the setSessionId method:
+        sessionId = java.util.UUID.randomUUID().toString();
         startTimestamp = new Date();
         lastAccessTime = startTimestamp; //default when first instantiated
         try {

File: src/org/jsecurity/web/WebUtils.java
Patch:
@@ -139,7 +139,7 @@ public static void constructAndBindSecurityContextToThread( HttpServletRequest r
     private static List<Principal> getPrincipals(HttpServletRequest request) {
         List<Principal> principals = null;
 
-        Session session = ThreadLocalSecurityContext.current().getSession( false );
+        Session session = (Session) ThreadContext.get( ThreadContext.SESSION_KEY );
         if( session != null ) {
             principals = (List<Principal>) session.getAttribute( PRINCIPALS_SESSION_KEY );
         } else {
@@ -179,7 +179,7 @@ public static void bindPrincipalsToSessionIfNecessary( HttpServletRequest reques
         SecurityContext ctx = (SecurityContext) ThreadContext.get( ThreadContext.SECURITY_CONTEXT_KEY );
 
         if ( ctx != null ) {
-            Session session = ThreadLocalSecurityContext.current().getSession( false );
+            Session session = ThreadLocalSecurityContext.current().getSession();
             if( session != null && session.getAttribute( PRINCIPALS_SESSION_KEY) == null ) {
                 session.setAttribute( PRINCIPALS_SESSION_KEY, ctx.getAllPrincipals() );
 

File: support/spring/src/org/jsecurity/spring/remoting/SecureRemoteInvocationFactory.java
Patch:
@@ -1,8 +1,8 @@
 package org.jsecurity.spring.remoting;
 
 import org.aopalliance.intercept.MethodInvocation;
-import org.jsecurity.context.support.ThreadLocalSecurityContext;
 import org.jsecurity.session.Session;
+import org.jsecurity.util.ThreadContext;
 import org.springframework.remoting.support.DefaultRemoteInvocationFactory;
 import org.springframework.remoting.support.RemoteInvocation;
 import org.springframework.remoting.support.RemoteInvocationFactory;
@@ -30,7 +30,7 @@ public class SecureRemoteInvocationFactory extends DefaultRemoteInvocationFactor
      * @return a remote invocation object containing the current session ID.
      */
     public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {
-        Session session = ThreadLocalSecurityContext.current().getSession( false );
+        Session session = (Session) ThreadContext.get( ThreadContext.SESSION_KEY );
 
         Serializable sessionId;
         if( session != null ) {

File: src/org/jsecurity/session/support/AbstractSessionManager.java
Patch:
@@ -517,7 +517,7 @@ public void touch( Serializable sessionId ) throws InvalidSessionException {
     }
 
     public Principal getPrincipal( Serializable sessionId ) {
-        Session s = retrieveAndValidateSession( sessionId );
+        return null;
     }
 
     public InetAddress getHostAddress( Serializable sessionId ) {

File: src/org/jsecurity/authc/support/ModularRealmAuthenticator.java
Patch:
@@ -72,8 +72,8 @@ public ModularRealmAuthenticator() {
     }
 
 
-    public ModularRealmAuthenticator(SecurityManager SecurityManager, List<? extends Realm> realms ) {
-        setSecurityManager( SecurityManager );
+    public ModularRealmAuthenticator(SecurityManager securityManager, List<? extends Realm> realms ) {
+        setSecurityManager( securityManager );
         this.realms = realms;
     }
 

File: src/org/jsecurity/session/support/AbstractSessionManager.java
Patch:
@@ -517,7 +517,7 @@ public void touch( Serializable sessionId ) throws InvalidSessionException {
     }
 
     public Principal getPrincipal( Serializable sessionId ) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
+        Session s = retrieveAndValidateSession( sessionId );
     }
 
     public InetAddress getHostAddress( Serializable sessionId ) {

File: src/org/jsecurity/authz/AuthorizationOperations.java
Patch:
@@ -31,7 +31,7 @@
 
 /**
  * <p>
- * Interface that specifies the set of authorization operations that are implemented by the {@link SecurityManager}
+ * Interface that specifies the set of authorization operations that are implemented by the {@link org.jsecurity.SecurityManager}
  * and all {@link org.jsecurity.realm.Realm}s.
  * </p>
  *

File: ri/business/src/org/jsecurity/ri/realm/activedirectory/ActiveDirectoryRealm.java
Patch:
@@ -144,7 +144,7 @@ protected void processAttribute(LdapDirectoryInfo info, Attribute attr) throws N
             Collection<String> roleNames = translateRoleNames(groupNames);
 
             if( log.isDebugEnabled() ) {
-                log.debug( "Adding roles [" + groupNames + "] to LDAP directory info." );
+                log.debug( "Adding roles [" + roleNames + "] to LDAP directory info." );
             }
 
             info.addAllRoleNames( roleNames );

File: ri/business/src/org/jsecurity/ri/authc/AbstractAuthenticator.java
Patch:
@@ -278,7 +278,7 @@ public final SecurityContext authenticate( AuthenticationToken token )
             }
         } catch ( AuthenticationException e ) {
             if ( logger.isInfoEnabled() ) {
-                logger.info( "Authentication failed for token submission [" + token + "]" );
+                logger.info( "Authentication failed for token submission [" + token + "] because [" + e.getMessage() + "]" );
             }
             sendFailureEvent( token, e );
             throw e;

File: ri/common/src/org/jsecurity/ri/util/UsernamePrincipal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005 Les Hazlewood
+ * Copyright (C) 2005 Jeremy Haile
  *
  * This library is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as published
@@ -111,7 +111,7 @@ public Object clone() {
             sp.setUsername( getUsername() ); //Strings are immutable, no need to clone
             return sp;
         } catch ( CloneNotSupportedException e ) {
-            throw new InternalError( "Unable to clone StringPrincipal");
+            throw new InternalError( "Unable to clone " + getClass().getName());
         }
     }
 

File: ri/web/src/org/jsecurity/ri/web/tags/PrincipalTag.java
Patch:
@@ -181,15 +181,15 @@ private String getPrincipalProperty(Principal principal, String property) throws
             }
 
             if( !foundProperty ) {
-                final String message = "Property [" + property + "] not found in principal of type [" + principal + "]";
+                final String message = "Property [" + property + "] not found in principal of type [" + principal.getClass().getName() + "]";
                 if (logger.isErrorEnabled()) {
                     logger.error(message);
                 }
                 throw new JspTagException( message );
             }
 
         } catch (Exception e) {
-            final String message = "Error reading property [" + property + "] from principal of type [" + principal + "]";
+            final String message = "Error reading property [" + property + "] from principal of type [" + principal.getClass().getName() + "]";
             if (logger.isErrorEnabled()) {
                 logger.error(message, e);
             }

File: api/src/org/jsecurity/authz/NoSuchPrincipalException.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Exception thrown if a principal of a particular type is requested from
- * an {@link AuthorizationContext} and no principal of that type is found
+ * an {@link org.jsecurity.context.SecurityContext} and no principal of that type is found
  * within the context.
  *
  * @since 0.1

File: api/src/org/jsecurity/authz/annotation/RolesRequired.java
Patch:
@@ -4,7 +4,7 @@
  * <p>
  * Requires the current executor to have one or more specified roles in order to execute the
  * annotated method.  If the executor's associated
- * {@link org.jsecurity.authz.AuthorizationContext AuthorizationContext} determines that the
+ * {@link org.jsecurity.context.SecurityContext SecurityContext} determines that the
  * executor does not have the specified role(s), the method will not be executed.
  * </p>
  * <p>For example,<br>
@@ -27,7 +27,7 @@
  * capabilities will not change for an application since permissions directly correspond to how
  * the application's functionality is programmed.
  *
- * @see org.jsecurity.authz.AuthorizationContext#hasRole(String)
+ * @see org.jsecurity.context.SecurityContext#hasRole(String)
  *
  * @since 0.1
  * @author Jeremy Haile

File: api/src/org/jsecurity/authz/module/AuthorizationModule.java
Patch:
@@ -25,7 +25,7 @@
 
 package org.jsecurity.authz.module;
 
-import org.jsecurity.authz.AuthorizationContext;
+import org.jsecurity.context.SecurityContext;
 import org.jsecurity.authz.AuthorizedAction;
 
 
@@ -55,7 +55,7 @@ public interface AuthorizationModule {
 
     /**
      * Called when the authorization module needs to vote on whether or not
-     * a particular {@link AuthorizationContext} is authorized to perform an
+     * a particular {@link org.jsecurity.context.SecurityContext} is authorized to perform an
      * {@link AuthorizedAction}.  This method is only called if this module
      * {@link #supports supports} the specified <tt>action</tt>.
      *
@@ -65,7 +65,7 @@ public interface AuthorizationModule {
      * @return a vote indicating whether or not this module grants authorization
      * to the user, or abstains from voting.
      */
-    AuthorizationVote isAuthorized( AuthorizationContext context,
+    AuthorizationVote isAuthorized( SecurityContext context,
                                     AuthorizedAction action );
 
 }

File: ri/business/src/org/jsecurity/ri/authz/module/ModularAuthorizationStrategy.java
Patch:
@@ -25,7 +25,7 @@
 
 package org.jsecurity.ri.authz.module;
 
-import org.jsecurity.authz.AuthorizationContext;
+import org.jsecurity.context.SecurityContext;
 import org.jsecurity.authz.AuthorizedAction;
 import org.jsecurity.authz.module.AuthorizationModule;
 import org.jsecurity.authz.module.AuthorizationVote;
@@ -54,7 +54,7 @@ public interface ModularAuthorizationStrategy {
      * @return true if the user should be authorized based on the votes, or
      * false otherwise.
      */
-    boolean isAuthorized( AuthorizationContext context,
+    boolean isAuthorized( SecurityContext context,
                           AuthorizedAction action,
                           Map<AuthorizationModule, AuthorizationVote> votes );
     

File: ri/business/src/org/jsecurity/ri/authz/module/NoDenialStrategy.java
Patch:
@@ -25,7 +25,7 @@
 
 package org.jsecurity.ri.authz.module;
 
-import org.jsecurity.authz.AuthorizationContext;
+import org.jsecurity.context.SecurityContext;
 import org.jsecurity.authz.AuthorizedAction;
 import org.jsecurity.authz.module.AuthorizationModule;
 import org.jsecurity.authz.module.AuthorizationVote;
@@ -52,7 +52,7 @@ public class NoDenialStrategy implements ModularAuthorizationStrategy {
     /**
      * @see ModularAuthorizationStrategy#isAuthorized
      */
-    public boolean isAuthorized( AuthorizationContext context,
+    public boolean isAuthorized( SecurityContext context,
                                  AuthorizedAction action,
                                  Map<AuthorizationModule, AuthorizationVote> votes ) {
 

File: ri/business/src/org/jsecurity/ri/authz/module/PermissionAnnotationAuthorizationModule.java
Patch:
@@ -25,7 +25,7 @@
 package org.jsecurity.ri.authz.module;
 
 import org.apache.commons.beanutils.BeanUtils;
-import org.jsecurity.authz.AuthorizationContext;
+import org.jsecurity.context.SecurityContext;
 import org.jsecurity.authz.AuthorizedAction;
 import org.jsecurity.authz.annotation.PermissionsRequired;
 import org.jsecurity.authz.method.MethodInvocation;
@@ -117,7 +117,7 @@ protected Permission createPermission( AuthorizedAction action ) {
         }
     }
 
-    public AuthorizationVote isAuthorized( AuthorizationContext context, AuthorizedAction action ) {
+    public AuthorizationVote isAuthorized( SecurityContext context, AuthorizedAction action ) {
         Permission p = createPermission( action );
         if ( context.implies( p ) ) {
             if ( log.isDebugEnabled() ) {
@@ -127,7 +127,7 @@ public AuthorizationVote isAuthorized( AuthorizationContext context, AuthorizedA
             return AuthorizationVote.grant;
         } else {
             if ( log.isDebugEnabled() ) {
-                log.debug( "AuthorizationContext does not imply permission [" + p +
+                log.debug( "SecurityContext does not imply permission [" + p +
                            "].  Returning deny vote." );
             }
             return AuthorizationVote.deny;

File: ri/business/src/org/jsecurity/ri/web/AuthenticationFilter.java
Patch:
@@ -27,7 +27,6 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.jsecurity.authz.AuthorizationContext;
 import org.jsecurity.context.SecurityContext;
 import org.jsecurity.ri.context.ThreadLocalSecurityContext;
 
@@ -167,7 +166,7 @@ public void doFilter(ServletRequest request, ServletResponse response, FilterCha
 
         HttpServletRequest httpRequest = (HttpServletRequest) request;
 
-        AuthorizationContext authContext = new ThreadLocalSecurityContext();
+        SecurityContext authContext = new ThreadLocalSecurityContext();
 
         String requestedPath = httpRequest.getRequestURI();
 

File: ri/web/src/org/jsecurity/ri/web/tags/HasRoleTag.java
Patch:
@@ -33,7 +33,7 @@ public class HasRoleTag extends RoleTag {
     public HasRoleTag(){}
 
     protected boolean showTagBody( String roleName ) {
-        return getAuthorizationContext().hasRole( roleName );
+        return getSecurityContext().hasRole( roleName );
     }
 
 }

File: ri/web/src/org/jsecurity/ri/web/tags/ImpliesTag.java
Patch:
@@ -37,7 +37,7 @@ public ImpliesTag() {
     }
 
     protected boolean showTagBody( Permission p ) {
-        return getAuthorizationContext().implies( p );
+        return getSecurityContext().implies( p );
     }
 
 }

File: ri/web/src/org/jsecurity/ri/web/tags/LacksRoleTag.java
Patch:
@@ -34,7 +34,7 @@ public LacksRoleTag() {
     }
 
     protected boolean showTagBody( String roleName ) {
-        boolean hasRole = getAuthorizationContext().hasRole( roleName );
+        boolean hasRole = getSecurityContext().hasRole( roleName );
         return !hasRole;
     }
 

File: ri/web/src/org/jsecurity/ri/web/tags/NotImpliesTag.java
Patch:
@@ -37,7 +37,7 @@ public NotImpliesTag() {
     }
 
     protected boolean showTagBody( Permission p ) {
-        boolean permitted = getAuthorizationContext().implies( p );
+        boolean permitted = getSecurityContext().implies( p );
         return !permitted;
     }
 

File: ri/web/src/org/jsecurity/ri/web/tags/SecureTag.java
Patch:
@@ -26,7 +26,6 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.jsecurity.authz.AuthorizationContext;
 import org.jsecurity.context.SecurityContext;
 import org.jsecurity.ri.context.ThreadLocalSecurityContext;
 
@@ -45,7 +44,7 @@ public abstract class SecureTag extends TagSupport {
 
     public SecureTag(){}
 
-    protected AuthorizationContext getAuthorizationContext() {
+    protected SecurityContext getSecurityContext() {
         return securityContext;
     }
 

File: support/spring/src/org/jsecurity/spring/remoting/SecureRemoteInvocationExecutor.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.jsecurity.ri.authz.DelegatingAuthorizationContext;
+import org.jsecurity.ri.authz.DelegatingSecurityContext;
 import org.jsecurity.ri.realm.RealmManager;
 import org.jsecurity.ri.util.ThreadUtils;
 import org.jsecurity.ri.web.WebUtils;
@@ -18,7 +18,7 @@
 
 /**
  * An implementation of the Spring {@link org.springframework.remoting.support.RemoteInvocationExecutor}
- * that binds the correct {@link Session} and {@link org.jsecurity.authz.AuthorizationContext} to the
+ * that binds the correct {@link Session} and {@link org.jsecurity.context.SecurityContext} to the
  * remote invocation thread during a remote execution.
  *
  * @since 0.1
@@ -88,7 +88,7 @@ public Object invoke(RemoteInvocation invocation, Object targetObject) throws No
                 // If principals and realm were found in the session, create a delegating authorization context
                 // and bind it to the thread.
                 if( principals != null && !principals.isEmpty() ) {
-                    ThreadUtils.bindToThread( new DelegatingAuthorizationContext( principals, realmManager ) );
+                    ThreadUtils.bindToThread( new DelegatingSecurityContext( principals, realmManager ) );
                 }
 
             } else {

File: support/spring/src/org/jsecurity/spring/servlet/security/AuthorizationInterceptor.java
Patch:
@@ -50,18 +50,18 @@ public void setRealmManager( RealmManager realmManager) {
     public boolean preHandle( HttpServletRequest request, HttpServletResponse response,
                               Object handler ) throws Exception {
 
-        WebUtils.bindAuthorizationContextToThread( request, realmManager );
+        WebUtils.bindSecurityContextToThread( request, realmManager );
         return true;
     }
 
     public void postHandle( HttpServletRequest request, HttpServletResponse response,
                             Object handler, ModelAndView modelAndView ) throws Exception {
-        WebUtils.bindAuthorizationContextToSession( request );
+        WebUtils.bindSecurityContextToSession( request );
     }
 
     public void afterCompletion( HttpServletRequest request, HttpServletResponse response,
                                  Object handler, Exception ex ) throws Exception {
-        WebUtils.unbindAuthorizationContextFromThread();
+        WebUtils.unbindSecurityContextFromThread();
     }
 
 }

File: ri/business/src/org/jsecurity/ri/AbstractSecurityManager.java
Patch:
@@ -25,6 +25,7 @@
 
 package org.jsecurity.ri;
 
+import org.jsecurity.SecurityManager;
 import org.jsecurity.Configuration;
 import org.jsecurity.authc.AuthenticationException;
 import org.jsecurity.authc.AuthenticationToken;

File: ri/business/src/org/jsecurity/ri/RealmSecurityManager.java
Patch:
@@ -142,7 +142,7 @@ public void destroy() {
      * is not found.
      * @param realmName the name of the realm to be retrieved.
      * @return the realm to be retrieved.
-     * @thros IllegalArgumentException if no realm is found with the given name.
+     * @throws IllegalArgumentException if no realm is found with the given name.
      */
     public Realm getRealm(String realmName) {
         Realm realm = realmMap.get( realmName );

File: ri/business/src/org/jsecurity/ri/realm/AbstractCachingRealm.java
Patch:
@@ -176,8 +176,11 @@ protected final AuthorizationInfo getAuthorizationInfo(Principal principal) {
         }
 
         if( info == null ) {
+
+            // Call template method if authorization info was not found in a cache
             info = doGetAuthorizationInfo( principal );
 
+            // If the info is not null and the cache has been created, then cache the info.
             if( info != null && authorizationInfoCache != null ) {
 
                 if (logger.isTraceEnabled()) {

File: samples/spring/src/org/jsecurity/samples/spring/SampleManager.java
Patch:
@@ -3,7 +3,7 @@
 import org.jsecurity.authz.annotation.RolesRequired;
 
 /**
- * Insert JavaDoc here.
+ * Business manager interface used for sample application.
  */
 public interface SampleManager {
 

File: samples/spring/src/org/jsecurity/samples/spring/ui/WebStartView.java
Patch:
@@ -78,7 +78,7 @@ public void init() throws IOException {
         methodPanel.add( secureMethod2Button );
 
         frame = new JFrame( "JSecurity Sample Application" );
-        frame.setSize( 300, 150 );
+        frame.setSize( 300, 200 );
 
         Container panel = frame.getContentPane();
         panel.setLayout( new BorderLayout() );
@@ -109,9 +109,11 @@ public void actionPerformed(ActionEvent e) {
 
             } else if( e.getSource() == secureMethod1Button ) {
                 sampleManager.secureMethod1();
+                JOptionPane.showMessageDialog( frame, "Method #1 successfully called.", "Success", JOptionPane.INFORMATION_MESSAGE );
 
             } else if( e.getSource() == secureMethod2Button ) {
                 sampleManager.secureMethod2();
+                JOptionPane.showMessageDialog( frame, "Method #2 successfully called.", "Success", JOptionPane.INFORMATION_MESSAGE );
 
             } else {
                 throw new RuntimeException( "Unexpected action event from source: " + e.getSource() );

File: api/src/org/jsecurity/authz/AuthorizationContext.java
Patch:
@@ -60,7 +60,7 @@ public interface AuthorizationContext {
      * @return a collection of principals associated with this context, or an empty collection
      * if no principals are associated with this authorization context
      */
-    Collection<Principal> getAllPrincipals();
+    List<Principal> getAllPrincipals();
 
     /**
      * Returns a single principal assignable from the specified type

File: ri/business/src/org/jsecurity/ri/authc/module/ldap/LdapAuthenticationModule.java
Patch:
@@ -176,7 +176,8 @@ protected AuthenticationInfo buildAuthenticationInfo(String username, char[] pas
         principals.add( principal );
         principals.addAll( ldapDirectoryInfo.getPrincipals() );
 
-        return new SimpleAuthenticationInfo( principals, password, ldapDirectoryInfo.getRoleNames() );
+        //todo Figure out how to get authz information since roles are not returned in SimpleAuthenticationInfo anymore
+        return new SimpleAuthenticationInfo( principals, password );
     }
 
     /**

File: ri/business/src/org/jsecurity/ri/web/AuthorizationContextFilter.java
Patch:
@@ -71,7 +71,8 @@ public void doFilter(ServletRequest servletRequest, ServletResponse servletRespo
         try {
 
             // Bind a auth context from the http session to the thread local
-            WebUtils.bindAuthorizationContextToThread( request );
+            //todo Fix filter to get the realm from somewhere - currently broken
+            WebUtils.bindAuthorizationContextToThread( null, request );
 
             filterChain.doFilter( servletRequest, servletResponse );
 

File: ri/common/src/org/jsecurity/ri/authz/DelegatingAuthorizationContext.java
Patch:
@@ -98,7 +98,7 @@ public Principal getPrincipal() {
     /**
      * @see org.jsecurity.authz.AuthorizationContext#getAllPrincipals()
      */
-    public Collection<Principal> getAllPrincipals() {
+    public List<Principal> getAllPrincipals() {
         return principals;
     }
 

File: ri/common/src/org/jsecurity/ri/authz/Realm.java
Patch:
@@ -26,7 +26,6 @@
 
 import org.jsecurity.authz.AuthorizationException;
 
-import java.io.Serializable;
 import java.security.Permission;
 import java.security.Principal;
 import java.util.Collection;
@@ -71,7 +70,7 @@ public interface Realm {
      * @return <tt>true</tt> if the subject with the id of <tt>subjectIdentifier</tt> has the role
      * with the id of <tt>roleIdentifier</tt>, <tt>false</tt> otherwise.
      */
-    boolean hasRole( Principal subjectIdentifier, Serializable roleIdentifier );
+    boolean hasRole( Principal subjectIdentifier, String roleIdentifier );
 
     /**
      * Checks to see if the roles with the given identifiers are associated with the subject (user)

File: jsecurity/ri/common/src/org/jsecurity/ri/util/PermissionUtils.java
Patch:
@@ -15,7 +15,7 @@ public class PermissionUtils {
 
     private static void assertTarget( String nameOrTarget ) {
         if ( nameOrTarget == null ) {
-            String msg = "name or target String argument cannot be null";
+            String msg = "name (a.k.a. target) String argument cannot be null";
             throw new IllegalArgumentException( msg );
         }
     }

File: jsecurity/ri/business/src/org/jsecurity/ri/authc/module/activedirectory/ActiveDirectoryAuthenticationModule.java
Patch:
@@ -230,7 +230,7 @@ protected LdapDirectoryInfo performAuthentication(String username, char[] passwo
         env.put(Context.REFERRAL, refferal);
 
         if (log.isDebugEnabled()) {
-            log.debug( "Initializing LDAP context using environment properties [" + env + "]" );
+            log.debug( "Initializing LDAP context using URL [" + url + "] for user [" + username + "]." );
         }
 
         LdapContext ctx = null;

File: jsecurity/ri/business/src/org/jsecurity/ri/authz/module/PermissionAnnotationAuthorizationModule.java
Patch:
@@ -50,7 +50,7 @@ public class PermissionAnnotationAuthorizationModule extends AnnotationAuthoriza
     public PermissionAnnotationAuthorizationModule() {
         setAnnotationClass( HasPermission.class );
     }
-                                                                
+
     private String inferTargetFromPath( Object[] methodArgs, String targetPath ) throws Exception {
         int propertyStartIndex = -1;
 
@@ -78,7 +78,7 @@ private String inferTargetFromPath( Object[] methodArgs, String targetPath ) thr
     }
 
     private Permission instantiatePermission( Class<? extends Permission> clazz,
-                                              String name, String[] actions ) {
+                                              String name, String actions ) {
         // Instantiate the permission instance using reflection
         Permission permission;
         try {
@@ -104,7 +104,7 @@ private Permission createPermission( MethodInvocation mi, HasPermission hp ) {
         if ( targetPath.equals( "" ) ) {
             targetPath = null;
         }
-        String[] actions = hp.actions();
+        String actions = hp.actions();
 
         if ( targetPath != null ) {
             try {

File: jsecurity/support/spring/src/org/jsecurity/spring/security/interceptor/AuthorizationInterceptor.java
Patch:
@@ -81,9 +81,9 @@ public String toString() {
 
             this.authorizer.checkAuthorization( authzCtx, jsecurityMI );
         } else {
-            String msg = "No AuthorizationContext available via " +
+            String msg = "User is not authenticated.  No AuthorizationContext available via " +
                 SecurityContext.class.getName() + ".getAuthorizationContext().  " +
-                "Authorization will be denied.  User may not be authenticated.";
+                "Authorization will be denied.";
             throw new UnauthorizedException( msg );
         }
 

File: jsecurity/ri/business/src/org/jsecurity/ri/authz/module/PermissionAnnotationAuthorizationModule.java
Patch:
@@ -50,7 +50,7 @@ public class PermissionAnnotationAuthorizationModule extends AnnotationAuthoriza
     public PermissionAnnotationAuthorizationModule() {
         setAnnotationClass( HasPermission.class );
     }
-
+                                                                
     private String inferTargetFromPath( Object[] methodArgs, String targetPath ) throws Exception {
         int propertyStartIndex = -1;
 

File: jsecurity/ri/business/src/org/jsecurity/session/DefaultSessionManager.java
Patch:
@@ -97,7 +97,7 @@ public void validateSessions() {
             if ( invalidCount > 0 ) {
                 msg += "  [" + invalidCount + "] sessions were stopped.";
             } else {
-                msg += "  No sessions were stopped";
+                msg += "  No sessions were stopped.";
             }
             log.info( msg );
         }

File: jsecurity/api/src/org/jsecurity/JSecurityException.java
Patch:
@@ -24,6 +24,8 @@
  */
 package org.jsecurity;
 
+import java.io.Serializable;
+
 /**
  * Root exception for all JSecurity runtime exceptions.  This class is used as the root instead
  * of {@link java.lang.SecurityException} to remove the potential for conflicts;  many other
@@ -32,7 +34,7 @@
  *
  * @author Les Hazlewood
  */
-public class JSecurityException extends RuntimeException {
+public class JSecurityException extends RuntimeException implements Serializable {
 
     public JSecurityException() {
         super();

File: jsecurity/api/src/org/jsecurity/session/SessionFactory.java
Patch:
@@ -109,8 +109,8 @@ public interface SessionFactory {
      *
      * @param sessionId the id of the session to acquire.
      * @return a handle to the session identified by <tt>sessionId</tt>
-     * @throws ExpiredSessionException if the session identified by <tt>sessionId</tt> has expired,
-     * thereby proventing further use.
+     * @throws InvalidSessionException if the session identified by <tt>sessionId</tt> has
+     * been stopped, expired, or doesn't exist.
      * @throws AuthorizationException if the executor of this method is not allowed to acquire
      * (i.e. join) the session identified by <tt>sessionId</tt>.  The reason for the exception
      * is implementation specific and could be for any number of reasons.  A common reason in many
@@ -120,6 +120,6 @@ public interface SessionFactory {
      *
      * @see HostUnauthorizedException
      */
-    Session getSession( Serializable sessionId ) throws ExpiredSessionException, AuthorizationException;
+    Session getSession( Serializable sessionId ) throws InvalidSessionException, AuthorizationException;
 
 }

File: jsecurity/ri/common/src/org/jsecurity/session/event/ExpiredSessionEvent.java
Patch:
@@ -42,5 +42,4 @@ public ExpiredSessionEvent( Serializable sessionId ) {
     public ExpiredSessionEvent( Object source, Serializable sessionId ) {
         super( source, sessionId );
     }
-
 }

File: jsecurity/ri/common/src/org/jsecurity/session/event/SessionEventSender.java
Patch:
@@ -26,7 +26,8 @@
 
 /**
  * Sends a {@link SessionEvent} to interested parties.  How interested parties receive the events
- * (e.g. via sychronous calls to listeners, JMS, etc) is determined by the implementation.
+ * (e.g. via sychronous calls to listeners, publishing JMS messages, etc) is determined by the
+ * implementation.
  *
  * @author Les Hazlewood
  */

File: jsecurity/ri/business/src/org/jsecurity/authz/module/AnnotationAuthorizationModule.java
Patch:
@@ -29,7 +29,6 @@
 import org.apache.commons.logging.LogFactory;
 import org.jsecurity.authz.AuthorizedAction;
 import org.jsecurity.authz.method.MethodInvocation;
-import org.jsecurity.authz.module.AuthorizationModule;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;

File: jsecurity/api/src/org/jsecurity/authz/annotation/HasPermission.java
Patch:
@@ -38,7 +38,7 @@
  * </p>
  * For example,<br>
  * <blockquote><pre>
- * &#64;HasPermission(value="MyFilePermission",target="file",actions={"read","write"})
+ * &#64;HasPermission(value="MyFilePermission",name="file",actions={"read","write"})
  * void someMethod();
  * </pre>
  * </blockquote>

