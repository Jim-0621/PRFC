File: objectbox-java/src/main/java/io/objectbox/sync/Sync.java
Patch:
@@ -18,7 +18,6 @@
 
 import io.objectbox.BoxStore;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.sync.server.SyncHybridBuilder;
 import io.objectbox.sync.server.SyncServer;
 import io.objectbox.sync.server.SyncServerBuilder;
 

File: objectbox-java/src/main/java/io/objectbox/sync/SyncCredentials.java
Patch:
@@ -92,6 +92,6 @@ public long getTypeId() {
      * This can be useful to use the same credentials when creating multiple clients or a server in combination with a
      * client as some credentials may get cleared when building a client or server.
      */
-    public abstract SyncCredentials createClone();
+    abstract SyncCredentials createClone();
 
 }

File: objectbox-java/src/main/java/io/objectbox/sync/SyncCredentialsToken.java
Patch:
@@ -75,7 +75,7 @@ public void clear() {
     }
 
     @Override
-    public SyncCredentialsToken createClone() {
+    SyncCredentialsToken createClone() {
         if (cleared) {
             throw new IllegalStateException("Cannot clone: credentials already have been cleared");
         }

File: objectbox-java/src/main/java/io/objectbox/sync/SyncCredentialsUserPassword.java
Patch:
@@ -43,7 +43,7 @@ public String getPassword() {
     }
 
     @Override
-    public SyncCredentials createClone() {
+    SyncCredentials createClone() {
         return new SyncCredentialsUserPassword(this.username, this.password);
     }
 }

File: objectbox-java/src/main/java/io/objectbox/sync/SyncHybrid.java
Patch:
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package io.objectbox.sync.server;
+package io.objectbox.sync;
 
 import java.io.Closeable;
 
 import io.objectbox.BoxStore;
-import io.objectbox.sync.SyncClient;
+import io.objectbox.sync.server.SyncServer;
 
 /**
  * The SyncHybrid combines the functionality of a Sync Client and a Sync Server.
@@ -36,7 +36,7 @@ public final class SyncHybrid implements Closeable {
     private BoxStore storeServer;
     private final SyncServer server;
 
-    public SyncHybrid(BoxStore store, SyncClient client, BoxStore storeServer, SyncServer server) {
+    SyncHybrid(BoxStore store, SyncClient client, BoxStore storeServer, SyncServer server) {
         this.store = store;
         this.client = client;
         this.storeServer = storeServer;

File: objectbox-java/src/main/java/io/objectbox/sync/server/SyncServerBuilder.java
Patch:
@@ -24,6 +24,7 @@
 import javax.annotation.Nullable;
 
 import io.objectbox.BoxStore;
+import io.objectbox.annotation.apihint.Internal;
 import io.objectbox.flatbuffers.FlatBufferBuilder;
 import io.objectbox.sync.Credentials;
 import io.objectbox.sync.Sync;
@@ -56,6 +57,7 @@ public class SyncServerBuilder {
     /**
      * Use {@link Sync#server(BoxStore, String, SyncCredentials)} instead.
      */
+    @Internal
     public SyncServerBuilder(BoxStore boxStore, String url, SyncCredentials authenticatorCredentials) {
         checkNotNull(boxStore, "BoxStore is required.");
         checkNotNull(url, "Sync server URL is required.");

File: objectbox-java/src/main/java/io/objectbox/converter/IntegerLongMapConverter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 ObjectBox Ltd. All rights reserved.
+ * Copyright 2020-2024 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,9 +19,9 @@
 import io.objectbox.flatbuffers.FlexBuffers;
 
 /**
- * Used to automatically convert {@code Map&lt;Integer, Long&gt;}.
+ * Like {@link IntegerFlexMapConverter}, but always restores integer map values as {@link Long}.
  * <p>
- * Unlike {@link FlexObjectConverter} always restores integer map values as {@link Long}.
+ * Used by default to convert {@code Map<Integer, Long>}.
  */
 public class IntegerLongMapConverter extends IntegerFlexMapConverter {
     @Override

File: objectbox-java/src/main/java/io/objectbox/converter/LongLongMapConverter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 ObjectBox Ltd. All rights reserved.
+ * Copyright 2020-2024 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,9 +19,9 @@
 import io.objectbox.flatbuffers.FlexBuffers;
 
 /**
- * Used to automatically convert {@code Map&lt;Long, Long&gt;}.
+ * Like {@link LongFlexMapConverter}, but always restores integer map values as {@link Long}.
  * <p>
- * Unlike {@link FlexObjectConverter} always restores integer map values as {@link Long}.
+ * Used by default to convert {@code Map<Long, Long>}.
  */
 public class LongLongMapConverter extends LongFlexMapConverter {
     @Override

File: objectbox-java/src/main/java/io/objectbox/Property.java
Patch:
@@ -316,7 +316,7 @@ public PropertyQueryCondition<ENTITY> between(double lowerBoundary, double upper
      * use maxResultCount of 100 with a Query limit of 10 to have 10 results that are of potentially better quality than
      * just passing in 10 for maxResultCount (quality/performance tradeoff).
      */
-    public PropertyQueryCondition<ENTITY> nearestNeighborsF32(float[] queryVector, int maxResultCount) {
+    public PropertyQueryCondition<ENTITY> nearestNeighbors(float[] queryVector, int maxResultCount) {
         return new NearestNeighborCondition<>(this, queryVector, maxResultCount);
     }
 

File: objectbox-java/src/main/java/io/objectbox/query/PropertyQueryConditionImpl.java
Patch:
@@ -475,7 +475,7 @@ public NearestNeighborCondition(Property<T> property, float[] queryVector, int m
 
         @Override
         void applyCondition(QueryBuilder<T> builder) {
-            builder.nearestNeighborsF32(property, queryVector, maxResultCount);
+            builder.nearestNeighbors(property, queryVector, maxResultCount);
         }
     }
 }

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -898,7 +898,7 @@ public QueryBuilder<T> between(Property<T> property, double value1, double value
         return this;
     }
 
-    QueryBuilder<T> nearestNeighborsF32(Property<T> property, float[] queryVector, int maxResultCount) {
+    public QueryBuilder<T> nearestNeighbors(Property<T> property, float[] queryVector, int maxResultCount) {
         verifyHandle();
         checkCombineCondition(nativeNearestNeighborsF32(handle, property.getId(), queryVector, maxResultCount));
         return this;

File: objectbox-java-api/src/main/java/io/objectbox/annotation/HnswIndex.java
Patch:
@@ -59,7 +59,7 @@
     /**
      * The distance type used for the HNSW index. Changing this value causes re-indexing.
      */
-    HnswDistanceType distanceType() default HnswDistanceType.DEFAULT;
+    VectorDistanceType distanceType() default VectorDistanceType.DEFAULT;
 
     /**
      * When repairing the graph after a node was removed, this gives the probability of adding backlinks to the repaired

File: objectbox-java-api/src/main/java/io/objectbox/annotation/VectorDistanceType.java
Patch:
@@ -17,9 +17,9 @@
 package io.objectbox.annotation;
 
 /**
- * The distance algorithm used by an {@link HnswIndex} (vector search).
+ * The vector distance algorithm used by an {@link HnswIndex} (vector search).
  */
-public enum HnswDistanceType {
+public enum VectorDistanceType {
 
     /**
      * The default; currently {@link #EUCLIDEAN}.

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -425,8 +425,7 @@ public <TARGET> QueryBuilder<TARGET> backlink(RelationInfo<TARGET, ?> relationIn
 
     /**
      * Specifies relations that should be resolved eagerly.
-     * This prepares the given relation objects to be preloaded (cached) avoiding further get operations from the db.
-     * A common use case is prealoading all
+     * This prepares the given relation objects to be preloaded (cached) avoiding further get operations from the database.
      *
      * @param relationInfo The relation as found in the generated meta info class ("EntityName_") of class T.
      * @param more         Supply further relations to be eagerly loaded.

File: objectbox-java/src/main/java/io/objectbox/sync/Sync.java
Patch:
@@ -37,6 +37,9 @@ public static SyncBuilder client(BoxStore boxStore, String url, SyncCredentials
      * Start building a sync server. Requires the BoxStore the server should use,
      * the URL and port the server should bind to and authenticator credentials to authenticate clients.
      * Additional authenticator credentials can be supplied using the builder.
+     * <p>
+     * For the embedded server, currently only {@link SyncCredentials#sharedSecret} and {@link SyncCredentials#none}
+     * are supported.
      */
     public static SyncServerBuilder server(BoxStore boxStore, String url, SyncCredentials authenticatorCredentials) {
         return new SyncServerBuilder(boxStore, url, authenticatorCredentials);

File: objectbox-java/src/main/java/io/objectbox/sync/server/SyncServerBuilder.java
Patch:
@@ -46,6 +46,9 @@ public SyncServerBuilder certificatePath(String certificatePath) {
 
     /**
      * Adds additional authenticator credentials to authenticate clients with.
+     * <p>
+     * For the embedded server, currently only {@link SyncCredentials#sharedSecret} and {@link SyncCredentials#none}
+     * are supported.
      */
     public SyncServerBuilder authenticatorCredentials(SyncCredentials authenticatorCredentials) {
         checkNotNull(authenticatorCredentials, "Authenticator credentials must not be null.");

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -453,6 +453,7 @@ public static boolean isDatabaseOpen(File directory) throws IOException {
      */
     @Experimental
     public static long sysProcMeminfoKb(String key) {
+        NativeLibraryLoader.ensureLoaded();
         return nativeSysProcMeminfoKb(key);
     }
 
@@ -475,6 +476,7 @@ public static long sysProcMeminfoKb(String key) {
      */
     @Experimental
     public static long sysProcStatusKb(String key) {
+        NativeLibraryLoader.ensureLoaded();
         return nativeSysProcStatusKb(key);
     }
 
@@ -720,6 +722,7 @@ public static boolean deleteAllFiles(File objectStoreDirectory) {
         if (isFileOpen(canonicalPath)) {
             throw new IllegalStateException("Cannot delete files: store is still open");
         }
+        NativeLibraryLoader.ensureLoaded();
         return nativeRemoveDbFiles(canonicalPath, true);
     }
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/BoxStoreBuilderTest.java
Patch:
@@ -55,7 +55,7 @@ protected BoxStore createBoxStore() {
     @Before
     public void setUpBuilder() {
         BoxStore.clearDefaultStore();
-        builder = new BoxStoreBuilder(createTestModel(null)).directory(boxStoreDir);
+        builder = createBuilderWithTestModel().directory(boxStoreDir);
     }
 
     @Test

File: tests/objectbox-java-test/src/test/java/io/objectbox/BoxStoreValidationTest.java
Patch:
@@ -53,7 +53,7 @@ protected BoxStore createBoxStore() {
     @Before
     public void setUpBuilder() {
         BoxStore.clearDefaultStore();
-        builder = new BoxStoreBuilder(createTestModel(null)).directory(boxStoreDir);
+        builder = createBuilderWithTestModel().directory(boxStoreDir);
     }
 
     @Test

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -28,7 +28,7 @@
 import io.objectbox.Property;
 import io.objectbox.annotation.apihint.Experimental;
 import io.objectbox.annotation.apihint.Internal;
-import io.objectbox.exception .DbException;
+import io.objectbox.exception.DbException;
 import io.objectbox.relation.RelationInfo;
 
 /**

File: objectbox-java/src/main/java/io/objectbox/DebugFlags.java
Patch:
@@ -21,8 +21,11 @@
 /**
  * Debug flags typically enable additional "debug logging" that can be helpful to better understand what is going on
  * internally. These are intended for the development process only; typically one does not enable them for releases.
+ *
+ * @deprecated DebugFlags moved to config package: use {@link io.objectbox.config.DebugFlags} instead.
  */
 @SuppressWarnings("unused")
+@Deprecated
 public final class DebugFlags {
   private DebugFlags() { }
   public static final int LOG_TRANSACTIONS_READ = 1;

File: objectbox-java/src/main/java/io/objectbox/config/FlatStoreOptions.java
Patch:
@@ -16,7 +16,7 @@
 
 // automatically generated by the FlatBuffers compiler, do not modify
 
-package io.objectbox.model;
+package io.objectbox.config;
 
 import io.objectbox.flatbuffers.BaseVector;
 import io.objectbox.flatbuffers.BooleanVector;

File: objectbox-java/src/main/java/io/objectbox/config/TreeOptionFlags.java
Patch:
@@ -16,7 +16,7 @@
 
 // automatically generated by the FlatBuffers compiler, do not modify
 
-package io.objectbox.model;
+package io.objectbox.config;
 
 /**
  * Options flags for trees.

File: objectbox-java/src/main/java/io/objectbox/config/ValidateOnOpenModeKv.java
Patch:
@@ -16,7 +16,7 @@
 
 // automatically generated by the FlatBuffers compiler, do not modify
 
-package io.objectbox.model;
+package io.objectbox.config;
 
 /**
  * Defines if and how the database is checked for valid key/value (KV) entries when opening it.

File: objectbox-java/src/main/java/io/objectbox/model/ValidateOnOpenMode.java
Patch:
@@ -20,7 +20,10 @@
 
 /**
  * Defines if and how the database is checked for structural consistency (pages) when opening it.
+ *
+ * @deprecated This class has moved to the config package, use {@link io.objectbox.config.ValidateOnOpenModePages} instead.
  */
+@Deprecated
 @SuppressWarnings("unused")
 public final class ValidateOnOpenMode {
   private ValidateOnOpenMode() { }

File: tests/objectbox-java-test/src/test/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import io.objectbox.ModelBuilder.EntityBuilder;
 import io.objectbox.ModelBuilder.PropertyBuilder;
 import io.objectbox.annotation.IndexType;
+import io.objectbox.config.DebugFlags;
 import io.objectbox.model.PropertyFlags;
 import io.objectbox.model.PropertyType;
 import org.junit.After;

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/AbstractQueryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 ObjectBox Ltd. All rights reserved.
+ * Copyright 2018-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,8 +25,8 @@
 import io.objectbox.AbstractObjectBoxTest;
 import io.objectbox.Box;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.DebugFlags;
 import io.objectbox.TestEntity;
+import io.objectbox.config.DebugFlags;
 
 import javax.annotation.Nullable;
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/QueryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,12 +19,12 @@
 import io.objectbox.Box;
 import io.objectbox.BoxStore;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.DebugFlags;
 import io.objectbox.TestEntity;
 import io.objectbox.TestEntity_;
 import io.objectbox.TestUtils;
 import io.objectbox.exception.DbExceptionListener;
 import io.objectbox.exception.NonUniqueResultException;
+import io.objectbox.config.DebugFlags;
 import io.objectbox.query.QueryBuilder.StringOrder;
 import io.objectbox.relation.MyObjectBox;
 import io.objectbox.relation.Order;

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/AbstractRelationTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import io.objectbox.Box;
 import io.objectbox.BoxStore;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.DebugFlags;
+import io.objectbox.config.DebugFlags;
 
 public abstract class AbstractRelationTest extends AbstractObjectBoxTest {
 

File: objectbox-java/src/main/java/io/objectbox/DebugFlags.java
Patch:
@@ -21,8 +21,11 @@
 /**
  * Debug flags typically enable additional "debug logging" that can be helpful to better understand what is going on
  * internally. These are intended for the development process only; typically one does not enable them for releases.
+ *
+ * @deprecated DebugFlags moved to config package: use {@link io.objectbox.config.DebugFlags} instead.
  */
 @SuppressWarnings("unused")
+@Deprecated
 public final class DebugFlags {
   private DebugFlags() { }
   public static final int LOG_TRANSACTIONS_READ = 1;

File: objectbox-java/src/main/java/io/objectbox/config/FlatStoreOptions.java
Patch:
@@ -16,7 +16,7 @@
 
 // automatically generated by the FlatBuffers compiler, do not modify
 
-package io.objectbox.model;
+package io.objectbox.config;
 
 import io.objectbox.flatbuffers.BaseVector;
 import io.objectbox.flatbuffers.BooleanVector;

File: objectbox-java/src/main/java/io/objectbox/config/TreeOptionFlags.java
Patch:
@@ -16,7 +16,7 @@
 
 // automatically generated by the FlatBuffers compiler, do not modify
 
-package io.objectbox.model;
+package io.objectbox.config;
 
 /**
  * Options flags for trees.

File: objectbox-java/src/main/java/io/objectbox/config/ValidateOnOpenModeKv.java
Patch:
@@ -16,7 +16,7 @@
 
 // automatically generated by the FlatBuffers compiler, do not modify
 
-package io.objectbox.model;
+package io.objectbox.config;
 
 /**
  * Defines if and how the database is checked for valid key/value (KV) entries when opening it.

File: objectbox-java/src/main/java/io/objectbox/model/ValidateOnOpenMode.java
Patch:
@@ -20,7 +20,10 @@
 
 /**
  * Defines if and how the database is checked for structural consistency (pages) when opening it.
+ *
+ * @deprecated This class has moved to the config package, use {@link io.objectbox.config.ValidateOnOpenMode} instead.
  */
+@Deprecated
 @SuppressWarnings("unused")
 public final class ValidateOnOpenMode {
   private ValidateOnOpenMode() { }

File: tests/objectbox-java-test/src/test/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import io.objectbox.ModelBuilder.EntityBuilder;
 import io.objectbox.ModelBuilder.PropertyBuilder;
 import io.objectbox.annotation.IndexType;
+import io.objectbox.config.DebugFlags;
 import io.objectbox.model.PropertyFlags;
 import io.objectbox.model.PropertyType;
 import org.junit.After;

File: tests/objectbox-java-test/src/test/java/io/objectbox/BoxStoreValidationTest.java
Patch:
@@ -21,9 +21,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 
+import io.objectbox.config.ValidateOnOpenMode;
 import io.objectbox.exception.FileCorruptException;
 import io.objectbox.exception.PagesCorruptException;
-import io.objectbox.model.ValidateOnOpenMode;
 import org.greenrobot.essentials.io.IoUtils;
 import org.junit.Before;
 import org.junit.Test;

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/AbstractQueryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 ObjectBox Ltd. All rights reserved.
+ * Copyright 2018-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,8 +25,8 @@
 import io.objectbox.AbstractObjectBoxTest;
 import io.objectbox.Box;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.DebugFlags;
 import io.objectbox.TestEntity;
+import io.objectbox.config.DebugFlags;
 
 import javax.annotation.Nullable;
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/QueryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,12 +19,12 @@
 import io.objectbox.Box;
 import io.objectbox.BoxStore;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.DebugFlags;
 import io.objectbox.TestEntity;
 import io.objectbox.TestEntity_;
 import io.objectbox.TestUtils;
 import io.objectbox.exception.DbExceptionListener;
 import io.objectbox.exception.NonUniqueResultException;
+import io.objectbox.config.DebugFlags;
 import io.objectbox.query.QueryBuilder.StringOrder;
 import io.objectbox.relation.MyObjectBox;
 import io.objectbox.relation.Order;

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/AbstractRelationTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import io.objectbox.Box;
 import io.objectbox.BoxStore;
 import io.objectbox.BoxStoreBuilder;
-import io.objectbox.DebugFlags;
+import io.objectbox.config.DebugFlags;
 
 public abstract class AbstractRelationTest extends AbstractObjectBoxTest {
 

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -520,7 +520,7 @@ byte[] buildFlatStoreOptions(String canonicalPath) {
         FlatStoreOptions.addFileMode(fbb, fileMode);
         FlatStoreOptions.addMaxReaders(fbb, maxReaders);
         if (validateOnOpenMode != 0) {
-            FlatStoreOptions.addValidateOnOpen(fbb, validateOnOpenMode);
+            FlatStoreOptions.addValidateOnOpenPages(fbb, validateOnOpenMode);
             if (validateOnOpenPageLimit != 0) {
                 FlatStoreOptions.addValidateOnOpenPageLimit(fbb, validateOnOpenPageLimit);
             }

File: objectbox-java/src/main/java/io/objectbox/DebugFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 ObjectBox Ltd. All rights reserved.
+ * Copyright 2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: objectbox-java/src/main/java/io/objectbox/flatbuffers/Constants.java
Patch:
@@ -46,7 +46,7 @@ public class Constants {
     Changes to the Java implementation need to be sure to change
     the version here and in the code generator on every possible
     incompatible change */
-    public static void FLATBUFFERS_2_0_8() {}
+    public static void FLATBUFFERS_23_5_26() {}
 }
 
 /// @endcond

File: objectbox-java/src/main/java/io/objectbox/model/EntityFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 ObjectBox Ltd. All rights reserved.
+ * Copyright 2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: objectbox-java/src/main/java/io/objectbox/model/PropertyFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 ObjectBox Ltd. All rights reserved.
+ * Copyright 2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: objectbox-java/src/main/java/io/objectbox/model/SyncFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 ObjectBox Ltd. All rights reserved.
+ * Copyright 2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: objectbox-java/src/main/java/io/objectbox/model/ValidateOnOpenMode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 ObjectBox Ltd. All rights reserved.
+ * Copyright 2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,7 @@
 package io.objectbox.model;
 
 /**
- * Defines if and how the database is checked for structural consistency when opening it.
+ * Defines if and how the database is checked for structural consistency (pages) when opening it.
  */
 @SuppressWarnings("unused")
 public final class ValidateOnOpenMode {

File: objectbox-java/src/main/java/io/objectbox/query/OrderFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 ObjectBox Ltd. All rights reserved.
+ * Copyright 2023 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: objectbox-java/src/main/java/io/objectbox/internal/NativeLibraryLoader.java
Patch:
@@ -30,6 +30,7 @@
 import java.lang.reflect.Method;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.Charset;
 import java.util.Arrays;
 
 import javax.annotation.Nonnull;
@@ -203,7 +204,8 @@ private static String getCpuArchOSOrNull() {
         try {
             // Linux
             Process exec = Runtime.getRuntime().exec("uname -m");
-            BufferedReader reader = new BufferedReader(new InputStreamReader(exec.getInputStream()));
+            BufferedReader reader = new BufferedReader(
+                    new InputStreamReader(exec.getInputStream(), Charset.defaultCharset()));
             archOrNull = reader.readLine();
             reader.close();
         } catch (Exception ignored) {

File: objectbox-java/src/main/java/io/objectbox/internal/ToManyGetter.java
Patch:
@@ -22,6 +22,6 @@
 import io.objectbox.annotation.apihint.Internal;
 
 @Internal
-public interface ToManyGetter<SOURCE> extends Serializable {
-    <TARGET> List<TARGET> getToMany(SOURCE object);
+public interface ToManyGetter<SOURCE, TARGET> extends Serializable {
+    List<TARGET> getToMany(SOURCE object);
 }

File: objectbox-java/src/main/java/io/objectbox/internal/ToOneGetter.java
Patch:
@@ -22,6 +22,6 @@
 import io.objectbox.relation.ToOne;
 
 @Internal
-public interface ToOneGetter<SOURCE> extends Serializable {
-    <TARGET> ToOne<TARGET> getToOne(SOURCE object);
+public interface ToOneGetter<SOURCE, TARGET> extends Serializable {
+    ToOne<TARGET> getToOne(SOURCE object);
 }

File: objectbox-java/src/main/java/io/objectbox/relation/ToMany.java
Patch:
@@ -696,7 +696,7 @@ public boolean internalCheckApplyToDbRequired() {
 
     private boolean prepareToManyBacklinkEntitiesForDb(long entityId, IdGetter<TARGET> idGetter,
                                                        @Nullable Map<TARGET, Boolean> setAdded, @Nullable Map<TARGET, Boolean> setRemoved) {
-        ToManyGetter<TARGET> backlinkToManyGetter = relationInfo.backlinkToManyGetter;
+        ToManyGetter<TARGET, Object> backlinkToManyGetter = relationInfo.backlinkToManyGetter;
 
         synchronized (this) {
             if (setAdded != null && !setAdded.isEmpty()) {
@@ -740,7 +740,7 @@ private boolean prepareToManyBacklinkEntitiesForDb(long entityId, IdGetter<TARGE
 
     private boolean prepareToOneBacklinkEntitiesForDb(long entityId, IdGetter<TARGET> idGetter,
                                                       @Nullable Map<TARGET, Boolean> setAdded, @Nullable Map<TARGET, Boolean> setRemoved) {
-        ToOneGetter<TARGET> backlinkToOneGetter = relationInfo.backlinkToOneGetter;
+        ToOneGetter<TARGET, Object> backlinkToOneGetter = relationInfo.backlinkToOneGetter;
 
         synchronized (this) {
             if (setAdded != null && !setAdded.isEmpty()) {

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/Customer_.java
Patch:
@@ -109,20 +109,20 @@ public long getId(Customer object) {
     }
 
     public static final RelationInfo<Customer, Order> orders =
-            new RelationInfo<>(Customer_.__INSTANCE, Order_.__INSTANCE, new ToManyGetter<Customer>() {
+            new RelationInfo<>(Customer_.__INSTANCE, Order_.__INSTANCE, new ToManyGetter<Customer, Order>() {
                 @Override
                 public List<Order> getToMany(Customer customer) {
                     return customer.getOrders();
                 }
-            }, Order_.customerId, new ToOneGetter<Order>() {
+            }, Order_.customerId, new ToOneGetter<Order, Customer>() {
                 @Override
                 public ToOne<Customer> getToOne(Order order) {
                     return order.getCustomer();
                 }
             });
 
     public static final RelationInfo<Customer, Order> ordersStandalone =
-            new RelationInfo<>(Customer_.__INSTANCE, Order_.__INSTANCE, new ToManyGetter<Customer>() {
+            new RelationInfo<>(Customer_.__INSTANCE, Order_.__INSTANCE, new ToManyGetter<Customer, Order>() {
                 @Override
                 public List<Order> getToMany(Customer customer) {
                     return customer.getOrders();

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/Order_.java
Patch:
@@ -110,7 +110,7 @@ public long getId(Order object) {
         }
     }
 
-    public static final RelationInfo<Order, Customer> customer = new RelationInfo<>(Order_.__INSTANCE, Customer_.__INSTANCE, customerId, new ToOneGetter<Order>() {
+    public static final RelationInfo<Order, Customer> customer = new RelationInfo<>(Order_.__INSTANCE, Customer_.__INSTANCE, customerId, new ToOneGetter<Order, Customer>() {
         @Override
         public ToOne<Customer> getToOne(Order object) {
             return object.getCustomer();

File: tests/objectbox-java-test/src/test/java/io/objectbox/tree/DataBranch_.java
Patch:
@@ -106,7 +106,7 @@ public long getId(DataBranch object) {
 
     /** To-one relation "parent" to target entity "DataBranch". */
     public static final RelationInfo<DataBranch, DataBranch> parent =
-            new RelationInfo<>(DataBranch_.__INSTANCE, DataBranch_.__INSTANCE, parentId, new ToOneGetter<DataBranch>() {
+            new RelationInfo<>(DataBranch_.__INSTANCE, DataBranch_.__INSTANCE, parentId, new ToOneGetter<DataBranch, DataBranch>() {
                 @Override
                 public ToOne<DataBranch> getToOne(DataBranch entity) {
                     return entity.parent;
@@ -115,7 +115,7 @@ public ToOne<DataBranch> getToOne(DataBranch entity) {
 
     /** To-one relation "metaBranch" to target entity "MetaBranch". */
     public static final RelationInfo<DataBranch, MetaBranch> metaBranch =
-            new RelationInfo<>(DataBranch_.__INSTANCE, MetaBranch_.__INSTANCE, metaBranchId, new ToOneGetter<DataBranch>() {
+            new RelationInfo<>(DataBranch_.__INSTANCE, MetaBranch_.__INSTANCE, metaBranchId, new ToOneGetter<DataBranch, MetaBranch>() {
                 @Override
                 public ToOne<MetaBranch> getToOne(DataBranch entity) {
                     return entity.metaBranch;

File: tests/objectbox-java-test/src/test/java/io/objectbox/tree/DataLeaf_.java
Patch:
@@ -118,7 +118,7 @@ public long getId(DataLeaf object) {
 
     /** To-one relation "dataBranch" to target entity "DataBranch". */
     public static final RelationInfo<DataLeaf, DataBranch> dataBranch =
-            new RelationInfo<>(DataLeaf_.__INSTANCE, io.objectbox.tree.DataBranch_.__INSTANCE, dataBranchId, new ToOneGetter<DataLeaf>() {
+            new RelationInfo<>(DataLeaf_.__INSTANCE, io.objectbox.tree.DataBranch_.__INSTANCE, dataBranchId, new ToOneGetter<DataLeaf, DataBranch>() {
                 @Override
                 public ToOne<DataBranch> getToOne(DataLeaf entity) {
                     return entity.dataBranch;
@@ -127,7 +127,7 @@ public ToOne<DataBranch> getToOne(DataLeaf entity) {
 
     /** To-one relation "metaLeaf" to target entity "MetaLeaf". */
     public static final RelationInfo<DataLeaf, MetaLeaf> metaLeaf =
-            new RelationInfo<>(DataLeaf_.__INSTANCE, io.objectbox.tree.MetaLeaf_.__INSTANCE, metaLeafId, new ToOneGetter<DataLeaf>() {
+            new RelationInfo<>(DataLeaf_.__INSTANCE, io.objectbox.tree.MetaLeaf_.__INSTANCE, metaLeafId, new ToOneGetter<DataLeaf, MetaLeaf>() {
                 @Override
                 public ToOne<MetaLeaf> getToOne(DataLeaf entity) {
                     return entity.metaLeaf;

File: tests/objectbox-java-test/src/test/java/io/objectbox/tree/MetaBranch_.java
Patch:
@@ -106,7 +106,7 @@ public long getId(MetaBranch object) {
 
     /** To-one relation "parent" to target entity "MetaBranch". */
     public static final RelationInfo<MetaBranch, MetaBranch> parent =
-            new RelationInfo<>(MetaBranch_.__INSTANCE, MetaBranch_.__INSTANCE, parentId, new ToOneGetter<MetaBranch>() {
+            new RelationInfo<>(MetaBranch_.__INSTANCE, MetaBranch_.__INSTANCE, parentId, new ToOneGetter<MetaBranch, MetaBranch>() {
                 @Override
                 public ToOne<MetaBranch> getToOne(MetaBranch entity) {
                     return entity.parent;

File: tests/objectbox-java-test/src/test/java/io/objectbox/tree/MetaLeaf_.java
Patch:
@@ -129,7 +129,7 @@ public long getId(MetaLeaf object) {
 
     /** To-one relation "branch" to target entity "MetaBranch". */
     public static final RelationInfo<MetaLeaf, MetaBranch> branch =
-            new RelationInfo<>(MetaLeaf_.__INSTANCE, MetaBranch_.__INSTANCE, branchId, new ToOneGetter<MetaLeaf>() {
+            new RelationInfo<>(MetaLeaf_.__INSTANCE, MetaBranch_.__INSTANCE, branchId, new ToOneGetter<MetaLeaf, MetaBranch>() {
                 @Override
                 public ToOne<MetaBranch> getToOne(MetaLeaf entity) {
                     return entity.branch;

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -482,7 +482,7 @@ byte[] buildFlatStoreOptions(String canonicalPath) {
 
         // ...then build options.
         FlatStoreOptions.addDirectoryPath(fbb, directoryPathOffset);
-        FlatStoreOptions.addMaxDbSizeInKByte(fbb, maxSizeInKByte);
+        FlatStoreOptions.addMaxDbSizeInKbyte(fbb, maxSizeInKByte);
         FlatStoreOptions.addFileMode(fbb, fileMode);
         FlatStoreOptions.addMaxReaders(fbb, maxReaders);
         if (validateOnOpenMode != 0) {

File: objectbox-java/src/main/java/io/objectbox/sync/package-info.java
Patch:
@@ -28,8 +28,8 @@
  *     credentials.</li>
  *     <li>Optional: use the {@link io.objectbox.sync.SyncBuilder} instance from the last step to configure the sync
  *     client and set initial listeners.</li>
- *     <li>Call {@link io.objectbox.sync.SyncBuilder#build()}</li> to get an instance of
- *     {@link io.objectbox.sync.SyncClient} (and hold on to it). Synchronization is now active.
+ *     <li>Call {@link io.objectbox.sync.SyncBuilder#build()} to get an instance of
+ *     {@link io.objectbox.sync.SyncClient} (and hold on to it). Synchronization is now active.</li>
  *     <li>Optional: Interact with {@link io.objectbox.sync.SyncClient}</li>
  * </ol>
  */

File: objectbox-java/src/main/java/io/objectbox/tree/Tree.java
Patch:
@@ -19,7 +19,7 @@
  * Adding properties to tree types is allowed.
  * <p>
  * Note there are TWO ways to work with tree data (both ways can be mixed):
- * - Standard ObjectBox entity types with e.g. Box<DataLeaf>
+ * - Standard ObjectBox entity types with e.g. Box&lt;DataLeaf&gt;
  * - Higher level tree API via this Tree class
  * <p>
  * To navigate in the tree, you typically start with {@link #getRoot()}, which returns a {@link Branch}.

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -532,6 +532,7 @@ public QueryBuilder<T> and() {
     }
 
     private void combineOperator(Operator operator) {
+        verifyHandle(); // Not using handle, but throw for consistency with other methods.
         if (lastCondition == 0) {
             throw new IllegalStateException("No previous condition. Use operators like and() and or() only between two conditions.");
         }

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -232,7 +232,8 @@ public static boolean isSyncServerAvailable() {
     /** Set when running inside TX */
     final ThreadLocal<Transaction> activeTx = new ThreadLocal<>();
 
-    private boolean closed;
+    // volatile so checkOpen() is more up-to-date (no need for synchronized; it's a race anyway)
+    volatile private boolean closed;
 
     final Object txCommitCountLock = new Object();
 

File: objectbox-java/src/main/java/io/objectbox/query/Query.java
Patch:
@@ -110,7 +110,8 @@ native void nativeSetParameter(long handle, int entityId, int propertyId, @Nulla
     private final int queryAttempts;
     private static final int INITIAL_RETRY_BACK_OFF_IN_MS = 10;
 
-    long handle;
+    // volatile so checkOpen() is more up-to-date (no need for synchronized; it's a race anyway)
+    volatile long handle;
 
     Query(Box<T> box, long queryHandle, @Nullable List<EagerRelation<T, ?>> eagerRelations, @Nullable  QueryFilter<T> filter,
           @Nullable Comparator<T> comparator) {

File: objectbox-java/src/main/java/io/objectbox/query/Query.java
Patch:
@@ -140,7 +140,7 @@ protected void finalize() throws Throwable {
      * If possible, call this always once done with this. Otherwise, will be called once this is finalized (e.g. garbage
      * collected).
      * <p>
-     * Calling any other methods of this afterwards will throw an exception.
+     * Calling any other methods of this afterwards will throw an {@link IllegalStateException}.
      */
     public synchronized void close() {
         if (handle != 0) {

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -532,6 +532,7 @@ public QueryBuilder<T> and() {
     }
 
     private void combineOperator(Operator operator) {
+        verifyHandle(); // Not using handle, but throw for consistency with other methods.
         if (lastCondition == 0) {
             throw new IllegalStateException("No previous condition. Use operators like and() and or() only between two conditions.");
         }

File: tests/objectbox-java-test/src/test/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -296,11 +296,11 @@ protected TestEntity createTestEntity(@Nullable String simpleString, int nr) {
         entity.setSimpleShortU((short) (100 + nr));
         entity.setSimpleIntU(nr);
         entity.setSimpleLongU(1000 + nr);
-        Map<String, Object> stringObjectMap = new HashMap<>();
         if (simpleString != null) {
+            Map<String, Object> stringObjectMap = new HashMap<>();
             stringObjectMap.put(simpleString, simpleString);
+            entity.setStringObjectMap(stringObjectMap);
         }
-        entity.setStringObjectMap(stringObjectMap);
         return entity;
     }
 

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -425,6 +425,7 @@ public <TARGET> QueryBuilder<TARGET> backlink(RelationInfo<TARGET, ?> relationIn
      * @param relationInfo The relation as found in the generated meta info class ("EntityName_") of class T.
      * @param more         Supply further relations to be eagerly loaded.
      */
+    @SuppressWarnings("rawtypes")
     public QueryBuilder<T> eager(RelationInfo relationInfo, RelationInfo... more) {
         return eager(0, relationInfo, more);
     }
@@ -436,6 +437,7 @@ public QueryBuilder<T> eager(RelationInfo relationInfo, RelationInfo... more) {
      * @param relationInfo The relation as found in the generated meta info class ("EntityName_") of class T.
      * @param more         Supply further relations to be eagerly loaded.
      */
+    @SuppressWarnings({"rawtypes", "unchecked"})
     public QueryBuilder<T> eager(int limit, RelationInfo relationInfo, @Nullable RelationInfo... more) {
         verifyNotSubQuery();
         if (eagerRelations == null) {

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -360,7 +360,7 @@ public QueryBuilder<T> sort(Comparator<T> comparator) {
 
 
     /**
-     * Asigns the given alias to the previous condition.
+     * Assigns the given alias to the previous condition.
      *
      * @param alias The string alias for use with setParameter(s) methods.
      */

File: objectbox-java/src/main/java/io/objectbox/internal/NativeLibraryLoader.java
Patch:
@@ -114,6 +114,7 @@ public class NativeLibraryLoader {
                 message = String.format(
                         "[ObjectBox] Android failed to load native library," +
                                 " check your APK/App Bundle includes a supported ABI or use ReLinker" +
+                                " https://docs.objectbox.io/android/app-bundle-and-split-apk" +
                                 " (vendor=%s,os=%s,os.arch=%s,SUPPORTED_ABIS=%s)",
                         vendor, osName, osArch, getSupportedABIsAndroid()
                 );

File: objectbox-java/src/main/java/io/objectbox/query/PropertyQueryConditionImpl.java
Patch:
@@ -325,7 +325,8 @@ void applyCondition(QueryBuilder<T> builder) {
                     builder.lessOrEqual(property, value, order);
                     break;
                 case CONTAINS:
-                    builder.contains(property, value, order);
+                    // Note: contains used for String[] as well, so do not enforce String type here.
+                    builder.containsNoTypeCheck(property, value, order);
                     break;
                 case STARTS_WITH:
                     builder.startsWith(property, value, order);

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/PropertyQueryTest.java
Patch:
@@ -82,7 +82,7 @@ public void testFindStrings() {
         putTestEntity("BAR", 100);
         putTestEntitiesStrings();
         putTestEntity("banana", 101);
-        Query<TestEntity> query = box.query().startsWith(simpleString, "b").build();
+        Query<TestEntity> query = box.query().startsWith(simpleString, "b", StringOrder.CASE_INSENSITIVE).build();
 
         String[] result = query.property(simpleString).findStrings();
         assertEquals(5, result.length);

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/QueryTest2.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.objectbox.query;
 
+import io.objectbox.query.QueryBuilder.StringOrder;
 import org.junit.Test;
 
 import java.util.List;
@@ -41,7 +42,7 @@ public void newQueryApi() {
 
         // current query API
         Query<TestEntity> query = box.query()
-                .equal(TestEntity_.simpleString, "Fry")
+                .equal(TestEntity_.simpleString, "Fry", StringOrder.CASE_INSENSITIVE)
                 .less(TestEntity_.simpleInt, 12)
                 .or()
                 .in(TestEntity_.simpleLong, new long[]{1012})

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -57,7 +57,7 @@
 import io.objectbox.sync.SyncClient;
 
 /**
- * An ObjectBox database that provides {@link Box Boxes} to put and get Objects of a specific Entity class
+ * An ObjectBox database that provides {@link Box Boxes} to put and get objects of specific entity classes
  * (see {@link #boxFor(Class)}). To get an instance of this class use {@code MyObjectBox.builder()}.
  */
 @SuppressWarnings({"unused", "UnusedReturnValue", "SameParameterValue", "WeakerAccess"})
@@ -71,7 +71,7 @@ public class BoxStore implements Closeable {
     /** Change so ReLinker will update native library when using workaround loading. */
     public static final String JNI_VERSION = "2.9.2-RC3";
 
-    private static final String VERSION = "2.9.2-2021-06-29";
+    private static final String VERSION = "2.9.2-2021-08-18";
     private static BoxStore defaultStore;
 
     /** Currently used DB dirs with values from {@link #getCanonicalPath(File)}. */

File: objectbox-java/src/main/java/io/objectbox/tree/Tree.java
Patch:
@@ -158,8 +158,8 @@ public long putMetaBranch(long id, long parentBranchId, String name) {
         return nativePutMetaBranch(handle, id, parentBranchId, name, null);
     }
 
-    public long putMetaBranch(long id, long parentBranchId, String name, @Nullable String uid) {
-        return nativePutMetaBranch(handle, id, parentBranchId, name, uid);
+    public long putMetaBranch(long id, long parentBranchId, String name, @Nullable String description) {
+        return nativePutMetaBranch(handle, id, parentBranchId, name, description);
     }
 
     public long[] putMetaBranches(String[] path) {

File: objectbox-java/src/main/java/io/objectbox/DebugFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 /**
  * Flags to enable debug behavior like additional logging.
  */
+@SuppressWarnings("unused")
 public final class DebugFlags {
   private DebugFlags() { }
   public static final int LOG_TRANSACTIONS_READ = 1;

File: objectbox-java/src/main/java/io/objectbox/flatbuffers/ByteBufferUtil.java
Patch:
@@ -19,6 +19,7 @@
 import static io.objectbox.flatbuffers.Constants.*;
 
 import java.nio.ByteBuffer;
+import java.nio.Buffer;
 
 /// @file
 /// @addtogroup flatbuffers_java_api
@@ -49,7 +50,7 @@ public static int getSizePrefix(ByteBuffer bb) {
      */
     public static ByteBuffer removeSizePrefix(ByteBuffer bb) {
         ByteBuffer s = bb.duplicate();
-        s.position(s.position() + SIZE_PREFIX_LENGTH);
+        ((Buffer) s).position(s.position() + SIZE_PREFIX_LENGTH);
         return s;
     }
 

File: objectbox-java/src/main/java/io/objectbox/flatbuffers/Constants.java
Patch:
@@ -46,7 +46,7 @@ public class Constants {
     Changes to the Java implementation need to be sure to change
     the version here and in the code generator on every possible
     incompatible change */
-    public static void FLATBUFFERS_1_12_0() {}
+    public static void FLATBUFFERS_2_0_0() {}
 }
 
 /// @endcond

File: objectbox-java/src/main/java/io/objectbox/flatbuffers/ReadBuf.java
Patch:
@@ -3,7 +3,7 @@
 /**
  *  Represent a chunk of data, where FlexBuffers will read from.
  */
-interface ReadBuf {
+public interface ReadBuf {
 
   /**
    * Read boolean from data. Booleans as stored as single byte

File: objectbox-java/src/main/java/io/objectbox/flatbuffers/Table.java
Patch:
@@ -18,6 +18,7 @@
 
 import static io.objectbox.flatbuffers.Constants.*;
 import java.nio.ByteBuffer;
+import java.nio.Buffer;
 import java.nio.ByteOrder;
 
 /// @cond FLATBUFFERS_INTERNAL
@@ -152,7 +153,7 @@ protected ByteBuffer __vector_as_bytebuffer(int vector_offset, int elem_size) {
     if (o == 0) return null;
     ByteBuffer bb = this.bb.duplicate().order(ByteOrder.LITTLE_ENDIAN);
     int vectorstart = __vector(o);
-    bb.position(vectorstart);
+    ((Buffer) bb).position(vectorstart);
     bb.limit(vectorstart + __vector_len(o) * elem_size);
     return bb;
   }
@@ -174,7 +175,7 @@ protected ByteBuffer __vector_in_bytebuffer(ByteBuffer bb, int vector_offset, in
     int vectorstart = __vector(o);
     bb.rewind();
     bb.limit(vectorstart + __vector_len(o) * elem_size);
-    bb.position(vectorstart);
+    ((Buffer) bb).position(vectorstart);
     return bb;
   }
 

File: objectbox-java/src/main/java/io/objectbox/model/EntityFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 /**
  * Not really an enum, but binary flags to use across languages
  */
+@SuppressWarnings("unused")
 public final class EntityFlags {
   private EntityFlags() { }
   /**

File: objectbox-java/src/main/java/io/objectbox/model/IdUid.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,10 +23,10 @@
 import java.util.*;
 import io.objectbox.flatbuffers.*;
 
-@SuppressWarnings("unused")
 /**
  * ID tuple: besides the main ID there is also a UID for verification
  */
+@SuppressWarnings("unused")
 public final class IdUid extends Struct {
   public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
   public IdUid __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
@@ -42,7 +42,7 @@ public static int createIdUid(FlatBufferBuilder builder, long id, long uid) {
     builder.prep(8, 16);
     builder.putLong(uid);
     builder.pad(4);
-    builder.putInt((int)id);
+    builder.putInt((int) id);
     return builder.offset();
   }
 

File: objectbox-java/src/main/java/io/objectbox/model/ModelEntity.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,7 +25,7 @@
 
 @SuppressWarnings("unused")
 public final class ModelEntity extends Table {
-  public static void ValidateVersion() { Constants.FLATBUFFERS_1_12_0(); }
+  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_0(); }
   public static ModelEntity getRootAsModelEntity(ByteBuffer _bb) { return getRootAsModelEntity(_bb, new ModelEntity()); }
   public static ModelEntity getRootAsModelEntity(ByteBuffer _bb, ModelEntity obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
   public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
@@ -69,7 +69,7 @@ public final class ModelEntity extends Table {
   public static void addRelations(FlatBufferBuilder builder, int relationsOffset) { builder.addOffset(4, relationsOffset, 0); }
   public static int createRelationsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
   public static void startRelationsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
-  public static void addFlags(FlatBufferBuilder builder, long flags) { builder.addInt(5, (int)flags, (int)0L); }
+  public static void addFlags(FlatBufferBuilder builder, long flags) { builder.addInt(5, (int) flags, (int) 0L); }
   public static void addNameSecondary(FlatBufferBuilder builder, int nameSecondaryOffset) { builder.addOffset(6, nameSecondaryOffset, 0); }
   public static int endModelEntity(FlatBufferBuilder builder) {
     int o = builder.endTable();

File: objectbox-java/src/main/java/io/objectbox/model/ModelRelation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,7 +25,7 @@
 
 @SuppressWarnings("unused")
 public final class ModelRelation extends Table {
-  public static void ValidateVersion() { Constants.FLATBUFFERS_1_12_0(); }
+  public static void ValidateVersion() { Constants.FLATBUFFERS_2_0_0(); }
   public static ModelRelation getRootAsModelRelation(ByteBuffer _bb) { return getRootAsModelRelation(_bb, new ModelRelation()); }
   public static ModelRelation getRootAsModelRelation(ByteBuffer _bb, ModelRelation obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
   public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }

File: objectbox-java/src/main/java/io/objectbox/model/PropertyType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 /**
  * Basic type of a property
  */
+@SuppressWarnings("unused")
 public final class PropertyType {
   private PropertyType() { }
   /**

File: objectbox-java/src/main/java/io/objectbox/model/SyncFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 /**
  * Flags to adjust sync behavior like additional logging.
  */
+@SuppressWarnings("unused")
 public final class SyncFlags {
   private SyncFlags() { }
   /**

File: objectbox-java/src/main/java/io/objectbox/model/ValidateOnOpenMode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 /**
  * Defines if and how the database is checked for structural consistency when opening it.
  */
+@SuppressWarnings("unused")
 public final class ValidateOnOpenMode {
   private ValidateOnOpenMode() { }
   /**

File: objectbox-java/src/main/java/io/objectbox/query/OrderFlags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 ObjectBox Ltd. All rights reserved.
+ * Copyright 2021 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 /**
  * Not really an enum, but binary flags to use across languages
  */
+@SuppressWarnings("unused")
 public final class OrderFlags {
   private OrderFlags() { }
   /**

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/QueryTest.java
Patch:
@@ -861,7 +861,7 @@ public void testForEachBreak() {
     // TODO can we improve? More than just "still works"?
     public void testQueryAttempts() {
         store.close();
-        BoxStoreBuilder builder = new BoxStoreBuilder(createTestModel(false)).directory(boxStoreDir)
+        BoxStoreBuilder builder = new BoxStoreBuilder(createTestModel(null)).directory(boxStoreDir)
                 .queryAttempts(5)
                 .failedReadTxAttemptCallback((result, error) -> {
                     if (error != null) {

File: objectbox-java/src/main/java/io/objectbox/reactive/Scheduler.java
Patch:
@@ -17,5 +17,5 @@
 package io.objectbox.reactive;
 
 public interface Scheduler {
-    <T> void run(RunWithParam runnable, T param);
+    <T> void run(RunWithParam<T> runnable, T param);
 }

File: tests/objectbox-java-test/src/test/java/io/objectbox/ObjectClassObserverTest.java
Patch:
@@ -259,7 +259,7 @@ int counter() {
         }
 
         @Override
-        public <T> void run(RunWithParam runnable, T param) {
+        public <T> void run(RunWithParam<T> runnable, T param) {
             counter.incrementAndGet();
             runnable.run(param);
         }

File: objectbox-java/src/main/java/io/objectbox/query/PropertyQueryConditionImpl.java
Patch:
@@ -298,7 +298,7 @@ public StringCondition(Property<T> property, Operation op, String value, StringO
         }
 
         public StringCondition(Property<T> property, Operation op, String value) {
-            this(property, op, value, StringOrder.CASE_INSENSITIVE);
+            this(property, op, value, StringOrder.CASE_SENSITIVE);
         }
 
         @Override
@@ -354,7 +354,7 @@ public StringArrayCondition(Property<T> property, Operation op, String[] value,
         }
 
         public StringArrayCondition(Property<T> property, Operation op, String[] value) {
-            this(property, op, value, StringOrder.CASE_INSENSITIVE);
+            this(property, op, value, StringOrder.CASE_SENSITIVE);
         }
 
         @Override

File: tests/objectbox-java-test/src/test/java/io/objectbox/tree/TreeTest.java
Patch:
@@ -9,7 +9,6 @@
 import static java.util.Objects.requireNonNull;
 import static org.junit.Assert.*;
 
-// TODO Add to FunctionalTestSuite.
 public class TreeTest extends AbstractObjectBoxTest {
     private Tree tree;
     private Branch root;

File: objectbox-java/src/main/java/io/objectbox/tree/Tree.java
Patch:
@@ -47,7 +47,7 @@ long getHandle() {
     }
 
     public Branch root() {
-        long dataBranchId = nativeRoot(handle);
+        long dataBranchId = nativeGetRootId(handle);
         return new Branch(this, dataBranchId);
     }
 
@@ -114,6 +114,6 @@ private <T> Callable<T> createTxCallable(Callable<T> callable) {
     /**
      * Get the root data branch ID.
      */
-    private native long nativeRoot(long handle);
+    private native long nativeGetRootId(long handle);
 
 }

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/AbstractQueryTest.java
Patch:
@@ -32,7 +32,9 @@ public class AbstractQueryTest extends AbstractObjectBoxTest {
 
     @Override
     protected BoxStoreBuilder createBoxStoreBuilder(boolean withIndex) {
-        return super.createBoxStoreBuilder(withIndex).debugFlags(DebugFlags.LOG_QUERY_PARAMETERS);
+        BoxStoreBuilder builder = super.createBoxStoreBuilder(withIndex);
+        if (DEBUG_LOG) builder.debugFlags(DebugFlags.LOG_QUERY_PARAMETERS);
+        return builder;
     }
 
     @Before

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/AbstractRelationTest.java
Patch:
@@ -36,9 +36,9 @@ public abstract class AbstractRelationTest extends AbstractObjectBoxTest {
 
     @Override
     protected BoxStore createBoxStore() {
-        return MyObjectBox.builder().baseDirectory(boxStoreDir)
-                .debugFlags(DebugFlags.LOG_TRANSACTIONS_READ | DebugFlags.LOG_TRANSACTIONS_WRITE)
-                .build();
+        BoxStoreBuilder builder = MyObjectBox.builder().baseDirectory(boxStoreDir);
+        if (DEBUG_LOG) builder.debugFlags(DebugFlags.LOG_TRANSACTIONS_READ | DebugFlags.LOG_TRANSACTIONS_WRITE);
+        return builder.build();
     }
 
     @After

File: objectbox-java/src/main/java/io/objectbox/sync/SyncCredentials.java
Patch:
@@ -43,11 +43,11 @@ public static SyncCredentials none() {
     public enum CredentialsType {
         // Note: this needs to match with CredentialsType in Core.
 
-        NONE(0),
+        NONE(1),
 
-        SHARED_SECRET(1),
+        SHARED_SECRET(2),
 
-        GOOGLE(2);
+        GOOGLE(3);
 
         public final long id;
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/index/model/MyObjectBox.java
Patch:
@@ -43,7 +43,7 @@ public static BoxStoreBuilder builder() {
     private static byte[] getModel() {
         ModelBuilder modelBuilder = new ModelBuilder();
         modelBuilder.lastEntityId(8, 602677774947261949L);
-        modelBuilder.lastIndexId(4, 4720210528670921467L);
+        modelBuilder.lastIndexId(4, 3512264863194799103L);
 
         EntityBuilder entityBuilder;
 

File: objectbox-java/src/main/java/io/objectbox/internal/NativeLibraryLoader.java
Patch:
@@ -105,8 +105,9 @@ public class NativeLibraryLoader {
             String osArch = System.getProperty("os.arch");
             String sunArch = System.getProperty("sun.arch.data.model");
             String message = String.format(
-                    "Loading ObjectBox native library failed: vendor=%s,os=%s,os.arch=%s,sun.arch=%s,android=%s,linux=%s",
-                    vendor, osName, osArch, sunArch, android, isLinux
+                    "[ObjectBox] Loading native library failed, please report this to us: " +
+                            "vendor=%s,os=%s,os.arch=%s,model=%s,android=%s,linux=%s,machine=%s",
+                    vendor, osName, osArch, sunArch, android, isLinux, getCpuArchOSOrNull()
             );
             throw new LinkageError(message, e); // UnsatisfiedLinkError does not allow a cause; use its super class
         }

File: objectbox-java/src/main/java/io/objectbox/sync/SyncCredentials.java
Patch:
@@ -49,7 +49,7 @@ public enum CredentialsType {
 
         GOOGLE(2);
 
-        public long id;
+        public final long id;
 
         CredentialsType(long id) {
             this.id = id;

File: objectbox-java/src/main/java/io/objectbox/InternalAccess.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.objectbox;
 
+import javax.annotation.Nullable;
+
 import io.objectbox.annotation.apihint.Internal;
 import io.objectbox.sync.SyncClient;
 
@@ -37,7 +39,7 @@ public static long getHandle(Transaction tx) {
         return tx.internalHandle();
     }
 
-    public static void setSyncClient(BoxStore boxStore, SyncClient syncClient) {
+    public static void setSyncClient(BoxStore boxStore, @Nullable SyncClient syncClient) {
         boxStore.setSyncClient(syncClient);
     }
 

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -270,7 +270,7 @@ public static boolean isObjectBrowserAvailable() {
 
     private byte[] buildFlatStoreOptions(BoxStoreBuilder builder, String canonicalPath) {
         FlatBufferBuilder fbb = new FlatBufferBuilder();
-        // TODO Is forceDefaults required by JNI or not?
+        // FlatBuffer default values are set in generated code, e.g. may be different from here, so always store value.
         fbb.forceDefaults(true);
 
         // Add non-integer values first...

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -291,6 +291,7 @@ private byte[] buildFlatStoreOptions(BoxStoreBuilder builder, String canonicalPa
                 FlatStoreOptions.addValidateOnOpenPageLimit(fbb, validateOnOpenPageLimit);
             }
         }
+        FlatStoreOptions.addReadSchema(fbb, !builder.doNotReadSchema);
         FlatStoreOptions.addUsePreviousCommit(fbb, builder.usePreviousCommit);
         FlatStoreOptions.addReadOnly(fbb, builder.readOnly);
         int debugFlags = builder.debugFlags;

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -281,6 +281,7 @@ private byte[] buildFlatStoreOptions(BoxStoreBuilder builder, String canonicalPa
         // ...then build options.
         FlatStoreOptions.addDirectoryPath(fbb, directoryPathOffset);
         FlatStoreOptions.addMaxDbSizeInKByte(fbb, builder.maxSizeInKByte);
+        FlatStoreOptions.addFileMode(fbb, builder.fileMode);
         FlatStoreOptions.addMaxReaders(fbb, builder.maxReaders);
         int validateOnOpenMode = builder.validateOnOpenMode;
         if (validateOnOpenMode != 0) {

File: objectbox-java/src/main/java/io/objectbox/model/FlatStoreOptions.java
Patch:
@@ -23,11 +23,11 @@
 import java.util.*;
 import com.google.flatbuffers.*;
 
-@SuppressWarnings("unused")
 /**
  * Options to open a store with. Set only the values you want; defaults are used otherwise.
  * Reminder: enable "force defaults" in the FlatBuffers builder, e.g. to pass in booleans with value "false".
  */
+@SuppressWarnings("unused")
 public final class FlatStoreOptions extends Table {
   public static void ValidateVersion() { Constants.FLATBUFFERS_1_12_0(); }
   public static FlatStoreOptions getRootAsFlatStoreOptions(ByteBuffer _bb) { return getRootAsFlatStoreOptions(_bb, new FlatStoreOptions()); }

File: objectbox-java/src/main/java/io/objectbox/ideasonly/ModelModifier.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.objectbox.ideasonly;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 public class ModelModifier {
     public class EntityModifier {
         final String schemaName;
@@ -37,6 +39,7 @@ public PropertyModifier property(String name) {
         }
     }
 
+    @SuppressFBWarnings // Class may be static, ignore as this is an idea only.
     public class PropertyModifier {
         final String name;
         final EntityModifier entityModifier;

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -27,6 +27,7 @@
 import java.io.OutputStream;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 import javax.annotation.Nonnull;
@@ -107,10 +108,11 @@ private BoxStoreBuilder() {
     /** Called internally from the generated class "MyObjectBox". Check MyObjectBox.builder() to get an instance. */
     @Internal
     public BoxStoreBuilder(byte[] model) {
-        this.model = model;
         if (model == null) {
             throw new IllegalArgumentException("Model may not be null");
         }
+        // Future-proofing: copy to prevent external modification.
+        this.model = Arrays.copyOf(model, model.length);
     }
 
     /**

File: objectbox-java/src/main/java/io/objectbox/model/EntityFlags.java
Patch:
@@ -28,7 +28,8 @@ private EntityFlags() { }
    */
   public static final int USE_NO_ARG_CONSTRUCTOR = 1;
 
-  public static final String[] names = { "USE_NO_ARG_CONSTRUCTOR", };
+  // Private to protect contents from getting modified.
+  private static final String[] names = { "USE_NO_ARG_CONSTRUCTOR", };
 
   public static String name(int e) { return names[e - USE_NO_ARG_CONSTRUCTOR]; }
 }

File: objectbox-java/src/main/java/io/objectbox/model/PropertyType.java
Patch:
@@ -69,7 +69,8 @@ private PropertyType() { }
   public static final short DateVector = 31;
   public static final short DateNanoVector = 32;
 
-  public static final String[] names = { "Unknown", "Bool", "Byte", "Short", "Char", "Int", "Long", "Float", "Double", "String", "Date", "Relation", "DateNano", "Reserved2", "Reserved3", "Reserved4", "Reserved5", "Reserved6", "Reserved7", "Reserved8", "Reserved9", "Reserved10", "BoolVector", "ByteVector", "ShortVector", "CharVector", "IntVector", "LongVector", "FloatVector", "DoubleVector", "StringVector", "DateVector", "DateNanoVector", };
+  // Private to protect contents from getting modified.
+  private static final String[] names = { "Unknown", "Bool", "Byte", "Short", "Char", "Int", "Long", "Float", "Double", "String", "Date", "Relation", "DateNano", "Reserved2", "Reserved3", "Reserved4", "Reserved5", "Reserved6", "Reserved7", "Reserved8", "Reserved9", "Reserved10", "BoolVector", "ByteVector", "ShortVector", "CharVector", "IntVector", "LongVector", "FloatVector", "DoubleVector", "StringVector", "DateVector", "DateNanoVector", };
 
   public static String name(int e) { return names[e]; }
 }

File: objectbox-java/src/main/java/io/objectbox/query/OrderFlags.java
Patch:
@@ -46,7 +46,8 @@ private OrderFlags() { }
    */
   public static final int NULLS_ZERO = 16;
 
-  public static final String[] names = { "DESCENDING", "CASE_SENSITIVE", "", "UNSIGNED", "", "", "", "NULLS_LAST", "", "", "", "", "", "", "", "NULLS_ZERO", };
+  // Private to protect contents from getting modified.
+  private static final String[] names = { "DESCENDING", "CASE_SENSITIVE", "", "UNSIGNED", "", "", "", "NULLS_LAST", "", "", "", "", "", "", "", "NULLS_ZERO", };
 
   public static String name(int e) { return names[e - DESCENDING]; }
 }

File: objectbox-rxjava3/src/main/java/io/objectbox/rx/RxBoxStore.java
Patch:
@@ -28,7 +28,8 @@ public abstract class RxBoxStore {
      * Using the returned Observable, you can be notified about data changes.
      * Once a transaction is committed, you will get info on classes with changed Objects.
      */
-    public static <T> Observable<Class> observable(final BoxStore boxStore) {
+    @SuppressWarnings("rawtypes") // BoxStore observer may return any (entity) type.
+    public static Observable<Class> observable(BoxStore boxStore) {
         return Observable.create(emitter -> {
             final DataSubscription dataSubscription = boxStore.subscribe().observer(data -> {
                 if (!emitter.isDisposed()) {

File: objectbox-java-api/src/main/java/io/objectbox/annotation/DefaultValue.java
Patch:
@@ -14,5 +14,5 @@
 @Retention(RetentionPolicy.CLASS)
 @Target({ElementType.FIELD})
 public @interface DefaultValue {
-    String value() default "";
+    String value();
 }

File: objectbox-java/src/main/java/io/objectbox/query/Query.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 ObjectBox Ltd. All rights reserved.
+ * Copyright 2017-2020 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -267,8 +267,8 @@ public LazyList<T> findLazy() {
      *
      * @param property the property for which to return values
      */
-    public PropertyQuery<T> property(Property<T> property) {
-        return new PropertyQuery<>(this, property);
+    public PropertyQuery property(Property<T> property) {
+        return new PropertyQuery(this, property);
     }
 
     <R> R callInReadTx(Callable<R> callable) {

File: objectbox-java/src/main/java/io/objectbox/Transaction.java
Patch:
@@ -56,7 +56,7 @@ public class Transaction implements Closeable {
 
     native long nativeCreateKeyValueCursor(long transaction);
 
-    native long nativeCreateCursor(long transaction, String entityName, Class entityClass);
+    native long nativeCreateCursor(long transaction, String entityName, Class<?> entityClass);
 
     // native long nativeGetStore(long transaction);
 
@@ -180,7 +180,7 @@ public KeyValueCursor createKeyValueCursor() {
 
     public <T> Cursor<T> createCursor(Class<T> entityClass) {
         checkOpen();
-        EntityInfo entityInfo = store.getEntityInfo(entityClass);
+        EntityInfo<T> entityInfo = store.getEntityInfo(entityClass);
         CursorFactory<T> factory = entityInfo.getCursorFactory();
         long cursorHandle = nativeCreateCursor(transaction, entityInfo.getDbName(), entityClass);
         return factory.createCursor(this, cursorHandle, store);

File: objectbox-java/src/main/java/io/objectbox/internal/ReflectionCache.java
Patch:
@@ -32,10 +32,10 @@ public static ReflectionCache getInstance() {
         return instance;
     }
 
-    private final Map<Class, Map<String, Field>> fields = new HashMap<>();
+    private final Map<Class<?>, Map<String, Field>> fields = new HashMap<>();
 
     @Nonnull
-    public synchronized Field getField(Class clazz, String name) {
+    public synchronized Field getField(Class<?> clazz, String name) {
         Map<String, Field> fieldsForClass = fields.get(clazz);
         if (fieldsForClass == null) {
             fieldsForClass = new HashMap<>();

File: objectbox-java/src/main/java/io/objectbox/query/EagerRelation.java
Patch:
@@ -18,11 +18,11 @@
 
 import io.objectbox.relation.RelationInfo;
 
-class EagerRelation {
+class EagerRelation<S, T> {
     public final int limit;
-    public final RelationInfo relationInfo;
+    public final RelationInfo<S, T> relationInfo;
 
-    EagerRelation(int limit, RelationInfo relationInfo) {
+    EagerRelation(int limit, RelationInfo<S, T> relationInfo) {
         this.limit = limit;
         this.relationInfo = relationInfo;
     }

File: tests/objectbox-java-test/src/test/java/io/objectbox/BoxTest.java
Patch:
@@ -256,9 +256,9 @@ public void testTwoReaders() {
 
     @Test
     public void testCollectionsNull() {
-        box.put((Collection) null);
+        box.put((Collection<TestEntity>) null);
         box.put((TestEntity[]) null);
-        box.remove((Collection) null);
+        box.remove((Collection<TestEntity>) null);
         box.remove((long[]) null);
         box.removeByIds(null);
     }

File: tests/objectbox-java-test/src/test/java/io/objectbox/ObjectClassObserverTest.java
Patch:
@@ -38,6 +38,7 @@
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertTrue;
 
+@SuppressWarnings({"rawtypes", "unchecked"})
 public class ObjectClassObserverTest extends AbstractObjectBoxTest {
 
     protected BoxStore createBoxStore() {

File: tests/objectbox-java-test/src/test/java/io/objectbox/TestUtils.java
Patch:
@@ -56,6 +56,7 @@ public static InputStream openInputStream(String filename) throws FileNotFoundEx
         return in;
     }
 
+    @SuppressWarnings("unchecked")
     public static <T extends Serializable> T serializeDeserialize(T entity) throws IOException, ClassNotFoundException {
         ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
         ObjectOutputStream out = new ObjectOutputStream(bytesOut);

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/QueryTest.java
Patch:
@@ -59,7 +59,7 @@ public class QueryTest extends AbstractQueryTest {
 
     @Test
     public void testBuild() {
-        Query query = box.query().build();
+        Query<TestEntity> query = box.query().build();
         assertNotNull(query);
     }
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/RelationTest.java
Patch:
@@ -82,13 +82,13 @@ public void testRelationToMany_activeRelationshipChanges() {
         List<Order> orders = customer.getOrders();
         assertEquals(2, orders.size());
         orderBox.remove(order1);
-        ((ToMany) orders).reset();
+        ((ToMany<Order>) orders).reset();
         assertEquals(1, orders.size());
 
         order2.setCustomer(null);
         orderBox.put(order2);
 
-        ((ToMany) orders).reset();
+        ((ToMany<Order>) orders).reset();
         assertEquals(0, orders.size());
     }
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/ToManyTest.java
Patch:
@@ -335,7 +335,7 @@ public void testSet_Swap() {
     public void testSyncToTargetBox_detached() {
         Customer customer = new Customer();
         customer.setId(42);
-        ((ToMany) customer.orders).applyChangesToDb();
+        ((ToMany<Order>) customer.orders).applyChangesToDb();
     }
 
     @Test

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/ToOneTest.java
Patch:
@@ -45,7 +45,7 @@ public void testTargetId_regularTargetIdProperty() {
         assertEquals(1977, entity.getCustomerId());
     }
 
-    private RelationInfo<Order, Customer> getRelationInfo(Property targetIdProperty) {
+    private RelationInfo<Order, Customer> getRelationInfo(Property<Order> targetIdProperty) {
         return new RelationInfo<>(new Order_(), new Customer_(), targetIdProperty, null);
     }
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/ObjectClassObserverTest.java
Patch:
@@ -38,6 +38,7 @@
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertTrue;
 
+@SuppressWarnings({"rawtypes", "unchecked"})
 public class ObjectClassObserverTest extends AbstractObjectBoxTest {
 
     protected BoxStore createBoxStore() {

File: tests/objectbox-java-test/src/test/java/io/objectbox/TestUtils.java
Patch:
@@ -56,6 +56,7 @@ public static InputStream openInputStream(String filename) throws FileNotFoundEx
         return in;
     }
 
+    @SuppressWarnings("unchecked")
     public static <T extends Serializable> T serializeDeserialize(T entity) throws IOException, ClassNotFoundException {
         ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
         ObjectOutputStream out = new ObjectOutputStream(bytesOut);

File: tests/objectbox-java-test/src/test/java/io/objectbox/BoxTest.java
Patch:
@@ -256,9 +256,9 @@ public void testTwoReaders() {
 
     @Test
     public void testCollectionsNull() {
-        box.put((Collection) null);
+        box.put((Collection<TestEntity>) null);
         box.put((TestEntity[]) null);
-        box.remove((Collection) null);
+        box.remove((Collection<TestEntity>) null);
         box.remove((long[]) null);
         box.removeByIds(null);
     }

File: tests/objectbox-java-test/src/test/java/io/objectbox/query/QueryTest.java
Patch:
@@ -59,7 +59,7 @@ public class QueryTest extends AbstractQueryTest {
 
     @Test
     public void testBuild() {
-        Query query = box.query().build();
+        Query<TestEntity> query = box.query().build();
         assertNotNull(query);
     }
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/RelationTest.java
Patch:
@@ -82,13 +82,13 @@ public void testRelationToMany_activeRelationshipChanges() {
         List<Order> orders = customer.getOrders();
         assertEquals(2, orders.size());
         orderBox.remove(order1);
-        ((ToMany) orders).reset();
+        ((ToMany<Order>) orders).reset();
         assertEquals(1, orders.size());
 
         order2.setCustomer(null);
         orderBox.put(order2);
 
-        ((ToMany) orders).reset();
+        ((ToMany<Order>) orders).reset();
         assertEquals(0, orders.size());
     }
 

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/ToManyTest.java
Patch:
@@ -335,7 +335,7 @@ public void testSet_Swap() {
     public void testSyncToTargetBox_detached() {
         Customer customer = new Customer();
         customer.setId(42);
-        ((ToMany) customer.orders).applyChangesToDb();
+        ((ToMany<Order>) customer.orders).applyChangesToDb();
     }
 
     @Test

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -368,7 +368,7 @@ Class<?> getEntityClassOrThrow(int entityTypeId) {
         return clazz;
     }
 
-    @SuppressWarnings("unchecked") // Shortcut to implementing a Map<Class<? extends B>, B>.
+    @SuppressWarnings("unchecked") // Casting is easier than writing a custom Map.
     @Internal
     <T> EntityInfo<T> getEntityInfo(Class<T> entityClass) {
         return (EntityInfo<T>) propertiesByClass.get(entityClass);

File: objectbox-java/src/main/java/io/objectbox/query/EagerRelation.java
Patch:
@@ -18,11 +18,11 @@
 
 import io.objectbox.relation.RelationInfo;
 
-class EagerRelation {
+class EagerRelation<S, T> {
     public final int limit;
-    public final RelationInfo relationInfo;
+    public final RelationInfo<S, T> relationInfo;
 
-    EagerRelation(int limit, RelationInfo relationInfo) {
+    EagerRelation(int limit, RelationInfo<S, T> relationInfo) {
         this.limit = limit;
         this.relationInfo = relationInfo;
     }

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -98,7 +98,7 @@ enum Operator {
     private Operator combineNextWith = Operator.NONE;
 
     @Nullable
-    private List<EagerRelation> eagerRelations;
+    private List<EagerRelation<T, ?>> eagerRelations;
 
     @Nullable
     private QueryFilter<T> filter;
@@ -382,10 +382,10 @@ public QueryBuilder<T> eager(int limit, RelationInfo relationInfo, @Nullable Rel
         if (eagerRelations == null) {
             eagerRelations = new ArrayList<>();
         }
-        eagerRelations.add(new EagerRelation(limit, relationInfo));
+        eagerRelations.add(new EagerRelation<>(limit, relationInfo));
         if (more != null) {
             for (RelationInfo info : more) {
-                eagerRelations.add(new EagerRelation(limit, info));
+                eagerRelations.add(new EagerRelation<>(limit, info));
             }
         }
         return this;

File: objectbox-java/src/main/java/io/objectbox/relation/ToMany.java
Patch:
@@ -90,7 +90,7 @@ public class ToMany<TARGET> implements List<TARGET>, Serializable {
     transient private boolean removeFromTargetBox;
     transient private Comparator<TARGET> comparator;
 
-    public ToMany(Object sourceEntity, RelationInfo<? extends Object, TARGET> relationInfo) {
+    public ToMany(Object sourceEntity, RelationInfo<?, TARGET> relationInfo) {
         //noinspection ConstantConditions Annotation does not enforce non-null.
         if (sourceEntity == null) {
             throw new IllegalArgumentException("No source entity given (null)");
@@ -690,7 +690,7 @@ public boolean internalCheckApplyToDbRequired() {
 
     private boolean prepareToManyBacklinkEntitiesForDb(long entityId, IdGetter<TARGET> idGetter,
             @Nullable Map<TARGET, Boolean> setAdded, @Nullable Map<TARGET, Boolean> setRemoved) {
-        ToManyGetter backlinkToManyGetter = relationInfo.backlinkToManyGetter;
+        ToManyGetter<TARGET> backlinkToManyGetter = relationInfo.backlinkToManyGetter;
 
         synchronized (this) {
             if (setAdded != null && !setAdded.isEmpty()) {
@@ -734,7 +734,7 @@ private boolean prepareToManyBacklinkEntitiesForDb(long entityId, IdGetter<TARGE
 
     private boolean prepareToOneBacklinkEntitiesForDb(long entityId, IdGetter<TARGET> idGetter,
             @Nullable Map<TARGET, Boolean> setAdded, @Nullable Map<TARGET, Boolean> setRemoved) {
-        ToOneGetter backlinkToOneGetter = relationInfo.backlinkToOneGetter;
+        ToOneGetter<TARGET> backlinkToOneGetter = relationInfo.backlinkToOneGetter;
 
         synchronized (this) {
             if (setAdded != null && !setAdded.isEmpty()) {

File: objectbox-java/src/main/java/io/objectbox/Cursor.java
Patch:
@@ -50,7 +50,7 @@ public abstract class Cursor<T> implements Closeable {
 
     static native boolean nativeSeek(long cursor, long key);
 
-    native Object nativeGetAllEntities(long cursor);
+    native List<T> nativeGetAllEntities(long cursor);
 
     static native Object nativeGetEntity(long cursor, long key);
 
@@ -199,7 +199,7 @@ public T first() {
 
     /** ~10% slower than iterating with {@link #first()} and {@link #next()} as done by {@link Box#getAll()}. */
     public List<T> getAll() {
-        return (List) nativeGetAllEntities(cursor);
+        return nativeGetAllEntities(cursor);
     }
 
     public boolean deleteEntity(long key) {

File: objectbox-java/src/main/java/io/objectbox/Transaction.java
Patch:
@@ -56,7 +56,7 @@ public class Transaction implements Closeable {
 
     native long nativeCreateKeyValueCursor(long transaction);
 
-    native long nativeCreateCursor(long transaction, String entityName, Class entityClass);
+    native long nativeCreateCursor(long transaction, String entityName, Class<?> entityClass);
 
     // native long nativeGetStore(long transaction);
 

File: objectbox-java/src/main/java/io/objectbox/internal/ReflectionCache.java
Patch:
@@ -32,10 +32,10 @@ public static ReflectionCache getInstance() {
         return instance;
     }
 
-    private final Map<Class, Map<String, Field>> fields = new HashMap<>();
+    private final Map<Class<?>, Map<String, Field>> fields = new HashMap<>();
 
     @Nonnull
-    public synchronized Field getField(Class clazz, String name) {
+    public synchronized Field getField(Class<?> clazz, String name) {
         Map<String, Field> fieldsForClass = fields.get(clazz);
         if (fieldsForClass == null) {
             fieldsForClass = new HashMap<>();

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -90,7 +90,7 @@ public class BoxStoreBuilder {
 
     int queryAttempts;
 
-    TxCallback failedReadTxAttemptCallback;
+    TxCallback<?> failedReadTxAttemptCallback;
 
     final List<EntityInfo<?>> entityInfoList = new ArrayList<>();
     private Factory<InputStream> initialDbFileFactory;
@@ -345,7 +345,7 @@ public BoxStoreBuilder queryAttempts(int queryAttempts) {
      * Useful for e.g. logging.
      */
     @Experimental
-    public BoxStoreBuilder failedReadTxAttemptCallback(TxCallback failedReadTxAttemptCallback) {
+    public BoxStoreBuilder failedReadTxAttemptCallback(TxCallback<?> failedReadTxAttemptCallback) {
         this.failedReadTxAttemptCallback = failedReadTxAttemptCallback;
         return this;
     }

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -604,7 +604,7 @@ public Class<T> getEntityClass() {
     }
 
     @Internal
-    public List<T> internalGetBacklinkEntities(int entityId, Property relationIdProperty, long key) {
+    public List<T> internalGetBacklinkEntities(int entityId, Property<?> relationIdProperty, long key) {
         Cursor<T> reader = getReader();
         try {
             return reader.getBacklinkEntities(entityId, relationIdProperty, key);

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -220,7 +220,7 @@ public static boolean isObjectBrowserAvailable() {
                 entityTypeIdByClass.put(entityInfo.getEntityClass(), entityId);
                 classByEntityTypeId.put(entityId, entityInfo.getEntityClass());
                 propertiesByClass.put(entityInfo.getEntityClass(), entityInfo);
-                for (Property property : entityInfo.getAllProperties()) {
+                for (Property<?> property : entityInfo.getAllProperties()) {
                     if (property.customType != null) {
                         if (property.converterClass == null) {
                             throw new RuntimeException("No converter class for custom type of " + property);

File: objectbox-java/src/main/java/io/objectbox/relation/RelationInfo.java
Patch:
@@ -38,7 +38,7 @@ public class RelationInfo<SOURCE, TARGET> implements Serializable {
     public final EntityInfo<TARGET> targetInfo;
 
     /** For relations based on a target ID property (null otherwise). */
-    public final Property targetIdProperty;
+    public final Property<?> targetIdProperty;
 
     /** For ToMany relations based on ToMany backlinks (0 otherwise). */
     public final int targetRelationId;
@@ -61,7 +61,7 @@ public class RelationInfo<SOURCE, TARGET> implements Serializable {
     /**
      * ToOne
      */
-    public RelationInfo(EntityInfo<SOURCE> sourceInfo, EntityInfo<TARGET> targetInfo, Property targetIdProperty,
+    public RelationInfo(EntityInfo<SOURCE> sourceInfo, EntityInfo<TARGET> targetInfo, Property<SOURCE> targetIdProperty,
                         ToOneGetter toOneGetter) {
         this.sourceInfo = sourceInfo;
         this.targetInfo = targetInfo;
@@ -78,7 +78,7 @@ public RelationInfo(EntityInfo<SOURCE> sourceInfo, EntityInfo<TARGET> targetInfo
      * ToMany as a ToOne backlink
      */
     public RelationInfo(EntityInfo<SOURCE> sourceInfo, EntityInfo<TARGET> targetInfo, ToManyGetter toManyGetter,
-                        Property targetIdProperty, ToOneGetter backlinkToOneGetter) {
+                        Property<TARGET> targetIdProperty, ToOneGetter backlinkToOneGetter) {
         this.sourceInfo = sourceInfo;
         this.targetInfo = targetInfo;
         this.targetIdProperty = targetIdProperty;

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/ToOneTest.java
Patch:
@@ -45,7 +45,7 @@ public void testTargetId_regularTargetIdProperty() {
         assertEquals(1977, entity.getCustomerId());
     }
 
-    private RelationInfo<Order, Customer> getRelationInfo(Property targetIdProperty) {
+    private RelationInfo<Order, Customer> getRelationInfo(Property<Order> targetIdProperty) {
         return new RelationInfo<>(new Order_(), new Customer_(), targetIdProperty, null);
     }
 

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -56,7 +56,7 @@ public class Box<T> {
 
     private final IdGetter<T> idGetter;
 
-    private EntityInfo entityInfo;
+    private EntityInfo<T> entityInfo;
     private volatile Field boxStoreField;
 
     Box(BoxStore store, Class<T> entityClass) {
@@ -560,7 +560,7 @@ public BoxStore getStore() {
         return store;
     }
 
-    public synchronized EntityInfo getEntityInfo() {
+    public synchronized EntityInfo<T> getEntityInfo() {
         if (entityInfo == null) {
             Cursor<T> reader = getReader();
             try {

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -92,7 +92,7 @@ public class BoxStoreBuilder {
 
     TxCallback failedReadTxAttemptCallback;
 
-    final List<EntityInfo> entityInfoList = new ArrayList<>();
+    final List<EntityInfo<?>> entityInfoList = new ArrayList<>();
     private Factory<InputStream> initialDbFileFactory;
 
     /** Not for application use. */
@@ -274,7 +274,7 @@ public BoxStoreBuilder maxReaders(int maxReaders) {
     }
 
     @Internal
-    public void entity(EntityInfo entityInfo) {
+    public void entity(EntityInfo<?> entityInfo) {
         entityInfoList.add(entityInfo);
     }
 

File: objectbox-java/src/main/java/io/objectbox/Transaction.java
Patch:
@@ -180,7 +180,7 @@ public KeyValueCursor createKeyValueCursor() {
 
     public <T> Cursor<T> createCursor(Class<T> entityClass) {
         checkOpen();
-        EntityInfo entityInfo = store.getEntityInfo(entityClass);
+        EntityInfo<T> entityInfo = store.getEntityInfo(entityClass);
         CursorFactory<T> factory = entityInfo.getCursorFactory();
         long cursorHandle = nativeCreateCursor(transaction, entityInfo.getDbName(), entityClass);
         return factory.createCursor(this, cursorHandle, store);

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -325,12 +325,12 @@ public QueryBuilder<T> parameterAlias(String alias) {
      */
     public <TARGET> QueryBuilder<TARGET> link(RelationInfo<?, TARGET> relationInfo) {
         boolean backlink = relationInfo.isBacklink();
-        EntityInfo relationOwner = backlink ? relationInfo.targetInfo : relationInfo.sourceInfo;
+        EntityInfo<?> relationOwner = backlink ? relationInfo.targetInfo : relationInfo.sourceInfo;
         return link(relationInfo, relationOwner, relationInfo.targetInfo, backlink);
     }
 
-    private <TARGET> QueryBuilder<TARGET> link(RelationInfo relationInfo, EntityInfo relationOwner, EntityInfo target,
-                                               boolean backlink) {
+    private <TARGET> QueryBuilder<TARGET> link(RelationInfo<?, ?> relationInfo, EntityInfo<?> relationOwner,
+                                               EntityInfo<?> target, boolean backlink) {
         int propertyId = relationInfo.targetIdProperty != null ? relationInfo.targetIdProperty.id : 0;
         int relationId = relationInfo.targetRelationId != 0 ? relationInfo.targetRelationId : relationInfo.relationId;
         long linkQBHandle = nativeLink(handle, storeHandle, relationOwner.getEntityId(), target.getEntityId(),

File: objectbox-java/src/main/java/io/objectbox/relation/ToMany.java
Patch:
@@ -837,7 +837,7 @@ public void internalApplyToDb(Cursor sourceCursor, Cursor<TARGET> targetCursor)
                 removeStandaloneRelations(sourceCursor, entityId, removedStandalone, targetIdGetter);
             }
             if (addedStandalone != null) {
-                addStandaloneRelations(sourceCursor, entityId, addedStandalone, targetIdGetter, false);
+                addStandaloneRelations(sourceCursor, entityId, addedStandalone, targetIdGetter);
             }
         }
     }
@@ -866,7 +866,7 @@ private void removeStandaloneRelations(Cursor cursor, long sourceEntityId, List<
 
     /** The target array may not contain non-persisted entities. */
     private void addStandaloneRelations(Cursor cursor, long sourceEntityId, TARGET[] added,
-                                        IdGetter<TARGET> targetIdGetter, boolean remove) {
+                                        IdGetter<TARGET> targetIdGetter) {
         int length = added.length;
         long[] targetIds = new long[length];
         for (int i = 0; i < length; i++) {
@@ -877,7 +877,7 @@ private void addStandaloneRelations(Cursor cursor, long sourceEntityId, TARGET[]
             }
             targetIds[i] = targetId;
         }
-        cursor.modifyRelations(relationInfo.relationId, sourceEntityId, targetIds, remove);
+        cursor.modifyRelations(relationInfo.relationId, sourceEntityId, targetIds, false);
     }
 
     /** For tests */

File: objectbox-java-api/src/main/java/io/objectbox/annotation/NotNull.java
Patch:
@@ -30,5 +30,5 @@
  */
 @Retention(RetentionPolicy.CLASS)
 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
-/** TODO public */ @interface NotNull {
+/* TODO public */ @interface NotNull {
 }

File: objectbox-java-api/src/main/java/io/objectbox/annotation/OrderBy.java
Patch:
@@ -28,7 +28,7 @@
  */
 @Retention(RetentionPolicy.CLASS)
 @Target(ElementType.FIELD)
-/** TODO public */ @interface OrderBy {
+/* TODO public */ @interface OrderBy {
     /**
      * Comma-separated list of properties, e.g. "propertyA, propertyB, propertyC"
      * To specify direction, add ASC or DESC after property name, e.g.: "propertyA DESC, propertyB ASC"

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -19,7 +19,6 @@
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -443,8 +442,10 @@ public void remove(@Nullable long... ids) {
         }
     }
 
+    /**
+     * @deprecated use {@link #removeByIds(Collection)} instead.
+     */
     @Deprecated
-    /** @deprecated use {@link #removeByIds(Collection)} instead. */
     public void removeByKeys(@Nullable Collection<Long> ids) {
         removeByIds(ids);
     }

File: objectbox-java/src/main/java/io/objectbox/Factory.java
Patch:
@@ -19,10 +19,10 @@
 import io.objectbox.annotation.apihint.Experimental;
 
 
-@Experimental
 /**
  * Generic Factory that provides a resource on demand (if and when it is required).
  */
+@Experimental
 public interface Factory<T> {
     T provide() throws Exception;
 }

File: objectbox-java/src/main/java/io/objectbox/model/IdUid.java
Patch:
@@ -23,10 +23,10 @@
 import java.util.*;
 import com.google.flatbuffers.*;
 
-@SuppressWarnings("unused")
 /**
  * ID tuple: besides the main ID there is also a UID for verification
  */
+@SuppressWarnings("unused")
 public final class IdUid extends Struct {
   public void __init(int _i, ByteBuffer _bb) { bb_pos = _i; bb = _bb; }
   public IdUid __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

File: objectbox-java/src/main/java/io/objectbox/model/Model.java
Patch:
@@ -23,13 +23,13 @@
 import java.util.*;
 import com.google.flatbuffers.*;
 
-@SuppressWarnings("unused")
 /**
  * A model describes all entities and other meta data.
  * The current model of an app is synced against ObjectBox's persisted schema.
  * The model itself is not persisted, and thus may change as long as both ends are consistent (Java and native).
  * There could be multiple models/schemas (one dbi per schema) in the future.
  */
+@SuppressWarnings("unused")
 public final class Model extends Table {
   public static Model getRootAsModel(ByteBuffer _bb) { return getRootAsModel(_bb, new Model()); }
   public static Model getRootAsModel(ByteBuffer _bb, Model obj) { Constants.FLATBUFFERS_1_11_1(); _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }

File: objectbox-java/src/main/java/io/objectbox/model/PropertyFlags.java
Patch:
@@ -73,11 +73,11 @@ private PropertyFlags() { }
   public static final int INDEX_HASH = 2048;
   /**
    * Index uses a 64 bit hash instead of the value
-   * (recommended mostly for 64 bit machines with values longer >200 bytes; small values are faster with a 32 bit hash)
+   * (recommended mostly for 64 bit machines with values longer than 200 bytes; small values are faster with a 32 bit hash)
    */
   public static final int INDEX_HASH64 = 4096;
   /**
-   * Unused yet: While our default are signed ints, queries & indexes need do know signing info.
+   * Unused yet: While our default are signed ints, queries and indexes need do know signing info.
    * Note: Don't combine with ID (IDs are always unsigned internally).
    */
   public static final int UNSIGNED = 8192;

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -623,7 +623,7 @@ public long[] getRelationIds(RelationInfo relationInfo, long id) {
     }
 
     public long[] getRelationBacklinkIds(RelationInfo relationInfo, long id) {
-        return internalGetRelationIds(relationInfo.targetInfo.getEntityId(), relationInfo.relationId, id, true);
+        return internalGetRelationIds(relationInfo.sourceInfo.getEntityId(), relationInfo.relationId, id, true);
     }
 
     @Internal

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -615,7 +615,7 @@ public List<T> getRelationEntities(RelationInfo relationInfo, long id) {
     }
 
     public List<T> getRelationBacklinkEntities(RelationInfo relationInfo, long id) {
-        return internalGetRelationEntities(relationInfo.targetInfo.getEntityId(), relationInfo.relationId, id, true);
+        return internalGetRelationEntities(relationInfo.sourceInfo.getEntityId(), relationInfo.relationId, id, true);
     }
 
     public long[] getRelationIds(RelationInfo relationInfo, long id) {

File: objectbox-java/src/main/java/io/objectbox/internal/NativeLibraryLoader.java
Patch:
@@ -82,7 +82,7 @@ public class NativeLibraryLoader {
                     System.err.println("File not available: " + file.getAbsolutePath());
                 }
                 try {
-                    if (!android || !loadLibraryAndroid(libname)) {
+                    if (!android || !loadLibraryAndroid(libname)) { // if android && loadLibraryAndroid OK: done
                         System.loadLibrary(libname);
                     }
                 } catch (UnsatisfiedLinkError e) {
@@ -101,7 +101,7 @@ public class NativeLibraryLoader {
                     "Loading ObjectBox native library failed: vendor=%s,os=%s,arch=%s,android=%s,linux=%s",
                     vendor, osName, sunArch, android, isLinux
             );
-            throw new RuntimeException(message, e);
+            throw new LinkageError(message, e); // UnsatisfiedLinkError does not allow a cause; use its super class
         }
     }
 

File: objectbox-java/src/main/java/io/objectbox/sync/SyncCredentialsImpl.java
Patch:
@@ -3,9 +3,9 @@
 class SyncCredentialsImpl extends SyncCredentials {
 
     private final String token;
-    private final AuthenticationType type;
+    private final CredentialsType type;
 
-    SyncCredentialsImpl(String token, AuthenticationType type) {
+    SyncCredentialsImpl(String token, CredentialsType type) {
         this.token = token;
         this.type = type;
     }
@@ -14,7 +14,7 @@ public String getToken() {
         return token;
     }
 
-    public String getTypeId() {
+    public int getTypeId() {
         return type.id;
     }
 }

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -26,6 +26,7 @@
 import java.io.FileOutputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
@@ -198,7 +199,8 @@ public BoxStoreBuilder androidContext(Object context) {
     private Object getApplicationContext(Object context) {
         try {
             return context.getClass().getMethod("getApplicationContext").invoke(context);
-        } catch (ReflectiveOperationException e) {
+        } catch (Exception e) {
+            // note: can't catch ReflectiveOperationException, is K+ (19+) on Android
             throw new RuntimeException("context must be a valid Android Context", e);
         }
     }

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -26,6 +26,7 @@
 import java.io.FileOutputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
@@ -198,7 +199,8 @@ public BoxStoreBuilder androidContext(Object context) {
     private Object getApplicationContext(Object context) {
         try {
             return context.getClass().getMethod("getApplicationContext").invoke(context);
-        } catch (ReflectiveOperationException e) {
+        } catch (Exception e) {
+            // note: can't catch ReflectiveOperationException, is K+ (19+) on Android
             throw new RuntimeException("context must be a valid Android Context", e);
         }
     }

File: objectbox-java-api/src/main/java/io/objectbox/converter/PropertyConverter.java
Patch:
@@ -23,6 +23,8 @@
  * <ul>
  * <li>Converters are created by the default constructor</li>
  * <li>Converters must be implemented thread-safe</li>
+ * <li>Converters must not interact with the database (such as using Box or BoxStore)</li>
+ * <li>Converters must handle null values</li>
  * </ul>
  */
 public interface PropertyConverter<P, D> {

File: objectbox-java/src/main/java/io/objectbox/relation/ToOne.java
Patch:
@@ -79,7 +79,7 @@ public ToOne(Object sourceEntity, RelationInfo relationInfo) {
         }
         this.entity = sourceEntity;
         this.relationInfo = relationInfo;
-        virtualProperty = relationInfo.targetIdProperty == null;
+        virtualProperty = relationInfo.targetIdProperty.isVirtual;
     }
 
     /**

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -323,8 +323,9 @@ public <TARGET> QueryBuilder<TARGET> link(RelationInfo<?, TARGET> relationInfo)
     private <TARGET> QueryBuilder<TARGET> link(RelationInfo relationInfo, EntityInfo relationOwner, EntityInfo target,
                                                boolean backlink) {
         int propertyId = relationInfo.targetIdProperty != null ? relationInfo.targetIdProperty.id : 0;
+        int relationId = relationInfo.targetRelationId != 0 ? relationInfo.targetRelationId : relationInfo.relationId;
         long linkQBHandle = nativeLink(handle, storeHandle, relationOwner.getEntityId(), target.getEntityId(),
-                propertyId, relationInfo.relationId, backlink);
+                propertyId, relationId, backlink);
         return new QueryBuilder<>(storeHandle, linkQBHandle);
     }
 

File: objectbox-java/src/main/java/io/objectbox/relation/ToOne.java
Patch:
@@ -112,7 +112,6 @@ private void ensureBoxes(TARGET target) {
             Field boxStoreField = ReflectionCache.getInstance().getField(entity.getClass(), "__boxStore");
             try {
                 boxStore = (BoxStore) boxStoreField.get(entity);
-                debugRelations = boxStore.isDebugRelations();
                 if (boxStore == null) {
                     if (target != null) {
                         boxStoreField = ReflectionCache.getInstance().getField(target.getClass(), "__boxStore");
@@ -123,6 +122,7 @@ private void ensureBoxes(TARGET target) {
                                 "call box.attach(entity) beforehand.");
                     }
                 }
+                debugRelations = boxStore.isDebugRelations();
             } catch (IllegalAccessException e) {
                 throw new RuntimeException(e);
             }

File: objectbox-java/src/main/java/io/objectbox/relation/ToOne.java
Patch:
@@ -119,7 +119,8 @@ private void ensureBoxes(TARGET target) {
                         boxStore = (BoxStore) boxStoreField.get(target);
                     }
                     if (boxStore == null) {
-                        throw new DbDetachedException("Cannot resolve relation for detached entities");
+                        throw new DbDetachedException("Cannot resolve relation for detached entities, " +
+                                "call box.attach(entity) beforehand.");
                     }
                 }
             } catch (IllegalAccessException e) {

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -45,6 +45,7 @@
  */
 @Beta
 @ThreadSafe
+@SuppressWarnings("WeakerAccess,UnusedReturnValue,unused")
 public class Box<T> {
     private final BoxStore store;
     private final Class<T> entityClass;
@@ -427,7 +428,7 @@ public void remove(long id) {
     /**
      * Removes (deletes) Objects by their ID in a single transaction.
      */
-    public void remove(long... ids) {
+    public void remove(@Nullable long... ids) {
         if (ids == null || ids.length == 0) {
             return;
         }

File: objectbox-java/src/main/java/io/objectbox/Cursor.java
Patch:
@@ -27,7 +27,7 @@
 import io.objectbox.annotation.apihint.Temporary;
 import io.objectbox.relation.ToMany;
 
-@SuppressWarnings({"unchecked", "SameParameterValue", "unused"})
+@SuppressWarnings({"unchecked", "SameParameterValue", "unused", "WeakerAccess", "UnusedReturnValue"})
 @Beta
 @Internal
 @NotThreadSafe

File: objectbox-java/src/main/java/io/objectbox/KeyValueCursor.java
Patch:
@@ -21,6 +21,7 @@
 import javax.annotation.concurrent.NotThreadSafe;
 
 @NotThreadSafe
+@SuppressWarnings("WeakerAccess,UnusedReturnValue, unused")
 public class KeyValueCursor implements Closeable {
     private static final int PUT_FLAG_FIRST = 1;
     private static final int PUT_FLAG_COMPLETE = 1 << 1;

File: objectbox-java/src/main/java/io/objectbox/Transaction.java
Patch:
@@ -26,6 +26,7 @@
 
 @Internal
 @NotThreadSafe
+@SuppressWarnings("WeakerAccess,UnusedReturnValue,unused")
 public class Transaction implements Closeable {
     /** May be set by tests */
     @Internal

File: objectbox-java/src/main/java/io/objectbox/query/QueryCondition.java
Patch:
@@ -49,7 +49,7 @@ abstract class AbstractCondition implements QueryCondition {
             this.values = null;
         }
 
-        AbstractCondition(Object[] values) {
+        AbstractCondition(@Nullable Object[] values) {
             this.value = null;
             this.values = values;
         }
@@ -75,13 +75,13 @@ public enum Operation {
         public final Property property;
         private final Operation operation;
 
-        public PropertyCondition(Property property, Operation operation, Object value) {
+        public PropertyCondition(Property property, Operation operation, @Nullable Object value) {
             super(checkValueForType(property, value));
             this.property = property;
             this.operation = operation;
         }
 
-        public PropertyCondition(Property property, Operation operation, Object[] values) {
+        public PropertyCondition(Property property, Operation operation, @Nullable Object[] values) {
             super(checkValuesForType(property, operation, values));
             this.property = property;
             this.operation = operation;

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -285,7 +285,7 @@ public QueryBuilder<T> sort(Comparator<T> comparator) {
      * @param <TARGET>     The target entity. For parent/tree like relations, it can be the same type.
      * @return A builder to define query conditions at the target entity side.
      */
-    public <TARGET> QueryBuilder<TARGET> link(RelationInfo<TARGET> relationInfo) {
+    public <TARGET> QueryBuilder<TARGET> link(RelationInfo<?, TARGET> relationInfo) {
         boolean backlink = relationInfo.isBacklink();
         EntityInfo relationOwner = backlink ? relationInfo.targetInfo : relationInfo.sourceInfo;
         return link(relationInfo, relationOwner, relationInfo.targetInfo, backlink);
@@ -312,7 +312,7 @@ private <TARGET> QueryBuilder<TARGET> link(RelationInfo relationInfo, EntityInfo
      * @param <TARGET>     The target entity. For parent/tree like relations, it can be the same type.
      * @return A builder to define query conditions at the target entity side.
      */
-    public <TARGET> QueryBuilder<TARGET> backlink(RelationInfo relationInfo) {
+    public <TARGET> QueryBuilder<TARGET> backlink(RelationInfo<TARGET, ?> relationInfo) {
         if (relationInfo.isBacklink()) {
             throw new IllegalArgumentException("Double backlink: The relation is already a backlink, please use a regular link on the original relation instead.");
         }

File: objectbox-java/src/main/java/io/objectbox/relation/ToMany.java
Patch:
@@ -67,7 +67,7 @@ public class ToMany<TARGET> implements List<TARGET>, Serializable {
     private final static Integer ONE = Integer.valueOf(1);
 
     private final Object entity;
-    private final RelationInfo<TARGET> relationInfo;
+    private final RelationInfo<Object, TARGET> relationInfo;
 
     private ListFactory listFactory;
     private List<TARGET> entities;
@@ -90,15 +90,15 @@ public class ToMany<TARGET> implements List<TARGET>, Serializable {
     transient private boolean removeFromTargetBox;
     transient private Comparator<TARGET> comparator;
 
-    public ToMany(Object sourceEntity, RelationInfo<TARGET> relationInfo) {
+    public ToMany(Object sourceEntity, RelationInfo<? extends Object, TARGET> relationInfo) {
         if (sourceEntity == null) {
             throw new IllegalArgumentException("No source entity given (null)");
         }
         if (relationInfo == null) {
             throw new IllegalArgumentException("No relation info given (null)");
         }
         this.entity = sourceEntity;
-        this.relationInfo = relationInfo;
+        this.relationInfo = (RelationInfo<Object, TARGET>) relationInfo;
     }
 
     /** Currently only used for non-persisted entities (id == 0). */

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/Customer_.java
Patch:
@@ -105,7 +105,7 @@ public long getId(Customer object) {
         }
     }
 
-    static final RelationInfo<Order> orders =
+    static final RelationInfo<Customer, Order> orders =
             new RelationInfo<>(Customer_.__INSTANCE, Order_.__INSTANCE, new ToManyGetter<Customer>() {
                 @Override
                 public ToMany<Order> getToMany(Customer customer) {
@@ -118,7 +118,7 @@ public ToOne<Customer> getToOne(Order order) {
                 }
             });
 
-    static final RelationInfo<Order> ordersStandalone =
+    static final RelationInfo<Customer, Order> ordersStandalone =
             new RelationInfo<>(Customer_.__INSTANCE, Order_.__INSTANCE, new ToManyGetter<Customer>() {
                 @Override
                 public ToMany<Order> getToMany(Customer customer) {

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/Order_.java
Patch:
@@ -114,7 +114,7 @@ public long getId(Order object) {
         }
     }
 
-    static final RelationInfo<Customer> customer = new RelationInfo<>(Order_.__INSTANCE, Customer_.__INSTANCE, customerId, new ToOneGetter<Order>() {
+    static final RelationInfo<Order, Customer> customer = new RelationInfo<>(Order_.__INSTANCE, Customer_.__INSTANCE, customerId, new ToOneGetter<Order>() {
         @Override
         public ToOne getToOne(Order object) {
             return object.customer__toOne;

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/ToManyStandaloneTest.java
Patch:
@@ -42,7 +42,7 @@ public void testPutAndGetPrimitives() {
         Cursor<Customer> cursorSource = InternalAccess.getWriter(customerBox);
         long[] orderIds = {order1.getId(), order2.getId()};
         cursorSource.modifyRelations(1, customerId, orderIds, false);
-        RelationInfo<Order> info = Customer_.ordersStandalone;
+        RelationInfo<Customer, Order> info = Customer_.ordersStandalone;
         int sourceEntityId = info.sourceInfo.getEntityId();
         Cursor<Order> targetCursor = cursorSource.getTx().createCursor(Order.class);
         List<Order> related = targetCursor.getRelationEntities(sourceEntityId, info.relationId, customerId, false);

File: tests/objectbox-java-test/src/test/java/io/objectbox/relation/ToOneTest.java
Patch:
@@ -45,7 +45,7 @@ public void testTargetId_withTargetIdProperty() {
         assertEquals(1977, entity.getCustomerId());
     }
 
-    private RelationInfo<Customer> getRelationInfo(Property targetIdProperty) {
+    private RelationInfo<Order, Customer> getRelationInfo(Property targetIdProperty) {
         return new RelationInfo<>(new Order_(), new Customer_(), targetIdProperty, null);
     }
 

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -294,8 +294,8 @@ public <TARGET> QueryBuilder<TARGET> link(RelationInfo<TARGET> relationInfo) {
     private <TARGET> QueryBuilder<TARGET> link(RelationInfo relationInfo, EntityInfo relationOwner, EntityInfo target,
                                                boolean backlink) {
         int propertyId = relationInfo.targetIdProperty != null ? relationInfo.targetIdProperty.id : 0;
-        long linkQBHandle = nativeLink(handle, storeHandle, relationOwner.getEntityId(), target.getEntityId(), propertyId,
-                relationInfo.relationId, relationInfo.isBacklink());
+        long linkQBHandle = nativeLink(handle, storeHandle, relationOwner.getEntityId(), target.getEntityId(),
+                propertyId, relationInfo.relationId, backlink);
         return new QueryBuilder<>(storeHandle, linkQBHandle);
     }
 

File: objectbox-java/src/main/java/io/objectbox/relation/ToMany.java
Patch:
@@ -141,7 +141,8 @@ private void ensureBoxes() {
             try {
                 boxStore = (BoxStore) boxStoreField.get(entity);
                 if (boxStore == null) {
-                    throw new DbDetachedException("Cannot resolve relation for detached entities");
+                    throw new DbDetachedException("Cannot resolve relation for detached entities, " +
+                            "call box.attach(entity) beforehand.");
                 }
             } catch (IllegalAccessException e) {
                 throw new RuntimeException(e);

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -178,7 +178,7 @@ public BoxStoreBuilder androidContext(Object context) {
         return this;
     }
 
-    static File getAndroidDbDir(Object context, String dbName) {
+    static File getAndroidDbDir(Object context, @Nullable String dbName) {
         File baseDir = getAndroidBaseDir(context);
         return new File(baseDir, dbName(dbName));
     }

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/AbstractRelationTest.java
Patch:
@@ -61,6 +61,7 @@ protected Customer putCustomer() {
 
     protected Order putOrder(@Nullable Customer customer, @Nullable String text) {
         Order order = new Order();
+        order.setCustomer(customer);
         order.setText(text);
         orderBox.put(order);
         return order;

File: tests/objectbox-java-test/src/main/java/io/objectbox/query/PropertyQueryTest.java
Patch:
@@ -29,6 +29,7 @@
 import io.objectbox.DebugFlags;
 import io.objectbox.TestEntity;
 import io.objectbox.TestEntityCursor;
+import io.objectbox.exception.DbException;
 import io.objectbox.query.QueryBuilder.StringOrder;
 
 import static io.objectbox.TestEntity_.*;
@@ -159,7 +160,7 @@ public void testFindLong() {
         assertEquals(1005, (long) query.property(simpleLong).distinct().findUniqueLong());
     }
 
-    @Test()
+    @Test(expected = DbException.class)
     public void testFindLong_uniqueFails() {
         putTestEntity(null, 1);
         putTestEntity(null, 1);
@@ -177,7 +178,7 @@ public void testFindInt() {
         assertEquals(5, (long) query.property(simpleInt).distinct().findUniqueInt());
     }
 
-    @Test()
+    @Test(expected = DbException.class)
     public void testFindInt_uniqueFails() {
         putTestEntity(null, 1);
         putTestEntity(null, 1);

File: tests/objectbox-java-test/src/main/java/io/objectbox/query/QueryPropertiesTest.java
Patch:
@@ -84,7 +84,7 @@ public void testFindStrings() {
     @Test(expected = IllegalArgumentException.class)
     public void testFindStrings_wrongPropertyType() {
         putTestEntitiesStrings();
-        box.query().build().findStrings(simpleInt);
+        box.query().build().property(simpleInt).findStrings();
     }
 
     private List<TestEntity> putTestEntitiesScalars() {

File: objectbox-java/src/main/java/io/objectbox/DebugFlags.java
Patch:
@@ -10,8 +10,9 @@ private DebugFlags() { }
   public static final int LOG_TRANSACTIONS_READ = 1;
   public static final int LOG_TRANSACTIONS_WRITE = 2;
   public static final int LOG_QUERIES = 4;
+  public static final int LOG_QUERY_PARAMETERS = 8;
 
-  public static final String[] names = { "LOG_TRANSACTIONS_READ", "LOG_TRANSACTIONS_WRITE", "", "LOG_QUERIES", };
+  public static final String[] names = { "LOG_TRANSACTIONS_READ", "LOG_TRANSACTIONS_WRITE", "", "LOG_QUERIES", "", "", "", "LOG_QUERY_PARAMETERS", };
 
   public static String name(int e) { return names[e - LOG_TRANSACTIONS_READ]; }
 }

File: tests/objectbox-java-test/src/main/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -29,12 +29,9 @@
 
 import io.objectbox.ModelBuilder.EntityBuilder;
 import io.objectbox.ModelBuilder.PropertyBuilder;
-import io.objectbox.internal.CursorFactory;
-import io.objectbox.internal.IdGetter;
 import io.objectbox.model.PropertyFlags;
 import io.objectbox.model.PropertyType;
 
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -52,6 +49,9 @@ public abstract class AbstractObjectBoxTest {
 
     @Before
     public void setUp() throws IOException {
+        Cursor.TRACK_CREATION_STACK = true;
+        Transaction.TRACK_CREATION_STACK = true;
+
         // This works with Android without needing any context
         File tempFile = File.createTempFile("object-store-test", "");
         tempFile.delete();

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -193,6 +193,8 @@ public static String getVersion() {
             nativeSetDebugFlags(handle, debugFlags);
             debugTxRead = (debugFlags & DebugFlags.LOG_TRANSACTIONS_READ) != 0;
             debugTxWrite = (debugFlags & DebugFlags.LOG_TRANSACTIONS_WRITE) != 0;
+        } else {
+            debugTxRead = debugTxWrite = false;
         }
         debugRelations = builder.debugRelations;
 

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -133,7 +133,7 @@ static native void nativeRegisterCustomType(long store, int entityId, int proper
 
     static native String nativeStartObjectBrowser(long store, String urlPath, int port);
 
-    static native String nativeSetDebugFlags(long store, int debugFlags);
+    static native void nativeSetDebugFlags(long store, int debugFlags);
 
     public static native boolean isObjectBrowserAvailable();
 

File: objectbox-java-api/src/main/java/io/objectbox/annotation/apihint/Beta.java
Patch:
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2017 Markus Junginger
+ * Copyright 2017 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: objectbox-java-api/src/main/java/io/objectbox/annotation/apihint/Experimental.java
Patch:
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2017 Markus Junginger
+ * Copyright 2017 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: objectbox-java-api/src/main/java/io/objectbox/annotation/apihint/Internal.java
Patch:
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2017 Markus Junginger
+ * Copyright 2017 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: objectbox-java-api/src/main/java/io/objectbox/annotation/apihint/Temporary.java
Patch:
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2017 Markus Junginger
+ * Copyright 2017 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: objectbox-java-api/src/main/java/io/objectbox/converter/PropertyConverter.java
Patch:
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2016 Markus Junginger
+ * Copyright 2017 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: objectbox-java/src/main/java/io/objectbox/Property.java
Patch:
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2017 Markus Junginger
+ * Copyright 2017 ObjectBox Ltd. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: objectbox-java/src/main/java/io/objectbox/ModelBuilder.java
Patch:
@@ -152,12 +152,12 @@ public EntityBuilder relation(String name, int relationId, long relationUid, int
             checkFinishProperty();
 
             int propertyNameOffset = fbb.createString(name);
-            int relationIdOffset = IdUid.createIdUid(fbb, relationId, relationUid);
-            int targetEntityIdOffset = IdUid.createIdUid(fbb, targetEntityId, targetEntityUid);
 
             ModelRelation.startModelRelation(fbb);
             ModelRelation.addName(fbb, propertyNameOffset);
+            int relationIdOffset = IdUid.createIdUid(fbb, relationId, relationUid);
             ModelRelation.addId(fbb, relationIdOffset);
+            int targetEntityIdOffset = IdUid.createIdUid(fbb, targetEntityId, targetEntityUid);
             ModelRelation.addTargetEntityId(fbb, targetEntityIdOffset);
             relationOffsets.add(ModelRelation.endModelRelation(fbb));
 

File: objectbox-java/src/main/java/io/objectbox/relation/ToMany.java
Patch:
@@ -151,7 +151,7 @@ private void ensureEntities() {
                 List<TARGET> newEntities;
                 int relationId = relationInfo.relationId;
                 if (relationId != 0) {
-                    newEntities = targetBox.internalGetRelationEntities(relationId, id);
+                    newEntities = entityBox.internalGetRelationEntities(relationId, id);
                 } else {
                     newEntities = targetBox.internalGetBacklinkEntities(relationInfo.targetInfo.getEntityId(),
                             relationInfo.targetIdProperty, id);

File: objectbox-java/src/main/java/io/objectbox/relation/ToOne.java
Patch:
@@ -210,6 +210,8 @@ public void run() {
 
     /** Both values should be set (and read) "atomically" using synchronized. */
     private synchronized void setResolvedTarget(@Nullable TARGET target, long targetId) {
+        // FIXME temp debug log
+        System.out.println("Setting resolved ToOne target to " + (target == null ? "null" : "non-null") + " for ID " + targetId);
         resolvedTargetId = targetId;
         this.target = target;
     }

File: objectbox-java/src/main/java/io/objectbox/exception/DbMaxReadersExceededException.java
Patch:
@@ -11,4 +11,7 @@ public DbMaxReadersExceededException(String message) {
         super(message);
     }
 
+    public DbMaxReadersExceededException(String message, int errorCode) {
+        super(message, errorCode);
+    }
 }

File: objectbox-java/src/main/java/io/objectbox/internal/NativeLibraryLoader.java
Patch:
@@ -27,14 +27,15 @@ public class NativeLibraryLoader {
             if (osName.contains("Windows")) {
                 libname += "-windows" + ("32".equals(sunArch) ? "-x86" : "-x64");
                 filename = libname + ".dll";
-                checkUnpackLib(filename);
+                //checkUnpackLib(filename);
             } else if (osName.contains("Linux")) {
                 libname += "-linux" + ("32".equals(sunArch) ? "-x86" : "-x64");
                 filename = "lib" + libname + ".so";
-                checkUnpackLib(filename);
+                //checkUnpackLib(filename);
             }
         }
         File file = new File(filename);
+        System.err.println("Checking file: " + file.getAbsolutePath());
         if (file.exists()) {
             System.load(file.getAbsolutePath());
         } else {

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -46,7 +46,7 @@ public class Box<T> {
         debugTx = store.debugTx;
     }
 
-    private Cursor<T> getReader() {
+    Cursor<T> getReader() {
         Cursor<T> cursor = getActiveTxCursor();
         if (cursor != null) {
             return cursor;
@@ -121,7 +121,7 @@ private void releaseWriter(Cursor<T> cursor) {
         }
     }
 
-    private void releaseReader(Cursor<T> cursor) {
+    void releaseReader(Cursor<T> cursor) {
         // NOP if TX is ongoing
         if (activeTxCursor.get() == null) {
             Transaction tx = cursor.getTx();

File: objectbox-java/src/main/java/com/google/flatbuffers/Table.java
Patch:
@@ -43,7 +43,7 @@ protected Charset initialValue() {
       return Charset.forName("UTF-8");
     }
   };
-  private final static ThreadLocal<CharBuffer> CHAR_BUFFER = new ThreadLocal<CharBuffer>();
+  private final static ThreadLocal<CharBuffer> CHAR_BUFFER = new ThreadLocal<>();
   /** Used to hold the position of the `bb` buffer. */
   protected int bb_pos;
   /** The underlying ByteBuffer to hold the data of the Table. */

File: objectbox-java/src/main/java/io/objectbox/BoxStoreBuilder.java
Patch:
@@ -47,7 +47,7 @@ static class EntityClasses<T> {
 
     boolean debugTransactions;
 
-    List<EntityClasses> entityClasses = new ArrayList<>();
+    final List<EntityClasses> entityClasses = new ArrayList<>();
 
     public BoxStoreBuilder(byte[] model) {
         this.model = model;

File: objectbox-java/src/main/java/io/objectbox/internal/CrashReportLogger.java
Patch:
@@ -2,10 +2,10 @@
 
 import io.objectbox.annotation.apihint.Internal;
 
-@Internal
 /**
  * Give native code the chance to add additional info for tools like Crashlytics.
  */
+@Internal
 public interface CrashReportLogger {
     void log(String message);
 }

File: objectbox-java/src/main/java/io/objectbox/internal/ReflectionCache.java
Patch:
@@ -8,13 +8,13 @@
 
 @Internal
 public class ReflectionCache {
-    private static ReflectionCache instance = new ReflectionCache();
+    private static final ReflectionCache instance = new ReflectionCache();
 
     public static ReflectionCache getInstance() {
         return instance;
     }
 
-    private Map<Class, Map<String, Field>> fields = new HashMap<>();
+    private final Map<Class, Map<String, Field>> fields = new HashMap<>();
 
     public synchronized Field getField(Class clazz, String name) {
         Map<String, Field> fieldsForClass = fields.get(clazz);

File: objectbox-java/src/main/java/io/objectbox/query/Query.java
Patch:
@@ -20,7 +20,7 @@
 @Beta
 public class Query<T> {
 
-    static native long nativeDestroy(long handle);
+    static native void nativeDestroy(long handle);
 
     native static Object nativeFindFirst(long handle, long cursorHandle);
 
@@ -69,7 +69,7 @@ native static void nativeSetParameters(long handle, int propertyId, String param
         this.box = box;
         handle = queryHandle;
         this.hasOrder = hasOrder;
-        publisher = new QueryPublisher<T>(this, box);
+        publisher = new QueryPublisher<>(this, box);
     }
 
     @Override

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -73,7 +73,7 @@ enum Operator {
 
     private static native long nativeCreate(long storeHandle, String entityName);
 
-    private static native long nativeDestroy(long handle);
+    private static native void nativeDestroy(long handle);
 
     private static native long nativeBuild(long handle);
 
@@ -152,7 +152,7 @@ public Query<T> build() {
             throw new IllegalStateException("Incomplete logic condition. Use or()/and() between two conditions only.");
         }
         long queryHandle = nativeBuild(handle);
-        Query<T> query = new Query<T>(box, queryHandle, hasOrder);
+        Query<T> query = new Query<>(box, queryHandle, hasOrder);
         close();
         return query;
     }

File: objectbox-java/src/main/java/io/objectbox/reactive/SubscriptionBuilder.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The data type the {@link DataObserver} subscribes to.
  */
 public class SubscriptionBuilder<T> {
-    private DataPublisher<T> publisher;
+    private final DataPublisher<T> publisher;
     private final Object publisherParam;
     private final ExecutorService threadPool;
     private DataObserver<T> observer;

File: tests/objectbox-java-test/src/main/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -71,7 +71,7 @@ public String getDbName() {
             }
 
             @Override
-            public IdGetter getIdGetter() {
+            public IdGetter<TestEntityMinimal> getIdGetter() {
                 return new IdGetter<TestEntityMinimal>() {
                     @Override
                     public long getId(TestEntityMinimal object) {

File: tests/objectbox-java-test/src/main/java/io/objectbox/CursorTest.java
Patch:
@@ -1,7 +1,5 @@
 package io.objectbox;
 
-import io.objectbox.exception.DbException;
-
 import org.junit.Test;
 
 import java.io.IOException;
@@ -16,7 +14,6 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 public class CursorTest extends AbstractObjectBoxTest {
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/TestUtils.java
Patch:
@@ -9,9 +9,6 @@
 import org.greenrobot.essentials.io.FileUtils;
 import org.greenrobot.essentials.io.IoUtils;
 
-/**
- * Created by markus.
- */
 public class TestUtils {
     public static String loadFile(String filename) {
         String json;

File: tests/objectbox-java-test/src/main/java/io/objectbox/index/model/EntityLongIndexCursor.java
Patch:
@@ -4,7 +4,6 @@
 import io.objectbox.Cursor;
 import io.objectbox.Properties;
 import io.objectbox.Transaction;
-import io.objectbox.annotation.apihint.Temporary;
 
 // THIS CODE was originally GENERATED BY ObjectBox.
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/CustomerCursor.java
Patch:
@@ -4,7 +4,6 @@
 import io.objectbox.Cursor;
 import io.objectbox.Properties;
 import io.objectbox.Transaction;
-import io.objectbox.annotation.apihint.Temporary;
 
 // THIS CODE IS ADAPTED from generated resources of the test-entity-annotations project
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/MultithreadedRelationTest.java
Patch:
@@ -31,8 +31,8 @@ public void testMultithreadedRelations() throws InterruptedException {
         running = false;
         assertNull(error);
         assertFalse(hasError);
-        for (int i = 0; i < threads.length; i++) {
-            threads[i].join();
+        for (Thread thread : threads) {
+            thread.join();
         }
     }
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/relation/Order_.java
Patch:
@@ -3,7 +3,6 @@
 
 import io.objectbox.Properties;
 import io.objectbox.Property;
-import io.objectbox.index.model.EntityLongIndex;
 import io.objectbox.internal.IdGetter;
 
 // THIS CODE IS ADAPTED from generated resources of the test-entity-annotations project

File: tests/objectbox-java-test/src/main/java/io/objectbox/FunctionalTestSuite.java
Patch:
@@ -9,6 +9,7 @@
 import io.objectbox.query.QueryObserverTest;
 import io.objectbox.query.QueryTest;
 import io.objectbox.relation.RelationTest;
+import io.objectbox.relation.ToOneTest;
 
 @RunWith(Suite.class)
 @SuiteClasses({
@@ -23,6 +24,7 @@
         QueryObserverTest.class,
         QueryTest.class,
         RelationTest.class,
+        ToOneTest.class,
         TransactionTest.class,
 })
 public class FunctionalTestSuite {

File: tests/objectbox-java-test/src/main/java/io/objectbox/CursorTest.java
Patch:
@@ -144,6 +144,7 @@ public void testPutSameIndexValue() {
         cursor.put(entity);
         assertEquals(key, cursor.lookupKeyUsingIndex(9, value));
         TestEntity read = cursor.get(key);
+        cursor.close();
         assertEquals(1977, read.getSimpleInt());
         assertEquals(value, read.getSimpleString());
     }
@@ -290,6 +291,7 @@ public void testGetPropertyId() {
         assertEquals(2, cursor.getPropertyId("simpleBoolean"));
         assertEquals(3, cursor.getPropertyId("simpleByte"));
         assertEquals(4, cursor.getPropertyId("simpleShort"));
+        cursor.close();
         transaction.abort();
     }
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -25,6 +25,7 @@ public abstract class AbstractObjectBoxTest {
     protected BoxStore store;
     protected Random random = new Random();
     protected boolean runExtensiveTests;
+
     int lastEntityId;
     int lastIndexId;
     long lastUid;

File: tests/objectbox-java-test/src/main/java/io/objectbox/FunctionalTestSuite.java
Patch:
@@ -7,6 +7,7 @@
 import io.objectbox.query.LazyListTest;
 import io.objectbox.query.QueryObserverTest;
 import io.objectbox.query.QueryTest;
+import io.objectbox.relation.RelationTest;
 
 @RunWith(Suite.class)
 @SuiteClasses({
@@ -19,6 +20,7 @@
         ObjectClassObserverTest.class,
         QueryObserverTest.class,
         QueryTest.class,
+        RelationTest.class,
         TransactionTest.class,
 })
 public class FunctionalTestSuite {

File: objectbox-java/src/main/java/io/objectbox/reactive/WeakDataObserver.java
Patch:
@@ -5,7 +5,7 @@
 import io.objectbox.annotation.apihint.Internal;
 
 @Internal
-public class WeakDataObserver<T> implements DataObserver<T> {
+public class WeakDataObserver<T> implements DataObserver<T>, DelegatingObserver {
     private final WeakReference<DataObserver<T>> weakDelegate;
     private DataSubscription subscription;
 
@@ -23,7 +23,7 @@ public void onData(T data) {
         }
     }
 
-    public DataObserver<T> getDelegate() {
+    public DataObserver<T> getObserverDelegate() {
         return weakDelegate.get();
     }
 

File: objectbox-java/src/main/java/io/objectbox/query/Query.java
Patch:
@@ -289,7 +289,7 @@ public void run() {
             if(objectClassSubscription != null) {
                 throw new IllegalStateException("Existing subscription found");
             }
-            objectClassSubscription = store.subscribe(box.getEntityClass()).weak().subscribe(objectClassObserver);
+            objectClassSubscription = store.subscribe(box.getEntityClass()).weak().observer(objectClassObserver);
         }
         observers.add(observer);
     }

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -32,7 +32,7 @@
 import io.objectbox.converter.PropertyConverter;
 import io.objectbox.exception.DbSchemaException;
 import io.objectbox.internal.CrashReportLogger;
-import io.objectbox.reactive.Publisher;
+import io.objectbox.reactive.DataPublisher;
 import io.objectbox.reactive.SubscriptionBuilder;
 
 @Beta
@@ -516,7 +516,7 @@ long internalHandle() {
      * Failed or aborted transaction do not trigger observers.
      */
     public SubscriptionBuilder<Class> subscribe() {
-        return new SubscriptionBuilder<Class>(objectClassPublisher, null, threadPool);
+        return new SubscriptionBuilder<>(objectClassPublisher, null, threadPool);
     }
 
     /**
@@ -525,7 +525,7 @@ public SubscriptionBuilder<Class> subscribe() {
      * Failed or aborted transaction do not trigger observers.
      */
     public <T> SubscriptionBuilder<Class<T>> subscribe(Class<T> forClass) {
-        return new SubscriptionBuilder<>((Publisher) objectClassPublisher, forClass, threadPool);
+        return new SubscriptionBuilder<>((DataPublisher) objectClassPublisher, forClass, threadPool);
     }
 
     @Internal

File: objectbox-java/src/main/java/io/objectbox/reactive/DataSubscription.java
Patch:
@@ -1,6 +1,6 @@
 package io.objectbox.reactive;
 
-public interface Subscription {
+public interface DataSubscription {
     void cancel();
 
     boolean isCanceled();

File: tests/test-proguard/src/main/java/io/objectbox/test/proguard/ObfuscatedEntity_.java
Patch:
@@ -13,9 +13,9 @@ public class ObfuscatedEntity_ implements Properties {
 
     public static final String __NAME_IN_DB = "ObfuscatedEntity";
 
-    public final static Property id = new Property(0, 0, long.class, "id", true, "id");
-    public final static Property myInt = new Property(1, 0, int.class, "myInt");
-    public final static Property myString = new Property(2, 0, String.class, "myString");
+    public final static Property id = new Property(0, 1, long.class, "id", true, "id");
+    public final static Property myInt = new Property(1, 2, int.class, "myInt");
+    public final static Property myString = new Property(2, 3, String.class, "myString");
 
     public final static Property[] __ALL_PROPERTIES = {
         id,

File: objectbox-java/src/main/java/io/objectbox/internal/ReflectionCache.java
Patch:
@@ -25,7 +25,7 @@ public synchronized Field getField(Class clazz, String name) {
         Field field = fieldsForClass.get(name);
         if (field == null) {
             try {
-                field = clazz.getDeclaredField("__boxStore");
+                field = clazz.getDeclaredField(name);
                 field.setAccessible(true);
             } catch (NoSuchFieldException e) {
                 throw new IllegalStateException(e);

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -432,7 +432,7 @@ public synchronized Properties getProperties() {
     }
 
     @Internal
-    List<T> getBacklinkEntities(int entityId, Property relationIdProperty, long key) {
+    public List<T> getBacklinkEntities(int entityId, Property relationIdProperty, long key) {
         Cursor<T> reader = getReader();
         try {
             return reader.getBacklinkEntities(entityId, relationIdProperty, key);

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -230,7 +230,8 @@ Integer getEntityId(Class entityClass) {
         return entityIdByClass.get(entityClass);
     }
 
-    int getEntityIdOrThrow(Class entityClass) {
+    @Internal
+    public int getEntityIdOrThrow(Class entityClass) {
         Integer id = entityIdByClass.get(entityClass);
         if (id == null) {
             throw new DbSchemaException("No entity registered for " + entityClass);

File: objectbox-java/src/main/java/io/objectbox/model/PropertyType.java
Patch:
@@ -22,9 +22,9 @@ private PropertyType() { }
    */
   public static final short Date = 10;
   /**
-   * Reference to another entity
+   * Relation to another entity
    */
-  public static final short Reference = 11;
+  public static final short Relation = 11;
   public static final short Reserved1 = 12;
   public static final short Reserved2 = 13;
   public static final short Reserved3 = 14;
@@ -46,7 +46,7 @@ private PropertyType() { }
   public static final short StringVector = 30;
   public static final short DateVector = 31;
 
-  public static final String[] names = { "Unknown", "Bool", "Byte", "Short", "Char", "Int", "Long", "Float", "Double", "String", "Date", "Reference", "Reserved1", "Reserved2", "Reserved3", "Reserved4", "Reserved5", "Reserved6", "Reserved7", "Reserved8", "Reserved9", "Reserved10", "BoolVector", "ByteVector", "ShortVector", "CharVector", "IntVector", "LongVector", "FloatVector", "DoubleVector", "StringVector", "DateVector", };
+  public static final String[] names = { "Unknown", "Bool", "Byte", "Short", "Char", "Int", "Long", "Float", "Double", "String", "Date", "Relation", "Reserved1", "Reserved2", "Reserved3", "Reserved4", "Reserved5", "Reserved6", "Reserved7", "Reserved8", "Reserved9", "Reserved10", "BoolVector", "ByteVector", "ShortVector", "CharVector", "IntVector", "LongVector", "FloatVector", "DoubleVector", "StringVector", "DateVector", };
 
   public static String name(int e) { return names[e]; }
 }

File: tests/objectbox-java-test/src/main/java/io/objectbox/CursorTest.java
Patch:
@@ -41,7 +41,7 @@ public void testPutAndGetEntity() {
         transaction.abort();
     }
 
-    @Test(expected = DbException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void testPutEntityWithInvalidId() {
         TestEntity entity = new TestEntity();
         entity.setId(777);

File: tests/objectbox-java-test/src/main/java/io/objectbox/TransactionTest.java
Patch:
@@ -137,21 +137,21 @@ public void testTransactionReset() {
         transaction.abort();
     }
 
-    @Test(expected = DbException.class)
+    @Test(expected = IllegalStateException.class)
     public void testCreateCursorAfterAbortException() {
         Transaction tx = store.beginReadTx();
         tx.abort();
         tx.createKeyValueCursor();
     }
 
-    @Test(expected = DbException.class)
+    @Test(expected = IllegalStateException.class)
     public void testCommitAfterAbortException() {
         Transaction tx = store.beginTx();
         tx.abort();
         tx.commit();
     }
 
-    @Test(expected = DbException.class)
+    @Test(expected = IllegalStateException.class)
     public void testCommitReadTxException() {
         Transaction tx = store.beginReadTx();
         tx.commit();

File: objectbox-java/src/main/java/io/objectbox/ModelBuilder.java
Patch:
@@ -39,7 +39,7 @@ public PropertyBuilder indexId(int indexId) {
             return this;
         }
 
-        public PropertyBuilder refId(int refId) {
+        public PropertyBuilder refId(long refId) {
             checkNotFinished();
             ModelProperty.addRefId(fbb, refId);
             return this;

File: objectbox-java/src/main/java/io/objectbox/Property.java
Patch:
@@ -63,7 +63,7 @@ public QueryCondition eq(Object value) {
         return new PropertyCondition(this, Operation.EQUALS, value);
     }
 
-    /** Creates an "not equal ('<>')" condition  for this property. */
+    /** Creates an "not equal ('&lt;&gt;')" condition  for this property. */
     public QueryCondition notEq(Object value) {
         return new PropertyCondition(this, Operation.NOT_EQUALS, value);
     }
@@ -84,12 +84,12 @@ public QueryCondition in(Collection<?> inValues) {
         return in(inValues.toArray());
     }
 
-    /** Creates an "greater than ('>')" condition  for this property. */
+    /** Creates an "greater than ('&gt;')" condition  for this property. */
     public QueryCondition gt(Object value) {
         return new PropertyCondition(this, Operation.GREATER_THAN, value);
     }
 
-    /** Creates an "less than ('<')" condition  for this property. */
+    /** Creates an "less than ('&lt;')" condition  for this property. */
     public QueryCondition lt(Object value) {
         return new PropertyCondition(this, Operation.LESS_THAN, value);
     }

File: tests/objectbox-java-test/src/main/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -38,7 +38,8 @@ protected BoxStore createBoxStore(boolean withIndex) {
     protected BoxStoreBuilder createBoxStoreBuilderWithTwoEntities(boolean withIndex) {
         BoxStoreBuilder builder = new BoxStoreBuilder(createTestModelWithTwoEntities(withIndex)).directory(boxStoreDir);
         builder.entity("TestEntity", TestEntity.class, TestEntityCursor.class);
-        return builder.entity("TestEntityMinimal", TestEntityMinimal.class, TestEntityMinimalCursor.class);
+        builder.entity("TestEntityMinimal", TestEntityMinimal.class, TestEntityMinimalCursor.class);
+        return builder;
     }
 
     protected BoxStoreBuilder createBoxStoreBuilder(boolean withIndex) {

File: objectbox-java/src/main/java/io/objectbox/Box.java
Patch:
@@ -338,8 +338,8 @@ public void removeAll() {
         }
     }
 
-    public QueryBuilder query() {
-        return new QueryBuilder(this, store.internalHandle(), store.getEntityName(entityClass));
+    public QueryBuilder<T> query() {
+        return new QueryBuilder<T>(this, store.internalHandle(), store.getEntityName(entityClass));
     }
 
     public BoxStore getStore() {

File: objectbox-java/src/main/java/io/objectbox/query/QueryBuilder.java
Patch:
@@ -2,11 +2,13 @@
 
 import io.objectbox.Box;
 import io.objectbox.Property;
+import io.objectbox.annotation.apihint.Experimental;
 import io.objectbox.annotation.apihint.Internal;
 
 /**
  * Created by Markus on 13.10.2016.
  */
+@Experimental
 public class QueryBuilder<T> {
     private final Box<T> box;
 

File: objectbox-java/src/main/java/io/objectbox/BoxStore.java
Patch:
@@ -69,7 +69,7 @@ public static synchronized boolean clearDefaultStore() {
     static native long nativeCreateIndex(long store, String name, int entityId, int propertyId);
 
     public static String getVersion() {
-        return "0.9.0-2016100213";
+        return "0.9.0-2016100214";
     }
 
     private final File directory;

File: tests/objectbox-java-test/src/main/java/io/objectbox/PerformanceTest.java
Patch:
@@ -124,6 +124,8 @@ private TestEntity createRandomTestEntity(String simpleString) {
         TestEntity e = new TestEntity();
         setScalarsToRandomValues(e);
         e.setSimpleString(simpleString);
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        e.setSimpleByteArray(bytes);
         return e;
     }
 

File: tests/objectbox-java-test/src/main/java/io/objectbox/TestEntityCursor.java
Patch:
@@ -3,7 +3,7 @@
 public class TestEntityCursor extends Cursor<TestEntity> {
 
     public TestEntityCursor(Transaction tx, long cursor) {
-        super(tx, cursor);
+        super(tx, cursor, null);
     }
 
     @Override

File: tests/objectbox-java-test/src/main/java/io/objectbox/TestUtils.java
Patch:
@@ -6,8 +6,8 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 
-import de.greenrobot.common.io.FileUtils;
-import de.greenrobot.common.io.IoUtils;
+import org.greenrobot.essentials.io.FileUtils;
+import org.greenrobot.essentials.io.IoUtils;
 
 /**
  * Created by markus.

File: objectbox-java/src/main/java/io/objectbox/ModelBuilder.java
Patch:
@@ -5,9 +5,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import objectstore.model.Model;
-import objectstore.model.ModelEntity;
-import objectstore.model.ModelProperty;
+import io.objectbox.model.Model;
+import io.objectbox.model.ModelEntity;
+import io.objectbox.model.ModelProperty;
 
 public class ModelBuilder {
     final FlatBufferBuilder fbb = new FlatBufferBuilder();

File: tests/objectbox-java-test/src/main/java/io/objectbox/AbstractObjectBoxTest.java
Patch:
@@ -1,14 +1,14 @@
 package io.objectbox;
 
-import io.objectbox.ModelBuilder.EntityBuilder;
 import org.junit.After;
 import org.junit.Before;
 
 import java.io.File;
 import java.util.Random;
 
-import objectstore.PropertyFlags;
-import objectstore.PropertyType;
+import io.objectbox.ModelBuilder.EntityBuilder;
+import io.objectbox.model.PropertyFlags;
+import io.objectbox.model.PropertyType;
 
 public abstract class AbstractObjectBoxTest {
     protected File boxStoreDir;

