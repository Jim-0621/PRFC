File: compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
Patch:
@@ -29,7 +29,7 @@ class TestApp {
   @MyQualifier
   static class TestClass1 {
     
-    @MyQualifier // qualfier on non-injectable constructor
+    @MyQualifier // qualifier on non-injectable constructor
     public TestClass1(String constructorParam) {}
   }
   

File: compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
Patch:
@@ -41,7 +41,7 @@ static class TestClass {
     @MyQualifier 
     int fieldWithWarningSuppressed2;
     
-    // qualfier on non-injectable constructor parameter
+    // qualifier on non-injectable constructor parameter
     public TestClass(@MyQualifier String constructorParam) {}
     
     @MyQualifier 

File: compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
Patch:
@@ -29,7 +29,7 @@ class TestApp {
   @MyQualifier
   static class TestClass1 {
     
-    @MyQualifier // qualfier on non-injectable constructor
+    @MyQualifier // qualifier on non-injectable constructor
     public TestClass1(String constructorParam) {}
   }
   

File: compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
Patch:
@@ -41,7 +41,7 @@ static class TestClass {
     @MyQualifier 
     int fieldWithWarningSuppressed2;
     
-    // qualfier on non-injectable constructor parameter
+    // qualifier on non-injectable constructor parameter
     public TestClass(@MyQualifier String constructorParam) {}
     
     @MyQualifier 

File: core/src/main/java/dagger/Provides.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to it's returned value. The object graph will
+ * method's return type is bound to its returned value. The object graph will
  * pass dependencies to the method as parameters.
  *
  * @author Bob Lee

File: core/src/main/java/dagger/Provides.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to it's returned value. The object graph will
+ * method's return type is bound to its returned value. The object graph will
  * pass dependencies to the method as parameters.
  *
  * @author Bob Lee

File: core/src/main/java/dagger/internal/Memoizer.java
Patch:
@@ -22,7 +22,9 @@
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
- * Represents an operation to be
+ * Represents an operation whose results are memoized. Results returned by invocations of
+ * {@link #create(Object)} are memoized so that the same object is returned for multiple invocations
+ * of {@link #get(Object)} for the same key.
  */
 abstract class Memoizer<K, V> {
   private final Map<K, V> map;

File: core/src/test/java/dagger/internal/FailoverLoaderTest.java
Patch:
@@ -33,7 +33,7 @@
 @RunWith(JUnit4.class)
 public final class FailoverLoaderTest {
 
-  @Module(injects = EntryPoint.class)
+  @Module(injects = Entry$Point.class)
   static class TestModule {
     @Provides String aString() { return "a"; }
   }
@@ -45,12 +45,12 @@ static final class TestModule$$ModuleAdapter extends TestingModuleAdapter<TestMo
     }
   }
 
-  static class EntryPoint {
+  static class Entry$Point {
     @Inject String a;
   }
 
   @Test public void simpleInjectionWithUnGeneratedCode() {
-    EntryPoint entryPoint = new EntryPoint();
+    Entry$Point entryPoint = new Entry$Point();
     ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.a).isEqualTo("a");
   }

File: core/src/main/java/dagger/Module.java
Patch:
@@ -28,9 +28,9 @@
 public @interface Module {
   /**
    * Returns classes that object graphs created with this module must be able to
-   * inject. This includes both classes passed to {@link ObjectGraph#get}, 
-   * the types of instances passed {@link ObjectGraph#inject} and 
-   * {@link javax.inject.Inject} annotated classes that need to be scoped to the 
+   * inject. This includes both classes passed to {@link ObjectGraph#get},
+   * the types of instances passed {@link ObjectGraph#inject} and
+   * {@link javax.inject.Inject} annotated classes that need to be scoped to the
    * resulting object graphs.
    *
    * <p>It is an error to call {@link ObjectGraph#get} or {@link

File: core/src/main/java/dagger/Module.java
Patch:
@@ -28,9 +28,9 @@
 public @interface Module {
   /**
    * Returns classes that object graphs created with this module must be able to
-   * inject. This includes both classes passed to {@link ObjectGraph#get}, 
-   * the types of instances passed {@link ObjectGraph#inject} and 
-   * {@link javax.inject.Inject} annotated classes that need to be scoped to the 
+   * inject. This includes both classes passed to {@link ObjectGraph#get},
+   * the types of instances passed {@link ObjectGraph#inject} and
+   * {@link javax.inject.Inject} annotated classes that need to be scoped to the
    * resulting object graphs.
    *
    * <p>It is an error to call {@link ObjectGraph#get} or {@link

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -213,7 +213,7 @@ private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnviron
       TypeElement moduleType = (TypeElement) module;
 
       // Verify that all modules do not extend from non-Object types.
-      if (!moduleType.getSuperclass().equals(objectType)) {
+      if (!types.isSameType(moduleType.getSuperclass(), objectType)) {
         error("Modules must not extend from other classes: " + elementToString(module), module);
       }
 

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -213,7 +213,7 @@ private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnviron
       TypeElement moduleType = (TypeElement) module;
 
       // Verify that all modules do not extend from non-Object types.
-      if (!moduleType.getSuperclass().equals(objectType)) {
+      if (!types.isSameType(moduleType.getSuperclass(), objectType)) {
         error("Modules must not extend from other classes: " + elementToString(module), module);
       }
 

File: examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * This module represents objects which exist only for the scope of a single activity. We can
- * safely create singletons using the activity instance because ths entire object graph will only
+ * safely create singletons using the activity instance because the entire object graph will only
  * ever exist inside of that activity.
  */
 @Module(

File: examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * This module represents objects which exist only for the scope of a single activity. We can
- * safely create singletons using the activity instance because ths entire object graph will only
+ * safely create singletons using the activity instance because the entire object graph will only
  * ever exist inside of that activity.
  */
 @Module(

File: compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
Patch:
@@ -19,11 +19,11 @@
 import java.io.IOException;
 import java.util.Comparator;
 import java.util.HashSet;
-import java.util.TreeSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
+import java.util.TreeSet;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -125,7 +125,7 @@ String shortName(String key) {
     return result.toString();
   }
 
-  /** A Comparator for BindingsGroup so we can insure a consistent ordering of output. */
+  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
   private static class BindingComparator implements Comparator<Binding<?>> {
     @Override
     public int compare(Binding<?> left, Binding<?> right) {

File: core/src/main/java/dagger/internal/BindingsGroup.java
Patch:
@@ -16,7 +16,7 @@
  */
 package dagger.internal;
 
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -26,7 +26,7 @@
  * the initial set of bindings for a graph (from provides methods).
  */
 public abstract class BindingsGroup {
-  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
 
   public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
 

File: core/src/main/java/dagger/internal/Keys.java
Patch:
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * BindingsGroup from {@code @Provides} methods are of the first two types. BindingsGroup
+ * Bindings from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -38,7 +38,7 @@ public final class Linker {
    */
   private final Linker base;
 
-  /** BindingsGroup requiring a call to attach(). May contain deferred bindings. */
+  /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */

File: compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
Patch:
@@ -125,7 +125,7 @@ String shortName(String key) {
     return result.toString();
   }
 
-  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
+  /** A Comparator for BindingsGroup so we can insure a consistent ordering of output. */
   private static class BindingComparator implements Comparator<Binding<?>> {
     @Override
     public int compare(Binding<?> left, Binding<?> right) {

File: core/src/main/java/dagger/internal/Keys.java
Patch:
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * BindingsGroup from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -38,7 +38,7 @@ public final class Linker {
    */
   private final Linker base;
 
-  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  /** BindingsGroup requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
@@ -77,9 +77,9 @@ public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
    * bindings can be used.
    *
    * This method may only be called before {@link #linkAll()}. Subsequent calls to
-   * {@link #installBindings()} will throw an {@link IllegalStateException}.
+   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
    */
-  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+  public void installBindings(BindingsGroup toInstall) {
     if (linkedBindings != null) {
       throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
     }

File: core/src/test/java/dagger/InjectionTest.java
Patch:
@@ -868,10 +868,10 @@ static class SingletonLinkedFromExtension {
     @Inject C c; // Singleton.
   }
 
-  @Module(complete=false, injects =C.class)
+  @Module(complete = false, injects = C.class)
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, injects =SingletonLinkedFromExtension.class)
+  @Module(addsTo = RootModule.class, injects = SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {

File: compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
Patch:
@@ -167,7 +167,7 @@ private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule,
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(new GraphAnalysisLoader(processingEnv), errorHandler);
+    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import dagger.ObjectGraph;
 import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
 import java.util.Collections;

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -485,7 +485,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
       writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
           "getBindings", setOfBindings, "injectMembersBindings");
       for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
+        writer.emitStatement("getBindings.add(%s)", parameterName(parameter));
       }
       writer.endMethod();
     }
@@ -499,7 +499,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
     for (Element parameter : parameters) {
       if (!first) args.append(", ");
       else first = false;
-      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
+      args.append(String.format("%s.get()", parameterName(parameter)));
     }
     writer.emitStatement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -485,7 +485,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
       writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
           "getBindings", setOfBindings, "injectMembersBindings");
       for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
+        writer.emitStatement("getBindings.add(%s)", parameterName(parameter));
       }
       writer.endMethod();
     }
@@ -499,7 +499,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
     for (Element parameter : parameters) {
       if (!first) args.append(", ");
       else first = false;
-      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
+      args.append(String.format("%s.get()", parameterName(parameter)));
     }
     writer.emitStatement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();

File: compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
Patch:
@@ -48,7 +48,8 @@ public final class InjectAdapterGenerationTest {
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+            "    super(Basic.AModule.class,INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
+            "      true, false);",
             "  }",
             "  @Override public Basic.AModule newModule() {",
             "    return new Basic.AModule();",

File: compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
Patch:
@@ -159,7 +159,7 @@ private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule,
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
+    Linker linker = new Linker(new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.

File: core/src/main/java/dagger/internal/ModuleAdapter.java
Patch:
@@ -57,7 +57,7 @@ protected T newModule() {
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public T getModule() {
-    return module;
+  public Class<?> getModuleClass() {
+    return module.getClass();
   }
 }

File: core/src/main/java/dagger/internal/Modules.java
Patch:
@@ -50,7 +50,7 @@ public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
     }
 
     // Next add adapters for the modules that we need to construct. This creates

File: core/src/main/java/dagger/internal/ModuleAdapter.java
Patch:
@@ -57,7 +57,7 @@ protected T newModule() {
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public T getModule() {
-    return module;
+  public Class<?> getModuleClass() {
+    return module.getClass();
   }
 }

File: core/src/main/java/dagger/internal/Modules.java
Patch:
@@ -50,7 +50,7 @@ public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
     }
 
     // Next add adapters for the modules that we need to construct. This creates

File: core/src/main/java/dagger/internal/Keys.java
Patch:
@@ -144,7 +144,7 @@ private static void typeToString(Type type, StringBuilder result, boolean topLev
         result.append("[]");
       } else if (c.isPrimitive()) {
         if (topLevel) {
-          throw new UnsupportedOperationException("Uninjectable type " + type);
+          throw new UnsupportedOperationException("Uninjectable type " + c.getName());
         }
         result.append(c.getName());
       } else {

File: core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
Patch:
@@ -170,7 +170,7 @@ public static <T> Binding<T> create(Class<T> type, boolean mustHaveInjections) {
         continue;
       }
       if (injectedConstructor != null) {
-        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
+        throw new InvalidBindingException(type.getName(), "has too many injectable constructors");
       }
       injectedConstructor = constructor;
     }
@@ -181,8 +181,8 @@ public static <T> Binding<T> create(Class<T> type, boolean mustHaveInjections) {
         } catch (NoSuchMethodException ignored) {
         }
       } else if (mustHaveInjections) {
-        throw new IllegalArgumentException("No injectable members on " + type.getName()
-            + ". Do you want to add an injectable constructor?");
+        throw new InvalidBindingException(type.getName(),
+            "has no injectable members. Do you want to add an injectable constructor?");
       }
     }
 

File: core/src/test/java/dagger/InjectionTest.java
Patch:
@@ -549,7 +549,7 @@ class TestModule {
 
   @Test public void noProvideBindingsForAbstractClasses() {
     class TestEntryPoint {
-      @Inject AbstractList<?> abstractList;
+      @Inject AbstractList abstractList;
     }
 
     @Module(injects = TestEntryPoint.class)

File: compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
Patch:
@@ -43,9 +43,9 @@ public final class AdapterJavadocs {
       + "A manager for {@code %s}'s injections into static fields.";
 
   /** Creates an appropriate javadoc depending on aspects of the type in question. */
-  static String binderTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
+  static String bindingTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
     StringBuffer sb = new StringBuffer();
-    sb.append("A {@code Binder<").append(type).append(">} implementation which satisfies\n");
+    sb.append("A {@code Binding<").append(type).append(">} implementation which satisfies\n");
     sb.append("Dagger's infrastructure requirements including:");
     if (dependent) {
       sb.append("\n\n");

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -54,7 +54,7 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
 import static dagger.internal.codegen.Util.adapterName;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getAnnotation;
@@ -239,7 +239,6 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
 
     writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitEmptyLine();
     writer.emitImports(
         getImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
 
@@ -419,7 +418,7 @@ private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerM
     boolean dependent = !parameters.isEmpty();
 
     writer.emitEmptyLine();
-    writer.emitJavadoc(binderTypeDocs(returnType, false, false, dependent));
+    writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
     writer.beginType(className, "class", PUBLIC | FINAL | STATIC,
         JavaWriter.type(Binding.class, returnType),
         JavaWriter.type(Provider.class, returnType));

File: examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
Patch:
@@ -37,7 +37,7 @@ public AndroidModule(DemoApplication application) {
 
   /**
    * Allow the application context to be injected but require that it be annotated with
-   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
+   * {@link ForApplication @ForApplication} to explicitly differentiate it from an activity context.
    */
   @Provides @Singleton @ForApplication Context provideApplicationContext() {
     return application;

File: examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
Patch:
@@ -37,7 +37,7 @@ public AndroidModule(DemoApplication application) {
 
   /**
    * Allow the application context to be injected but require that it be annotated with
-   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
+   * {@link ForApplication @ForApplication} to explicitly differentiate it from an activity context.
    */
   @Provides @Singleton @ForApplication Context provideApplicationContext() {
     return application;

File: compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
Patch:
@@ -21,9 +21,12 @@
 import dagger.Provides;
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
   static class ArrayInjectable {
     @Inject byte[] byteArray;

File: compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
Patch:
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
Patch:
@@ -1,5 +1,6 @@
 /**
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: core/src/main/java/dagger/internal/FailoverLoader.java
Patch:
@@ -51,7 +51,7 @@ public final class FailoverLoader implements Loader {
           // A null classloader is the system classloader.
           classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
           Class<?> type = classLoader.loadClass(className);
-          if (!type.isInterface()) {
+          if (type.isInterface()) {
             return null; // Short-circuit since we can't build reflective bindings for interfaces.
           }
           return ReflectiveAtInjectBinding.create(type, mustHaveInjections);

File: core/src/test/java/dagger/internal/TestingLoader.java
Patch:
@@ -26,7 +26,7 @@
 public final class TestingLoader implements Loader {
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> adapter = TestOnlyModuleAdapter.create(type);
+    ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
     adapter.module = (instance != null) ? instance : adapter.newModule();
     return adapter;
   }

File: core/src/main/java/dagger/internal/FailoverLoader.java
Patch:
@@ -51,7 +51,7 @@ public final class FailoverLoader implements Loader {
           // A null classloader is the system classloader.
           classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
           Class<?> type = classLoader.loadClass(className);
-          if (!type.isInterface()) {
+          if (type.isInterface()) {
             return null; // Short-circuit since we can't build reflective bindings for interfaces.
           }
           return ReflectiveAtInjectBinding.create(type, mustHaveInjections);

File: core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
Patch:
@@ -37,7 +37,7 @@ private GeneratedAdapters() { }
 
   /**
    * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a ClassNotFoundException.
+   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
    */
   public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
       throws ClassNotFoundException {
@@ -46,7 +46,7 @@ public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleCl
 
   /**
    * Attempts to load an adapter named from the provided class name plus a constant suffix
-   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a ClassNotFoundException.
+   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
    */
   public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
       throws ClassNotFoundException {
@@ -55,7 +55,7 @@ public static Binding<?> initInjectAdapter(String className, ClassLoader classLo
 
   /**
    * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #STATIC_INJECTION_SUFFIX}, or throws a ClassNotFoundException.
+   * {@link #STATIC_INJECTION_SUFFIX}, or throws a {@code ClassNotFoundException}.
    */
   public static StaticInjection initStaticInjection(Class<?> injectedClass)
       throws ClassNotFoundException {

File: compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
Patch:
@@ -54,8 +54,8 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.rawTypeToString;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -58,10 +58,9 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.isInterface;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
 import static java.lang.reflect.Modifier.PUBLIC;
 import static java.lang.reflect.Modifier.STATIC;
 
@@ -296,7 +295,7 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
     if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
       writer.emitEmptyLine();
       writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", PROTECTED);
+      writer.beginMethod(typeName, "newModule", PUBLIC);
       writer.emitStatement("return new %s()", typeName);
       writer.endMethod();
     }

File: core/src/main/java/dagger/internal/Loader.java
Patch:
@@ -23,7 +23,8 @@
  */
 public interface Loader {
   /**
-   * Returns a binding that uses {@code @Inject} annotations.
+   * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
+   * be found or created.
    */
   Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);

File: core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
@@ -35,7 +35,7 @@
  * Injects the {@code @Inject}-annotated fields and constructors of a class
  * using reflection.
  */
-final class ReflectiveAtInjectBinding<T> extends Binding<T> {
+public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
   private final ClassLoader loader;
   private final Constructor<T> constructor;

File: compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
Patch:
@@ -15,9 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
-
 import com.squareup.java.JavaWriter;
 import dagger.MembersInjector;
 import dagger.internal.Binding;
@@ -57,6 +54,8 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.rawTypeToString;
 import static dagger.internal.codegen.TypeUtils.typeToString;
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;

File: core/src/main/java/dagger/ObjectGraph.java
Patch:
@@ -16,9 +16,8 @@
  */
 package dagger;
 
-import dagger.internal.FailoverLoader;
-
 import dagger.internal.Binding;
+import dagger.internal.FailoverLoader;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.Loader;

File: core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
Patch:
@@ -133,7 +133,7 @@ private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method meth
    * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
    */
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
-  public static <T> ModuleAdapter<T> createAdaptor(Class<? extends T> moduleClass) {
+  public static <T> ModuleAdapter<T> create(Class<? extends T> moduleClass) {
     Module annotation = moduleClass.getAnnotation(Module.class);
     if (annotation == null) {
       throw new IllegalArgumentException("No @Module on " + moduleClass.getName());

File: compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
Patch:
@@ -15,6 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
 import com.squareup.java.JavaWriter;
 import dagger.MembersInjector;
 import dagger.internal.Binding;
@@ -54,8 +57,6 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.rawTypeToString;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;

File: compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
Patch:
@@ -58,10 +58,9 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.isInterface;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
 import static java.lang.reflect.Modifier.PUBLIC;
 import static java.lang.reflect.Modifier.STATIC;
 
@@ -296,7 +295,7 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
     if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
       writer.emitEmptyLine();
       writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", PROTECTED);
+      writer.beginMethod(typeName, "newModule", PUBLIC);
       writer.emitStatement("return new %s()", typeName);
       writer.endMethod();
     }

File: core/src/main/java/dagger/internal/Loader.java
Patch:
@@ -23,7 +23,8 @@
  */
 public interface Loader {
   /**
-   * Returns a binding that uses {@code @Inject} annotations.
+   * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
+   * be found or created.
    */
   Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);

File: core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
@@ -35,7 +35,7 @@
  * Injects the {@code @Inject}-annotated fields and constructors of a class
  * using reflection.
  */
-final class ReflectiveAtInjectBinding<T> extends Binding<T> {
+public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
   private final ClassLoader loader;
   private final Constructor<T> constructor;

File: compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
Patch:
@@ -70,9 +70,9 @@ static GraphAnalysisInjectBinding create(TypeElement type, boolean mustHaveInjec
         List<? extends VariableElement> parameters = constructor.getParameters();
         if (hasAtInject(enclosed)) {
           if (hasAtSingleton(enclosed)) {
-            throw new IllegalArgumentException("Singleton annotations have no effect on " +
-                "constructors. Did you mean to annotate the class? " +
-                type.getQualifiedName().toString());
+            throw new IllegalArgumentException("Singleton annotations have no effect on "
+                + "constructors. Did you mean to annotate the class? "
+                + type.getQualifiedName().toString());
           }
           if (hasInjectConstructor) {
             throw new IllegalArgumentException("Too many injectable constructors on "

File: core/src/main/java/dagger/ObjectGraph.java
Patch:
@@ -61,6 +61,8 @@
  * </ul>
  */
 public abstract class ObjectGraph {
+  ObjectGraph() {
+  }
 
   /**
    * Returns an instance of {@code type}.

File: compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
Patch:
@@ -38,7 +38,7 @@ public CompileTimePlugin(ProcessingEnvironment processingEnv) {
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+      String key, String className, boolean mustHaveInjections) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
@@ -51,7 +51,7 @@ public CompileTimePlugin(ProcessingEnvironment processingEnv) {
     if (type.getKind() == ElementKind.INTERFACE) {
       return null;
     }
-    return AtInjectBinding.create(type, mustBeInjectable);
+    return AtInjectBinding.create(type, mustHaveInjections);
   }
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {

File: core/src/main/java/dagger/internal/Plugin.java
Patch:
@@ -24,7 +24,7 @@ public interface Plugin {
   /**
    * Returns a binding that uses {@code @Inject} annotations.
    */
-  Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable);
+  Binding<?> getAtInjectBinding(String key, String className, boolean mustHaveInjections);
 
   /**
    * Returns a module adapter for {@code module}.

File: core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
Patch:
@@ -107,10 +107,10 @@ private static void collectIncludedModulesRecursively(Plugin plugin, ModuleAdapt
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) {
+      boolean mustHaveInjections) {
     for (int i = 0; i < plugins.length; i++) {
       try {
-        return plugins[i].getAtInjectBinding(key, className, mustBeInjectable);
+        return plugins[i].getAtInjectBinding(key, className, mustHaveInjections);
       } catch (RuntimeException e) {
         if (i == plugins.length - 1) throw e;
         logNotFound("Binding", className, e);

File: core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
Patch:
@@ -34,7 +34,7 @@ public final class ClassloadingPlugin implements Plugin {
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+      String key, String className, boolean mustHaveInjections) {
     return instantiate(className, INJECT_ADAPTER_SUFFIX);
   }
 

File: core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
Patch:
@@ -31,7 +31,7 @@
  */
 public final class ReflectivePlugin implements Plugin {
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+      String key, String className, boolean mustHaveInjections) {
     Class<?> c;
     try {
       c = Class.forName(className);
@@ -43,7 +43,7 @@ public final class ReflectivePlugin implements Plugin {
       return null;
     }
 
-    return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
+    return ReflectiveAtInjectBinding.create(c, mustHaveInjections);
   }
 
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -420,8 +420,9 @@ private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerM
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     String membersKey = null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), moduleType);
+    writer.emitStatement("super(%s, %s, %s, %s)",
+        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
     writer.emitStatement("this.module = module");
     writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();

File: core/src/main/java/dagger/internal/ProblemDetector.java
Patch:
@@ -40,7 +40,8 @@ public void detectUnusedBinding(Collection<Binding<?>> bindings) {
       StringBuilder builder = new StringBuilder();
       builder.append("You have these unused @Provider methods:");
       for (int i = 0; i < unusedBindings.size(); i++) {
-        builder.append("\n    ").append(i).append(". ").append(unusedBindings.get(i).requiredBy);
+        builder.append("\n    ").append(i + 1).append(". ")
+            .append(unusedBindings.get(i).requiredBy);
       }
       builder.append("\n    Set library=true in your module to disable this check.");
       throw new IllegalStateException(builder.toString());

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -420,8 +420,9 @@ private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerM
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     String membersKey = null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), moduleType);
+    writer.emitStatement("super(%s, %s, %s, %s)",
+        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
     writer.emitStatement("this.module = module");
     writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();

File: core/src/main/java/dagger/internal/ProblemDetector.java
Patch:
@@ -40,7 +40,8 @@ public void detectUnusedBinding(Collection<Binding<?>> bindings) {
       StringBuilder builder = new StringBuilder();
       builder.append("You have these unused @Provider methods:");
       for (int i = 0; i < unusedBindings.size(); i++) {
-        builder.append("\n    ").append(i).append(". ").append(unusedBindings.get(i).requiredBy);
+        builder.append("\n    ").append(i + 1).append(". ")
+            .append(unusedBindings.get(i).requiredBy);
       }
       builder.append("\n    Set library=true in your module to disable this check.");
       throw new IllegalStateException(builder.toString());

File: core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
Patch:
@@ -25,9 +25,9 @@
  * A runtime {@link Plugin} that loads generated classes.
  */
 public final class ClassloadingPlugin implements Plugin {
-  public static final String INJECT_ADAPTER_SUFFIX = "$InjectAdapter";
-  public static final String MODULE_ADAPTER_SUFFIX = "$ModuleAdapter";
-  public static final String STATIC_INJECTION_SUFFIX = "$StaticInjection";
+  public static final String INJECT_ADAPTER_SUFFIX = "$$InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = "$$ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = "$$StaticInjection";
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
     return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);

File: core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
Patch:
@@ -25,9 +25,9 @@
  * A runtime {@link Plugin} that loads generated classes.
  */
 public final class ClassloadingPlugin implements Plugin {
-  public static final String INJECT_ADAPTER_SUFFIX = "$InjectAdapter";
-  public static final String MODULE_ADAPTER_SUFFIX = "$ModuleAdapter";
-  public static final String STATIC_INJECTION_SUFFIX = "$StaticInjection";
+  public static final String INJECT_ADAPTER_SUFFIX = "$$InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = "$$ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = "$$StaticInjection";
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
     return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -244,7 +244,9 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
     StringBuilder injectsField = new StringBuilder().append("{ ");
     for (Object injectableType : injects) {
       TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = GeneratorKeys.rawMembersKey(typeMirror);
+      String key = CodeGen.isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
       injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     injectsField.append("}");

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -244,7 +244,9 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
     StringBuilder injectsField = new StringBuilder().append("{ ");
     for (Object injectableType : injects) {
       TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = GeneratorKeys.rawMembersKey(typeMirror);
+      String key = CodeGen.isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
       injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     injectsField.append("}");

File: compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
Patch:
@@ -17,7 +17,6 @@
 package test;
 
 import dagger.Module;
-import dagger.ObjectGraph;
 import dagger.Provides;
 import javax.inject.Inject;
 
@@ -39,7 +38,7 @@ static class EntryPoint {
     @Inject Foo f;
   }
 
-  @Module(entryPoints = EntryPoint.class)
+  @Module(injects = EntryPoint.class)
   static class TestModule {
     
   }
@@ -48,7 +47,7 @@ static class A { }
   static class B { }
   static class C { }
   static class D { }
-  @Module(entryPoints = D.class)
+  @Module(injects = D.class)
   static class CyclicModule {
     @Provides A a(@SuppressWarnings("unused") D d) { return null; }
     @Provides B b(@SuppressWarnings("unused") A a) { return null; }

File: compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
Patch:
@@ -31,7 +31,7 @@ public static void main(String[] args) {
     ObjectGraph.create(new TestModule()).get(TestApp.class).run();
   }
   
-  @Module(entryPoints = { TestApp.class })
+  @Module(injects = { TestApp.class })
   static class TestModule {}
 
   @Singleton

File: compiler/src/it/extension-graph/src/main/java/test/TestApp.java
Patch:
@@ -34,10 +34,10 @@ public static void main(String[] args) {
     extension.get(TestApp.class).run();
   }
   
-  @Module(entryPoints = { A.class, B.class })
+  @Module(injects = { A.class, B.class })
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, entryPoints = { C.class, TestApp.class })
+  @Module(addsTo=RootModule.class, injects = { C.class, TestApp.class })
   static class ExtensionModule { }
 
   @Singleton

File: compiler/src/it/include-non-module/src/main/java/test/TestApp.java
Patch:
@@ -29,7 +29,7 @@ public static void main(String[] args) {
   @Inject String s;
 
   @Module(
-      entryPoints = TestApp.class,
+      injects = TestApp.class,
       includes = TestApp.class)
   static class TestModule {
     @Provides String provideString() {

File: compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
Patch:
@@ -32,7 +32,7 @@ static class Supertype<T> {
   static class Subtype extends Supertype<Integer> {
   }
 
-  @Module(entryPoints = Subtype.class)
+  @Module(injects = Subtype.class)
   static class TestModule {
     @Provides String provideString() {
       return "a";

File: compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
Patch:
@@ -37,7 +37,7 @@ static class Dependency {
     public void doit() { throw AssertionError(); };
   }
   
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
     /* missing */ // @Provides Dependency a() { return new Dependency(); }
   }

File: compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
Patch:
@@ -29,7 +29,7 @@ static class InjectableSubclass extends NotInjectable {
     @Inject Integer integer;
   }
 
-  @Module(entryPoints = InjectableSubclass.class)
+  @Module(injects = InjectableSubclass.class)
   static class TestModule {
     @Provides String string() {
       return "string";

File: compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
Patch:
@@ -37,7 +37,7 @@ public static void main(String[] args) {
     ObjectGraph.create(new TestModule()).get(TestApp.class).run();
   }
 
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
 
     @Provides String string() throws IOException {

File: compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
Patch:
@@ -42,7 +42,7 @@ static class Foo {
   static class MyFoo extends Foo {
   }
 
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
 
     @Provides Foo providesFoo(MyFoo foo) {

File: compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
Patch:
@@ -36,7 +36,7 @@ static interface Dependency {
     void doit();
   }
   
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
     /* missing */ // @Provides Dependency a() { return new Dependency(); }
   }

File: compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
Patch:
@@ -27,7 +27,7 @@ static class InjectableSubclass extends NotInjectable {
     @Inject String string;
   }
 
-  @Module(entryPoints = InjectableSubclass.class)
+  @Module(injects = InjectableSubclass.class)
   static class TestModule {
     @Provides String provideString() {
       return "string";

File: compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
Patch:
@@ -148,9 +148,9 @@ private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule,
         boolean library = (Boolean) annotation.get("library");
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
-        // Gather the entry points from the annotation.
-        for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
-          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
+        // Gather the injectable types from the annotation.
+        for (Object injectableType : (Object[]) annotation.get("injects")) {
+          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) injectableType),
               module.getQualifiedName().toString(), false, true);
         }
 

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -204,9 +204,9 @@ public Binding<?> requestBinding(String key, Object requiredBy) {
    * enqueued to be linked.
    *
    * @param mustBeInjectable true if the the referenced key doesn't need to be
-   *     injectable. This is necessary for entry points (so that framework code
-   *     can inject arbitrary entry points like JUnit test cases or Android
-   *     activities) and for supertypes.
+   *     injectable. This is necessary for injectable types (so that framework
+   *     code can inject arbitrary classes like JUnit test cases or Android
+   *     activities) and also for supertypes.
    */
   public Binding<?> requestBinding(String key, Object requiredBy, boolean mustBeInjectable,
       boolean library) {

File: core/src/main/java/dagger/internal/ModuleAdapter.java
Patch:
@@ -23,17 +23,17 @@
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
-  public final String[] entryPoints;
+  public final String[] injectableTypes;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
   public final Class<?>[] includes;
   public final boolean complete;
   public final boolean library;
   protected T module;
 
-  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides,
+  protected ModuleAdapter(String[] injectableTypes, Class<?>[] staticInjections, boolean overrides,
       Class<?>[] includes, boolean complete, boolean library) {
-    this.entryPoints = entryPoints;
+    this.injectableTypes = injectableTypes;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
     this.includes = includes;

File: core/src/test/java/dagger/ExtensionWithStateTest.java
Patch:
@@ -32,7 +32,7 @@ static class B {
   }
 
   @Module(
-      entryPoints = A.class, // for testing
+      injects = A.class, // for testing
       complete = false
   )
   static class RootModule {
@@ -43,7 +43,7 @@ static class RootModule {
     @Provides A provideA() { return a; }
   }
 
-  @Module(addsTo = RootModule.class, entryPoints = { B.class })
+  @Module(addsTo = RootModule.class, injects = { B.class })
   static class ExtensionModule { }
 
   @Test public void basicInjectionWithExtension() {

File: core/src/test/java/dagger/InjectStaticsTest.java
Patch:
@@ -56,7 +56,7 @@ class TestModule {
   @Test public void instanceFieldsNotInjectedByInjectStatics() {
     @Module(
         staticInjections = InjectsStaticAndNonStatic.class,
-        entryPoints = InjectsStaticAndNonStatic.class)
+        injects = InjectsStaticAndNonStatic.class)
     class TestModule {
       @Provides String provideString() {
         return "static";
@@ -75,7 +75,7 @@ class TestModule {
   @Test public void staticFieldsNotInjectedByInjectMembers() {
     @Module(
         staticInjections = InjectsStaticAndNonStatic.class,
-        entryPoints = InjectsStaticAndNonStatic.class)
+        injects = InjectsStaticAndNonStatic.class)
     class TestModule {
       @Provides String provideString() {
         throw new AssertionError();

File: core/src/test/java/dagger/LazyInjectionTest.java
Patch:
@@ -24,8 +24,8 @@
 
 @RunWith(JUnit4.class)
 public final class LazyInjectionTest {
-  @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
-    @Module(entryPoints = LazyEntryPoint.class)
+  @Test public void getLazyDoesNotCauseInjectedTypesToBeLoaded() {
+    @Module(injects = LazyEntryPoint.class)
     class TestModule {
     }
 
@@ -99,7 +99,7 @@ class TestEntryPoint {
       @Inject String injected;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideString(Integer integer) {
         return integer.toString();

File: core/src/test/java/dagger/ProblemDetectorTest.java
Patch:
@@ -29,7 +29,7 @@ class TestEntryPoint {
       @Inject Rock rock;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 

File: core/src/test/java/dagger/ThreadSafetyTest.java
Patch:
@@ -49,7 +49,7 @@ static class LazyEntryPoint {
     @Inject Lazy<Integer> lazy;
   }
 
-  @Module(entryPoints = { Long.class, LazyEntryPoint.class })
+  @Module(injects = { Long.class, LazyEntryPoint.class })
   static class LatchingModule {
     private final AtomicInteger count = new AtomicInteger(FIRST_VALUE);
     private final CountDownLatch latch;

File: examples/simple/src/main/java/coffee/DripCoffeeModule.java
Patch:
@@ -5,7 +5,7 @@
 import javax.inject.Singleton;
 
 @Module(
-    entryPoints = CoffeeApp.class,
+    injects = CoffeeApp.class,
     includes = PumpModule.class
 )
 class DripCoffeeModule {

File: compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
Patch:
@@ -63,7 +63,7 @@ public static String get(ExecutableElement method) {
   }
 
   /** Returns the provided key for {@code method} wrapped by {@code Set}. */
-  public static String getElementKey(ExecutableElement method) {
+  public static String getSetKey(ExecutableElement method) {
     StringBuilder result = new StringBuilder();
     AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
     if (qualifier != null) {

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -309,7 +309,7 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
             break;
           }
           case SET: {
-            String key = GeneratorKeys.getElementKey(providerMethod);
+            String key = GeneratorKeys.getSetKey(providerMethod);
             writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));

File: core/src/main/java/dagger/internal/Keys.java
Patch:
@@ -88,7 +88,7 @@ public static String get(Type type, Annotation annotation) {
    * @param annotations the annotations on a single method, field or parameter.
    *     This array may contain at most one qualifier annotation.
    */
-  public static String getElementKey(Type type, Annotation[] annotations, Object subject) {
+  public static String getSetKey(Type type, Annotation[] annotations, Object subject) {
     Annotation qualifier = extractQualifier(annotations, subject);
     type = boxIfPrimitive(type);
     StringBuilder result = new StringBuilder();

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -132,7 +132,7 @@ public final class KeysTest {
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
+    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
         .isEqualTo("java.util.Set<java.lang.String>");
   }
 
@@ -141,7 +141,7 @@ public final class KeysTest {
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
+    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
         .isEqualTo("@javax.inject.Named(value=foo)/java.util.Set<java.lang.String>");
   }
 

File: compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
Patch:
@@ -63,7 +63,7 @@ public static String get(ExecutableElement method) {
   }
 
   /** Returns the provided key for {@code method} wrapped by {@code Set}. */
-  public static String getElementKey(ExecutableElement method) {
+  public static String getSetKey(ExecutableElement method) {
     StringBuilder result = new StringBuilder();
     AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
     if (qualifier != null) {

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -309,7 +309,7 @@ private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
             break;
           }
           case SET: {
-            String key = GeneratorKeys.getElementKey(providerMethod);
+            String key = GeneratorKeys.getSetKey(providerMethod);
             writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));

File: core/src/main/java/dagger/internal/Keys.java
Patch:
@@ -88,7 +88,7 @@ public static String get(Type type, Annotation annotation) {
    * @param annotations the annotations on a single method, field or parameter.
    *     This array may contain at most one qualifier annotation.
    */
-  public static String getElementKey(Type type, Annotation[] annotations, Object subject) {
+  public static String getSetKey(Type type, Annotation[] annotations, Object subject) {
     Annotation qualifier = extractQualifier(annotations, subject);
     type = boxIfPrimitive(type);
     StringBuilder result = new StringBuilder();

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -132,7 +132,7 @@ public final class KeysTest {
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
+    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
         .isEqualTo("java.util.Set<java.lang.String>");
   }
 
@@ -141,7 +141,7 @@ public final class KeysTest {
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
+    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
         .isEqualTo("@javax.inject.Named(value=foo)/java.util.Set<java.lang.String>");
   }
 

File: core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
Patch:
@@ -97,9 +97,7 @@ private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method meth
     } catch (InstantiationException e) {
       throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
     } catch (IllegalAccessException e) {
-      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
-          + " as it lacks an accessible no-args constructor. This module must be passed"
-          + " in as an instance, or the no-args constructor must be made public.", e);
+      throw new AssertionError();
     }
   }
 

File: androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
Patch:
@@ -23,13 +23,16 @@
 import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
 
 import static dagger.androidmanifest.ModuleGenerator.cleanActivityName;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public final class ModuleGeneratorTest {
   private final ModuleGenerator generator = new ModuleGenerator();
   private final StringWriter stringWriter = new StringWriter();

File: compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
Patch:
@@ -18,9 +18,12 @@
 import java.io.IOException;
 import java.io.StringWriter;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class DotWriterTest {
   private final StringWriter stringWriter = new StringWriter();
   private final DotWriter dotWriter = new DotWriter(stringWriter);

File: compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
Patch:
@@ -21,9 +21,12 @@
 import java.util.Set;
 import javax.inject.Named;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class GraphVisualizerTest {
   private final GraphVisualizer graphVisualizer = new GraphVisualizer();
 

File: core/src/test/java/dagger/ExtensionTest.java
Patch:
@@ -20,10 +20,13 @@
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertNotNull;
 
+@RunWith(JUnit4.class)
 public final class ExtensionTest {
   @Singleton
   static class A {

File: core/src/test/java/dagger/InjectStaticsTest.java
Patch:
@@ -18,9 +18,12 @@
 import javax.inject.Inject;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class InjectStaticsTest {
   @Before public void setUp() {
     InjectsOneField.staticField = null;

File: core/src/test/java/dagger/InjectionOfLazyTest.java
Patch:
@@ -20,13 +20,16 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
 /**
  * Tests of injection of Lazy<T> bindings.
  */
+@RunWith(JUnit4.class)
 public final class InjectionOfLazyTest {
   @Test public void lazyValueCreation() {
     final AtomicInteger counter = new AtomicInteger();

File: core/src/test/java/dagger/LazyInjectionTest.java
Patch:
@@ -17,9 +17,12 @@
 
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class LazyInjectionTest {
   @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
     @Module(entryPoints = LazyEntryPoint.class)

File: core/src/test/java/dagger/MembersInjectorTest.java
Patch:
@@ -19,6 +19,8 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -27,6 +29,7 @@
  * Tests MembersInjector injection, and how object graph features interact with
  * types unconstructable types (types that support members injection only).
  */
+@RunWith(JUnit4.class)
 public final class MembersInjectorTest {
   @Test public void injectMembers() {
     class TestEntryPoint {

File: core/src/test/java/dagger/ProblemDetectorTest.java
Patch:
@@ -17,9 +17,12 @@
 
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public final class ProblemDetectorTest {
   @Test public void atInjectCircularDependenciesDetected() {
     class TestEntryPoint {

File: core/src/test/java/dagger/SetBindingTest.java
Patch:
@@ -27,13 +27,16 @@
 import javax.inject.Named;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
+@RunWith(JUnit4.class)
 public final class SetBindingTest {
   @Test public void multiValueBindings_SingleModule() {
     class TestEntryPoint {

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -25,10 +25,13 @@
 import javax.inject.Named;
 import javax.inject.Provider;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class KeysTest {
   int primitive;
   @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {

File: core/src/test/java/dagger/InjectionTest.java
Patch:
@@ -730,7 +730,7 @@ class TestModule {
   }
 
   static class SingletonLinkedFromExtension {
-    @Inject C c; //singleton
+    @Inject C c; // Singleton.
   }
 
   @Module(complete=false, entryPoints=C.class)
@@ -739,7 +739,6 @@ static class RootModule { }
   @Module(addsTo=RootModule.class, entryPoints=SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
-  // Regression
   @Test public void testSingletonLinkingThroughExtensionGraph() {
     ObjectGraph root = ObjectGraph.create(new RootModule());
     // DO NOT CALL root.get(C.class)) HERE to get forced-linking behaviour from plus();

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -61,7 +61,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes({"dagger.Provides", "dagger.Module"})
+@SupportedAnnotationTypes({ "dagger.Provides", "dagger.Module" })
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -61,7 +61,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("dagger.Provides")
+@SupportedAnnotationTypes({"dagger.Provides", "dagger.Module"})
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
@@ -94,7 +94,7 @@ public final class ProvidesProcessor extends AbstractProcessor {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
           "Could not find types required by provides methods for " + remainingTypes.keySet());
     }
-    return true;
+    return false; // FullGraphProcessor needs an opportunity to process.
   }
 
   private void error(String msg, Element element) {
@@ -146,7 +146,7 @@ private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnviron
       methods.add(providerMethodAsExecutable);
     }
 
-    // catch any stray modules without @Provides since their entry points
+    // Catch any stray modules without @Provides since their entry points
     // should still be registered and a ModuleAdapter should still be written.
     for (Element type : env.getElementsAnnotatedWith(Module.class)) {
       if (type.getKind().equals(ElementKind.CLASS)) {

File: core/src/test/java/dagger/ExtensionWithStateTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -332,6 +332,9 @@ private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInj
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void injectMembers(Object t) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }

File: core/src/main/java/dagger/internal/SetBinding.java
Patch:
@@ -65,7 +65,7 @@ public SetBinding(String key) {
   }
 
   @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException(); // not a member injection binding.
+    throw new UnsupportedOperationException("Cannot inject into a multi-binder Set");
   }
 
   @Override public String toString() {

File: core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
Patch:
@@ -149,7 +149,7 @@ public ProviderMethodBinding(Method method, String key, Object instance) {
     }
 
     @Override public void injectMembers(T t) {
-      throw new UnsupportedOperationException(); // not a member injection binding.
+      throw new AssertionError("Provides method bindings are not MembersInjectors");
     }
 
     @Override public String toString() {

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -332,6 +332,9 @@ private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInj
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void injectMembers(Object t) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -332,6 +332,9 @@ private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInj
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
   }
 
 }

File: core/src/main/java/dagger/internal/Linker.java
Patch:
@@ -332,6 +332,9 @@ private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInj
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
   }
 
 }

File: compiler/src/main/java/dagger/internal/codegen/CodeGen.java
Patch:
@@ -143,6 +143,7 @@ public static void typeToString(final TypeMirror type, final StringBuilder resul
         return null;
       }
       @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        result.append(typeVariable); // TypeVariable.toString() returns the name, like 'T'.
         return null;
       }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {

File: compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
Patch:
@@ -112,7 +112,8 @@ private Set<String> getInjectedClassNames(RoundEnvironment env) {
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      injectedTypeNames.add(element.getEnclosingElement().asType().toString());
+      TypeMirror type = element.getEnclosingElement().asType();
+      injectedTypeNames.add(CodeGen.rawTypeToString(type, '.'));
     }
     return injectedTypeNames;
   }

File: compiler/src/main/java/dagger/internal/codegen/CodeGen.java
Patch:
@@ -143,6 +143,7 @@ public static void typeToString(final TypeMirror type, final StringBuilder resul
         return null;
       }
       @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        result.append(typeVariable); // TypeVariable.toString() returns the name, like 'T'.
         return null;
       }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {

File: compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
Patch:
@@ -112,7 +112,8 @@ private Set<String> getInjectedClassNames(RoundEnvironment env) {
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      injectedTypeNames.add(element.getEnclosingElement().asType().toString());
+      TypeMirror type = element.getEnclosingElement().asType();
+      injectedTypeNames.add(CodeGen.rawTypeToString(type, '.'));
     }
     return injectedTypeNames;
   }

File: compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
Patch:
@@ -250,6 +250,7 @@ private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
       writer.emitEmptyLine();
       writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
+      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
       if (constructor != null) {
         for (VariableElement parameter : constructor.getParameters()) {

File: compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
Patch:
@@ -365,6 +365,7 @@ private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerM
       writer.emitEmptyLine();
       writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
+      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);

File: compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
Patch:
@@ -223,13 +223,15 @@ public final class JavaWriterTest {
     javaWriter.emitPackage("com.squareup");
     javaWriter.emitImports(setOf("javax.inject.Singleton"));
     javaWriter.emitAnnotation("javax.inject.Singleton");
+    javaWriter.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
         + "import javax.inject.Singleton;\n"
         + "\n"
         + "@Singleton\n"
+        + "@SuppressWarnings(\"unchecked\")\n"
         + "class Foo {\n"
         + "}\n");
   }

File: compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
Patch:
@@ -170,8 +170,7 @@ private ExecutableElement findNoArgsConstructor(TypeElement typeElement) {
       }
       ExecutableElement constructor = (ExecutableElement) element;
       if (constructor.getParameters().isEmpty()) {
-        Set<Modifier> modifiers = constructor.getModifiers();
-        if (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) {
+        if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
           return null;
         } else {
           return constructor;

File: compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
Patch:
@@ -53,6 +53,9 @@ public void write(Map<String, Binding<?>> bindings, DotWriter writer) throws IOE
       sourceBinding.getDependencies(dependencies, dependencies);
       for (Binding<?> targetBinding : dependencies) {
         String targetName = namesIndex.get(targetBinding);
+        if (targetName == null) {
+          targetName = "Unbound:" + targetBinding.provideKey;
+        }
         writer.edge(sourceName, targetName);
       }
     }

File: compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
Patch:
@@ -53,6 +53,9 @@ public void write(Map<String, Binding<?>> bindings, DotWriter writer) throws IOE
       sourceBinding.getDependencies(dependencies, dependencies);
       for (Binding<?> targetBinding : dependencies) {
         String targetName = namesIndex.get(targetBinding);
+        if (targetName == null) {
+          targetName = "Unbound:" + targetBinding.provideKey;
+        }
         writer.edge(sourceName, targetName);
       }
     }

File: compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
Patch:
@@ -221,7 +221,7 @@ private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
           typeName);
     }
     if (supertype != null) {
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
           "supertype",
           CodeGen.parameterizedType(Binding.class, CodeGen.rawTypeToString(supertype, '.')),
           JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),

File: compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
Patch:
@@ -221,7 +221,7 @@ private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
           typeName);
     }
     if (supertype != null) {
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
           "supertype",
           CodeGen.parameterizedType(Binding.class, CodeGen.rawTypeToString(supertype, '.')),
           JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),

File: androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
Patch:
@@ -218,8 +218,8 @@ public static void generate(File manifestXml, String moduleName, File baseDir)
   private static void printUsage() {
     System.out.println("Usage: ModuleGenerator manifest module out");
     System.out.println("  manifest: path to AndroidManifest.xml");
-    System.out.println("    module: name of the generated class, like 'ActivitiesModule'.");
-    System.out.println("            May be fully-qualified like 'com.squareup.ActivitiesModule'.");
+    System.out.println("    module: name of the generated class, like 'ManifestModule'.");
+    System.out.println("            May be fully-qualified like 'com.squareup.ManifestModule'.");
     System.out.println("       out: base directory for generated .java source files");
   }
 }

File: androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
Patch:
@@ -30,7 +30,7 @@ public class ModuleGeneratorMojo extends AbstractMojo {
   /**
    * The {@code AndroidManifest.xml} file.
    *
-   * @parameter default-value="ActivitiesModule"
+   * @parameter default-value="ManifestModule"
    * @required
    */
   private String moduleName;

File: androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
Patch:
@@ -218,8 +218,8 @@ public static void generate(File manifestXml, String moduleName, File baseDir)
   private static void printUsage() {
     System.out.println("Usage: ModuleGenerator manifest module out");
     System.out.println("  manifest: path to AndroidManifest.xml");
-    System.out.println("    module: name of the generated class, like 'ActivitiesModule'.");
-    System.out.println("            May be fully-qualified like 'com.squareup.ActivitiesModule'.");
+    System.out.println("    module: name of the generated class, like 'ManifestModule'.");
+    System.out.println("            May be fully-qualified like 'com.squareup.ManifestModule'.");
     System.out.println("       out: base directory for generated .java source files");
   }
 }

File: androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
Patch:
@@ -30,7 +30,7 @@ public class ModuleGeneratorMojo extends AbstractMojo {
   /**
    * The {@code AndroidManifest.xml} file.
    *
-   * @parameter default-value="ActivitiesModule"
+   * @parameter default-value="ManifestModule"
    * @required
    */
   private String moduleName;

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import dagger.OneOf;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -27,6 +26,7 @@
 import javax.inject.Provider;
 import org.junit.Test;
 
+import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 
 public final class KeysTest {
@@ -125,7 +125,7 @@ public final class KeysTest {
     assertThat(Keys.getLazyKey(fieldKey("providerOfTypeAnnotated"))).isNull();
   }
 
-  @Provides @OneOf String elementProvides() { return "foo"; }
+  @Provides(type=SET) String elementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
@@ -134,7 +134,7 @@ public final class KeysTest {
   }
 
   @Named("foo")
-  @Provides @OneOf String qualifiedElementProvides() { return "foo"; }
+  @Provides(type=SET) String qualifiedElementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import dagger.OneOf;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -27,6 +26,7 @@
 import javax.inject.Provider;
 import org.junit.Test;
 
+import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 
 public final class KeysTest {
@@ -125,7 +125,7 @@ public final class KeysTest {
     assertThat(Keys.getLazyKey(fieldKey("providerOfTypeAnnotated"))).isNull();
   }
 
-  @Provides @OneOf String elementProvides() { return "foo"; }
+  @Provides(type=SET) String elementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
@@ -134,7 +134,7 @@ public final class KeysTest {
   }
 
   @Named("foo")
-  @Provides @OneOf String qualifiedElementProvides() { return "foo"; }
+  @Provides(type=SET) String qualifiedElementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});

File: compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
Patch:
@@ -97,7 +97,7 @@ private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule) {
         // Gather the entry points from the annotation.
         for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
           linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
-              module.getQualifiedName().toString());
+              module.getQualifiedName().toString(), false);
         }
 
         // Gather the static injections.

File: core/src/main/java/dagger/ObjectGraph.java
Patch:
@@ -164,7 +164,7 @@ private void linkStaticInjections() {
 
   private void linkEntryPoints() {
     for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
-      linker.requestEntryPoint(entry.getKey(), entry.getValue());
+      linker.requestBinding(entry.getKey(), entry.getValue(), false);
     }
   }
 
@@ -257,10 +257,10 @@ private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
     }
 
     synchronized (linker) {
-      Binding<?> binding = linker.requestBinding(key, moduleClass);
+      Binding<?> binding = linker.requestBinding(key, moduleClass, false);
       if (binding == null || !binding.isLinked()) {
         linker.linkRequested();
-        binding = linker.requestBinding(key, moduleClass);
+        binding = linker.requestBinding(key, moduleClass, false);
       }
       return binding;
     }

File: core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
Patch:
@@ -81,7 +81,7 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
       }
     }
     if (supertype != null && supertypeBinding == null) {
-      supertypeBinding = (Binding<? super T>) linker.requestBinding(keys[k], membersKey);
+      supertypeBinding = (Binding<? super T>) linker.requestBinding(keys[k], membersKey, false);
     }
   }
 

File: compiler/src/it/extension-graph/src/main/java/test/TestApp.java
Patch:
@@ -30,14 +30,14 @@ class TestApp implements Runnable {
 
   public static void main(String[] args) {
     ObjectGraph root = ObjectGraph.create(new RootModule());
-    ObjectGraph extension = root.extend(new ExtensionModule());
+    ObjectGraph extension = root.plus(new ExtensionModule());
     extension.get(TestApp.class).run();
   }
   
   @Module(entryPoints = { A.class, B.class })
   static class RootModule { }
 
-  @Module(augments=RootModule.class, entryPoints = { C.class, TestApp.class })
+  @Module(addsTo=RootModule.class, entryPoints = { C.class, TestApp.class })
   static class ExtensionModule { }
 
   @Singleton

File: compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
Patch:
@@ -37,8 +37,8 @@ public CompileTimePlugin(ProcessingEnvironment processingEnv) {
     this.processingEnv = processingEnv;
   }
 
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) throws ClassNotFoundException {
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {

File: compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
Patch:
@@ -144,7 +144,7 @@ private void collectIncludesRecursively(TypeElement module, Map<String, TypeElem
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     List<Object> seedModules = new ArrayList<Object>();
     seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
-    if (!annotation.get("augments").equals(Void.class)) seedModules.add(annotation.get("augments"));
+    if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
     for (Object include : seedModules) {
       if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,

File: core/src/main/java/dagger/internal/ModuleAdapter.java
Patch:
@@ -23,7 +23,6 @@
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
-
   public final String[] entryPoints;
   public final Class<?>[] staticInjections;
   public final boolean overrides;

File: core/src/main/java/dagger/internal/StaticInjection.java
Patch:
@@ -19,8 +19,6 @@
 
 /**
  * Injects the static fields of a class.
- *
- * @author Jesse Wilson
  */
 public abstract class StaticInjection {
 

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -29,9 +29,6 @@
 
 import static org.fest.assertions.Assertions.assertThat;
 
-/**
- * @author Jesse Wilson
- */
 public final class KeysTest {
   int primitive;
   @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {

File: compiler/src/it/extension-graph/src/main/java/test/TestApp.java
Patch:
@@ -30,14 +30,14 @@ class TestApp implements Runnable {
 
   public static void main(String[] args) {
     ObjectGraph root = ObjectGraph.create(new RootModule());
-    ObjectGraph extension = root.extend(new ExtensionModule());
+    ObjectGraph extension = root.plus(new ExtensionModule());
     extension.get(TestApp.class).run();
   }
   
   @Module(entryPoints = { A.class, B.class })
   static class RootModule { }
 
-  @Module(augments=RootModule.class, entryPoints = { C.class, TestApp.class })
+  @Module(addsTo=RootModule.class, entryPoints = { C.class, TestApp.class })
   static class ExtensionModule { }
 
   @Singleton

File: compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
Patch:
@@ -37,8 +37,8 @@ public CompileTimePlugin(ProcessingEnvironment processingEnv) {
     this.processingEnv = processingEnv;
   }
 
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) throws ClassNotFoundException {
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {

File: compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
Patch:
@@ -144,7 +144,7 @@ private void collectIncludesRecursively(TypeElement module, Map<String, TypeElem
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     List<Object> seedModules = new ArrayList<Object>();
     seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
-    if (!annotation.get("augments").equals(Void.class)) seedModules.add(annotation.get("augments"));
+    if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
     for (Object include : seedModules) {
       if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,

File: core/src/main/java/dagger/internal/ModuleAdapter.java
Patch:
@@ -23,7 +23,6 @@
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
-
   public final String[] entryPoints;
   public final Class<?>[] staticInjections;
   public final boolean overrides;

File: core/src/main/java/dagger/internal/StaticInjection.java
Patch:
@@ -19,8 +19,6 @@
 
 /**
  * Injects the static fields of a class.
- *
- * @author Jesse Wilson
  */
 public abstract class StaticInjection {
 

File: core/src/test/java/dagger/internal/KeysTest.java
Patch:
@@ -29,9 +29,6 @@
 
 import static org.fest.assertions.Assertions.assertThat;
 
-/**
- * @author Jesse Wilson
- */
 public final class KeysTest {
   int primitive;
   @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {

File: androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
Patch:
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,8 +95,9 @@ void generate(String packageName, List<String> nameReferences, String moduleName
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new HashMap<String, Object>();
+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
+    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);

File: core/src/main/java/com/squareup/objectgraph/Module.java
Patch:
@@ -48,6 +48,7 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
+   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default false;
+  boolean complete() default true;
 }

File: core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
Patch:
@@ -60,7 +60,7 @@ private void validateComplete(TypeElement rootModule) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectChildModulesRecursively(rootModule, allModules);
 
-    Linker linker = new BuildTimeLinker(processingEnv);
+    Linker linker = new BuildTimeLinker(processingEnv, rootModule.getQualifiedName().toString());
     Map<String, ProviderMethodBinding> baseBindings
         = new LinkedHashMap<String, ProviderMethodBinding>();
     Map<String, ProviderMethodBinding> overrideBindings

File: androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
Patch:
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,8 +95,9 @@ void generate(String packageName, List<String> nameReferences, String moduleName
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new HashMap<String, Object>();
+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
+    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);

File: core/src/main/java/com/squareup/objectgraph/Module.java
Patch:
@@ -48,6 +48,7 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
+   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default false;
+  boolean complete() default true;
 }

File: core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
Patch:
@@ -60,7 +60,7 @@ private void validateComplete(TypeElement rootModule) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectChildModulesRecursively(rootModule, allModules);
 
-    Linker linker = new BuildTimeLinker(processingEnv);
+    Linker linker = new BuildTimeLinker(processingEnv, rootModule.getQualifiedName().toString());
     Map<String, ProviderMethodBinding> baseBindings
         = new LinkedHashMap<String, ProviderMethodBinding>();
     Map<String, ProviderMethodBinding> overrideBindings

File: androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
Patch:
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedHashMap;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,9 +95,8 @@ void generate(String packageName, List<String> nameReferences, String moduleName
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
+    Map<String, Object> attributes = new HashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
-    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);

File: core/src/main/java/com/squareup/objectgraph/Module.java
Patch:
@@ -48,7 +48,6 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
-   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default true;
+  boolean complete() default false;
 }

File: androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
Patch:
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedHashMap;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,9 +95,8 @@ void generate(String packageName, List<String> nameReferences, String moduleName
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
+    Map<String, Object> attributes = new HashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
-    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);

File: core/src/main/java/com/squareup/objectgraph/Module.java
Patch:
@@ -48,7 +48,6 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
-   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default true;
+  boolean complete() default false;
 }

File: androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
Patch:
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,8 +95,9 @@ void generate(String packageName, List<String> nameReferences, String moduleName
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new HashMap<String, Object>();
+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
+    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);

File: core/src/main/java/com/squareup/objectgraph/Module.java
Patch:
@@ -48,6 +48,7 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
+   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default false;
+  boolean complete() default true;
 }

File: androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
Patch:
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,8 +95,9 @@ void generate(String packageName, List<String> nameReferences, String moduleName
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new HashMap<String, Object>();
+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
+    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);

File: core/src/main/java/com/squareup/objectgraph/Module.java
Patch:
@@ -48,6 +48,7 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
+   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default false;
+  boolean complete() default true;
 }

File: src/test/java/com/squareup/injector/InjectionTest.java
Patch:
@@ -420,10 +420,10 @@ class TestModule {
   static class ExtendsParameterizedType extends AbstractList<Integer> {
     @Inject String string;
     @Override public Integer get(int i) {
-      return i;
+      throw new AssertionError();
     }
     @Override public int size() {
-      return 5;
+      throw new AssertionError();
     }
   }
 

File: src/test/java/com/squareup/injector/InjectionTest.java
Patch:
@@ -420,10 +420,10 @@ class TestModule {
   static class ExtendsParameterizedType extends AbstractList<Integer> {
     @Inject String string;
     @Override public Integer get(int i) {
-      return i;
+      throw new AssertionError();
     }
     @Override public int size() {
-      return 5;
+      throw new AssertionError();
     }
   }
 

File: src/main/java/com/squareup/injector/internal/ModuleAdapter.java
Patch:
@@ -23,5 +23,5 @@
  * @author Jesse Wilson
  */
 public interface ModuleAdapter<T> {
-  Map<String, Binding<?>> getBindings(T t);
+  void getBindings(T t, Map<String, Binding<?>> map);
 }

File: src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
Patch:
@@ -30,7 +30,7 @@ final class ProviderMethodBinding<T> extends Binding<T> {
   private final Object instance;
 
   public ProviderMethodBinding(Method method, String key, Object instance) {
-    super(key, method.isAnnotationPresent(Singleton.class), false, method);
+    super(key, null, method.isAnnotationPresent(Singleton.class), method);
     this.method = method;
     this.instance = instance;
     method.setAccessible(true);
@@ -42,7 +42,7 @@ public ProviderMethodBinding(Method method, String key, Object instance) {
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-      parameters[i] = linker.requestBinding(key, method, false);
+      parameters[i] = linker.requestBinding(key, method);
     }
   }
 

File: src/main/java/com/squareup/injector/internal/StaticInjection.java
Patch:
@@ -55,7 +55,7 @@ public void attach(Linker linker) {
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field, false);
+      bindings[i] = linker.requestBinding(key, field);
     }
   }
 

File: src/test/java/com/squareup/injector/internal/KeysTest.java
Patch:
@@ -104,7 +104,7 @@ public final class KeysTest {
   @Named("/@") String injectedType;
   @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
     assertThat(Keys.getDelegateKey(fieldKey("membersInjectorOfType")))
-        .isEqualTo(fieldKey("injectedType"));
+        .isEqualTo("members/java.lang.String");
   }
 
   private String fieldKey(String fieldName) throws NoSuchFieldException {

File: src/main/java/com/squareup/injector/internal/ModuleAdapter.java
Patch:
@@ -23,5 +23,5 @@
  * @author Jesse Wilson
  */
 public interface ModuleAdapter<T> {
-  Map<String, Binding<?>> getBindings(T t);
+  void getBindings(T t, Map<String, Binding<?>> map);
 }

File: src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
Patch:
@@ -30,7 +30,7 @@ final class ProviderMethodBinding<T> extends Binding<T> {
   private final Object instance;
 
   public ProviderMethodBinding(Method method, String key, Object instance) {
-    super(key, method.isAnnotationPresent(Singleton.class), false, method);
+    super(key, null, method.isAnnotationPresent(Singleton.class), method);
     this.method = method;
     this.instance = instance;
     method.setAccessible(true);
@@ -42,7 +42,7 @@ public ProviderMethodBinding(Method method, String key, Object instance) {
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-      parameters[i] = linker.requestBinding(key, method, false);
+      parameters[i] = linker.requestBinding(key, method);
     }
   }
 

File: src/main/java/com/squareup/injector/internal/StaticInjection.java
Patch:
@@ -55,7 +55,7 @@ public void attach(Linker linker) {
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field, false);
+      bindings[i] = linker.requestBinding(key, field);
     }
   }
 

File: src/test/java/com/squareup/injector/internal/KeysTest.java
Patch:
@@ -104,7 +104,7 @@ public final class KeysTest {
   @Named("/@") String injectedType;
   @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
     assertThat(Keys.getDelegateKey(fieldKey("membersInjectorOfType")))
-        .isEqualTo(fieldKey("injectedType"));
+        .isEqualTo("members/java.lang.String");
   }
 
   private String fieldKey(String fieldName) throws NoSuchFieldException {

File: src/main/java/com/squareup/injector/internal/Binding.java
Patch:
@@ -27,6 +27,7 @@ public abstract class Binding<T> implements Provider<T>, MembersInjector<T>,
   public final boolean singleton;
   public final boolean injectMembersOnly;
   public final Object requiredBy;
+  public boolean linked;
 
   protected Binding(String key, boolean singleton, boolean injectMembersOnly, Object requiredBy) {
     if (singleton && injectMembersOnly) {

File: src/main/java/com/squareup/injector/internal/StaticInjection.java
Patch:
@@ -54,8 +54,8 @@ public void attach(Linker linker) {
     bindings = new Binding<?>[fields.length];
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
-      String fieldKey = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(fieldKey, field);
+      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(key, field, false);
     }
   }
 

File: src/test/java/com/squareup/injector/GuiceSupportTest.java
Patch:
@@ -40,14 +40,14 @@ static class StringModule {
 
   @Test public void testGuiceProviderGet() {
     GuiceInjector injector = new GuiceInjector();
-    DependencyGraph.get(injector).inject(injector);
+    ObjectGraph.get(injector).inject(injector);
     Injectable provided = injector.provider.get();
     assertThat(provided.string).isEqualTo("injected");
   }
 
   @Test public void testGuiceMembersInjector() {
     GuiceInjector injector = new GuiceInjector();
-    DependencyGraph.get(injector).inject(injector);
+    ObjectGraph.get(injector).inject(injector);
     Injectable injectable = new Injectable();
     injector.membersInjector.injectMembers(injectable);
     assertThat(injectable.string).isEqualTo("injected");

File: src/main/java/com/squareup/injector/internal/StaticInjection.java
Patch:
@@ -54,8 +54,8 @@ public void attach(Linker linker) {
     bindings = new Binding<?>[fields.length];
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
-      String fieldKey = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(fieldKey, field);
+      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(key, field, false);
     }
   }
 

File: src/test/java/com/squareup/injector/GuiceSupportTest.java
Patch:
@@ -40,14 +40,14 @@ static class StringModule {
 
   @Test public void testGuiceProviderGet() {
     GuiceInjector injector = new GuiceInjector();
-    DependencyGraph.get(injector).inject(injector);
+    ObjectGraph.get(injector).inject(injector);
     Injectable provided = injector.provider.get();
     assertThat(provided.string).isEqualTo("injected");
   }
 
   @Test public void testGuiceMembersInjector() {
     GuiceInjector injector = new GuiceInjector();
-    DependencyGraph.get(injector).inject(injector);
+    ObjectGraph.get(injector).inject(injector);
     Injectable injectable = new Injectable();
     injector.membersInjector.injectMembers(injectable);
     assertThat(injectable.string).isEqualTo("injected");

File: src/main/java/com/squareup/codegen/JavaWriter.java
Patch:
@@ -115,7 +115,8 @@ private void type(String type) throws IOException {
       String imported;
       if ((imported = importedTypes.get(name)) != null) {
         out.write(imported);
-      } else if (name.startsWith(packagePrefix)) {
+      } else if (name.startsWith(packagePrefix)
+          && name.indexOf('.', packagePrefix.length()) == -1) {
         out.write(name.substring(packagePrefix.length()));
       } else if (name.startsWith("java.lang.")) {
         out.write(name.substring("java.lang.".length()));

File: src/main/java/com/squareup/codegen/JavaWriter.java
Patch:
@@ -115,7 +115,8 @@ private void type(String type) throws IOException {
       String imported;
       if ((imported = importedTypes.get(name)) != null) {
         out.write(imported);
-      } else if (name.startsWith(packagePrefix)) {
+      } else if (name.startsWith(packagePrefix)
+          && name.indexOf('.', packagePrefix.length()) == -1) {
         out.write(name.substring(packagePrefix.length()));
       } else if (name.startsWith("java.lang.")) {
         out.write(name.substring("java.lang.".length()));

File: src/test/java/com/squareup/codegen/JavaWriterTest.java
Patch:
@@ -91,7 +91,7 @@ public final class JavaWriterTest {
   @Test public void constructorDeclaration() throws IOException {
     javaWriter.addPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod(null, "Foo", Modifier.PUBLIC, "java.lang.String", "s");
+    javaWriter.beginMethod(null, "com.squareup.Foo", Modifier.PUBLIC, "java.lang.String", "s");
     javaWriter.endMethod();
     javaWriter.endType();
     assertCode(""

File: src/test/java/com/squareup/codegen/JavaWriterTest.java
Patch:
@@ -91,7 +91,7 @@ public final class JavaWriterTest {
   @Test public void constructorDeclaration() throws IOException {
     javaWriter.addPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod(null, "Foo", Modifier.PUBLIC, "java.lang.String", "s");
+    javaWriter.beginMethod(null, "com.squareup.Foo", Modifier.PUBLIC, "java.lang.String", "s");
     javaWriter.endMethod();
     javaWriter.endType();
     assertCode(""

File: src/main/java/com/squareup/injector/Injector.java
Patch:
@@ -27,6 +27,6 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE) public @interface Injector {
-  Class<?>[] modules() default {};
-  Class<?>[] entryPoints() default {};
+  Class<?>[] modules() default { };
+  Class<?>[] entryPoints() default { };
 }

File: src/main/java/com/squareup/injector/internal/Linker.java
Patch:
@@ -160,7 +160,7 @@ private <T> void putBinding(final Binding<T> binding) {
         @Override public void injectMembers(T t) {
           binding.injectMembers(t);
         }
-        @SuppressWarnings("unchecked") // 'onlyInstance is either UNINITIALIZED' or a 'T'.
+        @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
         @Override public T get() {
           if (onlyInstance == UNINITIALIZED) {
             onlyInstance = binding.get();

File: src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
Patch:
@@ -15,9 +15,6 @@
  */
 package com.squareup.injector.internal;
 
-import com.squareup.injector.internal.Binding;
-import com.squareup.injector.internal.Keys;
-import com.squareup.injector.internal.Linker;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: src/main/java/com/squareup/codegen/CodeGen.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/codegen/GeneratorKeys.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/codegen/InjectProcessor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/codegen/ProvidesProcessor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/MembersInjector.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/Provides.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2007 Google Inc.
  * Copyright (C) 2012 Square, Inc.
  *

File: src/main/java/com/squareup/injector/internal/Binding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/internal/BuiltInBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/internal/ConstructorBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/internal/Keys.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/internal/LruCache.java
Patch:
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.injector.internal;
 
 import java.util.LinkedHashMap;

File: src/main/java/com/squareup/injector/internal/ModuleAdapter.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
 import com.squareup.injector.internal.Binding;
 import com.squareup.injector.internal.Keys;

File: src/main/java/com/squareup/codegen/GeneratorKeys.java
Patch:
@@ -67,7 +67,7 @@ private static void qualifierToString(AnnotationMirror qualifier, StringBuilder
     result.append('@');
     result.append(((TypeElement) qualifier.getAnnotationType().asElement()).getQualifiedName());
     result.append('(');
-    for (Map.Entry<? extends ExecutableElement,? extends AnnotationValue> entry
+    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
         : qualifier.getElementValues().entrySet()) {
       result.append(entry.getKey().getSimpleName());
       result.append('=');

File: src/test/java/com/squareup/codegen/JavaWriterTest.java
Patch:
@@ -179,7 +179,7 @@ public final class JavaWriterTest {
     javaWriter.beginControlFlow("try");
     javaWriter.statement("int j = s.length() + %s", 13);
     javaWriter.nextControlFlow("catch (RuntimeException e)");
-    javaWriter.statement("%s.printStackTrace()", "e");
+    javaWriter.statement("e.printStackTrace()");
     javaWriter.nextControlFlow("finally");
     javaWriter.statement("int k = %s", 13);
     javaWriter.endControlFlow();

File: src/main/java/com/squareup/injector/internal/LruCache.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;

File: src/main/java/com/squareup/injector/Injector.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import javax.inject.Provider;
 
 /**
  * Dependency injector.
@@ -36,7 +35,7 @@
  *   <li>Injection of {@code @Provides} method parameters.
  *   <li>{@code @Provides} methods annotated {@code @Singleton}.
  *   <li>Constructor-injected classes annotated {@code @Singleton}.
- *   <li>Injection of {@link Provider}s.
+ *   <li>Injection of {@link javax.inject.Provider}s.
  *   <li>Qualifier annotations on injected parameters and fields.
  *   <li>JSR 330 annotations.
  * </ul>

File: src/main/java/com/squareup/injector/LruCache.java
Patch:
@@ -201,7 +201,8 @@ public final V remove(K key) {
    *     this removal was caused by a {@link #put}. Otherwise it was caused by
    *     an eviction or a {@link #remove}.
    */
-  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
+  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
+  }
 
   /**
    * Called after a cache miss to compute a value for the corresponding key.

File: src/main/java/com/squareup/injector/Provides.java
Patch:
@@ -31,4 +31,5 @@
  * @author Bob Lee
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
-public @interface Provides {}
+public @interface Provides {
+}

File: src/main/java/com/squareup/injector/Modules.java
Patch:
@@ -27,6 +27,9 @@
  * @author Jesse Wilson
  */
 public final class Modules {
+  private Modules() {
+  }
+
   /**
    * Returns a map containing the bindings in {@code object}.
    *

File: src/main/java/com/squareup/codegen/JavaWriter.java
Patch:
@@ -182,7 +182,7 @@ public void beginMethod(String returnType, String name, int modifiers, String...
   }
 
   /**
-   * @param s a code statement like "int i = 5". Shouldn't contain any trialing
+   * @param s a code statement like "int i = 5". Shouldn't contain a trailing
    * semicolon or newline character.
    */
   public void statement(String s) throws IOException {

