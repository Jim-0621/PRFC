File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -2995,7 +2995,7 @@ public ErrorCode isAllowUserMessage(String targetUser, String fromUser) {
 
         if (mDisableStrangerChat) {
             //在禁止私聊时，是否是允许私聊的用户id
-            if(mAllowStrangerChatSet.contains(targetUser)) {
+            if(mAllowStrangerChatSet.contains(targetUser) || mAllowStrangerChatSet.contains(fromUser)) {
                 return ErrorCode.ERROR_CODE_SUCCESS;
             }
 

File: common/src/main/java/io/moquette/spi/impl/security/AES.java
Patch:
@@ -176,7 +176,7 @@ public static byte[] AESDecrypt(byte[] sSrc, byte[] aesKey, boolean checkTime, b
                     //2018.1.1 0:0:0 以来的小时数
                     int curhour = (int) ((System.currentTimeMillis()/1000 - 1514736000)/3600);
 
-                    if (curhour - hours > 24 && checkTime) {
+                    if (Math.abs(curhour - hours)  > 24 && checkTime) {
                         if(invalidTime != null) {
                             invalidTime[0] = true;
                         }

File: broker/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -534,7 +534,7 @@ private static Result<MqttConnectPayload> decodeConnectionPayload(
 
         final MqttProperties willProperties;
         if (mqttConnectVariableHeader.isWillFlag()) {
-            if (mqttVersion.protocolLevel() >= MqttVersion.MQTT_5.protocolLevel()) {
+            if (mqttVersion.protocolLevel() <= MqttVersion.MQTT_5.protocolLevel()) {
                 final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
                 willProperties = propertiesResult.value;
                 numberOfBytesConsumed += propertiesResult.numberOfBytesConsumed;

File: broker/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
Patch:
@@ -534,7 +534,7 @@ private static Result<MqttConnectPayload> decodeConnectionPayload(
 
         final MqttProperties willProperties;
         if (mqttConnectVariableHeader.isWillFlag()) {
-            if (mqttVersion.protocolLevel() <= MqttVersion.MQTT_5.protocolLevel()) {
+            if (mqttVersion.protocolLevel() >= MqttVersion.MQTT_5.protocolLevel()) {
                 final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
                 willProperties = propertiesResult.value;
                 numberOfBytesConsumed += propertiesResult.numberOfBytesConsumed;

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -1439,7 +1439,7 @@ public ErrorCode quitGroup(String operator, String groupId, boolean admin) {
             }
             return ErrorCode.ERROR_CODE_NOT_EXIST;
         }
-        
+
         if(!admin && groupInfo.getType() == ProtoConstants.GroupType.GroupType_Organization) {
             return ErrorCode.ERROR_CODE_NOT_RIGHT;
         }
@@ -1486,7 +1486,7 @@ public void clearUserGroups(String userId) {
         int[] removedCount = new int[1];
         for (String groupId : groupIds) {
             removedCount[0] = 0;
-            ErrorCode errorCode = quitGroup(userId, groupId);
+            ErrorCode errorCode = quitGroup(userId, groupId, true);
             LOG.info("clear user {} group {} result {}", userId, groupId, errorCode);
         }
     }

File: broker/src/main/java/win/liyufan/im/HttpUtils.java
Patch:
@@ -87,8 +87,8 @@ public void onFailure(Call call, IOException e) {
                 }
                 System.out.println(logText);
                 e.printStackTrace();
-                LOG.info(logText);
-                LOG.info("POST to {} with data {} failure", url, jsonStr);
+                LOG.error(logText);
+                LOG.error("POST to {} with data {} failure", url, jsonStr);
                 if(httpCallback != null) {
                     httpCallback.onFailure(-1, e.getMessage());
                 }

File: common/src/main/java/cn/wildfirechat/common/ErrorCode.java
Patch:
@@ -29,6 +29,7 @@ public enum ErrorCode {
 
     //Group error
     ERROR_CODE_GROUP_ALREADY_EXIST(11, "group already exist"),
+    ERROR_CODE_ALREADY_IN_GROUP(12, "member already in group"),
 
     //user error
     ERROR_CODE_FRIEND_ALREADY_REQUEST(16, "already send request"),

File: sdk/src/main/java/cn/wildfirechat/sdk/Main.java
Patch:
@@ -860,6 +860,7 @@ static void testChatroom() throws Exception {
             System.exit(-1);
         }
 
+        Thread.sleep(1000);
         getChatroomInfoIMResult = ChatroomAdmin.getChatroomInfo(chatroomId);
         if (getChatroomInfoIMResult != null && getChatroomInfoIMResult.getErrorCode() == ErrorCode.ERROR_CODE_SUCCESS && getChatroomInfoIMResult.getResult().getState() == ProtoConstants.ChatroomState.Chatroom_State_End) {
             System.out.println("chatroom destroyed!");

File: broker/src/main/java/com/xiaoleilu/loServer/action/channel/ChannelAction.java
Patch:
@@ -84,7 +84,7 @@ public ErrorCode preAction(Request request, Response response) {
         }
         
         if (StringUtil.isNullOrEmpty(channelInfo.getSecret())) {
-            return ErrorCode.ERROR_CODE_NOT_RIGHT;
+            return ErrorCode.ERROR_CODE_CHANNEL_NO_SECRET;
         }
 
         String str = nonce + "|" + channelInfo.getSecret() + "|" + timestamp;

File: common/src/main/java/cn/wildfirechat/common/ErrorCode.java
Patch:
@@ -49,6 +49,7 @@ public enum ErrorCode {
     ERROR_CODE_WS_NOT_CONFIGURED_CORRECTLY(28, "ws not configured correctly"),
     ERROR_CODE_CONFERENCE_ROOM_NOT_EXIST(60, "conference room not exist"),
 
+    ERROR_CODE_CHANNEL_NO_SECRET(237, "channel no secret"),
     ERROR_CODE_USER_NOT_PREPARED(238, "user not prepared"),
     ERROR_CODE_API_NOT_SIGNED(239, "api not signed or sign parameter not completion"),
     ERROR_CODE_GROUP_EXCEED_MAX_MEMBER_COUNT(240, "group exceed max member count"),

File: common/src/main/java/cn/wildfirechat/common/ErrorCode.java
Patch:
@@ -20,6 +20,7 @@ public enum ErrorCode {
 
     //Auth error
     ERROR_CODE_TOKEN_ERROR(6, "token error"),
+    ERROR_CODE_KICKED_OFF(7, "kicked off"),
     ERROR_CODE_USER_FORBIDDEN(8, "user forbidden"),
 
     //Message error

File: broker/src/main/java/win/liyufan/im/SensitiveFilter.java
Patch:
@@ -31,12 +31,12 @@ public Set<String> getSensitiveWords(String text,MatchType matchType){
             return sensitiveWords;
         }
 
-        String orignalText = text;
+        String originalText = text;
         text = text.toLowerCase();
         for(int i=0;i<text.length();i++){
             int sensitiveWordLength = getSensitiveWordLength(text, i, matchType);
             if(sensitiveWordLength>0){
-                String sensitiveWord = orignalText.substring(i, i + sensitiveWordLength);
+                String sensitiveWord = originalText.substring(i, i + sensitiveWordLength);
                 sensitiveWords.add(sensitiveWord);
                 if(matchType==MatchType.MIN_MATCH){
                     break;

File: broker/src/main/java/com/xiaoleilu/loServer/handler/Response.java
Patch:
@@ -357,8 +357,8 @@ private DefaultHttpResponse toDefaultHttpResponse() {
 		final DefaultHttpResponse defaultHttpResponse = new DefaultHttpResponse(httpVersion, status);
 
 		// headers
-		final HttpHeaders httpHeaders = defaultHttpResponse.headers().add(headers);
-
+		HttpHeaders httpHeaders = defaultHttpResponse.headers().add(headers);
+        httpHeaders.set(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);
 		// Cookies
 		for (Cookie cookie : cookies) {
 			httpHeaders.add(HttpHeaderNames.SET_COOKIE.toString(), ServerCookieEncoder.LAX.encode(cookie));

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/AddGroupMemberAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/DismissGroupAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/KickoffGroupMemberAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/ModifyGroupInfoAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/ModifyGroupMemberAliasAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/QuitGroupMemberAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: broker/src/main/java/com/xiaoleilu/loServer/action/robot/TransferGroupAction.java
Patch:
@@ -73,7 +73,7 @@ public Executor getResponseExecutor() {
                             ctx.executor().execute(command);
                         };
                     }
-                }, false, 1);
+                }, false);
                 return false;
             } else {
                 response.setStatus(HttpResponseStatus.OK);

File: common/src/main/java/cn/wildfirechat/common/APIPath.java
Patch:
@@ -77,7 +77,7 @@ public interface APIPath {
     String Robot_User_Info = "/robot/user_info";
     String Robot_Message_Send = "/robot/message/send";
     String Robot_Verify_Application_User = "/robot/user/verify";
-    
+
     String Robot_Group_Member_Add = "/robot/group/member/add";
     String Robot_Group_Allow_Member = "/robot/group/manager/allow";
     String Robot_Create_Group = "/robot/group/create";

File: broker/src/main/java/io/moquette/spi/IMessagesStore.java
Patch:
@@ -159,7 +159,6 @@ public String toString() {
     WFCMessage.PullMessageResult fetchChatroomMessage(String fromUser, String chatroomId, String exceptClientId, long fromMessageId);
 
     ErrorCode verifyToken(String userId, String token, List<String> serverIPs, List<Integer> ports);
-    ErrorCode login(String name, String password, List<String> userIdRet);
 
     List<FriendData> getFriendList(String userId, String clientId, long version);
     void clearUserFriend(String userId);

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -1469,8 +1469,8 @@ public ErrorCode recallMessage(long messageUid, String operatorId, String client
             }
 
             String searchContent = message.getContent().getSearchableContent() == null ? "" : message.getContent().getSearchableContent();
-            String cont = message.getContent().getContent() == null ? "" : message.getContent().getContent();
-            String extra = message.getContent().getExtra() == null ? "" : message.getContent().getExtra();
+            String cont = message.getContent().getContent() == null ? "" : message.getContent().getContent().replace("\"", "\\\"");
+            String extra = message.getContent().getExtra() == null ? "" : message.getContent().getExtra().replace("\"", "\\\"");
             String recalledContent = "{\"s\":\"" + message.getFromUser() +  "\",\"ts\":" + message.getServerTimestamp() +  ",\"t\":" + message.getContent().getType() + ",\"sc\":\"" + searchContent + "\",\"c\":\"" + cont + "\",\"e\":\"" + extra  + "\"}";
 
             message = message.toBuilder().setContent(message.getContent().toBuilder().setContent(operatorId).setType(80).clearSearchableContent().setData(ByteString.copyFrom(String.valueOf(messageUid).getBytes())).setExtra(recalledContent).build()).build();

File: broker/src/main/java/io/moquette/imhandler/GroupHandler.java
Patch:
@@ -19,6 +19,8 @@ abstract public class GroupHandler<T> extends IMHandler<T> {
     protected void sendGroupNotification(String fromUser, String targetId, List<Integer> lines, WFCMessage.MessageContent content) {
         if (lines == null) {
             lines = new ArrayList<>();
+        } else {
+            lines = new ArrayList<>(lines);
         }
 
         if (lines.isEmpty()) {

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -2273,8 +2273,6 @@ public ErrorCode handleFriendRequest(String userId, WFCMessage.HandleFriendReque
     public ErrorCode blackUserRequest(String fromUser, String targetUserId, int state, long[] heads) {
         if (state == 2) {
             state = 1;
-        } else {
-            state = 0;
         }
 
         HazelcastInstance hzInstance = m_Server.getHazelcastInstance();

File: broker/src/main/java/io/moquette/spi/impl/MessagesPublisher.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.moquette.spi.impl;
 
+import cn.wildfirechat.pojos.OutputMessageData;
 import cn.wildfirechat.proto.ProtoConstants;
 import cn.wildfirechat.proto.WFCMessage;
 import cn.wildfirechat.push.PushServer;

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -1591,7 +1591,7 @@ public void updateUserOnlineSetting(MemorySessionStore.Session session, boolean
             return;
         }
 
-        if (session.getPlatform() == Platform_Linux || session.getPlatform() == Platform_Windows || session.getPlatform() == Platform_OSX) {
+        if (session.getPlatform() == Platform_LINUX || session.getPlatform() == Platform_Windows || session.getPlatform() == Platform_OSX) {
             updateUserSettings(session.username, WFCMessage.ModifyUserSettingReq.newBuilder().setScope(kUserSettingPCOnline).setKey("PC").setValue(online ? (System.currentTimeMillis()  + "|"  + session.getPlatform() + "|" + session.getClientID() + "|" + session.getPhoneName()) : "").build());
         } else {
             String value = null;
@@ -1601,7 +1601,7 @@ public void updateUserOnlineSetting(MemorySessionStore.Session session, boolean
                 }
 
                 switch (s.getPlatform()) {
-                    case Platform_Linux:
+                    case Platform_LINUX:
                     case Platform_Windows:
                     case Platform_OSX:
                         value = System.currentTimeMillis() + "|" + s.getPlatform() + "|" + s.getClientID() + "|" + s.getPhoneName();

File: broker/src/main/java/io/moquette/persistence/MemorySessionStore.java
Patch:
@@ -381,8 +381,8 @@ public Session updateOrCreateUserSession(String username, String clientID, int p
                             if (s.getPlatform() == ProtoConstants.Platform.Platform_Android || s.getPlatform() == ProtoConstants.Platform.Platform_iOS) {
                                 remove = true;
                             }
-                        } else if(platform == ProtoConstants.Platform.Platform_OSX || platform == ProtoConstants.Platform.Platform_Windows || platform == ProtoConstants.Platform.Platform_Linux) {
-                            if (s.getPlatform() == ProtoConstants.Platform.Platform_OSX || s.getPlatform() == ProtoConstants.Platform.Platform_Windows || platform == ProtoConstants.Platform.Platform_Linux) {
+                        } else if(platform == ProtoConstants.Platform.Platform_OSX || platform == ProtoConstants.Platform.Platform_Windows || platform == ProtoConstants.Platform.Platform_LINUX) {
+                            if (s.getPlatform() == ProtoConstants.Platform.Platform_OSX || s.getPlatform() == ProtoConstants.Platform.Platform_Windows || platform == ProtoConstants.Platform.Platform_LINUX) {
                                 remove = true;
                             }
                         } else {

File: common/src/main/java/cn/wildfirechat/proto/ProtoConstants.java
Patch:
@@ -46,7 +46,7 @@ public interface Platform {
         int Platform_OSX = 4;
         int Platform_WEB = 5;
         int Platform_WX = 6;
-        int Platform_Linux = 7;
+        int Platform_LINUX = 7;
     }
 
     //message NotifyMessage & PullMessageRequest -> type

File: sdk/src/main/java/cn/wildfirechat/sdk/Main.java
Patch:
@@ -258,8 +258,8 @@ static void testUserRelation() throws Exception {
             System.exit(-1);
         }
 
-        updateFriendStatusResult = RelationAdmin.setUserBlacklist("ff1", "ff2", true);
-        if (updateFriendStatusResult != null && updateFriendStatusResult.getErrorCode() == ErrorCode.ERROR_CODE_SUCCESS) {
+        IMResult<Void> updateBlacklistStatusResult = RelationAdmin.setUserBlacklist("ff1", "ff2", true);
+        if (updateBlacklistStatusResult != null && updateBlacklistStatusResult.getErrorCode() == ErrorCode.ERROR_CODE_SUCCESS) {
             System.out.println("update blacklist status success");
         } else {
             System.out.println("update blacklist status failure");

File: sdk/src/main/java/cn/wildfirechat/sdk/RelationAdmin.java
Patch:
@@ -28,7 +28,7 @@ public static IMResult<Void> setUserBlacklist(String userId, String targetId, bo
         InputBlacklistRequest input = new InputBlacklistRequest();
         input.setUserId(userId);
         input.setTargetUid(targetId);
-        input.setStatus(isBlacklist ? 1 : 0);
+        input.setStatus(isBlacklist ? 2 : 1);
         return AdminHttpUtils.httpJsonPost(path, input, Void.class);
     }
 

File: broker/src/main/java/io/moquette/imhandler/HandleFriendRequestHandler.java
Patch:
@@ -28,7 +28,7 @@ public ErrorCode action(ByteBuf ackPayload, String clientID, String fromUser, bo
             long[] heads = new long[2];
             ErrorCode errorCode = m_messagesStore.handleFriendRequest(fromUser, request, builder, heads, isAdmin);
 
-            if (errorCode == ERROR_CODE_SUCCESS && !isAdmin) {
+            if (errorCode == ERROR_CODE_SUCCESS && !isAdmin && builder.getConversation() != null) {
                 long messageId = MessageShardingUtil.generateId();
                 long timestamp = System.currentTimeMillis();
                 builder.setMessageId(messageId);

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -112,7 +112,7 @@ public class MemoryMessagesStore implements IMessagesStore {
     private final DatabaseStore databaseStore;
     private ConcurrentHashMap<String, Long> userMaxPullSeq = new ConcurrentHashMap<>();
 
-    private AtomicReference<SensitiveFilter> mSensitiveFilter = new AtomicReference<>();
+    private AtomicReference<SensitiveFilter> mSensitiveFilter;
     private volatile long lastUpdateSensitiveTime = 0;
 
     private ConcurrentHashMap<String, Boolean> userGlobalSlientMap = new ConcurrentHashMap<>();

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -111,7 +111,7 @@ public class MemoryMessagesStore implements IMessagesStore {
     private final DatabaseStore databaseStore;
     private ConcurrentHashMap<String, Long> userMaxPullSeq = new ConcurrentHashMap<>();
 
-    private AtomicReference<SensitiveFilter> mSensitiveFilter;
+    private AtomicReference<SensitiveFilter> mSensitiveFilter = new AtomicReference<>();
     private volatile long lastUpdateSensitiveTime = 0;
 
     private ConcurrentHashMap<String, Boolean> userGlobalSlientMap = new ConcurrentHashMap<>();

File: broker/src/main/java/io/moquette/persistence/DatabaseStore.java
Patch:
@@ -172,7 +172,7 @@ List<WFCMessage.User> searchUserFromDB(String keyword, boolean buzzy, int page)
             if (buzzy) {
                 sql += " where (`_display_name` like ? or `_name` = ? or `_mobile` = ?) ";
             } else {
-                sql += " where (``_name` = ? or `_mobile` = ?) ";
+                sql += " where (`_name` = ? or `_mobile` = ?) ";
             }
 
             sql += " and _type <> 2"; //can search normal user(0) and robot(1), can not search things

File: sdk/src/main/java/cn/wildfirechat/sdk/FriendAdmin.java
Patch:
@@ -19,7 +19,7 @@ public static IMResult<Void> getFriendStatusList(String userId, int status) thro
         String path = APIPath.Friend_Get_List;
         InputGetFriendList input = new InputGetFriendList();
         input.setUserId(userId);
-        input.setStatus(0);
+        input.setStatus(status);
         return AdminHttpUtils.httpJsonPost(path, input, Void.class);
     }
 

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -111,7 +111,7 @@ public final class BrokerConstants {
     public static final String MONGODB_Data_Expire_Days = "mongodb.data_expire_days";
 
     public static final String MESSAGE_ROAMING = "message.roaming";
-    public static final String MESSAGE_Remote_History_Message = "message.reomte_history_message";
+    public static final String MESSAGE_Remote_History_Message = "message.remote_history_message";
 
 
     private BrokerConstants() {

File: common/src/main/java/cn.wildfirechat.pojos/MessagePayload.java
Patch:
@@ -129,8 +129,8 @@ public WFCMessage.MessageContent toProtoMessageContent() {
             builder.setSearchableContent(searchableContent);
         if (!StringUtil.isNullOrEmpty(pushContent))
             builder.setPushContent(pushContent);
-        if (!StringUtil.isNullOrEmpty(searchableContent))
-            builder.setContent(searchableContent);
+        if (!StringUtil.isNullOrEmpty(content))
+            builder.setContent(content);
         if (!StringUtil.isNullOrEmpty(base64edData))
             builder.setData(ByteString.copyFrom(Base64.getDecoder().decode(base64edData)));
         if (!StringUtil.isNullOrEmpty(remoteMediaUrl))

File: broker/src/main/java/io/moquette/persistence/DatabaseStore.java
Patch:
@@ -1153,7 +1153,7 @@ void updateSession(String uid, String cid, MemorySessionStore.Session session, W
                     statement.setInt(index++, request.getPlatform());
                 }
                 if (session.getPushType() != request.getPushType()) {
-                    statement.setInt(index++, request.getPushType());
+                    statement.setInt(index++, request.getPushType() >= 32 ? 0 : request.getPushType());
                 }
                 if (!strEqual(session.getDeviceName(), request.getDeviceName())) {
                     statement.setString(index++, request.getDeviceName());

File: sdk/src/main/java/cn/wildfirechat/sdk/Main.java
Patch:
@@ -294,7 +294,7 @@ public static void main(String[] args) throws Exception {
 
 
         //初始化机器人API
-        RobotHttpUtils.init("http://localhost:18080", "robot1", "123456");
+        RobotHttpUtils.init("http://localhost", "robot1", "123456");
         //***********************************************
         //****  机器人API
         //***********************************************
@@ -313,7 +313,7 @@ public static void main(String[] args) throws Exception {
             System.exit(-1);
         }
 
-        IMResult<InputOutputUserInfo> resultRobotGetUserInfo = RobotService.getUserInfo("user1");
+        IMResult<InputOutputUserInfo> resultRobotGetUserInfo = RobotService.getUserInfo("userId1");
         if (resultRobotGetUserInfo != null && resultRobotGetUserInfo.getErrorCode() == ErrorCode.ERROR_CODE_SUCCESS) {
             System.out.println("robot get user info success");
         } else {

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -1047,7 +1047,7 @@ public ErrorCode canSendMessageInGroup(String memberId, String groupId) {
                     return ErrorCode.ERROR_CODE_GROUP_MUTED;
                 }
 
-                if (member.getMemberId().equals(memberId) && member.getType() != GroupMemberType_Removed) {
+                if (member.getMemberId().equals(memberId) && member.getType() == GroupMemberType_Removed) {
                     return ErrorCode.ERROR_CODE_NOT_IN_GROUP;
                 }
             }

File: broker/src/main/java/io/moquette/persistence/RPCCenter.java
Patch:
@@ -73,7 +73,7 @@ public void sendResponse(int errorCode, byte[] message, String toUuid, int reque
                 info.future.cancel(true);
                 if (info.callback != null) {
                     info.callback.getResponseExecutor().execute(() -> {
-                        if (errorCode == 0 || errorCode == ErrorCode.ERROR_CODE_ASYNC_HANDLER.getCode()) {
+                        if (errorCode == 0 || errorCode == ErrorCode.ERROR_CODE_SUCCESS_GZIPED.getCode()) {
                             info.callback.onSuccess(message);
                         } else {
                             info.callback.onError(ErrorCode.fromCode(errorCode));

File: broker/src/main/java/io/moquette/spi/impl/Qos1PublishHandler.java
Patch:
@@ -188,7 +188,7 @@ void imHandler(String clientID, String fromUser, String topic, byte[] payloadCon
                                         e.printStackTrace();
                                     }
                                     data = out.toByteArray();
-                                    code = (byte)ErrorCode.ERROR_CODE_ASYNC_HANDLER.code;
+                                    code = (byte)ErrorCode.ERROR_CODE_SUCCESS_GZIPED.code;
                                 }
 
                                 data = AES.AESEncrypt(data, session.getSecret());

File: broker/src/main/java/io/moquette/spi/impl/Qos1PublishHandler.java
Patch:
@@ -114,7 +114,7 @@ public void onRpcMsg(String fromUser, String clientId, byte[] message, int reque
                     byte[] response = new byte[ackPayload.readableBytes()];
                     ackPayload.readBytes(response);
                     ReferenceCountUtil.release(ackPayload);
-                    RPCCenter.getInstance().sendResponse(ERROR_CODE_SUCCESS.getCode(), response, from, requestId);
+                    RPCCenter.getInstance().sendResponse(errorCode.getCode(), response, from, requestId);
                 }
             }, isAdmin);
         }

File: wildfire_jmeter/src/main/java/net/xmeter/samplers/AbstractMQTTSampler.java
Patch:
@@ -189,7 +189,7 @@ protected String getClientId() {
     protected String token;
 
     protected boolean getToken(String userId, String clientId) {
-        String url = "http://" + getServer() + ":18080/admin/user/token";
+        String url = "http://" + getServer() + ":18080/admin/user/get_token";
         String adminSecret = "123456";
         HttpPost post = null;
         try {

File: broker/src/main/java/com/xiaoleilu/loServer/pojos/GroupNotificationBinaryContent.java
Patch:
@@ -32,12 +32,14 @@ public class GroupNotificationBinaryContent {
     private String m;
 
     public GroupNotificationBinaryContent(String g, String o, String n, String m) {
+        this.g = g;
         this.o = o;
         this.n = n;
         this.m = m;
     }
 
     public GroupNotificationBinaryContent(String g, String operator, String name, List<String> members) {
+        this.g = g;
         this.o = operator;
         this.n = name;
         this.ms = members;

File: broker/src/main/java/io/moquette/persistence/DatabaseStore.java
Patch:
@@ -553,7 +553,7 @@ List<WFCMessage.Message> loadRemoteMessages(String user, WFCMessage.Conversation
     List<WFCMessage.Message> loadRemoteMessagesFromTable(String user, WFCMessage.Conversation conversation, long beforeUid, int count, String table) {
         String sql = "select `_mid`, `_from`, `_type`, `_target`, `_line`, `_data`, `_dt` from " + table +" where";
         if (conversation.getType() == ProtoConstants.ConversationType.ConversationType_Private) {
-            sql += " _type = ? and _line = ? and _mid < ? and ((_target = ?  and _from = ?) or (_target = ?  and _from = ?)";
+            sql += " _type = ? and _line = ? and _mid < ? and ((_target = ?  and _from = ?) or (_target = ?  and _from = ?))";
         } else {
             sql += " _type = ? and _line = ? and _mid < ? and _target = ?";
         }

File: broker/src/main/java/io/moquette/imhandler/SetFriendAliasRequestHandler.java
Patch:
@@ -19,9 +19,9 @@
 @Handler(IMTopic.SetFriendAliasTopic)
 public class SetFriendAliasRequestHandler extends GroupHandler<WFCMessage.AddFriendRequest> {
     @Override
-    public ErrorCode action(ByteBuf ackPayload, String clientID, String fromUser, boolean isAdmin, WFCMessage.AddGroupMemberRequest request, Qos1PublishHandler.IMCallback callback) {
+    public ErrorCode action(ByteBuf ackPayload, String clientID, String fromUser, boolean isAdmin, WFCMessage.AddFriendRequest request, Qos1PublishHandler.IMCallback callback) {
         long[] head = new long[1];
-        ErrorCode errorCode = m_messagesStore.blackUserRequest(fromUser, request.getUid(), request.getStatus(), head);
+        ErrorCode errorCode = m_messagesStore.setFriendAliasRequest(fromUser, request.getTargetUid(), request.getReason(), head);
         if (errorCode == ERROR_CODE_SUCCESS) {
             publisher.publishNotification(IMTopic.NotifyFriendTopic, fromUser, head[0]);
         }

File: broker/src/main/java/io/moquette/spi/impl/MessagesPublisher.java
Patch:
@@ -212,7 +212,7 @@ private void publish2Receivers(String sender, int conversationType, String targe
                 }
 
                 if (pullType == ProtoConstants.PullType.Pull_ChatRoom) {
-                    if (exceptClientId.equals(targetSession.getClientID())) {
+                    if (exceptClientId != null && exceptClientId.equals(targetSession.getClientID())) {
                         targetSession.refreshLastChatroomActiveTime();
                     }
 

File: broker/src/main/java/com/xiaoleilu/loServer/action/admin/GetChatroomInfoAction.java
Patch:
@@ -40,10 +40,10 @@ public void action(Request request, Response response) {
                 WFCMessage.ChatroomInfo info = messagesStore.getChatroomInfo(chatroomid);
 
                 RestResult result;
-                if (info == null) {
+                if (info != null) {
                     result = RestResult.ok(new OutputGetChatroomInfo(chatroomid, messagesStore.getChatroomMemberCount(chatroomid), info));
                 } else {
-                    result = RestResult.resultOf(ErrorCode.ERROR_CODE_SUCCESS);
+                    result = RestResult.resultOf(ErrorCode.ERROR_CODE_NOT_EXIST);
                 }
                 response.setStatus(HttpResponseStatus.OK);
 

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -591,7 +591,6 @@ public WFCMessage.GroupInfo createGroup(String fromUser, WFCMessage.GroupInfo gr
             .build();
 
         mIMap.put(groupId, groupInfo);
-        databaseStore.persistGroupInfo(groupInfo);
         MultiMap<String, WFCMessage.GroupMember> groupMembers = hzInstance.getMultiMap(GROUP_MEMBERS);
 
         for (WFCMessage.GroupMember member : memberList) {
@@ -767,8 +766,7 @@ public ErrorCode dismissGroup(String operator, String groupId) {
 
         groupMembers.remove(groupId);
         mIMap.remove(groupId);
-
-        databaseStore.removeGroupInfoFromDB(groupId);
+        
         databaseStore.removeGroupMemberFromDB(groupId);
 
         return ErrorCode.ERROR_CODE_SUCCESS;

File: broker/src/main/java/io/moquette/imhandler/GroupHandler.java
Patch:
@@ -26,13 +26,13 @@ protected void sendGroupNotification(String fromUser, String targetId, List<Inte
         }
 
         for (int line : lines) {
-            WFCMessage.Message.Builder builder = WFCMessage.Message.newBuilder().setContent(content);
-            builder.setConversation(builder.getConversationBuilder().setType(ProtoConstants.ConversationType.ConversationType_Group).setTarget(targetId).setLine(line));
             long timestamp = System.currentTimeMillis();
+            WFCMessage.Message.Builder builder = WFCMessage.Message.newBuilder().setContent(content).setServerTimestamp(timestamp);
+            builder.setConversation(builder.getConversationBuilder().setType(ProtoConstants.ConversationType.ConversationType_Group).setTarget(targetId).setLine(line));
             builder.setFromUser(fromUser);
             long messageId = MessageShardingUtil.generateId();
             builder.setMessageId(messageId);
-            saveAndPublish(fromUser, null, builder.build(), timestamp);
+            saveAndPublish(fromUser, null, builder.build());
         }
     }
 

File: broker/src/main/java/io/moquette/imhandler/HandleFriendRequestHandler.java
Patch:
@@ -32,7 +32,7 @@ public ErrorCode action(ByteBuf ackPayload, String clientID, String fromUser, WF
                 long timestamp = System.currentTimeMillis();
                 builder.setMessageId(messageId);
                 builder.setServerTimestamp(timestamp);
-                saveAndPublish(request.getTargetUid(), null, builder.build(), timestamp);
+                saveAndPublish(request.getTargetUid(), null, builder.build());
 
                 WFCMessage.MessageContent.Builder contentBuilder = WFCMessage.MessageContent.newBuilder().setType(90).setContent("以上是打招呼信息");
                 builder = WFCMessage.Message.newBuilder();
@@ -44,15 +44,15 @@ public ErrorCode action(ByteBuf ackPayload, String clientID, String fromUser, WF
 
                 messageId = MessageShardingUtil.generateId();
                 builder.setMessageId(messageId);
-                saveAndPublish(request.getTargetUid(), null, builder.build(), timestamp);
+                saveAndPublish(request.getTargetUid(), null, builder.build());
 
                 contentBuilder.setContent("你们已经成为好友了，现在可以开始聊天了");
                 builder.setContent(contentBuilder);
                 messageId = MessageShardingUtil.generateId();
                 builder.setMessageId(messageId);
                 timestamp = System.currentTimeMillis();
                 builder.setServerTimestamp(timestamp);
-                saveAndPublish(request.getTargetUid(), null, builder.build(), System.currentTimeMillis());
+                saveAndPublish(request.getTargetUid(), null, builder.build());
 
                 publisher.publishNotification(IMTopic.NotifyFriendTopic, request.getTargetUid(), heads[0]);
                 publisher.publishNotification(IMTopic.NotifyFriendTopic, fromUser, heads[1]);

File: broker/src/main/java/io/moquette/imhandler/IMHandler.java
Patch:
@@ -240,10 +240,10 @@ public void afterAction(String clientID, String fromUser, String topic, Qos1Publ
 
     }
 
-    protected long saveAndPublish(String username, String clientID, WFCMessage.Message message, long timestamp) {
+    protected long saveAndPublish(String username, String clientID, WFCMessage.Message message) {
         Set<String> notifyReceivers = new LinkedHashSet<>();
 
-        message = m_messagesStore.storeMessage(username, clientID, message, timestamp);
+        message = m_messagesStore.storeMessage(username, clientID, message);
         int pullType = m_messagesStore.getNotifyReceivers(username, message, notifyReceivers);
         this.publisher.publish2Receivers(message, notifyReceivers, clientID, pullType);
         return message.getMessageId();

File: broker/src/main/java/io/moquette/imhandler/SendMessageHandler.java
Patch:
@@ -99,7 +99,7 @@ public ErrorCode action(ByteBuf ackPayload, String clientID, String fromUser, WF
 
                 if (errorCode == ErrorCode.ERROR_CODE_SUCCESS) {
                     if (!ignoreMsg) {
-                        saveAndPublish(fromUser, clientID, message, timestamp);
+                        saveAndPublish(fromUser, clientID, message);
                     }
                     ackPayload = ackPayload.capacity(20);
                     ackPayload.writeLong(messageId);

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -150,7 +150,7 @@ public DatabaseStore getDatabaseStore() {
     }
 
     @Override
-    public WFCMessage.Message storeMessage(String fromUser, String fromClientId, WFCMessage.Message message, long timestamp) {
+    public WFCMessage.Message storeMessage(String fromUser, String fromClientId, WFCMessage.Message message) {
         HazelcastInstance hzInstance = m_Server.getHazelcastInstance();
         IMap<Long, MessageBundle> mIMap = hzInstance.getMap(MESSAGES_MAP);
 

File: broker/src/main/java/io/moquette/spi/IMessagesStore.java
Patch:
@@ -97,7 +97,7 @@ public String toString() {
     }
 
     DatabaseStore getDatabaseStore();
-    WFCMessage.Message storeMessage(String fromUser, String fromClientId, WFCMessage.Message message, long timestamp);
+    WFCMessage.Message storeMessage(String fromUser, String fromClientId, WFCMessage.Message message);
 	int getNotifyReceivers(String fromUser, WFCMessage.Message message, Set<String> notifyReceivers);
     WFCMessage.PullMessageResult fetchMessage(String user, String exceptClientId, long fromMessageId, int pullType);
     long insertUserMessages(String sender, int conversationType, String target, int line, int messageContentType, String userId, long messageId);

File: broker/src/main/java/io/moquette/broker/MQTTConnectionFactory.java
Patch:
@@ -33,7 +33,7 @@ class MQTTConnectionFactory {
         this.postOffice = postOffice;
     }
 
-    public MQTTConnection create(Channel channel) {
+    MQTTConnection create(Channel channel) {
         return new MQTTConnection(channel, brokerConfig, authenticator, sessionRegistry, postOffice);
     }
 }

File: broker/src/main/java/io/moquette/broker/SessionRegistry.java
Patch:
@@ -197,7 +197,7 @@ private Session createNewSession(MQTTConnection mqttConnection, MqttConnectMessa
             final Session.Will will = createWill(msg);
             newSession = new Session(clientId, clean, will, sessionQueue);
         } else {
-            newSession = new Session(clean, clientId, sessionQueue);
+            newSession = new Session(clientId, clean, sessionQueue);
         }
 
         newSession.markConnected();

File: broker/src/main/java/io/moquette/broker/Server.java
Patch:
@@ -178,8 +178,9 @@ public void startServer(IConfig config, List<? extends InterceptHandler> handler
 
         ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();
         subscriptions.init(subscriptionsRepository);
-        SessionRegistry sessions = new SessionRegistry(subscriptions, queueRepository);
-        dispatcher = new PostOffice(subscriptions, authorizatorPolicy, retainedRepository, sessions, interceptor);
+        final Authorizator authorizator = new Authorizator(authorizatorPolicy);
+        SessionRegistry sessions = new SessionRegistry(subscriptions, queueRepository, authorizator);
+        dispatcher = new PostOffice(subscriptions, retainedRepository, sessions, interceptor, authorizator);
         final BrokerConfiguration brokerConfig = new BrokerConfiguration(config);
         MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions,
                                                                             dispatcher);

File: broker/src/main/java/io/moquette/broker/Server.java
Patch:
@@ -179,8 +179,7 @@ public void startServer(IConfig config, List<? extends InterceptHandler> handler
         ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();
         subscriptions.init(subscriptionsRepository);
         SessionRegistry sessions = new SessionRegistry(subscriptions, queueRepository);
-        dispatcher = new PostOffice(subscriptions, authorizatorPolicy, retainedRepository, sessions,
-                                    interceptor);
+        dispatcher = new PostOffice(subscriptions, authorizatorPolicy, retainedRepository, sessions, interceptor);
         final BrokerConfiguration brokerConfig = new BrokerConfiguration(config);
         MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions,
                                                                             dispatcher);

File: broker/src/main/java/io/moquette/broker/metrics/MQTTMessageLogger.java
Patch:
@@ -38,7 +38,7 @@
 @Sharable
 public class MQTTMessageLogger extends ChannelDuplexHandler {
 
-    private static final Logger LOG = LoggerFactory.getLogger("messageLogger");
+    private static final Logger LOG = LoggerFactory.getLogger(MQTTMessageLogger.class);
 
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object message) throws Exception {

File: broker/src/test/java/io/moquette/integration/IntegrationUtils.java
Patch:
@@ -30,7 +30,7 @@ public final class IntegrationUtils {
 
     static String localH2MvStoreDBPath() {
         String currentDir = System.getProperty("user.dir");
-        return currentDir + File.separator + "out" + File.separator + DEFAULT_MOQUETTE_STORE_H2_DB_FILENAME;
+        return currentDir + File.separator + "build" + File.separator + DEFAULT_MOQUETTE_STORE_H2_DB_FILENAME;
     }
 
     public static Properties prepareTestProperties() {

File: broker/src/test/java/io/moquette/integration/IntegrationUtils.java
Patch:
@@ -30,7 +30,7 @@ public final class IntegrationUtils {
 
     static String localH2MvStoreDBPath() {
         String currentDir = System.getProperty("user.dir");
-        return currentDir + File.separator + "target" + File.separator + DEFAULT_MOQUETTE_STORE_H2_DB_FILENAME;
+        return currentDir + File.separator + "out" + File.separator + DEFAULT_MOQUETTE_STORE_H2_DB_FILENAME;
     }
 
     public static Properties prepareTestProperties() {

File: broker/src/main/java/io/moquette/broker/subscriptions/DumpTreeVisitor.java
Patch:
@@ -39,6 +39,7 @@ private String prettySubscriptions(CNode node) {
         for (Subscription couple : node.subscriptions) {
             subScriptionsStr
                 .append("{filter=").append(couple.topicFilter).append(", ")
+                .append("qos=").append(couple.getRequestedQos()).append(", ")
                 .append("client='").append(couple.clientId).append("'}");
             counter++;
             if (counter < node.subscriptions.size()) {

File: broker/src/main/java/io/moquette/broker/IRetainedRepository.java
Patch:
@@ -19,11 +19,12 @@
 import io.netty.handler.codec.mqtt.MqttPublishMessage;
 
 public interface IRetainedRepository {
+
     void cleanRetained(Topic topic);
 
     void retain(Topic topic, MqttPublishMessage msg);
 
-    boolean isEmtpy();
+    boolean isEmpty();
 
     MqttPublishMessage retainedOnTopic(String topic);
 }

File: broker/src/main/java/io/moquette/broker/MemoryRetainedRepository.java
Patch:
@@ -39,7 +39,7 @@ public void retain(Topic topic, MqttPublishMessage msg) {
     }
 
     @Override
-    public boolean isEmtpy() {
+    public boolean isEmpty() {
         return storage.isEmpty();
     }
 

File: broker/src/main/java/io/moquette/broker/subscriptions/ISubscriptionsDirectory.java
Patch:
@@ -32,8 +32,6 @@ public interface ISubscriptionsDirectory {
 
     void removeSubscription(Topic topic, String clientID);
 
-    List<Subscription> matches(Topic topic);
-
     int size();
 
     String dumpTree();

File: broker/src/test/java/io/moquette/broker/PostOfficePublishTest.java
Patch:
@@ -241,7 +241,7 @@ public void testPublishWithEmptyPayloadClearRetainedStore() {
                 .topicName(NEWS_TOPIC).build());
 
         // Verify
-        assertTrue("QoS0 MUST clean retained message for topic", retainedRepository.isEmtpy());
+        assertTrue("QoS0 MUST clean retained message for topic", retainedRepository.isEmpty());
     }
 
     @Test
@@ -403,7 +403,7 @@ public void cleanRetainedMessageStoreWhenPublishWithRetainedQos0IsReceived() {
                 .topicName(NEWS_TOPIC).build());
 
         // Verify
-        assertTrue("Retained message for topic /news must be cleared", retainedRepository.isEmtpy());
+        assertTrue("Retained message for topic /news must be cleared", retainedRepository.isEmpty());
     }
 
     private void assertMessageIsRetained(String expectedTopicName) {

File: broker/src/test/java/io/moquette/broker/config/ConfigurationParserTest.java
Patch:
@@ -16,13 +16,14 @@
 
 package io.moquette.broker.config;
 
-import io.moquette.broker.config.ConfigurationParser;
 import org.junit.Before;
 import org.junit.Test;
+
 import java.io.Reader;
 import java.io.StringReader;
 import java.text.ParseException;
 import java.util.Properties;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 

File: broker/src/test/java/io/moquette/integration/ServerIntegrationWebSocketTest.java
Patch:
@@ -62,8 +62,8 @@ public void setUp() throws Exception {
     @After
     public void tearDown() throws Exception {
         client.stop();
-
         m_server.stopServer();
+        IntegrationUtils.clearTestStorage();
     }
 
     @SuppressWarnings("FutureReturnValueIgnored")

File: broker/src/test/java/io/moquette/spec/v3_1_1/connection/ConnectionIT.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.File;
 import java.io.IOException;
 import io.moquette.BrokerConstants;
+import io.moquette.integration.IntegrationUtils;
 import io.moquette.testclient.RawClient;
 import org.junit.After;
 import org.junit.Before;
@@ -53,6 +54,7 @@ public void tearDown() throws Exception {
                     dbFile.delete());
         }
         assertFalse(dbFile.exists());
+        IntegrationUtils.clearTestStorage();
     }
 
     @Test(timeout = 3000)

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -27,9 +27,9 @@ public final class BrokerConstants {
     public static final String PASSWORD_FILE_PROPERTY_NAME = "password_file";
     public static final String PORT_PROPERTY_NAME = "port";
     public static final String HOST_PROPERTY_NAME = "host";
-    public static final String DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME = "moquette_store.mapdb";
+    public static final String DEFAULT_MOQUETTE_STORE_H2_DB_FILENAME = "moquette_store.h2";
     public static final String DEFAULT_PERSISTENT_PATH = System.getProperty("user.dir") + File.separator
-            + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
+            + DEFAULT_MOQUETTE_STORE_H2_DB_FILENAME;
     public static final String WEB_SOCKET_PORT_PROPERTY_NAME = "websocket_port";
     public static final String WSS_PORT_PROPERTY_NAME = "secure_websocket_port";
 

File: broker/src/main/java/io/moquette/interception/BrokerInterceptor.java
Patch:
@@ -160,7 +160,7 @@ public void notifyTopicUnsubscribed(final String topic, final String clientID, f
     public void notifyMessageAcknowledged(final InterceptAcknowledgedMessage msg) {
         for (final InterceptHandler handler : this.handlers.get(InterceptAcknowledgedMessage.class)) {
             LOG.debug("Notifying MQTT ACK message to interceptor. CId={}, messageId={}, topic={}, interceptorId={}",
-                msg.getMsg().getClientID(), msg.getPacketID(), msg.getTopic(), handler.getID());
+                msg.getMsg()/*.getClientID()*/, msg.getPacketID(), msg.getTopic(), handler.getID());
             executor.execute(() -> handler.onMessageAcknowledged(msg));
         }
     }

File: broker/src/test/java/io/moquette/integration/ServerIntegrationFuseTest.java
Patch:
@@ -68,6 +68,8 @@ public void tearDown() throws Exception {
         }
 
         m_server.stopServer();
+
+        IntegrationUtils.clearTestStorage();
     }
 
     @Test

File: broker/src/test/java/io/moquette/integration/ServerIntegrationOpenSSLTest.java
Patch:
@@ -55,7 +55,7 @@ protected void startServer() throws IOException {
         sslProps.put(BrokerConstants.JKS_PATH_PROPERTY_NAME, "serverkeystore.jks");
         sslProps.put(BrokerConstants.KEY_STORE_PASSWORD_PROPERTY_NAME, "passw0rdsrv");
         sslProps.put(BrokerConstants.KEY_MANAGER_PASSWORD_PROPERTY_NAME, "passw0rdsrv");
-        sslProps.put(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME, IntegrationUtils.localMapDBPath());
+        sslProps.put(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME, IntegrationUtils.localH2MvStoreDBPath());
         m_server.startServer(sslProps);
     }
 }

File: broker/src/test/java/io/moquette/integration/ServerIntegrationPahoTest.java
Patch:
@@ -80,6 +80,8 @@ public void tearDown() throws Exception {
         }
 
         stopServer();
+
+        IntegrationUtils.clearTestStorage();
     }
 
     private void stopServer() {

File: broker/src/test/java/io/moquette/integration/ServerIntegrationRestartTest.java
Patch:
@@ -82,6 +82,8 @@ public void tearDown() throws Exception {
         }
 
         m_server.stopServer();
+
+        IntegrationUtils.clearTestStorage();
     }
 
     @Test

File: broker/src/main/java/io/moquette/broker/InflightResender.java
Patch:
@@ -155,7 +155,8 @@ private void destroy() {
 
     private void resendNotAcked(ChannelHandlerContext ctx/* , IdleStateEvent evt */) {
         if (LOG.isTraceEnabled()) {
-            LOG.trace("Flushing idle Netty channel {} for clientId: {}", ctx.channel(), NettyUtils.clientID(ctx.channel()));
+            LOG.trace("Flushing idle Netty channel {} for clientId: {}", ctx.channel(),
+                      NettyUtils.clientID(ctx.channel()));
         }
         ctx.fireUserEventTriggered(new ResendNotAckedPublishes());
     }

File: broker/src/main/java/io/moquette/server/netty/AutoFlushHandler.java
Patch:
@@ -111,7 +111,8 @@ private void initialize(ChannelHandlerContext ctx) {
         // Avoid the case where destroy() is called before scheduling timeouts.
         // See: https://github.com/netty/netty/issues/143
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Initializing autoflush handler on channel {} Cid: {}", ctx.channel(), NettyUtils.clientID(ctx.channel()));
+            LOG.debug("Initializing autoflush handler on channel {} Cid: {}", ctx.channel(),
+                      NettyUtils.clientID(ctx.channel()));
         }
         switch (state) {
             case 1:

File: broker/src/main/java/io/moquette/server/netty/metrics/MQTTMessageLogger.java
Patch:
@@ -60,7 +60,7 @@ private void logMQTTMessage(ChannelHandlerContext ctx, Object message, String di
         }
         MqttMessage msg = (MqttMessage) message;
         if (msg.fixedHeader() == null) {
-        	throw new IOException("Unknown packet");
+            throw new IOException("Unknown packet");
         }
         String clientID = NettyUtils.clientID(ctx.channel());
         MqttMessageType messageType = msg.fixedHeader().messageType();
@@ -69,7 +69,7 @@ private void logMQTTMessage(ChannelHandlerContext ctx, Object message, String di
             case PINGREQ:
             case PINGRESP:
                 LOG.debug("{} {} <{}>", direction, messageType, clientID);
-                break;        
+                break;
             case CONNECT:
             case DISCONNECT:
                 LOG.info("{} {} <{}>", direction, messageType, clientID);

File: broker/src/main/java/io/moquette/spi/IMessagesStore.java
Patch:
@@ -44,7 +44,6 @@ public StoredMessage(byte[] message, MqttQoS qos, String topic) {
             m_topic = topic;
         }
 
-
         public void setQos(MqttQoS qos) {
             this.m_qos = qos;
         }

File: broker/src/main/java/io/moquette/spi/ISessionsStore.java
Patch:
@@ -27,6 +27,7 @@
 /**
  * Store used to handle the persistence of the subscriptions tree.
  */
+@Deprecated
 public interface ISessionsStore {
 
     void initStore();

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Subscription.java
Patch:
@@ -47,6 +47,9 @@ public Subscription(Subscription orig) {
 
     /**
      * Constructor with undefined maximum QoS
+     *
+     * @param clientId id of client owning this subscription.
+     * @param topicFilter the topic to subscribe to.
      * */
     public Subscription(String clientId, Topic topicFilter) {
         this.requestedQos = null;

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Topic.java
Patch:
@@ -41,6 +41,9 @@ public class Topic implements Serializable {
 
     /**
      * Factory method
+     *
+     * @param s the topic string (es "/a/b").
+     * @return the created Topic instance.
      * */
     public static Topic asTopic(String s) {
         return new Topic(s);

File: broker/src/test/java/io/moquette/server/ServerIntegrationPahoCanPublishOnReadBlockedTopicTest.java
Patch:
@@ -47,7 +47,8 @@
 
 public class ServerIntegrationPahoCanPublishOnReadBlockedTopicTest {
 
-    private static final Logger LOG = LoggerFactory.getLogger(ServerIntegrationPahoCanPublishOnReadBlockedTopicTest.class);
+    private static final Logger LOG =
+        LoggerFactory.getLogger(ServerIntegrationPahoCanPublishOnReadBlockedTopicTest.class);
 
     static MqttClientPersistence s_dataStore;
     static MqttClientPersistence s_pubDataStore;

File: broker/src/test/java/io/moquette/testclient/Client.java
Patch:
@@ -26,6 +26,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.nio.charset.Charset;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
@@ -109,7 +110,7 @@ public void connect(String willTestamentTopic, String willTestamentMsg) {
         MqttConnectPayload mqttConnectPayload = new MqttConnectPayload(
                 this.clientId,
                 willTestamentTopic,
-                willTestamentMsg.getBytes(),
+                willTestamentMsg.getBytes(Charset.forName("UTF-8")),
                 null,
                 null);
         MqttConnectMessage connectMessage = new MqttConnectMessage(

File: broker/src/main/java/io/moquette/broker/MQTTConnection.java
Patch:
@@ -321,7 +321,7 @@ void processPublish(MqttPublishMessage msg) {
         }
         switch (qos) {
             case AT_MOST_ONCE:
-                postOffice.receivedPublishQos0(topic, username, clientId, payload, retain);
+                postOffice.receivedPublishQos0(topic, username, clientId, payload, retain, msg);
                 break;
             case AT_LEAST_ONCE: {
                 final int messageID = msg.variableHeader().packetId();

File: broker/src/main/java/io/moquette/broker/MemorySubscriptionsRepository.java
Patch:
@@ -2,13 +2,14 @@
 
 import io.moquette.spi.impl.subscriptions.Subscription;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 
 public class MemorySubscriptionsRepository implements ISubscriptionsRepository {
 
-    private final List<Subscription> subscriptions = new LinkedList<>();
+    private final List<Subscription> subscriptions = new ArrayList<>();
 
     @Override
     public List<Subscription> listAllSubscriptions() {

File: broker/src/main/java/io/moquette/broker/Session.java
Patch:
@@ -20,7 +20,7 @@ class Session {
     private static final int FLIGHT_BEFORE_RESEND_MS = 5_000;
     private static final int INFLIGHT_WINDOW_SIZE = 10;
 
-    class InFlightPacket implements Delayed {
+    static class InFlightPacket implements Delayed {
 
         final int packetId;
         private long startTime;

File: broker/src/main/java/io/moquette/server/Server.java
Patch:
@@ -255,7 +255,9 @@ public void stopServer() {
             }
         }
 
-        scheduler.shutdown();
+		// calling shutdown() does not actually stop tasks that are not cancelled,
+		// and SessionsRepository does not stop its tasks. Thus shutdownNow().
+        scheduler.shutdownNow();
 
         LOG.info("Moquette server has been stopped.");
     }

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -46,6 +46,7 @@ public final class BrokerConstants {
     public static final String KEY_STORE_PASSWORD_PROPERTY_NAME = "key_store_password";
     public static final String KEY_MANAGER_PASSWORD_PROPERTY_NAME = "key_manager_password";
     public static final String ALLOW_ANONYMOUS_PROPERTY_NAME = "allow_anonymous";
+    public static final String REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT = "reauthorize_subscriptions_on_connect";
     public static final String ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME = "allow_zero_byte_client_id";
     public static final String ACL_FILE_PROPERTY_NAME = "acl_file";
     public static final String AUTHORIZATOR_CLASS_NAME = "authorizator_class";

File: broker/src/test/java/io/moquette/spi/impl/AbstractProtocolProcessorCommonUtils.java
Patch:
@@ -81,7 +81,7 @@ protected void initializeProcessorAndSubsystems() {
         subscriptions.init(sessionsRepository);
         m_processor = new ProtocolProcessor();
         m_processor.init(subscriptions, m_messagesStore, m_sessionStore, m_mockAuthenticator, true,
-                         new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR, sessionsRepository);
+                         new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR, sessionsRepository, false);
     }
 
     void verifyNoPublishIsReceived() {

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessor_CONNECT_Test.java
Patch:
@@ -70,7 +70,7 @@ public void setUp() throws InterruptedException {
         m_processor = new ProtocolProcessor();
         m_processor.init(subscriptions, m_messagesStore, m_sessionStore, m_mockAuthenticator, true,
                          new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR,
-                         new SessionsRepository(this.m_sessionStore, null));
+                         new SessionsRepository(this.m_sessionStore, null), false);
     }
 
     @Test
@@ -160,7 +160,7 @@ public void prohibitAnonymousClient() {
 
     protected void reinitProcessorProhibitingAnonymousClients() {
         m_processor.init(subscriptions, m_messagesStore, m_sessionStore, m_mockAuthenticator, false,
-            new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR, new SessionsRepository(this.m_sessionStore, null));
+            new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR, new SessionsRepository(this.m_sessionStore, null), false);
     }
 
     @Test
@@ -325,7 +325,7 @@ public void testZeroByteClientIdWithoutCleanSession() {
 
     protected void reinitProtocolProcessorWithZeroLengthClientIdAndAnonymousClients() {
         m_processor.init(subscriptions, m_messagesStore, m_sessionStore, m_mockAuthenticator, true, true,
-            new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR, new SessionsRepository(this.m_sessionStore, null));
+            new PermitAllAuthorizator(), NO_OBSERVERS_INTERCEPTOR, new SessionsRepository(this.m_sessionStore, null), false);
     }
 
     @Test

File: broker/src/main/java/io/moquette/server/Server.java
Patch:
@@ -255,7 +255,9 @@ public void stopServer() {
             }
         }
 
-        scheduler.shutdown();
+		// calling shutdown() does not actually stop tasks that are not cancelled,
+		// and SessionsRepository does not stop its tasks. Thus shutdownNow().
+        scheduler.shutdownNow();
 
         LOG.info("Moquette server has been stopped.");
     }

File: broker/src/test/java/io/moquette/spi/impl/AbstractProtocolProcessorCommonUtils.java
Patch:
@@ -46,7 +46,7 @@ abstract class AbstractProtocolProcessorCommonUtils {
     static final String TEST_USER = "fakeuser";
     static final String TEST_PWD = "fakepwd";
 
-    private static final String HELLO_WORLD_MQTT = "Hello world MQTT!!";
+    static final String HELLO_WORLD_MQTT = "Hello world MQTT!!";
 
     EmbeddedChannel m_channel;
     ProtocolProcessor m_processor;
@@ -305,11 +305,11 @@ protected void connectWithCleanSession(String clientId) {
         assertEquals("Connect must be accepted", CONNECTION_ACCEPTED, connAck.variableHeader().connectReturnCode());
     }
 
-    protected void disconnect() throws InterruptedException {
+    protected void disconnect() {
         disconnect(this.m_channel);
     }
 
-    protected void disconnect(EmbeddedChannel channel) throws InterruptedException {
+    protected void disconnect(EmbeddedChannel channel) {
         this.m_processor.processDisconnect(channel);
     }
 

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessor_CONNECT_Test.java
Patch:
@@ -278,14 +278,14 @@ public void testMultipleReconnection() throws InterruptedException {
 
         // subscribe
         MqttSubscribeMessage subscribeMsg = MqttMessageBuilders.subscribe()
-                .addSubscription(MqttQoS.AT_MOST_ONCE, ProtocolProcessorTest.FAKE_TOPIC).messageId(10).build();
+                .addSubscription(MqttQoS.AT_MOST_ONCE, ProtocolProcessorTest.NEWS_TOPIC).messageId(10).build();
 
         NettyUtils.clientID(m_session, FAKE_CLIENT_ID);
         NettyUtils.cleanSession(m_session, false);
         m_processor.processSubscribe(m_session, subscribeMsg);
         Subscription expectedSubscription = new Subscription(
                 FAKE_CLIENT_ID,
-                new Topic(ProtocolProcessorTest.FAKE_TOPIC),
+                new Topic(ProtocolProcessorTest.NEWS_TOPIC),
                 MqttQoS.AT_MOST_ONCE);
         verifySubscriptionExists(m_sessionStore, expectedSubscription);
         assertEqualsSubAck(m_session.readOutbound());

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -719,7 +719,8 @@ public void processUnsubscribe(Channel channel, MqttUnsubscribeMessage msg) {
 
         // ack the client
         int messageID = msg.variableHeader().messageId();
-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_LEAST_ONCE, false, 0);
+        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE,
+                                                         false, 0);
         MqttUnsubAckMessage ackMessage = new MqttUnsubAckMessage(fixedHeader, from(messageID));
 
         LOG.debug("Sending UNSUBACK message. CId={}, topics={}, messageId={}", clientID, topics, messageID);

File: broker/src/main/java/io/moquette/spi/impl/SessionsRepository.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
@@ -48,7 +49,7 @@ public void run() {
     private final ISessionsStore sessions;
     private ISubscriptionsStore subscriptionsStore;
     private ScheduledExecutorService scheduler;
-    private final Map<String, ClientSession> sessionsCache = new ConcurrentHashMap<>();
+    private final ConcurrentMap<String, ClientSession> sessionsCache = new ConcurrentHashMap<>();
 
     public SessionsRepository(ISessionsStore sessionsStore, ScheduledExecutorService scheduler) {
         this.sessions = sessionsStore;

File: broker/src/main/java/io/moquette/spi/impl/BrokerInterceptor.java
Patch:
@@ -88,6 +88,7 @@ void stop() {
             LOG.warn("Forcing shutdown of interceptor thread pool...");
             executor.shutdownNow();
         }
+        LOG.info("interceptors stopped");
     }
 
     @Override

File: perf/src/main/java/io/moquette/parser/netty/performance/ProtocolDecodingServer.java
Patch:
@@ -123,7 +123,7 @@ public void initChannel(SocketChannel ch) throws Exception {
                 })
                 .option(ChannelOption.SO_BACKLOG, 128)
                 .option(ChannelOption.SO_REUSEADDR, true)
-                .option(ChannelOption.TCP_NODELAY, true)
+                .childOption(ChannelOption.TCP_NODELAY, true)
                 .childOption(ChannelOption.SO_KEEPALIVE, true);
         try {
             // Bind and start to accept incoming connections.

File: perf/src/main/java/io/moquette/parser/netty/performance/ProtocolPublishDecodingServer.java
Patch:
@@ -71,7 +71,7 @@ public void initChannel(SocketChannel ch) throws Exception {
                 })
                 .option(ChannelOption.SO_BACKLOG, 128)
                 .option(ChannelOption.SO_REUSEADDR, true)
-                .option(ChannelOption.TCP_NODELAY, true)
+                .childOption(ChannelOption.TCP_NODELAY, true)
                 .childOption(ChannelOption.SO_KEEPALIVE, true);
         try {
             // Bind and start to accept incoming connections.

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -115,4 +115,6 @@ public Set<Subscription> getSubscriptions() {
     public String toString() {
         return getClass().getSimpleName() + "{clientID='" + clientID + "'}";
     }
+
+    public abstract void wipeSubscriptions();
 }

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -235,7 +235,7 @@ public void processConnect(Channel channel, MqttConnectMessage msg) {
         }
 
         ConnectionDescriptor descriptor = new ConnectionDescriptor(clientId, channel, cleanSession);
-        ConnectionDescriptor existing = this.connectionDescriptors.addConnection(descriptor);
+        final ConnectionDescriptor existing = this.connectionDescriptors.addConnection(descriptor);
         if (existing != null) {
             LOG.info("Client ID is being used in an existing connection, force to be closed. CId={}", clientId);
             existing.abort();
@@ -616,7 +616,8 @@ private boolean removeSubscriptions(ConnectionDescriptor descriptor, String clie
 
         if (descriptor.cleanSession) {
             LOG.info("Removing saved subscriptions. CId={}", descriptor.clientID);
-            subscriptionStore.wipeSubscriptions(clientID);
+            final ClientSession session = this.sessionsRepository.sessionForClient(clientID);
+            session.wipeSubscriptions();
             LOG.info("Saved subscriptions have been removed. CId={}", descriptor.clientID);
         }
         return true;

File: broker/src/main/java/io/moquette/interception/HazelcastInterceptHandler.java
Patch:
@@ -24,6 +24,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import static io.moquette.spi.impl.Utils.readBytesAndRewind;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 public class HazelcastInterceptHandler extends AbstractInterceptHandler {
 
@@ -45,7 +46,8 @@ public void onPublish(InterceptPublishMessage msg) {
         ByteBuf payload = msg.getPayload();
         byte[] payloadContent = readBytesAndRewind(payload);
 
-        LOG.info("{} publish on {} message: {}", msg.getClientID(), msg.getTopicName(), new String(payloadContent));
+        LOG.info("{} publish on {} message: {}", msg.getClientID(), msg.getTopicName(),
+                 new String(payloadContent, UTF_8));
         ITopic<HazelcastMsg> topic = hz.getTopic("moquette");
         HazelcastMsg hazelcastMsg = new HazelcastMsg(msg);
         topic.publish(hazelcastMsg);

File: broker/src/main/java/io/moquette/persistence/MemoryMessagesStore.java
Patch:
@@ -41,7 +41,7 @@ public void initStore() {
     public void storeRetained(Topic topic, StoredMessage storedMessage) {
         LOG.debug("Store retained message for topic={}, CId={}", topic, storedMessage.getClientID());
         if (storedMessage.getClientID() == null) {
-            throw new IllegalArgumentException( "Message to be persisted must have a not null client ID");
+            throw new IllegalArgumentException("Message to be persisted must have a not null client ID");
         }
         m_retainedStore.put(topic, storedMessage);
     }

File: broker/src/main/java/io/moquette/persistence/MemorySessionStore.java
Patch:
@@ -33,7 +33,7 @@ public class MemorySessionStore implements ISessionsStore, ISubscriptionsStore {
 
     private static final Logger LOG = LoggerFactory.getLogger(MemorySessionStore.class);
 
-    class Session {
+    static class Session {
         final String clientID;
         final Map<Topic, Subscription> subscriptions = new ConcurrentHashMap<>();
         boolean cleanSession;
@@ -170,7 +170,6 @@ public Subscription reload(Subscription subcription) {
         return subscriptions.get(subcription.getTopicFilter());
     }
 
-
     @Override
     public StoredMessage inFlightAck(String clientID, int messageID) {
         return getSession(clientID).outboundFlightMessages.remove(messageID);

File: broker/src/main/java/io/moquette/server/config/ClasspathResourceLoader.java
Patch:
@@ -19,6 +19,8 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.nio.charset.StandardCharsets;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -51,7 +53,7 @@ public Reader loadDefaultResource() {
     public Reader loadResource(String relativePath) {
         LOG.info("Loading resource. RelativePath = {}.", relativePath);
         InputStream is = this.classLoader.getResourceAsStream(relativePath);
-        return is != null ? new InputStreamReader(is) : null;
+        return is != null ? new InputStreamReader(is, StandardCharsets.UTF_8) : null;
     }
 
     @Override

File: broker/src/main/java/io/moquette/server/netty/MoquetteIdleTimeoutHandler.java
Patch:
@@ -24,6 +24,8 @@
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
 
+import static io.netty.channel.ChannelFutureListener.CLOSE_ON_FAILURE;
+
 @Sharable
 class MoquetteIdleTimeoutHandler extends ChannelDuplexHandler {
 
@@ -37,7 +39,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
                 LOG.info("Firing channel inactive event. MqttClientId = {}.", NettyUtils.clientID(ctx.channel()));
                 // fire a channelInactive to trigger publish of Will
                 ctx.fireChannelInactive();
-                ctx.close();
+                ctx.close().addListener(CLOSE_ON_FAILURE);
             }
         } else {
             if (LOG.isDebugEnabled()) {

File: broker/src/main/java/io/moquette/server/netty/metrics/BytesMetricsHandler.java
Patch:
@@ -24,6 +24,8 @@
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 
+import static io.netty.channel.ChannelFutureListener.CLOSE_ON_FAILURE;
+
 public class BytesMetricsHandler extends ChannelDuplexHandler {
 
     private static final AttributeKey<BytesMetrics> ATTR_KEY_METRICS = AttributeKey.valueOf("BytesMetrics");
@@ -53,7 +55,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         BytesMetrics metrics = ctx.channel().attr(ATTR_KEY_METRICS).get();
         metrics.incrementWrote(((ByteBuf) msg).writableBytes());
-        ctx.write(msg, promise);
+        ctx.write(msg, promise).addListener(CLOSE_ON_FAILURE);
     }
 
     @Override

File: broker/src/main/java/io/moquette/server/netty/metrics/MQTTMessageLogger.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.List;
 
 import static io.moquette.spi.impl.Utils.messageId;
+import static io.netty.channel.ChannelFutureListener.CLOSE_ON_FAILURE;
 
 /**
  *
@@ -100,6 +101,6 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         logMQTTMessage(ctx, msg, "C<-B");
-        ctx.write(msg, promise);
+        ctx.write(msg, promise).addListener(CLOSE_ON_FAILURE);
     }
 }

File: broker/src/main/java/io/moquette/server/netty/metrics/MessageMetricsHandler.java
Patch:
@@ -23,6 +23,8 @@
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 
+import static io.netty.channel.ChannelFutureListener.CLOSE_ON_FAILURE;
+
 public class MessageMetricsHandler extends ChannelDuplexHandler {
 
     private static final AttributeKey<MessageMetrics> ATTR_KEY_METRICS = AttributeKey.valueOf("MessageMetrics");
@@ -52,7 +54,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         MessageMetrics metrics = ctx.channel().attr(ATTR_KEY_METRICS).get();
         metrics.incrementWrote(1);
-        ctx.write(msg, promise);
+        ctx.write(msg, promise).addListener(CLOSE_ON_FAILURE);
     }
 
     @Override

File: broker/src/main/java/io/moquette/spi/TransientSession.java
Patch:
@@ -30,7 +30,7 @@ public class TransientSession extends ClientSession {
 
     private static final Logger LOG = LoggerFactory.getLogger(TransientSession.class);
 
-    private Queue<StoredMessage> messagesQueue = new LinkedList<>();
+    private Queue<StoredMessage> messagesQueue = new ArrayDeque<>();
 
     private final AtomicInteger packetGenerator = new AtomicInteger(1);
 
@@ -43,7 +43,7 @@ public TransientSession(String clientID) {
     }
 
     @Override
-    public void disconnect() {}
+    public void disconnect() { }
 
     @Override
     public boolean isCleanSession() {

File: broker/src/main/java/io/moquette/spi/impl/DebugUtils.java
Patch:
@@ -18,10 +18,12 @@
 
 import io.netty.buffer.ByteBuf;
 
+import java.nio.charset.StandardCharsets;
+
 final class DebugUtils {
 
     static String payload2Str(ByteBuf content) {
-        return new String(content.copy().array());
+        return new String(content.copy().array(), StandardCharsets.UTF_8);
     }
 
     private DebugUtils() {

File: broker/src/main/java/io/moquette/spi/impl/SessionsRepository.java
Patch:
@@ -33,7 +33,8 @@
 public class SessionsRepository {
 
     /**
-     * Task to be scheduled to execute the cleaning of persisted sessions (clean flag=false) older than a defined period.
+     * Task to be scheduled to execute the cleaning of persisted sessions (clean flag=false) older than a
+     * defined period.
      */
     private class SessionCleanerTask implements Runnable {
 
@@ -55,6 +56,7 @@ public SessionsRepository(ISessionsStore sessionsStore, ScheduledExecutorService
         this.scheduler = scheduler;
     }
 
+    @SuppressWarnings("FutureReturnValueIgnored")
     public void init() {
         SessionCleanerTask cleanerTask = new SessionCleanerTask();
         this.scheduler.schedule(cleanerTask, 1, TimeUnit.HOURS);

File: broker/src/main/java/io/moquette/spi/impl/security/AcceptAllAuthenticator.java
Patch:
@@ -20,6 +20,7 @@
 
 public class AcceptAllAuthenticator implements IAuthenticator {
 
+    @Override
     public boolean checkValid(String clientId, String username, byte[] password) {
         return true;
     }

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Token.java
Patch:
@@ -35,11 +35,11 @@ protected String name() {
     }
 
     protected boolean match(Token t) {
-        if (t == MULTI || t == SINGLE) {
+        if (MULTI.equals(t) || SINGLE.equals(t)) {
             return false;
         }
 
-        if (this == MULTI || this == SINGLE) {
+        if (MULTI.equals(this) || SINGLE.equals(this)) {
             return true;
         }
 

File: broker/src/test/java/io/moquette/server/MessageCollector.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class MessageCollector implements MqttCallback {
 
-    private final class ReceivedMessage {
+    private static final class ReceivedMessage {
 
         private final MqttMessage message;
         private final String topic;

File: broker/src/test/java/io/moquette/server/ServerIntegrationFuseTest.java
Patch:
@@ -27,6 +27,8 @@
 import java.io.IOException;
 import java.util.Properties;
 import java.util.concurrent.TimeUnit;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.*;
 
 public class ServerIntegrationFuseTest {
@@ -98,6 +100,6 @@ public void checkWillTestamentIsPublishedOnConnectionKill_noRetain() throws Exce
         Message msg = m_subscriber.receive(500, TimeUnit.MILLISECONDS);
         assertNotNull("We should get notified with 'Will' message", msg);
         msg.ack();
-        assertEquals(willTestamentMsg, new String(msg.getPayload()));
+        assertEquals(willTestamentMsg, new String(msg.getPayload(), UTF_8));
     }
 }

File: broker/src/test/java/io/moquette/server/ServerIntegrationSSLTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.moquette.server;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertFalse;
 import java.io.File;
 import java.io.IOException;
@@ -150,7 +151,7 @@ public void checkSupportSSLForMultipleClient() throws Exception {
         MqttConnectOptions secondClientOptions = new MqttConnectOptions();
         secondClientOptions.setSocketFactory(ssf);
         secondClient.connect(secondClientOptions);
-        secondClient.publish("/topic", new MqttMessage("message".getBytes()));
+        secondClient.publish("/topic", new MqttMessage("message".getBytes(UTF_8)));
         secondClient.disconnect();
 
         m_client.disconnect();

File: broker/src/test/java/io/moquette/server/ServerIntegrationWebSocketTest.java
Patch:
@@ -65,6 +65,7 @@ public void tearDown() throws Exception {
         m_server.stopServer();
     }
 
+    @SuppressWarnings("FutureReturnValueIgnored")
     @Test
     public void checkPlainConnect() throws Exception {
         LOG.info("*** checkPlainConnect ***");

File: broker/src/test/java/io/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -33,6 +33,7 @@
 import java.util.Properties;
 import java.util.concurrent.TimeUnit;
 import static io.netty.handler.codec.mqtt.MqttConnectReturnCode.*;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.*;
 
 public class ServerLowlevelMessagesIntegrationTests {
@@ -121,7 +122,7 @@ public void testWillMessageIsWiredOnClientKeepAliveExpiry() throws Exception {
                 assertNotNull("the will message should be fired after keep alive!", msg);
                 // the will message hasn't to be received before the elapsing of Keep Alive timeout
                 assertTrue(System.currentTimeMillis() - connectTime > 3000);
-                assertEquals(willTestamentMsg, new String(msg.getPayload(), StandardCharsets.UTF_8));
+                assertEquals(willTestamentMsg, new String(msg.getPayload(), UTF_8));
         });
 
         m_willSubscriber.disconnect();
@@ -153,7 +154,7 @@ public void testWillMessageIsPublishedOnClientBadDisconnection() throws Interrup
 
         // Verify will testament is published
         org.eclipse.paho.client.mqttv3.MqttMessage receivedTestament = m_messageCollector.waitMessage(1);
-        assertEquals(willTestamentMsg, new String(receivedTestament.getPayload()));
+        assertEquals(willTestamentMsg, new String(receivedTestament.getPayload(), UTF_8));
         m_willSubscriber.disconnect();
     }
 

File: broker/src/test/java/io/moquette/spi/impl/BrokerInterceptorTest.java
Patch:
@@ -30,6 +30,7 @@
 import java.util.Collections;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.refEq;
 import static org.mockito.Mockito.mock;
@@ -126,7 +127,7 @@ public void testNotifyClientDisconnected() throws Exception {
     public void testNotifyTopicPublished() throws Exception {
         interceptor.notifyTopicPublished(
                 MqttMessageBuilders.publish().qos(MqttQoS.AT_MOST_ONCE)
-                    .payload(Unpooled.copiedBuffer("Hello".getBytes())).build(),
+                    .payload(Unpooled.copiedBuffer("Hello".getBytes(UTF_8))).build(),
                 "cli1234",
                 "cli1234");
         interval();

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessorTest.java
Patch:
@@ -42,6 +42,7 @@
 import static io.moquette.spi.impl.ProtocolProcessor.lowerQosToTheSubscriptionDesired;
 import static io.netty.handler.codec.mqtt.MqttQoS.AT_LEAST_ONCE;
 import static io.netty.handler.codec.mqtt.MqttQoS.AT_MOST_ONCE;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
@@ -61,7 +62,6 @@ public class ProtocolProcessorTest extends AbstractProtocolProcessorCommonUtils
     static final List<InterceptHandler> EMPTY_OBSERVERS = Collections.emptyList();
     static final BrokerInterceptor NO_OBSERVERS_INTERCEPTOR = new BrokerInterceptor(EMPTY_OBSERVERS);
 
-
     @Before
     public void setUp() throws InterruptedException {
         initializeProcessorAndSubsystems();
@@ -143,7 +143,7 @@ public List<Subscription> matches(Topic topic) {
 
         // Exercise
         MqttPublishMessage msg = MqttMessageBuilders.publish().topicName(FAKE_TOPIC).qos(AT_MOST_ONCE)
-                .retained(false).payload(Unpooled.copiedBuffer("Hello".getBytes())).build();
+                .retained(false).payload(Unpooled.copiedBuffer("Hello".getBytes(UTF_8))).build();
         NettyUtils.userName(m_channel, "FakeCLI");
         m_processor.processPublish(m_channel, msg);
 
@@ -269,7 +269,7 @@ public void testRepublishAndConsumePersistedMessages_onReconnect() {
         List<Subscription> emptySubs = Collections.emptyList();
         when(subs.matches(any(Topic.class))).thenReturn(emptySubs);
 
-        StoredMessage retainedMessage = new StoredMessage("Hello".getBytes(), MqttQoS.EXACTLY_ONCE, "/topic");
+        StoredMessage retainedMessage = new StoredMessage("Hello".getBytes(UTF_8), MqttQoS.EXACTLY_ONCE, "/topic");
         retainedMessage.setRetained(true);
         retainedMessage.setClientID(FAKE_PUBLISHER_ID);
         m_messagesStore.storeRetained(new Topic("/topic"), retainedMessage);

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessor_VariousUseCases_Test.java
Patch:
@@ -201,7 +201,8 @@ public void testPublishWithQoS2() throws InterruptedException {
     }
 
     @Test
-    public void avoidMultipleNotificationsAfterMultipleReconnection_cleanSessionFalseQoS1() throws InterruptedException {
+    public void avoidMultipleNotificationsAfterMultipleReconnection_cleanSessionFalseQoS1()
+            throws InterruptedException {
         connect();
         subscribe("/topic", AT_LEAST_ONCE);
         disconnect();
@@ -221,7 +222,6 @@ public void avoidMultipleNotificationsAfterMultipleReconnection_cleanSessionFals
         verifyPublishIsReceived("Hello MQTT 2", AT_LEAST_ONCE);
     }
 
-
     @Test
     public void testConnectSubPub_cycle_getTimeout_on_second_disconnect_issue142() throws InterruptedException {
         connect();

File: broker/src/test/java/io/moquette/spi/impl/subscriptions/TopicTest.java
Patch:
@@ -122,7 +122,6 @@ public void exceptHeadToken() {
         assertEquals(Topic.asTopic("a/b"), Topic.asTopic("/a/b").exceptHeadToken());
     }
 
-
     public static TopicAssert assertThat(Topic topic) {
         return new TopicAssert(topic);
     }

File: h2_storage/src/test/java/io/moquette/persistence/h2/H2SessionsStoreTest.java
Patch:
@@ -97,7 +97,8 @@ public void testListAllSessionsOlderThan() {
     }
 
     @Test
-    public void testRetrieve1000ExpiredSessionPerformance() throws InterruptedException, ExecutionException, TimeoutException {
+    public void testRetrieve1000ExpiredSessionPerformance() throws InterruptedException, ExecutionException,
+                TimeoutException {
         H2SessionsStore sessionsStore = (H2SessionsStore) storageService.sessionsStore();
 
         final ExecutorService executorService = Executors.newFixedThreadPool(2);

File: mapdb_storage/src/main/java/io/moquette/persistence/mapdb/MapDBMessagesStore.java
Patch:
@@ -78,7 +78,7 @@ public void cleanRetained(Topic topic) {
     public void storeRetained(Topic topic, StoredMessage storedMessage) {
         LOG.debug("Store retained message for topic={}, CId={}", topic, storedMessage.getClientID());
         if (storedMessage.getClientID() == null) {
-            throw new IllegalArgumentException( "Message to be persisted must have a not null client ID");
+            throw new IllegalArgumentException("Message to be persisted must have a not null client ID");
         }
         m_retainedStore.put(topic, storedMessage);
     }

File: mapdb_storage/src/main/java/io/moquette/persistence/mapdb/MapDBPersistentStore.java
Patch:
@@ -63,6 +63,7 @@ public ISessionsStore sessionsStore() {
         return m_sessionsStore;
     }
 
+    @SuppressWarnings("FutureReturnValueIgnored")
     @Override
     public void initStore() {
         LOG.info("Initializing MapDB store");

File: mapdb_storage/src/test/java/io/moquette/persistence/mapdb/MapDBPersistentStoreTest.java
Patch:
@@ -28,11 +28,13 @@
 import org.junit.Test;
 
 import java.io.File;
+import java.nio.charset.StandardCharsets;
 import java.util.Properties;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.*;
 
 /**
@@ -99,7 +101,7 @@ public void testNextPacketID_existingClientSession() {
 
     @Test
     public void testNextPacketID() {
-        StoredMessage msgStored = new StoredMessage("Hello".getBytes(), MqttQoS.AT_LEAST_ONCE, "/topic");
+        StoredMessage msgStored = new StoredMessage("Hello".getBytes(UTF_8), MqttQoS.AT_LEAST_ONCE, "/topic");
         msgStored.setClientID(TEST_CLIENT);
 
         // request a first ID

File: mapdb_storage/src/test/java/io/moquette/persistence/mapdb/MapDBSessionsStoreTest.java
Patch:
@@ -98,7 +98,8 @@ public void testListAllSessionsOlderThan() {
     }
 
     @Test
-    public void testRetrieve1000ExpiredSessionPerformance() throws InterruptedException, ExecutionException, TimeoutException {
+    public void testRetrieve1000ExpiredSessionPerformance() throws InterruptedException, ExecutionException,
+                TimeoutException {
         MapDBSessionsStore sessionsStore = (MapDBSessionsStore) storageService.sessionsStore();
 
         final ExecutorService executorService = Executors.newFixedThreadPool(2);

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -57,6 +57,8 @@ public final class BrokerConstants {
     public static final String NETTY_SO_KEEPALIVE_PROPERTY_NAME = "netty.so_keepalive";
     public static final String NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME = "netty.channel_timeout.seconds";
     public static final String NETTY_EPOLL_PROPERTY_NAME = "netty.epoll";
+    public static final String NETTY_MAX_BYTES_PROPERTY_NAME = "netty.mqtt.message_size";
+    public static final int DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE = 8092;
     public static final String METRICS_ENABLE_PROPERTY_NAME = "use_metrics";
     public static final String METRICS_LIBRATO_EMAIL_PROPERTY_NAME = "metrics.librato.email";
     public static final String METRICS_LIBRATO_TOKEN_PROPERTY_NAME = "metrics.librato.token";

File: broker/src/main/java/io/moquette/server/config/IConfig.java
Patch:
@@ -42,6 +42,8 @@ void assignDefaults() {
         setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, Boolean.TRUE.toString());
         setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, "");
         setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, "");
+        setProperty(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,
+            String.valueOf(BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE));
     }
 
     public abstract IResourceLoader getResourceLoader();

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -57,6 +57,8 @@ public final class BrokerConstants {
     public static final String NETTY_SO_KEEPALIVE_PROPERTY_NAME = "netty.so_keepalive";
     public static final String NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME = "netty.channel_timeout.seconds";
     public static final String NETTY_EPOLL_PROPERTY_NAME = "netty.epoll";
+    public static final String NETTY_MAX_BYTES_PROPERTY_NAME = "netty.mqtt.message_size";
+    public static final int DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE = 8092;
     public static final String METRICS_ENABLE_PROPERTY_NAME = "use_metrics";
     public static final String METRICS_LIBRATO_EMAIL_PROPERTY_NAME = "metrics.librato.email";
     public static final String METRICS_LIBRATO_TOKEN_PROPERTY_NAME = "metrics.librato.token";

File: broker/src/main/java/io/moquette/server/config/IConfig.java
Patch:
@@ -42,6 +42,8 @@ void assignDefaults() {
         setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, Boolean.TRUE.toString());
         setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, "");
         setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, "");
+        setProperty(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,
+            String.valueOf(BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE));
     }
 
     public abstract IResourceLoader getResourceLoader();

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -844,7 +844,7 @@ private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscrip
             grantedQoSLevels.add(req.qualityOfService().value());
         }
 
-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_LEAST_ONCE, false, 0);
+        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE, false, 0);
         MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels);
         return new MqttSubAckMessage(fixedHeader, from(messageId), payload);
     }

File: h2_storage/src/test/java/io/moquette/persistence/h2/H2PersistentQueueTest.java
Patch:
@@ -4,6 +4,7 @@
 import org.h2.mvstore.MVStore;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -54,6 +55,7 @@ public void testPoll() {
         assertTrue("after poll 2 elements inserted before, should be empty", sut.isEmpty());
     }
 
+    @Ignore
     @Test
     public void testPerformance() {
         H2PersistentQueue<String> sut = new H2PersistentQueue<>(this.mvStore, "test");

File: h2_storage/src/test/java/io/moquette/persistence/h2/H2PersistentQueueTest.java
Patch:
@@ -4,6 +4,7 @@
 import org.h2.mvstore.MVStore;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -54,6 +55,7 @@ public void testPoll() {
         assertTrue("after poll 2 elements inserted before, should be empty", sut.isEmpty());
     }
 
+    @Ignore
     @Test
     public void testPerformance() {
         H2PersistentQueue<String> sut = new H2PersistentQueue<>(this.mvStore, "test");

File: broker/src/main/java/io/moquette/persistence/MemorySessionStore.java
Patch:
@@ -303,7 +303,7 @@ public int getSecondPhaseAckPendingMessages(String clientID) {
 
     @Override
     public void cleanSession(String clientID) {
-        LOG.error("Fooooooooo <{}>", clientID);
+        LOG.debug("Session cleanup for client <{}>", clientID);
 
         Session session = sessions.get(clientID);
         if (session == null) {

File: broker/src/main/java/io/moquette/persistence/MemorySessionStore.java
Patch:
@@ -303,7 +303,7 @@ public int getSecondPhaseAckPendingMessages(String clientID) {
 
     @Override
     public void cleanSession(String clientID) {
-        LOG.error("Fooooooooo <{}>", clientID);
+        LOG.debug("Session cleanup for client <{}>", clientID);
 
         Session session = sessions.get(clientID);
         if (session == null) {

File: broker/src/main/java/io/moquette/server/netty/BugSnagErrorsHandler.java
Patch:
@@ -17,11 +17,13 @@
 
 import com.bugsnag.Bugsnag;
 import io.moquette.server.config.IConfig;
+import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
 import static io.moquette.BrokerConstants.BUGSNAG_TOKEN_PROPERTY_NAME;
 
+@Sharable
 public class BugSnagErrorsHandler extends ChannelInboundHandlerAdapter {
 
     private Bugsnag bugsnag;

File: broker/src/main/java/io/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -218,6 +218,9 @@ void init(ChannelPipeline pipeline) {
                 pipeline.addFirst("idleStateHandler", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));
                 pipeline.addAfter("idleStateHandler", "idleEventHandler", timeoutHandler);
                 // pipeline.addLast("logger", new LoggingHandler("Netty", LogLevel.ERROR));
+                if (errorsCather.isPresent()) {
+                    pipeline.addLast("bugsnagCatcher", errorsCather.get());
+                }
                 pipeline.addFirst("bytemetrics", new BytesMetricsHandler(m_bytesMetricsCollector));
                 pipeline.addLast("decoder", new MqttDecoder());
                 pipeline.addLast("encoder", MqttEncoder.INSTANCE);

File: mapdb_storage/src/main/java/io/moquette/persistence/mapdb/MapDBSessionsStore.java
Patch:
@@ -191,7 +191,7 @@ public int nextPacketID(String clientID) {
         Set<Integer> inFlightForClient = this.m_inFlightIds.get(clientID);
         if (inFlightForClient == null) {
             int nextPacketId = 1;
-            inFlightForClient = Collections.newSetFromMap(new ConcurrentHashMap<Integer, Boolean>());
+            inFlightForClient = Collections.newSetFromMap(new ConcurrentHashMap<>());
             inFlightForClient.add(nextPacketId);
             this.m_inFlightIds.put(clientID, inFlightForClient);
             return nextPacketId;

File: broker/src/test/java/io/moquette/spi/ClientSessionTest.java
Patch:
@@ -36,7 +36,7 @@ public class ClientSessionTest {
     @Before
     public void setUp() {
         store = new SubscriptionsDirectory();
-        MemoryStorageService storageService = new MemoryStorageService();
+        MemoryStorageService storageService = new MemoryStorageService(null, null);
         this.sessionsStore = storageService.sessionsStore();
         store.init(sessionsStore);
 

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessor_CONNECT_Test.java
Patch:
@@ -60,7 +60,7 @@ public void setUp() throws InterruptedException {
 
         // sleep to let the messaging batch processor to process the initEvent
         Thread.sleep(300);
-        MemoryStorageService memStorage = new MemoryStorageService();
+        MemoryStorageService memStorage = new MemoryStorageService(null, null);
         m_messagesStore = memStorage.messagesStore();
         m_sessionStore = memStorage.sessionsStore();
         // m_messagesStore.initStore();

File: perf/src/main/java/io/moquette/spi/impl/subscriptions/PerformanceTest.java
Patch:
@@ -35,7 +35,7 @@ public final class PerformanceTest {
      */
     public static void main(String[] args) throws IOException, InterruptedException {
         SubscriptionsDirectory store = new SubscriptionsDirectory();
-        MemoryStorageService memStore = new MemoryStorageService();
+        MemoryStorageService memStore = new MemoryStorageService(null, null);
         ISessionsStore aSessionsStore = memStore.sessionsStore();
         store.init(aSessionsStore);
 

File: broker/src/main/java/io/moquette/server/netty/NettyMQTTHandler.java
Patch:
@@ -86,6 +86,7 @@ public void channelRead(ChannelHandlerContext ctx, Object message) {
         } catch (Throwable ex) {
             LOG.error("Exception was caught while processing MQTT message, " + ex.getCause(), ex);
             ctx.fireExceptionCaught(ex);
+            ctx.close();
         }
     }
 

File: broker/src/main/java/io/moquette/spi/ISessionsStore.java
Patch:
@@ -131,5 +131,5 @@ public interface ISessionsStore {
      */
     int getSecondPhaseAckPendingMessages(String clientID);
 
-    void dropInFlightMessagesInSession(String clientID);
+    void cleanSession(String clientID);
 }

File: h2_storage/src/main/java/io/moquette/persistence/h2/H2MessagesStore.java
Patch:
@@ -17,15 +17,13 @@
 
 import io.moquette.spi.IMatchingCondition;
 import io.moquette.spi.IMessagesStore;
-import io.moquette.spi.IMessagesStore.StoredMessage;
 import io.moquette.spi.MessageGUID;
 import io.moquette.spi.impl.subscriptions.Topic;
 import org.h2.mvstore.Cursor;
 import org.h2.mvstore.MVMap;
 import org.h2.mvstore.MVStore;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import sun.plugin2.message.Message;
 
 import java.util.*;
 

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Subscription.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.moquette.spi.impl.subscriptions;
 
-import io.moquette.spi.ISessionsStore.ClientTopicCouple;
+import io.moquette.spi.ISubscriptionsStore.ClientTopicCouple;
 import io.netty.handler.codec.mqtt.MqttQoS;
 import java.io.Serializable;
 

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/TreeNode.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.moquette.spi.impl.subscriptions;
 
-import io.moquette.spi.ISessionsStore.ClientTopicCouple;
+import io.moquette.spi.ISubscriptionsStore.ClientTopicCouple;
 import java.util.*;
 import java.util.concurrent.LinkedBlockingQueue;
 

File: broker/src/test/java/io/moquette/spi/ClientSessionTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.moquette.persistence.MemoryStorageService;
 import io.moquette.spi.impl.subscriptions.Subscription;
-import io.moquette.spi.impl.subscriptions.SubscriptionsStore;
+import io.moquette.spi.impl.subscriptions.SubscriptionsDirectory;
 import io.moquette.spi.impl.subscriptions.Topic;
 import static io.netty.handler.codec.mqtt.MqttQoS.*;
 import org.junit.Before;
@@ -31,11 +31,11 @@ public class ClientSessionTest {
     ClientSession session1;
     ClientSession session2;
     ISessionsStore sessionsStore;
-    SubscriptionsStore store;
+    SubscriptionsDirectory store;
 
     @Before
     public void setUp() {
-        store = new SubscriptionsStore();
+        store = new SubscriptionsDirectory();
         MemoryStorageService storageService = new MemoryStorageService();
         this.sessionsStore = storageService.sessionsStore();
         store.init(sessionsStore);

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessor_CONNECT_Test.java
Patch:
@@ -24,7 +24,7 @@
 import io.moquette.spi.ISessionsStore;
 import io.moquette.spi.impl.security.PermitAllAuthorizator;
 import io.moquette.spi.impl.subscriptions.Subscription;
-import io.moquette.spi.impl.subscriptions.SubscriptionsStore;
+import io.moquette.spi.impl.subscriptions.SubscriptionsDirectory;
 import io.moquette.spi.impl.subscriptions.Topic;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.mqtt.MqttConnectMessage;
@@ -51,7 +51,7 @@ public class ProtocolProcessor_CONNECT_Test {
 
     IMessagesStore m_messagesStore;
     ISessionsStore m_sessionStore;
-    SubscriptionsStore subscriptions;
+    SubscriptionsDirectory subscriptions;
     MockAuthenticator m_mockAuthenticator;
 
     @Before
@@ -73,7 +73,7 @@ public void setUp() throws InterruptedException {
         users.put(ProtocolProcessorTest.TEST_USER, ProtocolProcessorTest.TEST_PWD);
         m_mockAuthenticator = new MockAuthenticator(clientIds, users);
 
-        subscriptions = new SubscriptionsStore();
+        subscriptions = new SubscriptionsDirectory();
         subscriptions.init(m_sessionStore);
         m_processor = new ProtocolProcessor();
         m_processor.init(

File: perf/src/main/java/io/moquette/spi/impl/subscriptions/PerformanceTest.java
Patch:
@@ -34,7 +34,7 @@ public final class PerformanceTest {
        cpufreq-set -g performance -u 800MHz -c 3
      */
     public static void main(String[] args) throws IOException, InterruptedException {
-        SubscriptionsStore store = new SubscriptionsStore();
+        SubscriptionsDirectory store = new SubscriptionsDirectory();
         MemoryStorageService memStore = new MemoryStorageService();
         ISessionsStore aSessionsStore = memStore.sessionsStore();
         store.init(aSessionsStore);
@@ -56,7 +56,7 @@ public static void main(String[] args) throws IOException, InterruptedException
                             + ((i / (users * devices * values)) % subs));
 
             Subscription sub = new Subscription("CLI_ID_" + (i % users), topics[i], MqttQoS.AT_MOST_ONCE);
-            aSessionsStore.addNewSubscription(sub);
+            aSessionsStore.subscriptionStore().addNewSubscription(sub);
             store.add(sub.asClientTopicCouple());
         }
 

File: broker/src/main/java/io/moquette/interception/AbstractInterceptHandler.java
Patch:
@@ -26,8 +26,6 @@
 
 /**
  * Basic abstract class usefull to avoid empty methods creation in subclasses.
- *
- * Created by andrea on 08/12/15.
  */
 public abstract class AbstractInterceptHandler implements InterceptHandler {
 

File: broker/src/main/java/io/moquette/interception/InterceptHandler.java
Patch:
@@ -28,8 +28,6 @@
  * Almost every method receives a subclass of {@link MqttMessage}, except <code>onDisconnect</code>
  * that receives the client id string and <code>onSubscribe</code> and <code>onUnsubscribe</code>
  * that receive a {@link Subscription} object.
- *
- * @author Wagner Macedo
  */
 public interface InterceptHandler {
 

File: broker/src/main/java/io/moquette/interception/messages/InterceptAbstractMessage.java
Patch:
@@ -19,9 +19,6 @@
 import io.netty.handler.codec.mqtt.MqttMessage;
 import io.netty.handler.codec.mqtt.MqttQoS;
 
-/**
- * @author Wagner Macedo
- */
 public abstract class InterceptAbstractMessage implements InterceptMessage {
 
     private final MqttMessage msg;

File: broker/src/main/java/io/moquette/server/ConnectionDescriptor.java
Patch:
@@ -32,9 +32,6 @@
 /**
  * Value object to maintain the information of single connection, like ClientID, Channel, and clean
  * session flag.
- *
- *
- * @author andrea
  */
 public class ConnectionDescriptor {
 

File: broker/src/main/java/io/moquette/server/DefaultMoquetteSslContextCreator.java
Patch:
@@ -33,16 +33,14 @@
 /**
  * Moquette server implementation to load SSL certificate from local filesystem path configured in
  * config file.
- *
- * Created by andrea on 13/12/15.
  */
 class DefaultMoquetteSslContextCreator implements ISslContextCreator {
 
     private static final Logger LOG = LoggerFactory.getLogger(DefaultMoquetteSslContextCreator.class);
 
     private IConfig props;
 
-    public DefaultMoquetteSslContextCreator(IConfig props) {
+    DefaultMoquetteSslContextCreator(IConfig props) {
         this.props = props;
     }
 

File: broker/src/main/java/io/moquette/server/Server.java
Patch:
@@ -52,8 +52,6 @@
 
 /**
  * Launch a configured version of the server.
- *
- * @author andrea
  */
 public class Server {
 
@@ -336,7 +334,7 @@ public IConnectionsManager getConnectionsManager() {
     public ProtocolProcessor getProcessor() {
         return m_processor;
     }
-    
+
     public ScheduledExecutorService getScheduler() {
         return scheduler;
     }

File: broker/src/main/java/io/moquette/server/config/ConfigurationParser.java
Patch:
@@ -32,8 +32,6 @@
  *
  * A line that at the very first has # is a comment Each line has key value format, where the
  * separator used it the space.
- *
- * @author andrea
  */
 class ConfigurationParser {
 

File: broker/src/main/java/io/moquette/server/config/IConfig.java
Patch:
@@ -20,8 +20,6 @@
 
 /**
  * Base interface for all configuration implementations (filesystem, memory or classpath)
- *
- * @author andrea
  */
 public abstract class IConfig {
 

File: broker/src/main/java/io/moquette/server/config/MemoryConfig.java
Patch:
@@ -21,8 +21,6 @@
 
 /**
  * Configuration backed by memory.
- *
- * @author andrea
  */
 public class MemoryConfig extends IConfig {
 

File: broker/src/main/java/io/moquette/server/netty/metrics/BytesMetrics.java
Patch:
@@ -18,8 +18,8 @@
 
 public class BytesMetrics {
 
-    private long m_readBytes = 0;
-    private long m_wroteBytes = 0;
+    private long m_readBytes;
+    private long m_wroteBytes;
 
     void incrementRead(long numBytes) {
         m_readBytes += numBytes;

File: broker/src/main/java/io/moquette/server/netty/metrics/MessageMetrics.java
Patch:
@@ -18,8 +18,8 @@
 
 public class MessageMetrics {
 
-    private long m_messagesRead = 0;
-    private long m_messageWrote = 0;
+    private long m_messagesRead;
+    private long m_messageWrote;
 
     void incrementRead(long numMessages) {
         m_messagesRead += numMessages;

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -38,8 +38,6 @@
  *     completely acknowledged.</li>
  *     <li>Optionally, QoS 0 messages pending transmission to the Client.</li>
  * </ul>
- *
- * @author andrea
  */
 public class ClientSession {
 
@@ -76,7 +74,7 @@ public void waitingRel(int messageID, MessageGUID guid) {
         }
     }
 
-    private final static Logger LOG = LoggerFactory.getLogger(ClientSession.class);
+    private static final Logger LOG = LoggerFactory.getLogger(ClientSession.class);
 
     public final String clientID;
 

File: broker/src/main/java/io/moquette/spi/IMatchingCondition.java
Patch:
@@ -18,8 +18,6 @@
 
 import io.moquette.spi.impl.subscriptions.Topic;
 
-/**
- */
 public interface IMatchingCondition {
 
     boolean match(Topic key);

File: broker/src/main/java/io/moquette/spi/IMessaging.java
Patch:
@@ -20,8 +20,6 @@
  * Callback interface used to be notified of some events from the input event queue.
  *
  * It's the abstraction of the messaging stuff attached in after the front protocol parsing stuff.
- *
- * @author andrea
  */
 public interface IMessaging {
 }

File: broker/src/main/java/io/moquette/spi/ISessionsStore.java
Patch:
@@ -26,8 +26,6 @@
 
 /**
  * Store used to handle the persistence of the subscriptions tree.
- *
- * @author andrea
  */
 public interface ISessionsStore {
 
@@ -66,7 +64,6 @@ public int hashCode() {
         public String toString() {
             return "ClientTopicCouple{" + "topicFilter='" + topicFilter + '\'' + ", clientID='" + clientID + '\'' + '}';
         }
-
     }
 
     void initStore();

File: broker/src/main/java/io/moquette/spi/impl/security/Authorization.java
Patch:
@@ -21,8 +21,6 @@
 
 /**
  * Carries the read/write authorization to topics for the users.
- *
- * @author andrea
  */
 public class Authorization {
 

File: broker/src/main/java/io/moquette/spi/impl/security/DenyAllAuthorizator.java
Patch:
@@ -19,9 +19,6 @@
 import io.moquette.spi.impl.subscriptions.Topic;
 import io.moquette.spi.security.IAuthorizator;
 
-/**
- * @author andrea
- */
 public class DenyAllAuthorizator implements IAuthorizator {
 
     @Override

File: broker/src/main/java/io/moquette/spi/impl/security/FileAuthenticator.java
Patch:
@@ -31,7 +31,6 @@
  * NB -n is important because echo append a newline by default at the of string. -n avoid this
  * behaviour.
  *
- * @author andrea
  * @deprecated user {@link ResourceAuthenticator} instead
  */
 public class FileAuthenticator extends ResourceAuthenticator {

File: broker/src/main/java/io/moquette/spi/impl/security/PermitAllAuthorizator.java
Patch:
@@ -19,9 +19,6 @@
 import io.moquette.spi.impl.subscriptions.Topic;
 import io.moquette.spi.security.IAuthorizator;
 
-/**
- * @author andrea
- */
 public class PermitAllAuthorizator implements IAuthorizator {
 
     @Override

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Subscription.java
Patch:
@@ -22,9 +22,6 @@
 
 /**
  * Maintain the information about which Topic a certain ClientID is subscribed and at which QoS
- *
- *
- * @author andrea
  */
 public final class Subscription implements Serializable {
 

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/TreeNode.java
Patch:
@@ -26,7 +26,7 @@ class TreeNode {
     List<TreeNode> m_children = new ArrayList<>();
     Set<ClientTopicCouple> m_subscriptions = new HashSet<>();
 
-    private int subtreeSubscriptions = 0;
+    private int subtreeSubscriptions;
 
     TreeNode() {
     }

File: broker/src/main/java/io/moquette/spi/security/IAuthenticator.java
Patch:
@@ -18,8 +18,6 @@
 
 /**
  * username and password checker
- *
- * @author andrea
  */
 public interface IAuthenticator {
 

File: broker/src/main/java/io/moquette/spi/security/IAuthorizator.java
Patch:
@@ -23,8 +23,6 @@
  *
  * Create an authorizator that matches topic names with same grammar of subscriptions. The # is
  * always a terminator and its the multilevel matcher. The + sign is the single level matcher.
- *
- * @author andrea
  */
 public interface IAuthorizator {
 

File: broker/src/main/java/io/moquette/spi/security/ISslContextCreator.java
Patch:
@@ -20,8 +20,6 @@
 
 /**
  * SSL certificate loader used to open SSL connections (websocket and MQTT-S).
- *
- * Created by andrea on 13/12/15.
  */
 public interface ISslContextCreator {
 

File: broker/src/test/java/io/moquette/server/MessageCollector.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class MessageCollector implements MqttCallback {
 
-    private class ReceivedMessage {
+    private final class ReceivedMessage {
 
         private final MqttMessage message;
         private final String topic;
@@ -38,7 +38,7 @@ private ReceivedMessage(MqttMessage message, String topic) {
     }
 
     private BlockingQueue<ReceivedMessage> m_messages = new LinkedBlockingQueue<>();
-    private boolean m_connectionLost = false;
+    private boolean m_connectionLost;
 
     /**
      * Return the message from the queue if not empty, else return null with wait period.

File: broker/src/test/java/io/moquette/server/ServerIntegrationSSLTest.java
Patch:
@@ -49,8 +49,6 @@
 
 /**
  * Check that Moquette could also handle SSL.
- *
- * @author andrea
  */
 public class ServerIntegrationSSLTest {
 

File: broker/src/test/java/io/moquette/server/ServerIntegrationWebSocketTest.java
Patch:
@@ -34,8 +34,6 @@
 
 /**
  * Integration test to check the function of Moquette with a WebSocket channel.
- *
- * @author andrea
  */
 public class ServerIntegrationWebSocketTest {
 

File: broker/src/test/java/io/moquette/spi/impl/BrokerInterceptorTest.java
Patch:
@@ -32,9 +32,6 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-/**
- * @author Wagner Macedo
- */
 public class BrokerInterceptorTest {
 
     // value to check for changes after every notification

File: broker/src/test/java/io/moquette/spi/impl/MockAuthenticator.java
Patch:
@@ -22,8 +22,6 @@
 
 /**
  * Test utility to implements authenticator instance.
- *
- * @author andrea
  */
 class MockAuthenticator implements IAuthenticator {
 

File: broker/src/test/java/io/moquette/spi/impl/NettyChannelAssertions.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Some useful assertions used by Netty's EmbeddedChannel in tests.
  */
-class NettyChannelAssertions {
+final class NettyChannelAssertions {
 
     static void assertEqualsConnAck(MqttConnectReturnCode expectedCode, Object connAck) {
         assertEqualsConnAck(null, expectedCode, connAck);
@@ -54,4 +54,6 @@ static void assertEqualsSubAck(/* byte expectedCode, */ Object subAck) {
         // assertEquals(expectedCode, connAckMsg.getReturnCode());
     }
 
+    private NettyChannelAssertions() {
+    }
 }

File: broker/src/test/java/io/moquette/spi/impl/security/ACLFileParserTest.java
Patch:
@@ -23,9 +23,6 @@
 import java.text.ParseException;
 import static org.junit.Assert.*;
 
-/**
- * @author andrea
- */
 public class ACLFileParserTest {
 
     @Test

File: broker/src/test/java/io/moquette/spi/impl/security/AuthorizationsCollectorTest.java
Patch:
@@ -22,9 +22,6 @@
 import java.text.ParseException;
 import static org.junit.Assert.*;
 
-/**
- * @author andrea
- */
 public class AuthorizationsCollectorTest {
 
     private static final Authorization RW_ANEMOMETER = new Authorization(new Topic("/weather/italy/anemometer"));

File: broker/src/test/java/io/moquette/testclient/Client.java
Patch:
@@ -32,8 +32,6 @@
 /**
  * Class used just to send and receive MQTT messages without any protocol login in action, just use
  * the encoder/decoder part.
- *
- * @author andrea
  */
 public class Client {
 
@@ -46,7 +44,7 @@ public interface ICallback {
     final ClientNettyMQTTHandler handler = new ClientNettyMQTTHandler();
     EventLoopGroup workerGroup;
     Channel m_channel;
-    private boolean m_connectionLost = false;
+    private boolean m_connectionLost;
     private ICallback callback;
     private String clientId;
     private MqttMessage receivedMsg;

File: mapdb_storage/src/main/java/io/moquette/persistence/mapdb/MapDBMessagesStore.java
Patch:
@@ -28,8 +28,6 @@
 
 /**
  * IMessagesStore implementation backed by MapDB.
- *
- * @author andrea
  */
 class MapDBMessagesStore implements IMessagesStore {
 

File: mapdb_storage/src/main/java/io/moquette/persistence/mapdb/MapDBPersistentStore.java
Patch:
@@ -27,7 +27,6 @@
 import org.slf4j.LoggerFactory;
 import java.io.File;
 import java.io.IOException;
-import java.io.Serializable;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
@@ -48,7 +47,8 @@ public class MapDBPersistentStore implements IStore {
 
     public MapDBPersistentStore(IConfig props, ScheduledExecutorService scheduler) {
         this.m_storePath = props.getProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME, "");
-        this.m_autosaveInterval = Integer.parseInt(props.getProperty(BrokerConstants.AUTOSAVE_INTERVAL_PROPERTY_NAME, "30"));
+        this.m_autosaveInterval = Integer
+                .parseInt(props.getProperty(BrokerConstants.AUTOSAVE_INTERVAL_PROPERTY_NAME, "30"));
         this.m_scheduler = scheduler;
     }
 

File: mapdb_storage/src/main/java/io/moquette/persistence/mapdb/MapDBSessionsStore.java
Patch:
@@ -36,8 +36,6 @@
 
 /**
  * ISessionsStore implementation backed by MapDB.
- *
- * @author andrea
  */
 class MapDBSessionsStore implements ISessionsStore {
 

File: osgi_test/src/test/java/io/moquette/test/osgi/MoquetteOsgiTest.java
Patch:
@@ -26,7 +26,6 @@
 import org.ops4j.pax.exam.junit.PaxExam;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
-import org.osgi.framework.ServiceReference;
 
 import javax.inject.Inject;
 
@@ -38,7 +37,7 @@
 public class MoquetteOsgiTest {
     @Inject
     private BundleContext bundleContext;
- 
+
     @Configuration
     public Option[] config() {
 

File: broker/src/test/java/io/moquette/server/IntegrationUtils.java
Patch:
@@ -33,12 +33,12 @@ public class IntegrationUtils {
 
     static String localMapDBPath() {
         String currentDir = System.getProperty("user.dir");
-        return currentDir + File.separator + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
+        return currentDir + File.separator + "target" + File.separator + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
     }
 
     static String localClusterMapDBPath(int port) {
         String currentDir = System.getProperty("user.dir");
-        return currentDir + File.separator + port + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
+        return currentDir + File.separator + "target" + File.separator + port + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
     }
 
     public static Properties prepareTestProperties() {

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/interception/messages/InterceptAbstractMessage.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/ConnectionDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/Constants.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/DefaultMoquetteSslContextCreator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/Server.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/ServerAcceptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/config/ConfigurationParser.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/config/IConfig.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/config/MemoryConfig.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/config/ResourceLoaderConfig.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/MessageBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/MoquetteIdleTimeoutHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/NettyMQTTHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/NettyUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/BytesMetrics.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/BytesMetricsCollector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/BytesMetricsHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/MQTTMessageLogger.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/MessageMetrics.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/MessageMetricsCollector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/server/netty/metrics/MessageMetricsHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/IMatchingCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/IMessagesStore.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/IMessaging.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/MessageGUID.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/DebugUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessorBootstrapper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/ACLFileParser.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/Authorization.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/AuthorizationsCollector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/DenyAllAuthorizator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/FileAuthenticator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/PermitAllAuthorizator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/security/ResourceAuthenticator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Subscription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Token.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Topic.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/TreeNode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/persistence/MapDBMessagesStore.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/security/IAuthenticator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/security/IAuthorizator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/main/java/io/moquette/spi/security/ISslContextCreator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/Utils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ConfigurationClassLoaderTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/IntegrationUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/MQTTWebSocket.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationEmbeddedPublishTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationFuseTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationPahoTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationQoSValidationTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationSSLClientAuthTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationSSLTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerIntegrationWebSocketTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/ServerRestartIntegrationTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/server/config/ConfigurationParserTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spec/v3_1_1/connection/ConnectionIT.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/MemoryMessagesStore.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/MemoryStorageService.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/MockAuthenticator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/MockReceiverChannel.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/NettyChannelAssertions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessorTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/ProtocolProcessor_CONNECT_Test.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/security/ACLFileParserTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/security/AuthorizationsCollectorTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/security/FileAuthenticatorTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/subscriptions/SubscriptionsStoreTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/impl/subscriptions/TopicTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/spi/persistence/MapDBPersistentStoreTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/testclient/Client.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: broker/src/test/java/io/moquette/testclient/ClientNettyMQTTHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0

File: embedding_moquette/src/main/java/io/moquette/testembedded/EmbeddedLauncher.java
Patch:
@@ -1,5 +1,5 @@
     /*
- * Copyright (c) 2012-2017 The original author or authorsgetRockQuestions()
+ * Copyright (c) 2012-2017 The original author or authors
  * ------------------------------------------------------
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -78,4 +78,4 @@ public void run() {
         mqttBroker.internalPublish(message, "INTRLPUB");
         System.out.println("After self publish");
     }
-}
\ No newline at end of file
+}

File: broker/src/main/java/io/moquette/server/netty/MoquetteIdleTimeoutHandler.java
Patch:
@@ -33,7 +33,7 @@ class MoquetteIdleTimeoutHandler extends ChannelDuplexHandler {
     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
         if (evt instanceof IdleStateEvent) {
             IdleState e = ((IdleStateEvent) evt).state();
-            if (e == IdleState.ALL_IDLE) {
+            if (e == IdleState.READER_IDLE) {
                 LOG.info("Firing channel inactive event. MqttClientId = {}.", NettyUtils.clientID(ctx.channel()));
                 // fire a channelInactive to trigger publish of Will
                 ctx.fireChannelInactive();

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -519,7 +519,7 @@ private void setIdleTime(ChannelPipeline pipeline, int idleTime) {
         if (pipeline.names().contains("idleStateHandler")) {
             pipeline.remove("idleStateHandler");
         }
-        pipeline.addFirst("idleStateHandler", new IdleStateHandler(0, 0, idleTime));
+        pipeline.addFirst("idleStateHandler", new IdleStateHandler(idleTime, 0, 0));
     }
 
     /**

File: perf/src/main/java/io/moquette/parser/netty/performance/ProtocolDecodingServer.java
Patch:
@@ -28,7 +28,7 @@ class MoquetteIdleTimeoutHandler extends ChannelDuplexHandler {
         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
             if (evt instanceof IdleStateEvent) {
                 IdleState e = ((IdleStateEvent) evt).state();
-                if (e == IdleState.ALL_IDLE) {
+                if (e == IdleState.READER_IDLE) {
                     //fire a channelInactive to trigger publish of Will
                     ctx.fireChannelInactive();
                     ctx.close();
@@ -86,7 +86,7 @@ void init() {
                     public void initChannel(SocketChannel ch) throws Exception {
                         ChannelPipeline pipeline = ch.pipeline();
                         try {
-                            pipeline.addFirst("idleStateHandler", new IdleStateHandler(0, 0, 2));
+                            pipeline.addFirst("idleStateHandler", new IdleStateHandler(2, 0, 0));
                             pipeline.addAfter("idleStateHandler", "idleEventHandler", new MoquetteIdleTimeoutHandler());
                             pipeline.addLast("decoder", new MqttDecoder());
                             pipeline.addLast("encoder", MqttEncoder.INSTANCE);

File: broker/src/main/java/io/moquette/spi/impl/DebugUtils.java
Patch:
@@ -13,17 +13,18 @@
  *
  * You may elect to redistribute this code under either of these licenses.
  */
+
 package io.moquette.spi.impl;
 
 import io.netty.buffer.ByteBuf;
-
 import java.nio.ByteBuffer;
 
 /**
  *
  * @author andrea
  */
 class DebugUtils {
+
     static String payload2Str(ByteBuffer content) {
         byte[] b = new byte[content.remaining()];
         content.mark();
@@ -33,7 +34,7 @@ static String payload2Str(ByteBuffer content) {
     }
 
     static String payload2Str(ByteBuf content) {
-        //byte[] b = new byte[content.readableBytes()];
+        // byte[] b = new byte[content.readableBytes()];
         return new String(content.copy().array());
     }
 }

File: perf/src/main/java/io/moquette/spi/impl/subscriptions/PerformanceTest.java
Patch:
@@ -4,9 +4,9 @@
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadMXBean;
-import io.moquette.parser.proto.messages.AbstractMessage;
 import io.moquette.spi.ISessionsStore;
 import io.moquette.spi.impl.MemoryStorageService;
+import io.netty.handler.codec.mqtt.MqttQoS;
 
 public class PerformanceTest {
 
@@ -39,7 +39,7 @@ public static void main(String[] args) throws IOException, InterruptedException
             topics[i] = (i % users) + "/" + ((i / users) % devices) + "/" + ((i / (users * devices)) % values) + "/"
                     + ((i / (users * devices * values)) % subs);
 
-            Subscription sub = new Subscription("CLI_ID_" + (i % users), topics[i], AbstractMessage.QOSType.MOST_ONE);
+            Subscription sub = new Subscription("CLI_ID_" + (i % users), topics[i], MqttQoS.AT_MOST_ONCE);
             aSessionsStore.addNewSubscription(sub);
             store.add(sub.asClientTopicCouple());
         }

File: netty_parser/src/main/java/io/moquette/parser/proto/messages/PublishMessage.java
Patch:
@@ -42,7 +42,7 @@ public void setTopicName(String topicName) {
     }
 
     public ByteBuffer getPayload() {
-        return m_payload;
+        return m_payload.duplicate();
     }
 
     public void setPayload(ByteBuffer payload) {

File: perf/src/main/java/io/moquette/spi/impl/subscriptions/PerformanceTest.java
Patch:
@@ -4,9 +4,9 @@
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadMXBean;
-import io.moquette.parser.proto.messages.AbstractMessage;
 import io.moquette.spi.ISessionsStore;
 import io.moquette.spi.impl.MemoryStorageService;
+import io.netty.handler.codec.mqtt.MqttQoS;
 
 public class PerformanceTest {
 
@@ -39,7 +39,7 @@ public static void main(String[] args) throws IOException, InterruptedException
             topics[i] = (i % users) + "/" + ((i / users) % devices) + "/" + ((i / (users * devices)) % values) + "/"
                     + ((i / (users * devices * values)) % subs);
 
-            Subscription sub = new Subscription("CLI_ID_" + (i % users), topics[i], AbstractMessage.QOSType.MOST_ONE);
+            Subscription sub = new Subscription("CLI_ID_" + (i % users), topics[i], MqttQoS.AT_MOST_ONCE);
             aSessionsStore.addNewSubscription(sub);
             store.add(sub.asClientTopicCouple());
         }

File: broker/src/main/java/io/moquette/server/netty/NettyMQTTHandler.java
Patch:
@@ -46,9 +46,7 @@ public NettyMQTTHandler(ProtocolProcessor processor) {
     public void channelRead(ChannelHandlerContext ctx, Object message) {
         AbstractMessage msg = (AbstractMessage) message;
         String messageType = Utils.msgType2String(msg.getMessageType());
-        if (LOG.isDebugEnabled()) {
-        	LOG.debug("Processing MQTT message. MessageType = {}.", messageType);
-        }
+        LOG.debug("Processing MQTT message. MessageType = {}.", messageType);
         try {
             switch (msg.getMessageType()) {
                 case CONNECT:

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -88,7 +88,7 @@ public boolean subscribe(Subscription newSubscription) {
 				newSubscription.getTopicFilter(), AbstractMessage.QOSType.formatQoS(newSubscription.getRequestedQos()));
         boolean validTopic = SubscriptionsStore.validate(newSubscription.getTopicFilter());
         if (!validTopic) {
-            LOG.error("The topic filter is not valid. MqttClientId = {}, topics = {}.", newSubscription.getClientId(),
+            LOG.warn("The topic filter is not valid. MqttClientId = {}, topics = {}.", newSubscription.getClientId(),
 					newSubscription.getTopicFilter());
             //send SUBACK with 0x80 for this topic filter
             return false;

File: broker/src/main/java/io/moquette/spi/impl/Qos0PublishHandler.java
Patch:
@@ -45,8 +45,8 @@ void receivedPublishQos0(Channel channel, PublishMessage msg) {
         String clientID = NettyUtils.clientID(channel);
         toStoreMsg.setClientID(clientID);
 
-		if (LOG.isDebugEnabled()) {
-			LOG.debug("Sending publish message to subscribers. MqttClientId = {}, topic = {}, messageId = {}, payload = {}, subscriptionTree = {}.",
+		if (LOG.isTraceEnabled()) {
+			LOG.trace("Sending publish message to subscribers. MqttClientId = {}, topic = {}, messageId = {}, payload = {}, subscriptionTree = {}.",
 					clientID, topic, msg.getMessageID(), DebugUtils.payload2Str(toStoreMsg.getMessage()),
 					subscriptions.dumpTree());
 		} else {

File: broker/src/main/java/io/moquette/spi/impl/Qos1PublishHandler.java
Patch:
@@ -50,8 +50,8 @@ void receivedPublishQos1(Channel channel, PublishMessage msg) {
         String clientID = NettyUtils.clientID(channel);
         toStoreMsg.setClientID(clientID);
 
-		if (LOG.isDebugEnabled()) {
-			LOG.debug("Sending publish message to subscribers. MqttClientId = {}, topic = {}, messageId = {}, payload = {}, subscriptionTree = {}.",
+		if (LOG.isTraceEnabled()) {
+			LOG.trace("Sending publish message to subscribers. MqttClientId = {}, topic = {}, messageId = {}, payload = {}, subscriptionTree = {}.",
 					clientID, topic, msg.getMessageID(), DebugUtils.payload2Str(toStoreMsg.getMessage()),
 					subscriptions.dumpTree());
 		} else {

File: broker/src/main/java/io/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -102,9 +102,7 @@ public void initStore() {
         m_scheduler.scheduleWithFixedDelay(new Runnable() {
             @Override
             public void run() {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Committing to MapDB...");
-                }
+                LOG.debug("Committing to MapDB...");
                 m_db.commit();
             }
         }, this.m_autosaveInterval, this.m_autosaveInterval, TimeUnit.SECONDS);

File: perf/src/main/java/io/moquette/parser/netty/performance/LoopMQTTHandler.java
Patch:
@@ -85,9 +85,7 @@ private void handlePublish(ChannelHandlerContext ctx, PublishMessage msg) {
 
         long start = System.nanoTime();
         LOG.debug("push forward message the topic {}", msg.getTopicName());
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("content <{}>", payload2Str(msg.getPayload()));
-        }
+        LOG.debug("content <{}>", payload2Str(msg.getPayload()));
         String decodedPayload = payload2Str(msg.getPayload());
         long sentTime = Long.parseLong(decodedPayload.split("-")[1]);
         forthNetworkTime.recordValue(start - sentTime);

File: perf/src/main/java/io/moquette/parser/netty/performance/NettyPublishReceiverHandler.java
Patch:
@@ -44,9 +44,7 @@ public void channelRead(ChannelHandlerContext ctx, Object message) {
     private void handlePublish(MqttPublishMessage msg) {
         long start = System.nanoTime();
         LOG.debug("push forward message the topic {}", msg.variableHeader().topicName());
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("content <{}>", payload2Str(msg.content()));
-        }
+        LOG.debug("content <{}>", payload2Str(msg.content()));
         String decodedPayload = payload2Str(msg.content());
         long sentTime = Long.parseLong(decodedPayload.split("-")[1]);
         forthNetworkTime.recordValue(start - sentTime);

File: perf/src/main/java/io/moquette/parser/netty/performance/PublishReceiverHandler.java
Patch:
@@ -45,9 +45,7 @@ public void channelRead(ChannelHandlerContext ctx, Object message) {
     private void handlePublish(PublishMessage msg) {
         long start = System.nanoTime();
         LOG.debug("push forward message the topic {}", msg.getTopicName());
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("content <{}>", payload2Str(msg.getPayload()));
-        }
+        LOG.debug("content <{}>", payload2Str(msg.getPayload()));
         String decodedPayload = payload2Str(msg.getPayload());
         long sentTime = Long.parseLong(decodedPayload.split("-")[1]);
         forthNetworkTime.recordValue(start - sentTime);

File: broker/src/main/java/io/moquette/interception/HazelcastMsg.java
Patch:
@@ -9,7 +9,8 @@
  */
 public class HazelcastMsg implements Serializable {
 
-    private final String clientId;
+	private static final long serialVersionUID = 1L;
+	private final String clientId;
     private final byte qos;
     private final byte[] payload;
     private final String topic;

File: broker/src/main/java/io/moquette/server/config/IResourceLoader.java
Patch:
@@ -11,7 +11,9 @@ public interface IResourceLoader {
     String getName();
 
     class ResourceIsDirectoryException extends RuntimeException {
-        public ResourceIsDirectoryException(String message) {
+		private static final long serialVersionUID = 1L;
+
+		public ResourceIsDirectoryException(String message) {
             super(message);
         }
     }

File: broker/src/main/java/io/moquette/server/netty/AutoFlushHandler.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.timeout.IdleStateEvent;
 import io.netty.util.concurrent.EventExecutor;
 
 import java.util.concurrent.ScheduledFuture;

File: broker/src/main/java/io/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -38,7 +38,6 @@
 import io.netty.handler.codec.http.HttpResponseEncoder;
 import io.netty.handler.codec.http.HttpServerCodec;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.Utf8FrameValidator;
 import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.timeout.IdleStateHandler;

File: broker/src/main/java/io/moquette/server/netty/NettyUtils.java
Patch:
@@ -16,7 +16,6 @@
 package io.moquette.server.netty;
 
 import io.moquette.server.Constants;
-import io.moquette.spi.impl.ProtocolProcessor;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.util.Attribute;

File: broker/src/main/java/io/moquette/spi/IMessagesStore.java
Patch:
@@ -20,16 +20,15 @@
 import io.moquette.parser.proto.messages.AbstractMessage;
 
 import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Defines the SPI to be implemented by a StorageService that handle persistence of messages
  */
 public interface IMessagesStore {
 
     class StoredMessage implements Serializable {
-        final AbstractMessage.QOSType m_qos;
+		private static final long serialVersionUID = 1L;
+		final AbstractMessage.QOSType m_qos;
         final byte[] m_payload;
         final String m_topic;
         private boolean m_retained;

File: broker/src/main/java/io/moquette/spi/MessageGUID.java
Patch:
@@ -21,7 +21,8 @@
  * Value object for GUIDs of messages.
  * */
 public class MessageGUID implements Serializable {
-    private final String guid;
+	private static final long serialVersionUID = 1L;
+	private final String guid;
 
     public MessageGUID(String guid) {
         this.guid = guid;

File: broker/src/main/java/io/moquette/spi/impl/InternalRepublisher.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Queue;
 import java.util.concurrent.BlockingQueue;
 
 class InternalRepublisher {

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessorBootstrapper.java
Patch:
@@ -106,7 +106,6 @@ public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> em
 
         subscriptions.init(m_sessionsStore);
 
-        String configPath = System.getProperty("moquette.path", null);
         String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, "");
 
         if (!authenticatorClassName.isEmpty()) {

File: broker/src/main/java/io/moquette/spi/impl/security/DBAuthenticator.java
Patch:
@@ -22,7 +22,6 @@ public class DBAuthenticator implements IAuthenticator {
 
     private static final Logger LOG = LoggerFactory.getLogger(DBAuthenticator.class);
 
-    private final String sqlQuery;
     private final MessageDigest messageDigest;
     private final PreparedStatement preparedStatement;
 
@@ -44,7 +43,6 @@ public DBAuthenticator(IConfig conf){
      */
     public DBAuthenticator(String driver, String jdbcUrl, String sqlQuery, String digestMethod){
 
-        this.sqlQuery = sqlQuery;
         try {
             Class.forName(driver);
             final Connection connection = DriverManager.getConnection(jdbcUrl);

File: broker/src/main/java/io/moquette/spi/impl/security/ResourceAuthenticator.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.moquette.server.config.IResourceLoader;
 import io.moquette.spi.security.IAuthenticator;
-import org.apache.commons.codec.binary.Hex;
 import org.apache.commons.codec.digest.DigestUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/Subscription.java
Patch:
@@ -28,7 +28,8 @@
  */
 public final class Subscription implements Serializable {
     
-    final QOSType requestedQos; //max QoS acceptable
+	private static final long serialVersionUID = 1L;
+	final QOSType requestedQos; //max QoS acceptable
     final String clientId;
     final String topicFilter;
     final boolean active;

File: broker/src/main/java/io/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -45,7 +45,8 @@ public class MapDBPersistentStore {
      * a session.
      * */
     public static class PersistentSession implements Serializable {
-        public final boolean cleanSession;
+		private static final long serialVersionUID = 1L;
+		public final boolean cleanSession;
 
         public PersistentSession(boolean cleanSession) {
             this.cleanSession = cleanSession;

File: broker/src/main/java/io/moquette/spi/persistence/MapDBSessionsStore.java
Patch:
@@ -16,7 +16,6 @@
 package io.moquette.spi.persistence;
 
 import io.moquette.spi.ClientSession;
-import io.moquette.spi.IMessagesStore;
 import io.moquette.spi.IMessagesStore.StoredMessage;
 import io.moquette.spi.ISessionsStore;
 import io.moquette.spi.MessageGUID;

File: broker/src/main/java/io/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -276,8 +276,8 @@ public void close() {
         if (m_bossGroup == null) {
             throw new IllegalStateException("Invoked close on an Acceptor that wasn't initialized");
         }
-        Future workerWaiter = m_workerGroup.shutdownGracefully();
-        Future bossWaiter = m_bossGroup.shutdownGracefully();
+        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();
+        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();
 
         try {
             workerWaiter.await(100);

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -460,6 +460,8 @@ public void processPublish(Channel channel, PublishMessage msg) {
             case EXACTLY_ONCE:
                 this.qos2PublishHandler.receivedPublishQos2(channel, msg);
                 break;
+            default:
+            	break;
         }
     }
 

File: broker/src/main/java/io/moquette/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -247,7 +247,7 @@ public String dumpTree() {
         return visitor.getResult();
     }
     
-    private void bfsVisit(TreeNode node, IVisitor visitor, int deep) {
+    private void bfsVisit(TreeNode node, IVisitor<?> visitor, int deep) {
         if (node == null) {
             return;
         }

File: broker/src/main/java/io/moquette/interception/Interceptor.java
Patch:
@@ -49,7 +49,7 @@ public interface Interceptor {
 
     void notifyMessageAcknowledged(InterceptAcknowledgedMessage msg);
 
-    boolean addInterceptHandler(InterceptHandler interceptHandler);
+    void addInterceptHandler(InterceptHandler interceptHandler);
 
-    boolean removeInterceptHandler(InterceptHandler interceptHandler);
+    void removeInterceptHandler(InterceptHandler interceptHandler);
 }

File: broker/src/main/java/io/moquette/interception/messages/InterceptAbstractMessage.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * @author Wagner Macedo
  */
-public abstract class InterceptAbstractMessage {
+public abstract class InterceptAbstractMessage implements InterceptMessage {
     private final AbstractMessage msg;
 
     InterceptAbstractMessage(AbstractMessage msg) {

File: broker/src/main/java/io/moquette/interception/messages/InterceptAcknowledgedMessage.java
Patch:
@@ -2,7 +2,7 @@
 
 import static io.moquette.spi.IMessagesStore.StoredMessage;
 
-public class InterceptAcknowledgedMessage {
+public class InterceptAcknowledgedMessage implements InterceptMessage {
 	final private StoredMessage msg;
 	private final String username;
 	private final String topic;

File: broker/src/main/java/io/moquette/interception/messages/InterceptConnectionLostMessage.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * @author Wagner Macedo
  */
-public class InterceptConnectionLostMessage {
+public class InterceptConnectionLostMessage implements InterceptMessage {
     private final String clientID;
     private final String username;
 

File: broker/src/main/java/io/moquette/interception/messages/InterceptDisconnectMessage.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * @author Wagner Macedo
  */
-public class InterceptDisconnectMessage {
+public class InterceptDisconnectMessage implements InterceptMessage {
     private final String clientID;
     private final String username;
 

File: broker/src/main/java/io/moquette/interception/messages/InterceptSubscribeMessage.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * @author Wagner Macedo
  */
-public class InterceptSubscribeMessage {
+public class InterceptSubscribeMessage implements InterceptMessage {
     private final Subscription subscription;
     private final String username;
 

File: broker/src/main/java/io/moquette/interception/messages/InterceptUnsubscribeMessage.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * @author Wagner Macedo
  */
-public class InterceptUnsubscribeMessage {
+public class InterceptUnsubscribeMessage implements InterceptMessage {
     private final String topicFilter;
     private final String clientID;
     private final String username;

File: broker/src/main/java/io/moquette/server/netty/AutoFlushHandler.java
Patch:
@@ -136,6 +136,9 @@ private void destroy() {
 
     /**
      * Is called when the write timeout expire.
+     *
+     * @param ctx the channel context.
+     * @throws Exception in case of any IO error.
      */
     protected void channelIdle(ChannelHandlerContext ctx/*, IdleStateEvent evt*/) throws Exception {
 //        ctx.fireUserEventTriggered(evt);

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -82,6 +82,8 @@ public List<IMessagesStore.StoredMessage> storedMessages() {
 
     /**
      * Remove the messages stored in a cleanSession false.
+     *
+     * @param guid the guid of the message to remove from the queue.
      */
     public void removeEnqueued(MessageGUID guid) {
         this.m_sessionsStore.removeEnqueued(this.clientID, guid);
@@ -182,6 +184,7 @@ public IMessagesStore.StoredMessage storedMessage(int messageID) {
 
     /**
      * Enqueue a message to be sent to the client.
+     * @param pubMessage the message to enqueue.
      * @return false if the queue is full.
      * */
     public boolean enqueue(PublishMessage pubMessage) {

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessorBootstrapper.java
Patch:
@@ -74,6 +74,8 @@ public ProtocolProcessorBootstrapper() {
      *                      and fallback on the default one (permit all).
      * @param authorizator an implementation of the authorizator to be used, if null load that specified in config
      *                      and fallback on the default one (permit all).
+     * @param server the serber to init.
+     * @return the processor created for the broker.
      * */
     public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> embeddedObservers,
                                   IAuthenticator authenticator, IAuthorizator authorizator, Server server) {

File: broker/src/main/java/io/moquette/spi/impl/security/FileAuthenticator.java
Patch:
@@ -19,7 +19,7 @@
 
 /**
  * Load user credentials from a text file.
- * Each line of the file is formatted as "<username>:<sha256(password)>". The username mustn't contains : char.
+ * Each line of the file is formatted as "[username]:[sha256(password)]". The username mustn't contains : char.
  *
  * To encode your password from command line on Linux systems, you could use:
  * <pre>

File: broker/src/main/java/io/moquette/spi/impl/security/ResourceAuthenticator.java
Patch:
@@ -33,7 +33,7 @@
 
 /**
  * Load user credentials from a text resource.
- * Each line of the file is formatted as "<username>:<sha256(password)>". The username mustn't contains : char.
+ * Each line of the file is formatted as "[username]:[sha256(password)]". The username mustn't contains : char.
  *
  * To encode your password from command line on Linux systems, you could use:
  * <pre>

File: broker/src/main/java/io/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -69,6 +69,7 @@ public MapDBPersistentStore(IConfig props) {
 
     /**
      * Factory method to create message store backed by MapDB
+     * @return the message store instance.
      * */
     public IMessagesStore messagesStore() {
         return m_messageStore;

File: broker/src/main/java/io/moquette/spi/persistence/MapDBSessionsStore.java
Patch:
@@ -227,9 +227,6 @@ public void removeEnqueued(String clientID, MessageGUID guid) {
         List<MessageGUID> guids = Utils.defaultGet(m_enqueuedStore, clientID, new ArrayList<MessageGUID>());
         guids.remove(guid);
         m_enqueuedStore.put(clientID, guids);
-        m_messagesStore.decUsageCounter(guid);
-        //if counter gets to 0 then remove from storage
-        m_messagesStore.removeStoredMessage(guid);
     }
 
     @Override

File: broker/src/test/java/io/moquette/server/ServerIntegrationFuseTest.java
Patch:
@@ -74,7 +74,7 @@ public void tearDown() throws Exception {
 
     @Test
     public void checkWillTestamentIsPublishedOnConnectionKill_noRetain() throws Exception {
-        LOG.info("checkWillTestamentIsPublishedOnConnectionKill");
+        LOG.info("checkWillTestamentIsPublishedOnConnectionKill_noRetain");
         
         String willTestamentTopic = "/will/test";
         String willTestamentMsg = "Bye bye";
@@ -93,7 +93,6 @@ public void checkWillTestamentIsPublishedOnConnectionKill_noRetain() throws Exce
         m_mqtt.setClientId("Subscriber");
         m_subscriber = m_mqtt.blockingConnection();
         m_subscriber.connect();
-//        Topic[] topics = new Topic[]{new Topic(willTestamentTopic, QoS.AT_LEAST_ONCE)};
         Topic[] topics = new Topic[]{new Topic(willTestamentTopic, QoS.AT_MOST_ONCE)};
         m_subscriber.subscribe(topics);
         

File: broker/src/test/java/io/moquette/server/ServerIntegrationPahoTest.java
Patch:
@@ -286,6 +286,7 @@ public void testPublishWithQoS1_notCleanSession() throws Exception {
         assertEquals("Hello MQTT", m_messagesCollector.getMessage(true).toString());
     }
 
+
     @Test
     public void checkReceivePublishedMessage_after_a_reconnect_with_notCleanSession() throws Exception {
         LOG.info("*** checkReceivePublishedMessage_after_a_reconnect_with_notCleanSession ***");
@@ -461,10 +462,10 @@ public void testSubcriptionDoesntStayActiveAfterARestart() throws Exception {
         clientForPublish.publish("topic", "Hello".getBytes(), 2, true);
 
         //verify clientForSubscribe1 doesn't receive a notification but clientForSubscribe2 yes
-        System.out.println("Before waiting to receive 1 sec from " + clientForSubscribe1.getClientId());
+        LOG.info("Before waiting to receive 1 sec from " + clientForSubscribe1.getClientId());
         assertFalse(clientForSubscribe1.isConnected());
         assertTrue(clientForSubscribe2.isConnected());
-        System.out.println("Waiting to receive 1 sec from " + clientForSubscribe2.getClientId());
+        LOG.info("Waiting to receive 1 sec from " + clientForSubscribe2.getClientId());
         MqttMessage messageOnB = cbSubscriber2.getMessage(true);
         assertEquals("Hello", new String(messageOnB.getPayload()));
     }

File: broker/src/main/java/io/moquette/server/config/IConfig.java
Patch:
@@ -36,7 +36,7 @@ void assignDefaults() {
         setProperty(BrokerConstants.HOST_PROPERTY_NAME, BrokerConstants.HOST);
         //setProperty(BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME, Integer.toString(BrokerConstants.WEBSOCKET_PORT));
         setProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME, "");
-        setProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME, BrokerConstants.DEFAULT_PERSISTENT_PATH);
+        //setProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME, BrokerConstants.DEFAULT_PERSISTENT_PATH);
         setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, Boolean.TRUE.toString());
         setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, "");
         setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, "");

File: broker/src/main/java/io/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -36,7 +36,9 @@
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.codec.http.HttpServerCodec;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.Utf8FrameValidator;
 import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.timeout.IdleStateHandler;
@@ -184,8 +186,7 @@ private void initializeWebSocketTransport(final NettyMQTTHandler handler, IConfi
         initFactory(host, port, new PipelineInitializer() {
             @Override
             void init(ChannelPipeline pipeline) {
-                pipeline.addLast("httpEncoder", new HttpResponseEncoder());
-                pipeline.addLast("httpDecoder", new HttpRequestDecoder());
+                pipeline.addLast(new HttpServerCodec());
                 pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
                 pipeline.addLast("webSocketHandler", new WebSocketServerProtocolHandler("/mqtt", MQTT_SUBPROTOCOL_CSV_LIST));
                 pipeline.addLast("ws2bytebufDecoder", new WebSocketFrameToByteBufDecoder());

File: broker/src/main/java/io/moquette/server/netty/metrics/MQTTMessageLogger.java
Patch:
@@ -97,7 +97,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        logMQTTMessage(ctx, (AbstractMessage) msg, "C<-B");
+        logMQTTMessage(ctx, msg, "C<-B");
         ctx.write(msg, promise);
     }
 //

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -385,12 +385,11 @@ private void failedCredentials(Channel session) {
     }
 
     private void setupAutoFlusher(ChannelPipeline pipeline, int flushIntervalMs) {
-        AutoFlushHandler autoFlushHandler = new AutoFlushHandler(flushIntervalMs, TimeUnit.MILLISECONDS);
         try {
-            pipeline.addAfter("idleEventHandler", "autoFlusher", autoFlushHandler);
+            pipeline.addAfter("idleEventHandler", "autoFlusher", new AutoFlushHandler(flushIntervalMs, TimeUnit.MILLISECONDS));
         } catch (NoSuchElementException nseex) {
             //the idleEventHandler is not present on the pipeline
-            pipeline.addFirst("autoFlusher", autoFlushHandler);
+            pipeline.addFirst("autoFlusher", new AutoFlushHandler(flushIntervalMs, TimeUnit.MILLISECONDS));
         }
     }
 

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -571,10 +571,12 @@ protected void directSend(ClientSession clientsession, String topic, AbstractMes
         Channel channel = m_clientIDs.get(clientId).channel;
         LOG.trace("Session for clientId {}", clientId);
         if (channel.isWritable()) {
+            LOG.debug("channel is writable");
             //if channel is writable don't enqueue
-            channel.write(pubMessage);
+            channel.writeAndFlush(pubMessage);
         } else {
             //enqueue to the client session
+            LOG.debug("enqueue to client session");
             clientsession.enqueue(pubMessage);
         }
     }

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -400,7 +400,7 @@ public void processPublish(Channel channel, PublishMessage msg) {
             LOG.info("server {} replying with PubAck to MSG ID {}", m_server_port, messageID);
         } else if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) { //QoS2
             guid = m_messagesStore.storePublishForFuture(toStoreMsg);
-            if(msg.isLocal()) {
+            if (msg.isLocal()) {
                 sendPubRec(clientID, messageID);
             }
             //Next the client will send us a pub rel

File: broker/src/main/java/io/moquette/spi/persistence/MapDBSessionsStore.java
Patch:
@@ -203,6 +203,7 @@ public void bindToDeliver(String guid, String clientID) {
         List<String> guids = Utils.defaultGet(m_enqueuedStore, clientID, new ArrayList<String>());
         guids.add(guid);
         m_enqueuedStore.put(clientID, guids);
+        m_messagesStore.incUsageCounter(guid);
     }
 
     @Override
@@ -215,6 +216,8 @@ public void removeEnqueued(String clientID, String guid) {
         List<String> guids = Utils.defaultGet(m_enqueuedStore, clientID, new ArrayList<String>());
         guids.remove(guid);
         m_enqueuedStore.put(clientID, guids);
+        m_messagesStore.decUsageCounter(guid);
+        //TODO if counter gets to 0 then remove from storage
     }
 
     @Override

File: broker/src/main/java/io/moquette/interception/HazelcastInterceptHandler.java
Patch:
@@ -15,7 +15,7 @@ public class HazelcastInterceptHandler extends AbstractInterceptHandler {
     private static final Logger LOG = LoggerFactory.getLogger(HazelcastInterceptHandler.class);
     private final HazelcastInstance hz;
 
-    public HazelcastInterceptHandler (Server server){
+    public HazelcastInterceptHandler(Server server){
         this.hz = server.getHazelcastInstance();
     }
 

File: broker/src/test/java/io/moquette/server/ServerIntegrationHazelcastHandlerInterceptorTest.java
Patch:
@@ -21,9 +21,6 @@
 
 import static org.junit.Assert.assertEquals;
 
-/**
- * Created by mackristof on 13/05/2016.
- */
 public class ServerIntegrationHazelcastHandlerInterceptorTest{
     private static final Logger LOG = LoggerFactory.getLogger(ServerIntegrationHazelcastHandlerInterceptorTest.class);
 

File: broker/src/test/java/io/moquette/server/ServerRestartIntegrationTest.java
Patch:
@@ -63,9 +63,9 @@ public static void beforeTests() {
 
     @Before
     public void setUp() throws Exception {
-        startServer();
         String dbPath = IntegrationUtils.localMapDBPath();
         IntegrationUtils.cleanPersistenceFile(dbPath);
+        startServer();
 
         m_subscriber = new MqttClient("tcp://localhost:1883", "Subscriber", s_dataStore);
         m_messageCollector = new MessageCollector();

File: broker/src/test/java/io/moquette/server/ServerRestartIntegrationTest.java
Patch:
@@ -63,9 +63,9 @@ public static void beforeTests() {
 
     @Before
     public void setUp() throws Exception {
-        startServer();
         String dbPath = IntegrationUtils.localMapDBPath();
         IntegrationUtils.cleanPersistenceFile(dbPath);
+        startServer();
 
         m_subscriber = new MqttClient("tcp://localhost:1883", "Subscriber", s_dataStore);
         m_messageCollector = new MessageCollector();

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -36,6 +36,7 @@ public class BrokerConstants {
     public static final String KEY_STORE_PASSWORD_PROPERTY_NAME = "key_store_password";
     public static final String KEY_MANAGER_PASSWORD_PROPERTY_NAME = "key_manager_password";
     public static final String ALLOW_ANONYMOUS_PROPERTY_NAME = "allow_anonymous";
+    public static final String ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME = "allow_zero_byte_client_id";
     public static final String ACL_FILE_PROPERTY_NAME = "acl_file";
     public static final String AUTHORIZATOR_CLASS_NAME = "authorizator_class";
     public static final String AUTHENTICATOR_CLASS_NAME = "authenticator_class";

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessorBootstrapper.java
Patch:
@@ -139,7 +139,8 @@ public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> em
         }
 
         boolean allowAnonymous = Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, "true"));
-        m_processor.init(subscriptions, messagesStore, sessionsStore, authenticator, allowAnonymous, authorizator, m_interceptor, props.getProperty(BrokerConstants.PORT_PROPERTY_NAME));
+        boolean allowZeroByteClientId = Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, "false"));
+        m_processor.init(subscriptions, messagesStore, sessionsStore, authenticator, allowAnonymous, allowZeroByteClientId, authorizator, m_interceptor, props.getProperty(BrokerConstants.PORT_PROPERTY_NAME));
         return m_processor;
     }
     

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -280,6 +280,8 @@ private void failedCredentials(Channel session) {
         ConnAckMessage okResp = new ConnAckMessage();
         okResp.setReturnCode(ConnAckMessage.BAD_USERNAME_OR_PASSWORD);
         session.writeAndFlush(okResp);
+        session.close();
+        LOG.info("Client {} failed to connect with bad username or password.", session);
     }
 
     /**

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -36,6 +36,7 @@ public class BrokerConstants {
     public static final String KEY_STORE_PASSWORD_PROPERTY_NAME = "key_store_password";
     public static final String KEY_MANAGER_PASSWORD_PROPERTY_NAME = "key_manager_password";
     public static final String ALLOW_ANONYMOUS_PROPERTY_NAME = "allow_anonymous";
+    public static final String ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME = "allow_zero_byte_client_id";
     public static final String ACL_FILE_PROPERTY_NAME = "acl_file";
     public static final String AUTHORIZATOR_CLASS_NAME = "authorizator_class";
     public static final String AUTHENTICATOR_CLASS_NAME = "authenticator_class";

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessorBootstrapper.java
Patch:
@@ -139,7 +139,8 @@ public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> em
         }
 
         boolean allowAnonymous = Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, "true"));
-        m_processor.init(subscriptions, messagesStore, sessionsStore, authenticator, allowAnonymous, authorizator, m_interceptor, props.getProperty(BrokerConstants.PORT_PROPERTY_NAME));
+        boolean allowZeroByteClientId = Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, "false"));
+        m_processor.init(subscriptions, messagesStore, sessionsStore, authenticator, allowAnonymous, allowZeroByteClientId, authorizator, m_interceptor, props.getProperty(BrokerConstants.PORT_PROPERTY_NAME));
         return m_processor;
     }
     

File: broker/src/main/java/io/moquette/interception/HazelcastMsg.java
Patch:
@@ -5,23 +5,22 @@
 /**
  * Created by mackristof on 28/05/2016.
  */
-public class HazelcastMsg implements Serializable{
+public class HazelcastMsg implements Serializable {
 
     private final String clientId;
     private final String userName;
     private final byte qos;
     private final byte[] payload;
     private final String topic;
 
-    public HazelcastMsg(String clientId, String topic , byte qos, byte[] payload, String userName) {
+    public HazelcastMsg(String clientId, String topic, byte qos, byte[] payload, String userName) {
         this.clientId = clientId;
         this.qos = qos;
         this.payload = payload;
         this.userName = userName;
         this.topic = topic;
     }
 
-
     public String getClientId() {
         return clientId;
     }

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -364,11 +364,10 @@ public void processPublish(Channel channel, PublishMessage msg) {
             route2Subscribers(toStoreMsg);
         } else if (qos == AbstractMessage.QOSType.LEAST_ONE) { //QoS1
             route2Subscribers(toStoreMsg);
-            LOG.info("##### server {} trying to reply with PubAck to MSG ID {}", m_server_port, messageID);
             if (msg.isLocal()) {
                 sendPubAck(clientID, messageID);
             }
-            LOG.info("### server {} replying with PubAck to MSG ID {}", m_server_port, messageID);
+            LOG.info("server {} replying with PubAck to MSG ID {}", m_server_port, messageID);
         } else if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) { //QoS2
             guid = m_messagesStore.storePublishForFuture(toStoreMsg);
             if(msg.isLocal()) {
@@ -717,7 +716,7 @@ public void processUnsubscribe(Channel channel, UnsubscribeMessage msg) {
 
     public void processSubscribe(Channel channel, SubscribeMessage msg) {
         String clientID = NettyUtils.clientID(channel);
-        LOG.debug("SUBSCRIBE client <{}> packetID {}", clientID, msg.getMessageID());
+        LOG.debug("SUBSCRIBE client <{}> on server {} packetID {}", clientID, m_server_port, msg.getMessageID());
 
         ClientSession clientSession = m_sessionsStore.sessionForClient(clientID);
         verifyToActivate(clientSession);
@@ -778,6 +777,7 @@ public boolean match(String key) {
             }
         });
 
+        LOG.debug("Found {} messages to republish", messages.size());
         ClientSession targetSession = m_sessionsStore.sessionForClient(newSubscription.getClientId());
         verifyToActivate(targetSession);
         for (IMessagesStore.StoredMessage storedMsg : messages) {

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -94,9 +94,9 @@ public String toString() {
         return "ClientSession{clientID='" + clientID + '\'' +"}";
     }
 
-    public boolean subscribe(String topicFilter, Subscription newSubscription) {
-        LOG.info("<{}> subscribed to topicFilter <{}> with QoS {}",
-                newSubscription.getClientId(), topicFilter,
+    public boolean subscribe(Subscription newSubscription) {
+        LOG.info("<{}> subscribed to the topic filter <{}> with QoS {}",
+                newSubscription.getClientId(), newSubscription.getTopicFilter(),
                 AbstractMessage.QOSType.formatQoS(newSubscription.getRequestedQos()));
         boolean validTopic = SubscriptionsStore.validate(newSubscription.getTopicFilter());
         if (!validTopic) {

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -715,7 +715,7 @@ public void processSubscribe(Channel channel, SubscribeMessage msg) {
 
             AbstractMessage.QOSType qos = AbstractMessage.QOSType.valueOf(req.qos);
             Subscription newSubscription = new Subscription(clientID, req.topicFilter, qos);
-            boolean valid = clientSession.subscribe(req.topicFilter, newSubscription);
+            boolean valid = clientSession.subscribe(newSubscription);
             ackMessage.addType(valid ? qos : AbstractMessage.QOSType.FAILURE);
             if (valid) {
                 newSubscriptions.add(newSubscription);

File: broker/src/main/java/io/moquette/interception/HazelcastMsg.java
Patch:
@@ -10,13 +10,13 @@ public class HazelcastMsg implements Serializable{
     private final String clientId;
     private final String userName;
     private final byte qos;
-    private final String payload;
+    private final byte[] payload;
     private final String topic;
 
     public HazelcastMsg(String clientId, String topic , byte qos, byte[] payload, String userName) {
         this.clientId = clientId;
         this.qos = qos;
-        this.payload = new String(payload);
+        this.payload = payload;
         this.userName = userName;
         this.topic = topic;
     }
@@ -30,7 +30,7 @@ public byte getQos() {
         return qos;
     }
 
-    public String getPayload() {
+    public byte[] getPayload() {
         return payload;
     }
 

File: broker/src/main/java/io/moquette/server/HazelcastListener.java
Patch:
@@ -32,7 +32,7 @@ public void onMessage(Message<HazelcastMsg> msg) {
                 PublishMessage publishMessage = new PublishMessage();
                 publishMessage.setTopicName(msg.getMessageObject().getTopic());
                 publishMessage.setQos(AbstractMessage.QOSType.valueOf(msg.getMessageObject().getQos()));
-                publishMessage.setPayload(ByteBuffer.wrap(msg.getMessageObject().getPayload().getBytes("UTF-8")));
+                publishMessage.setPayload(ByteBuffer.wrap(msg.getMessageObject().getPayload()));
                 publishMessage.setLocal(false);
                 publishMessage.setClientId(msg.getMessageObject().getClientId());
                 server.internalPublish(publishMessage);

File: broker/src/main/java/io/moquette/BrokerConstants.java
Patch:
@@ -21,6 +21,7 @@
  * Created by andrea on 08/12/15.
  */
 public class BrokerConstants {
+    public static final String INTERCEPT_HANDLER_PROPERTY_NAME ="intercept.handler";
     public static final String PERSISTENT_STORE_PROPERTY_NAME = "persistent_store";
     public static final String AUTOSAVE_INTERVAL_PROPERTY_NAME = "autosave_interval";
     public static final String PASSWORD_FILE_PROPERTY_NAME = "password_file";
@@ -47,4 +48,5 @@ public class BrokerConstants {
     public static final String DISABLED_PORT_BIND = "disabled";
     public static final String HOST = "0.0.0.0";
     public static final String NEED_CLIENT_AUTH = "need_client_auth";
+    public static final String HAZELCAST_CONFIGURATION = "hazelcast.configuration";
 }

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -284,7 +284,9 @@ private void republishStoredInSession(ClientSession clientSession) {
 
         LOG.info("republishing stored messages to client <{}>", clientSession.clientID);
         for (IMessagesStore.StoredMessage pubEvt : publishedEvents) {
-            //TODO put in flight zone
+            //put in flight zone
+            LOG.trace("Adding to inflight <{}>", pubEvt.getMessageID());
+            clientSession.inFlightAckWaiting(pubEvt.getGuid(), pubEvt.getMessageID());
             directSend(clientSession, pubEvt.getTopic(), pubEvt.getQos(),
                     pubEvt.getMessage(), false, pubEvt.getMessageID());
             clientSession.removeEnqueued(pubEvt.getGuid());

File: broker/src/main/java/io/moquette/server/config/ClasspathConfig.java
Patch:
@@ -43,13 +43,13 @@ public ClasspathConfig() {
         }
         Reader configReader = new InputStreamReader(is);
         ConfigurationParser confParser = new ConfigurationParser();
+        m_properties = confParser.getProperties();
         assignDefaults();
         try {
             confParser.parse(configReader);
         } catch (ParseException pex) {
             LOG.warn("An error occurred in parsing configuration, fallback on default configuration", pex);
         }
-        m_properties = confParser.getProperties();
     }
 
     @Override

File: broker/src/main/java/io/moquette/server/config/FilesystemConfig.java
Patch:
@@ -34,13 +34,13 @@ public class FilesystemConfig extends IConfig {
 
     public FilesystemConfig(File file) {
         ConfigurationParser confParser = new ConfigurationParser();
+        m_properties = confParser.getProperties();
         assignDefaults();
         try {
             confParser.parse(file);
         } catch (ParseException pex) {
             LOG.warn("An error occurred in parsing configuration, fallback on default configuration", pex);
         }
-        m_properties = confParser.getProperties();
     }
 
     public FilesystemConfig() {

File: broker/src/main/java/io/moquette/server/config/ClasspathConfig.java
Patch:
@@ -29,7 +29,7 @@
  *
  * @author andrea
  */
-public class ClasspathConfig implements IConfig {
+public class ClasspathConfig extends IConfig {
 
     private static final Logger LOG = LoggerFactory.getLogger(ClasspathConfig.class);
 
@@ -43,6 +43,7 @@ public ClasspathConfig() {
         }
         Reader configReader = new InputStreamReader(is);
         ConfigurationParser confParser = new ConfigurationParser();
+        assignDefaults();
         try {
             confParser.parse(configReader);
         } catch (ParseException pex) {

File: broker/src/main/java/io/moquette/server/config/FilesystemConfig.java
Patch:
@@ -27,13 +27,14 @@
  *
  * @author andrea
  */
-public class FilesystemConfig implements IConfig {
+public class FilesystemConfig extends IConfig {
     private static final Logger LOG = LoggerFactory.getLogger(FilesystemConfig.class);
 
-    private final Properties m_properties;
+    private Properties m_properties = new Properties();
 
     public FilesystemConfig(File file) {
         ConfigurationParser confParser = new ConfigurationParser();
+        assignDefaults();
         try {
             confParser.parse(file);
         } catch (ParseException pex) {

File: broker/src/test/java/io/moquette/server/ServerIntegrationWebSocketTest.java
Patch:
@@ -49,6 +49,7 @@ public class ServerIntegrationWebSocketTest {
     protected void startServer() throws IOException {
         m_server = new Server();
         final Properties configProps = IntegrationUtils.prepareTestPropeties();
+        configProps.put(BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME, Integer.toString(BrokerConstants.WEBSOCKET_PORT));
         m_config = new MemoryConfig(configProps);
         m_server.startServer(m_config);
     }

File: broker/src/test/java/io/moquette/server/ServerIntegrationSSLClientAuthTest.java
Patch:
@@ -96,7 +96,7 @@ public class ServerIntegrationSSLClientAuthTest {
     static MqttClientPersistence s_dataStore;
 
     IMqttClient m_client;
-    TestCallback m_callback;
+    MessageCollector m_callback;
 
     @BeforeClass
     public static void beforeTests() {
@@ -130,7 +130,7 @@ public void setUp() throws Exception {
         m_client = new MqttClient("ssl://localhost:8883", "TestClient", s_dataStore);
 //        m_client = new MqttClient("ssl://test.mosquitto.org:8883", "TestClient", s_dataStore);
         
-        m_callback = new TestCallback();
+        m_callback = new MessageCollector();
         m_client.setCallback(m_callback);
     }
 

File: broker/src/main/java/io/moquette/spi/ISessionsStore.java
Patch:
@@ -27,6 +27,8 @@
  */
 public interface ISessionsStore {
 
+    void updateCleanStatus(String clientID, boolean cleanSession);
+
     class ClientTopicCouple {
         public final String topicFilter;
         public final String clientID;
@@ -99,6 +101,7 @@ public String toString() {
     ClientSession createNewSession(String clientID, boolean cleanSession);
 
     /**
+     * @param clientID the client owning the session.
      * @return the session for the given clientID, null if not found.
      * */
     ClientSession sessionForClient(String clientID);

File: broker/src/main/java/io/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -219,6 +219,9 @@ public void processConnect(Channel channel, ConnectMessage msg) {
         if (!msg.isCleanSession() && isSessionAlreadyStored) {
             okResp.setSessionPresent(true);
         }
+        if (isSessionAlreadyStored) {
+            clientSession.cleanSession(msg.isCleanSession());
+        }
         channel.writeAndFlush(okResp);
         m_interceptor.notifyClientConnected(msg);
 

File: broker/src/main/java/io/moquette/spi/IMessagesStore.java
Patch:
@@ -141,7 +141,5 @@ public String toString() {
      * */
     int nextPacketID(String clientID);
 
-//    void close();
-
     void cleanRetained(String topic);
 }

File: broker/src/main/java/io/moquette/server/netty/NettyMQTTHandler.java
Patch:
@@ -96,7 +96,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             if (stolenAttr != null && stolenAttr == Boolean.TRUE) {
                 stolen = stolenAttr;
             }
-            m_processor.processConnectionLost(clientID, stolen);
+            m_processor.processConnectionLost(clientID, stolen, new NettyChannel(ctx));
         }
         ctx.close();
     }

File: broker/src/main/java/io/moquette/spi/ClientSession.java
Patch:
@@ -148,12 +148,10 @@ public boolean isCleanSession() {
 
     public void activate() {
         this.active = true;
-        this.m_sessionsStore.activate(this.clientID);
     }
 
     public void deactivate() {
         this.active = false;
-        this.m_sessionsStore.deactivate(this.clientID);
     }
 
     public boolean isActive() {

File: broker/src/main/java/io/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -46,11 +46,9 @@ public class MapDBPersistentStore {
      * */
     public static class PersistentSession implements Serializable {
         public final boolean cleanSession;
-        public final boolean active;
 
-        public PersistentSession(boolean cleanSession, boolean active) {
+        public PersistentSession(boolean cleanSession) {
             this.cleanSession = cleanSession;
-            this.active = active;
         }
     }
 

File: broker/src/main/java/io/moquette/server/ServerAcceptor.java
Patch:
@@ -26,7 +26,7 @@
  */
 public interface ServerAcceptor {
     
-    void initialize(ProtocolProcessor processor, IConfig props) throws IOException;
+    void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException;
     
     void close();
 }

File: broker/src/main/java/io/moquette/server/Server.java
Patch:
@@ -27,7 +27,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.swing.*;
 import java.io.File;
 import java.io.IOException;
 import java.util.Collections;

File: broker/src/main/java/io/moquette/server/netty/MoquetteIdleTimeoutHandler.java
Patch:
@@ -22,7 +22,7 @@
 import io.netty.handler.timeout.IdleStateEvent;
 
 @Sharable
-class MoquetteIdleTimoutHandler extends ChannelDuplexHandler {
+class MoquetteIdleTimeoutHandler extends ChannelDuplexHandler {
     @Override
     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
         if (evt instanceof IdleStateEvent) {

File: broker/src/main/java/io/moquette/server/netty/NettyUtils.java
Patch:
@@ -45,6 +45,6 @@ public static void setIdleTime(ChannelHandlerContext channel, int idleTime) {
             channel.pipeline().remove("idleEventHandler");
         }
         channel.pipeline().addFirst("idleStateHandler", new IdleStateHandler(0, 0, idleTime));
-        channel.pipeline().addAfter("idleStateHandler", "idleEventHandler", new MoquetteIdleTimoutHandler());
+        channel.pipeline().addAfter("idleStateHandler", "idleEventHandler", new MoquetteIdleTimeoutHandler());
     }
 }

File: broker/src/main/java/io/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -69,8 +69,7 @@ public static SimpleMessaging getInstance() {
     public ProtocolProcessor init(IConfig props) {
         subscriptions = new SubscriptionsStore();
 
-        //TODO use a property to select the storage path
-        m_mapStorage = new MapDBPersistentStore(props.getProperty(PERSISTENT_STORE_PROPERTY_NAME, ""));
+        m_mapStorage = new MapDBPersistentStore(props);
         m_mapStorage.initStore();
         IMessagesStore messagesStore = m_mapStorage.messagesStore();
         ISessionsStore sessionsStore = m_mapStorage.sessionsStore(messagesStore);

File: parser_commons/src/main/java/io/moquette/commons/Constants.java
Patch:
@@ -28,6 +28,7 @@ public class Constants {
     public static final String DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME = "moquette_store.mapdb";
     public static final String DEFAULT_PERSISTENT_PATH = System.getProperty("user.dir") + File.separator + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
     public static final String PERSISTENT_STORE_PROPERTY_NAME = "persistent_store";
+    public static final String AUTOSAVE_INTERVAL_PROPERTY_NAME = "autosave_interval";
     public static final String PASSWORD_FILE_PROPERTY_NAME = "password_file";    
     public static final String PORT_PROPERTY_NAME = "port";
     public static final String HOST_PROPERTY_NAME = "host";

File: broker/src/main/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -428,7 +428,9 @@ private PublishEvent convertFromStored(StoredPublishEvent evt) {
         byte[] message = evt.getMessage();
         ByteBuffer bbmessage = ByteBuffer.wrap(message);
         //bbmessage.flip();
-        return new PublishEvent(evt.getTopic(), evt.getQos(),
+        PublishEvent pubEvt = new PublishEvent(evt.getTopic(), evt.getQos(),
                 bbmessage, evt.isRetain(), evt.getClientID(), evt.getMessageID());
+        pubEvt.setGuid(evt.getGuid());
+        return pubEvt;
     }
 }

File: broker/src/test/java/org/eclipse/moquette/server/ServerIntegrationPahoTest.java
Patch:
@@ -61,8 +61,9 @@ protected void startServer() throws IOException {
     @Before
     public void setUp() throws Exception {
         String dbPath = IntegrationUtils.localMapDBPath();
-        File dbFile = new File(dbPath);
-        assertFalse(String.format("The DB storagefile %s already exists", dbPath), dbFile.exists());
+        IntegrationUtils.cleanPersistenceFile(dbPath);
+//        File dbFile = new File(dbPath);
+//        assertFalse(String.format("The DB storagefile %s already exists", dbPath), dbFile.exists());
     	
         startServer();
 

File: broker/src/test/java/org/eclipse/moquette/spi/impl/ProtocolProcessorTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.eclipse.moquette.interception.InterceptHandler;
 import org.eclipse.moquette.proto.messages.*;
 import org.eclipse.moquette.server.netty.NettyChannel;
+import org.eclipse.moquette.spi.ClientSession;
 import org.eclipse.moquette.spi.IMatchingCondition;
 import org.eclipse.moquette.spi.IMessagesStore;
 import org.eclipse.moquette.spi.ISessionsStore;
@@ -484,9 +485,9 @@ public void testForwardPublishWithCorrectQos() {
 
         ProtocolProcessor processor = new ProtocolProcessor() {
             @Override
-            protected void directSend(String clientId, String topic, AbstractMessage.QOSType qos, ByteBuffer message,
+            protected void directSend(ClientSession session, String topic, AbstractMessage.QOSType qos, ByteBuffer message,
                                       boolean retained, Integer messageID) {
-                publishedForwarded.add(new PublishEvent(topic, qos, message, retained, clientId, messageID));
+                publishedForwarded.add(new PublishEvent(topic, qos, message, retained, session.clientID, messageID));
             }
         };
         processor.init(subscriptions, memoryMessageStore, sessionsStore, null, true, null, NO_OBSERVERS_INTERCEPTOR);

File: broker/src/test/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStoreTest.java
Patch:
@@ -22,7 +22,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.io.File;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
@@ -87,11 +86,13 @@ public void testNextPacketID_existingClientSession() {
     @Test
     public void testNextPacketID() {
         //request a first ID
+
         int packetId = m_storageService.nextPacketID("CLIENT");
+        m_storageService.inFlight("CLIENT", packetId, "ABCDE"); //simulate an inflight
         assertEquals(1, packetId);
 
         //release the ID
-//        m_storageService.cleanTemporaryPublish("CLIENT", packetId);
+        m_storageService.inFlightAck("CLIENT", packetId);
 
         //request a second packetID, counter restarts from 0
         packetId = m_storageService.nextPacketID("CLIENT");

File: broker/src/main/java/org/eclipse/moquette/server/netty/NettyChannel.java
Patch:
@@ -31,11 +31,13 @@ public class NettyChannel implements ServerChannel {
     private ChannelHandlerContext m_channel;
 
     public static final String ATTR_USERNAME = "username";
+    public static final String ATTR_SESSION_STOLEN = "sessionStolen";
 
     public static final AttributeKey<Object> ATTR_KEY_KEEPALIVE = AttributeKey.valueOf(Constants.KEEP_ALIVE);
     public static final AttributeKey<Object> ATTR_KEY_CLEANSESSION = AttributeKey.valueOf(Constants.CLEAN_SESSION);
     public static final AttributeKey<Object> ATTR_KEY_CLIENTID = AttributeKey.valueOf(Constants.ATTR_CLIENTID);
     public static final AttributeKey<Object> ATTR_KEY_USERNAME = AttributeKey.valueOf(ATTR_USERNAME);
+    public static final AttributeKey<Object> ATTR_KEY_SESSION_STOLEN = AttributeKey.valueOf(ATTR_SESSION_STOLEN);
 
     NettyChannel(ChannelHandlerContext ctx) {
         m_channel = ctx;

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -181,6 +181,7 @@ public void processConnect(ServerChannel session, ConnectMessage msg) {
                 cleanSession(msg.getClientID());
             }
 
+            oldSession.setAttribute(NettyChannel.ATTR_KEY_SESSION_STOLEN, true);
             oldSession.close(false);
             LOG.debug("Existing connection with same client ID <{}>, forced to close", msg.getClientID());
         }
@@ -544,14 +545,13 @@ public void processDisconnect(ServerChannel session, DisconnectMessage msg) thro
     public void processConnectionLost(LostConnectionEvent evt) {
         String clientID = evt.clientID;
         //If already removed a disconnect message was already processed for this clientID
-        if (m_clientIDs.remove(clientID) != null) {
-
+        if (evt.sessionStolen && m_clientIDs.remove(clientID) != null) {
             //de-activate the subscriptions for this ClientID
             subscriptions.deactivate(clientID);
             LOG.info("Lost connection with client <{}>", clientID);
         }
         //publish the Will message (if any) for the clientID
-        if (m_willStore.containsKey(clientID)) {
+        if (!evt.sessionStolen && m_willStore.containsKey(clientID)) {
             WillMessage will = m_willStore.get(clientID);
             forwardPublishWill(will, clientID);
             m_willStore.remove(clientID);

File: broker/src/main/java/org/eclipse/moquette/server/Server.java
Patch:
@@ -102,6 +102,7 @@ public void startServer(IConfig config) throws IOException {
     public void stopServer() {
     	LOG.info("Server stopping...");
         m_acceptor.close();
+        SimpleMessaging.getInstance().shutdown();
         LOG.info("Server stopped");
     }
 }

File: broker/src/main/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -312,6 +312,8 @@ public void close() {
         LOG.debug("persisted subscriptions {}", m_persistentSubscriptions);
         this.m_db.close();
         LOG.debug("closed disk storage");
+        this.m_scheduler.shutdown();
+        LOG.debug("Persistence commit scheduler is shutdown");
     }
 
     /*-------- QoS 2  storage management --------------*/

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -224,7 +224,7 @@ void processConnect(ServerChannel session, ConnectMessage msg) {
 
         //Handle will flag
         if (msg.isWillFlag()) {
-            AbstractMessage.QOSType willQos = AbstractMessage.QOSType.values()[msg.getWillQos()];
+            AbstractMessage.QOSType willQos = AbstractMessage.QOSType.valueOf(msg.getWillQos());
             byte[] willPayload = msg.getWillMessage();
             ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
             //save the will testament in the clientID store
@@ -391,7 +391,7 @@ void forward2Subscribers(PublishEvent pubEvt) {
         }
         for (final Subscription sub : subscriptions.matches(topic)) {
             AbstractMessage.QOSType qos = publishingQos;
-            if (qos.ordinal() > sub.getRequestedQos().ordinal()) {
+            if (qos.byteValue() > sub.getRequestedQos().byteValue()) {
                 qos = sub.getRequestedQos();
             }
 
@@ -637,7 +637,7 @@ void processSubscribe(ServerChannel session, SubscribeMessage msg) {
         ackMessage.setMessageID(msg.getMessageID());
 
         for (SubscribeMessage.Couple req : msg.subscriptions()) {
-            AbstractMessage.QOSType qos = AbstractMessage.QOSType.values()[req.getQos()];
+            AbstractMessage.QOSType qos = AbstractMessage.QOSType.valueOf(req.getQos());
             Subscription newSubscription = new Subscription(clientID, req.getTopicFilter(), qos, cleanSession);
             boolean valid = subscribeSingleTopic(newSubscription, req.getTopicFilter());
             ackMessage.addType(valid ? qos : AbstractMessage.QOSType.FAILURE);

File: broker/src/main/java/org/eclipse/moquette/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -237,7 +237,7 @@ public List<Subscription> matches(String topic) {
         for (Subscription sub : matchingSubs) {
             Subscription existingSub = subsForClient.get(sub.getClientId());
             //update the selected subscriptions if not present or if has a greater qos
-            if (existingSub == null || existingSub.getRequestedQos().ordinal() < sub.getRequestedQos().ordinal()) {
+            if (existingSub == null || existingSub.getRequestedQos().byteValue() < sub.getRequestedQos().byteValue()) {
                 subsForClient.put(sub.getClientId(), sub);
             }
         }

File: broker/src/test/java/org/eclipse/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -113,7 +113,7 @@ public void checkWillMessageIsWiredOnClientKeepAliveExpiry() throws Exception {
         connectMessage.setWillFlag(true);
         connectMessage.setWillMessage(willTestamentMsg.getBytes());
         connectMessage.setWillTopic(willTestamentTopic);
-        connectMessage.setWillQos((byte) QOSType.MOST_ONE.ordinal());
+        connectMessage.setWillQos(QOSType.MOST_ONE.byteValue());
         
         //Execute
         m_client.sendMessage(connectMessage);
@@ -155,7 +155,7 @@ public void call(AbstractMessage msg) {
         connectMessage.setClientID("");
         connectMessage.setKeepAlive(keepAlive);
         connectMessage.setWillFlag(false);
-        connectMessage.setWillQos((byte) QOSType.MOST_ONE.ordinal());
+        connectMessage.setWillQos(QOSType.MOST_ONE.byteValue());
         
         //Execute
         m_client.sendMessage(connectMessage);

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/SubAckDecoder.java
Patch:
@@ -49,7 +49,7 @@ void decode(AttributeMap ctx, ByteBuf in, List<Object> out) throws Exception {
         }
         for (int i = 0; i < remainingLength; i++) {
             byte qos = in.readByte();
-            message.addType(AbstractMessage.QOSType.values()[qos]);
+            message.addType(AbstractMessage.QOSType.valueOf(qos));
         }
         
         out.add(message);

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/SubAckEncoder.java
Patch:
@@ -40,8 +40,7 @@ protected void encode(ChannelHandlerContext chc, SubAckMessage message, ByteBuf
             buff.writeBytes(Utils.encodeRemainingLength(variableHeaderSize));
             buff.writeShort(message.getMessageID());
             for (QOSType c : message.types()) {
-                int qosValue = (c == QOSType.FAILURE) ? qosValue = 0x80 : c.ordinal();
-                buff.writeByte(qosValue);
+                buff.writeByte(c.byteValue());
             }
 
             out.writeBytes(buff);

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/Utils.java
Patch:
@@ -184,7 +184,7 @@ static byte encodeFlags(AbstractMessage message) {
             flags |= 0x01;
         }
         
-        flags |= ((message.getQos().ordinal() & 0x03) << 1);
+        flags |= ((message.getQos().byteValue() & 0x03) << 1);
         return flags;
     }
     

File: parser_commons/src/main/java/org/eclipse/moquette/proto/Utils.java
Patch:
@@ -173,7 +173,7 @@ static byte encodeFlags(AbstractMessage message) {
             flags |= 0x01;
         }
         
-        flags |= ((message.getQos().ordinal() & 0x03) << 1);
+        flags |= ((message.getQos().byteValue() & 0x03) << 1);
         return flags;
     }
 

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -224,7 +224,7 @@ void processConnect(ServerChannel session, ConnectMessage msg) {
 
         //Handle will flag
         if (msg.isWillFlag()) {
-            AbstractMessage.QOSType willQos = AbstractMessage.QOSType.values()[msg.getWillQos()];
+            AbstractMessage.QOSType willQos = AbstractMessage.QOSType.valueOf(msg.getWillQos());
             byte[] willPayload = msg.getWillMessage();
             ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
             //save the will testament in the clientID store
@@ -391,7 +391,7 @@ void forward2Subscribers(PublishEvent pubEvt) {
         }
         for (final Subscription sub : subscriptions.matches(topic)) {
             AbstractMessage.QOSType qos = publishingQos;
-            if (qos.ordinal() > sub.getRequestedQos().ordinal()) {
+            if (qos.byteValue() > sub.getRequestedQos().byteValue()) {
                 qos = sub.getRequestedQos();
             }
 
@@ -637,7 +637,7 @@ void processSubscribe(ServerChannel session, SubscribeMessage msg) {
         ackMessage.setMessageID(msg.getMessageID());
 
         for (SubscribeMessage.Couple req : msg.subscriptions()) {
-            AbstractMessage.QOSType qos = AbstractMessage.QOSType.values()[req.getQos()];
+            AbstractMessage.QOSType qos = AbstractMessage.QOSType.valueOf(req.getQos());
             Subscription newSubscription = new Subscription(clientID, req.getTopicFilter(), qos, cleanSession);
             boolean valid = subscribeSingleTopic(newSubscription, req.getTopicFilter());
             ackMessage.addType(valid ? qos : AbstractMessage.QOSType.FAILURE);

File: broker/src/main/java/org/eclipse/moquette/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -237,7 +237,7 @@ public List<Subscription> matches(String topic) {
         for (Subscription sub : matchingSubs) {
             Subscription existingSub = subsForClient.get(sub.getClientId());
             //update the selected subscriptions if not present or if has a greater qos
-            if (existingSub == null || existingSub.getRequestedQos().ordinal() < sub.getRequestedQos().ordinal()) {
+            if (existingSub == null || existingSub.getRequestedQos().byteValue() < sub.getRequestedQos().byteValue()) {
                 subsForClient.put(sub.getClientId(), sub);
             }
         }

File: broker/src/test/java/org/eclipse/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -113,7 +113,7 @@ public void checkWillMessageIsWiredOnClientKeepAliveExpiry() throws Exception {
         connectMessage.setWillFlag(true);
         connectMessage.setWillMessage(willTestamentMsg.getBytes());
         connectMessage.setWillTopic(willTestamentTopic);
-        connectMessage.setWillQos((byte) QOSType.MOST_ONE.ordinal());
+        connectMessage.setWillQos(QOSType.MOST_ONE.byteValue());
         
         //Execute
         m_client.sendMessage(connectMessage);
@@ -155,7 +155,7 @@ public void call(AbstractMessage msg) {
         connectMessage.setClientID("");
         connectMessage.setKeepAlive(keepAlive);
         connectMessage.setWillFlag(false);
-        connectMessage.setWillQos((byte) QOSType.MOST_ONE.ordinal());
+        connectMessage.setWillQos(QOSType.MOST_ONE.byteValue());
         
         //Execute
         m_client.sendMessage(connectMessage);

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/SubAckDecoder.java
Patch:
@@ -49,7 +49,7 @@ void decode(AttributeMap ctx, ByteBuf in, List<Object> out) throws Exception {
         }
         for (int i = 0; i < remainingLength; i++) {
             byte qos = in.readByte();
-            message.addType(AbstractMessage.QOSType.values()[qos]);
+            message.addType(AbstractMessage.QOSType.valueOf(qos));
         }
         
         out.add(message);

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/SubAckEncoder.java
Patch:
@@ -40,8 +40,7 @@ protected void encode(ChannelHandlerContext chc, SubAckMessage message, ByteBuf
             buff.writeBytes(Utils.encodeRemainingLength(variableHeaderSize));
             buff.writeShort(message.getMessageID());
             for (QOSType c : message.types()) {
-                int qosValue = (c == QOSType.FAILURE) ? qosValue = 0x80 : c.ordinal();
-                buff.writeByte(qosValue);
+                buff.writeByte(c.byteValue());
             }
 
             out.writeBytes(buff);

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/Utils.java
Patch:
@@ -184,7 +184,7 @@ static byte encodeFlags(AbstractMessage message) {
             flags |= 0x01;
         }
         
-        flags |= ((message.getQos().ordinal() & 0x03) << 1);
+        flags |= ((message.getQos().byteValue() & 0x03) << 1);
         return flags;
     }
     

File: parser_commons/src/main/java/org/eclipse/moquette/proto/Utils.java
Patch:
@@ -173,7 +173,7 @@ static byte encodeFlags(AbstractMessage message) {
             flags |= 0x01;
         }
         
-        flags |= ((message.getQos().ordinal() & 0x03) << 1);
+        flags |= ((message.getQos().byteValue() & 0x03) << 1);
         return flags;
     }
 

File: broker/src/main/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -86,7 +86,7 @@ public void initStore() {
 	            LOG.error(null, ex);
 	            throw new MQTTException("Can't create temp file for subscriptions storage [" + m_storePath + "]", ex);
 	        }
-	        m_db = DBMaker.newFileDB(tmpFile).closeOnJvmShutdown().make();
+	        m_db = DBMaker.newFileDB(tmpFile).make();
     	}
         m_retainedStore = m_db.getHashMap("retained");
         m_persistentMessageStore = m_db.getHashMap("persistedMessages");

File: broker/src/main/java/org/eclipse/moquette/spi/impl/MemoryStorageService.java
Patch:
@@ -104,6 +104,9 @@ public List<PublishEvent> listMessagesInSession(String clientID) {
     @Override
     public void removeMessageInSession(String clientID, Integer messageID) {
         List<PublishEvent> events = m_persistentMessageStore.get(clientID);
+        if (events == null) {
+            return;
+        }
         PublishEvent toRemoveEvt = null;
         for (PublishEvent evt : events) {
             if (evt.getMessageID() == null && messageID == null) {

File: broker/src/main/java/org/eclipse/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -189,7 +189,7 @@ void init(ChannelPipeline pipeline) {
                 pipeline.addLast("httpEncoder", new HttpResponseEncoder());
                 pipeline.addLast("httpDecoder", new HttpRequestDecoder());
                 pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
-                pipeline.addLast("webSocketHandler", new WebSocketServerProtocolHandler("/mqtt"/*"/mqtt"*/, "mqttv3.1, mqttv3.1.1"));
+                pipeline.addLast("webSocketHandler", new WebSocketServerProtocolHandler("/mqtt", "mqtt, mqttv3.1, mqttv3.1.1"));
                 //pipeline.addLast("webSocketHandler", new WebSocketServerProtocolHandler(null, "mqtt"));
                 pipeline.addLast("ws2bytebufDecoder", new WebSocketFrameToByteBufDecoder());
                 pipeline.addLast("bytebuf2wsEncoder", new ByteBufToWebSocketFrameEncoder());

File: broker/src/main/java/org/eclipse/moquette/spi/ISessionsStore.java
Patch:
@@ -53,4 +53,6 @@ public interface ISessionsStore {
      * @return true iff there are subscriptions persisted with clientID
      */
     boolean contains(String clientID);
+
+    void createNewSession(String clientID);
 }

File: broker/src/test/java/org/eclipse/moquette/spi/impl/subscriptions/SubscriptionsStoreTest.java
Patch:
@@ -313,6 +313,7 @@ public void testMatchTopics_single() {
         assertTrue(SubscriptionsStore.matchTopics("/finance", "+/+"));
         assertTrue(SubscriptionsStore.matchTopics("/finance/stock/ibm", "/finance/+/ibm"));
         assertTrue(SubscriptionsStore.matchTopics("/", "+/+"));
+        assertTrue(SubscriptionsStore.matchTopics("sport/", "sport/+"));
         assertFalse(SubscriptionsStore.matchTopics("/finance/stock", "+"));
     }
     

File: broker/src/main/java/org/eclipse/moquette/interception/messages/InterceptConnectMessage.java
Patch:
@@ -57,15 +57,15 @@ public String getUsername() {
         return msg.getUsername();
     }
 
-    public String getPassword() {
+    public byte[] getPassword() {
         return msg.getPassword();
     }
 
     public String getWillTopic() {
         return msg.getWillTopic();
     }
 
-    public String getWillMessage() {
+    public byte[] getWillMessage() {
         return msg.getWillMessage();
     }
 }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -177,7 +177,7 @@ void processConnect(ServerChannel session, ConnectMessage msg) {
 
         //handle user authentication
         if (msg.isUserFlag()) {
-            String pwd = null;
+            byte[] pwd = null;
             if (msg.isPasswordFlag()) {
                 pwd = msg.getPassword();
             } else if (!this.allowAnonymous) {
@@ -225,7 +225,7 @@ void processConnect(ServerChannel session, ConnectMessage msg) {
         //Handle will flag
         if (msg.isWillFlag()) {
             AbstractMessage.QOSType willQos = AbstractMessage.QOSType.values()[msg.getWillQos()];
-            byte[] willPayload = msg.getWillMessage().getBytes();
+            byte[] willPayload = msg.getWillMessage();
             ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
             //save the will testament in the clientID store
             WillMessage will = new WillMessage(msg.getWillTopic(), bb, msg.isWillRetain(),willQos );

File: broker/src/main/java/org/eclipse/moquette/spi/impl/security/AcceptAllAuthenticator.java
Patch:
@@ -4,7 +4,7 @@
  * Created by andrea on 8/23/14.
  */
 public class AcceptAllAuthenticator implements IAuthenticator {
-    public boolean checkValid(String username, String password) {
+    public boolean checkValid(String username, byte[] password) {
         return true;
     }
 }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/security/IAuthenticator.java
Patch:
@@ -22,5 +22,5 @@
  */
 public interface IAuthenticator {
 
-    boolean checkValid(String username, String password);
+    boolean checkValid(String username, byte[] password);
 }

File: broker/src/test/java/org/eclipse/moquette/server/ConfigurationClassLoaderTest.java
Patch:
@@ -79,7 +79,7 @@ public void loadAuthorizator() throws Exception {
     }
 
     @Override
-    public boolean checkValid(String username, String password) {
+    public boolean checkValid(String username, byte[] password) {
         return true;
     }
 

File: broker/src/test/java/org/eclipse/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -111,7 +111,7 @@ public void checkWillMessageIsWiredOnClientKeepAliveExpiry() throws Exception {
         connectMessage.setClientID("FAKECLNT");
         connectMessage.setKeepAlive(keepAlive);
         connectMessage.setWillFlag(true);
-        connectMessage.setWillMessage(willTestamentMsg);
+        connectMessage.setWillMessage(willTestamentMsg.getBytes());
         connectMessage.setWillTopic(willTestamentTopic);
         connectMessage.setWillQos((byte) QOSType.MOST_ONE.ordinal());
         

File: broker/src/test/java/org/eclipse/moquette/spi/impl/MockAuthenticator.java
Patch:
@@ -25,13 +25,13 @@
  */
 class MockAuthenticator implements IAuthenticator {
     
-    private Map<String, String> m_userPwds;
+    private Map<String, byte[]> m_userPwds;
     
-    MockAuthenticator(Map<String, String> userPwds) {
+    MockAuthenticator(Map<String, byte[]> userPwds) {
         m_userPwds = userPwds;
     }
 
-    public boolean checkValid(String username, String password) {
+    public boolean checkValid(String username, byte[] password) {
         if (!m_userPwds.containsKey(username)) {
             return false;
         }

File: broker/src/test/java/org/eclipse/moquette/spi/impl/security/FileAuthenticatorTest.java
Patch:
@@ -31,22 +31,22 @@ public void loadPasswordFile_verifyValid() {
         String file = getClass().getResource("/password_file.conf").getPath();        
         IAuthenticator auth = new FileAuthenticator(null, file);
         
-        assertTrue(auth.checkValid("testuser", "passwd"));
+        assertTrue(auth.checkValid("testuser", "passwd".getBytes()));
     }
     
     @Test
     public void loadPasswordFile_verifyInvalid() {
         String file = getClass().getResource("/password_file.conf").getPath();        
         IAuthenticator auth = new FileAuthenticator(null, file);
         
-        assertFalse(auth.checkValid("testuser2", "passwd"));
+        assertFalse(auth.checkValid("testuser2", "passwd".getBytes()));
     }
     
     @Test
     public void loadPasswordFile_verifyDirectoryRef() {
         IAuthenticator auth = new FileAuthenticator("", "");
         
-        assertFalse(auth.checkValid("testuser2", "passwd"));
+        assertFalse(auth.checkValid("testuser2", "passwd".getBytes()));
     }
 
 }
\ No newline at end of file

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/ConnectDecoder.java
Patch:
@@ -173,7 +173,7 @@ void decode(AttributeMap ctx, ByteBuf in, List<Object> out) throws UnsupportedEn
 
         //Decode willMessage
         if (willFlag) {
-            String willMessage = Utils.decodeString(in);
+            byte[] willMessage = Utils.readFixedLengthContent(in);
             if (willMessage == null) {
                 in.resetReaderIndex();
                 return;
@@ -207,7 +207,7 @@ void decode(AttributeMap ctx, ByteBuf in, List<Object> out) throws UnsupportedEn
 
         //Decode password
         if (passwordFlag) {
-            String password = Utils.decodeString(in);
+            byte[] password = Utils.readFixedLengthContent(in);
             if (password == null) {
                 in.resetReaderIndex();
                 return;

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/ConnectEncoder.java
Patch:
@@ -65,12 +65,12 @@ protected void encode(ChannelHandlerContext chc, ConnectMessage message, ByteBuf
                 variableHeaderBuff.writeBytes(Utils.encodeString(message.getClientID()));
                 if (message.isWillFlag()) {
                     variableHeaderBuff.writeBytes(Utils.encodeString(message.getWillTopic()));
-                    variableHeaderBuff.writeBytes(Utils.encodeString(message.getWillMessage()));
+                    variableHeaderBuff.writeBytes(Utils.encodeFixedLengthContent(message.getWillMessage()));
                 }
                 if (message.isUserFlag() && message.getUsername() != null) {
                     variableHeaderBuff.writeBytes(Utils.encodeString(message.getUsername()));
                     if (message.isPasswordFlag() && message.getPassword() != null) {
-                        variableHeaderBuff.writeBytes(Utils.encodeString(message.getPassword()));
+                        variableHeaderBuff.writeBytes(Utils.encodeFixedLengthContent(message.getPassword()));
                     }
                 }
             }

File: netty_parser/src/test/java/org/eclipse/moquette/parser/netty/ConnectDecoderTest.java
Patch:
@@ -142,7 +142,7 @@ public void testBaseHeader_ClientID() throws UnsupportedEncodingException, Excep
         verifyBaseHeader(message);
         assertEquals("ABCDEFGH", message.getClientID());
         assertEquals("Topic", message.getWillTopic());
-        assertEquals("Message", message.getWillMessage());
+        assertEquals("Message", new String(message.getWillMessage()));
     }
     
     
@@ -167,9 +167,9 @@ public void testBaseHeader_extra_with_user_pwd() throws UnsupportedEncodingExcep
         assertEquals(AbstractMessage.CONNECT, message.getMessageType());
         assertEquals("ABCDEFGH", message.getClientID());
         assertEquals("Topic", message.getWillTopic());
-        assertEquals("Message", message.getWillMessage());
+        assertEquals("Message", new String(message.getWillMessage()));
         assertEquals("Fakeuser", message.getUsername());
-        assertEquals("pwd", message.getPassword());
+        assertEquals("pwd", new String(message.getPassword()));
     }
     
     @Test(expected = CorruptedFrameException.class)

File: netty_parser/src/test/java/org/eclipse/moquette/parser/netty/ConnectEncoderTest.java
Patch:
@@ -75,7 +75,7 @@ public void testCompleteHeader() throws Exception {
         //variable part
         msg.setClientID("ABCDEF");
         msg.setWillTopic("Topic");
-        msg.setWillMessage("Message");
+        msg.setWillMessage("Message".getBytes());
         
         ByteBuf out = Unpooled.buffer();
         
@@ -111,9 +111,9 @@ public void testCompleteHeaderWIthUser_password() throws Exception {
         //variable part
         msg.setClientID("ABCDEF");
         msg.setWillTopic("Topic");
-        msg.setWillMessage("Message");
+        msg.setWillMessage("Message".getBytes());
         msg.setUsername("Pablo");
-        msg.setPassword("PBL");
+        msg.setPassword("PBL".getBytes());
         
         ByteBuf out = Unpooled.buffer();
         

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/PubRelEncoder.java
Patch:
@@ -28,7 +28,7 @@ class PubRelEncoder extends DemuxEncoder<PubRelMessage> {
 
     @Override
     protected void encode(ChannelHandlerContext chc, PubRelMessage msg, ByteBuf out) {
-        out.writeByte(AbstractMessage.PUBREL << 4);
+        out.writeByte(AbstractMessage.PUBREL << 4 | 0x02);
         out.writeBytes(Utils.encodeRemainingLength(2));
         out.writeShort(msg.getMessageID());
     }

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/PubRelEncoder.java
Patch:
@@ -28,7 +28,7 @@ class PubRelEncoder extends DemuxEncoder<PubRelMessage> {
 
     @Override
     protected void encode(ChannelHandlerContext chc, PubRelMessage msg, ByteBuf out) {
-        out.writeByte(AbstractMessage.PUBREL << 4);
+        out.writeByte(AbstractMessage.PUBREL << 4 | 0x02);
         out.writeBytes(Utils.encodeRemainingLength(2));
         out.writeShort(msg.getMessageID());
     }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -289,7 +289,7 @@ void processPubAck(ServerChannel session, PubAckMessage msg) {
     private void cleanSession(String clientID) {
         LOG.info("cleaning old saved subscriptions for client <{}>", clientID);
         //remove from log all subscriptions
-        m_sessionsStore.wipeSubscriptions(clientID);
+        //m_sessionsStore.wipeSubscriptions(clientID);
         subscriptions.removeForClient(clientID);
 
         //remove also the messages stored of type QoS1/2

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -152,7 +152,7 @@ void init(SubscriptionsStore subscriptions, IMessagesStore storageService,
     @MQTTMessage(message = ConnectMessage.class)
     void processConnect(ServerChannel session, ConnectMessage msg) {
         LOG.debug("CONNECT for client <{}>", msg.getClientID());
-        if (msg.getProcotolVersion() != VERSION_3_1 && msg.getProcotolVersion() != VERSION_3_1_1) {
+        if (msg.getProtocolVersion() != VERSION_3_1 && msg.getProtocolVersion() != VERSION_3_1_1) {
             ConnAckMessage badProto = new ConnAckMessage();
             badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
             LOG.warn("processConnect sent bad proto ConnAck");

File: broker/src/test/java/org/eclipse/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -77,7 +77,7 @@ public void tearDown() throws Exception {
     public void elapseKeepAliveTime() throws InterruptedException {
         int keepAlive = 2; //secs
         ConnectMessage connectMessage = new ConnectMessage();
-        connectMessage.setProcotolVersion((byte)3);
+        connectMessage.setProtocolVersion((byte) 3);
         connectMessage.setClientID("FAKECLNT");
         connectMessage.setKeepAlive(keepAlive);
         m_client.sendMessage(connectMessage);
@@ -101,7 +101,7 @@ public void checkWillMessageIsWiredOnClientKeepAliveExpiry() throws Exception {
         
         int keepAlive = 2; //secs
         ConnectMessage connectMessage = new ConnectMessage();
-        connectMessage.setProcotolVersion((byte)3);
+        connectMessage.setProtocolVersion((byte) 3);
         connectMessage.setClientID("FAKECLNT");
         connectMessage.setKeepAlive(keepAlive);
         connectMessage.setWillFlag(true);
@@ -145,7 +145,7 @@ public void call(AbstractMessage msg) {
         
         int keepAlive = 2; //secs
         ConnectMessage connectMessage = new ConnectMessage();
-        connectMessage.setProcotolVersion((byte) 4);
+        connectMessage.setProtocolVersion((byte) 4);
         connectMessage.setClientID("");
         connectMessage.setKeepAlive(keepAlive);
         connectMessage.setWillFlag(false);

File: netty_parser/src/test/java/org/eclipse/moquette/parser/netty/ConnectDecoderTest.java
Patch:
@@ -238,7 +238,7 @@ private ByteBuf encodeString(ByteBuf buff, String str) throws UnsupportedEncodin
     private void verifyBaseHeader(ConnectMessage connMessage) {
         assertNotNull(connMessage);
         assertEquals("MQIsdp", connMessage.getProtocolName());
-        assertEquals(VERSION_3_1, connMessage.getProcotolVersion());
+        assertEquals(VERSION_3_1, connMessage.getProtocolVersion());
         assertTrue(connMessage.isUserFlag());
         assertTrue(connMessage.isPasswordFlag());
         assertTrue(connMessage.isCleanSession());
@@ -251,7 +251,7 @@ private void verifyBaseHeader(ConnectMessage connMessage) {
     private void verifyBaseHeader311(ConnectMessage connMessage) {
         assertNotNull(connMessage);
         assertEquals("MQTT", connMessage.getProtocolName());
-        assertEquals(VERSION_3_1_1, connMessage.getProcotolVersion());
+        assertEquals(VERSION_3_1_1, connMessage.getProtocolVersion());
         assertTrue(connMessage.isUserFlag());
         assertTrue(connMessage.isPasswordFlag());
         assertTrue(connMessage.isCleanSession());

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -23,6 +23,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
+import io.netty.util.internal.StringUtil;
+import org.apache.commons.codec.binary.StringUtils;
 import org.eclipse.moquette.server.netty.NettyChannel;
 import org.eclipse.moquette.spi.IMatchingCondition;
 import org.eclipse.moquette.spi.IMessagesStore;
@@ -144,7 +146,7 @@ void init(SubscriptionsStore subscriptions, IMessagesStore storageService,
         // Get the ring buffer from the Disruptor to be used for publishing.
         m_ringBuffer = disruptor.getRingBuffer();
     }
-    
+
     @MQTTMessage(message = ConnectMessage.class)
     void processConnect(ServerChannel session, ConnectMessage msg) {
         LOG.debug("CONNECT for client <{}>", msg.getClientID());

File: broker/src/test/java/org/eclipse/moquette/spi/impl/ProtocolProcessorTest.java
Patch:
@@ -185,7 +185,7 @@ public void testHandleConnect_BadProtocol() {
         //Verify
         assertEquals(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION, m_returnCode);
     }
-    
+
     @Test
     public void testConnect_badClientID() {
         connMsg.setClientID("extremely_long_clientID_greater_than_23");

File: netty_parser/src/test/java/org/eclipse/moquette/parser/netty/ConnectDecoderTest.java
Patch:
@@ -66,7 +66,7 @@ public void testBaseHeader() throws Exception {
     public void testBaseHeader_311() throws UnsupportedEncodingException {
         m_buff = Unpooled.buffer(12);
         initBaseHeader311(m_buff);
-        List<Object> results = new ArrayList<Object>();
+        List<Object> results = new ArrayList<>();
         
         //Excercise
         m_msgdec.decode(this.attrMap, m_buff, results);

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -256,7 +256,7 @@ private Object loadClass(String className, Class<?> cls) {
             Class<?> clazz = Class.forName(className);
 
             // check if method getInstance exists
-            Method method = clazz.getMethod("getInstace", new Class[] {});
+            Method method = clazz.getMethod("getInstance", new Class[] {});
             try {
                 instance = method.invoke(null, new Object[] {});
             } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {

File: parser_commons/src/main/java/org/eclipse/moquette/commons/Constants.java
Patch:
@@ -32,6 +32,7 @@ public class Constants {
     public static final String PORT_PROPERTY_NAME = "port";
     public static final String HOST_PROPERTY_NAME = "host";
     public static final String WEB_SOCKET_PORT_PROPERTY_NAME = "websocket_port";
+    public static final String WSS_PORT_PROPERTY_NAME = "secure_websocket_port";
     public static final String SSL_PORT_PROPERTY_NAME = "ssl_port";
     public static final String JKS_PATH_PROPERTY_NAME = "jks_path";
     public static final String KEY_STORE_PASSWORD_PROPERTY_NAME = "key_store_password";

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -587,7 +587,9 @@ void processUnsubscribe(ServerChannel session, UnsubscribeMessage msg) {
 
         for (String topic : topics) {
             subscriptions.removeSubscription(topic, clientID);
+            m_sessionsStore.removeSubscription(topic, clientID);
         }
+
         //ack the client
         UnsubAckMessage ackMessage = new UnsubAckMessage();
         ackMessage.setMessageID(messageID);

File: parser_commons/src/main/java/org/eclipse/moquette/proto/messages/AbstractMessage.java
Patch:
@@ -38,7 +38,7 @@ public abstract class AbstractMessage {
     public static final byte DISCONNECT = 14; //Client is Disconnecting
 
     public static enum QOSType {
-        MOST_ONE, LEAST_ONE, EXACTLY_ONCE, RESERVED;
+        MOST_ONE, LEAST_ONE, EXACTLY_ONCE, RESERVED, FAILURE;
         
         public static String formatQoS(QOSType qos) {
             return String.format("%d - %s", qos.ordinal(), qos.name());

File: broker/src/main/java/org/eclipse/moquette/spi/IMessagesStore.java
Patch:
@@ -77,7 +77,7 @@ public String getTopic() {
      */
     List<PublishEvent> listMessagesInSession(String clientID);
     
-    void removeMessageInSession(String clientID, int packetID);
+    void removeMessageInSession(String clientID, Integer packetID);
 
     void dropMessagesInSession(String clientID);
 

File: broker/src/main/java/org/eclipse/moquette/spi/impl/events/PublishEvent.java
Patch:
@@ -31,7 +31,7 @@ public class PublishEvent extends MessagingEvent {
     boolean m_retain;
     String m_clientID;
     //Optional attribute, available only fo QoS 1 and 2
-    int m_msgID;
+    Integer m_msgID;
 
     public PublishEvent(String topic, QOSType qos, ByteBuffer message, boolean retain,
                         String clientID, Integer msgID) {
@@ -65,7 +65,7 @@ public String getClientID() {
         return m_clientID;
     }
 
-    public int getMessageID() {
+    public Integer getMessageID() {
         return m_msgID;
     }
 

File: broker/src/main/java/org/eclipse/moquette/spi/impl/storage/StoredPublishEvent.java
Patch:
@@ -32,7 +32,7 @@ public class StoredPublishEvent implements Serializable {
     boolean m_retain;
     String m_clientID;
     //Optional attribute, available only fo QoS 1 and 2
-    int m_msgID;
+    Integer m_msgID;
     
     public StoredPublishEvent(PublishEvent wrapped) {
         m_topic = wrapped.getTopic();
@@ -67,7 +67,7 @@ public String getClientID() {
         return m_clientID;
     }
 
-    public int getMessageID() {
+    public Integer getMessageID() {
         return m_msgID;
     }
 }

File: broker/src/main/java/org/eclipse/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -245,7 +245,7 @@ void init(ChannelPipeline pipeline) throws Exception {
                 pipeline.addFirst("idleStateHandler", new IdleStateHandler(0, 0, Constants.DEFAULT_CONNECT_TIMEOUT));
                 pipeline.addAfter("idleStateHandler", "idleEventHandler", new MoquetteIdleTimoutHandler());
                 //pipeline.addLast("logger", new LoggingHandler("Netty", LogLevel.ERROR));
-                pipeline.addFirst("bytemetrics", new BytesMetricsHandler(m_bytesMetricsCollector));pipeline.addFirst("metrics", new BytesMetricsHandler(m_bytesMetricsCollector));
+                pipeline.addFirst("bytemetrics", new BytesMetricsHandler(m_bytesMetricsCollector));
                 pipeline.addLast("decoder", new MQTTDecoder());
                 pipeline.addLast("encoder", new MQTTEncoder());
                 pipeline.addLast("metrics", new MessageMetricsHandler(m_metricsCollector));

File: broker/src/main/java/org/eclipse/moquette/server/netty/metrics/BytesMetricsHandler.java
Patch:
@@ -59,7 +59,8 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
     public void close(ChannelHandlerContext ctx,
                       ChannelPromise promise) throws Exception {
         BytesMetrics metrics = ctx.attr(ATTR_KEY_METRICS).get();
-        m_collector.addMetrics(metrics);
+        m_collector.sumReadBytes(metrics.readBytes());
+        m_collector.sumWroteBytes(metrics.wroteBytes());
         super.close(ctx, promise);
     }
 }

File: broker/src/main/java/org/eclipse/moquette/server/netty/metrics/MessageMetricsHandler.java
Patch:
@@ -58,7 +58,8 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
     public void close(ChannelHandlerContext ctx,
                       ChannelPromise promise) throws Exception {
         MessageMetrics metrics = ctx.attr(ATTR_KEY_METRICS).get();
-        m_collector.addMetrics(metrics);
+        m_collector.sumReadMessages(metrics.messagesRead());
+        m_collector.sumWroteMessages(metrics.messagesWrote());
         super.close(ctx, promise);
     }
 }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -153,6 +153,7 @@ public void stop() {
     @Override
     public void onEvent(ValueEvent t, long l, boolean bln) throws Exception {
         MessagingEvent evt = t.getEvent();
+        t.setEvent(null); //free the reference to all Netty stuff
         LOG.info("onEvent processing messaging event from input ringbuffer {}", evt);
         if (evt instanceof StopEvent) {
             processStop();

File: broker/src/main/java/org/eclipse/moquette/spi/IMessaging.java
Patch:
@@ -30,7 +30,7 @@ public interface IMessaging {
 
     void stop();
 
-    void lostConnection(ServerChannel session, String clientID);
+    void lostConnection(String clientID);
 
     void handleProtocolMessage(ServerChannel session, AbstractMessage msg);
 }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -122,8 +122,8 @@ private void disruptorPublish(MessagingEvent msgEvent) {
     }
     
     @Override
-    public void lostConnection(ServerChannel session, String clientID) {
-        disruptorPublish(new LostConnectionEvent(session, clientID));
+    public void lostConnection(String clientID) {
+        disruptorPublish(new LostConnectionEvent(clientID));
     }
 
     @Override

File: broker/src/main/java/org/eclipse/moquette/spi/impl/events/LostConnectionEvent.java
Patch:
@@ -23,11 +23,11 @@
  * @author andrea
  */
 public class LostConnectionEvent extends MessagingEvent {
-    public final ServerChannel session;
+//    public final ServerChannel session;
     public final String clientID;
 
-    public LostConnectionEvent(ServerChannel session, String clientID) {
-        this.session = session;
+    public LostConnectionEvent(/*ServerChannel session, */String clientID) {
+//        this.session = session;
         this.clientID = clientID;
     }
 }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -206,9 +206,11 @@ private void processInit(Properties props) {
         String aclFilePath = props.getProperty(ACL_FILE_PROPERTY_NAME, "");
         IAuthorizator authorizator;
         if (aclFilePath != null && !aclFilePath.isEmpty()) {
-            authorizator = new ACLAuthorizator(aclFilePath);
+            authorizator = new ACLAuthorizator(configPath, aclFilePath);
+            LOG.info("Using acl file defined at path {}", aclFilePath);
         } else {
             authorizator = new PermitAllAuthorizator();
+            LOG.info("Starting without ACL definition");
         }
 
         boolean allowAnonymous = Boolean.parseBoolean(props.getProperty(ALLOW_ANONYMOUS_PROPERTY_NAME, "true"));

File: broker/src/main/java/org/eclipse/moquette/spi/impl/security/ACLAuthorizator.java
Patch:
@@ -35,8 +35,8 @@ public class ACLAuthorizator implements IAuthorizator {
 
     List<Authorization> m_authorisations = Collections.emptyList();
 
-    public ACLAuthorizator(String aclFilePath) {
-        File aclFile = new File(aclFilePath);
+    public ACLAuthorizator(String parent, String filePath) {
+        File aclFile = new File(parent, filePath);
         try {
             m_authorisations = ACLFileParser.parse(aclFile);
         } catch (ParseException pex) {

File: broker/src/main/java/org/eclipse/moquette/server/ConfigurationParser.java
Patch:
@@ -59,6 +59,7 @@ private void createDefaults() {
         m_properties.put(WEB_SOCKET_PORT_PROPERTY_NAME, Integer.toString(WEBSOCKET_PORT));
         m_properties.put(PASSWORD_FILE_PROPERTY_NAME, "");
         m_properties.put(PERSISTENT_STORE_PROPERTY_NAME, DEFAULT_PERSISTENT_PATH);
+        m_properties.put(ALLOW_ANONYMOUS, true);
     }
     
     /**

File: parser_commons/src/main/java/org/eclipse/moquette/commons/Constants.java
Patch:
@@ -36,4 +36,5 @@ public class Constants {
     public static final String JKS_PATH_PROPERTY_NAME = "jks_path";
     public static final String KEY_STORE_PASSWORD_PROPERTY_NAME = "key_store_password";
     public static final String KEY_MANAGER_PASSWORD_PROPERTY_NAME = "key_manager_password";
+    public static final String ALLOW_ANONYMOUS = "allow_anonymous";
 }

File: parser_commons/src/main/java/org/eclipse/moquette/commons/Constants.java
Patch:
@@ -26,7 +26,7 @@ public class Constants {
     public static final String HOST = "0.0.0.0";
     public static final int DEFAULT_CONNECT_TIMEOUT = 10;
     public static final String DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME = "moquette_store.mapdb";
-    public static final String DEFAULT_PERSISTENT_PATH = System.getProperty("user.home") + File.separator + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
+    public static final String DEFAULT_PERSISTENT_PATH = System.getProperty("user.dir") + File.separator + DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME;
     public static final String PERSISTENT_STORE_PROPERTY_NAME = "persistent_store";
     public static final String PASSWORD_FILE_PROPERTY_NAME = "password_file";    
     public static final String PORT_PROPERTY_NAME = "port";

File: broker/src/test/java/org/eclipse/moquette/server/ServerRestartIntegrationTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.fusesource.mqtt.client.*;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -94,7 +95,7 @@ public void checkRestartCleanSubscriptionTree() throws Exception {
         }
         
         //restart the server
-        m_server.startServer();
+        m_server.startServer(IntegrationUtils.prepareTestPropeties());
         
         //reconnect the Subscriber subscribing to the same /topic but different QoS
         m_subscriber = m_mqtt.blockingConnection();
@@ -129,7 +130,7 @@ public void checkDontPublishInactiveClientsAfterServerRestart() throws Exception
         m_server.stopServer();
 
         //restart the server
-        m_server.startServer();
+        m_server.startServer(IntegrationUtils.prepareTestPropeties());
 
         MQTT mqtt = new MQTT();
         mqtt.setHost("localhost", 1883);

File: broker/src/test/java/org/eclipse/moquette/server/ServerIntegrationFuseTest.java
Patch:
@@ -44,7 +44,7 @@ public class ServerIntegrationFuseTest {
     
     protected void startServer() throws IOException {
         m_server = new Server();
-        m_server.startServer(new Properties());
+        m_server.startServer(IntegrationUtils.prepareTestPropeties());
     }
 
     @Before

File: broker/src/test/java/org/eclipse/moquette/server/ServerIntegrationQoSValidationTest.java
Patch:
@@ -60,7 +60,7 @@ public static void beforeTests() {
 
     protected void startServer() throws IOException {
         m_server = new Server();
-        m_server.startServer(new Properties());
+        m_server.startServer(IntegrationUtils.prepareTestPropeties());
     }
 
     @Before

File: broker/src/test/java/org/eclipse/moquette/server/ServerIntegrationWebSocketTest.java
Patch:
@@ -47,7 +47,7 @@ public class ServerIntegrationWebSocketTest {
 
     protected void startServer() throws IOException {
         m_server = new Server();
-        m_server.startServer(new Properties());
+        m_server.startServer(IntegrationUtils.prepareTestPropeties());
     }
 
     @Before

File: broker/src/test/java/org/eclipse/moquette/server/ServerLowlevelMessagesIntegrationTests.java
Patch:
@@ -49,7 +49,7 @@ public class ServerLowlevelMessagesIntegrationTests {
 
     protected void startServer() throws IOException {
         m_server = new Server();
-        m_server.startServer(new Properties());
+        m_server.startServer(IntegrationUtils.prepareTestPropeties());
     }
 
     @Before

File: broker/src/main/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -199,7 +199,7 @@ public void addInFlight(PublishEvent evt, String clientID, int packetID) {
     }
 
     /**
-     * Return the next valid packetIdentifer for the given client session.
+     * Return the next valid packetIdentifier for the given client session.
      * */
     @Override
     public int nextPacketID(String clientID) {
@@ -211,7 +211,7 @@ public int nextPacketID(String clientID) {
             this.m_inFlightIds.put(clientID, inFlightForClient);
             return nextPacketId;
         }
-        int maxId = Collections.max(inFlightForClient);
+        int maxId = inFlightForClient.isEmpty() ? 0 : Collections.max(inFlightForClient);
         int nextPacketId = (maxId + 1) % 0xFFFF;
         inFlightForClient.add(nextPacketId);
         return nextPacketId;

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -169,7 +169,7 @@ public void onEvent(ValueEvent t, long l, boolean bln) throws Exception {
                     histogram.recordValue(delay);
                 }
             } catch (Throwable th) {
-                LOG.error("Grave error processing the message {} for {}", message, session, th);
+                LOG.error("Serious error processing the message {} for {}", message, session, th);
             }
         }
     }

File: broker/src/test/java/org/eclipse/moquette/server/ServerIntegrationSSLTest.java
Patch:
@@ -76,8 +76,8 @@ protected void startServer() throws IOException {
 
     @Before
     public void setUp() throws Exception {
-        File dbFile = new File(m_server.getProperties().getProperty(org.eclipse.moquette.commons.Constants.PERSISTENT_STORE_PROPERTY_NAME));
-        assertFalse(String.format("The DB storagefile %s already exists", m_server.getProperties().getProperty(org.eclipse.moquette.commons.Constants.PERSISTENT_STORE_PROPERTY_NAME)), dbFile.exists());
+        File dbFile = new File(org.eclipse.moquette.commons.Constants.DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME);
+        assertFalse(String.format("The DB storagefile %s already exists",org.eclipse.moquette.commons.Constants.DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME), dbFile.exists());
         
         startServer();
 

File: broker/src/test/java/org/eclipse/moquette/server/ServerIntegrationPahoTest.java
Patch:
@@ -52,9 +52,9 @@ protected void startServer() throws IOException {
 
     @Before
     public void setUp() throws Exception {
-        File dbFile = new File(m_server.getProperties().getProperty(org.eclipse.moquette.commons.Constants.PERSISTENT_STORE_PROPERTY_NAME));
-        assertFalse(String.format("The DB storagefile %s already exists", m_server.getProperties().getProperty(org.eclipse.moquette.commons.Constants.PERSISTENT_STORE_PROPERTY_NAME)), dbFile.exists());
-        
+        File dbFile = new File(org.eclipse.moquette.commons.Constants.DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME);
+        assertFalse(String.format("The DB storagefile %s already exists",org.eclipse.moquette.commons.Constants.DEFAULT_MOQUETTE_STORE_MAP_DB_FILENAME), dbFile.exists());
+    	
         startServer();
 
         m_client = new MqttClient("tcp://localhost:1883", "TestClient", s_dataStore);

File: broker/src/main/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -24,6 +24,7 @@
 import org.eclipse.moquette.spi.impl.storage.StoredPublishEvent;
 import org.eclipse.moquette.spi.impl.subscriptions.Subscription;
 import org.eclipse.moquette.proto.messages.AbstractMessage;
+
 import static org.eclipse.moquette.spi.impl.Utils.defaultGet;
 
 import org.mapdb.DB;

File: broker/src/test/java/org/eclipse/moquette/server/ServerRestartIntegrationTest.java
Patch:
@@ -43,7 +43,7 @@ public class ServerRestartIntegrationTest {
     BlockingConnection m_publisher;
     Properties properties;
     private final static String PERSISTENT_STORE_PROPERTY_NAME = "persistent_store";
-    private final static String PERSISTENT_STORE_FILE_NAME = "store.mapdb";
+    private final static String PERSISTENT_STORE_FILE_NAME = System.getProperty("user.home") + File.separator + "moquette_store.mapdb";
     
     protected void startServer() throws IOException {
     	properties = new Properties();
@@ -73,7 +73,7 @@ public void tearDown() throws Exception {
         }
 
         m_server.stopServer();
-        File dbFile = new File(properties.getProperty(PERSISTENT_STORE_PROPERTY_NAME));
+        File dbFile = new File(m_server.getProperties().getProperty(org.eclipse.moquette.commons.Constants.PERSISTENT_STORE_PROPERTY_NAME));
         if (dbFile.exists()) {
             dbFile.delete();
         }
@@ -92,7 +92,7 @@ public void checkRestartCleanSubscriptionTree() throws Exception {
         
         //shutdown the server
         m_server.stopServer();
-        File dbFile = new File(properties.getProperty(PERSISTENT_STORE_PROPERTY_NAME));
+        File dbFile = new File(m_server.getProperties().getProperty(org.eclipse.moquette.commons.Constants.PERSISTENT_STORE_PROPERTY_NAME));
         if (dbFile.exists()) {
             dbFile.delete();
         }

File: broker/src/main/java/org/eclipse/moquette/server/netty/NettyChannel.java
Patch:
@@ -34,9 +34,9 @@ public class NettyChannel implements ServerChannel {
     
     private Map<Object, AttributeKey<Object>> m_attributesKeys = new HashMap<Object, AttributeKey<Object>>();
     
-    private static final AttributeKey<Object> ATTR_KEY_KEEPALIVE = new AttributeKey<Object>(Constants.KEEP_ALIVE);
-    private static final AttributeKey<Object> ATTR_KEY_CLEANSESSION = new AttributeKey<Object>(Constants.CLEAN_SESSION);
-    private static final AttributeKey<Object> ATTR_KEY_CLIENTID = new AttributeKey<Object>(Constants.ATTR_CLIENTID);
+    private static final AttributeKey<Object> ATTR_KEY_KEEPALIVE = AttributeKey.valueOf(Constants.KEEP_ALIVE);
+    private static final AttributeKey<Object> ATTR_KEY_CLEANSESSION = AttributeKey.valueOf(Constants.CLEAN_SESSION);
+    private static final AttributeKey<Object> ATTR_KEY_CLIENTID = AttributeKey.valueOf(Constants.ATTR_CLIENTID);
 
     NettyChannel(ChannelHandlerContext ctx) {
         m_channel = ctx;

File: broker/src/main/java/org/eclipse/moquette/server/netty/metrics/BytesMetricsHandler.java
Patch:
@@ -24,7 +24,7 @@
 
 public class BytesMetricsHandler extends ChannelDuplexHandler {
 
-    private static final AttributeKey<BytesMetrics> ATTR_KEY_METRICS = new AttributeKey<BytesMetrics>("BytesMetrics");
+    private static final AttributeKey<BytesMetrics> ATTR_KEY_METRICS = AttributeKey.valueOf("BytesMetrics");
 
     private BytesMetricsCollector m_collector;
 

File: broker/src/main/java/org/eclipse/moquette/server/netty/metrics/MessageMetricsHandler.java
Patch:
@@ -23,7 +23,7 @@
 
 public class MessageMetricsHandler extends ChannelDuplexHandler {
 
-    private static final AttributeKey<MessageMetrics> ATTR_KEY_METRICS = new AttributeKey<MessageMetrics>("MessageMetrics");
+    private static final AttributeKey<MessageMetrics> ATTR_KEY_METRICS = AttributeKey.valueOf("MessageMetrics");
 
     private MessageMetricsCollector m_collector;
 

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -85,7 +85,7 @@ public static SimpleMessaging getInstance() {
     public void init(Properties configProps) {
         subscriptions = new SubscriptionsStore();
         m_executor = Executors.newFixedThreadPool(1);
-        m_disruptor = new Disruptor<ValueEvent>(ValueEvent.EVENT_FACTORY, 1024 * 32, m_executor);
+        m_disruptor = new Disruptor<>(ValueEvent.EVENT_FACTORY, 1024 * 32, m_executor);
         /*Disruptor<ValueEvent> m_disruptor = new Disruptor<ValueEvent>(ValueEvent.EVENT_FACTORY, 1024 * 32, m_executor,
                 ProducerType.MULTI, new BusySpinWaitStrategy());*/
         m_disruptor.handleEventsWith(this);

File: broker/src/main/java/org/eclipse/moquette/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -200,7 +200,7 @@ public List<Subscription> matches(String topic) {
         } catch (ParseException ex) {
             //TODO handle the parse exception
             LOG.error(null, ex);
-            return Collections.EMPTY_LIST;
+            return Collections.emptyList();
         }
 
         Queue<Token> tokenQueue = new LinkedBlockingDeque<Token>(tokens);
@@ -274,7 +274,7 @@ public static boolean matchTopics(String msgTopic, String subscriptionTopic) {
     }
     
     protected static List<Token> parseTopic(String topic) throws ParseException {
-        List res = new ArrayList<Token>();
+        List<Token> res = new ArrayList<>();
         String[] splitted = topic.split("/");
 
         if (splitted.length == 0) {

File: broker/src/test/java/org/eclipse/moquette/spi/impl/subscriptions/SubscriptionsStoreTest.java
Patch:
@@ -46,7 +46,7 @@ public void setUp() throws IOException {
     
     @Test
     public void testParseTopic() throws ParseException {
-        List tokens = store.parseTopic("finance/stock/ibm");
+        List<Token> tokens = store.parseTopic("finance/stock/ibm");
         assertEqualsSeq(asArray("finance", "stock", "ibm"), tokens);
 
         tokens = store.parseTopic("/finance/stock/ibm");
@@ -63,7 +63,7 @@ public void testParseTopic() throws ParseException {
 
     @Test
     public void testParseTopicMultiValid() throws ParseException {
-        List tokens = store.parseTopic("finance/stock/#");
+        List<Token> tokens = store.parseTopic("finance/stock/#");
         assertEqualsSeq(asArray("finance", "stock", Token.MULTI), tokens);
 
         tokens = store.parseTopic("#");
@@ -82,7 +82,7 @@ public void testParseTopicMultiNotAferSeparatorNotValid() throws ParseException
 
     @Test
     public void testParseTopicSingleValid() throws ParseException {
-        List tokens = store.parseTopic("finance/stock/+");
+        List<Token> tokens = store.parseTopic("finance/stock/+");
         assertEqualsSeq(asArray("finance", "stock", Token.SINGLE), tokens);
 
         tokens = store.parseTopic("+");

File: netty_parser/src/main/java/org/eclipse/moquette/parser/netty/MQTTDecoder.java
Patch:
@@ -32,9 +32,9 @@
 public class MQTTDecoder extends ByteToMessageDecoder {
     
     //3 = 3.1, 4 = 3.1.1
-    static final AttributeKey<Integer> PROTOCOL_VERSION = new AttributeKey<Integer>("version");
+    static final AttributeKey<Integer> PROTOCOL_VERSION = AttributeKey.valueOf("version");
     
-    private final Map<Byte, DemuxDecoder> m_decoderMap = new HashMap<Byte, DemuxDecoder>();
+    private final Map<Byte, DemuxDecoder> m_decoderMap = new HashMap<>();
     
     public MQTTDecoder() {
        m_decoderMap.put(AbstractMessage.CONNECT, new ConnectDecoder());

File: broker/src/main/java/org/eclipse/moquette/spi/impl/MemoryStorageService.java
Patch:
@@ -94,7 +94,7 @@ public void storePublishForFuture(PublishEvent evt) {
 
     @Override
     public List<PublishEvent> retrievePersistedPublishes(String clientID) {
-        return m_persistentMessageStore.get(clientID);
+        return new ArrayList<>(m_persistentMessageStore.get(clientID));
     }
     
     @Override

File: broker/src/main/java/org/eclipse/moquette/spi/impl/ProtocolProcessor.java
Patch:
@@ -248,6 +248,7 @@ private void republishStored(String clientID) {
         for (PublishEvent pubEvt : publishedEvents) {
             sendPublish(pubEvt.getClientID(), pubEvt.getTopic(), pubEvt.getQos(),
                    pubEvt.getMessage(), false, pubEvt.getMessageID());
+            m_messagesStore.cleanPersistedPublishMessage(clientID, pubEvt.getMessageID());
         }
     }
     

File: broker/src/main/java/org/eclipse/moquette/spi/persistence/MapDBPersistentStore.java
Patch:
@@ -237,6 +237,7 @@ public void persistQoS2Message(String publishKey, PublishEvent evt) {
     }
 
     public void removeQoS2Message(String publishKey) {
+        LOG.debug("Removing stored Q0S2 message <{}>", publishKey);
         m_qos2Store.remove(publishKey);
     }
 

File: broker/src/main/java/org/eclipse/moquette/server/netty/NettyMQTTHandler.java
Patch:
@@ -79,7 +79,7 @@ public void channelRead(ChannelHandlerContext ctx, Object message) {
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         NettyChannel channel = m_channelMapper.get(ctx);
         String clientID = (String) channel.getAttribute(Constants.ATTR_CLIENTID);
-        m_messaging.lostConnection(clientID);
+        m_messaging.lostConnection(channel, clientID);
         ctx.close(/*false*/);
         synchronized(m_channelMapper) {
             m_channelMapper.remove(ctx);

File: broker/src/main/java/org/eclipse/moquette/spi/IMessaging.java
Patch:
@@ -30,7 +30,7 @@ public interface IMessaging {
 
     void stop();
 
-    void lostConnection(String clientID);
+    void lostConnection(ServerChannel session, String clientID);
 
     void handleProtocolMessage(ServerChannel session, AbstractMessage msg);
 }

File: broker/src/main/java/org/eclipse/moquette/spi/impl/SimpleMessaging.java
Patch:
@@ -107,8 +107,8 @@ private void disruptorPublish(MessagingEvent msgEvent) {
     }
     
     @Override
-    public void lostConnection(String clientID) {
-        disruptorPublish(new LostConnectionEvent(clientID));
+    public void lostConnection(ServerChannel session, String clientID) {
+        disruptorPublish(new LostConnectionEvent(session, clientID));
     }
 
     @Override
@@ -145,7 +145,7 @@ public void onEvent(ValueEvent t, long l, boolean bln) throws Exception {
         } 
         if (evt instanceof LostConnectionEvent) {
             LostConnectionEvent lostEvt = (LostConnectionEvent) evt;
-            m_processor.processConnectionLost(lostEvt.getClientID());
+            m_processor.processConnectionLost(lostEvt);
             return;
         }
         

File: broker/src/main/java/org/eclipse/moquette/server/netty/NettyAcceptor.java
Patch:
@@ -67,7 +67,7 @@ static class WebSocketFrameToByteBufDecoder extends MessageToMessageDecoder<Bina
         protected void decode(ChannelHandlerContext chc, BinaryWebSocketFrame frame, List<Object> out) throws Exception {
             //convert the frame to a ByteBuf
             ByteBuf bb = frame.content();
-            System.out.println("WebSocketFrameToByteBufDecoder decode - " + ByteBufUtil.hexDump(bb));
+            //System.out.println("WebSocketFrameToByteBufDecoder decode - " + ByteBufUtil.hexDump(bb));
             bb.retain();
             out.add(bb);
         }
@@ -79,7 +79,7 @@ static class ByteBufToWebSocketFrameEncoder extends MessageToMessageEncoder<Byte
         protected void encode(ChannelHandlerContext chc, ByteBuf bb, List<Object> out) throws Exception {
             //convert the ByteBuf to a WebSocketFrame
             BinaryWebSocketFrame result = new BinaryWebSocketFrame();
-            System.out.println("ByteBufToWebSocketFrameEncoder encode - " + ByteBufUtil.hexDump(bb));
+            //System.out.println("ByteBufToWebSocketFrameEncoder encode - " + ByteBufUtil.hexDump(bb));
             result.content().writeBytes(bb);
             out.add(result);
         }

File: broker/src/test/java/org/eclipse/moquette/spec/v3_1_1/connection/ConnectionIT.java
Patch:
@@ -13,7 +13,7 @@
  *
  * You may elect to redistribute this code under either of these licenses.
  */
-package org.eclipse.moquette.connection;
+package org.eclipse.moquette.spec.v3_1_1.connection;
 
 import java.io.IOException;
 

File: broker/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/AnnotationSupportTest.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author andrea
  */
-public class AnnotationSuportTest {
+public class AnnotationSupportTest {
     
     class SimplyAnnotatedFixture {
         

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/ConnAckDecoder.java
Patch:
@@ -16,7 +16,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         in.resetReaderIndex();
         //Common decoding part
         ConnAckMessage message = new ConnAckMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/ConnectDecoder.java
Patch:
@@ -46,7 +46,7 @@ void decode(AttributeMap ctx, ByteBuf in, List<Object> out) throws UnsupportedEn
         in.resetReaderIndex();
         //Common decoding part
         ConnectMessage message = new ConnectMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/DisconnectDecoder.java
Patch:
@@ -31,7 +31,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         //Common decoding part
         in.resetReaderIndex();
         DisconnectMessage message = new DisconnectMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/MessageIDDecoder.java
Patch:
@@ -33,7 +33,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         in.resetReaderIndex();
         //Common decoding part
         MessageIDMessage message = createMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/PingReqDecoder.java
Patch:
@@ -31,7 +31,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         //Common decoding part
         in.resetReaderIndex();
         PingReqMessage message = new PingReqMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/PingRespDecoder.java
Patch:
@@ -31,7 +31,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         //Common decoding part
         in.resetReaderIndex();
         PingRespMessage message = new PingRespMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/PubRelDecoder.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.util.AttributeMap;
 import java.io.UnsupportedEncodingException;
 import java.util.List;

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/SubAckDecoder.java
Patch:
@@ -32,7 +32,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         //Common decoding part
         in.resetReaderIndex();
         SubAckMessage message = new SubAckMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x00, in)) {
             in.resetReaderIndex();
             return;
         }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/SubscribeDecoder.java
Patch:
@@ -34,11 +34,10 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         //Common decoding part
         SubscribeMessage message = new SubscribeMessage();
         in.resetReaderIndex();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x02, in)) {
             in.resetReaderIndex();
             return;
         }
-        //TODO check reserved fixed flags = b0010
         
         //check qos level
         if (message.getQos() != QOSType.LEAST_ONE) {

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/UnsubscribeDecoder.java
Patch:
@@ -33,7 +33,7 @@ void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exce
         //Common decoding part
         in.resetReaderIndex();
         UnsubscribeMessage message = new UnsubscribeMessage();
-        if (!decodeCommonHeader(message, in)) {
+        if (!decodeCommonHeader(message, 0x02, in)) {
             in.resetReaderIndex();
             return;
         }

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/MemoryStorageService.java
Patch:
@@ -74,7 +74,8 @@ public void storePublishForFuture(PublishEvent evt) {
         m_persistentMessageStore.put(clientID, storedEvents);
     }
 
-    public List<PublishEvent> retrivePersistedPublishes(String clientID) {
+    @Override
+    public List<PublishEvent> retrievePersistedPublishes(String clientID) {
         return m_persistentMessageStore.get(clientID);
     }
     

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/ProtocolProcessor.java
Patch:
@@ -176,7 +176,7 @@ void processConnect(ServerChannel session, ConnectMessage msg) {
     
     private void republishStored(String clientID) {
         LOG.trace("republishStored invoked");
-        List<PublishEvent> publishedEvents = m_storageService.retrivePersistedPublishes(clientID);
+        List<PublishEvent> publishedEvents = m_storageService.retrievePersistedPublishes(clientID);
         if (publishedEvents == null) {
             LOG.info("No stored messages for client <{}>", clientID);
             return;
@@ -224,7 +224,7 @@ protected void processPublish(PublishEvent evt) {
             sendPubRec(evt.getClientID(), evt.getMessageID());
         }
 
-        //NB publish 2 subscribers for QoS 2 happen upon PUBREL from publsher
+        //NB publish to subscribers for QoS 2 happen upon PUBREL from publisher
         if (qos != AbstractMessage.QOSType.EXACTLY_ONCE) {
             publish2Subscribers(topic, qos, message, retain, evt.getMessageID());
         }
@@ -294,7 +294,7 @@ private void sendPublish(String clientId, String topic, AbstractMessage.QOSType
     }
     
     private void sendPublish(String clientId, String topic, AbstractMessage.QOSType qos, ByteBuffer message, boolean retained, int messageID) {
-        LOG.debug("sendPublish invoked clientId <{}> on topic <{}> QoS {} ratained {} messageID {}", clientId, topic, qos, retained, messageID);
+        LOG.debug("sendPublish invoked clientId <{}> on topic <{}> QoS {} retained {} messageID {}", clientId, topic, qos, retained, messageID);
         PublishMessage pubMessage = new PublishMessage();
         pubMessage.setRetainFlag(retained);
         pubMessage.setTopicName(topic);

File: broker/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/subscriptions/SubscriptionsStoreTest.java
Patch:
@@ -59,7 +59,7 @@ public void testSplitTopic() throws ParseException {
         assertEqualsSeq(asArray(Token.EMPTY, "finance", "stock", "ibm"), tokens);
 
         tokens = store.splitTopic("/");
-        assertEqualsSeq(asArray(Token.EMPTY), tokens);
+        assertEqualsSeq(asArray(Token.EMPTY, Token.EMPTY), tokens);
     }
 
 //    @Test(expected = ParseException.class)
@@ -295,10 +295,12 @@ public void testMatchTopics_multi() {
     public void testMatchTopics_single() {
         assertTrue(SubscriptionsStore.matchTopics("finance", "+"));
         assertTrue(SubscriptionsStore.matchTopics("finance/stock", "finance/+"));
+        assertFalse(SubscriptionsStore.matchTopics("finance", "finance/+"));
         assertTrue(SubscriptionsStore.matchTopics("/finance", "/+"));
         assertFalse(SubscriptionsStore.matchTopics("/finance", "+"));
         assertTrue(SubscriptionsStore.matchTopics("/finance", "+/+"));
         assertTrue(SubscriptionsStore.matchTopics("/finance/stock/ibm", "/finance/+/ibm"));
+        assertTrue(SubscriptionsStore.matchTopics("/", "+/+"));
         assertFalse(SubscriptionsStore.matchTopics("/finance/stock", "+"));
     }
     

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessaging.java
Patch:
@@ -188,8 +188,8 @@ private void processInit(Properties props) {
         subscriptions.init(m_storageService);
         
         String passwdPath = props.getProperty("password_file");
-        String configPath = System.getProperty("moquette.path", "");
-        IAuthenticator authenticator = new FileAuthenticator(configPath + passwdPath);
+        String configPath = System.getProperty("moquette.path", null);
+        IAuthenticator authenticator = new FileAuthenticator(configPath, passwdPath);
         
         m_processor.init(subscriptions, m_storageService, authenticator);
     }

File: broker/src/main/java/org/dna/mqtt/moquette/server/ConfigurationParser.java
Patch:
@@ -29,6 +29,7 @@ class ConfigurationParser {
     ConfigurationParser() {
         m_properties.put("port", Integer.toString(Constants.PORT));
         m_properties.put("host", Constants.HOST);
+        m_properties.put("password_file", "");
     }
     
     /**

File: broker/src/main/java/org/dna/mqtt/moquette/server/Server.java
Patch:
@@ -40,8 +40,8 @@ public void run() {
     public void startServer() throws IOException {
         ConfigurationParser confParser = new ConfigurationParser();
         try {
-            String configPath = System.getProperty("moquette.path", "");
-            confParser.parse(new File(configPath + "config/moquette.conf"));
+            String configPath = System.getProperty("moquette.path", null);
+            confParser.parse(new File(configPath, "config/moquette.conf"));
         } catch (ParseException pex) {
             LOG.warn("An error occured in parsing configuration, fallback on default configuration", pex);
         }

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessaging.java
Patch:
@@ -187,8 +187,9 @@ private void processInit(Properties props) {
 
         subscriptions.init(m_storageService);
         
-        String path = props.getProperty("password_file");
-        IAuthenticator authenticator = new FileAuthenticator(path);
+        String passwdPath = props.getProperty("password_file");
+        String configPath = System.getProperty("moquette.path", "");
+        IAuthenticator authenticator = new FileAuthenticator(configPath + passwdPath);
         
         m_processor.init(subscriptions, m_storageService, authenticator);
     }

File: broker/src/main/java/org/dna/mqtt/moquette/server/Server.java
Patch:
@@ -40,9 +40,10 @@ public void run() {
     public void startServer() throws IOException {
         ConfigurationParser confParser = new ConfigurationParser();
         try {
-            confParser.parse(new File("config/moquette.conf"));
+            String configPath = System.getProperty("moquette.path", "");
+            confParser.parse(new File(configPath + "config/moquette.conf"));
         } catch (ParseException pex) {
-            LOG.warn("An error occured in parsing configuration, fallback on deafult configuration", pex);
+            LOG.warn("An error occured in parsing configuration, fallback on default configuration", pex);
         }
         Properties configProps = confParser.getProperties();
         

File: broker/src/main/java/org/dna/mqtt/moquette/server/ConfigurationParser.java
Patch:
@@ -8,7 +8,6 @@
 import java.io.Reader;
 import java.text.ParseException;
 import java.util.Properties;
-import java.util.logging.Level;
 import org.dna.mqtt.commons.Constants;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: broker/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/ProtocolProcessorTest.java
Patch:
@@ -252,6 +252,7 @@ public List<Subscription> matches(String topic) {
         
         //Exercise
         ByteBuffer buffer = ByteBuffer.allocate(5).put("Hello".getBytes());
+        buffer.rewind();
         PublishEvent pubEvt = new PublishEvent(FAKE_TOPIC, AbstractMessage.QOSType.MOST_ONE, buffer, false, "FakeCLI", null);
         m_processor.processPublish(pubEvt);
 

File: broker/src/main/java/org/dna/mqtt/moquette/server/ServerAcceptor.java
Patch:
@@ -1,6 +1,7 @@
 package org.dna.mqtt.moquette.server;
 
 import java.io.IOException;
+import java.util.Properties;
 import org.dna.mqtt.moquette.messaging.spi.IMessaging;
 
 /**
@@ -9,7 +10,7 @@
  */
 public interface ServerAcceptor {
     
-    void initialize(IMessaging messaging) throws IOException;
+    void initialize(IMessaging messaging, Properties props) throws IOException;
     
     void close();
 }

File: parser_commons/src/main/java/org/dna/mqtt/commons/Constants.java
Patch:
@@ -5,5 +5,6 @@
  */
 public class Constants {
     public static final int PORT = 1883;
+    public static final String HOST = "0.0.0.0";
     public static final int DEFAULT_CONNECT_TIMEOUT = 10;
 }

File: broker/src/main/java/org/dna/mqtt/moquette/server/netty/MoquetteIdleTimoutHandler.java
Patch:
@@ -3,12 +3,13 @@
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.timeout.IdleState;
+import io.netty.handler.timeout.IdleStateEvent;
 
 class MoquetteIdleTimoutHandler extends ChannelDuplexHandler {
     @Override
     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
-        if (evt instanceof IdleState) {
-            IdleState e = (IdleState) evt;
+        if (evt instanceof IdleStateEvent) {
+            IdleState e = ((IdleStateEvent) evt).state();
             if (e == IdleState.ALL_IDLE) {
                 ctx.close();
             } /*else if (e.getState() == IdleState.WRITER_IDLE) {

File: broker/src/main/java/org/dna/mqtt/moquette/server/netty/NettyMQTTHandler.java
Patch:
@@ -52,7 +52,7 @@ public void channelRead(ChannelHandlerContext ctx, Object message) {
                     break;
                 case PINGREQ:
                     PingRespMessage pingResp = new PingRespMessage();
-                    ctx.write(pingResp);
+                    ctx.writeAndFlush(pingResp);
                     break;
             }
         } catch (Exception ex) {

File: broker/src/test/java/org/dna/mqtt/moquette/server/ServerIntegrationPahoTest.java
Patch:
@@ -315,7 +315,6 @@ private void publishFromAnotherClient(String topic, byte[] payload, int qos) thr
         anotherClient.disconnect();
     }
 
-    //BUG
     @Test
     public void testPublishWithQoS2() throws Exception {
         LOG.info("*** testPublishWithQoS2 ***");

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/ProtocolProcessor.java
Patch:
@@ -244,7 +244,7 @@ private void publish2Subscribers(String topic, AbstractMessage.QOSType qos, Byte
             LOG.debug("Broker republishing to client <{}> topic <{}> qos <{}>, active {}", 
                     sub.getClientId(), sub.getTopic(), qos, sub.isActive());
             
-            if (qos == AbstractMessage.QOSType.MOST_ONE) {
+            if (qos == AbstractMessage.QOSType.MOST_ONE && sub.isActive()) {
                 //QoS 0
                 sendPublish(sub.getClientId(), topic, qos, message, false);
             } else {

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -124,10 +124,10 @@ public void add(Subscription newSubscription) {
     public void removeSubscription(String topic, String clientID) {
         TreeNode matchNode = findMatchingNode(topic);
         
-        //search fr the subscription to remove
+        //search for the subscription to remove
         Subscription toBeRemoved = null;
         for (Subscription sub : matchNode.subscriptions()) {
-            if (sub.topic.equals(topic)) {
+            if (sub.topic.equals(topic) && sub.getClientId().equals(clientID)) {
                 toBeRemoved = sub;
                 break;
             }

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/ProtocolProcessor.java
Patch:
@@ -270,8 +270,8 @@ private void sendPublish(String clientId, String topic, AbstractMessage.QOSType
         pubMessage.setTopicName(topic);
         pubMessage.setQos(qos);
         pubMessage.setPayload(message);
-        LOG.info(String.format("send publish message to <%s> on topic <%s>, message is [%s]", 
-                clientId, topic, new String(message)));
+        
+        LOG.info(String.format("send publish message to <%s> on topic <%s>", clientId, topic));
         if (pubMessage.getQos() != AbstractMessage.QOSType.MOST_ONE) {
             pubMessage.setMessageID(messageID);
         }

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/events/PublishEvent.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage.QOSType;
 
-import java.io.Serializable;
 import java.nio.ByteBuffer;
 import org.dna.mqtt.moquette.proto.messages.PublishMessage;
 import org.dna.mqtt.moquette.server.ServerChannel;
@@ -11,7 +10,7 @@
  *
  * @author andrea
  */
-public class PublishEvent extends MessagingEvent implements Serializable {
+public class PublishEvent extends MessagingEvent {
     String m_topic;
     QOSType m_qos;
     //byte[] m_message;

File: broker/src/test/java/org/dna/mqtt/moquette/server/ServerIntegrationPahoTest.java
Patch:
@@ -306,6 +306,7 @@ private void publishFromAnotherClient(String topic, byte[] payload, int qos) thr
         anotherClient.disconnect();
     }
 
+    //BUG
     @Test
     public void testPublishWithQoS2() throws Exception {
         LOG.info("*** testPublishWithQoS2 ***");
@@ -324,6 +325,7 @@ public void testPublishWithQoS2() throws Exception {
         assertEquals(2, m_callback.getMessage().getQos());
     }
 
+    //BUG
     @Test
     public void testPublishReceiveWithQoS2() throws Exception {
         LOG.info("*** testPublishReceiveWithQoS2 ***");

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/subscriptions/TreeNode.java
Patch:
@@ -148,7 +148,7 @@ public void activate(String clientID) {
 
         //go deep
         for (TreeNode child : m_children) {
-            child.deactivate(clientID);
+            child.activate(clientID);
         }
 
     }

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/subscriptions/SubscriptionsStore.java
Patch:
@@ -79,7 +79,7 @@ public void init(IStorageService storageService) {
     
     protected void addDirect(Subscription newSubscription) {
         TreeNode current = findMatchingNode(newSubscription.topic);
-        current.addSubcription(newSubscription);
+        current.addSubscription(newSubscription);
     }
     
     private TreeNode findMatchingNode(String topic) {

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/subscriptions/TreeNode.java
Patch:
@@ -24,7 +24,7 @@ void setToken(Token topic) {
         this.m_token = topic;
     }
 
-    void addSubcription(Subscription s) {
+    void addSubscription(Subscription s) {
         //avoid double registering
         if (m_subscriptions.contains(s)) {
             return;
@@ -82,7 +82,7 @@ void matches(Queue<Token> tokens, List<Subscription> matchingSubs) {
 
         for (TreeNode n : m_children) {
             if (n.getToken().match(t)) {
-                //Create a copy of token, alse if navigate 2 sibling it
+                //Create a copy of token, else if navigate 2 sibling it
                 //consumes 2 elements on the queue instead of one
                 n.matches(new LinkedBlockingQueue<Token>(tokens), matchingSubs);
             }

File: netty_parser/src/main/java/org/dna/mqtt/moquette/parser/netty/PublishDecoder.java
Patch:
@@ -18,9 +18,9 @@ class PublishDecoder extends DemuxDecoder {
 
     @Override
     void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
-        LOG.debug("decode invoked with buffer " + in);
-        int startPos = in.readerIndex();
+        LOG.info("decode invoked with buffer " + in);
         in.resetReaderIndex();
+        int startPos = in.readerIndex();
 
         //Common decoding part
         PublishMessage message = new PublishMessage();

File: parser_commons/src/main/java/org/dna/mqtt/moquette/proto/messages/PubRecMessage.java
Patch:
@@ -7,4 +7,7 @@
  */
 public class PubRecMessage extends MessageIDMessage {
     
+    public PubRecMessage() {
+        m_messageType = AbstractMessage.PUBREC;
+    }
 }

File: parser_commons/src/main/java/org/dna/mqtt/moquette/proto/messages/SubscribeMessage.java
Patch:
@@ -31,6 +31,7 @@ public String getTopic() {
 
     public SubscribeMessage() {
         //Subscribe has always QoS 1
+        m_messageType = AbstractMessage.SUBSCRIBE;
         m_qos = AbstractMessage.QOSType.LEAST_ONE;
     }
     

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/ProtocolProcessor.java
Patch:
@@ -6,7 +6,6 @@
 import org.apache.mina.core.session.IdleStatus;
 import org.apache.mina.core.session.IoSession;
 import org.dna.mqtt.moquette.messaging.spi.IMatchingCondition;
-import org.dna.mqtt.moquette.messaging.spi.IMessaging;
 import org.dna.mqtt.moquette.messaging.spi.IStorageService;
 import org.dna.mqtt.moquette.messaging.spi.impl.events.PubAckEvent;
 import org.dna.mqtt.moquette.messaging.spi.impl.events.PublishEvent;

File: broker/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/ProtocolProcessorTest.java
Patch:
@@ -9,7 +9,6 @@
 import org.apache.mina.core.session.DummySession;
 import org.apache.mina.core.session.IoSession;
 import org.apache.mina.core.write.WriteRequest;
-import org.dna.mqtt.moquette.messaging.spi.IMessaging;
 import org.dna.mqtt.moquette.messaging.spi.IStorageService;
 import org.dna.mqtt.moquette.messaging.spi.impl.events.PublishEvent;
 import org.dna.mqtt.moquette.messaging.spi.impl.subscriptions.Subscription;
@@ -27,7 +26,6 @@
 import static org.junit.Assert.assertTrue;
 import org.junit.Before;
 import org.junit.Test;
-import static org.mockito.Mockito.*;
 
 /**
  *

File: broker/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessaging.java
Patch:
@@ -400,15 +400,15 @@ public boolean match(String key) {
         for (StoredMessage storedMsg : messages) {
             //fire the as retained the message
             LOG.debug("Inserting NotifyEvent into outbound for topic " + topic);
-            notify(new NotifyEvent(newSubscription.getClientId(), topic, storedMsg.getQos(), storedMsg.getPayload(), true));
+            notify(new NotifyEvent(newSubscription.getClientId(), storedMsg.getTopic(), storedMsg.getQos(), storedMsg.getPayload(), true));
         }
     }
 
     protected void processSubscribe(IoSession session, SubscribeMessage msg, String clientID, boolean cleanSession) {
         LOG.debug("processSubscribe invoked");
 
         for (SubscribeMessage.Couple req : msg.subscriptions()) {
-            QOSType qos = AbstractMessage.QOSType.fromByte(req.getQos());
+            QOSType qos = AbstractMessage.QOSType.values()[req.getQos()];
             Subscription newSubscription = new Subscription(clientID, req.getTopic(), qos, cleanSession);
             subscribeSingleTopic(newSubscription, req.getTopic());
         }

File: parser/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/subscriptions/SubscriptionsStoreTest.java
Patch:
@@ -7,9 +7,6 @@
 import java.util.List;
 
 import org.dna.mqtt.moquette.messaging.spi.impl.DummyStorageService;
-import org.dna.mqtt.moquette.messaging.spi.impl.subscriptions.SubscriptionsStore;
-import org.dna.mqtt.moquette.messaging.spi.impl.subscriptions.SubscriptionsStore.Token;
-import org.dna.mqtt.moquette.messaging.spi.impl.subscriptions.Subscription;
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage;
 import org.fusesource.hawtdb.api.MultiIndexFactory;
 import org.fusesource.hawtdb.api.PageFile;

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessaging.java
Patch:
@@ -402,7 +402,6 @@ protected void processSubscribe(IoSession session, SubscribeMessage msg, String
         //TODO by now it handles only QoS 0 messages
         for (int i = 0; i < msg.subscriptions().size(); i++) {
             ackMessage.addType(QOSType.MOST_ONE);
-            ackMessage.addType(QOSType.LEAST_ONE);
         }
         LOG.info("replying with SubAct to MSG ID " + msg.getMessageID());
         session.write(ackMessage);

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/HawtDBStorageService.java
Patch:
@@ -34,8 +34,7 @@ public class HawtDBStorageService implements IStorageService {
     //bind clientID+MsgID -> evt message published
     private SortedIndex<String, PublishEvent> m_inflightStore;
 
-    //persistent Map of clientID, list of Subscriptions
-    //TODO move to Set to avoid double subscriptions
+    //persistent Map of clientID, set of Subscriptions
     private SortedIndex<String, Set<Subscription>> m_persistentSubscriptions;
 
     public HawtDBStorageService() {

File: parser/src/main/java/org/dna/mqtt/moquette/server/MQTTHandler.java
Patch:
@@ -4,6 +4,7 @@
 import org.apache.mina.core.session.IdleStatus;
 import org.apache.mina.core.session.IoSession;
 import org.dna.mqtt.moquette.messaging.spi.IMessaging;
+import org.dna.mqtt.moquette.proto.Utils;
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -23,7 +24,7 @@ public class MQTTHandler extends IoHandlerAdapter {
     @Override
     public void messageReceived(IoSession session, Object message) throws Exception {
         AbstractMessage msg = (AbstractMessage) message;
-        LOG.info("Received a message of type {0}", msg.getMessageType());
+        LOG.info(String.format("Received a message of type %s", Utils.msgType2String(msg.getMessageType())));
         try {
             switch (msg.getMessageType()) {
                 case CONNECT:

File: parser/src/main/java/org/dna/mqtt/moquette/client/Client.java
Patch:
@@ -63,7 +63,7 @@ public final class Client {
     private int m_connectRetries = DEFAULT_RETRIES;
     private String m_hostname;
     private int m_port;
-    //internal mangement used for conversation with the server
+    //internal management used for conversation with the server
     private IoConnector m_connector;
     private IoSession m_session;
     private CountDownLatch m_connectBarrier;

File: parser/src/test/java/org/dna/mqtt/moquette/proto/PubAckDecoderTest.java
Patch:
@@ -38,7 +38,7 @@ public void testHeader() throws Exception {
         
         assertNotNull(m_mockProtoDecoder.getMessage());
         assertEquals(MessageDecoder.OK, res);
-        assertEquals(messageId, m_mockProtoDecoder.getMessage().getMessageID());
+        assertEquals(messageId, m_mockProtoDecoder.getMessage().getMessageID().intValue());
         assertEquals(AbstractMessage.PUBACK, m_mockProtoDecoder.getMessage().getMessageType());
     }
     

File: parser/src/test/java/org/dna/mqtt/moquette/proto/SubAckDecoderTest.java
Patch:
@@ -39,7 +39,7 @@ public void testBadQos() throws Exception {
 
         //Verify
         assertEquals(MessageDecoderResult.OK, res);
-        assertEquals(0xAABB, m_mockProtoDecoder.getMessage().getMessageID());
+        assertEquals(0xAABB, m_mockProtoDecoder.getMessage().getMessageID().intValue());
         List<QOSType> qoses = m_mockProtoDecoder.getMessage().types();
         assertEquals(3, qoses.size());
         assertEquals(QOSType.LEAST_ONE, qoses.get(0));
@@ -64,7 +64,7 @@ public void testBugBadRemainingCalculation() throws Exception {
         assertNotNull(m_mockProtoDecoder.getMessage());
         assertEquals(MessageDecoder.OK, res);
         SubAckMessage message = (SubAckMessage) m_mockProtoDecoder.getMessage();
-        assertEquals(0x0A, message.getMessageID());
+        assertEquals(0x0A, message.getMessageID().intValue());
         assertEquals(1, message.types().size());
         assertEquals(AbstractMessage.QOSType.LEAST_ONE, message.types().get(0));
     }

File: parser/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessagingTest.java
Patch:
@@ -57,7 +57,7 @@ public void testPublish() throws InterruptedException {
 //        messaging.setNotifier(notifier);
 
         //Exercise
-        PublishEvent pubEvt = new PublishEvent(FAKE_TOPIC, QOSType.MOST_ONE, "Hello".getBytes(), false);
+        PublishEvent pubEvt = new PublishEvent(FAKE_TOPIC, QOSType.MOST_ONE, "Hello".getBytes(), false, "FakeCLI");
         messaging.processPublish(pubEvt);
 
         //Verify

File: parser/src/test/java/org/dna/mqtt/moquette/server/MQTTHandlerTest.java
Patch:
@@ -86,7 +86,7 @@ public void testWill() {
         //Verify
         assertEquals(ConnAckMessage.CONNECTION_ACCEPTED, m_returnCode);
         verify(mockedMessaging).publish(eq("topic"), eq("Topic message".getBytes()), 
-                any(AbstractMessage.QOSType.class), anyBoolean());
+                any(AbstractMessage.QOSType.class), anyBoolean(), eq("123"));
     }
     
     

File: parser/src/test/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessagingTest.java
Patch:
@@ -4,13 +4,10 @@
 import org.dna.mqtt.moquette.messaging.spi.impl.events.PublishEvent;
 import org.dna.mqtt.moquette.messaging.spi.impl.events.SubscribeEvent;
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage.QOSType;
-import org.junit.After;
 import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.*;
 
 /**

File: parser/src/main/java/org/dna/mqtt/moquette/proto/MQTTLoggingFilter.java
Patch:
@@ -6,9 +6,9 @@
 import org.apache.mina.core.write.WriteRequest;
 import org.apache.mina.filter.logging.LogLevel;
 import org.apache.mina.filter.logging.LoggingFilter;
+import static org.dna.mqtt.moquette.proto.messages.AbstractMessage.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import static org.dna.mqtt.moquette.proto.messages.AbstractMessage.*;
 
 /**
  * Apache MINA logging filter that pretty prints the header of messages

File: parser/src/main/java/org/dna/mqtt/moquette/proto/PublishDecoder.java
Patch:
@@ -5,8 +5,8 @@
 import org.apache.mina.filter.codec.ProtocolDecoderOutput;
 import org.apache.mina.filter.codec.demux.MessageDecoderResult;
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage;
+import org.dna.mqtt.moquette.proto.messages.AbstractMessage.QOSType;
 import org.dna.mqtt.moquette.proto.messages.PublishMessage;
-import static org.dna.mqtt.moquette.proto.messages.AbstractMessage.*;
 
 /**
  *
@@ -20,7 +20,7 @@ public MessageDecoderResult decodable(IoSession session, IoBuffer in) {
 
     public MessageDecoderResult decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {
         int startPos = in.position();
-        
+
         //Common decoding part
         PublishMessage message = new PublishMessage();
         if (decodeCommonHeader(message, in) == NEED_DATA) {

File: parser/src/main/java/org/dna/mqtt/moquette/server/MQTTHandler.java
Patch:
@@ -228,6 +228,7 @@ public void notify(String clientId, String topic, QOSType qOSType, byte[] payloa
         pubMessage.setPayload(payload);
         assert m_clientIDs != null;
         assert m_clientIDs.get(clientId) != null;
+        LOG.debug("Session for clientId " + clientId + " is " + m_clientIDs.get(clientId).getSession());
         m_clientIDs.get(clientId).getSession().write(pubMessage);
     }
 }

File: parser/src/main/java/org/dna/mqtt/moquette/proto/UnsubscribeEncoder.java
Patch:
@@ -35,7 +35,7 @@ public void encode(IoSession session, UnsubscribeMessage message, ProtocolEncode
         IoBuffer buff = IoBuffer.allocate(2 + variableHeaderSize);
 
         buff.put((byte) (AbstractMessage.UNSUBSCRIBE << 4 | flags));
-        buff.put(Utils.encodeRemainingLength(2 + variableHeaderSize));
+        buff.put(Utils.encodeRemainingLength(variableHeaderSize));
         buff.put(variableHeaderBuff).flip();
 
         out.write(buff);

File: parser/src/test/java/org/dna/mqtt/moquette/proto/UnsubscribeEncoderTest.java
Patch:
@@ -38,7 +38,8 @@ public void testEncodeWithSingleTopic() throws Exception {
         
         //Verify
         assertEquals((byte)0xA2, (byte)m_mockProtoEncoder.getBuffer().get()); //1 byte
-        assertEquals(12, m_mockProtoEncoder.getBuffer().get()); //remaining length
+        //2 messageID + 2 length + 6 chars = 10
+        assertEquals(10, m_mockProtoEncoder.getBuffer().get()); //remaining length
         
         //verify M1ssageID
         assertEquals((byte)0xAA, m_mockProtoEncoder.getBuffer().get());
@@ -64,7 +65,7 @@ public void testEncodeWithMultiTopic() throws Exception {
 
         //Verify
         assertEquals((byte)0xA2, (byte)m_mockProtoEncoder.getBuffer().get()); //1 byte
-        assertEquals(16, m_mockProtoEncoder.getBuffer().get()); //remaining length
+        assertEquals(14, m_mockProtoEncoder.getBuffer().get()); //remaining length
         
         //verify M1ssageID
         assertEquals((byte)0xAA, m_mockProtoEncoder.getBuffer().get());

File: parser/src/main/java/org/dna/mqtt/moquette/proto/UnsubscribeEncoder.java
Patch:
@@ -32,10 +32,10 @@ public void encode(IoSession session, UnsubscribeMessage message, ProtocolEncode
         variableHeaderBuff.flip();
         int variableHeaderSize = variableHeaderBuff.remaining();
         byte flags = Utils.encodeFlags(message);
-        IoBuffer buff = IoBuffer.allocate(4 + variableHeaderSize);
+        IoBuffer buff = IoBuffer.allocate(2 + variableHeaderSize);
 
         buff.put((byte) (AbstractMessage.UNSUBSCRIBE << 4 | flags));
-        buff.put(Utils.encodeRemainingLength(4 + variableHeaderSize));
+        buff.put(Utils.encodeRemainingLength(2 + variableHeaderSize));
         buff.put(variableHeaderBuff).flip();
 
         out.write(buff);

File: parser/src/main/java/org/dna/mqtt/moquette/client/ClientMQTTHandler.java
Patch:
@@ -51,7 +51,7 @@ private void handleConnectAck(IoSession session, ConnAckMessage connAckMessage)
     }
 
     private void handleSubscribeAck(IoSession session, SubAckMessage subAckMessage) {
-        m_callback.subscribeAckCallback();
+        m_callback.subscribeAckCallback(subAckMessage.getMessageID());
     }
     
     private void handlePublish(IoSession session, PublishMessage pubMessage) {

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SubscriptionsStore.java
Patch:
@@ -1,6 +1,5 @@
 package org.dna.mqtt.moquette.messaging.spi.impl;
 
-import java.io.IOException;
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.List;
@@ -16,7 +15,7 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Represents a tree of published topics
+ * Represents a tree of topics subscriptions.
  *
  * @author andrea
  */

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessaging.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.io.Serializable;
 import java.text.ParseException;
 import java.util.List;
 import java.util.Map;
@@ -28,7 +29,7 @@
  */
 public class SimpleMessaging implements IMessaging {
     
-    private static class StoredMessage {
+    private static class StoredMessage implements Serializable {
         QOSType m_qos;
         byte[] m_payload;
 

File: parser/src/test/java/org/dna/mqtt/moquette/proto/TestUtils.java
Patch:
@@ -1,14 +1,13 @@
 package org.dna.mqtt.moquette.proto;
 
-import org.dna.mqtt.moquette.proto.Utils;
-import org.dna.mqtt.moquette.proto.messages.AbstractMessage;
 import java.io.UnsupportedEncodingException;
 import org.apache.mina.core.buffer.IoBuffer;
 import org.apache.mina.core.filterchain.IoFilter.NextFilter;
 import org.apache.mina.core.future.WriteFuture;
 import org.apache.mina.core.session.IoSession;
 import org.apache.mina.filter.codec.ProtocolDecoderOutput;
 import org.apache.mina.filter.codec.ProtocolEncoderOutput;
+import org.dna.mqtt.moquette.proto.messages.AbstractMessage;
 import static org.junit.Assert.*;
 
 /**

File: parser/src/main/java/org/dna/mqtt/moquette/client/IPublishCallback.java
Patch:
@@ -6,5 +6,5 @@
  */
 public interface IPublishCallback {
 
-    void published(String topic, byte[] message);
+    void published(String topic, byte[] message/*, boolean retained*/);
 }

File: parser/src/main/java/org/dna/mqtt/moquette/server/MQTTHandler.java
Patch:
@@ -199,8 +199,9 @@ public void setAuthenticator(IAuthenticator authenticator) {
         m_authenticator = authenticator;
     }
 
-    public void notify(String clientId, String topic, QOSType qOSType, byte[] payload) {
+    public void notify(String clientId, String topic, QOSType qOSType, byte[] payload, boolean retained) {
         PublishMessage pubMessage = new PublishMessage();
+        pubMessage.setRetainFlag(retained);
         pubMessage.setTopicName(topic);
         pubMessage.setQos(qOSType);
         pubMessage.setPayload(payload);

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/IMessaging.java
Patch:
@@ -27,4 +27,6 @@ public interface IMessaging {
      * was subscribed
      */
     void removeSubscriptions(String clientID);
+    
+    void close();
 }

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/Subscription.java
Patch:
@@ -1,5 +1,6 @@
 package org.dna.mqtt.moquette.messaging.spi.impl;
 
+import java.io.Serializable;
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage.QOSType;
 
 /**
@@ -9,7 +10,7 @@
  * 
  * @author andrea
  */
-public class Subscription {
+public class Subscription implements Serializable {
     
     QOSType requestedQos;
     String clientId;

File: parser/src/test/java/org/dna/mqtt/moquette/server/ServerIntegrationTest.java
Patch:
@@ -37,6 +37,7 @@ public void tearDown() {
     public void testSubscribe() throws IOException, InterruptedException {
 //        startServer();
         Client client = new Client("localhost", Server.PORT);
+//        Client client = new Client("test.mosquitto.org", 1883);
         client.connect();
         
         
@@ -49,10 +50,8 @@ public void published(String topic, byte[] message) {
         
         client.publish("/topic", "Test my payload".getBytes());
         
-        
         client.close();
         
-        
         assertTrue(received);
     }
     

File: parser/src/test/java/org/dna/mqtt/moquette/proto/UnsubscribeEncoderTest.java
Patch:
@@ -41,7 +41,7 @@ public void testEncodeWithMultiTopic() throws Exception {
 
         //Verify
         assertEquals((byte)0x82, (byte)m_mockProtoEncoder.getBuffer().get()); //1 byte
-        assertEquals(20, m_mockProtoEncoder.getBuffer().get()); //remaining length
+        assertEquals(16, m_mockProtoEncoder.getBuffer().get()); //remaining length
         
         //verify M1ssageID
         assertEquals((byte)0xAA, m_mockProtoEncoder.getBuffer().get());

File: parser/src/main/java/org/dna/mqtt/moquette/messaging/spi/impl/SimpleMessaging.java
Patch:
@@ -45,6 +45,7 @@ public void subscribe(String clientId, String topic, QOSType qos) {
         Subscription newSubscription = new Subscription(clientId, topic, qos);
         rwLock.writeLock().lock();
         if (subscriptions.contains(newSubscription)) {
+            rwLock.writeLock().unlock();
             return;
         }
         subscriptions.add(newSubscription);

File: parser/src/main/java/org/dna/mqtt/moquette/proto/SubAckDecoder.java
Patch:
@@ -29,9 +29,10 @@ public MessageDecoderResult decode(IoSession session, IoBuffer in, ProtocolDecod
         
         //MessageID
         message.setMessageID(Utils.readWord(in));
+        remainingLength -= 2;
         
         //Qos array
-        if (in.remaining() < remainingLength) {
+        if (in.remaining() < remainingLength ) {
             return NEED_DATA;
         }
         for (int i = 0; i < remainingLength; i++) {

File: parser/src/test/java/org/dna/mqtt/moquette/proto/PublishDecoderTest.java
Patch:
@@ -85,7 +85,6 @@ public void testHeaderWithMessageID_Payload() throws Exception {
     
      @Test
      public void testBugOnRealCase() throws Exception {
-      //msg hex = 30:1b:00:06:2f:74:6f:70:69:63:54:65:73:74:20:6d:79:20:70:61:79:6c:6f:61:64
          byte[] overallMessage = new byte[] {0x30, 0x17, //fixed header, 25 byte lenght
              0x00, 0x06, 0x2f, 0x74, 0x6f, 0x70, 0x69, 0x63, //[/topic] string 2 len + 6 content
              0x54, 0x65, 0x73, 0x74, 0x20, 0x6d, 0x79, // [Test my payload] encoding

File: parser/src/main/java/org/dna/mqtt/moquette/proto/SubscribeEncoder.java
Patch:
@@ -34,10 +34,10 @@ public void encode(IoSession session, SubscribeMessage message, ProtocolEncoderO
         variableHeaderBuff.flip();
         int variableHeaderSize = variableHeaderBuff.remaining();
         byte flags = Utils.encodeFlags(message);
-        IoBuffer buff = IoBuffer.allocate(4 + variableHeaderSize);
+        IoBuffer buff = IoBuffer.allocate(2 + variableHeaderSize);
 
         buff.put((byte) (AbstractMessage.SUBSCRIBE << 4 | flags));
-        buff.put(Utils.encodeRemainingLength(4 + variableHeaderSize));
+        buff.put(Utils.encodeRemainingLength(variableHeaderSize));
         buff.put(variableHeaderBuff).flip();
 
         out.write(buff);

File: parser/src/main/java/org/dna/mqtt/moquette/proto/PublishEncoder.java
Patch:
@@ -37,9 +37,9 @@ public void encode(IoSession session, PublishMessage message, ProtocolEncoderOut
         
         byte flags = Utils.encodeFlags(message);
         
-        IoBuffer buff = IoBuffer.allocate(4 + variableHeaderSize);
+        IoBuffer buff = IoBuffer.allocate(2 + variableHeaderSize);
         buff.put((byte) (AbstractMessage.PUBLISH << 4 | flags));
-        buff.put(Utils.encodeRemainingLength(4 + variableHeaderSize));
+        buff.put(Utils.encodeRemainingLength(variableHeaderSize));
         buff.put(variableHeaderBuff).flip();
 
         out.write(buff);

File: parser/src/main/java/org/dna/mqtt/moquette/server/Server.java
Patch:
@@ -12,6 +12,7 @@
 import org.dna.mqtt.moquette.proto.ConnAckEncoder;
 import org.dna.mqtt.moquette.proto.ConnectDecoder;
 import org.dna.mqtt.moquette.proto.DisconnectDecoder;
+import org.dna.mqtt.moquette.proto.PublishDecoder;
 import org.dna.mqtt.moquette.proto.messages.ConnAckMessage;
 /**
  * Launch a  configured version of the server.
@@ -32,6 +33,7 @@ public static void main(String[] args) throws IOException {
     protected void startServer() throws IOException {
         DemuxingProtocolDecoder decoder = new DemuxingProtocolDecoder();
         decoder.addMessageDecoder(new ConnectDecoder());
+        decoder.addMessageDecoder(new PublishDecoder());
         decoder.addMessageDecoder(new DisconnectDecoder());
         
         DemuxingProtocolEncoder encoder = new DemuxingProtocolEncoder();

File: parser/src/test/java/org/dna/mqtt/moquette/server/ServerIntegrationTest.java
Patch:
@@ -23,7 +23,7 @@ public void testSubscribe() throws IOException, InterruptedException {
         Client client = new Client("localhost", Server.PORT);
         client.connect();
         
-//        client.publish("/topic", "Test my payload".getBytes());
+        client.publish("/topic", "Test my payload".getBytes());
         //TODO client.subscribe("/topic", callback)
         
         client.close();

File: parser/src/main/java/org/dna/mqtt/moquette/client/Client.java
Patch:
@@ -115,7 +115,7 @@ public void connect() throws MQTTException {
         //suspend until the server respond with CONN_ACK
         boolean unlocked = false; 
         try {
-            unlocked = m_connectBarrier.await(1000, TimeUnit.MILLISECONDS); //TODO parametrize
+            unlocked = m_connectBarrier.await(CONNECT_TIMEOUT, TimeUnit.MILLISECONDS); //TODO parametrize
         } catch (InterruptedException ex) {
             throw new ConnectionException(ex);
         }
@@ -179,6 +179,7 @@ public void publish(String topic, byte[] payload) throws PublishException{
      *  TODO extract this SPI method in a SPI
      */
     protected void connectionAckCallback(byte returnCode) {
+        LOG.info("connectionAckCallback invoked");
         m_returnCode = returnCode;
         m_connectBarrier.countDown();
     }

File: parser/src/main/java/org/dna/mqtt/moquette/client/ClientMQTTHandler.java
Patch:
@@ -4,8 +4,8 @@
 import org.apache.mina.core.service.IoHandlerAdapter;
 import org.apache.mina.core.session.IoSession;
 import org.dna.mqtt.moquette.proto.messages.AbstractMessage;
-import org.dna.mqtt.moquette.proto.messages.ConnAckMessage;
 import static org.dna.mqtt.moquette.proto.messages.AbstractMessage.*;
+import org.dna.mqtt.moquette.proto.messages.ConnAckMessage;
 
 /**
  *
@@ -28,7 +28,7 @@ public void messageReceived(IoSession session, Object message) throws Exception
         switch (msg.getMessageType()) {
             case CONNACK:
                 handleConnectAck(session, (ConnAckMessage) msg);
-        break;
+                break;
 //            case SUBSCRIBE:
 //                handleSubscribe(session, (SubscribeMessage) msg);
 //        break;

File: parser/src/main/java/org/dna/mqtt/moquette/server/Server.java
Patch:
@@ -8,10 +8,10 @@
 import org.apache.mina.filter.codec.ProtocolCodecFilter;
 import org.apache.mina.filter.codec.demux.DemuxingProtocolDecoder;
 import org.apache.mina.filter.codec.demux.DemuxingProtocolEncoder;
-import org.apache.mina.filter.logging.LoggingFilter;
 import org.apache.mina.transport.socket.nio.NioSocketAcceptor;
 import org.dna.mqtt.moquette.proto.ConnAckEncoder;
 import org.dna.mqtt.moquette.proto.ConnectDecoder;
+import org.dna.mqtt.moquette.proto.DisconnectDecoder;
 import org.dna.mqtt.moquette.proto.messages.ConnAckMessage;
 /**
  * Launch a  configured version of the server.
@@ -32,14 +32,15 @@ public static void main(String[] args) throws IOException {
     protected void startServer() throws IOException {
         DemuxingProtocolDecoder decoder = new DemuxingProtocolDecoder();
         decoder.addMessageDecoder(new ConnectDecoder());
+        decoder.addMessageDecoder(new DisconnectDecoder());
         
         DemuxingProtocolEncoder encoder = new DemuxingProtocolEncoder();
 //        encoder.addMessageEncoder(ConnectMessage.class, new ConnectEncoder());
         encoder.addMessageEncoder(ConnAckMessage.class, new ConnAckEncoder());
         
         IoAcceptor acceptor = new NioSocketAcceptor();
 
-        acceptor.getFilterChain().addLast( "logger", new LoggingFilter() );
+//        acceptor.getFilterChain().addLast( "logger", new LoggingFilter("SERVER LOG") );
         acceptor.getFilterChain().addLast( "codec", new ProtocolCodecFilter(encoder, decoder));
 
         acceptor.setHandler( new MQTTHandler() );

File: parser/src/test/java/org/dna/mqtt/moquette/server/ServerIntegrationTest.java
Patch:
@@ -23,7 +23,7 @@ public void testSubscribe() throws IOException, InterruptedException {
         Client client = new Client("localhost", Server.PORT);
         client.connect();
         
-        client.publish("/topic", "Test my payload".getBytes());
+//        client.publish("/topic", "Test my payload".getBytes());
         //TODO client.subscribe("/topic", callback)
         
         client.close();

File: parser/src/main/java/org/dna/mqtt/moquette/proto/MqttDecoder.java
Patch:
@@ -18,7 +18,7 @@ protected MessageDecoderResult decodeCommonHeader(AbstractMessage message, IoBuf
             return NEED_DATA;
         }
         byte h1 = in.get();
-        byte messageType = (byte) ((h1 & 0x0010) >> 4);
+        byte messageType = (byte) ((h1 & 0x00F0) >> 4);
         boolean dupFlag = ((byte) ((h1 & 0x0008) >> 3) == 1);
         byte qosLevel = (byte) ((h1 & 0x0006) >> 1);
         boolean retainFlag = ((byte) (h1 & 0x0001) == 1);

File: parser/src/main/java/org/dna/mqtt/moquette/proto/Utils.java
Patch:
@@ -92,7 +92,7 @@ static MessageDecoderResult checkDecodable(byte type, IoBuffer in) {
     }
     
     /**
-     * Return the IoBuffer with string ancoded as MSB, LSB and UTF-8 encoded
+     * Return the IoBuffer with string encoded as MSB, LSB and UTF-8 encoded
      * string content.
      */
     static IoBuffer encodeString(String str) {

